<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="4475ebb24c0e359de01708bc1d247a728f337715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exeflags&lt;/code&gt; should be set to the required command line arguments for new workers.</source>
          <target state="translated">&lt;code&gt;exeflags&lt;/code&gt; должны быть установлены необходимые аргументы командной строки для новых рабочих процессов .</target>
        </trans-unit>
        <trans-unit id="05f09246b7fa073a7f1026d572e6e088740c6e5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exeflags&lt;/code&gt;: additional flags passed to the worker processes.</source>
          <target state="translated">&lt;code&gt;exeflags&lt;/code&gt; : дополнительные флаги, передаваемые рабочим процессам.</target>
        </trans-unit>
        <trans-unit id="3e8963f41f3051e232c8d5de842f5be607191c3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt; &amp;ndash; the path to the Julia executable on the host, defaults to &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; or &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; - путь к исполняемому файлу Julia на хосте, по умолчанию &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; или &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbecc18bae8e3704699c9ddb2d2f6ee8f7947be3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt; is the name of the &lt;code&gt;julia&lt;/code&gt; executable including the full path.</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; - это имя исполняемого файла &lt;code&gt;julia&lt;/code&gt; , включая полный путь.</target>
        </trans-unit>
        <trans-unit id="9e9777b51b1141d2eaeeb8767f03f02a288a8ebb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt;: name of the &lt;code&gt;julia&lt;/code&gt; executable. Defaults to &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; or &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt; as the case may be.</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; : имя исполняемого файла &lt;code&gt;julia&lt;/code&gt; . По умолчанию используется &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; или &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt; в зависимости от обстоятельств.</target>
        </trans-unit>
        <trans-unit id="b6dc7570f94249d865b09eb2a692da386f794499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; is used within modules to tell Julia which functions should be made available to the user. For example: &lt;code&gt;export foo&lt;/code&gt; makes the name &lt;code&gt;foo&lt;/code&gt; available when &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; the module. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d0445c62c1b3939fafe7b40795814fcba18b16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; is used within modules to tell Julia which functions should be made available to the user. For example: &lt;code&gt;export foo&lt;/code&gt; makes the name &lt;code&gt;foo&lt;/code&gt; available when &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; the module. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; используется в модулях, чтобы сообщить Джулии, какие функции должны быть доступны пользователю. Например: &lt;code&gt;export foo&lt;/code&gt; делает имя &lt;code&gt;foo&lt;/code&gt; доступным при &lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; модуля. См. Подробности в &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;разделе руководства о модулях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6574aff1f598d8da6d01cfe7e24524b2c0a7bd1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a7471ee53c91775ff9ce42d242abe595bcfc7dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x)&lt;/code&gt; can be any call expression. Returns the result of &lt;code&gt;f(x)&lt;/code&gt; if the types match, and an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it finds different types.</source>
          <target state="translated">&lt;code&gt;f(x)&lt;/code&gt; может быть любым выражением вызова. Возвращает результат &lt;code&gt;f(x)&lt;/code&gt; , если типы совпадают, то и &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; , если он находит различные типы.</target>
        </trans-unit>
        <trans-unit id="d0b49364119f011655f3a8d05e365aee509c9dd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must not cause a task switch, which excludes most I/O operations such as &lt;code&gt;println&lt;/code&gt;. Using the &lt;code&gt;@async&lt;/code&gt; macro (to defer context switching to outside of the finalizer) or &lt;code&gt;ccall&lt;/code&gt; to directly invoke IO functions in C may be helpful for debugging purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="497f30aa399e54f4d4675a55c3eafb38181ea62b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;factors&lt;/code&gt; is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix.</source>
          <target state="translated">&lt;code&gt;factors&lt;/code&gt; - это матрица размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17c27552004d64395046d29795efee05dcc044c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;factors&lt;/code&gt;, as in the &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt; type, is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix.</source>
          <target state="translated">&lt;code&gt;factors&lt;/code&gt; , как и в типе &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt; &lt;code&gt;QR&lt;/code&gt; &lt;/a&gt; , представляют собой матрицу размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d807df0dedd6adab6f030655307f5490121a67cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (0)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; (0)</target>
        </trans-unit>
        <trans-unit id="7c323dd694e4baf6f9a2d099639446439f70e26f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fastforward::Bool=false&lt;/code&gt;: If &lt;code&gt;fastforward&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return &lt;code&gt;false&lt;/code&gt;. This is equivalent to the git CLI option &lt;code&gt;--ff-only&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fastforward::Bool=false&lt;/code&gt; : если &lt;code&gt;fastforward&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , выполнять слияние только в том случае, если слияние является быстрой перемоткой вперед (текущая глава ветки является предком коммитов, подлежащих слиянию), в противном случае отказываться от слияния и возвращать &lt;code&gt;false&lt;/code&gt; . Это эквивалентно опции git CLI &lt;code&gt;--ff-only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87c543b2d8b2065a2e5dc452819e6c3f937251e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch&lt;/code&gt; can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; можно рассматривать как явную операцию перемещения данных, поскольку она напрямую запрашивает перемещение объекта на локальную машину. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; (и несколько связанных конструкций) также перемещает данные, но это не так очевидно, поэтому его можно назвать операцией неявного перемещения данных. Рассмотрим эти два подхода к построению и возведению в квадрат случайной матрицы:</target>
        </trans-unit>
        <trans-unit id="441aed98e0f65cd26d43e6c836d252a8cc6789ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch&lt;/code&gt; can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f304481efd9961734ed02019c52b7f122e9caadf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch_opts&lt;/code&gt;: The options for performing the pre-checkout fetch of the remote as part of the clone.</source>
          <target state="translated">&lt;code&gt;fetch_opts&lt;/code&gt; : параметры для выполнения выборки перед оформлением заказа на удаленном компьютере как части клона.</target>
        </trans-unit>
        <trans-unit id="b6fd3b698a115341e458d38e2ec7ad39b99bd28b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_favor&lt;/code&gt;: how to handle conflicting file contents for the &lt;code&gt;text&lt;/code&gt; driver.</source>
          <target state="translated">&lt;code&gt;file_favor&lt;/code&gt; : как обрабатывать конфликтующее содержимое файла для &lt;code&gt;text&lt;/code&gt; драйвера.</target>
        </trans-unit>
        <trans-unit id="4de1b4ec1dbc92d77323db107114a2663e47b3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_flags&lt;/code&gt;: guidelines for merging files.</source>
          <target state="translated">&lt;code&gt;file_flags&lt;/code&gt; : рекомендации по слиянию файлов.</target>
        </trans-unit>
        <trans-unit id="3fbf2559a3914fd50a580c62f1bf3a524a1b31f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_mode&lt;/code&gt;: read/write/access mode for any files involved in the checkout. Default is &lt;code&gt;0755&lt;/code&gt; or &lt;code&gt;0644&lt;/code&gt;, depending on the blob.</source>
          <target state="translated">&lt;code&gt;file_mode&lt;/code&gt; : режим чтения / записи / доступа для любых файлов, участвующих в оформлении заказа. По умолчанию &lt;code&gt;0755&lt;/code&gt; или &lt;code&gt;0644&lt;/code&gt; , в зависимости от большого двоичного объекта.</target>
        </trans-unit>
        <trans-unit id="2c42aacc63e30d4330883c95cf718c8560278f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_open_flags&lt;/code&gt;: bitflags used to open any files during the checkout.</source>
          <target state="translated">&lt;code&gt;file_open_flags&lt;/code&gt; : битовые флаги, используемые для открытия любых файлов во время оформления заказа.</target>
        </trans-unit>
        <trans-unit id="5a0fc1d82d9beeb03810443c1cef5731061c18c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED]))&lt;/code&gt;, and it sets options for the diff. The default is to show files added, modified, or deleted.</source>
          <target state="translated">&lt;code&gt;filter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED]))&lt;/code&gt; , и он устанавливает параметры для diff. По умолчанию отображаются добавленные, измененные или удаленные файлы.</target>
        </trans-unit>
        <trans-unit id="f1902a68a69fa5a2286af83a34ec192b45a3e6c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; Clauses</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; статьи</target>
        </trans-unit>
        <trans-unit id="705dcca1f483b5f410a7d024bf9ea5567a98d882" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a246350d082e2ecf351fc1a6227a9daf36f33939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findnext(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; such that &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; and &lt;code&gt;i &amp;lt;= start&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if unmatched.</source>
          <target state="translated">&lt;code&gt;findnext(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; такая, что &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; и &lt;code&gt;i &amp;lt;= start&lt;/code&gt; , или &lt;code&gt;nothing&lt;/code&gt; если не совпадают.</target>
        </trans-unit>
        <trans-unit id="07de775ab3ffe3db837f89e66ab75d6248ad4f16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findprev(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; such that &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; and &lt;code&gt;stop &amp;lt;= i&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if unmatched.</source>
          <target state="translated">&lt;code&gt;findprev(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; , чтобы &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; и &lt;code&gt;stop &amp;lt;= i&lt;/code&gt; , или &lt;code&gt;nothing&lt;/code&gt; если не совпадают.</target>
        </trans-unit>
        <trans-unit id="6132598e6b7a6f7dbd326bd4b30b37bdb5c4535d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: Flags for the delta and the objects on each side. Determines whether to treat the file(s) as binary/text, whether they exist on each side of the diff, and whether the object ids are known to be correct.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : Флаги для дельты и объектов с каждой стороны. Определяет, следует ли рассматривать файл (ы) как двоичный / текстовый, существуют ли они с каждой стороны различия и известны ли идентификаторы объектов правильными.</target>
        </trans-unit>
        <trans-unit id="08dfea97d21ddfc07bbc16a2205aa96d1c822a29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: a combination of the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_flag_t&quot;&gt;&lt;code&gt;git_diff_flag_t&lt;/code&gt;&lt;/a&gt; flags. The &lt;code&gt;i&lt;/code&gt;th bit of this integer sets the &lt;code&gt;i&lt;/code&gt;th flag.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : комбинация флагов &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_flag_t&quot;&gt; &lt;code&gt;git_diff_flag_t&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;i&lt;/code&gt; й бит этого целого устанавливает &lt;code&gt;i&lt;/code&gt; го флага.</target>
        </trans-unit>
        <trans-unit id="6a3f46c8ead4a96fd5e9f1735c77e01ac2e9df4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: an &lt;code&gt;enum&lt;/code&gt; for flags describing merge behavior. Defined in &lt;a href=&quot;https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h#L95&quot;&gt;&lt;code&gt;git_merge_flag_t&lt;/code&gt;&lt;/a&gt;. The corresponding Julia enum is &lt;code&gt;GIT_MERGE&lt;/code&gt; and has values:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : &lt;code&gt;enum&lt;/code&gt; для флагов, описывающих поведение слияния. Определено в &lt;a href=&quot;https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h#L95&quot;&gt; &lt;code&gt;git_merge_flag_t&lt;/code&gt; &lt;/a&gt; . Соответствующее перечисление Julia - &lt;code&gt;GIT_MERGE&lt;/code&gt; и имеет значения:</target>
        </trans-unit>
        <trans-unit id="c7ad69674a910f1a345e02b973a2e9f13be3f925" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: flags controlling which files will appear in the diff. Defaults to &lt;code&gt;DIFF_NORMAL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : флаги, управляющие тем, какие файлы будут отображаться в diff. По умолчанию &lt;code&gt;DIFF_NORMAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac96c3420fc47ecbae6d81e79e8646bf681816a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: flags for controlling any callbacks used in a status call.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : флаги для управления любыми обратными вызовами, используемыми в вызове статуса.</target>
        </trans-unit>
        <trans-unit id="0f514fc00776f1753b3aa88448a24342da8ef48c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: one of &lt;code&gt;Consts.BLAME_NORMAL&lt;/code&gt; or &lt;code&gt;Consts.BLAME_FIRST_PARENT&lt;/code&gt; (the other blame flags are not yet implemented by libgit2).</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : один из &lt;code&gt;Consts.BLAME_NORMAL&lt;/code&gt; или &lt;code&gt;Consts.BLAME_FIRST_PARENT&lt;/code&gt; (другие флаги обвинения еще не реализованы в libgit2).</target>
        </trans-unit>
        <trans-unit id="e302baefdbfe650eed3e3989e00d95ff24420d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;floor(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;floor(T, x)&lt;/code&gt; преобразует результат в тип &lt;code&gt;T&lt;/code&gt; , выбрасывая &lt;code&gt;InexactError&lt;/code&gt; , если значение не представляется возможным.</target>
        </trans-unit>
        <trans-unit id="83862f9f9b336e858b86ef3cce875e4b50041164" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;floor(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; that is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;floor(x)&lt;/code&gt; возвращает ближайшее целое значение того же типа, что и &lt;code&gt;x&lt;/code&gt; , которое меньше или равно &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="555deaa32601a989d7598bcb2f199e104d3181cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt; loops repeatedly evaluate a block of statements while iterating over a sequence of values.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; Циклы for многократно оценивают блок операторов, перебирая последовательность значений.</target>
        </trans-unit>
        <trans-unit id="ffc0eadc34c155040e86b2da693e68d65e15d861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;while&lt;/code&gt; loops, and &lt;a href=&quot;../arrays/index#Comprehensions-1&quot;&gt;Comprehensions&lt;/a&gt; have the following behavior: any new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; Циклы for, циклы &lt;code&gt;while&lt;/code&gt; и &lt;a href=&quot;../arrays/index#Comprehensions-1&quot;&gt;Components&lt;/a&gt; имеют следующее поведение: любые новые переменные, введенные в их области действия, выделяются для каждой итерации цикла, как если бы тело цикла было окружено блоком &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bec35bbf9967b12c572f1318ed025dfeae186ddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c53dd6aa8e8d475ff1ee618c1ee3d8f300a0e513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: determines if the push will be a force push, overwriting the remote branch.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; : определяет, будет ли нажатие принудительным, перезаписывающим удаленную ветвь.</target>
        </trans-unit>
        <trans-unit id="4ffee3fe6299fc5a6f0fbcb9a6544eb7b084a999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, branch creation will be forced.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , создание ветки будет принудительным.</target>
        </trans-unit>
        <trans-unit id="26c5127fe157928b2cdc7f2f08c633baf7c246a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, existing references will be overwritten.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , существующие ссылки будут перезаписаны.</target>
        </trans-unit>
        <trans-unit id="d8ce10e1bd1c57308264cfa8a02820161529c9d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, a force-push will occur, disregarding conflicts.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , произойдет принудительное нажатие без учета конфликтов.</target>
        </trans-unit>
        <trans-unit id="e46f672d0974765d0e4d253aed78bcd6e5d3db60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; &amp;ndash; Determines whether backtraces are printed with (default, &lt;code&gt;:tree&lt;/code&gt;) or without (&lt;code&gt;:flat&lt;/code&gt;) indentation indicating tree structure.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; - определяет, будут ли обратные трассировки печататься с (по умолчанию,: &lt;code&gt;:tree&lt;/code&gt; ) или без ( &lt;code&gt;:flat&lt;/code&gt; ) отступом, указывающим древовидную структуру.</target>
        </trans-unit>
        <trans-unit id="c5f38a1c899e88a0f23d1dfceaf7e3fd37e72169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; &amp;ndash; Introduced above, determines whether backtraces are printed with (default, &lt;code&gt;:tree&lt;/code&gt;) or without (&lt;code&gt;:flat&lt;/code&gt;) indentation indicating tree structure.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; - введенный выше, определяет, будут ли обратные трассировки печататься с (по умолчанию,: &lt;code&gt;:tree&lt;/code&gt; ) или без ( &lt;code&gt;:flat&lt;/code&gt; ) отступом, указывающим древовидную структуру.</target>
        </trans-unit>
        <trans-unit id="07b58cbb5868ed67a3999d68cce4a5e6d8243fe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward&lt;/code&gt; &amp;ndash; the forwarding option used for &lt;code&gt;-L&lt;/code&gt; option of ssh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f61b7b48011ec894bf5fdc902e3b4b8a9fb28f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; must accept the bound channel as its only argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23fcdc8d4522728ad257672e40067d5a19c4c857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="0109f2ca671c98fc793c2888fdfb44cb05b2f484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global const&lt;/code&gt; statements from local scope after &lt;code&gt;__init__()&lt;/code&gt; has been started (see issue #12010 for plans to add an error for this)</source>
          <target state="translated">&lt;code&gt;global const&lt;/code&gt; операторы глобальных констант из локальной области видимости после &lt;code&gt;__init__()&lt;/code&gt; (см. проблему №12010, чтобы узнать о планах добавить ошибку для этого)</target>
        </trans-unit>
        <trans-unit id="09097a47be30f38cda85035ead6ddf1a81219edb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global x&lt;/code&gt; makes &lt;code&gt;x&lt;/code&gt; in the current scope and its inner scopes refer to the global variable of that name. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcb126bd8fbe56f4b5b16fa14c6c4a92e9cf8a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global x&lt;/code&gt; makes &lt;code&gt;x&lt;/code&gt; in the current scope and its inner scopes refer to the global variable of that name. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;global x&lt;/code&gt; делает &lt;code&gt;x&lt;/code&gt; в текущей области видимости, а ее внутренние области видимости ссылаются на глобальную переменную с этим именем. Дополнительную информацию см. В разделе &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;руководства по области видимости переменных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c2e813901bd2d8f12c7e3878d31c8f733486073" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a90e71a2c6d30f99d8ba5b28c6c2a5bb0f3aff1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash&lt;/code&gt; is a full (&lt;code&gt;GitHash&lt;/code&gt;) or partial (&lt;code&gt;GitShortHash&lt;/code&gt;) hash.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; - это полный ( &lt;code&gt;GitHash&lt;/code&gt; ) или частичный ( &lt;code&gt;GitShortHash&lt;/code&gt; ) хеш.</target>
        </trans-unit>
        <trans-unit id="6ab9710162b39252a4dfe60a21316f6a9dd04318" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;head_to_index&lt;/code&gt;: a pointer to a &lt;a href=&quot;#LibGit2.DiffDelta&quot;&gt;&lt;code&gt;DiffDelta&lt;/code&gt;&lt;/a&gt; which encapsulates the difference(s) between the file as it exists in HEAD and in the index.</source>
          <target state="translated">&lt;code&gt;head_to_index&lt;/code&gt; : указатель на &lt;a href=&quot;#LibGit2.DiffDelta&quot;&gt; &lt;code&gt;DiffDelta&lt;/code&gt; ,&lt;/a&gt; который инкапсулирует разницу (я) между файлом в том виде, в котором он существует в HEAD и в индексе.</target>
        </trans-unit>
        <trans-unit id="a8fb6255646b88973be5d589e3e2cd202888275d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hessenberg!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;hessenberg!&lt;/code&gt; то же самое, что и &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt; &lt;code&gt;hessenberg&lt;/code&gt; &lt;/a&gt; , но экономит место, перезаписывая вход &lt;code&gt;A&lt;/code&gt; , вместо создания копии.</target>
        </trans-unit>
        <trans-unit id="443aaa2d8a08dbab9eefb3c00c406e4d50854023" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;homedir&lt;/code&gt; determines the home directory via &lt;code&gt;libuv&lt;/code&gt;'s &lt;code&gt;uv_os_homedir&lt;/code&gt;. For details (for example on how to specify the home directory via environment variables), see the &lt;a href=&quot;http://docs.libuv.org/en/v1.x/misc.html#c.uv_os_homedir&quot;&gt;&lt;code&gt;uv_os_homedir&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;homedir&lt;/code&gt; определяет домашний каталог с помощью &lt;code&gt;libuv&lt;/code&gt; &amp;laquo;s &lt;code&gt;uv_os_homedir&lt;/code&gt; . Подробнее (например, о том, как указать домашний каталог с помощью переменных среды), см. &lt;a href=&quot;http://docs.libuv.org/en/v1.x/misc.html#c.uv_os_homedir&quot;&gt; &lt;code&gt;uv_os_homedir&lt;/code&gt; документации uv_os_homedir&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25471dd737a8db4cd226555668049cca23bf99f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host::AbstractString=&quot;&quot;&lt;/code&gt;: the hostname to use in the output. A hostname is required to be specified.</source>
          <target state="translated">&lt;code&gt;host::AbstractString=&quot;&quot;&lt;/code&gt; : имя хоста для использования в выводе. Необходимо указать имя хоста.</target>
        </trans-unit>
        <trans-unit id="6b6378d9ceebd483400cddb31fa9c2a3c49dd015" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; &amp;ndash; the host address (either an &lt;code&gt;AbstractString&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; - адрес хоста ( &lt;code&gt;AbstractString&lt;/code&gt; или &lt;code&gt;Nothing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="98f2590aab388123acc554ec9786e12f2ed78dd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; enables case-insensitive matching</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; включает соответствие без учета регистра</target>
        </trans-unit>
        <trans-unit id="1ac86474612cc32f61718a325d8179094b3f029b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; is unique across all references created from the worker specified by &lt;code&gt;whence&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; является уникальным во всех ссылках , созданные из рабочего определяется &lt;code&gt;whence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77683aec1c525b2fa7ea4282b18b2bfd743591a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the commit being worked on during this rebase step.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; коммита, над которым работали на этом этапе перебазирования.</target>
        </trans-unit>
        <trans-unit id="4632953193a9be88e4db3f78db33ec9c0b3e5355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the item in the diff. If the item is empty on this side of the diff (for instance, if the diff is of the removal of a file), this will be &lt;code&gt;GitHash(0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; элемента в diff. Если элемент с этой стороны &lt;code&gt;GitHash(0)&lt;/code&gt; например, если разность касается удаления файла), это будет GitHash (0) .</target>
        </trans-unit>
        <trans-unit id="9e890a5aeabd7d8ed2134402d7301e54269b9fea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id_abbrev&lt;/code&gt;: only present in LibGit2 versions newer than or equal to &lt;code&gt;0.25.0&lt;/code&gt;. The length of the &lt;code&gt;id&lt;/code&gt; field when converted using &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Usually equal to &lt;code&gt;OID_HEXSZ&lt;/code&gt; (40).</source>
          <target state="translated">&lt;code&gt;id_abbrev&lt;/code&gt; : присутствует только в версиях LibGit2 новее или равных &lt;code&gt;0.25.0&lt;/code&gt; . Длина поля &lt;code&gt;id&lt;/code&gt; при преобразовании с использованием &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; . Обычно равно &lt;code&gt;OID_HEXSZ&lt;/code&gt; (40).</target>
        </trans-unit>
        <trans-unit id="3d569a64dd1d8d5f907282660e533f0925b4121f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id_abbrev&lt;/code&gt;: sets the length of the abbreviated &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; to print. Default is &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id_abbrev&lt;/code&gt; : устанавливает длину сокращенного &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; для печати. По умолчанию &lt;code&gt;7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b126af9abc886e3ecfdde16a44fc1fd06cacab0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ident&lt;/code&gt; &amp;ndash; worker as identified by the &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt;&lt;code&gt;ClusterManager&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ident&lt;/code&gt; - работник, как определено &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt; &lt;code&gt;ClusterManager&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63b00d5176640c38aab5edaa5b524b6e779cf1b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; blocks also return a value, which may seem unintuitive to users coming from many other languages. This value is simply the return value of the last executed statement in the branch that was chosen, so</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; Блоки if также возвращают значение, которое может показаться неинтуитивным для пользователей многих других языков. Это значение является просто возвращаемым значением последнего выполненного оператора в выбранной ветви, поэтому</target>
        </trans-unit>
        <trans-unit id="fcb2f9043fb5a6e861c26de7d9fc3e06f6279b43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; blocks are &quot;leaky&quot;, i.e. they do not introduce a local scope. This means that new variables defined inside the &lt;code&gt;if&lt;/code&gt; clauses can be used after the &lt;code&gt;if&lt;/code&gt; block, even if they weren't defined before. So, we could have defined the &lt;code&gt;test&lt;/code&gt; function above as</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; блоки &quot;дырявые&quot;, т.е. они не вводят локальную область видимости. Это означает, что новые переменные, определенные внутри предложений &lt;code&gt;if&lt;/code&gt; , могут использоваться после блока &lt;code&gt;if&lt;/code&gt; , даже если они не были определены ранее. Итак, мы могли бы определить &lt;code&gt;test&lt;/code&gt; функцию выше как</target>
        </trans-unit>
        <trans-unit id="4bf46a1a1630b72dba5a7f8db4ee562143b45f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elseif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elseif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; conditional syntax:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elseif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; выполняет условную оценку, которая позволяет оценивать или не оценивать части кода в зависимости от значения логического выражения. Вот анатомия условного синтаксиса &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elseif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="566ebce021ad66c3334658155da253a262017f6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="b5d807151cf5fb7a277f815a71877f8ac2493dd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore_submodules&lt;/code&gt;: whether to look at files in submodules or not. Defaults to &lt;code&gt;SUBMODULE_IGNORE_UNSPECIFIED&lt;/code&gt;, which means the submodule's configuration will control whether it appears in the diff or not.</source>
          <target state="translated">&lt;code&gt;ignore_submodules&lt;/code&gt; : смотреть ли файлы в подмодулях или нет. По умолчанию &lt;code&gt;SUBMODULE_IGNORE_UNSPECIFIED&lt;/code&gt; , что означает, что конфигурация подмодуля будет определять, будет ли он отображаться в diff или нет.</target>
        </trans-unit>
        <trans-unit id="c7ec9971812e6bb11003c306876aa97764469071" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignorestatus::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then the &lt;code&gt;Cmd&lt;/code&gt; will not throw an error if the return code is nonzero.</source>
          <target state="translated">&lt;code&gt;ignorestatus::Bool&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; (по умолчанию &lt;code&gt;false&lt;/code&gt; ), то &lt;code&gt;Cmd&lt;/code&gt; не выдаст ошибку, если код возврата отличен от нуля.</target>
        </trans-unit>
        <trans-unit id="b778f0523dec6fb0a23df4b4366a7735dc4e5360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt;. Names from the imported &lt;code&gt;Foo&lt;/code&gt; module can be accessed with dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;). See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d73230963993ccbecb868483fbaecb6157d6cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt;. Names from the imported &lt;code&gt;Foo&lt;/code&gt; module can be accessed with dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;). See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;import Foo&lt;/code&gt; загрузит модуль или пакет &lt;code&gt;Foo&lt;/code&gt; . К именам из импортированного модуля &lt;code&gt;Foo&lt;/code&gt; можно получить доступ с помощью точечного синтаксиса (например, &lt;code&gt;Foo.foo&lt;/code&gt; для доступа к имени &lt;code&gt;foo&lt;/code&gt; ). См. Подробности в &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;разделе руководства о модулях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a86299ce603a7643e3664ff35ca004b94ad86d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c35c5eb16c9e1c075a2a381e94cfe254e7dd0daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; the &lt;code&gt;tst.jl&lt;/code&gt; file in the Julia REPL with &lt;code&gt;include(&quot;tst.jl&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; в &lt;code&gt;tst.jl&lt;/code&gt; файл в Джулии РЕПЛ с &lt;code&gt;include(&quot;tst.jl&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f768295f60d5987df59c14346dbea6137535cca3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_to_workdir&lt;/code&gt;: a pointer to a &lt;code&gt;DiffDelta&lt;/code&gt; which encapsulates the difference(s) between the file as it exists in the index and in the &lt;a href=&quot;#LibGit2.workdir&quot;&gt;&lt;code&gt;workdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index_to_workdir&lt;/code&gt; : указатель на &lt;code&gt;DiffDelta&lt;/code&gt; , который инкапсулирует разницу (я) между файлом в том виде, в котором он существует в индексе и в &lt;a href=&quot;#LibGit2.workdir&quot;&gt; &lt;code&gt;workdir&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="474f56e3f7f2db91f626ba947f94c8134a832be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inds&lt;/code&gt; can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;true&lt;/code&gt; indicating entries to delete.</source>
          <target state="translated">&lt;code&gt;inds&lt;/code&gt; может быть либо итератором, либо набором отсортированных и уникальных целочисленных индексов, либо логическим вектором той же длины, что &lt;code&gt;a&lt;/code&gt; с &lt;code&gt;true&lt;/code&gt; указывающим записи для удаления.</target>
        </trans-unit>
        <trans-unit id="f4b74525a3214d8995b7de35723cd0e10aa9cc48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_worker(cookie, manager::FooManager)&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; be called as part of worker process initialization.</source>
          <target state="translated">&lt;code&gt;init_worker(cookie, manager::FooManager)&lt;/code&gt; &lt;em&gt;должен&lt;/em&gt; вызываться как часть инициализации рабочего процесса.</target>
        </trans-unit>
        <trans-unit id="062786138593a2c08d489ac7499ae90c9ac1b687" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inmemory&lt;/code&gt;: start an in-memory rebase. Callers working on the rebase can go through its steps and commit any changes, but cannot rewind HEAD or update the repository. The &lt;a href=&quot;#LibGit2.workdir&quot;&gt;&lt;code&gt;workdir&lt;/code&gt;&lt;/a&gt; will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.</source>
          <target state="translated">&lt;code&gt;inmemory&lt;/code&gt; : начать перебазирование в памяти. Вызывающие, работающие над перебазированием, могут пройти его шаги и зафиксировать любые изменения, но не могут перемотать HEAD или обновить репозиторий. &lt;a href=&quot;#LibGit2.workdir&quot;&gt; &lt;code&gt;workdir&lt;/code&gt; &lt;/a&gt; не будет изменен. Присутствует только в версиях libgit2 новее или равных 0.24.0.</target>
        </trans-unit>
        <trans-unit id="43f0e964371142a5bdcf673bc58ad413b60b5576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;BOOL&lt;/code&gt; (C, typical)</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; , &lt;code&gt;BOOL&lt;/code&gt; (C, типичный)</target>
        </trans-unit>
        <trans-unit id="8c6987d5f4b696d5dad48c78ec3bd108e4434880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interhunk_lines&lt;/code&gt;: the maximum number of &lt;em&gt;unchanged&lt;/em&gt; lines &lt;em&gt;between&lt;/em&gt; two separate hunks allowed before the hunks will be combined. Default is 0.</source>
          <target state="translated">&lt;code&gt;interhunk_lines&lt;/code&gt; : максимальное количество &lt;em&gt;неизмененных&lt;/em&gt; строк &lt;em&gt;между&lt;/em&gt; двумя отдельными блоками, разрешенное до объединения блоков. По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="5ac758c6df49f7e88cbaf72ed20736709216e27a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv(::Missing)&lt;/code&gt; requires at least Julia 1.2.</source>
          <target state="translated">&lt;code&gt;inv(::Missing)&lt;/code&gt; требует как минимум Julia 1.2.</target>
        </trans-unit>
        <trans-unit id="defccb8166cf527d394e34aea3f1751d7f3bf94e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f1625223f3bccb84ba7248a9f8ae3e5a6efc8f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fd375f58223ce99e67fd522a69ff52eeb0090c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; , &lt;code&gt;sqrt&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb423dd8ec10d55f3420319afa3f79a334d2182d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io&lt;/code&gt; &amp;ndash; Allows you to save the results to a buffer, e.g. a file, but the default is to print to &lt;code&gt;stdout&lt;/code&gt; (the console).</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; - Позволяет сохранять результаты в буфер, например , файл, но по умолчанию для печати на &lt;code&gt;stdout&lt;/code&gt; ( на консоль).</target>
        </trans-unit>
        <trans-unit id="5546bdb05f19d23dc367936cace4cab1b8200d3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io&lt;/code&gt; &amp;ndash; the connection used to access the worker (a subtype of &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; - соединение, используемое для доступа к воркеру (подтип &lt;code&gt;IO&lt;/code&gt; или &lt;code&gt;Nothing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b8a259654f78220bfceb0da4679453a56d4d9938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isbare::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, clone the remote as a bare repository, which will make &lt;code&gt;repo_path&lt;/code&gt; itself the git directory instead of &lt;code&gt;repo_path/.git&lt;/code&gt;. This means that a working tree cannot be checked out. Plays the role of the git CLI argument &lt;code&gt;--bare&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isbare::Bool=false&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , клонировать пульт как &lt;code&gt;repo_path&lt;/code&gt; репозиторий, что сделает сам repo_path каталогом git вместо &lt;code&gt;repo_path/.git&lt;/code&gt; . Это означает, что рабочее дерево не может быть извлечено. Играет роль аргумента командной строки git &lt;code&gt;--bare&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f28ba244c2cc607da8b0fcf1f3367c037ee2322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isequal&lt;/code&gt; can also be used to distinguish signed zeros:</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; также можно использовать для различения нулей со знаком :</target>
        </trans-unit>
        <trans-unit id="6155f47b9568bd6b958ba232c62862f14186f428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isequal&lt;/code&gt; is the comparison function used by hash tables (&lt;code&gt;Dict&lt;/code&gt;). &lt;code&gt;isequal(x,y)&lt;/code&gt; must imply that &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; - это функция сравнения, используемая хеш-таблицами ( &lt;code&gt;Dict&lt;/code&gt; ). &lt;code&gt;isequal(x,y)&lt;/code&gt; должно означать, что &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c588e795f436dd4d05aaac17fde984ce26c5d8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ismerge&lt;/code&gt;: Boolean flag indicating whether the changes at the remote have been merged into the local copy yet or not. If &lt;code&gt;true&lt;/code&gt;, the local copy is up to date with the remote fetch head.</source>
          <target state="translated">&lt;code&gt;ismerge&lt;/code&gt; : логический флаг, указывающий, были ли внесены изменения на удаленном компьютере в локальную копию или нет. Если &lt;code&gt;true&lt;/code&gt; , локальная копия обновлена ​​с головкой удаленной выборки.</target>
        </trans-unit>
        <trans-unit id="cf09e161cb1b30fd41fdc4159954ec544ced0840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isready&lt;/code&gt; - return false if a &lt;code&gt;take!&lt;/code&gt; on the pool would block, else true</source>
          <target state="translated">&lt;code&gt;isready&lt;/code&gt; - вернуть false, если &lt;code&gt;take!&lt;/code&gt; на пуле будет блокировать, иначе правда</target>
        </trans-unit>
        <trans-unit id="7ad6e3363b26358cf09c26c458c64943918beb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isready&lt;/code&gt; tests for the presence of any object in the channel, while &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; waits for an object to become available.</source>
          <target state="translated">&lt;code&gt;isready&lt;/code&gt; проверяет наличие любого объекта в канале, а &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; ожидает, когда объект станет доступным.</target>
        </trans-unit>
        <trans-unit id="cf94b7544dc2a3713c698136abf41c0ffeb4bb19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_error&lt;/code&gt; takes a C string, and &lt;code&gt;jl_errorf&lt;/code&gt; is called like &lt;code&gt;printf&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;jl_error&lt;/code&gt; принимает строку C, а &lt;code&gt;jl_errorf&lt;/code&gt; вызывается как &lt;code&gt;printf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41fc079cf4386f9010ec6a2a6dcc4d336dfd5990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_value_t**&lt;/code&gt; (a reference to a Julia Type)</source>
          <target state="translated">&lt;code&gt;jl_value_t**&lt;/code&gt; (ссылка на тип Джулии)</target>
        </trans-unit>
        <trans-unit id="c496bfdad90f2fcfcf408b69f7b755c0534067bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_value_t*&lt;/code&gt; (any Julia Type)</source>
          <target state="translated">&lt;code&gt;jl_value_t*&lt;/code&gt; (любой тип Юлии)</target>
        </trans-unit>
        <trans-unit id="a6119baf62a14c4942fa709be955c8698c7254e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jpvt&lt;/code&gt; is an integer vector of length &lt;code&gt;n&lt;/code&gt; corresponding to the permutation $P$.</source>
          <target state="translated">&lt;code&gt;jpvt&lt;/code&gt; - целочисленный вектор длины &lt;code&gt;n&lt;/code&gt; , соответствующий перестановке $ P $.</target>
        </trans-unit>
        <trans-unit id="5370bf4f79562ad85e01f701fe6974cf62dddd5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;julia    pkg&amp;gt; generate MyPkg              # type ] to enter pkg mode    julia&amp;gt; push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode&lt;/code&gt; If you restart your Julia session you'll have to re-issue that command modifying &lt;code&gt;LOAD_PATH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;julia pkg&amp;gt; generate MyPkg # type ] to enter pkg mode julia&amp;gt; push!(LOAD_PATH, pwd()) # hit backspace to exit pkg mode&lt;/code&gt; Если вы перезапустите сеанс Julia, вам придется повторно выполнить эту команду, изменяя &lt;code&gt;LOAD_PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd73df7706c15ba69b8cb61854340ff6886bc85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;julia    using PkgTemplates    t = Template()    generate(&quot;MyPkg&quot;, t)&lt;/code&gt; This will create a blank package, &lt;code&gt;&quot;MyPkg&quot;&lt;/code&gt;, in your &lt;code&gt;.julia/dev&lt;/code&gt; directory. Note that PkgTemplates allows you to control many different options through its &lt;code&gt;Template&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;julia using PkgTemplates t = Template() generate(&quot;MyPkg&quot;, t)&lt;/code&gt; Это создаст пустой пакет &lt;code&gt;&quot;MyPkg&quot;&lt;/code&gt; в вашем &lt;code&gt;.julia/dev&lt;/code&gt; . Обратите внимание, что PkgTemplates позволяет вам управлять множеством различных параметров через конструктор &lt;code&gt;Template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="625af536bb88ddf9aa5a8b9ba26a788c563e9774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keepempty&lt;/code&gt;: whether empty fields should be kept in the result. Default is &lt;code&gt;false&lt;/code&gt; without a &lt;code&gt;dlm&lt;/code&gt; argument, &lt;code&gt;true&lt;/code&gt; with a &lt;code&gt;dlm&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;keepempty&lt;/code&gt; : должны ли оставаться в результате пустые поля. По умолчанию &lt;code&gt;false&lt;/code&gt; без аргумента &lt;code&gt;dlm&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; с аргументом &lt;code&gt;dlm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c6fd799a7cffc4157ed068f75896f2a6f68342b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill(manager, pid, config)&lt;/code&gt; is called to remove a worker from the cluster. On the master process, the corresponding &lt;code&gt;IO&lt;/code&gt; objects must be closed by the implementation to ensure proper cleanup. The default implementation simply executes an &lt;code&gt;exit()&lt;/code&gt; call on the specified remote worker.</source>
          <target state="translated">&lt;code&gt;kill(manager, pid, config)&lt;/code&gt; вызывается для удаления рабочего из кластера. В главном процессе соответствующие объекты &lt;code&gt;IO&lt;/code&gt; должны быть закрыты реализацией, чтобы обеспечить надлежащую очистку. Реализация по умолчанию просто выполняет вызов &lt;code&gt;exit()&lt;/code&gt; для указанного удаленного работника.</target>
        </trans-unit>
        <trans-unit id="5bfba992423752658b61db87a6fc7a82071655e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;launched::Array&lt;/code&gt;: the array to append one or more &lt;code&gt;WorkerConfig&lt;/code&gt; objects to</source>
          <target state="translated">&lt;code&gt;launched::Array&lt;/code&gt; &lt;code&gt;WorkerConfig&lt;/code&gt; :: Array : массив для добавления одного или нескольких объектов WorkerConfig к</target>
        </trans-unit>
        <trans-unit id="6c4472e72e5805ee9aa798ea6065a631b9f8120d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazy&lt;/code&gt;: Applicable only with &lt;code&gt;topology=:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; : применимо только с &lt;code&gt;topology=:all_to_all&lt;/code&gt; . Если &lt;code&gt;true&lt;/code&gt; , соединения рабочий-рабочий настраиваются лениво, т.е. они устанавливаются при первом экземпляре удаленного вызова между рабочими. По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="6ab3641b567d7550fa4574b7e9fcd59486edd69f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(iter)&lt;/code&gt; and &lt;code&gt;size(iter, [dim])&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;length(iter)&lt;/code&gt; и &lt;code&gt;size(iter, [dim])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b82c15769674081bdc4b1e2732d829ab6f255a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(str)&lt;/code&gt; the number of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length(str)&lt;/code&gt; количество символов в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="520336ce4b0d7ffb4223a859ab46df75e628bf97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(str, i, j)&lt;/code&gt; the number of valid character indices in &lt;code&gt;str&lt;/code&gt; from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length(str, i, j)&lt;/code&gt; количество допустимых индексов символов в &lt;code&gt;str&lt;/code&gt; от &lt;code&gt;i&lt;/code&gt; до &lt;code&gt;j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45f8144db4b1abe106783e820484be829d5e84bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, &lt;code&gt;let&lt;/code&gt; creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures. The &lt;code&gt;let&lt;/code&gt; syntax accepts a comma-separated series of assignments and variable names:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; Операторы let выделяют новые привязки переменных при каждом запуске. В то время как присвоение изменяет существующее местоположение значения, &lt;code&gt;let&lt;/code&gt; создает новые местоположения. Это различие можно обнаружить только в случае переменных, которые перестают действовать из-за замыканий. &lt;code&gt;let&lt;/code&gt; синтаксис принимает через запятую ряд заданий и имен переменных:</target>
        </trans-unit>
        <trans-unit id="2857b88b57ff8e8634f1fd5411364f41533e5276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="6d34fd9ee3b3db157e9c05aba51e1a69d53562d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt;: the maximum size of the result. &lt;code&gt;limit=0&lt;/code&gt; implies no maximum (default)</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; : максимальный размер результата. &lt;code&gt;limit=0&lt;/code&gt; означает отсутствие максимума (по умолчанию)</target>
        </trans-unit>
        <trans-unit id="4701fc63cc18d0bd4efa7e7a724aa45a91814bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line&lt;/code&gt; - the line number to open the editor at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee768c9c42d9eb36402e2084b6758909461265e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt; introduces a new local variable. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a949f1c99f2882cd291b76f59d11378f665e213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt; introduces a new local variable. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; представляет новую локальную переменную. Дополнительную информацию см. В разделе &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;руководства по области видимости переменных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1237a0341e49a3e81f1f3559c045b64e25d095c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="b2ace899c61be5098940595710c0631ed9e0f98f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localclone&lt;/code&gt;: Flag whether to clone a local object database or do a fetch. The default is to let git decide. It will not use the git-aware transport for a local clone, but will use it for URLs which begin with &lt;code&gt;file://&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;localclone&lt;/code&gt; : отметьте, следует ли клонировать локальную базу данных объектов или выполнить выборку. По умолчанию позволяет git решать. Он не будет использовать транспорт с поддержкой git для локального клона, но будет использовать его для URL-адресов, которые начинаются с &lt;code&gt;file://&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45419d31c5c3e877e8801855f33df8c42b91a13b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lu!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;code&gt;lu!&lt;/code&gt; то же самое, что и &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt; , но экономит место за счет перезаписи ввода &lt;code&gt;A&lt;/code&gt; вместо создания копии. &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; исключение , если разложение производит ряд не представим типом элемента &lt;code&gt;A&lt;/code&gt; , например , для целочисленных типов.</target>
        </trans-unit>
        <trans-unit id="80e7ecffd4874930679049a4efd39c31c359825a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt; treats the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; tokens as matching the start and end of individual lines, as opposed to the whole string.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; обрабатывает токены &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; как совпадающие с началом и концом отдельных строк, а не со всей строкой.</target>
        </trans-unit>
        <trans-unit id="959d5f8f25ccf34278c7231d15d752b5420fe0a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; единичная матрица размером m на &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f58713efbedd940089d6be8f8c2bd121e93d80c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix. Requires &lt;code&gt;using LinearAlgebra&lt;/code&gt; for &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0804fc37d749faa6c59c487dd0fd30a88f27145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;machine_spec&lt;/code&gt; is a string of the form &lt;code&gt;[user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. If &lt;code&gt;[bind_addr[:port]]&lt;/code&gt; is specified, other workers will connect to this worker at the specified &lt;code&gt;bind_addr&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;machine_spec&lt;/code&gt; - это строка вида &lt;code&gt;[user@]host[:port] [bind_addr[:port]]&lt;/code&gt; . &lt;code&gt;user&lt;/code&gt; умолчанию используется текущий пользователь, &lt;code&gt;port&lt;/code&gt; на стандартный порт ssh. Если &lt;code&gt;[bind_addr[:port]]&lt;/code&gt; , другие &lt;code&gt;bind_addr&lt;/code&gt; будут подключаться к этому воркеру через указанные bind_addr и &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae97bd7ed7d82dd19e12486744447e7aab4faa00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;machines&lt;/code&gt; is a vector of machine specifications. Workers are started for each specification.</source>
          <target state="translated">&lt;code&gt;machines&lt;/code&gt; - это вектор технических характеристик машины. Рабочие запускаются для каждой спецификации.</target>
        </trans-unit>
        <trans-unit id="6b0e0fb4129a24815ec030736714dbdf7a492aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt; defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/init/#Base.eval-1&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols.</source>
          <target state="translated">&lt;code&gt;macro&lt;/code&gt; определяет метод вставки сгенерированного кода в программу. Макрос отображает последовательность выражений аргументов в возвращаемое выражение, и полученное выражение подставляется непосредственно в программу в точке вызова макроса. Макросы - это способ запуска сгенерированного кода без вызова &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/init/#Base.eval-1&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; , поскольку вместо этого сгенерированный код просто становится частью окружающей программы. Аргументы макроса могут включать выражения, буквальные значения и символы.</target>
        </trans-unit>
        <trans-unit id="b776a97940ed8af56b4981f4f88255433cb44ef9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt; defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/init/#Base.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols. Macros can be defined for variable number of arguments (varargs), but do not accept keyword arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8484bf3ce18b73a3cab86759b8f006be25dfcef0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;macro&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="84b9fe4b3edfa78bd622af9c76d19c51a2ae7a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)&lt;/code&gt; is called at different times during the worker's lifetime with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">&lt;code&gt;manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)&lt;/code&gt; вызывается в разное время в течение жизни рабочего с соответствующими значениями &lt;code&gt;op&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a3811884df527d3a7abba9f083f81c97faa84f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manager::ClusterManager&lt;/code&gt;: the cluster manager that &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; is called with</source>
          <target state="translated">&lt;code&gt;manager::ClusterManager&lt;/code&gt; : менеджер кластера, с &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; вызывается addprocs</target>
        </trans-unit>
        <trans-unit id="8fdaf74a3de08a38b1e7873c2d0c9cc29c15317c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map!(f, values(dict::AbstractDict))&lt;/code&gt; requires Julia 1.2 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f703846e4a33db719039e6bcacfcf60d0b7d137b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapreduce&lt;/code&gt; with multiple iterators requires Julia 1.2 or later.</source>
          <target state="translated">&lt;code&gt;mapreduce&lt;/code&gt; с несколькими итераторами требует Julia 1.2 или новее.</target>
        </trans-unit>
        <trans-unit id="404b7144aa3a425a14deb38ee5cef8b003767781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_candidates_tags&lt;/code&gt;: consider this many most recent tags in &lt;code&gt;refs/tags&lt;/code&gt; to describe a commit. Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).</source>
          <target state="translated">&lt;code&gt;max_candidates_tags&lt;/code&gt; : примите во внимание это количество последних тегов в &lt;code&gt;refs/tags&lt;/code&gt; для описания фиксации. По умолчанию - 10 (чтобы проверялись 10 последних тегов, чтобы узнать, описывают ли они фиксацию).</target>
        </trans-unit>
        <trans-unit id="72981d27e1ab22dbc583a1145b1621a961f192c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_line&lt;/code&gt;: the last line of the file to which to blame. The default is &lt;code&gt;0&lt;/code&gt;, meaning the last line of the file.</source>
          <target state="translated">&lt;code&gt;max_line&lt;/code&gt; : последняя строка файла, виновного. По умолчанию &lt;code&gt;0&lt;/code&gt; , что означает последнюю строку файла.</target>
        </trans-unit>
        <trans-unit id="15cedd55ecf1ad91d90724912d371f1e5caa41be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel&lt;/code&gt; &amp;ndash; the maximum number of workers to connect to in parallel on the host</source>
          <target state="translated">&lt;code&gt;max_parallel&lt;/code&gt; - максимальное количество рабочих для параллельного подключения на хосте</target>
        </trans-unit>
        <trans-unit id="d995f39223c4bb9a999a43cfcca6c5681ab1ad1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel&lt;/code&gt;: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.</source>
          <target state="translated">&lt;code&gt;max_parallel&lt;/code&gt; : указывает максимальное количество рабочих, подключенных параллельно к хосту. По умолчанию 10.</target>
        </trans-unit>
        <trans-unit id="1b1d9f37af536ccd58c278c3e506d8652b8ac208" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_size&lt;/code&gt;: the maximum file size of a blob. Above this size, it will be treated as a binary blob. The default is 512 MB.</source>
          <target state="translated">&lt;code&gt;max_size&lt;/code&gt; : максимальный размер файла большого двоичного объекта. Если размер превышает этот, он будет рассматриваться как двоичный BLOB-объект. По умолчанию - 512 МБ.</target>
        </trans-unit>
        <trans-unit id="eaffe3704906f8467b046897a2780542aedcf5e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; Limits frames at a depth higher than &lt;code&gt;maxdepth&lt;/code&gt; in the &lt;code&gt;:tree&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;maxdepth&lt;/code&gt; - ограничивает кадры глубиной выше &lt;code&gt;maxdepth&lt;/code&gt; в формате &lt;code&gt;:tree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32491e760e7f18f6d8360a85f2a4709cc201ee79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; Limits the depth higher than &lt;code&gt;maxdepth&lt;/code&gt; in the &lt;code&gt;:tree&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;maxdepth&lt;/code&gt; - ограничивает глубину выше &lt;code&gt;maxdepth&lt;/code&gt; в формате &lt;code&gt;:tree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f20d7bbc515704268a8c41e4ee1011847047e24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxlog=integer&lt;/code&gt; should be used as a hint to the backend that the message should be displayed no more than &lt;code&gt;maxlog&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;maxlog=integer&lt;/code&gt; следует использовать как подсказку бэкэнду, что сообщение должно отображаться не чаще, чем &lt;code&gt;maxlog&lt;/code&gt; раз.</target>
        </trans-unit>
        <trans-unit id="234c5dd9163cc56272b3f54c2a5466c8b1f6eaee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxsize&lt;/code&gt;: specifies a size beyond which the buffer may not be grown.</source>
          <target state="translated">&lt;code&gt;maxsize&lt;/code&gt; : указывает размер, за пределами которого буфер не может быть увеличен.</target>
        </trans-unit>
        <trans-unit id="98f6f1cd7ea6f9bdc2332e5a901da5db582cd3aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mean&lt;/code&gt; for empty arrays requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;mean&lt;/code&gt; для пустых массивов требуется как минимум Julia 1.1.</target>
        </trans-unit>
        <trans-unit id="2f22ee8634e701a2f38532448ed1c500b069efd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts::MergeOptions = MergeOptions()&lt;/code&gt;: options for how to perform the merge, including whether fastforwarding is allowed. See &lt;a href=&quot;#LibGit2.MergeOptions&quot;&gt;&lt;code&gt;MergeOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;merge_opts::MergeOptions = MergeOptions()&lt;/code&gt; : параметры для выполнения слияния, в том числе разрешена ли быстрая пересылка. См. &lt;a href=&quot;#LibGit2.MergeOptions&quot;&gt; &lt;code&gt;MergeOptions&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="71cc2e70735d9fd74fff0caeb5b8d510b36cbd2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts::MergeOptions=MergeOptions()&lt;/code&gt;: &lt;code&gt;merge_opts&lt;/code&gt; specifies options for the merge, such as merge strategy in case of conflicts.</source>
          <target state="translated">&lt;code&gt;merge_opts::MergeOptions=MergeOptions()&lt;/code&gt; : &lt;code&gt;merge_opts&lt;/code&gt; указывает параметры для слияния, такие как стратегия слияния в случае конфликтов.</target>
        </trans-unit>
        <trans-unit id="125e60bc501dba72f09f0b4976efe2ce6d4483cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts&lt;/code&gt;: merge options controlling how the trees will be merged at each rebase step. Only present on libgit2 versions newer than or equal to 0.24.0.</source>
          <target state="translated">&lt;code&gt;merge_opts&lt;/code&gt; : параметры слияния, управляющие тем, как деревья будут слиты на каждом шаге перебазирования. Присутствует только в версиях libgit2 новее или равных 0.24.0.</target>
        </trans-unit>
        <trans-unit id="a5c88c45c2e1535dc547029bf00d88024b7ab716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergewith!&lt;/code&gt; requires Julia 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d6df524e25091e18c8beea5b75a95d3f719841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergewith&lt;/code&gt; requires Julia 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b67314512e49ee15c92e5c7e9f6dbd1931dab06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; should be an expression which evaluates to a string which is a human readable description of the log event. By convention, this string will be formatted as markdown when presented.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; должно быть выражением, результатом которого является строка, которая представляет собой удобочитаемое описание события журнала. По соглашению, эта строка будет отформатирована как уценка при представлении.</target>
        </trans-unit>
        <trans-unit id="b90e0c119e4dfcc2e9dd089d139594390c4da90a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meta_formatter&lt;/code&gt; is a function which takes the log event metadata &lt;code&gt;(level, _module, group, id, file, line)&lt;/code&gt; and returns a color (as would be passed to printstyled), prefix and suffix for the log message. The default is to prefix with the log level and a suffix containing the module, file and line location.</source>
          <target state="translated">&lt;code&gt;meta_formatter&lt;/code&gt; - это функция, которая принимает метаданные событий журнала &lt;code&gt;(level, _module, group, id, file, line)&lt;/code&gt; и возвращает цвет (который будет передан в printstyled), префикс и суффикс для сообщения журнала. По умолчанию используется префикс уровня журнала и суффикс, содержащий модуль, файл и расположение строки.</target>
        </trans-unit>
        <trans-unit id="793b666b763adfb5cbc980bd4657fe28ca8ebfa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metric&lt;/code&gt;: optional custom function to use to determine the similarity between two files for rename detection.</source>
          <target state="translated">&lt;code&gt;metric&lt;/code&gt; : необязательная настраиваемая функция, используемая для определения сходства двух файлов для обнаружения переименования.</target>
        </trans-unit>
        <trans-unit id="ee731c731c0b59328238d9d827bb96b9a9284c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_line&lt;/code&gt;: the first line of the file from which to starting blaming. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;min_line&lt;/code&gt; : первая строка файла, с которой начинается обвинение. По умолчанию &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b3253f765bb04e11f5c63333adab3ac5b42e254" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_match_characters&lt;/code&gt;: the minimum number of &lt;em&gt;alphanumeric&lt;/em&gt; characters which much change in a commit in order for the change to be associated with that commit. The default is 20. Only takes effect if one of the &lt;code&gt;Consts.BLAME_*_COPIES&lt;/code&gt; flags are used, which libgit2 does not implement yet.</source>
          <target state="translated">&lt;code&gt;min_match_characters&lt;/code&gt; : минимальное количество &lt;em&gt;буквенно-цифровых&lt;/em&gt; символов, которые сильно меняются в фиксации, чтобы изменение было связано с этой фиксацией. По умолчанию 20. &lt;code&gt;Consts.BLAME_*_COPIES&lt;/code&gt; только в том случае, если используется один из флагов Consts.BLAME _ * _ COPIES, который в libgit2 еще не реализован.</target>
        </trans-unit>
        <trans-unit id="5db057df9be404f6e7c104b6feff23b69ad90b59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; Limits frames with less than &lt;code&gt;mincount&lt;/code&gt; occurrences.</source>
          <target state="translated">&lt;code&gt;mincount&lt;/code&gt; - ограничивает кадры с количеством вхождений меньше &lt;code&gt;mincount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1560ab3a1270d2ec7101ba0ebabaa0d8741ee114" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; Limits the printout to only those lines with at least &lt;code&gt;mincount&lt;/code&gt; occurrences.</source>
          <target state="translated">&lt;code&gt;mincount&lt;/code&gt; - ограничивает распечатку только теми строками, в &lt;code&gt;mincount&lt;/code&gt; встречается как минимум mincount .</target>
        </trans-unit>
        <trans-unit id="7fc9303555177cabe6ff1fd33c9914d821e64acb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard mathematical operators and functions. For these functions, uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means a math operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fbe82d06f465bb8d2948bd22cf8237ee9a59c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mod&lt;/code&gt; with offset 1; returns &lt;code&gt;r&amp;isin;(0,y]&lt;/code&gt; for &lt;code&gt;y&amp;gt;0&lt;/code&gt; or &lt;code&gt;r&amp;isin;[y,0)&lt;/code&gt; for &lt;code&gt;y&amp;lt;0&lt;/code&gt;, where &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; со смещением 1; возвращает &lt;code&gt;r&amp;isin;(0,y]&lt;/code&gt; для &lt;code&gt;y&amp;gt;0&lt;/code&gt; или &lt;code&gt;r&amp;isin;[y,0)&lt;/code&gt; для &lt;code&gt;y&amp;lt;0&lt;/code&gt; , где &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d4ee2c86fd7250e19c9601f24f28fca8d9bdc9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; must be one of &lt;code&gt;&quot;r&quot;&lt;/code&gt;, &lt;code&gt;&quot;r+&quot;&lt;/code&gt;, &lt;code&gt;&quot;w+&quot;&lt;/code&gt;, or &lt;code&gt;&quot;a+&quot;&lt;/code&gt;, and defaults to &lt;code&gt;&quot;r+&quot;&lt;/code&gt; if the file specified by &lt;code&gt;filename&lt;/code&gt; already exists, or &lt;code&gt;&quot;w+&quot;&lt;/code&gt; if not. If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers. You cannot specify an &lt;code&gt;init&lt;/code&gt; function if the file is not writable.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; должен быть одним из &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;r+&quot;&lt;/code&gt; , &lt;code&gt;&quot;w+&quot;&lt;/code&gt; или &lt;code&gt;&quot;a+&quot;&lt;/code&gt; , и по умолчанию должен быть &lt;code&gt;&quot;r+&quot;&lt;/code&gt; если файл, указанный в &lt;code&gt;filename&lt;/code&gt; , уже существует, или &lt;code&gt;&quot;w+&quot;&lt;/code&gt; если нет. Если &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; функция &lt;code&gt;init&lt;/code&gt; типа initfn (S :: SharedArray) , она вызывается для всех участвующих рабочих процессов . Вы не можете указать функцию &lt;code&gt;init&lt;/code&gt; если файл недоступен для записи.</target>
        </trans-unit>
        <trans-unit id="9a097698641d5469c04e6f0f998cce8e958f0b35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt;: the &lt;a href=&quot;../../base/file/index#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; mode for the item.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; : режим &lt;a href=&quot;../../base/file/index#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; для элемента.</target>
        </trans-unit>
        <trans-unit id="2698588e3b9b4ad6d810639c1a90db1327c88c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; declares a &lt;a href=&quot;#Core.Module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else&amp;rsquo;s. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5158bf646d4d27259805df6c3a41ba7e37637e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; declares a &lt;a href=&quot;#Core.Module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else&amp;rsquo;s. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; объявляет &lt;a href=&quot;#Core.Module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; , который является отдельной рабочей областью глобальных переменных. Внутри модуля вы можете контролировать, какие имена из других модулей видны (посредством импорта), и указывать, какие из ваших имен должны быть общедоступными (посредством экспорта). Модули позволяют создавать определения верхнего уровня, не беспокоясь о конфликтах имен, когда ваш код используется вместе с чужим. Более подробную информацию см. В разделе &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;руководства о модулях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6b46915fd1e85bc90eb5d56fd7bd927a43d2f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c95192ba3e3940cd0188a72ebb62589a75aa7d1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg::AbstractString=&quot;&quot;&lt;/code&gt;: the message for the tag.</source>
          <target state="translated">&lt;code&gt;msg::AbstractString=&quot;&quot;&lt;/code&gt; : сообщение для тега.</target>
        </trans-unit>
        <trans-unit id="f4d691c48a28d2ce55d8a4698e4a2c1aee668e25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt;: a message to insert into the reflogs.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; : сообщение для вставки в журналы рефлогов.</target>
        </trans-unit>
        <trans-unit id="487395b1bdfc7e61d7447898d434b73b3a4f1f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast_loop&lt;/code&gt;: loopback for multicast packets (default: &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;multicast_loop&lt;/code&gt; : шлейф для многоадресных пакетов (по умолчанию: &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e99e21c3690f3dcdfa4d6c0fe75cee3eea8fe44c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast_ttl&lt;/code&gt;: TTL for multicast packets (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;multicast_ttl&lt;/code&gt; : TTL для многоадресных пакетов (по умолчанию: &lt;code&gt;nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="187344f44af903c3b6f0efb3f7498faa785d7c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplex&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use SSH multiplexing for tunneling) or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44fe996e6d08709a8c10b3979d511d5e4323b6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplex&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH multiplexing is used for SSH tunneling. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56a3d584155f39e37a0ccc363839ae179552328" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt; is similar to &lt;a href=&quot;#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;, but additionally allows the fields of the type to be set after construction. See the manual section on &lt;a href=&quot;../../manual/types/index#Composite-Types&quot;&gt;Composite Types&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f441746093557e9ec7fe5f7c0d91f2ae4fdd6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt; is similar to &lt;a href=&quot;#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;, but additionally allows the fields of the type to be set after construction. See the manual section on &lt;a href=&quot;../../manual/types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;mutable struct&lt;/code&gt; похожа на &lt;a href=&quot;#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; , но дополнительно позволяет устанавливать поля типа после построения. Для получения дополнительной информации см. Раздел руководства о &lt;a href=&quot;../../manual/types/index#Composite-Types-1&quot;&gt;составных типах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="112c939f3f1e9b5e8b278904ec6b0b49257b0632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;mutable struct&lt;/code&gt; слово структуры</target>
        </trans-unit>
        <trans-unit id="320c0e13d8c7b9ff51bc77d61fd9070c11bc1ebc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; is the total number of instruction pointers you can store, with a default value of &lt;code&gt;10^6&lt;/code&gt;. If your typical backtrace is 20 instruction pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of less than 1%. This may be good enough for most applications.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; - общее количество указателей инструкций, которые вы можете сохранить, со значением по умолчанию &lt;code&gt;10^6&lt;/code&gt; . Если ваша типичная обратная трассировка - это 20 указателей инструкций, вы можете собрать 50000 обратных трассировок, что предполагает статистическую погрешность менее 1%. Этого может быть достаточно для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="e658555bc40ad43ec211978ec0729a0b02c58be6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: The full name of the committer or author of the commit.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : полное имя коммиттера или автора коммита.</target>
        </trans-unit>
        <trans-unit id="552e03fffa49ac0ec7ab0ea1aaa5c130fedf4f05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: The name in the local reference database of the fetch head, for example, &lt;code&gt;&quot;refs/heads/master&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : имя в локальной справочной базе данных заголовка выборки, например, &lt;code&gt;&quot;refs/heads/master&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d29f5a5c3f202febb2a81757e5b837859f3823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ncodeunits(str)&lt;/code&gt; number of &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding#Terminology&quot;&gt;code units&lt;/a&gt; in a string.</source>
          <target state="translated">&lt;code&gt;ncodeunits(str)&lt;/code&gt; количество &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding#Terminology&quot;&gt;кодовых единиц&lt;/a&gt; в строке.</target>
        </trans-unit>
        <trans-unit id="f909eb780ec20a645e7ec717e2b09ab499055360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="735cb1802f16a2c6f76996e3fbd8153f32d4f6fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_file&lt;/code&gt;: A &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt;&lt;code&gt;DiffFile&lt;/code&gt;&lt;/a&gt; containing information about the file(s) after the changes.</source>
          <target state="translated">&lt;code&gt;new_file&lt;/code&gt; : &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt; &lt;code&gt;DiffFile&lt;/code&gt; &lt;/a&gt; содержащий информацию о файле (ах) после изменений.</target>
        </trans-unit>
        <trans-unit id="7be2c96b12a02f7083c9d25ea7528ad8667d09e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_prefix&lt;/code&gt;: the virtual file directory in which to place new files on one side of the diff. Default is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_prefix&lt;/code&gt; : виртуальный файловый каталог, в который помещаются новые файлы с одной стороны от diff. По умолчанию - &lt;code&gt;&quot;b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8c2e95eb3130b139d44d439028bbbfabf438e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newest_commit&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the newest commit from which to look at changes.</source>
          <target state="translated">&lt;code&gt;newest_commit&lt;/code&gt; : &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; новейшего коммита, из которого можно посмотреть изменения.</target>
        </trans-unit>
        <trans-unit id="8f40f498efe7ceacbe5a57c6f819e21dd76050f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newline2lf=true&lt;/code&gt;, &lt;code&gt;newline2ls=true&lt;/code&gt;, or &lt;code&gt;newline2ps=true&lt;/code&gt;: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively</source>
          <target state="translated">&lt;code&gt;newline2lf=true&lt;/code&gt; , &lt;code&gt;newline2ls=true&lt;/code&gt; или &lt;code&gt;newline2ps=true&lt;/code&gt; : конвертировать различные последовательности новой строки (LF, CRLF, CR, NEL) в символы перевода строки (LF), разделения строк (LS) или разделения абзацев (PS) соответственно</target>
        </trans-unit>
        <trans-unit id="4ec45f42c32c00b527d28e030133b724dbf610e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nfiles&lt;/code&gt;: The number of files in the delta (for instance, if the delta was run on a submodule commit id, it may contain more than one file).</source>
          <target state="translated">&lt;code&gt;nfiles&lt;/code&gt; : количество файлов в дельте (например, если дельта была запущена для идентификатора фиксации подмодуля, он может содержать более одного файла).</target>
        </trans-unit>
        <trans-unit id="13583c0cdd9e082972c1e68b453244539921d780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; Limits frames that are below the heuristic noise floor of the sample (only applies to format &lt;code&gt;:tree&lt;/code&gt;). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of samples on this line, and &lt;code&gt;N&lt;/code&gt; is the number of samples for the callee.</source>
          <target state="translated">&lt;code&gt;noisefloor&lt;/code&gt; - ограничивает кадры, которые находятся ниже эвристического минимального уровня шума выборки (применяется только к format &lt;code&gt;:tree&lt;/code&gt; ). Рекомендуемое значение для этого - 2,0 (по умолчанию 0). Этот параметр скрывает выборки, для которых &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - количество выборок в этой строке, а &lt;code&gt;N&lt;/code&gt; - количество выборок для вызываемого.</target>
        </trans-unit>
        <trans-unit id="f539796532455743d77bf293cbd17e25f2f2dad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; Limits frames that exceed the heuristic noise floor of the sample (only applies to format &lt;code&gt;:tree&lt;/code&gt;). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of samples on this line, and &lt;code&gt;N&lt;/code&gt; is the number of samples for the callee.</source>
          <target state="translated">&lt;code&gt;noisefloor&lt;/code&gt; - ограничивает кадры, которые превышают эвристический минимальный уровень шума выборки (применяется только к format &lt;code&gt;:tree&lt;/code&gt; ). Рекомендуемое значение для этого - 2,0 (по умолчанию 0). Этот параметр скрывает выборки, для которых &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - количество выборок в этой строке, а &lt;code&gt;N&lt;/code&gt; - количество выборок для вызываемого.</target>
        </trans-unit>
        <trans-unit id="7cccdf2a98a9aae590bd349512e62d461403b275" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_cb&lt;/code&gt;: An optional callback function to notify the user if a checkout conflict occurs. If this function returns a non-zero value, the checkout will be cancelled.</source>
          <target state="translated">&lt;code&gt;notify_cb&lt;/code&gt; : дополнительная функция обратного вызова для уведомления пользователя в случае возникновения конфликта при оформлении заказа . Если эта функция вернет ненулевое значение, оформление заказа будет отменено.</target>
        </trans-unit>
        <trans-unit id="30392c812d865b5c68f24732d969c588932dc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_cb&lt;/code&gt;: optional callback which will notify the user of changes to the diff as file deltas are added to it.</source>
          <target state="translated">&lt;code&gt;notify_cb&lt;/code&gt; : необязательный обратный вызов, который будет уведомлять пользователя об изменениях в diff, когда к нему добавляются дельты файлов.</target>
        </trans-unit>
        <trans-unit id="5d44c57c1841b302e1e4a4864a4e16016feedd35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_flags&lt;/code&gt;: Flags for what sort of conflicts the user should be notified about.</source>
          <target state="translated">&lt;code&gt;notify_flags&lt;/code&gt; : флаги, о каких конфликтах следует уведомлять пользователя.</target>
        </trans-unit>
        <trans-unit id="c444029454795fde1134c2d469857e669b1440c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_payload&lt;/code&gt;: Payload for the notify callback function.</source>
          <target state="translated">&lt;code&gt;notify_payload&lt;/code&gt; : полезная нагрузка для функции обратного вызова уведомления.</target>
        </trans-unit>
        <trans-unit id="f8a72ff21213c5747c87230deb5736ece00049c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntasks&lt;/code&gt; can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of &lt;code&gt;ntasks_func&lt;/code&gt; is less than the current number of tasks.</source>
          <target state="translated">&lt;code&gt;ntasks&lt;/code&gt; также можно указать как функцию с нулевым аргументом. В этом случае количество задач для параллельного запуска проверяется перед обработкой каждого элемента, и новая задача запускается, если значение &lt;code&gt;ntasks_func&lt;/code&gt; меньше текущего количества задач.</target>
        </trans-unit>
        <trans-unit id="28a2d799c4775665ec0492395458a2421920f94b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntasks&lt;/code&gt; specifies the number of tasks to run concurrently. Depending on the length of the collections, if &lt;code&gt;ntasks&lt;/code&gt; is unspecified, up to 100 tasks will be used for concurrent mapping.</source>
          <target state="translated">&lt;code&gt;ntasks&lt;/code&gt; указывает количество задач для одновременного выполнения. В зависимости от длины коллекций, если &lt;code&gt;ntasks&lt;/code&gt; не указан , для одновременного сопоставления будет использоваться до 100 задач.</target>
        </trans-unit>
        <trans-unit id="649eb66db0ac1d45f589aa8e9473637c03ceaed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; allows you to skip the specified number of bytes at the beginning of the file.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; позволяет пропустить указанное количество байтов в начале файла.</target>
        </trans-unit>
        <trans-unit id="f497a87199a32512c97994d5a18e9f772067d770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oid&lt;/code&gt;: The &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the tip of the fetch head.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; : &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; кончика головы выборки.</target>
        </trans-unit>
        <trans-unit id="b1944d05e865a7be7c70b13dc44ad49d6eef824c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_file&lt;/code&gt;: A &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt;&lt;code&gt;DiffFile&lt;/code&gt;&lt;/a&gt; containing information about the file(s) before the changes.</source>
          <target state="translated">&lt;code&gt;old_file&lt;/code&gt; : &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt; &lt;code&gt;DiffFile&lt;/code&gt; &lt;/a&gt; содержащий информацию о файле (ах) до изменений.</target>
        </trans-unit>
        <trans-unit id="0c4e9a36bc861c7981c727529931615c5c12cf7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_prefix&lt;/code&gt;: the virtual file directory in which to place old files on one side of the diff. Default is &lt;code&gt;&quot;a&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old_prefix&lt;/code&gt; : виртуальный файловый каталог, в который можно поместить старые файлы на одной стороне diff. По умолчанию - &lt;code&gt;&quot;a&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c31e5cf28678d5c969358670eb5133dd3159a86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oldest_commit&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the oldest commit from which to look at changes.</source>
          <target state="translated">&lt;code&gt;oldest_commit&lt;/code&gt; : &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; самого старого коммита, из которого можно посмотреть изменения.</target>
        </trans-unit>
        <trans-unit id="1ab08f6dbafd16b32ce5160a5db1168198264195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;only_follow_first_parent&lt;/code&gt;: when finding the distance from a matching reference to the described object, only consider the distance from the first parent.</source>
          <target state="translated">&lt;code&gt;only_follow_first_parent&lt;/code&gt; : при нахождении расстояния от совпадающей ссылки до описываемого объекта учитывайте только расстояние от первого родителя.</target>
        </trans-unit>
        <trans-unit id="cf7b1529623e34aaf3b56dcbaf1430c042e15e1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimize&lt;/code&gt; controls whether additional optimizations, such as inlining, are also applied. &lt;code&gt;raw&lt;/code&gt; makes all metadata and dbg.* calls visible. &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; (default) or &lt;code&gt;:none&lt;/code&gt;, to specify the verbosity of code comments. &lt;code&gt;dump_module&lt;/code&gt; prints the entire module that encapsulates the function.</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; контролирует, применяются ли также дополнительные оптимизации, такие как встраивание. &lt;code&gt;raw&lt;/code&gt; делает видимыми все метаданные и вызовы dbg. *. &lt;code&gt;debuginfo&lt;/code&gt; может принимать одно из &lt;code&gt;:source&lt;/code&gt; значений : source (по умолчанию) или &lt;code&gt;:none&lt;/code&gt; , чтобы указать подробность комментариев кода. &lt;code&gt;dump_module&lt;/code&gt; печатает весь модуль, который инкапсулирует функцию.</target>
        </trans-unit>
        <trans-unit id="5c0c73b16f432720504516e2f958debb7c0a4f9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: determines the options for the fetch, e.g. whether to prune afterwards. See &lt;a href=&quot;#LibGit2.FetchOptions&quot;&gt;&lt;code&gt;FetchOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; : определяет параметры для выборки, например, нужно ли обрезать впоследствии. См. &lt;a href=&quot;#LibGit2.FetchOptions&quot;&gt; &lt;code&gt;FetchOptions&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6a9ddb6ecff4eeaf4d380bca97b4dd6f7fde407e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: determines the options for the push, e.g. which proxy headers to use. See &lt;a href=&quot;#LibGit2.PushOptions&quot;&gt;&lt;code&gt;PushOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; : определяет параметры для push, например, какие заголовки прокси использовать. См. &lt;a href=&quot;#LibGit2.PushOptions&quot;&gt; &lt;code&gt;PushOptions&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d7f25b0d9ee03294770f82dddd1bc7bcef0fb64c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optype&lt;/code&gt;: the type of rebase operation currently being performed. The options are:</source>
          <target state="translated">&lt;code&gt;optype&lt;/code&gt; : тип выполняемой в настоящее время операции перебазирования. Возможные варианты:</target>
        </trans-unit>
        <trans-unit id="d3e3a0e908208f76b5ccd84be51a34bb39927cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ospid&lt;/code&gt; &amp;ndash; the process ID according to the host OS, used to interrupt worker processes</source>
          <target state="translated">&lt;code&gt;ospid&lt;/code&gt; - идентификатор процесса в соответствии с ОС хоста, используемый для прерывания рабочих процессов</target>
        </trans-unit>
        <trans-unit id="697de2c67496b1d84f2571e138792286e7da4946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;our_label&lt;/code&gt;: In case of conflicts, the name of &quot;our&quot; side.</source>
          <target state="translated">&lt;code&gt;our_label&lt;/code&gt; : В случае конфликтов название &amp;laquo;нашей&amp;raquo; стороны.</target>
        </trans-unit>
        <trans-unit id="6830be65e4ac77ca9e62be6dc5c7e0620fc0523a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, &lt;code&gt;norm(A, Inf)&lt;/code&gt; returns the largest value in &lt;code&gt;abs.(A)&lt;/code&gt;, whereas &lt;code&gt;norm(A, -Inf)&lt;/code&gt; returns the smallest. If &lt;code&gt;A&lt;/code&gt; is a matrix and &lt;code&gt;p=2&lt;/code&gt;, then this is equivalent to the Frobenius norm.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; может принимать любое числовое значение (даже если не все значения дают математически верную векторную норму). В частности, &lt;code&gt;norm(A, Inf)&lt;/code&gt; возвращает наибольшее значение в &lt;code&gt;abs.(A)&lt;/code&gt; , тогда как &lt;code&gt;norm(A, -Inf)&lt;/code&gt; возвращает наименьшее. Если &lt;code&gt;A&lt;/code&gt; - матрица и &lt;code&gt;p=2&lt;/code&gt; , то это эквивалентно норме Фробениуса.</target>
        </trans-unit>
        <trans-unit id="c1263f31af18883ad798ffeb9ebfc0a698a746ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallelism&lt;/code&gt;: if a pack file must be created, this variable sets the number of worker threads which will be spawned by the packbuilder. If &lt;code&gt;0&lt;/code&gt;, the packbuilder will auto-set the number of threads to use. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parallelism&lt;/code&gt; : если необходимо создать файл пакета, эта переменная устанавливает количество рабочих потоков, которые будут порождены конструктором пакетов. Если &lt;code&gt;0&lt;/code&gt; , конструктор пакетов автоматически установит количество используемых потоков. По умолчанию &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="062dd574e97337bbf0642f566cbd632bf4e6858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params::Dict&lt;/code&gt;: all the keyword arguments passed to &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;params::Dict&lt;/code&gt; : все аргументы ключевого слова, переданные в &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c7beec041180be0f67a5413cf19dc80f87f5c60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent_ids::Vector{GitHash}=GitHash[]&lt;/code&gt; is a list of commits by &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; to use as parent commits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.</source>
          <target state="translated">&lt;code&gt;parent_ids::Vector{GitHash}=GitHash[]&lt;/code&gt; - это список &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; для использования в качестве родительских коммитов для нового, и может быть пустым. У фиксации может быть несколько родителей, например, если это фиксация слияния.</target>
        </trans-unit>
        <trans-unit id="2aeba9857371fd4afaedeaa23fe9e52591dc0285" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parse(Bool, str)&lt;/code&gt; requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;parse(Bool, str)&lt;/code&gt; требует как минимум Julia 1.1.</target>
        </trans-unit>
        <trans-unit id="985febc2923b1ba06875dac2b326b7c44efb7b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password::AbstractString=&quot;&quot;&lt;/code&gt;: the password to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;password::AbstractString=&quot;&quot;&lt;/code&gt; : пароль для использования в выводе, если он указан.</target>
        </trans-unit>
        <trans-unit id="7b2d565e6b56d3e37cd4a4c107b73f4f88a4add0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path::AbstractString=&quot;&quot;&lt;/code&gt;: the path to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;path::AbstractString=&quot;&quot;&lt;/code&gt; : путь для использования в выводе, если он указан.</target>
        </trans-unit>
        <trans-unit id="6bbb797e9183ff39fe99d21ff1e7ff0b15d193b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - the path to the source file to open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a1cfd3ac44390db0e2939f5bb09d810d9dc716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt;: a &lt;code&gt;NULL&lt;/code&gt; terminated path to the item relative to the working directory of the repository.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; : путь к элементу с завершающим &lt;code&gt;NULL&lt;/code&gt; относительно рабочего каталога репозитория.</target>
        </trans-unit>
        <trans-unit id="df78851e58e7c0164b5edaedb4aae38730252715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;: If not empty, describes which paths to search during the checkout. If empty, the checkout will occur over all files in the repository.</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt; : если не пусто, описывает, какие пути искать во время оформления заказа. Если пусто, проверка будет происходить для всех файлов в репозитории.</target>
        </trans-unit>
        <trans-unit id="aaac9c176103fbec24dd83078cf0783db26c54ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathspec&lt;/code&gt;: an array of paths to use for path-matching. The behavior of the path-matching will vary depending on the values of &lt;code&gt;show&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pathspec&lt;/code&gt; : массив путей, используемых для сопоставления пути. Поведение сопоставления пути будет варьироваться в зависимости от значений &lt;code&gt;show&lt;/code&gt; и &lt;code&gt;flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5de9b2330e81c1ec09cc2a025ec36b4958e8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathspec&lt;/code&gt;: path to files to include in the diff. Default is to use all files in the repository.</source>
          <target state="translated">&lt;code&gt;pathspec&lt;/code&gt; : путь к файлам для включения в diff. По умолчанию используются все файлы в репозитории.</target>
        </trans-unit>
        <trans-unit id="5d5c79832426fbf09095f04929a254af7d30d839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pattern&lt;/code&gt;: only consider tags which match &lt;code&gt;pattern&lt;/code&gt;. Supports glob expansion.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; : рассматривать только теги, соответствующие &lt;code&gt;pattern&lt;/code&gt; . Поддерживает расширение глобуса.</target>
        </trans-unit>
        <trans-unit id="faa8387984da43a7639fa49609355dfec1758934" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt;: the payload to be provided to the two callback functions.</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; : полезная нагрузка, которая будет предоставлена ​​двум функциям обратного вызова.</target>
        </trans-unit>
        <trans-unit id="66e76aa49d7a614c921c6cec0e182e1bd4a6645c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt;: the payload to pass to &lt;code&gt;notify_cb&lt;/code&gt; and &lt;code&gt;progress_cb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; : полезная нагрузка, передаваемая в &lt;code&gt;notify_cb&lt;/code&gt; и &lt;code&gt;progress_cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2913a1a2626baab62573ae3ba9c2e917e2edec43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peakflops&lt;/code&gt; computes the peak flop rate of the computer by using double precision &lt;a href=&quot;#LinearAlgebra.BLAS.gemm!&quot;&gt;&lt;code&gt;gemm!&lt;/code&gt;&lt;/a&gt;. By default, if no arguments are specified, it multiplies a matrix of size &lt;code&gt;n x n&lt;/code&gt;, where &lt;code&gt;n = 2000&lt;/code&gt;. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with &lt;a href=&quot;#LinearAlgebra.BLAS.set_num_threads&quot;&gt;&lt;code&gt;BLAS.set_num_threads(n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;peakflops&lt;/code&gt; вычисляет пиковую скорость флопа компьютера с помощью gemm двойной точности &lt;a href=&quot;#LinearAlgebra.BLAS.gemm!&quot;&gt; &lt;code&gt;gemm!&lt;/code&gt; &lt;/a&gt;, По умолчанию, если аргументы не указаны, он умножает матрицу размера &lt;code&gt;n x n&lt;/code&gt; , где &lt;code&gt;n = 2000&lt;/code&gt; . Если базовый BLAS использует несколько потоков, реализуются более высокие ставки флопа. Количество потоков BLAS можно установить с помощью &lt;a href=&quot;#LinearAlgebra.BLAS.set_num_threads&quot;&gt; &lt;code&gt;BLAS.set_num_threads(n)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87b91990e60f0a690dd7da2850cc5ea9cee3bec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perfdata_cb&lt;/code&gt;: An optional callback function to display performance data.</source>
          <target state="translated">&lt;code&gt;perfdata_cb&lt;/code&gt; : дополнительная функция обратного вызова для отображения данных о производительности.</target>
        </trans-unit>
        <trans-unit id="e9d2d97fa30fe0159febc55e5a72c5956e0c05f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perfdata_payload&lt;/code&gt;: Payload for the performance callback.</source>
          <target state="translated">&lt;code&gt;perfdata_payload&lt;/code&gt; : полезная нагрузка для обратного вызова производительности.</target>
        </trans-unit>
        <trans-unit id="c5c86680e44cfade629b4ed2ebc1670d3a11ff31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pmap&lt;/code&gt; can also use a mix of processes and tasks via the &lt;code&gt;batch_size&lt;/code&gt; argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length &lt;code&gt;batch_size&lt;/code&gt; or less. A batch is sent as a single request to a free worker, where a local &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt; processes elements from the batch using multiple concurrent tasks.</source>
          <target state="translated">&lt;code&gt;pmap&lt;/code&gt; также может использовать сочетание процессов и задач с помощью аргумента &lt;code&gt;batch_size&lt;/code&gt; . Для пакетов размером больше 1, коллекция обрабатывается несколькими пакетами, длина каждого из которых составляет &lt;code&gt;batch_size&lt;/code&gt; или меньше. Пакет отправляется как один запрос бесплатному &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt; , где локальный asyncmap обрабатывает элементы из пакета, используя несколько одновременных задач.</target>
        </trans-unit>
        <trans-unit id="a6062089bc8ea7356a1c0e294144b992c9b0d190" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port::Union{AbstractString,Integer}=&quot;&quot;&lt;/code&gt;: the port number to use in the output if provided. Cannot be specified when using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;port::Union{AbstractString,Integer}=&quot;&quot;&lt;/code&gt; : номер порта для использования в выводе, если он указан. Не может быть указан при использовании синтаксиса, подобного scp.</target>
        </trans-unit>
        <trans-unit id="3926b6e41c21bebec38e3305ee3aef86c0f67cdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; &amp;ndash; the port on the host used to connect to the worker (either an &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; - порт на хосте, используемый для подключения к работнику (либо &lt;code&gt;Int&lt;/code&gt; , либо &lt;code&gt;Nothing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d7ae02e4311ab0f64e68f548cb0826d87786e864" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;power_method&lt;/code&gt; repeatedly creates a new vector and normalizes it. We have not specified any type signature in function declaration, let's see if it works with the aforementioned datatypes:</source>
          <target state="translated">&lt;code&gt;power_method&lt;/code&gt; многократно создает новый вектор и нормализует его. Мы не указали сигнатуру типа в объявлении функции, давайте посмотрим, работает ли она с вышеупомянутыми типами данных:</target>
        </trans-unit>
        <trans-unit id="9113fbab087ead22351138a5675e71d4cc277d28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precision&lt;/code&gt; as a keyword argument requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;precision&lt;/code&gt; is the second positional argument (&lt;code&gt;BigFloat(x, precision)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;precision&lt;/code&gt; в качестве аргумента ключевого слова требует, по крайней мере, Julia 1.1. В Julia 1.0 &lt;code&gt;precision&lt;/code&gt; - это второй позиционный аргумент ( &lt;code&gt;BigFloat(x, precision)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af54082b04f05e356fa41312f4ae5ca97f259a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive type&lt;/code&gt; declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:</source>
          <target state="translated">&lt;code&gt;primitive type&lt;/code&gt; объявляет конкретный тип, данные которого состоят только из серии битов. Классическими примерами примитивных типов являются целые числа и значения с плавающей запятой. Некоторые примеры объявлений встроенных примитивных типов:</target>
        </trans-unit>
        <trans-unit id="d408d986573283a26cbda182d85b826b49383c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive type&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;primitive type&lt;/code&gt; Keyword</target>
        </trans-unit>
        <trans-unit id="ce0cc2b360368626a735bd2ae5d7c2a083fbb6e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; &quot;lock&quot; the stream during a call. Consequently changing &lt;code&gt;write&lt;/code&gt; to &lt;code&gt;println&lt;/code&gt; in the above example results in:</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; и &lt;code&gt;println&lt;/code&gt; &amp;laquo;блокируют&amp;raquo; поток во время разговора. Следовательно, изменение &lt;code&gt;write&lt;/code&gt; на &lt;code&gt;println&lt;/code&gt; в приведенном выше примере приводит к:</target>
        </trans-unit>
        <trans-unit id="1959b9f7871b156edd3a2de5e77463b33177e392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; falls back to calling &lt;code&gt;show&lt;/code&gt;, so most types should just define &lt;code&gt;show&lt;/code&gt;. Define &lt;code&gt;print&lt;/code&gt; if your type has a separate &quot;plain&quot; representation. For example, &lt;code&gt;show&lt;/code&gt; displays strings with quotes, and &lt;code&gt;print&lt;/code&gt; displays strings without quotes.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; возвращается к вызову &lt;code&gt;show&lt;/code&gt; , поэтому большинство типов должны просто определять &lt;code&gt;show&lt;/code&gt; . Определите &lt;code&gt;print&lt;/code&gt; если ваш тип имеет отдельное &quot;простое&quot; представление. Например, &lt;code&gt;show&lt;/code&gt; отображает строки в кавычках, а &lt;code&gt;print&lt;/code&gt; отображает строки без кавычек.</target>
        </trans-unit>
        <trans-unit id="d0178c5df89eb967f462cc2e8445f025988bec10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;process&lt;/code&gt; &amp;ndash; the process which will be connected (usually the manager will assign this during &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; - процесс, который будет подключен (обычно менеджер назначает это во время &lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c63a4f1761d5adacd1e7460b66b481bd63cdd398" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_cb&lt;/code&gt;: An optional callback function to display checkout progress.</source>
          <target state="translated">&lt;code&gt;progress_cb&lt;/code&gt; : дополнительная функция обратного вызова для отображения хода оформления заказа.</target>
        </trans-unit>
        <trans-unit id="7cb6a0f147459271d2a7a2a1bcb82b298199436d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_cb&lt;/code&gt;: optional callback which will display diff progress. Only relevant on libgit2 versions at least as new as 0.24.0.</source>
          <target state="translated">&lt;code&gt;progress_cb&lt;/code&gt; : дополнительный обратный вызов, который будет отображать прогресс сравнения. Актуально только для версий libgit2 не ниже 0.24.0.</target>
        </trans-unit>
        <trans-unit id="a974da56e773f57fa11edfba525b0d17e70b3e1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_payload&lt;/code&gt;: Payload for the progress callback.</source>
          <target state="translated">&lt;code&gt;progress_payload&lt;/code&gt; : полезная нагрузка для обратного вызова прогресса.</target>
        </trans-unit>
        <trans-unit id="9656c555e40a59798ca04ab2a0fd64ef8fcd145d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propertynames(x)&lt;/code&gt; may return only &quot;public&quot; property names that are part of the documented interface of &lt;code&gt;x&lt;/code&gt;. If you want it to also return &quot;private&quot; fieldnames intended for internal use, pass &lt;code&gt;true&lt;/code&gt; for the optional second argument. REPL tab completion on &lt;code&gt;x.&lt;/code&gt; shows only the &lt;code&gt;private=false&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;propertynames(x)&lt;/code&gt; может возвращать только &amp;laquo;общедоступные&amp;raquo; имена свойств, которые являются частью документированного интерфейса &lt;code&gt;x&lt;/code&gt; . Если вы хотите, чтобы он также возвращал &amp;laquo;частные&amp;raquo; имена полей, предназначенные для внутреннего использования, передайте значение &lt;code&gt;true&lt;/code&gt; для необязательного второго аргумента. Завершение вкладки REPL на &lt;code&gt;x.&lt;/code&gt; показывает только свойства &lt;code&gt;private=false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29d345329a2391a60fb2ebd4642c5f13f15f3a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy_opts&lt;/code&gt;: only relevant if the LibGit2 version is greater than or equal to &lt;code&gt;0.25.0&lt;/code&gt;. Sets options for using a proxy to communicate with a remote. See &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt;&lt;code&gt;ProxyOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;proxy_opts&lt;/code&gt; : актуально, только если версия LibGit2 больше или равна &lt;code&gt;0.25.0&lt;/code&gt; . Устанавливает параметры использования прокси для связи с удаленным. См. &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt; &lt;code&gt;ProxyOptions&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2a1c2878a9100523ed8ddcdc2ca50b8e3e3accca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy_opts&lt;/code&gt;: options for connecting to the remote through a proxy. See &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt;&lt;code&gt;ProxyOptions&lt;/code&gt;&lt;/a&gt;. Only present on libgit2 versions newer than or equal to 0.25.0.</source>
          <target state="translated">&lt;code&gt;proxy_opts&lt;/code&gt; : варианты подключения к удаленному через прокси. См. &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt; &lt;code&gt;ProxyOptions&lt;/code&gt; &lt;/a&gt; . Присутствует только в версиях libgit2 новее или равных 0.25.0.</target>
        </trans-unit>
        <trans-unit id="2d1cca20f02fc7ef7b42d7136de423456f81b239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxytype&lt;/code&gt;: an &lt;code&gt;enum&lt;/code&gt; for the type of proxy to use. Defined in &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_proxy_t&quot;&gt;&lt;code&gt;git_proxy_t&lt;/code&gt;&lt;/a&gt;. The corresponding Julia enum is &lt;code&gt;GIT_PROXY&lt;/code&gt; and has values:</source>
          <target state="translated">&lt;code&gt;proxytype&lt;/code&gt; : &lt;code&gt;enum&lt;/code&gt; для типа используемого прокси. Определено в &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_proxy_t&quot;&gt; &lt;code&gt;git_proxy_t&lt;/code&gt; &lt;/a&gt; . Соответствующее перечисление Julia - &lt;code&gt;GIT_PROXY&lt;/code&gt; и имеет значения:</target>
        </trans-unit>
        <trans-unit id="7c30e484bc5a233582234aa0eaf5f9ff4b81c5cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prune&lt;/code&gt;: whether to perform a prune after the fetch or not. The default is to use the setting from the &lt;code&gt;GitConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; : выполнять ли обрезку после выборки или нет. По умолчанию используется настройка из &lt;code&gt;GitConfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d39971bfff573dc1ff9e1372624b262b5a7768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put!&lt;/code&gt; - put back a worker to the available pool</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; - вернуть воркера в доступный пул</target>
        </trans-unit>
        <trans-unit id="a29ba5aea9b5cc34e1af996fefeb1a63d0872750" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d064f8a98d481de062cba01c97539bfc2f0871d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;StridedMatrix&lt;/code&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;code&gt;qr!&lt;/code&gt; то же самое, что и &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; ,&lt;/a&gt; когда &lt;code&gt;A&lt;/code&gt; является подтипом &lt;code&gt;StridedMatrix&lt;/code&gt; , но экономит место, перезаписывая вход &lt;code&gt;A&lt;/code&gt; , вместо создания копии. &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; исключение , если разложение производит ряд не представим типом элемента &lt;code&gt;A&lt;/code&gt; , например , для целочисленных типов.</target>
        </trans-unit>
        <trans-unit id="cf9e4bad0fd4a4794a48064d48581af7033259a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr&lt;/code&gt; returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; matrices can be stored compactly rather as two separate dense matrices.</source>
          <target state="translated">&lt;code&gt;qr&lt;/code&gt; возвращает несколько типов, потому что LAPACK использует несколько представлений, которые минимизируют требования к памяти для хранения продуктов элементарных отражателей Хаусхолдера, так что матрицы &lt;code&gt;Q&lt;/code&gt; и &lt;code&gt;R&lt;/code&gt; могут храниться компактно, а не как две отдельные плотные матрицы.</target>
        </trans-unit>
        <trans-unit id="fe298f4b4614717693aba0cf7548649332f44a5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qsort&lt;/code&gt; expects a comparison function that return a C &lt;code&gt;int&lt;/code&gt;, so we annotate the return type to be &lt;code&gt;Cint&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b9466c550831a8245833d9e56b4ae895f63c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quiet&lt;/code&gt;: inform other git clients helping with/working on the rebase that the rebase should be done &quot;quietly&quot;. Used for interoperability. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;quiet&lt;/code&gt; : сообщить другим клиентам git, помогающим / работающим с перебазированием, что перебазирование должно выполняться &amp;laquo;тихо&amp;raquo;. Используется для взаимодействия. По умолчанию &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89148ab980d30701194964666d016c3558cde6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt; creates multiple expression objects in a block without using the explicit &lt;a href=&quot;#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. For example:</source>
          <target state="translated">&lt;code&gt;quote&lt;/code&gt; создает несколько объектов выражения в блоке без использования явного конструктора &lt;a href=&quot;#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="1f3b9755167388bcf3471ba197b6c40b6008de5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;quote&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9096a143fba87878f860ce663f000649f6400ccc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; produces a regular expression object rather than a string</source>
          <target state="translated">&lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; создает объект регулярного выражения, а не строку</target>
        </trans-unit>
        <trans-unit id="6ec672446bd53c264182855affbe5a78b442fb6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;: restricts operations to the buffer; see &lt;code&gt;open&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;append&lt;/code&gt; : ограничивает операции буфером; см &lt;code&gt;open&lt;/code&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="ecf721b9c658fe1430c1a0d12d81daeb2549a2e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recur&lt;/code&gt; &amp;ndash; Controls the recursion handling in &lt;code&gt;:tree&lt;/code&gt; format. &lt;code&gt;:off&lt;/code&gt; (default) prints the tree as normal. &lt;code&gt;:flat&lt;/code&gt; instead compresses any recursion (by ip), showing the approximate effect of converting any self-recursion into an iterator. &lt;code&gt;:flatc&lt;/code&gt; does the same but also includes collapsing of C frames (may do odd things around &lt;code&gt;jl_apply&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fbd8f3deb831b9f5ec8b1264c745debaec29b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursion_limit&lt;/code&gt;: the upper limit on the number of merges of common ancestors to perform to try to build a new virtual merge base for the merge. The default is no limit. This field is only present on libgit2 versions newer than 0.24.0.</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; : верхний предел количества слияний общих предков, которые необходимо выполнить, чтобы попытаться создать новую виртуальную базу слияния для слияния. По умолчанию ограничений нет. Это поле присутствует только в версиях libgit2 новее 0.24.0.</target>
        </trans-unit>
        <trans-unit id="e3223e9226e352a329b29a7eace6c1d31eb0a618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refname::AbstractString=Consts.HEAD_FILE&lt;/code&gt;: if not NULL, the name of the reference to update to point to the new commit. For example, &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; will update the HEAD of the current branch. If the reference does not yet exist, it will be created.</source>
          <target state="translated">&lt;code&gt;refname::AbstractString=Consts.HEAD_FILE&lt;/code&gt; : если не NULL, имя ссылки для обновления, указывающей на новую фиксацию. Например, &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; обновит HEAD текущей ветки. Если ссылка еще не существует, она будет создана.</target>
        </trans-unit>
        <trans-unit id="7c7e2623afd5bf4ea28699952aaf1e41bf326a1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt;: determines properties of the fetch.</source>
          <target state="translated">&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt; : определяет свойства выборки.</target>
        </trans-unit>
        <trans-unit id="cad51a938d649503c2ef46d1225a6fc56968236e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt;: determines properties of the push.</source>
          <target state="translated">&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt; : определяет свойства выталкивания.</target>
        </trans-unit>
        <trans-unit id="789e0d7504799b3b38c290db69c2914eaa79a006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rejectna=true&lt;/code&gt;: throw an error if unassigned code points are found</source>
          <target state="translated">&lt;code&gt;rejectna=true&lt;/code&gt; : выдает ошибку при обнаружении неназначенных кодовых точек</target>
        </trans-unit>
        <trans-unit id="47c34491f7ee239ad33defe253fb1defd64e8594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt;: the name of the upstream remote to push to.</source>
          <target state="translated">&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt; : имя вышестоящего удаленного сервера, на который выполняется отправка.</target>
        </trans-unit>
        <trans-unit id="4b26ba19c7207aa3b208454b432a26db97e4da0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt;: which remote, specified by name, of &lt;code&gt;repo&lt;/code&gt; to fetch from. If this is empty, the URL will be used to construct an anonymous remote.</source>
          <target state="translated">&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt; : с какого удаленного &lt;code&gt;repo&lt;/code&gt; , указанного по имени, выполнить выборку. Если он пуст, URL-адрес будет использоваться для создания анонимного пульта дистанционного управления.</target>
        </trans-unit>
        <trans-unit id="ffdcacc6e1483f4d462c34f2bea9360ca75d4db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb::Ptr{Cvoid}=C_NULL&lt;/code&gt;: a callback which will be used to create the remote before it is cloned. If &lt;code&gt;C_NULL&lt;/code&gt; (the default), no attempt will be made to create the remote - it will be assumed to already exist.</source>
          <target state="translated">&lt;code&gt;remote_cb::Ptr{Cvoid}=C_NULL&lt;/code&gt; : обратный вызов, который будет использоваться для создания удаленного устройства перед его клонированием. Если &lt;code&gt;C_NULL&lt;/code&gt; (по умолчанию), не будет предпринято никаких попыток создать пульт - предполагается, что он уже существует.</target>
        </trans-unit>
        <trans-unit id="81f2145109807b12c478f9428b7d01692494e503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb&lt;/code&gt;: An optional callback used to create the &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt;&lt;code&gt;GitRemote&lt;/code&gt;&lt;/a&gt; before making the clone from it.</source>
          <target state="translated">&lt;code&gt;remote_cb&lt;/code&gt; : дополнительный обратный вызов, используемый для создания &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt; &lt;code&gt;GitRemote&lt;/code&gt; &lt;/a&gt; перед созданием из него клона.</target>
        </trans-unit>
        <trans-unit id="08210342f9819d0a52928951c3cf701a468f0a0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb_payload&lt;/code&gt;: The payload for the remote callback.</source>
          <target state="translated">&lt;code&gt;remote_cb_payload&lt;/code&gt; : полезная нагрузка для удаленного обратного вызова.</target>
        </trans-unit>
        <trans-unit id="0b84ddfb974082fe30d2fdbc1437b3f617f6a788" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteref_id&lt;/code&gt; is a low-level API which returns a &lt;code&gt;RRID&lt;/code&gt; object that wraps &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; values of a remote reference.</source>
          <target state="translated">&lt;code&gt;remoteref_id&lt;/code&gt; - это низкоуровневый API, который возвращает объект &lt;code&gt;RRID&lt;/code&gt; , который обертывает значения &lt;code&gt;whence&lt;/code&gt; и &lt;code&gt;id&lt;/code&gt; удаленной ссылки.</target>
        </trans-unit>
        <trans-unit id="8507e85a94a6cd1cb8268156f73c57a12952c455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : URL-адрес &lt;code&gt;remote&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af1618648ef5cfe8bc793d28a4d2646feb098771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;. If not specified, will be assumed based on the given name of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : URL-адрес &lt;code&gt;remote&lt;/code&gt; . Если не указано, будет предполагаться на основе заданного имени &lt;code&gt;remote&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="609e8e82126a8aeb5967ff81fbb3ef2aa24bd998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename_threshold&lt;/code&gt;: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.</source>
          <target state="translated">&lt;code&gt;rename_threshold&lt;/code&gt; : насколько похожие два файла должны рассматривать один как переименование другого. Это целое число, задающее процентное сходство. По умолчанию - 50.</target>
        </trans-unit>
        <trans-unit id="a1f245ca6c95e5deef1b0ce6ee0330ae1e9c18b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repetition&lt;/code&gt; can be &lt;code&gt;Val(1)&lt;/code&gt; or &lt;code&gt;Val(Inf)&lt;/code&gt;, and should be used as a suggestion for deciding the amount of precomputation, if applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a99cf9dace7b445312c1ed6b449e6eaff870cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb&lt;/code&gt;: An optional callback which will be used to create the &lt;em&gt;new&lt;/em&gt; repository into which the clone is made.</source>
          <target state="translated">&lt;code&gt;repository_cb&lt;/code&gt; : необязательный обратный вызов, который будет использоваться для создания &lt;em&gt;нового&lt;/em&gt; репозитория, в котором будет сделан клон.</target>
        </trans-unit>
        <trans-unit id="69b143fd85b9454789782c1eb3c8d602eb3b9b29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb_payload&lt;/code&gt;: The payload for the repository callback.</source>
          <target state="translated">&lt;code&gt;repository_cb_payload&lt;/code&gt; : полезная нагрузка для обратного вызова репозитория.</target>
        </trans-unit>
        <trans-unit id="5023aea211818a0760fb42fd29ef6a5a0289aa0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repr&lt;/code&gt; returns the output of &lt;code&gt;show&lt;/code&gt; as a string.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; возвращает вывод &lt;code&gt;show&lt;/code&gt; в виде строки.</target>
        </trans-unit>
        <trans-unit id="7ff0db60e6e9b0f8032c3c60e6fb8dfbe0818b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return x&lt;/code&gt; causes the enclosing function to exit early, passing the given value &lt;code&gt;x&lt;/code&gt; back to its caller. &lt;code&gt;return&lt;/code&gt; by itself with no value is equivalent to &lt;code&gt;return nothing&lt;/code&gt; (see &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;return x&lt;/code&gt; заставляет включающую функцию выйти раньше, передавая заданное значение &lt;code&gt;x&lt;/code&gt; обратно вызывающей стороне. Сам по себе &lt;code&gt;return&lt;/code&gt; без значения эквивалентен отсутствию &lt;code&gt;return nothing&lt;/code&gt; ( &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; не вижу ).</target>
        </trans-unit>
        <trans-unit id="502272392029d8c1210ca8442ce973a51a80b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="45cec38c32f578811af123b4529c8927598f6954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite_notes_ref&lt;/code&gt;: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.</source>
          <target state="translated">&lt;code&gt;rewrite_notes_ref&lt;/code&gt; : имя ссылки на примечания, которое будет использоваться для перезаписи примечаний к фиксации по завершении перебазирования.</target>
        </trans-unit>
        <trans-unit id="ee12f97ff2f79dfd78b89cda4ab0e281561a61af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right_justify&lt;/code&gt; is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).</source>
          <target state="translated">&lt;code&gt;right_justify&lt;/code&gt; - это целочисленный столбец, в котором метаданные журнала выровнены по правому краю . По умолчанию - ноль (метаданные размещаются в отдельной строке).</target>
        </trans-unit>
        <trans-unit id="b331dc2677ed78e2b46e6f7e4f15579bf2430629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.ceil&quot;&gt;&lt;code&gt;ceil&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; с использованием этого режима округления является псевдонимом для &lt;a href=&quot;#Base.ceil&quot;&gt; &lt;code&gt;ceil&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b82694560cc17d932ed74b0e5a76969bf6a0851b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; с использованием этого режима округления является псевдонимом для &lt;a href=&quot;#Base.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6064aeb0303df233165e5be4f2a31b0e19b1991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.trunc&quot;&gt;&lt;code&gt;trunc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; с использованием этого режима округления является псевдонимом для &lt;a href=&quot;#Base.trunc&quot;&gt; &lt;code&gt;trunc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4f32289fec3fa365e6110d93226bbad2f67917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; allows the &lt;code&gt;.&lt;/code&gt; modifier to match newlines.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; позволяет &lt;code&gt;.&lt;/code&gt; модификатор для соответствия новой строке.</target>
        </trans-unit>
        <trans-unit id="f9a850a68210f1321a24f7f9f7751b659bc2b984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sB&lt;/code&gt; has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</source>
          <target state="translated">&lt;code&gt;sB&lt;/code&gt; был помечен как (действительная) симметричная матрица, поэтому для последующих операций, которые мы могли бы выполнить с ней, таких как собственное разложение или вычисление произведения матрица-вектор, эффективность можно определить, указав только половину ее. Например:</target>
        </trans-unit>
        <trans-unit id="ccc484e194571496ce1eda5190c7d8120eefadd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt;: the URL scheme which identifies the protocol to be used. For HTTP use &quot;http&quot;, SSH use &quot;ssh&quot;, etc. When &lt;code&gt;scheme&lt;/code&gt; is not provided the output format will be &quot;ssh&quot; but using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt; : схема URL, которая определяет используемый протокол. Для HTTP используйте &amp;laquo;http&amp;raquo;, SSH используйте &amp;laquo;ssh&amp;raquo; и т. Д. Если &lt;code&gt;scheme&lt;/code&gt; не указана, формат вывода будет &amp;laquo;ssh&amp;raquo;, но с использованием синтаксиса, подобного scp.</target>
        </trans-unit>
        <trans-unit id="93b2806e781d6fca17b7143cb112498a0b664a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scroll::Symbol=:na&lt;/code&gt;: If &lt;code&gt;:wrap&lt;/code&gt; then wrap the cursor around top and bottom, if :&lt;code&gt;nowrap&lt;/code&gt; do not wrap cursor</source>
          <target state="translated">&lt;code&gt;scroll::Symbol=:na&lt;/code&gt; : If &lt;code&gt;:wrap&lt;/code&gt; тогда обтекать курсор сверху и снизу, if: &lt;code&gt;nowrap&lt;/code&gt; не переносить курсор</target>
        </trans-unit>
        <trans-unit id="4b280689ba075d50a8bf44f6918ee06bdd7f1ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_head::Bool=true&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, after the branch creation finishes the branch head will be set as the HEAD of &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_head::Bool=true&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , то после завершения создания ветки заголовок ветки будет установлен как HEAD &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cc61ed461b5dbaa13fd1fd838ddca4a2542572c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; can speed up some computations on some hardware. However, it can break identities such as &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; может ускорить некоторые вычисления на некотором оборудовании. Однако он может нарушить такие идентификаторы, как &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2e75ceadb77395d5345eca4bc8bc47dec72358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shaxxx()&lt;/code&gt; takes &lt;code&gt;AbstractString&lt;/code&gt; and array-like objects (&lt;code&gt;NTuple&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;) with elements of type &lt;code&gt;UInt8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shaxxx()&lt;/code&gt; принимает &lt;code&gt;AbstractString&lt;/code&gt; и объекты &lt;code&gt;NTuple&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; ( NTuple и Array ) с элементами типа &lt;code&gt;UInt8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ec3df759f8c80bc7761d61c8e5aa7aa26b8f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show&lt;/code&gt;: a flag for which files to examine and in which order. The default is &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; : флаг, какие файлы проверять и в каком порядке. По умолчанию - &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a32266a7567a6361fd0030ea46dc886158ce573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt;: if no matching reference can be found which describes a commit, show the commit's &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; instead of throwing an error (the default behavior).</source>
          <target state="translated">&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt; : если не может быть найдена соответствующая ссылка, описывающая фиксацию, показать &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; фиксации&lt;/a&gt; вместо выдачи ошибки (поведение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="321d9936b85b091cfbe32e4ed333aa1019f70153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_limited&lt;/code&gt; limits the printing of large data structures to something which can fit on the screen by setting the &lt;code&gt;:limit&lt;/code&gt;&lt;code&gt;IOContext&lt;/code&gt; key during formatting.</source>
          <target state="translated">&lt;code&gt;show_limited&lt;/code&gt; ограничивает печать больших структур данных чем-то, что может поместиться на экране, путем установки ключа &lt;code&gt;:limit&lt;/code&gt; &lt;code&gt;IOContext&lt;/code&gt; во время форматирования.</target>
        </trans-unit>
        <trans-unit id="eb77d8781dd9b346f7972d289b6b8d6656b27a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt;: the tagger's signature.</source>
          <target state="translated">&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt; : подпись теггера.</target>
        </trans-unit>
        <trans-unit id="d753c86afdec45711bc5c02d99a4e474cd4a4e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;similarity&lt;/code&gt;: Used to indicate if a file has been renamed or copied.</source>
          <target state="translated">&lt;code&gt;similarity&lt;/code&gt; : используется, чтобы указать, был ли файл переименован или скопирован.</target>
        </trans-unit>
        <trans-unit id="ff10e5c77568c1b5f3ae641f11c70c8c65f4ba74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7997da896750d945cfa8c2d3cb4698bd3a261b9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10f869613b60c50f32f40c9033fbe46c6290e23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt;: the size of the item in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; : размер элемента в байтах.</target>
        </trans-unit>
        <trans-unit id="5477a94f16fd95259abdf4ec79e87fa8ddde3d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizehint&lt;/code&gt;: suggests a capacity of the buffer (&lt;code&gt;data&lt;/code&gt; must implement &lt;code&gt;sizehint!(data, size)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sizehint&lt;/code&gt; : предлагает емкость буфера ( &lt;code&gt;data&lt;/code&gt; должны реализовывать &lt;code&gt;sizehint!(data, size)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8c3ba1857a9b0055e1e04c56e79b38b776b38ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples, and &lt;code&gt;:overhead&lt;/code&gt; sorts by the number of samples incurred by each function by itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b3de6bcf724e5eb7a7cd993fb64be110536dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, whereas &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples.</source>
          <target state="translated">&lt;code&gt;sortedby&lt;/code&gt; - контролирует порядок в &lt;code&gt;:flat&lt;/code&gt; формате. &lt;code&gt;:filefuncline&lt;/code&gt; (по умолчанию) сортирует по строке исходного текста , тогда как &lt;code&gt;:count&lt;/code&gt; сортирует по количеству собранных выборок.</target>
        </trans-unit>
        <trans-unit id="9ab7b3a3ab6403e446642819fa1d378711eeccfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortslices&lt;/code&gt; extends naturally to higher dimensions. E.g., if &lt;code&gt;A&lt;/code&gt; is a a 2x2x2 array, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; will sort slices within the 3rd dimension, passing the 2x2 slices &lt;code&gt;A[:, :, 1]&lt;/code&gt; and &lt;code&gt;A[:, :, 2]&lt;/code&gt; to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the &lt;code&gt;by&lt;/code&gt; or &lt;code&gt;lt&lt;/code&gt; keyword argument to specify such an order.</source>
          <target state="translated">&lt;code&gt;sortslices&lt;/code&gt; естественным образом распространяется на более высокие измерения. Например, если &lt;code&gt;A&lt;/code&gt; представляет собой массив 2x2x2, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; будет сортировать фрагменты в 3-м измерении, передавая фрагменты 2x2 &lt;code&gt;A[:, :, 1]&lt;/code&gt; и &lt;code&gt;A[:, :, 2]&lt;/code&gt; в функцию сравнения. , Обратите внимание, что хотя для многомерных срезов нет порядка по умолчанию, вы можете использовать аргумент ключевого слова &lt;code&gt;by&lt;/code&gt; или &lt;code&gt;lt&lt;/code&gt; , чтобы указать такой порядок.</target>
        </trans-unit>
        <trans-unit id="4951048c7ac40b21df3d0f006898cdcb02270fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spec&lt;/code&gt; is a textual specification: see &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;the git docs&lt;/a&gt; for a full list.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; - это текстовая спецификация: полный список см. &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;в документации git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f04859a49c065ca19fcdcec7b6d599fc9662e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqrt(x)&lt;/code&gt;, &lt;code&gt;&amp;radic;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqrt(x)&lt;/code&gt; , &lt;code&gt;&amp;radic;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1844a8d2cb0ff3056c35be76a61b67e6353a981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; flags to use in establishing the SSH connection</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; - флаги для использования при установлении SSH-соединения</target>
        </trans-unit>
        <trans-unit id="7a4e3e2ec23bd08e30d9fd3aad5785bb62849893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt;: specifies additional ssh options, e.g. &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt;`</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; : Определяет дополнительные параметры SSH, например &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="482b777392d5aea02672e566aeba40602b1e6b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode Versioning Stability</source>
          <target state="translated">&lt;code&gt;stable=true&lt;/code&gt; : обеспечить стабильность управления версиями Unicode</target>
        </trans-unit>
        <trans-unit id="c3f34cc201b5d8b2b94a13ec51d0f5a9bea4d457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode versioning stability (never introduce characters missing from earlier Unicode versions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d673d269bddb99403b4804cd814dccb535526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_worker&lt;/code&gt; is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</source>
          <target state="translated">&lt;code&gt;start_worker&lt;/code&gt; - это внутренняя функция, которая является точкой входа по умолчанию для рабочих процессов, подключающихся через TCP / IP. Он настраивает процесс как рабочий кластера Julia.</target>
        </trans-unit>
        <trans-unit id="0d39313a7b53c31deacd642a6f563eef785766ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startswith&lt;/code&gt; does not compile the anchoring into the regular expression, but instead passes the anchoring as &lt;code&gt;match_option&lt;/code&gt; to PCRE. If compile time is amortized, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; is faster than &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startswith&lt;/code&gt; не компилирует привязку в регулярное выражение, а вместо этого передает привязку как &lt;code&gt;match_option&lt;/code&gt; в PCRE. Если во время компиляции амортизируется, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; быстрее , чем &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15339811e6d33db9e7897efcdd503d8c3b49eea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: One of &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt;, indicating whether the file has been added/modified/deleted.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : один из &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt; , указывающий, был ли файл добавлен / изменен / удален.</target>
        </trans-unit>
        <trans-unit id="593409fff5972acd2d5fc66532b51e6073c0482a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : содержит флаги состояния для файла, указывающие, является ли он текущим или каким-либо образом был изменен в индексе или рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="7130447a57fb8968eccd9497b959129d184d5ebe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; as a positional argument requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; как позиционный аргумент требует как минимум Юлии 1.1.</target>
        </trans-unit>
        <trans-unit id="d0f59bf23005820bb215225956bc86d1eabe9e2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; may be specified as either a positional or keyword argument.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; может быть указан как позиционный аргумент или как ключевое слово.</target>
        </trans-unit>
        <trans-unit id="e12b59a2409adf775bb3ba9ebdfd0542b9cb0251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream&lt;/code&gt; must be a &lt;code&gt;TTY&lt;/code&gt;, a &lt;code&gt;Pipe&lt;/code&gt;, or a socket.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; должен быть &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;Pipe&lt;/code&gt; или сокетом.</target>
        </trans-unit>
        <trans-unit id="92d2aefd112ecb4c0e212056a16040530a1c9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; should usually not be defined directly. Instead, define a method &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt;. If &lt;code&gt;string(x)&lt;/code&gt; for a certain type needs to be highly efficient, then it may make sense to add a method to &lt;code&gt;string&lt;/code&gt; and define &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; to ensure the functions are consistent.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; обычно не следует определять напрямую. Вместо этого определите метод &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt; . Если &lt;code&gt;string(x)&lt;/code&gt; для определенного типа должна быть высокоэффективной, тогда может иметь смысл добавить метод в &lt;code&gt;string&lt;/code&gt; и определить &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; чтобы обеспечить согласованность функций.</target>
        </trans-unit>
        <trans-unit id="3a0a1bd4f366a04445c7d0b5b5d4912e1e3e7619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strings&lt;/code&gt; can be any iterable over elements &lt;code&gt;x&lt;/code&gt; which are convertible to strings via &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt;. &lt;code&gt;strings&lt;/code&gt; will be printed to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; могут быть любыми итерациями по элементам &lt;code&gt;x&lt;/code&gt; , которые можно преобразовать в строки с помощью &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt; . &lt;code&gt;strings&lt;/code&gt; будут напечатаны в &lt;code&gt;io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03d10d2948fe43796bacbfe30f1e399090a85dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripcc=true&lt;/code&gt;: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</source>
          <target state="translated">&lt;code&gt;stripcc=true&lt;/code&gt; : убрать управляющие символы; горизонтальные табуляции и подача форм преобразуются в пробелы; новые строки также преобразуются в пробелы, если не указан флаг преобразования новой строки</target>
        </trans-unit>
        <trans-unit id="348e9291c5b543afc5d72a87490213ecd8d4eb07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripignore=true&lt;/code&gt;: strip Unicode's &quot;default ignorable&quot; characters (e.g. the soft hyphen or the left-to-right marker)</source>
          <target state="translated">&lt;code&gt;stripignore=true&lt;/code&gt; : убрать &amp;laquo;игнорируемые по умолчанию&amp;raquo; символы Unicode (например, мягкий дефис или маркер слева направо)</target>
        </trans-unit>
        <trans-unit id="ea8af5006099bc8365d7c8c2016e824fc2c530ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripmark=true&lt;/code&gt;: strip diacritical marks (e.g. accents)</source>
          <target state="translated">&lt;code&gt;stripmark=true&lt;/code&gt; : убрать диакритические знаки (например, акценты)</target>
        </trans-unit>
        <trans-unit id="152fe4fc303b0a193c1b742fe9f4ede9b98c674b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct T&lt;/code&gt; (including typedef to a struct)</source>
          <target state="translated">&lt;code&gt;struct T&lt;/code&gt; (включая typedef для структуры)</target>
        </trans-unit>
        <trans-unit id="c56e50a4a868cc2df17e58d4812fe396996de54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="ba2cc4e0e66a121d0318b71f9b1e31d8945e78e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;s are immutable by default; an instance of one of these types cannot be modified after construction. Use &lt;a href=&quot;#mutable%20struct&quot;&gt;&lt;code&gt;mutable struct&lt;/code&gt;&lt;/a&gt; instead to declare a type whose instances can be modified.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; s по умолчанию неизменяемы; экземпляр одного из этих типов не может быть изменен после построения. Вместо этого используйте &lt;a href=&quot;#mutable%20struct&quot;&gt; &lt;code&gt;mutable struct&lt;/code&gt; &lt;/a&gt; чтобы объявить тип, экземпляры которого можно изменять.</target>
        </trans-unit>
        <trans-unit id="13e850a37abc68848cc3b254dc2d22440b355863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supertype operator&lt;/code&gt; (reverse of subtype operator)</source>
          <target state="translated">&lt;code&gt;supertype operator&lt;/code&gt; (обратный оператору подтипа)</target>
        </trans-unit>
        <trans-unit id="cc1fbbda24d7f513ea72de9ed041f7b7a1294c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supress_output::Bool=false&lt;/code&gt;: For testing. If true, menu will not be printed to console.</source>
          <target state="translated">&lt;code&gt;supress_output::Bool=false&lt;/code&gt; : для тестирования. Если true, меню не будет выводиться на консоль.</target>
        </trans-unit>
        <trans-unit id="865fee67603befce1b0155fd32588cd0eea3727b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; то же самое, что и &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; , но изменяет аргументы &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; на месте, а не копирует.</target>
        </trans-unit>
        <trans-unit id="5ac943a1020666f7a7da5c2717895ed9dd7a951a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies. See documentation of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; for details. ```</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f1a2a22493ae52966dc56d654ec748102e1aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; то же самое, что и &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; , но экономит место за счет перезаписи ввода &lt;code&gt;A&lt;/code&gt; вместо создания копии.</target>
        </trans-unit>
        <trans-unit id="2f443b46f49f7a0ffb67743e11d80b3fef2023d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. See documentation of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; for details. ```</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f8b179c1cd1baf106b501d9f23e6788334be4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; - take a worker from the available pool (to be used for remote function execution)</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; - взять воркера из доступного пула (для удаленного выполнения функции)</target>
        </trans-unit>
        <trans-unit id="fbcd6c4d67df75ccaec5596e95f9f2b241b36c9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;a href=&quot;#Base.fetch-Tuple%7BTask%7D&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt; on an empty, closed channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a385216e2414d1ff7d0e710e07a4b2820a4c3d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; и &lt;code&gt;fetch&lt;/code&gt; (которая извлекает, но не удаляет значение) в закрытом канале успешно возвращает любые существующие значения, пока он не будет очищен. Продолжая приведенный выше пример:</target>
        </trans-unit>
        <trans-unit id="f655219d63910b18e55d1c7b6d809270664f739b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_directory&lt;/code&gt;: If not empty, checkout to this directory instead of the &lt;code&gt;workdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target_directory&lt;/code&gt; : Если не пустой, извлечет этот каталог вместо &lt;code&gt;workdir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73fa24ada0f915b08e5eb705950254ddb5149ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_limit&lt;/code&gt;: the maximum number of files to compare with to look for renames. The default is 200.</source>
          <target state="translated">&lt;code&gt;target_limit&lt;/code&gt; : максимальное количество файлов для сравнения для поиска переименований. По умолчанию 200.</target>
        </trans-unit>
        <trans-unit id="8aa9f0c43ae05a2ce21f07a765041be8eb22e9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_local_storage&lt;/code&gt; manipulates a key-value store specific to the current task.</source>
          <target state="translated">&lt;code&gt;task_local_storage&lt;/code&gt; управляет хранилищем ключей и значений, специфичным для текущей задачи.</target>
        </trans-unit>
        <trans-unit id="918476307e3ca43e70bc1905ec5bcef98a16e9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;their_label&lt;/code&gt;: In case of conflicts, the name of &quot;their&quot; side.</source>
          <target state="translated">&lt;code&gt;their_label&lt;/code&gt; : В случае конфликтов название &amp;laquo;своей&amp;raquo; стороны.</target>
        </trans-unit>
        <trans-unit id="6030193bdbe78c187e1658db0e709e4fa8490cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology&lt;/code&gt;: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; : определяет, как рабочие подключаются друг к другу. Отправка сообщения между неподключенными работниками приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="afb214098cd0d7a7d60c3cf6760db696f2f4fcce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:all_to_all&lt;/code&gt;: All processes are connected to each other. The default.</source>
          <target state="translated">&lt;code&gt;topology=:all_to_all&lt;/code&gt; : Все процессы связаны друг с другом. По умолчанию.</target>
        </trans-unit>
        <trans-unit id="88dec064b9bfcaf6a26453d2e661939ebc23d230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:custom&lt;/code&gt;: The &lt;code&gt;launch&lt;/code&gt; method of the cluster manager specifies the connection topology via fields &lt;code&gt;ident&lt;/code&gt; and &lt;code&gt;connect_idents&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt;. A worker with a cluster manager identity &lt;code&gt;ident&lt;/code&gt; will connect to all workers specified in &lt;code&gt;connect_idents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topology=:custom&lt;/code&gt; : Метод &lt;code&gt;launch&lt;/code&gt; диспетчера кластера определяет топологию подключения через поля &lt;code&gt;ident&lt;/code&gt; ifier и &lt;code&gt;connect_idents&lt;/code&gt; в &lt;code&gt;WorkerConfig&lt;/code&gt; . Рабочий с &lt;code&gt;ident&lt;/code&gt; менеджера кластера будет подключаться ко всем рабочим, указанным в &lt;code&gt;connect_idents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b734d8bcd640fb2c65bc20498e0e55564a7cf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:master_worker&lt;/code&gt;: Only the driver process, i.e. &lt;code&gt;pid&lt;/code&gt; 1 connects to the workers. The workers do not connect to each other.</source>
          <target state="translated">&lt;code&gt;topology=:master_worker&lt;/code&gt; только процесс драйвера, т.е. &lt;code&gt;pid&lt;/code&gt; 1. Рабочие не подключаются друг к другу.</target>
        </trans-unit>
        <trans-unit id="2d9f7d8f681c6583e7676e7d6edc9308af158917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt;: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.</source>
          <target state="translated">&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt; : имя удаленной ветки, которую эта новая ветка должна отслеживать, если таковая имеется. Если пусто (по умолчанию), удаленная ветвь отслеживаться не будет.</target>
        </trans-unit>
        <trans-unit id="4e2130c7a7a9a101281bd18d3a385769f9600d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14ddcb95a156c7bb55a2265603cd736316fe9393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; is a git tree to use to create the commit, showing its ancestry and relationship with any other history. &lt;code&gt;tree&lt;/code&gt; must belong to &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; - это дерево git, используемое для создания фиксации, показывающее его происхождение и связь с любой другой историей. &lt;code&gt;tree&lt;/code&gt; должно принадлежать &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5eb7dc6b4355a5d1f4c868ec0c32021d4596579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; (1)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; (1)</target>
        </trans-unit>
        <trans-unit id="0936c575e4a9bce1faa418b1592ef449dfc0490a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;trunc(T, x)&lt;/code&gt; преобразует результат в тип &lt;code&gt;T&lt;/code&gt; , выбрасывая &lt;code&gt;InexactError&lt;/code&gt; , если значение не представляется возможным.</target>
        </trans-unit>
        <trans-unit id="7b21c9a0f1d3cee2b1f4d67453d1344f204a37a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; whose absolute value is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trunc(x)&lt;/code&gt; возвращает ближайшее целое значение того же типа, что и &lt;code&gt;x&lt;/code&gt; , абсолютное значение которого меньше или равно &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbee0eec9b2e55430d527d6582dd8877f12bb7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate&lt;/code&gt;: truncates the buffer size to zero length.</source>
          <target state="translated">&lt;code&gt;truncate&lt;/code&gt; : обрезает размер буфера до нулевой длины.</target>
        </trans-unit>
        <trans-unit id="41b6e3b3fb48f326fbad1eec1eadf0a833f25b9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try/catch&lt;/code&gt; statements also allow the &lt;code&gt;Exception&lt;/code&gt; to be saved in a variable. The following contrived example calculates the square root of the second element of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is indexable, otherwise assumes &lt;code&gt;x&lt;/code&gt; is a real number and returns its square root:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; Операторы try / catch также позволяют сохранять &lt;code&gt;Exception&lt;/code&gt; в переменной. В следующем надуманном примере вычисляется квадратный корень из второго элемента &lt;code&gt;x&lt;/code&gt; , если &lt;code&gt;x&lt;/code&gt; является индексируемым, в противном случае предполагается, что &lt;code&gt;x&lt;/code&gt; является действительным числом, и возвращает его квадратный корень:</target>
        </trans-unit>
        <trans-unit id="c33b1b48f85121178c6189a83f36ae5a4de3a504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="abd7dd9b12720a69f43edb81b0af4bb55b4e9603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ttl&lt;/code&gt;: Time-to-live of packets sent on the socket (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; : время жизни пакетов, отправленных через сокет (по умолчанию: &lt;code&gt;nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bbe2f11d5812292598ef7400b637ef93f999bc1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use tunneling), &lt;code&gt;false&lt;/code&gt; (do not use tunneling), or &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; (use default for the manager)</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; (использовать туннелирование), &lt;code&gt;false&lt;/code&gt; (не использовать туннелирование) или &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; (использовать по умолчанию для менеджера)</target>
        </trans-unit>
        <trans-unit id="402b0271ddb14ba3adb678d7b893e14da34abca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;, &lt;code&gt;bind_addr&lt;/code&gt;, &lt;code&gt;sshflags&lt;/code&gt; and &lt;code&gt;max_parallel&lt;/code&gt; are used when a ssh tunnel is required to connect to the workers from the master process.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; , &lt;code&gt;bind_addr&lt;/code&gt; , &lt;code&gt;sshflags&lt;/code&gt; и &lt;code&gt;max_parallel&lt;/code&gt; используются , когда SSH туннель требуется для подключения к рабочим из главного процесса.</target>
        </trans-unit>
        <trans-unit id="3ae98d30d6b9f87be7214d21f7b1f1658026f596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH tunneling will be used to connect to the worker from the master process. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , то для подключения к рабочему из главного процесса будет использоваться SSH-туннель. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fdfbb92ea4996a990fc0aedc71b8b96f842b098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt;: string to use for unchecked</source>
          <target state="translated">&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt; : строка, используемая для снятия отметки</target>
        </trans-unit>
        <trans-unit id="ae5641baee7f560f12b53646e74002ae2a7b0bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt;: character to use for up arrow</source>
          <target state="translated">&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt; : символ для стрелки вверх</target>
        </trans-unit>
        <trans-unit id="1286bd62882b2197d9326752a14abf249e35dcf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_fetchhead&lt;/code&gt;: whether to update the &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; after the fetch. The default is to perform the update, which is the normal git behavior.</source>
          <target state="translated">&lt;code&gt;update_fetchhead&lt;/code&gt; : обновлять ли &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; после выборки. По умолчанию выполняется обновление, что является нормальным поведением git.</target>
        </trans-unit>
        <trans-unit id="689158119264263de422838a5b03a631131c1362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab24710e9825de064a163f5ce94d79be47ade840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: The URL of the fetch head.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : URL заголовка выборки.</target>
        </trans-unit>
        <trans-unit id="f442181197e49f968f2471275a5f012e278f3859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: the URL of the proxy.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : URL-адрес прокси.</target>
        </trans-unit>
        <trans-unit id="19c4e769ed90cfd681ef1b310a2d6f9ad4296082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userdata&lt;/code&gt; is provided for custom cluster managers to store their own worker-specific information.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; предоставляется для настраиваемых менеджеров кластеров для хранения их собственной информации о работнике.</target>
        </trans-unit>
        <trans-unit id="d3b8331fceffede2316a7974124bb49b8eeb18b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt;: the username to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt; : имя пользователя для использования в выводе, если оно указано.</target>
        </trans-unit>
        <trans-unit id="7d104208af9cf68b573f7feb14b42536431e64fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c27371ad1b21bb51acb86107c58f827061ba3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; загрузит модуль или пакет &lt;code&gt;Foo&lt;/code&gt; и сделает его &lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; имена доступными для прямого использования. Имена также могут использоваться через точечный синтаксис (например, &lt;code&gt;Foo.foo&lt;/code&gt; для доступа к имени &lt;code&gt;foo&lt;/code&gt; ) независимо от того, &lt;code&gt;export&lt;/code&gt; они или нет. См. Подробности в &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;разделе руководства о модулях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="838b54a9eab8767958b3b80fdcf1e81d2fcffe22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="3e6a732011c1dc2660c4dbf3be189b6cbac8e5cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v&lt;/code&gt; now gets converted to the channel's type with &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; теперь преобразуется в тип канала с помощью &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; называется.</target>
        </trans-unit>
        <trans-unit id="49167f4be17e10d892b6cbc7f3c57602c873f166" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&quot;name&quot;&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;var&quot;name&quot;&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a66a7e6c62d3aec6a461aa958f979b8da4631830" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt;: print all additional information</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; : распечатать всю дополнительную информацию</target>
        </trans-unit>
        <trans-unit id="38771c8d2e3b58102e803157f1021fdc77359ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt;: version of the struct in use, in case this changes later. For now, always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; : версия используемой структуры, если она изменится позже. Пока всегда &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1609ac09d4613eb0a602a783024f2b37f908873d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vl&lt;/code&gt; is the lower bound of the window of eigenvalues to search for, and &lt;code&gt;vu&lt;/code&gt; is the upper bound.</source>
          <target state="translated">&lt;code&gt;vl&lt;/code&gt; - это нижняя граница окна поиска собственных значений, а &lt;code&gt;vu&lt;/code&gt; - верхняя граница.</target>
        </trans-unit>
        <trans-unit id="39634ab88344e26a6c4f7e1a95904a898f43f0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; and &lt;code&gt;[[noreturn]]&lt;/code&gt; or &lt;code&gt;_Noreturn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; и &lt;code&gt;[[noreturn]]&lt;/code&gt; или &lt;code&gt;_Noreturn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f798cc6e3986d2379a7244ce2f55decce5179fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;: a &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt;&lt;code&gt;TimeStruct&lt;/code&gt;&lt;/a&gt; indicating when the commit was authored/committed into the repository.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; : &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt; &lt;code&gt;TimeStruct&lt;/code&gt; ,&lt;/a&gt; указывающий, когда фиксация была создана / зафиксирована в репозитории.</target>
        </trans-unit>
        <trans-unit id="3719daed583548857eb7718a7ea0092ff6bffe3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;whence&lt;/code&gt; - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling &lt;code&gt;RemoteChannel(2)&lt;/code&gt; from the master process would result in a &lt;code&gt;where&lt;/code&gt; value of 2 and a &lt;code&gt;whence&lt;/code&gt; value of 1.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; - относится к узлу, с которого была создана удаленная ссылка. Обратите внимание, что это отличается от узла, на котором фактически существует указанный базовый объект. Например, вызов &lt;code&gt;RemoteChannel(2)&lt;/code&gt; из главного процесса приведет к получению значения &lt;code&gt;where&lt;/code&gt; 2 и значения 1 &lt;code&gt;whence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4feca933c79656bb4a1cc14d4c9d2c920ea65480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; - refers to the node where the underlying object/storage referred to by the reference actually exists.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; - относится к узлу, где фактически существует базовый объект / хранилище, на которое ссылается ссылка.</target>
        </trans-unit>
        <trans-unit id="be931cf43d24dd627ab40ea349a9901fcb931b4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="551426be1e371b3925c0f4c041a102931aa878ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; Циклы while повторно вычисляют условное выражение и продолжают вычислять тело цикла while, пока выражение остается истинным. Если выражение условия ложно при первом достижении цикла while, тело никогда не оценивается.</target>
        </trans-unit>
        <trans-unit id="f18b5d8d4e26142e2aee4c1c2ade071ef4896235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9e0e55014bc39303400ae1fa6e711c88709191dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_hide::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows no new console window is displayed when the &lt;code&gt;Cmd&lt;/code&gt; is executed. This has no effect if a console is already open or on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_hide::Bool&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; (по умолчанию &lt;code&gt;false&lt;/code&gt; ), то в Windows новое окно консоли не отображается при выполнении &lt;code&gt;Cmd&lt;/code&gt; . Это не действует, если консоль уже открыта или в системах, отличных от Windows.</target>
        </trans-unit>
        <trans-unit id="dfac6550a56cdb5e20498842d2ca74d4884878f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_verbatim::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows the &lt;code&gt;Cmd&lt;/code&gt; will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes &lt;code&gt;&quot;&lt;/code&gt; in the command line, and &lt;code&gt;\&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt; are preceded by backslashes. &lt;code&gt;windows_verbatim=true&lt;/code&gt; is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_verbatim::Bool&lt;/code&gt; : Если &lt;code&gt;true&lt;/code&gt; (по умолчанию &lt;code&gt;false&lt;/code&gt; ), то в Windows &lt;code&gt;Cmd&lt;/code&gt; отправит процессу строку командной строки без кавычек или экранирования аргументов, даже аргументов, содержащих пробелы. (В Windows аргументы отправляются программе в виде единой строки &amp;laquo;командной строки&amp;raquo;, и программы несут ответственность за ее анализ на аргументы. По умолчанию пустые аргументы и аргументы с пробелами или табуляцией заключаются в двойные кавычки &lt;code&gt;&quot;&lt;/code&gt; в команде line, а &lt;code&gt;\&lt;/code&gt; или &lt;code&gt;&quot;&lt;/code&gt; предшествуют обратная косая черта. &lt;code&gt;windows_verbatim=true&lt;/code&gt; используется для запуска программ, которые нестандартно анализируют командную строку.) Не влияет на системы, отличные от Windows.</target>
        </trans-unit>
        <trans-unit id="7b8aee3aafac635044e497c27a0514876ff35397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write(io, c)&lt;/code&gt;, in contrast, may emit an encoding depending on &lt;code&gt;typeof(c)&lt;/code&gt;, and &lt;code&gt;read(io, typeof(c))&lt;/code&gt; should read the same encoding as &lt;code&gt;write&lt;/code&gt;. New &lt;code&gt;AbstractChar&lt;/code&gt; types must provide their own implementations of &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write(io, c)&lt;/code&gt; , напротив, может выдавать кодировку в зависимости от &lt;code&gt;typeof(c)&lt;/code&gt; , а &lt;code&gt;read(io, typeof(c))&lt;/code&gt; должен читать ту же кодировку, что и &lt;code&gt;write&lt;/code&gt; . Новые типы &lt;code&gt;AbstractChar&lt;/code&gt; должны обеспечивать собственные реализации &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fadd3731757e74adbe714a9fc3cde1b0f50d386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x % T&lt;/code&gt; converts an integer &lt;code&gt;x&lt;/code&gt; to a value of integer type &lt;code&gt;T&lt;/code&gt; congruent to &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of bits in &lt;code&gt;T&lt;/code&gt;. In other words, the binary representation is truncated to fit.</source>
          <target state="translated">&lt;code&gt;x % T&lt;/code&gt; преобразует целое число &lt;code&gt;x&lt;/code&gt; до значения целого типа &lt;code&gt;T&lt;/code&gt; конгруэнтен &lt;code&gt;x&lt;/code&gt; по модулю &lt;code&gt;2^n&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; есть число бит в &lt;code&gt;T&lt;/code&gt; . Другими словами, двоичное представление усекается по размеру.</target>
        </trans-unit>
        <trans-unit id="90c41f1363237dda010ffbdcb1e50483f239fe01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (where &lt;code&gt;&amp;sdot;&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\cdot&lt;/code&gt; in the REPL) is a synonym for &lt;code&gt;dot(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (где &lt;code&gt;&amp;sdot;&lt;/code&gt; можно ввести с помощью символа табуляции &lt;code&gt;\cdot&lt;/code&gt; в REPL) является синонимом &lt;code&gt;dot(x, y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a73d00c797f625743ed5be89aa6859e0e140e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x*2^n&lt;/code&gt; computed efficiently for integer values of &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x*2^n&lt;/code&gt; вычисляется эффективно для целых значений &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1940ccb42a82ee4f57a9ef424ce506f2b4432f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; и &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a950a8c9e0c5cf38b19bf4e5268bb9ee46dfc69c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; идентичны</target>
        </trans-unit>
        <trans-unit id="ab3ac69532931e0ece805a61f4c297980ed1e736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may also be arrays of numbers, in which case &lt;code&gt;norm&lt;/code&gt; defaults to the usual &lt;code&gt;norm&lt;/code&gt; function in LinearAlgebra, but may be changed by passing a &lt;code&gt;norm::Function&lt;/code&gt; keyword argument. (For numbers, &lt;code&gt;norm&lt;/code&gt; is the same thing as &lt;code&gt;abs&lt;/code&gt;.) When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are arrays, if &lt;code&gt;norm(x-y)&lt;/code&gt; is not finite (i.e. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;), the comparison falls back to checking whether all elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are approximately equal component-wise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; также могут быть массивами чисел, и в этом случае &lt;code&gt;norm&lt;/code&gt; по умолчанию соответствует обычной функции &lt;code&gt;norm&lt;/code&gt; в LinearAlgebra, но может быть изменен путем передачи аргумента ключевого слова &lt;code&gt;norm::Function&lt;/code&gt; . (Для чисел, &lt;code&gt;norm&lt;/code&gt; это то же самое , как &lt;code&gt;abs&lt;/code&gt; .) Когда &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются массивами, если &lt;code&gt;norm(x-y)&lt;/code&gt; не является конечным (т.е. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; или &lt;code&gt;NaN&lt;/code&gt; ), сравнение возвращается к проверке все ли элементы &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются примерно равные по компонентам.</target>
        </trans-unit>
        <trans-unit id="a48f8b3cde36a8ddf02a94dfeb998cab82856e48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; enables &quot;comment mode&quot;: whitespace is enabled except when escaped with &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; is treated as starting a comment.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; включает &quot;режим комментариев&quot;: пробелы разрешены, кроме случаев, когда они экранированы с помощью &lt;code&gt;\&lt;/code&gt; , а &lt;code&gt;#&lt;/code&gt; рассматривается как начало комментария.</target>
        </trans-unit>
        <trans-unit id="9b7e404002ef27b1a2197f45feec798673ffc690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a finite number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; - конечное число</target>
        </trans-unit>
        <trans-unit id="c0524cd745ecc91f2a8a799e342f5f682c7f1d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is infinite</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; бесконечно</target>
        </trans-unit>
        <trans-unit id="47fb95081b3ce22a0b461fae81e21bbc77c62b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is not a number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; не число</target>
        </trans-unit>
        <trans-unit id="bcdade3b450aacebe7ce055923202bb9a54acb72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a786472b355da8522bfc59ef4c0762b67c585b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="54aac4fafe7a37588d94288478848558abaf1196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~/.julia&lt;/code&gt; where &lt;code&gt;~&lt;/code&gt; is the user home as appropriate on the system;</source>
          <target state="translated">&lt;code&gt;~/.julia&lt;/code&gt; , где &lt;code&gt;~&lt;/code&gt; - домашний адрес пользователя в системе;</target>
        </trans-unit>
        <trans-unit id="e0376dc9fd7a8a47da8cd6fcc825a0caa36450a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All&lt;/em&gt; functions are generic and use multiple dispatch. Argument lists don't have to follow the same template, which leads to a powerful idiom (see &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt;). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition of a more specific method for the intersection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df118c2fbb6c1d7ba0ff4dd87b88d00cf764a55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before&lt;/em&gt; loading any code, make sure you're running Revise: say &lt;code&gt;using Revise&lt;/code&gt; or follow its documentation on configuring it to run automatically.</source>
          <target state="translated">&lt;em&gt;Перед&lt;/em&gt; загрузкой любого кода убедитесь, что вы используете Revise: скажем, &lt;code&gt;using Revise&lt;/code&gt; или следуйте документации по настройке для автоматического запуска.</target>
        </trans-unit>
        <trans-unit id="743bea8b6e02264a01bcef3ea67aed3f0cad8650" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Creating&lt;/em&gt; log events is the concern of the module author who needs to decide where events are triggered and which information to include.</source>
          <target state="translated">&lt;em&gt;Создание&lt;/em&gt; событий журнала - это забота автора модуля, который должен решить, какие события запускаются и какую информацию включать.</target>
        </trans-unit>
        <trans-unit id="b124a7e86891727331d73882ce0c24f7eaafd8ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don't copy these examples!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Не копируйте эти примеры!&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1da7110d00e265f94760324ffd9a23c2410b52b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implicit use&lt;/em&gt; of &lt;code&gt;x&lt;/code&gt; covers any indirect use of resources logically owned by &lt;code&gt;x&lt;/code&gt; which the compiler cannot see. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cf9402e58fc3879fb68f8afe68b31dae06eee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Processing&lt;/em&gt; of log events &amp;mdash; that is, display, filtering, aggregation and recording &amp;mdash; is the concern of the application author who needs to bring multiple modules together into a cooperating application.</source>
          <target state="translated">&lt;em&gt;Обработка&lt;/em&gt; событий журнала - то есть отображение, фильтрация, агрегирование и запись - это забота автора приложения, которому необходимо объединить несколько модулей в одно взаимодействующее приложение.</target>
        </trans-unit>
        <trans-unit id="7685c1fa95d4518c2af3eb032fd247fef3129095" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt; sort strategy.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Стратегия сортировки &quot; &lt;em&gt;разделяй и властвуй&quot;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="955d87cc46ecdddf5939b69f5d5e66211dd43025" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt;: sort strategy similar to &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt;&lt;code&gt;MergeSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;разделяй и властвуй&lt;/em&gt; : стратегия сортировки, аналогичная &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt; &lt;code&gt;MergeSort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="547c0f175b81af7715456826fa2ddb801ca75ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;good performance&lt;/em&gt; for large collections.</source>
          <target state="translated">&lt;em&gt;хорошая производительность&lt;/em&gt; для больших коллекций.</target>
        </trans-unit>
        <trans-unit id="76e3721332fa8c80267a6d025e92a7b31c647f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iid&lt;/em&gt;, independently and identically distributed.</source>
          <target state="translated">&lt;em&gt;iid&lt;/em&gt; , независимо и одинаково распространяемые.</target>
        </trans-unit>
        <trans-unit id="4eecbf6b8e99fcad79c0f04ad8ffa79c56d8a143" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;на месте&lt;/em&gt; в памяти.</target>
        </trans-unit>
        <trans-unit id="53b7f08036597cd9367e51ae64cec4b72d17fb7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;не на месте&lt;/em&gt; в памяти.</target>
        </trans-unit>
        <trans-unit id="69d8a8fdc356b8320c038747a06bcc5697c84ab8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not stable&lt;/em&gt;: does not preserve the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;нестабильно&lt;/em&gt; : не сохраняет порядок элементов, которые сравниваются одинаково (например, &amp;laquo;a&amp;raquo; и &amp;laquo;A&amp;raquo; в виде букв без учета регистра).</target>
        </trans-unit>
        <trans-unit id="bc0febd17aa71743548f98f48c43c546e1abfb04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quadratic performance&lt;/em&gt; in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.</source>
          <target state="translated">&lt;em&gt;квадратичная производительность&lt;/em&gt; по количеству сортируемых элементов: она хорошо подходит для небольших коллекций, но не должна использоваться для больших.</target>
        </trans-unit>
        <trans-unit id="a1491802554c00bcc7d066e787c837a325301ece" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stable&lt;/em&gt;: preserves the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;стабильный&lt;/em&gt; : сохраняет порядок элементов, которые сравниваются одинаково (например, &amp;laquo;a&amp;raquo; и &amp;laquo;A&amp;raquo; в виде букв без учета регистра).</target>
        </trans-unit>
        <trans-unit id="47450e33687d2bd35b73c1a40f6abb2479676524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A package directory&lt;/strong&gt; is a directory containing the source trees of a set of packages as subdirectories, and forms an &lt;em&gt;implicit environment&lt;/em&gt;. If &lt;code&gt;X&lt;/code&gt; is a subdirectory of a package directory and &lt;code&gt;X/src/X.jl&lt;/code&gt; exists, then the package &lt;code&gt;X&lt;/code&gt; is available in the package directory environment and &lt;code&gt;X/src/X.jl&lt;/code&gt; is the source file by which it is loaded.</source>
          <target state="translated">&lt;strong&gt;Каталог пакетов&lt;/strong&gt; - это каталог, содержащий деревья исходных текстов набора пакетов в виде подкаталогов и образующий &lt;em&gt;неявную среду&lt;/em&gt; . Если &lt;code&gt;X&lt;/code&gt; является подкаталогом каталога пакета и существует &lt;code&gt;X/src/X.jl&lt;/code&gt; , то пакет &lt;code&gt;X&lt;/code&gt; доступен в среде каталога пакетов, а &lt;code&gt;X/src/X.jl&lt;/code&gt; - исходный файл, из которого он загружается.</target>
        </trans-unit>
        <trans-unit id="ab6e1278144bfe85f8b9792c5068eed40f8bd5eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environement&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="translated">&lt;strong&gt;Среда проекта&lt;/strong&gt; - это каталог с файлом проекта и необязательным файлом манифеста, который образует &lt;em&gt;явную среду&lt;/em&gt; . Файл проекта определяет имена и идентификаторы прямых зависимостей проекта. Файл манифеста, если он присутствует, дает полный граф зависимостей, включая все прямые и косвенные зависимости, точные версии каждой зависимости и достаточную информацию для поиска и загрузки правильной версии.</target>
        </trans-unit>
        <trans-unit id="71e41c9cbdf8ac89f9996aae247a324d7f18b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environment&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dcf2f7a4986e6945bd060c2a9f0b685ebc4a479" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Automatic promotion for built-in arithmetic types and operators.&lt;/strong&gt; In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum &lt;code&gt;1 + 1.5&lt;/code&gt; as the floating-point value &lt;code&gt;2.5&lt;/code&gt;, even though one of the operands to &lt;code&gt;+&lt;/code&gt; is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</source>
          <target state="translated">&lt;strong&gt;Автоматическое продвижение встроенных арифметических типов и операторов.&lt;/strong&gt; В большинстве языков встроенные числовые типы при использовании в качестве операндов для арифметических операторов с инфиксным синтаксисом, например &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;/&lt;/code&gt; , автоматически переводятся в общий тип для получения ожидаемых результатов. C, Java, Perl и Python, и это лишь некоторые из них, правильно вычисляют сумму &lt;code&gt;1 + 1.5&lt;/code&gt; как значение с плавающей запятой &lt;code&gt;2.5&lt;/code&gt; , даже если один из операндов равен &lt;code&gt;+&lt;/code&gt; целое число. Эти системы удобны и разработаны достаточно тщательно, чтобы они, как правило, практически незаметны для программиста: вряд ли кто-то сознательно задумывается об этом продвижении при написании такого выражения, но компиляторы и интерпретаторы должны выполнять преобразование перед сложением, поскольку целые числа и числа с плавающей точкой - баллы не могут быть добавлены как есть. Таким образом, сложные правила для таких автоматических преобразований неизбежно являются частью спецификаций и реализаций таких языков.</target>
        </trans-unit>
        <trans-unit id="40672dddf16a6430318b3eb0b9096db189222d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brief description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Краткое описание&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="540bb8e1a8c92de3d9695826131a325154196169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Broadcasting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Broadcasting&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f7d8aeead87b3699dcf3142b1e6dee864b1f9e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bypassing default machinery&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обход оборудования по умолчанию&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c3f895628a42c1489009a0b0558d48806270adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code inclusion:&lt;/strong&gt; e.g. &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt;. Inclusion allows you to split a single program across multiple source files. The expression &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; causes the contents of the file &lt;code&gt;source.jl&lt;/code&gt; to be evaluated in the global scope of the module where the &lt;code&gt;include&lt;/code&gt; call occurs. If &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; is called multiple times, &lt;code&gt;source.jl&lt;/code&gt; is evaluated multiple times. The included path, &lt;code&gt;source.jl&lt;/code&gt;, is interpreted relative to the file where the &lt;code&gt;include&lt;/code&gt; call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, &lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt;&lt;code&gt;pwd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Включение кода:&lt;/strong&gt; например, &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; . Включение позволяет разделить одну программу на несколько исходных файлов. Выражение &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; приводит к тому, что содержимое файла &lt;code&gt;source.jl&lt;/code&gt; оценивается в глобальной области видимости модуля, в котором происходит вызов &lt;code&gt;include&lt;/code&gt; . Если &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; вызывается несколько раз, &lt;code&gt;source.jl&lt;/code&gt; оценивается несколько раз. Включенный путь, &lt;code&gt;source.jl&lt;/code&gt; , интерпретируется относительно файла, в котором происходит вызов &lt;code&gt;include&lt;/code&gt; . Это упрощает перемещение поддерева исходных файлов. В REPL включенные пути интерпретируются относительно текущего рабочего каталога,&lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt; &lt;code&gt;pwd()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01b2956aa02b611eba1c44ae4666e386f9a69158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion between linear and cartesian indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Преобразование между линейным и декартовым индексами&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8981b2e89255132713afc6ec39691c7bdea5024d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cursor movement&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Движение курсора&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f5b988cb89cb4ede6b56c1271511dfc59d67ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default definition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Определение по умолчанию&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1c863333a531bcda45cde640d9c35956bb33378" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Editing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Editing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c838c65ad1ba4b74d30de6df9d506f5e2b0ac9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else&lt;/strong&gt;. Any other arguments.</source>
          <target state="translated">&lt;strong&gt;Все остальное&lt;/strong&gt; . Любые другие аргументы.</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aec29b6e22750bc511d0ca82430cb4a126753e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="19683dd3d8903f638a6b291d6c9f28ca79e6c660" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Existing local:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;already a local variable&lt;/em&gt;, then the existing local &lt;code&gt;x&lt;/code&gt; is assigned;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9102cd5f3ec81f62379dfb14e7e329a015e35f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Extensions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d05122489d09030ff3668a78437ee26a3f82b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;External links&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;внешние ссылки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83e0b267355d0c11ea2a53fe10c727c43451c8c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Floating-point types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Типы с плавающей запятой:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a16a8e8a484df94b3401f2c14b02422be6ca3e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;. Putting a function argument first permits the use of &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; blocks for passing multiline anonymous functions.</source>
          <target state="translated">&lt;strong&gt;Аргумент функции&lt;/strong&gt; . Ввод аргумента функции первым позволяет использовать блоки &lt;a href=&quot;../../base/base/index#do&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt; для передачи многострочных анонимных функций.</target>
        </trans-unit>
        <trans-unit id="7ec40a2f0a30b472e6c7208cfd9385764834e554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hard scope:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;not already a local variable&lt;/em&gt; and assignment occurs inside of any hard scope construct (i.e. within a let block, function or macro body, comprehension, or generator), a new local named &lt;code&gt;x&lt;/code&gt; is created in the scope of the assignment;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca787ea86b26829b090b38d91fb7a76042f2799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensional examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Примеры более высоких измерений&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6a830a0dff55184e4ece6c75f5be5491d3d9702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Высшие измерения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0fb2b5df39867dacb9671eb2a360e55518f879f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I/O stream&lt;/strong&gt;. Specifying the &lt;code&gt;IO&lt;/code&gt; object first permits passing the function to functions such as &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt;&lt;code&gt;sprint&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;sprint(show, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Поток ввода-вывода&lt;/strong&gt; . Указание объекта &lt;code&gt;IO&lt;/code&gt; сначала позволяет передать функцию таким функциям, как &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt; &lt;code&gt;sprint&lt;/code&gt; &lt;/a&gt; , например &lt;code&gt;sprint(show, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45650bbd2deb4cc345f368e53f1b5e765a99a0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6981e39179d49e3bc1edb6f6043ddc4d3a9c17e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Важные необязательные методы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feaf5b204440e5d7b91a26fca33465989ee60de5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input being mutated&lt;/strong&gt;. For example, in &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt; is the object being mutated and it appears before the value to be inserted into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Ввод изменен&lt;/strong&gt; . Например, в &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!(x, v)&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;x&lt;/code&gt; является объектом будучи мутировал и, кажется , прежде , чем значение для вставки в &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35035aa4af72e7ec2407cb311a13aa4b3f4086e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input not being mutated&lt;/strong&gt;. In &lt;code&gt;fill!(x, v)&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; being mutated and it comes after &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Вход не изменяется&lt;/strong&gt; . В &lt;code&gt;fill!(x, v)&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; будучи мутировал , и он приходит после того, как &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c1aac8a2ffe99a6f68662d283f199e4c7902db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Integer types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Целочисленные типы:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b0deb4e2e9417b81879cdc846953811ed3197f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key&lt;/strong&gt;. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.</source>
          <target state="translated">&lt;strong&gt;Ключ&lt;/strong&gt; . Для ассоциативных коллекций это ключ пары ключ-значение. Для других проиндексированных коллекций это index.</target>
        </trans-unit>
        <trans-unit id="ff1552788ed9b7867471169f6f6e13e67ae56e49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Аргументы ключевых слов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6d1fbca2eaaca33fbedfae851b1718e81cb621c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword arguments&lt;/strong&gt;. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.</source>
          <target state="translated">&lt;strong&gt;Аргументы ключевого слова&lt;/strong&gt; . В ключевом слове Julia аргументы в любом случае должны стоять последними в определениях функций; они перечислены здесь для полноты картины.</target>
        </trans-unit>
        <trans-unit id="940941ba13fb5db6a5ccc6b2d81447af0218c6f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keywords&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Keywords&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="739565cef16139694d18e4e833e383d92f6229e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lather. Rinse. Repeat.&lt;/strong&gt; Explore ideas at the &lt;code&gt;julia&lt;/code&gt; command prompt. Save good ideas in &lt;code&gt;tst.jl&lt;/code&gt;. To execute &lt;code&gt;tst.jl&lt;/code&gt; after it has been changed, just &lt;code&gt;include&lt;/code&gt; it again.</source>
          <target state="translated">&lt;strong&gt;Lather. Полоскание. Повторение.&lt;/strong&gt; Изучите идеи в командной строке &lt;code&gt;julia&lt;/code&gt; . Сохранить хорошие идеи в &lt;code&gt;tst.jl&lt;/code&gt; . Чтобы выполнить &lt;code&gt;tst.jl&lt;/code&gt; после того , как было изменено, просто &lt;code&gt;include&lt;/code&gt; его снова.</target>
        </trans-unit>
        <trans-unit id="062ff7c1f91aac8affdefeef654af299368b137e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No automatic promotion.&lt;/strong&gt; This camp includes Ada and ML &amp;ndash; very &quot;strict&quot; statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression &lt;code&gt;1 + 1.5&lt;/code&gt; would be a compilation error in both Ada and ML. Instead one must write &lt;code&gt;real(1) + 1.5&lt;/code&gt;, explicitly converting the integer &lt;code&gt;1&lt;/code&gt; to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</source>
          <target state="translated">&lt;strong&gt;Нет автоматического продвижения. &lt;/strong&gt;В этот лагерь входят Ada и ML - очень &amp;laquo;строгие&amp;raquo; статически типизированные языки. В этих языках каждое преобразование должно быть явно указано программистом. Таким образом, пример выражения &lt;code&gt;1 + 1.5&lt;/code&gt; будет ошибкой компиляции как в Ada, так и в ML. Вместо этого нужно написать &lt;code&gt;real(1) + 1.5&lt;/code&gt; , явно преобразовав целое число &lt;code&gt;1&lt;/code&gt; в значение с плавающей запятой перед выполнением сложения. Явное преобразование повсюду настолько неудобно, что даже в Ada есть некоторая степень автоматического преобразования: целочисленные литералы автоматически переводятся в ожидаемый целочисленный тип, а литералы с плавающей запятой аналогичным образом переводятся в соответствующие типы с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="19f000a09892ceb4a24beccfa194f3fb0e83a418" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-traditional indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Нетрадиционные индексы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3411b52319b78e51339257b20de47be2deece6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Due to the specifics of the &lt;code&gt;libgit2&lt;/code&gt; authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : из-за &lt;code&gt;libgit2&lt;/code&gt; процедуры аутентификации libgit2 , когда аутентификация не удалась, эта функция вызывается снова без какого-либо указания, была ли аутентификация успешной или нет. Чтобы избежать бесконечного цикла из-за многократного использования одних и тех же ошибочных учетных данных, мы будем отслеживать состояние с помощью полезной нагрузки.</target>
        </trans-unit>
        <trans-unit id="9305d29fbc35afa9e63a3c399be778dee6ddefff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . В этом разделе рассматривается встраивание кода Julia в C в Unix-подобных операционных системах. Чтобы сделать это в Windows, см. Следующий раздел.</target>
        </trans-unit>
        <trans-unit id="fbff1879231e49a20a9f4f3abc431b43d8a6387c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Дополнительные методы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fb86f3d0dc24e6e4655476741634ef5c5d50df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package loading:&lt;/strong&gt; e.g. &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;. The import mechanism allows you to load a package&amp;mdash;i.e. an independent, reusable collection of Julia code, wrapped in a module&amp;mdash;and makes the resulting module available by the name &lt;code&gt;X&lt;/code&gt; inside of the importing module. If the same &lt;code&gt;X&lt;/code&gt; package is imported multiple times in the same Julia session, it is only loaded the first time&amp;mdash;on subsequent imports, the importing module gets a reference to the same module. Note though, that &lt;code&gt;import X&lt;/code&gt; can load different packages in different contexts: &lt;code&gt;X&lt;/code&gt; can refer to one package named &lt;code&gt;X&lt;/code&gt; in the main project but potentially to different packages also named &lt;code&gt;X&lt;/code&gt; in each dependency. More on this below.</source>
          <target state="translated">&lt;strong&gt;Пакет загрузки:&lt;/strong&gt; например , &lt;code&gt;import X&lt;/code&gt; или с &lt;code&gt;using X&lt;/code&gt; . Механизм импорта позволяет загружать пакет - т. Е. Независимую многократно используемую коллекцию кода Julia, заключенную в модуль, - и делает получившийся модуль доступным по имени &lt;code&gt;X&lt;/code&gt; внутри модуля импорта. Если один и тот же пакет &lt;code&gt;X&lt;/code&gt; импортируется несколько раз в одном сеансе Julia, он загружается только в первый раз - при последующих импортах импортирующий модуль получает ссылку на тот же модуль. Однако обратите внимание, что &lt;code&gt;import X&lt;/code&gt; может загружать разные пакеты в разных контекстах: &lt;code&gt;X&lt;/code&gt; может ссылаться на один пакет с именем &lt;code&gt;X&lt;/code&gt; в основном проекте, но, возможно, на разные пакеты, также называемые &lt;code&gt;X&lt;/code&gt; в каждой зависимости. Подробнее об этом ниже.</target>
        </trans-unit>
        <trans-unit id="fd7c146c235ccd96ea634cfca88f3355f9e6c234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Program control&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Программный контроль&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a191672dfe99327da9dff700b45c0a90a2ec39c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put code under development in a temporary module.&lt;/strong&gt; Create a file, say &lt;code&gt;Tmp.jl&lt;/code&gt;, and include within it</source>
          <target state="translated">&lt;strong&gt;Поместите разрабатываемый код во временный модуль. &lt;/strong&gt;Создайте файл, скажем &lt;code&gt;Tmp.jl&lt;/code&gt; , и включите в него</target>
        </trans-unit>
        <trans-unit id="4eebb852c621ba2a07cde7c387d74387c1073db2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put your test code in another file.&lt;/strong&gt; Create another file, say &lt;code&gt;tst.jl&lt;/code&gt;, which looks like</source>
          <target state="translated">&lt;strong&gt;Поместите свой тестовый код в другой файл. &lt;/strong&gt;Создайте еще один файл, скажем &lt;code&gt;tst.jl&lt;/code&gt; , который выглядит как</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="261a3928dc6c3e62bad4f4dc9c5ff983868f3948" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Смотрите также&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36121b3eefd78b60d0003f60318af0689a90639e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Soft scope:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;not already a local variable&lt;/em&gt; and all of the scope constructs containing the assignment are soft scopes (loops, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; blocks, or &lt;code&gt;struct&lt;/code&gt; blocks), the behavior depends on whether the global variable &lt;code&gt;x&lt;/code&gt; is defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3021827c46a7ed515f5246c6017d78d244ed6bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Dependent Types&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608f32cb9eef948fcb1ef6e535b6635c88420101" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent Types&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a6a8a34ed60528197f028d9fedecb6c66b4c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Независимая от системы:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212d71ac9a214ae43f2cb6533589aa526743d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System-dependent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;System-dependent:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="62fabcca68af5e84228e26aadaf1eb51caedddfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</source>
          <target state="translated">&lt;strong&gt;Граф зависимости&lt;/strong&gt; каталога проекта определяется наличием и содержимым файлов проекта в подкаталоге каждого пакета. Правила следующие:</target>
        </trans-unit>
        <trans-unit id="35fd5fb379b76233f79b688e018757619277e941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for &lt;code&gt;App&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;График зависимостей&lt;/strong&gt; среды проекта определяется содержимым файла манифеста, если он есть. Если файла манифеста нет, график пуст. Файл манифеста содержит раздел для каждой прямой или косвенной зависимости проекта. Для каждой зависимости в файле перечислены UUID пакета и хэш дерева исходного кода или явный путь к исходному коду. Рассмотрим следующий пример файла манифеста для &lt;code&gt;App&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99a933b1a5fc31f0c493bc7563a8e1ef2ab60637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ключевым моментом здесь является то, что код Julia внутренне представлен как структура данных, доступная из самого языка.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ec20ee36876b86777c4834a05d78e1ed0df59a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is &lt;code&gt;/home/me/animals&lt;/code&gt; then the &lt;code&gt;paths&lt;/code&gt; map could be represented by this dictionary:</source>
          <target state="translated">&lt;strong&gt;Карта путей&lt;/strong&gt; в каталоге пакета проста: она сопоставляет имена подкаталогов с соответствующими путями точек входа. Другими словами, если путь к каталогу нашего примера проекта - &lt;code&gt;/home/me/animals&lt;/code&gt; , то карта &lt;code&gt;paths&lt;/code&gt; может быть представлена ​​этим словарем:</target>
        </trans-unit>
        <trans-unit id="7176439c445de46708b9fc3e70d97730d2317fd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; of a project environment is extracted from the manifest file. The path of a package &lt;code&gt;uuid&lt;/code&gt; named &lt;code&gt;X&lt;/code&gt; is determined by these rules (in order):</source>
          <target state="translated">&lt;strong&gt;Карта путей&lt;/strong&gt; среды проекта извлекается из файла манифеста. Путь к &lt;code&gt;uuid&lt;/code&gt; пакета с именем &lt;code&gt;X&lt;/code&gt; определяется этими правилами (по порядку):</target>
        </trans-unit>
        <trans-unit id="d3d291e6a57a7e987da705641960c2e565ce87e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder &lt;code&gt;X&lt;/code&gt;...</source>
          <target state="translated">&lt;strong&gt;Карта корней&lt;/strong&gt; определяется путем изучения содержимого каталога пакетов для создания списка всех существующих пакетов. Кроме того, каждой записи будет присвоен UUID следующим образом: Для данного пакета, находящегося внутри папки &lt;code&gt;X&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="cd6e60a191a6ba1c08e90279b391c492d145ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; of the environment is determined by the contents of the project file, specifically, its top-level &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt; entries and its &lt;code&gt;[deps]&lt;/code&gt; section (all optional). Consider the following example project file for the hypothetical application, &lt;code&gt;App&lt;/code&gt;, as described earlier:</source>
          <target state="translated">&lt;strong&gt;Корни карту&lt;/strong&gt; окружающей среды определяется содержимым файла проекта, в частности, его верхнего уровня &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;uuid&lt;/code&gt; записи и его &lt;code&gt;[deps]&lt;/code&gt; раздел (все по желанию). Рассмотрим следующий пример файла проекта для гипотетического приложения &lt;code&gt;App&lt;/code&gt; , как описано ранее:</target>
        </trans-unit>
        <trans-unit id="fda932e2af71b43d983578e7c22d5ddfec83e11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type&lt;/strong&gt;. Passing a type typically means that the output will have the given type. In &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt;&lt;/a&gt;, the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read(io, String)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;IO&lt;/code&gt; argument appears before the type, which is in keeping with the order outlined here.</source>
          <target state="translated">&lt;strong&gt;Тип&lt;/strong&gt; . Передача типа обычно означает, что вывод будет иметь данный тип. При &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt; &lt;/a&gt; тип стоит перед строкой для синтаксического анализа. Есть много таких примеров , когда тип появляется первым, но это полезно отметить , что в &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read(io, String)&lt;/code&gt; &lt;/a&gt; , то &lt;code&gt;IO&lt;/code&gt; аргумент появляется перед типом, который в соответствии с порядком изложен здесь.</target>
        </trans-unit>
        <trans-unit id="b586fc911b064b4cf7b9cf3a61a4f379ea0edfb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use in broadcasting&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eab55c50210340cd0c0df6a7519baa6abc6fcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93eadc871861400a6078e0c61f3521be0b3a0f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;code&gt;fill!(x, v)&lt;/code&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Ценность&lt;/strong&gt; . Для ассоциативных коллекций это значение пар &quot;ключ-значение&quot;. В таких случаях, как &lt;code&gt;fill!(x, v)&lt;/code&gt; , это &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5d0e0a9d5ca3af4a899d7c1e28f16c0a7bba6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Varargs&lt;/strong&gt;. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt;, the dimensions can be given as a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt;, or as &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;s, e.g. &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Вараргс&lt;/strong&gt; . Это относится к аргументам, которые могут быть перечислены бесконечно в конце вызова функции. Например, в &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt; размеры могут быть заданы как &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; , например, &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt; , или как &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; s, например, &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="545631b4b295bbbbaed02465401d0864d0ba7cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What code will this generate?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Какой код это сгенерирует?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b9ef5ff046429380c724127c17394868104ef2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What happens next?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что происходит дальше?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0ff7b4939bf14804a87f9610d1e80a40b4a40b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b12835c0c0b2c5b88b2a8e731d5eb2b1969e8e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a1a83d04dbd981bd8fe4ab619b42f958ca751fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH12]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH12]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b43d748a54903580e1f21b7242d8d7bb7c4a651a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a356e5ff840b60f1a7fd81a3055863d97b69c77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b68ee69a50f3609b2ad16980f29687180123ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_3]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_3]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a85a3aeb27ca57bd4a8e009398c96aa33508ed10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_4]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_4]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddd2e496892d30147f2d48e88aa633252774dbf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_5]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_5]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ddc74cbd626ac29e02b601b534c540a40ab5c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_6]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_6]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e97166948a5a3dd11986acbec9fbe6e3cecc60a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AHR13]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AHR13]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65bccd8483458eb47f0cf100e59d18c925a72cfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[B96]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[B96]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f94a30b3537fd21ece46a3be3dc64a62b55b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[BH83]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[BH83]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="11b1b49422b93ae8106416d25659e6c4a205faf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d14e168d4fa4ad2378bdf18be346c186cebb91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a39f9cf2c50ef187780e440b9a6f2239b055ca1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Clarke61]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Clarke61]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c9f7af37c9c1abf3d2cee7bcb7b4328414a23f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[H05]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[H05]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86010be2d69f415c30df7072124ec31548c70f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[KY88]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[KY88]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95c6fae5f939df06b7b59cc5c966b9329d025d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[S84]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[S84]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6c947d8396f46ae50ccb15050b140acd93e682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274fa9920703743f7af11b5a3280a2a8b5492b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[issue8859]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[issue8859]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deb59e9858773588134a730e8495054b325e35ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;graph:&lt;/strong&gt;&lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;граф: &lt;/strong&gt; &lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da29c13a3741ca50b24df3f7e215f047cc6fe3b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;malloc/free&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc/free&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc5e4770f37b853a29d3b06890d6a4abca810ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;paths:&lt;/strong&gt;&lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;пути: &lt;/strong&gt; &lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e060769be59aa948e668dd91db6570aedd04731c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;roots:&lt;/strong&gt;&lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;корни: &lt;/strong&gt; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec6dd4d3b2fc9b4797a8648dcfb6a94dffc781ff" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;4.0 &lt;i&gt;я&lt;/i&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="4b5fcf2420327f83a4a6033c345a55bd47a95680" translate="yes" xml:space="preserve">
          <source>==()</source>
          <target state="translated">==()</target>
        </trans-unit>
        <trans-unit id="924d44730ffe4a504a8c5b50688254e4e4997e86" translate="yes" xml:space="preserve">
          <source>@__DIR__</source>
          <target state="translated">@__DIR__</target>
        </trans-unit>
        <trans-unit id="bd05d820a39cc57788c144db33dd9e5d64bc802d" translate="yes" xml:space="preserve">
          <source>@__FILE__</source>
          <target state="translated">@__FILE__</target>
        </trans-unit>
        <trans-unit id="0a7e2fb02c2ce1b02c47c60a07b07cab4fff90c0" translate="yes" xml:space="preserve">
          <source>@__LINE__</source>
          <target state="translated">@__LINE__</target>
        </trans-unit>
        <trans-unit id="cc0701eaddfdfad8a65ef41e959c8e4f27062811" translate="yes" xml:space="preserve">
          <source>@__MODULE__</source>
          <target state="translated">@__MODULE__</target>
        </trans-unit>
        <trans-unit id="0662c8864fe3f1ee3b1e0fb430b61c3e64455909" translate="yes" xml:space="preserve">
          <source>@allocated</source>
          <target state="translated">@allocated</target>
        </trans-unit>
        <trans-unit id="521dba9e02174468f68a0b805b470b64bd37b2ab" translate="yes" xml:space="preserve">
          <source>@assert</source>
          <target state="translated">@assert</target>
        </trans-unit>
        <trans-unit id="3b7c965e962f36eb0e6c472eea82392cdc514ade" translate="yes" xml:space="preserve">
          <source>@async</source>
          <target state="translated">@async</target>
        </trans-unit>
        <trans-unit id="e9bfca0d6780244df737a5f488a11f321a4e3e28" translate="yes" xml:space="preserve">
          <source>@b_str</source>
          <target state="translated">@b_str</target>
        </trans-unit>
        <trans-unit id="f0925e6a5b16433b144a470019c1c0dd5de55e2d" translate="yes" xml:space="preserve">
          <source>@boundscheck</source>
          <target state="translated">@boundscheck</target>
        </trans-unit>
        <trans-unit id="4c462c8f8efc0e427cbc1cf6bea236a9cc0c83e0" translate="yes" xml:space="preserve">
          <source>@cfunction</source>
          <target state="translated">@cfunction</target>
        </trans-unit>
        <trans-unit id="4edd1d89ba51e67e5cde36c993ecbd6d4257872d" translate="yes" xml:space="preserve">
          <source>@deprecate</source>
          <target state="translated">@deprecate</target>
        </trans-unit>
        <trans-unit id="c460a7d72a405ba1e96118402a7742091a82dc52" translate="yes" xml:space="preserve">
          <source>@elapsed</source>
          <target state="translated">@elapsed</target>
        </trans-unit>
        <trans-unit id="34bfbc0fb605f42aad89cbd346daff31c66f5b0e" translate="yes" xml:space="preserve">
          <source>@eval</source>
          <target state="translated">@eval</target>
        </trans-unit>
        <trans-unit id="0ce3f8c769d6a2e9b95a931f13c7916418581d1b" translate="yes" xml:space="preserve">
          <source>@generated</source>
          <target state="translated">@generated</target>
        </trans-unit>
        <trans-unit id="d7621df9275358d3c30a2cfd8844f4521261ee73" translate="yes" xml:space="preserve">
          <source>@gensym</source>
          <target state="translated">@gensym</target>
        </trans-unit>
        <trans-unit id="a443a35e19dcd1ec15e45404c7ffcdeb21fd2474" translate="yes" xml:space="preserve">
          <source>@goto</source>
          <target state="translated">@goto</target>
        </trans-unit>
        <trans-unit id="19d47413bcaa88444056e76c473085f6a1b72db9" translate="yes" xml:space="preserve">
          <source>@inbounds</source>
          <target state="translated">@inbounds</target>
        </trans-unit>
        <trans-unit id="b5cf25ca00c54f41be13cd9463b582cceefc51b6" translate="yes" xml:space="preserve">
          <source>@inline</source>
          <target state="translated">@inline</target>
        </trans-unit>
        <trans-unit id="8ca0acccfff73ec5f39bf9a76ceb21c3d72aa439" translate="yes" xml:space="preserve">
          <source>@isdefined</source>
          <target state="translated">@isdefined</target>
        </trans-unit>
        <trans-unit id="03c2e7fdb001cbf566801d52a83375cbdaa52bd5" translate="yes" xml:space="preserve">
          <source>@label</source>
          <target state="translated">@label</target>
        </trans-unit>
        <trans-unit id="4ea1201781ae986fc43d71514b609cb6e748d76c" translate="yes" xml:space="preserve">
          <source>@macroexpand</source>
          <target state="translated">@macroexpand</target>
        </trans-unit>
        <trans-unit id="1fd88e55d30c6edcea950811aea00f2ce4456bac" translate="yes" xml:space="preserve">
          <source>@macroexpand1</source>
          <target state="translated">@macroexpand1</target>
        </trans-unit>
        <trans-unit id="78b6dbe95bbae61a934cb6e904cb50533688efaf" translate="yes" xml:space="preserve">
          <source>@noinline</source>
          <target state="translated">@noinline</target>
        </trans-unit>
        <trans-unit id="a5325bbb0409334c7f59038d601431b5a3a33c33" translate="yes" xml:space="preserve">
          <source>@nospecialize</source>
          <target state="translated">@nospecialize</target>
        </trans-unit>
        <trans-unit id="cacd42ee4286c01451a0c3f4cbfa6028f915c0f9" translate="yes" xml:space="preserve">
          <source>@polly</source>
          <target state="translated">@polly</target>
        </trans-unit>
        <trans-unit id="4806d3609cdd2247d8453f645dee6710dc41ea0f" translate="yes" xml:space="preserve">
          <source>@propagate_inbounds</source>
          <target state="translated">@propagate_inbounds</target>
        </trans-unit>
        <trans-unit id="8d60f37515947a1cb20c28aea812b1fc5a9f5bf0" translate="yes" xml:space="preserve">
          <source>@pure</source>
          <target state="translated">@pure</target>
        </trans-unit>
        <trans-unit id="3a55093c30bbbe794bf8d402406d8fcf7a4d1310" translate="yes" xml:space="preserve">
          <source>@r_str</source>
          <target state="translated">@r_str</target>
        </trans-unit>
        <trans-unit id="5996760e14e5f71bfe6fa0d484bd050be2d81350" translate="yes" xml:space="preserve">
          <source>@raw_str</source>
          <target state="translated">@raw_str</target>
        </trans-unit>
        <trans-unit id="97cb7ca3c593693dc788600f2394549a69a72d68" translate="yes" xml:space="preserve">
          <source>@s_str</source>
          <target state="translated">@s_str</target>
        </trans-unit>
        <trans-unit id="0b2cd610c2ee6714f1bb72ef08e30cbecc00753b" translate="yes" xml:space="preserve">
          <source>@show</source>
          <target state="translated">@show</target>
        </trans-unit>
        <trans-unit id="74ed0e99c473ebedb95b8c861f075073cb57397f" translate="yes" xml:space="preserve">
          <source>@specialize</source>
          <target state="translated">@specialize</target>
        </trans-unit>
        <trans-unit id="151387036f429960867face2abcd91f32770c4e2" translate="yes" xml:space="preserve">
          <source>@static</source>
          <target state="translated">@static</target>
        </trans-unit>
        <trans-unit id="a68f475d88760f9b0feb2de9ebbfc91426a3b8f2" translate="yes" xml:space="preserve">
          <source>@sync</source>
          <target state="translated">@sync</target>
        </trans-unit>
        <trans-unit id="d38a8f83640ce0fff0b022161540cfdf0fb32550" translate="yes" xml:space="preserve">
          <source>@task</source>
          <target state="translated">@task</target>
        </trans-unit>
        <trans-unit id="aa18b4621d361b5a46f6036593dc03baa5cf1328" translate="yes" xml:space="preserve">
          <source>@threadcall</source>
          <target state="translated">@threadcall</target>
        </trans-unit>
        <trans-unit id="692eee2d0727b5f3f157c333231a8f4d656b6df0" translate="yes" xml:space="preserve">
          <source>@threadcall (Experimental)</source>
          <target state="translated">@threadcall (экспериментальный)</target>
        </trans-unit>
        <trans-unit id="cd087251781047bb579dc74d06a058b6ba3920e2" translate="yes" xml:space="preserve">
          <source>@time</source>
          <target state="translated">@time</target>
        </trans-unit>
        <trans-unit id="8568facb0a4570662a512fe404e622e193f338a6" translate="yes" xml:space="preserve">
          <source>@timed</source>
          <target state="translated">@timed</target>
        </trans-unit>
        <trans-unit id="27b687fc74e91aa623c8e1b6ee200080f7df4707" translate="yes" xml:space="preserve">
          <source>@timev</source>
          <target state="translated">@timev</target>
        </trans-unit>
        <trans-unit id="805c0ec7ef38a1e449165679942f376bf2b79ddf" translate="yes" xml:space="preserve">
          <source>@v_str</source>
          <target state="translated">@v_str</target>
        </trans-unit>
        <trans-unit id="30bb2b68176ace645967cfe93607300e8069c9f2" translate="yes" xml:space="preserve">
          <source>@view</source>
          <target state="translated">@view</target>
        </trans-unit>
        <trans-unit id="c0636d48f28866f15bfbc1ee9241d4414596eec3" translate="yes" xml:space="preserve">
          <source>@views</source>
          <target state="translated">@views</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="ae3a173d257f68d7b3200b2390513b03472ff42a" translate="yes" xml:space="preserve">
          <source>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported &lt;code&gt;isbits&lt;/code&gt; element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides(A)&lt;/code&gt;&lt;/a&gt; method that returns a tuple of &quot;strides&quot; for each dimension; a provided &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt; method accesses the &lt;code&gt;k&lt;/code&gt;th element within this tuple. Increasing the index of dimension &lt;code&gt;k&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; should increase the index &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;getindex(A,i)&lt;/code&gt; by &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt;. If a pointer conversion method &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt;&lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt;&lt;/a&gt; is provided, the memory layout must correspond in the same way to these strides. &lt;code&gt;DenseArray&lt;/code&gt; is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the appropriate definition of &lt;code&gt;strides&lt;/code&gt;. More concrete examples can be found within the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;interface guide for strided arrays&lt;/a&gt;. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">&amp;laquo;Строчный&amp;raquo; массив хранится в памяти с элементами, размещенными в регулярных смещениях, так что экземпляр с поддерживаемым &lt;code&gt;isbits&lt;/code&gt; элемента isbits может быть передан внешним функциям C и Fortran, которые ожидают этого макета памяти. Массивы с &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt; &lt;code&gt;strides(A)&lt;/code&gt; &lt;/a&gt; должны определять метод strides (A), который возвращает кортеж &amp;laquo;шагов&amp;raquo; для каждого измерения; предоставленный метод &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; обращается к &lt;code&gt;k&lt;/code&gt; - му элементу в этом кортеже. Увеличение индекса измерения &lt;code&gt;k&lt;/code&gt; на &lt;code&gt;1&lt;/code&gt; должно увеличивать индекс &lt;code&gt;i&lt;/code&gt; для &lt;code&gt;getindex(A,i)&lt;/code&gt; на &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; . Если метод преобразования указателя &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt; &lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt; &lt;/a&gt;предусмотрено, макет памяти должен точно так же соответствовать этим шагам. &lt;code&gt;DenseArray&lt;/code&gt; - это очень специфический пример массива с полосами, в котором элементы расположены непрерывно, поэтому он предоставляет своим подтипам соответствующее определение &lt;code&gt;strides&lt;/code&gt; . Более конкретные примеры можно найти в &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;руководстве по интерфейсу для полосатых массивов&lt;/a&gt; . &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt; - удобные псевдонимы для многих типов встроенных массивов, которые считаются последовательными массивами, что позволяет им отправлять на выбор специализированные реализации, вызывающие хорошо настроенные и оптимизированные функции BLAS и LAPACK, используя только указатель и шаги.</target>
        </trans-unit>
        <trans-unit id="b06ef311fe65245308768dcdeb585be5facb485c" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;view&amp;rdquo; is a data structure that acts like an array (it is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;), but the underlying data is actually part of another array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a6d45076b09098eb9df88807c997bb15e85369" translate="yes" xml:space="preserve">
          <source>A (all)</source>
          <target state="translated">А (все)</target>
        </trans-unit>
        <trans-unit id="9e0270f067c0a720b45c4eb9f114b3b4f763ba05" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LibGit2.GitCommit&quot;&gt;&lt;code&gt;GitCommit&lt;/code&gt;&lt;/a&gt; will be peeled to a &lt;a href=&quot;#LibGit2.GitTree&quot;&gt;&lt;code&gt;GitTree&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#LibGit2.GitCommit&quot;&gt; &lt;code&gt;GitCommit&lt;/code&gt; &lt;/a&gt; будет очищенный к &lt;a href=&quot;#LibGit2.GitTree&quot;&gt; &lt;code&gt;GitTree&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba75f83e672a51cdb25eeef228f835e8a4e0af8a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; operator represents a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. The identity operator &lt;code&gt;I&lt;/code&gt; is defined as a constant and is an instance of &lt;code&gt;UniformScaling&lt;/code&gt;. The size of these operators are generic and match the other matrix in the binary operations &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;. For &lt;code&gt;A+I&lt;/code&gt; and &lt;code&gt;A-I&lt;/code&gt; this means that &lt;code&gt;A&lt;/code&gt; must be square. Multiplication with the identity operator &lt;code&gt;I&lt;/code&gt; is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; оператор представляет собой скалярные раз тождественный оператор, &lt;code&gt;&amp;lambda;*I&lt;/code&gt; . Оператор идентичности &lt;code&gt;I&lt;/code&gt; определяется как константа и является экземпляром &lt;code&gt;UniformScaling&lt;/code&gt; . Размер этих операторов является общим и соответствует другой матрице в бинарных операциях &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;\&lt;/code&gt; . Для &lt;code&gt;A+I&lt;/code&gt; и &lt;code&gt;A-I&lt;/code&gt; это означает, что &lt;code&gt;A&lt;/code&gt; должно быть квадратным. Умножение с оператором идентичности &lt;code&gt;I&lt;/code&gt; не требует никаких затрат (за исключением проверки того, что коэффициент масштабирования равен единице) и, следовательно, почти без накладных расходов.</target>
        </trans-unit>
        <trans-unit id="c842dce0eb13d715db2132316b0c05a4d0e9a5e4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; that sets the value of &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; (default: &lt;code&gt;60.0&lt;/code&gt;). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , который устанавливает значение &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; ( по умолчанию: &lt;code&gt;60.0&lt;/code&gt; ). Эта функция дает количество секунд, в течение которых рабочий процесс будет ждать, пока главный процесс установит соединение, прежде чем завершиться.</target>
        </trans-unit>
        <trans-unit id="f904b64ee325fb09a13719884cf4994b4a67dc0b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is in an open state initially. This means that it can be read from and written to freely via &lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;put!&lt;/code&gt; calls. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; closes a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. On a closed &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;put!&lt;/code&gt; will fail. For example:</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; находится в открытом состоянии на начальном этапе. Это означает, что его можно свободно читать и записывать с помощью &lt;code&gt;take!&lt;/code&gt; и &lt;code&gt;put!&lt;/code&gt; звонки. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; закрывает &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; . На закрытом &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;put!&lt;/code&gt; не удастся. Например:</target>
        </trans-unit>
        <trans-unit id="8375d9780c1ae8c1682f81b0f7a6ce2515b39852" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is local to a process. Worker 2 cannot directly refer to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; on worker 3 and vice-versa. A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, however, can put and take values across workers.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; является локальным для процесса. Работник 2 не может напрямую ссылаться на &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; на работнике 3 и наоборот. Однако &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; может передавать и принимать значения между исполнителями.</target>
        </trans-unit>
        <trans-unit id="fc8c6fb411b59b42a835d08f8b3cc960e82887e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can be thought of as a &lt;em&gt;handle&lt;/em&gt; to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; можно рассматривать как &lt;em&gt;ручки&lt;/em&gt; на &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17cfa5600f21f142fc6aae797119fcc13529b73c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; iterator of length &lt;code&gt;n&lt;/code&gt; whose elements exponentially increase at a rate in the interval &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt;). The first element is &lt;code&gt;first_delay&lt;/code&gt; and all elements are clamped to &lt;code&gt;max_delay&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; итератор длиной &lt;code&gt;n&lt;/code&gt; , элементы которой растет экспоненциально со скоростью в интервале &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt; ). Первый элемент - &lt;code&gt;first_delay&lt;/code&gt; , и все элементы &lt;code&gt;max_delay&lt;/code&gt; на max_delay .</target>
        </trans-unit>
        <trans-unit id="4eff87e10245c4721bd18e0368a4c02ba6a49f3c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair (most common),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c79d61fbf339539f4166e2a7bfbe466aba53081" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, which must be written as a literal constant,</source>
          <target state="translated">&lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; пара, который должен быть записан в виде буквальной константы,</target>
        </trans-unit>
        <trans-unit id="524fcaed9fa041013c206a6350ca0d844bfa68a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(name, library)&lt;/code&gt; function specification must be a constant expression. However, it is possible to use computed values as function names by staging through &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;(name, library)&lt;/code&gt; функция спецификация должна быть константным выражением. Тем не менее, можно использовать вычисленные значения в качестве имен функций, используя &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="d15e6f0f33d377d6237a8e9e56d281edb772d043" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character on either end of a column's header separator (the row containing &lt;code&gt;-&lt;/code&gt; characters) specifies whether the row is left-aligned, right-aligned, or (when &lt;code&gt;:&lt;/code&gt; appears on both ends) center-aligned. Providing no &lt;code&gt;:&lt;/code&gt; characters will default to right-aligning the column.</source>
          <target state="translated">A &lt;code&gt;:&lt;/code&gt; символ на любом конце разделителя заголовка столбца (строка, содержащая символы &lt;code&gt;-&lt;/code&gt; ) определяет, выравнивается ли строка по левому краю, по правому краю или (когда &lt;code&gt;:&lt;/code&gt; появляется на обоих концах) по центру. Если нет &lt;code&gt;:&lt;/code&gt; символы по умолчанию выравнивают столбец по правому краю.</target>
        </trans-unit>
        <trans-unit id="d46ad2498166339bc8bbf3585924bc43d1e8d5c2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufferStream&lt;/code&gt; is an in-memory &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; which behaves like an &lt;code&gt;IO&lt;/code&gt;&amp;ndash;it is a stream which can be handled asynchronously.</source>
          <target state="translated">&lt;code&gt;BufferStream&lt;/code&gt; находится в оперативной памяти &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; , которая ведет себя как &lt;code&gt;IO&lt;/code&gt; -IT представляет собой поток , который может быть обработан асинхронно.</target>
        </trans-unit>
        <trans-unit id="d1f408408afbccca18234c62817be522377e93f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CartesianIndex&lt;/code&gt; is sometimes produced by &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt;, and always when iterating with an explicit &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CartesianIndex&lt;/code&gt; иногда производится &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; , и всегда при переборе с явной &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d375921fbca2bf53253dd9c9c9cb98fe33f687c8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Channel&lt;/code&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop runs as long as the &lt;code&gt;Channel&lt;/code&gt; has data or is open. The loop variable takes on all values added to the &lt;code&gt;Channel&lt;/code&gt;. The &lt;code&gt;for&lt;/code&gt; loop is terminated once the &lt;code&gt;Channel&lt;/code&gt; is closed and emptied.</source>
          <target state="translated">&lt;code&gt;Channel&lt;/code&gt; может быть использован в качестве итератора объекта в &lt;code&gt;for&lt;/code&gt; цикла, и в этом случае цикл выполняется до тех пор , как &lt;code&gt;Channel&lt;/code&gt; имеет данные или открыто. Переменная цикла принимает все значения, добавленные к &lt;code&gt;Channel&lt;/code&gt; . Цикл &lt;code&gt;for&lt;/code&gt; завершается после закрытия и опорожнения &lt;code&gt;Channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1464a151c99f208872dfcf6ce120c5e13267f23e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Char&lt;/code&gt; value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode code point&lt;/a&gt;. (Julia packages may define other subtypes of &lt;code&gt;AbstractChar&lt;/code&gt;, e.g. to optimize operations for other &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;text encodings&lt;/a&gt;.) Here is how &lt;code&gt;Char&lt;/code&gt; values are input and shown:</source>
          <target state="translated">Значение &lt;code&gt;Char&lt;/code&gt; представляет один символ: это всего лишь 32-битный примитивный тип со специальным буквальным представлением и соответствующим арифметическим поведением, который можно преобразовать в числовое значение, представляющее &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;кодовую точку Unicode&lt;/a&gt; . (Пакеты Julia могут определять другие подтипы &lt;code&gt;AbstractChar&lt;/code&gt; , например, для оптимизации операций для других &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;текстовых кодировок&lt;/a&gt; .) Вот как значения &lt;code&gt;Char&lt;/code&gt; вводятся и отображаются:</target>
        </trans-unit>
        <trans-unit id="29831ac830f246eb0b5dcfbe779b29bb30cb2979" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CompoundPeriod&lt;/code&gt; is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, &quot;a year and a day&quot; is not a fixed number of days, but can be expressed using a &lt;code&gt;CompoundPeriod&lt;/code&gt;. In fact, a &lt;code&gt;CompoundPeriod&lt;/code&gt; is automatically generated by addition of different period types, e.g. &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; produces a &lt;code&gt;CompoundPeriod&lt;/code&gt; result.</source>
          <target state="translated">&lt;code&gt;CompoundPeriod&lt;/code&gt; полезно для выражения периодов времени, которые не являются фиксированной кратно меньших периодов. Например, &amp;laquo;год и день&amp;raquo; - это не фиксированное количество дней, но его можно выразить с помощью &lt;code&gt;CompoundPeriod&lt;/code&gt; . Фактически &lt;code&gt;CompoundPeriod&lt;/code&gt; автоматически генерируется путем добавления различных типов периодов, например, &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; дает результат &lt;code&gt;CompoundPeriod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="013639aa4c9e00f4e19703e4c05f20b5824ce3b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DataType&lt;/code&gt; may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a &lt;code&gt;DataType&lt;/code&gt; with nonzero size, but no field names. A composite type is a &lt;code&gt;DataType&lt;/code&gt; that has field names or is empty (zero size).</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; может быть абстрактными или бетоном. Если он конкретный, он имеет указанный размер, схему хранения и (необязательно) имена полей. Таким образом, примитивный тип - это &lt;code&gt;DataType&lt;/code&gt; с ненулевым размером, но без имен полей. Составной тип - это &lt;code&gt;DataType&lt;/code&gt; , имеющий имена полей или пустой (нулевой размер).</target>
        </trans-unit>
        <trans-unit id="8254718d7cf35196b57a0c256656d29ca6967f68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Future&lt;/code&gt; is a placeholder for a single computation of unknown termination status and time. For multiple potential computations, see &lt;code&gt;RemoteChannel&lt;/code&gt;. See &lt;code&gt;remoteref_id&lt;/code&gt; for identifying an &lt;code&gt;AbstractRemoteRef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a8047ce7922366b0e1686ff32c1d95d34209f7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitCommit&lt;/code&gt; will be peeled to a &lt;code&gt;GitTree&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GitCommit&lt;/code&gt; будет очищенный к &lt;code&gt;GitTree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d18c2ea92257c3ec465776fe14e9a5ed1ec94622" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitRevWalker&lt;/code&gt;&lt;em&gt;walks&lt;/em&gt; through the &lt;em&gt;revisions&lt;/em&gt; (i.e. commits) of a git repository &lt;code&gt;repo&lt;/code&gt;. It is a collection of the commits in the repository, and supports iteration and calls to &lt;a href=&quot;#LibGit2.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LibGit2.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; (for instance, &lt;code&gt;count&lt;/code&gt; could be used to determine what percentage of commits in a repository were made by a certain author).</source>
          <target state="translated">&lt;code&gt;GitRevWalker&lt;/code&gt; &lt;em&gt;ходит&lt;/em&gt; по &lt;em&gt;пересмотру&lt;/em&gt; (т.е. фиксаций) одного мерзавца хранилища &lt;code&gt;repo&lt;/code&gt; . Это набор коммитов в репозитории, который поддерживает итерацию и вызовы для &lt;a href=&quot;#LibGit2.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#LibGit2.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; (например, &lt;code&gt;count&lt;/code&gt; можно использовать для определения того, какой процент коммитов в репозитории был сделан определенным автором).</target>
        </trans-unit>
        <trans-unit id="7218806e6e918d7a7efe224d0bbd25603b822749" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitTag&lt;/code&gt; will be peeled to the object it references.</source>
          <target state="translated">&lt;code&gt;GitTag&lt;/code&gt; будет очищен до объекта он ссылается.</target>
        </trans-unit>
        <trans-unit id="9ecaf0ba8d28df22c60ef1b5589bb9e3a4cbe6da" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Hessenberg&lt;/code&gt; object represents the Hessenberg factorization &lt;code&gt;QHQ'&lt;/code&gt; of a square matrix, or a shift &lt;code&gt;Q(H+&amp;mu;I)Q'&lt;/code&gt; thereof, which is produced by the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56db16f375b3ec2b4282d7f16a671aeb187ec450" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="translated">&lt;code&gt;MIME&lt;/code&gt; - объект может быть передан в качестве второго аргумента &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; для вывода запроса в этом формате.</target>
        </trans-unit>
        <trans-unit id="bd67479c52c92dddc64ec714d9c7069f1b10867a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ab14f4b27b0ebae05bdd35cfc7b0f0829b66e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MersenneTwister&lt;/code&gt; or &lt;code&gt;RandomDevice&lt;/code&gt; RNG can generate uniformly random numbers of the following types: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt;&lt;code&gt;UInt128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; (or complex numbers of those types). Random floating point numbers are generated uniformly in $[0, 1)$. As &lt;code&gt;BigInt&lt;/code&gt; represents unbounded integers, the interval must be specified (e.g. &lt;code&gt;rand(big.(1:6))&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;MersenneTwister&lt;/code&gt; или &lt;code&gt;RandomDevice&lt;/code&gt; ГСЧ может генерировать равномерно случайные числа следующих типов: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt; &lt;code&gt;UInt128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; (или комплексные числа этих типов). Случайные числа с плавающей запятой генерируются равномерно в $ [0, 1) $. Как &lt;code&gt;BigInt&lt;/code&gt; представляет неограниченные целые числа, интервал должен быть указан (например, &lt;code&gt;rand(big.(1:6))&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="93e7981a3162e9783d86dcf2247127a2e48a689e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc156039502be223f5f3af68d44a563690ef471" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; является отдельной глобальной переменной рабочей областью. См. &lt;a href=&quot;#module&quot;&gt; &lt;code&gt;module&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;раздел руководства о модулях&lt;/a&gt; для получения подробной информации.</target>
        </trans-unit>
        <trans-unit id="a7ec3daecca2c04b2bae1c27f0094a5422da6aa1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;N&lt;/code&gt;-dimensional custom array that reports its &lt;code&gt;IndexStyle&lt;/code&gt; as &lt;code&gt;IndexCartesian&lt;/code&gt; needs to implement indexing (and indexed assignment) with exactly &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices; all other indexing expressions &amp;mdash; including linear indexing &amp;mdash; will be recomputed to the equivalent Cartesian location. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;2&amp;times;3&lt;/code&gt; custom matrix with cartesian indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt;, this would be recomputed to the equivalent Cartesian index and call &lt;code&gt;A[1, 3]&lt;/code&gt; since &lt;code&gt;5 = 2*1 + 3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe27036120fb22dce22db3d877ea4b7e275e7b94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NamedTuple&lt;/code&gt; type can be used as a constructor, accepting a single tuple argument. The constructed &lt;code&gt;NamedTuple&lt;/code&gt; type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</source>
          <target state="translated">Тип &lt;code&gt;NamedTuple&lt;/code&gt; можно использовать как конструктор, принимающий единственный аргумент кортежа. Построенная &lt;code&gt;NamedTuple&lt;/code&gt; типа может быть либо типа бетона, с указанным оба параметра, или типа , который определяет только имена полей:</target>
        </trans-unit>
        <trans-unit id="ea99f7079d8791c0343a7307d5e653f1f644267c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Polar&lt;/code&gt; object will then display automatically using HTML in an environment that supports HTML display, but you can call &lt;code&gt;show&lt;/code&gt; manually to get HTML output if you want:</source>
          <target state="translated">Затем объект &lt;code&gt;Polar&lt;/code&gt; будет автоматически отображаться с использованием HTML в среде, которая поддерживает отображение HTML, но вы можете вызвать &lt;code&gt;show&lt;/code&gt; вручную, чтобы получить вывод HTML, если хотите:</target>
        </trans-unit>
        <trans-unit id="3992f5106e091bf1a1db28341609bec19be4cafd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3372e99dcae94f7a8aba1e912fc8ad984983e16" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="translated">Объект &lt;code&gt;VersionNumber&lt;/code&gt; , описывающий, какая версия Julia используется. Подробнее см. &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Литералы номера версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b5d6ebeedad778839a920e823243163f3ccd68a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1b0b9643100f5709d747b0fa1193640db35af9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">Блок &lt;code&gt;do&lt;/code&gt; , как и любая другая внутренняя функция, может &amp;laquo;захватывать&amp;raquo; переменные из окружающей его области видимости. Например, &lt;code&gt;data&lt;/code&gt; переменных в приведенном выше примере &lt;code&gt;open...do&lt;/code&gt; захватываются из внешней области. Захваченные переменные могут создавать проблемы с производительностью, как описано в &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;советах&lt;/a&gt; по производительности .</target>
        </trans-unit>
        <trans-unit id="13afa4d8f5eaeee48f3a15d19e444c7dc58d320a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop or comprehension iteration variable is always a new variable:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; цикла или переменной понимание итерации всегда новая переменная:</target>
        </trans-unit>
        <trans-unit id="1cc87568b64210c7c32ecbee8a0599fd750c9777" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;group&lt;/code&gt; for the event, which is set to the base name of the file by default, without extension. This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group &lt;code&gt;:depwarn&lt;/code&gt;), or into logical groupings across or within modules.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; для события, которое устанавливается на базовое имя файла по умолчанию, без расширения. Это можно использовать для более &lt;code&gt;:depwarn&lt;/code&gt; группировки сообщений по категориям, чем уровень журнала (например, все предупреждения об устаревании имеют group : depwarn ) или в логические группировки по модулям или внутри них.</target>
        </trans-unit>
        <trans-unit id="236e91049303fa66d220cd5b5421a9050d83f949" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement allows intercepting errors (exceptions) thrown by &lt;a href=&quot;#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; утверждение позволяет перехватывать ошибки (исключения) , брошенные &lt;a href=&quot;#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; , так что выполнение программы может быть продолжено. Например, следующий код пытается записать файл, но предупреждает пользователя и продолжает вместо завершения выполнения, если файл не может быть записан:</target>
        </trans-unit>
        <trans-unit id="6f7e3d0cb44d68c0e786c74714c652c1e6239ca4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package&lt;/em&gt; is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt; statements. These statements also make the module named &lt;code&gt;X&lt;/code&gt;&amp;mdash;which results from loading the package code&amp;mdash;available within the module where the import statement occurs. The meaning of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; is context-dependent: which &lt;code&gt;X&lt;/code&gt; package is loaded depends on what code the statement occurs in. Thus, handling of &lt;code&gt;import X&lt;/code&gt; happens in two stages: first, it determines &lt;strong&gt;what&lt;/strong&gt; package is defined to be &lt;code&gt;X&lt;/code&gt; in this context; second, it determines &lt;strong&gt;where&lt;/strong&gt; that particular &lt;code&gt;X&lt;/code&gt; package is found.</source>
          <target state="translated">&lt;em&gt;Пакет&lt;/em&gt; является источник дерева со стандартной компоновкой обеспечения функциональных возможностей, которые могут быть повторно использованы в других проектах Юлия. Пакет загружается с помощью &lt;code&gt;import X&lt;/code&gt; или &lt;code&gt;using X&lt;/code&gt; операторов X. Эти операторы также делают модуль с именем &lt;code&gt;X&lt;/code&gt; , который является результатом загрузки кода пакета, доступным внутри модуля, в котором выполняется оператор импорта. Значение &lt;code&gt;X&lt;/code&gt; в &lt;code&gt;import X&lt;/code&gt; зависит от контекста: какой пакет &lt;code&gt;X&lt;/code&gt; загружен, зависит от того, в каком коде встречается оператор. Таким образом, обработка &lt;code&gt;import X&lt;/code&gt; происходит в два этапа: во-первых, он определяет, &lt;strong&gt;какой&lt;/strong&gt; пакет определен как &lt;code&gt;X&lt;/code&gt; в контексте; во-вторых, он определяет, &lt;strong&gt;где находится&lt;/strong&gt; этот конкретный пакет &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ea5ce3cb4556ddc297c6aeebda772ae9221423a" translate="yes" xml:space="preserve">
          <source>A C function declared to return &lt;code&gt;Cvoid&lt;/code&gt; will return the value &lt;code&gt;nothing&lt;/code&gt; in Julia.</source>
          <target state="translated">Функция AC, объявленная как возвращающая &lt;code&gt;Cvoid&lt;/code&gt; , вернет в Julia значение &lt;code&gt;nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="390614814aa5adb2a2fccf6c0c90c7149f4d96ba" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def83ea9fa11b0a4be5ef6b08c5ce4257e5755ca" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Строка в стиле C, состоящая из собственного символьного типа &lt;a href=&quot;#Base.Cchar&quot;&gt; &lt;code&gt;Cchar&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;Cstring&lt;/code&gt; завершаются NUL. Для строк в стиле C, состоящих из собственного типа широких символов, см. &lt;a href=&quot;#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о взаимодействии строк с C см. В &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;руководстве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18521ba47ad36cc4f8c112bae48ca35ecb2ee122" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0a9fe2ade0eb6e9c2e2cc4b61f726d6a965d9c" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Строка в стиле C, состоящая из собственного типа широких символов &lt;a href=&quot;#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;Cwstring&lt;/code&gt; завершаются NUL. Для строк в стиле C, состоящих из собственного символьного типа, см. &lt;a href=&quot;#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о взаимодействии строк с C см. В &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;руководстве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c197fd05f688124d54264f0b58fc3c22d93ec77c" translate="yes" xml:space="preserve">
          <source>A Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional array, with exactly one index per dimension. This means that requesting &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; from an array that is &lt;code&gt;IndexCartesian&lt;/code&gt; will return a range of &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023376b34dc0e6e575fb072d80744bfc1276423d" translate="yes" xml:space="preserve">
          <source>A Givens rotation linear operator. The fields &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; represent the cosine and sine of the rotation angle, respectively. The &lt;code&gt;Givens&lt;/code&gt; type supports left multiplication &lt;code&gt;G*A&lt;/code&gt; and conjugated transpose right multiplication &lt;code&gt;A*G'&lt;/code&gt;. The type doesn't have a &lt;code&gt;size&lt;/code&gt; and can therefore be multiplied with matrices of arbitrary size as long as &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; for &lt;code&gt;G*A&lt;/code&gt; or &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; for &lt;code&gt;A*G'&lt;/code&gt;.</source>
          <target state="translated">Линейный оператор вращения Гивенса. Поля &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;s&lt;/code&gt; представляют собой косинус и синус угла поворота соответственно. Тип &lt;code&gt;Givens&lt;/code&gt; поддерживает левое умножение &lt;code&gt;G*A&lt;/code&gt; и сопряженное транспонирование правого умножения &lt;code&gt;A*G'&lt;/code&gt; . Тип не имеет &lt;code&gt;size&lt;/code&gt; и поэтому может быть умножен на матрицы произвольного размера, если &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; для &lt;code&gt;G*A&lt;/code&gt; или &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; для &lt;code&gt;A*G'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0f95cfdddef2f3b16bd0eaacf8c5ec7871a86e5" translate="yes" xml:space="preserve">
          <source>A Julia Function</source>
          <target state="translated">Функция Джулии</target>
        </trans-unit>
        <trans-unit id="338b907694ffa95225d1463f09b5454501424162" translate="yes" xml:space="preserve">
          <source>A Julia cluster has the following characteristics:</source>
          <target state="translated">Кластер Джулия обладает следующими характеристиками:</target>
        </trans-unit>
        <trans-unit id="b46f55d05b4cea9eeb2d26c893736aefe4db768d" translate="yes" xml:space="preserve">
          <source>A Julia function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbb147573dcd49250e15c543ce261c2ed456757" translate="yes" xml:space="preserve">
          <source>A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</source>
          <target state="translated">Скрипт Julia может содержать любое количество функций,и все определения будут внешне видны при загрузке файла.Определения функций могут быть загружены из файлов вне текущей рабочей директории.</target>
        </trans-unit>
        <trans-unit id="ec5c0a21b198e35d9011cfccf1720c04200ccca0" translate="yes" xml:space="preserve">
          <source>A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The &lt;code&gt;payload_ptr&lt;/code&gt; is required to contain a &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; object which will keep track of state and settings.</source>
          <target state="translated">Функция обратного вызова учетных данных LibGit2, которая обеспечивает различные функции получения учетных данных по протоколу подключения. &lt;code&gt;payload_ptr&lt;/code&gt; обязан содержать &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; объект , который будет следить за состоянием и настройками.</target>
        </trans-unit>
        <trans-unit id="01a933ad46a5f5ec0c3c3e174d75cd08e0a9bf13" translate="yes" xml:space="preserve">
          <source>A LibGit2 representation of an array of strings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt;&lt;code&gt;git_strarray&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Представление LibGit2 массива строк. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt; &lt;code&gt;git_strarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6b4f3bedfc4889701c09c75dc083d1c8d58006" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a compact blocked format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">Факторизация QR-матрицы, хранящаяся в компактном блочном формате, обычно получается из &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; . Если $ A $ - матрица размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="a2bfddaee8ff7a44aec0ab4b2b1e184a0f187d2e" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">Факторизация QR-матрицы, хранящаяся в упакованном формате, обычно полученная из &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; . Если $ A $ - матрица размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="c9925c571d2e1e694cc1d660f2d03ec4cf1ec057" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization with column pivoting in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">Факторизация QR-матрицы с поворотом столбцов в упакованном формате, обычно получаемая из &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; . Если $ A $ - матрица размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="028b2fd647f67d6a5b3b18c1e2a4be06ea973f76" translate="yes" xml:space="preserve">
          <source>A basic editor/REPL workflow</source>
          <target state="translated">Базовый редактор/РЕПОЛЬНЫЙ рабочий процесс</target>
        </trans-unit>
        <trans-unit id="3e270c005ba798894763e8eb54b974bf29e5d476" translate="yes" xml:space="preserve">
          <source>A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by &lt;a href=&quot;#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Буферизованный поток ввода-вывода, обертывающий файловый дескриптор ОС. В основном используется для представления файлов, возвращаемых &lt;a href=&quot;#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6761a9dad52906730c7e2d2e824c87ab1ba9a0c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt;, which may then be passed into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; for translation:</source>
          <target state="translated">Вызов &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; возвращает вектор &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt; , который затем может быть передан в &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; для перевода:</target>
        </trans-unit>
        <trans-unit id="783595edaa0cd8106f88e2687e628c9ad8922d54" translate="yes" xml:space="preserve">
          <source>A cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3, 4)&lt;/code&gt; custom matrix type with cartesian indexing, we could reference &lt;code&gt;A[2, 1, 3]&lt;/code&gt; and Julia would automatically convert this into the correct location in the underlying memory. See also &lt;a href=&quot;#Base.IndexLinear&quot;&gt;&lt;code&gt;IndexLinear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В декартовом стиле индексации для описания позиции в массиве используется несколько целых чисел / индексов. Например, если бы &lt;code&gt;A&lt;/code&gt; был пользовательским типом матрицы &lt;code&gt;(2, 3, 4)&lt;/code&gt; с декартовой индексацией, мы могли бы ссылаться на &lt;code&gt;A[2, 1, 3]&lt;/code&gt; и Джулия автоматически преобразовала бы это в правильное место в базовой памяти. См. Также &lt;a href=&quot;#Base.IndexLinear&quot;&gt; &lt;code&gt;IndexLinear&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b670cf7ce6aa053516969f59beb26f75521a626" translate="yes" xml:space="preserve">
          <source>A channel can be visualized as a pipe, i.e., it has a write end and a read end :</source>
          <target state="translated">Канал можно визуализировать как трубу,т.е.у него есть конец для записи и конец для чтения:</target>
        </trans-unit>
        <trans-unit id="cda0bd3645d716870c693b3b59018dd4924caf33" translate="yes" xml:space="preserve">
          <source>A classic example is the standard C library &lt;code&gt;qsort&lt;/code&gt; function, declared as:</source>
          <target state="translated">Классическим примером является стандартная функция &lt;code&gt;qsort&lt;/code&gt; библиотеки C , объявленная как:</target>
        </trans-unit>
        <trans-unit id="e90162b2f2534c5d2ad98ffd6060c363829dd8a7" translate="yes" xml:space="preserve">
          <source>A cluster spanning machines using the &lt;code&gt;--machine-file&lt;/code&gt; option. This uses a passwordless &lt;code&gt;ssh&lt;/code&gt; login to start Julia worker processes (from the same path as the current host) on the specified machines.</source>
          <target state="translated">Кластер, охватывающий машины, использующий параметр &lt;code&gt;--machine-file&lt;/code&gt; . При этом используется вход по &lt;code&gt;ssh&lt;/code&gt; без пароля для запуска рабочих процессов Julia (с того же пути, что и текущий хост) на указанных машинах.</target>
        </trans-unit>
        <trans-unit id="7d02127d252ebd3948a9767c4487385c4243c197" translate="yes" xml:space="preserve">
          <source>A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than &lt;code&gt;/etc/passwd&lt;/code&gt;, we wanted to sort the contents of the file &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt;. Let's try it:</source>
          <target state="translated">Распространенная ошибка при запуске внешних программ через оболочку заключается в том, что если имя файла содержит символы, которые являются специальными для оболочки, они могут вызвать нежелательное поведение. Предположим, например, что вместо &lt;code&gt;/etc/passwd&lt;/code&gt; мы хотим отсортировать содержимое файла &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt; . Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="6454f39a38aef4a6a88d7b516cb03974038d7792" translate="yes" xml:space="preserve">
          <source>A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the &lt;a href=&quot;../../base/base/index#const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">Обычно переменные используются для присвоения имен конкретным неизменным значениям. Такие переменные присваиваются только один раз. Это намерение может быть передано компилятору с помощью ключевого слова &lt;a href=&quot;../../base/base/index#const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d3cb20f10d68d34ff29611ac3f50ba68dd4c4b99" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of all documentable Julia syntax.</source>
          <target state="translated">Всеобъемлющий обзор всего документального синтаксиса Джулии.</target>
        </trans-unit>
        <trans-unit id="0d6d37f3dca8ed9b04613226e4330c5ab758e3f1" translate="yes" xml:space="preserve">
          <source>A concrete implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt; (like &lt;code&gt;Channel&lt;/code&gt;), is required to implement &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. The remote object referred to by a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is stored in a &lt;code&gt;Channel{Any}(1)&lt;/code&gt;, i.e., a &lt;code&gt;Channel&lt;/code&gt; of size 1 capable of holding objects of &lt;code&gt;Any&lt;/code&gt; type.</source>
          <target state="translated">Для реализации &lt;code&gt;put!&lt;/code&gt; Требуется конкретная реализация &lt;code&gt;AbstractChannel&lt;/code&gt; (например, &lt;code&gt;Channel&lt;/code&gt; ). , &lt;code&gt;take!&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;isready&lt;/code&gt; и &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . Удаленный объект, на который ссылается &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; , хранится в &lt;code&gt;Channel{Any}(1)&lt;/code&gt; , то есть в &lt;code&gt;Channel&lt;/code&gt; размера 1, способном содержать объекты &lt;code&gt;Any&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="e6d94519717188d6531df826c6d7c056c25b4e04" translate="yes" xml:space="preserve">
          <source>A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for &lt;code&gt;Foo&lt;/code&gt; objects that takes only one argument and uses the given value for both the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; fields. This is simple:</source>
          <target state="translated">Конструктор похож на любую другую функцию в Julia в том смысле, что его общее поведение определяется комбинированным поведением его методов. Соответственно, вы можете добавить функциональность конструктору, просто определив новые методы. Например, предположим, что вы хотите добавить метод конструктора для объектов &lt;code&gt;Foo&lt;/code&gt; , который принимает только один аргумент и использует заданное значение для полей &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; . Это просто:</target>
        </trans-unit>
        <trans-unit id="da756968deae2626766b76b59d785afc3e81b3a6" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="translated">Удобный макрос для записи типов &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt; &lt;code&gt;MIME&lt;/code&gt; &lt;/a&gt; , обычно используемый при добавлении методов для &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; . Например, синтаксис &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; может использоваться для определения того, как писать HTML-представление &lt;code&gt;MyType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70c4d119efcef0d9d58b6c1b731caa5e0cea492c" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce500fee8f2cf895c4ff2e81b81207ab74479894" translate="yes" xml:space="preserve">
          <source>A correct way to define a method that accepts all arguments of type &lt;code&gt;Point{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is:</source>
          <target state="translated">Правильный способ определения метода, который принимает все аргументы типа &lt;code&gt;Point{T}&lt;/code&gt; где &lt;code&gt;T&lt;/code&gt; - подтип &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; , следующий:</target>
        </trans-unit>
        <trans-unit id="3fdea15c071a796482bb0cbad61dbe066b8e91d1" translate="yes" xml:space="preserve">
          <source>A curated list of useful learning resources to help new users get started can be found on the &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;learning&lt;/a&gt; page of the main Julia web site.</source>
          <target state="translated">Кураторский список полезных учебных ресурсов, которые помогут новым пользователям начать работу, можно найти на странице &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;обучения&lt;/a&gt; на главном веб-сайте Julia.</target>
        </trans-unit>
        <trans-unit id="195192cf6a65111d3220eb69daad42095c4bb54b" translate="yes" xml:space="preserve">
          <source>A custom array that reports its &lt;code&gt;IndexStyle&lt;/code&gt; as &lt;code&gt;IndexLinear&lt;/code&gt; only needs to implement indexing (and indexed assignment) with a single &lt;code&gt;Int&lt;/code&gt; index; all other indexing expressions &amp;mdash; including multidimensional accesses &amp;mdash; will be recomputed to the linear index. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;2&amp;times;3&lt;/code&gt; custom matrix with linear indexing, and we referenced &lt;code&gt;A[1, 3]&lt;/code&gt;, this would be recomputed to the equivalent linear index and call &lt;code&gt;A[5]&lt;/code&gt; since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eda7036e705b5b4e6080ae4d063390e3d333bd8" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. For that standard types (&lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;... etc_, if no title text is specified after the admonition type, then the type title used will be the type of the block. E.g. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02f82182ef74a9efe3bec210a9632727895f0a5" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="translated">Пользовательский заголовок для поля может быть указан в виде строки (в двойных кавычках) после типа предупреждения. Если после типа предупреждения не указан текст заголовка, то в качестве заголовка будет использован тип блока, то есть &lt;code&gt;&quot;Note&quot;&lt;/code&gt; в случае &lt;code&gt;note&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ad883b8ebd4cb13361ac5dca2bf64c895374f2" translate="yes" xml:space="preserve">
          <source>A data buffer for exporting data from libgit2. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt;&lt;code&gt;git_buf&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Буфер данных для экспорта данных из libgit2. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt; &lt;code&gt;git_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="043f580a8a8cc9a9005c9d9892ccd32895f20dc0" translate="yes" xml:space="preserve">
          <source>A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</source>
          <target state="translated">Утраченная функция внутренне выполняет поиск,чтобы распечатать соответствующее предупреждение только один раз.Этот дополнительный поиск может привести к значительному замедлению,поэтому все использование устаревших функций должно быть изменено в соответствии с предупреждениями.</target>
        </trans-unit>
        <trans-unit id="30d96d8ddfc84bb803bea097ec17d062d6889473" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8caa8da69c3b3cb75cd1d014abbbf0696fbf4493" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="translated">Путь к каталогу, указывающий, какой проект должен быть начальным активным проектом. Установка этой переменной среды имеет тот же эффект, что и указание &lt;code&gt;--project&lt;/code&gt; запуска --project , но &lt;code&gt;--project&lt;/code&gt; имеет более высокий приоритет. Если переменная установлена ​​на &lt;code&gt;@.&lt;/code&gt; Затем Джулия пытается найти каталог проекта , который содержит &lt;code&gt;Project.toml&lt;/code&gt; или &lt;code&gt;JuliaProject.toml&lt;/code&gt; файл из текущего каталога и его родителей. См. Также главу о &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;загрузке кода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="214eedeee1125bd3c3f68e94a3d499c9e468ec4a" translate="yes" xml:space="preserve">
          <source>A distributed memory, parallel for loop of the form :</source>
          <target state="translated">Распределенная память,параллельная циклу формы :</target>
        </trans-unit>
        <trans-unit id="19754b4c8d91fdeebb8f2031c8dcc27614b27813" translate="yes" xml:space="preserve">
          <source>A document can be split up into different sections using headers. Headers use the following syntax:</source>
          <target state="translated">Документ можно разделить на разные разделы с помощью заголовков.Заголовки используют следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="906831c5f1833fe1c6cead11729270eaa1e64820" translate="yes" xml:space="preserve">
          <source>A fast, unfair-scheduling version of &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; which immediately yields to &lt;code&gt;t&lt;/code&gt; before calling the scheduler.</source>
          <target state="translated">Быстрая, нечестная версия &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; которая немедленно уступает &lt;code&gt;t&lt;/code&gt; перед вызовом планировщика.</target>
        </trans-unit>
        <trans-unit id="5b34dfa04ee74a34a9d1a9cbb45d550b2f88b889" translate="yes" xml:space="preserve">
          <source>A few general rules to note:</source>
          <target state="translated">Следует отметить несколько общих правил:</target>
        </trans-unit>
        <trans-unit id="af07889865f77b7c4b96703878fe873de95ec344" translate="yes" xml:space="preserve">
          <source>A few other points to be aware of:</source>
          <target state="translated">Несколько других моментов,о которых следует знать:</target>
        </trans-unit>
        <trans-unit id="60a8d349acf8be941cbc934da15ee121f8a78126" translate="yes" xml:space="preserve">
          <source>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia's singleton types, but with that caveat that only type objects have singleton types.</source>
          <target state="translated">Несколько популярных языков имеют однокнопочные типы,включая Haskell,Scala и Ruby.В общем употреблении термин &quot;однокнопочный тип&quot; относится к типу,единственным экземпляром которого является одно значение.Это значение применимо к однокнопочным типам Julia,но с этой оговоркой,что только объекты типа имеют однокнопочные типы.</target>
        </trans-unit>
        <trans-unit id="00922cb6654b9fb1b8cc559d5766ed07010c9573" translate="yes" xml:space="preserve">
          <source>A few special expressions correspond to calls to functions with non-obvious names. These are:</source>
          <target state="translated">Несколько специальных выражений соответствуют вызовам функций с неочевидными именами.Это:</target>
        </trans-unit>
        <trans-unit id="df6e90fee529846cc6c25c991e16a7b9cfb908be" translate="yes" xml:space="preserve">
          <source>A file can also be preloaded on multiple processes at startup with the &lt;code&gt;-L&lt;/code&gt; flag, and a driver script can be used to drive the computation:</source>
          <target state="translated">Файл также может быть предварительно загружен в несколько процессов при запуске с помощью флага &lt;code&gt;-L&lt;/code&gt; , а для выполнения вычислений можно использовать сценарий драйвера:</target>
        </trans-unit>
        <trans-unit id="f9a01e3bc84b099bc13fd4194e7a227e1495a2f3" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef6fc12def87705c0724012674763d06330988e" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="translated">Полный список дополнений табуляции можно найти в разделе руководства &amp;laquo; &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Ввод Unicode&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="776e65341479516956a84c86603101c98f11aaf1" translate="yes" xml:space="preserve">
          <source>A full suite of parsing and formatting tests and examples is available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полный набор разбора и форматирования тесты и примеры доступны в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1efd2d920b71c04b3aea5f88fea207dff694c1" translate="yes" xml:space="preserve">
          <source>A function &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; to request the richest available multimedia display of a Julia object &lt;code&gt;x&lt;/code&gt; (with a plain-text fallback).</source>
          <target state="translated">Функция &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; для запроса самого богатого доступного мультимедийного отображения объекта Julia &lt;code&gt;x&lt;/code&gt; (с откатом в виде обычного текста).</target>
        </trans-unit>
        <trans-unit id="96f1b83c87e5168541a9af06566b09eb353921f1" translate="yes" xml:space="preserve">
          <source>A function is called using the traditional parenthesis syntax:</source>
          <target state="translated">Функция вызывается с использованием традиционного синтаксиса скобок:</target>
        </trans-unit>
        <trans-unit id="d5d505a0f9d0a8bc085cb6ea8549229cd44ccf9a" translate="yes" xml:space="preserve">
          <source>A function name may be used alone in place of the tuple (just &lt;code&gt;:function&lt;/code&gt; or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</source>
          <target state="translated">Имя функции может использоваться отдельно вместо кортежа (просто &lt;code&gt;:function&lt;/code&gt; или &lt;code&gt;&quot;function&quot;&lt;/code&gt; ). В этом случае имя разрешается в текущем процессе. Эта форма может использоваться для вызова функций библиотеки C, функций в среде выполнения Julia или функций в приложении, связанном с Julia.</target>
        </trans-unit>
        <trans-unit id="59d50016e8809b20104597755ad0d300cddc21a6" translate="yes" xml:space="preserve">
          <source>A function signature:</source>
          <target state="translated">Функциональная подпись:</target>
        </trans-unit>
        <trans-unit id="fe743a5fafb686fdaff2fd3950e5909b38ec521c" translate="yes" xml:space="preserve">
          <source>A function with a declared return type converts its return value to that type.</source>
          <target state="translated">Функция с объявленным типом возврата преобразует свое возвращаемое значение в этот тип.</target>
        </trans-unit>
        <trans-unit id="fff933fe03507e0a69f0bb2eb791a7b5f8b176b4" translate="yes" xml:space="preserve">
          <source>A functional programming style is fully supported by the language, including closures, but isn't always the idiomatic solution for Julia. Some &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;workarounds&lt;/a&gt; may be necessary for performance when modifying captured variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a045a60155304dcdc010c60b6dbf032ba437c0" translate="yes" xml:space="preserve">
          <source>A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a &lt;code&gt;GitObject&lt;/code&gt; in a repository.</source>
          <target state="translated">Идентификатор объекта git на основе хэша sha-1. Это 20-байтовая строка (40 шестнадцатеричных цифр), используемая для идентификации &lt;code&gt;GitObject&lt;/code&gt; в репозитории.</target>
        </trans-unit>
        <trans-unit id="2b9dac9baaf8e5d26caf82470268456378e7b354" translate="yes" xml:space="preserve">
          <source>A given &lt;code&gt;AbstractChar&lt;/code&gt; subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported &lt;code&gt;UInt32&lt;/code&gt; value may throw an error. Conversely, the built-in &lt;a href=&quot;#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; type represents a &lt;em&gt;superset&lt;/em&gt; of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value &lt;em&gt;to&lt;/em&gt;&lt;code&gt;UInt32&lt;/code&gt; throws an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid&lt;/code&gt;&lt;/a&gt; function can be used to check which codepoints are representable in a given &lt;code&gt;AbstractChar&lt;/code&gt; type.</source>
          <target state="translated">Данный подтип &lt;code&gt;AbstractChar&lt;/code&gt; может представлять только подмножество Unicode, и в этом случае преобразование из неподдерживаемого значения &lt;code&gt;UInt32&lt;/code&gt; может вызвать ошибку. И наоборот, встроенный тип &lt;a href=&quot;#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt; представляет собой &lt;em&gt;надмножество&lt;/em&gt; Unicode (чтобы без потерь кодировать недопустимые потоки байтов), и в этом случае преобразование значения, отличного от Unicode, &lt;em&gt;в &lt;/em&gt; &lt;code&gt;UInt32&lt;/code&gt; вызывает ошибку. &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid&lt;/code&gt; &lt;/a&gt; функция может быть использована , чтобы проверить , какие кодовые представимы в данном &lt;code&gt;AbstractChar&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="04d95958adcacd4e7b4382e807134e41ec53c3fc" translate="yes" xml:space="preserve">
          <source>A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.</source>
          <target state="translated">Глобальная переменная может иметь свое значение и,следовательно,ее тип может измениться в любой момент.Это затрудняет компилятору оптимизацию кода с использованием глобальных переменных.Переменные должны быть локальными или по возможности передаваться в качестве аргументов в функции.</target>
        </trans-unit>
        <trans-unit id="e11090dc004521cb3583f54e041c822a584bd2f5" translate="yes" xml:space="preserve">
          <source>A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn't have to worry about callbacks or even making sure that the server gets to run. When we called &lt;code&gt;connect&lt;/code&gt; the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:</source>
          <target state="translated">Большая сила Джулии заключается в том, что, поскольку API предоставляется синхронно, даже если ввод-вывод на самом деле происходит асинхронно, нам не нужно было беспокоиться об обратных вызовах или даже о том, чтобы сервер запускался. Когда мы вызывали &lt;code&gt;connect&lt;/code&gt; , текущая задача ждала установления соединения и продолжала выполнение только после того, как это было сделано. В этой паузе задача сервера возобновила выполнение (поскольку теперь был доступен запрос на соединение), приняла соединение, распечатала сообщение и ждала следующего клиента. Чтение и письмо работают одинаково. Чтобы убедиться в этом, рассмотрим следующий простой эхо-сервер:</target>
        </trans-unit>
        <trans-unit id="31c1ae4c7c3a38a0afd976393219aa6a44dd785b" translate="yes" xml:space="preserve">
          <source>A hard-coded &lt;a href=&quot;../base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; of common array types that follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays&quot;&gt;strided array interface&lt;/a&gt;, with elements of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9e1db1edf203efc9535001b0c4d60d58c32400" translate="yes" xml:space="preserve">
          <source>A header line can contain any inline syntax in the same way as a paragraph can.</source>
          <target state="translated">Строка заголовка может содержать любой строчный синтаксис так же,как и абзац.</target>
        </trans-unit>
        <trans-unit id="a5bee9cb41ed39aedfa6d81eeafb7305d47a4fcb" translate="yes" xml:space="preserve">
          <source>A key part in defining an &lt;code&gt;AbstractArray&lt;/code&gt; subtype is &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt;. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension. These two modalities are identified by Julia as &lt;code&gt;IndexLinear()&lt;/code&gt; and &lt;code&gt;IndexCartesian()&lt;/code&gt;. Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</source>
          <target state="translated">Ключевым &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt; в определении подтипа &lt;code&gt;AbstractArray&lt;/code&gt; является IndexStyle . Поскольку индексация является такой важной частью массива и часто возникает в циклах быстрого выполнения, важно сделать как индексацию, так и присвоение индекса как можно эффективнее. Структуры данных массива обычно определяются одним из двух способов: либо он наиболее эффективно обращается к своим элементам, используя только один индекс (линейное индексирование), либо он внутренне обращается к элементам с индексами, указанными для каждого измерения. Эти две &lt;code&gt;IndexLinear()&lt;/code&gt; определены Джулией как IndexLinear () и &lt;code&gt;IndexCartesian()&lt;/code&gt; . Преобразование линейного индекса в несколько индексов индексации обычно очень дорого, поэтому это обеспечивает механизм на основе признаков, позволяющий использовать эффективный универсальный код для всех типов массивов.</target>
        </trans-unit>
        <trans-unit id="3a023b19be8aa0bdde697959a3cb353c50c4a7e6" translate="yes" xml:space="preserve">
          <source>A linear index into the array &lt;code&gt;A&lt;/code&gt; can be converted to a &lt;code&gt;CartesianIndex&lt;/code&gt; for cartesian indexing with &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;), and a set of &lt;code&gt;N&lt;/code&gt; cartesian indices can be converted to a linear index with &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Линейный индекс в массиве &lt;code&gt;A&lt;/code&gt; может быть преобразован в &lt;code&gt;CartesianIndex&lt;/code&gt; для декартовой индексации с помощью &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (см. &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; ), а набор из &lt;code&gt;N&lt;/code&gt; декартовых индексов может быть преобразован в линейный индекс с помощью &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (см. &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c3eb1f6f74eb080998f31c2d0aa44b3b54b4558" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer index to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to efficiently access the elements. This means that requesting &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; from an array that is &lt;code&gt;IndexLinear&lt;/code&gt; will return a simple one-dimensional range, even if it is multidimensional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba3600321961b41d61a445772a6a0bbc42feb66" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3)&lt;/code&gt; custom matrix type with linear indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt; (using linear style), this would be equivalent to referencing &lt;code&gt;A[1, 3]&lt;/code&gt; (since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;). See also &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Стиль линейной индексации использует одно целое число для описания позиции в массиве (даже если это многомерный массив), а для доступа к элементам используется порядок столбцов. Например, если бы &lt;code&gt;A&lt;/code&gt; был &lt;code&gt;(2, 3)&lt;/code&gt; пользовательским типом матрицы с линейной индексацией, и мы ссылались бы на &lt;code&gt;A[5]&lt;/code&gt; (используя линейный стиль), это было бы эквивалентно ссылке на &lt;code&gt;A[1, 3]&lt;/code&gt; (поскольку &lt;code&gt;2*1 + 3 = 5&lt;/code&gt; ). См. Также &lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60b78a78e322605d51a66eddac408816c2a8d70e" translate="yes" xml:space="preserve">
          <source>A literal tuple of input types</source>
          <target state="translated">Буквальный кортеж входных типов</target>
        </trans-unit>
        <trans-unit id="abd07e8344438c1637a18b8d088b307bacd1facc" translate="yes" xml:space="preserve">
          <source>A little further down, you see:</source>
          <target state="translated">Немного дальше вниз,видите ли:</target>
        </trans-unit>
        <trans-unit id="b734fc221d82e75922a1b3bf7185abae1cf63084" translate="yes" xml:space="preserve">
          <source>A local cluster specified with the &lt;code&gt;-p&lt;/code&gt; option as shown above.</source>
          <target state="translated">Локальный кластер, указанный с параметром &lt;code&gt;-p&lt;/code&gt; , как показано выше.</target>
        </trans-unit>
        <trans-unit id="b83cf191c90b25b0d5f433557856a4746d3a9017" translate="yes" xml:space="preserve">
          <source>A logger controls how log records are filtered and dispatched. When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.</source>
          <target state="translated">Журналист управляет тем,как журнальные записи фильтруются и отправляются.Когда запись в журнале генерируется,регистратор-это первая часть настраиваемого пользователем кода,который проверяет запись и решает,что с ней делать.</target>
        </trans-unit>
        <trans-unit id="042546047eaee48205b79c0943331492c9d777d2" translate="yes" xml:space="preserve">
          <source>A lot of the power and extensibility in Julia comes from a collection of informal interfaces. By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</source>
          <target state="translated">Большая часть мощности и расширяемости в Джулии происходит из коллекции неформальных интерфейсов.Расширяя несколько специфических методов для работы с пользовательским типом,объекты этого типа не только получают эти функциональные возможности,но и могут быть использованы в других методах,которые написаны,чтобы в общих чертах построить на этом поведении.</target>
        </trans-unit>
        <trans-unit id="cdda590f5cebd6037d45dcdc70b7f61af7141059" translate="yes" xml:space="preserve">
          <source>A low-level API which returns the backing &lt;code&gt;AbstractChannel&lt;/code&gt; for an &lt;code&gt;id&lt;/code&gt; returned by &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt;&lt;code&gt;remoteref_id&lt;/code&gt;&lt;/a&gt;. The call is valid only on the node where the backing channel exists.</source>
          <target state="translated">Низкоуровневый API, который возвращает резервный &lt;code&gt;AbstractChannel&lt;/code&gt; для &lt;code&gt;id&lt;/code&gt; возвращаемого &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt; &lt;code&gt;remoteref_id&lt;/code&gt; &lt;/a&gt; . Вызов действителен только на узле, на котором существует поддерживающий канал.</target>
        </trans-unit>
        <trans-unit id="43d1ae4e08959da49eefb761652820ef46f3ee1d" translate="yes" xml:space="preserve">
          <source>A low-level API which, given a &lt;code&gt;IO&lt;/code&gt; connection or a &lt;code&gt;Worker&lt;/code&gt;, returns the &lt;code&gt;pid&lt;/code&gt; of the worker it is connected to. This is useful when writing custom &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt;&lt;code&gt;serialize&lt;/code&gt;&lt;/a&gt; methods for a type, which optimizes the data written out depending on the receiving process id.</source>
          <target state="translated">Низкоуровневый API , который, учитывая &lt;code&gt;IO&lt;/code&gt; соединение или &lt;code&gt;Worker&lt;/code&gt; , возвращает &lt;code&gt;pid&lt;/code&gt; процесса работника он подключен. Это полезно при написании пользовательских методов &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt; &lt;code&gt;serialize&lt;/code&gt; &lt;/a&gt; для типа, которые оптимизируют записываемые данные в зависимости от идентификатора принимающего процесса.</target>
        </trans-unit>
        <trans-unit id="ba795db29049d0891e980ecd11cc60ac3e97da8e" translate="yes" xml:space="preserve">
          <source>A machine specification is either a string &lt;code&gt;machine_spec&lt;/code&gt; or a tuple - &lt;code&gt;(machine_spec, count)&lt;/code&gt;.</source>
          <target state="translated">Спецификация машины - это либо строка &lt;code&gt;machine_spec&lt;/code&gt; , либо кортеж - &lt;code&gt;(machine_spec, count)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1f8848b8ea19b616dae75f53fa9e5a2b6e59a0" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</source>
          <target state="translated">Макрос для оценки выражения,отбрасывающий результирующее значение,вместо того,чтобы возвращать количество секунд,которое потребовалось для выполнения в качестве числа с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="25d6ce8e35c816ac4036b6028811a1a2075b37da" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3b3a4181a161e900f67d35ae07d34f42540d5c" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the &lt;code&gt;@time&lt;/code&gt; macros, which do not try to adjust for the effects of compilation.</source>
          <target state="translated">Макрос для оценки выражения, отбрасывающий результирующее значение, вместо этого возвращающий общее количество байтов, выделенных во время оценки выражения. Примечание: выражение оценивается внутри локальной функции, а не в текущем контексте, чтобы исключить эффекты компиляции, однако некоторые выделения могут быть из-за JIT-компиляции. Это также делает результаты несовместимыми с макросами &lt;code&gt;@time&lt;/code&gt; , которые не пытаются приспособиться к эффектам компиляции.</target>
        </trans-unit>
        <trans-unit id="d8419a19f9c35dcf69afb6a224b11b1158512f81" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</source>
          <target state="translated">Макрос для выполнения выражения,возвращающий значение выражения,прошедшее время,суммарные выделенные байты,время сбора мусора и объект с различными счетчиками выделения памяти.</target>
        </trans-unit>
        <trans-unit id="ec81ff86af0859e961659a65c9fded1ce9fa3695" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.</source>
          <target state="translated">Макрос для выполнения выражения,распечатывающий время его выполнения,количество выделенных байтов и общее количество вызванных им распределений,прежде чем вернуть значение выражения.</target>
        </trans-unit>
        <trans-unit id="e612ee47dedcebb8c33ec68affacf4a81104cb7f" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a &lt;code&gt;for&lt;/code&gt; loop to run with multiple threads. Splits the iteration space among multiple tasks and runs those tasks on threads according to a scheduling policy. A barrier is placed at the end of the loop which waits for all tasks to finish execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89e0c8d5e0780de8c8e7183eaddeb751b876c48" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a for-loop to run with multiple threads. This spawns &lt;code&gt;nthreads()&lt;/code&gt; number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.</source>
          <target state="translated">Макрос для распараллеливания цикла for для работы с несколькими потоками. Это порождает количество потоков &lt;code&gt;nthreads()&lt;/code&gt; , разделяет пространство итерации между ними и выполняет итерацию параллельно. В конце цикла помещается барьер, который ожидает, пока все потоки завершат выполнение, и цикл возвращается.</target>
        </trans-unit>
        <trans-unit id="4056e98728a50b1503d6d58ab30b4f400279b462" translate="yes" xml:space="preserve">
          <source>A memory address referring to data of type &lt;code&gt;T&lt;/code&gt;. However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</source>
          <target state="translated">Адрес памяти со ссылкой на данные типа &lt;code&gt;T&lt;/code&gt; . Однако нет гарантии, что память действительно действительна или что она действительно представляет данные указанного типа.</target>
        </trans-unit>
        <trans-unit id="95d230cf10af62aec1cf82bb28af648076032cf6" translate="yes" xml:space="preserve">
          <source>A message &lt;code&gt;id&lt;/code&gt; that is a unique, fixed identifier for the &lt;em&gt;source code statement&lt;/em&gt; where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; сообщения, который является уникальным фиксированным идентификатором для &lt;em&gt;оператора исходного кода, в&lt;/em&gt; котором появляется макрос ведения журнала. Этот идентификатор разработан так, чтобы быть достаточно стабильным, даже если исходный код файла изменяется, пока сам оператор регистрации остается прежним.</target>
        </trans-unit>
        <trans-unit id="2750f8d62ad398e67307a20fbfa3a8d50bdd8b0e" translate="yes" xml:space="preserve">
          <source>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</source>
          <target state="translated">Метод с сигнатурой требуемого типа в данной общей функции не существует.Кроме того,не существует уникального наиболее специфического метода.</target>
        </trans-unit>
        <trans-unit id="cb18ac1bbb6e9e8d32b3f5b781aaa128caf3d148" translate="yes" xml:space="preserve">
          <source>A more portable file would need to encode the word size &amp;ndash; 32 bit or 64 bit &amp;ndash; and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).</source>
          <target state="translated">Более переносимый файл должен будет закодировать размер слова - 32-битный или 64-битный - и информацию о порядке байтов в заголовке. На практике рассмотрите возможность кодирования двоичных данных с использованием стандартных форматов, таких как HDF5 (который можно использовать с отображением памяти).</target>
        </trans-unit>
        <trans-unit id="d12bebeb20e9c7a91d427b124d0d24b749dfc69d" translate="yes" xml:space="preserve">
          <source>A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a &lt;code&gt;Union&lt;/code&gt; of the types in question, but then this set would not be extensible as &lt;code&gt;Union&lt;/code&gt;-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;Holy-trait&quot;&lt;/a&gt;.</source>
          <target state="translated">Естественным расширением итеративной отправки выше является добавление слоя к выбору метода, который позволяет выполнять диспетчеризацию наборов типов, которые не зависят от наборов, определенных иерархией типов. Мы могли бы построить такой набор, записав &lt;code&gt;Union&lt;/code&gt; рассматриваемых типов, но тогда этот набор не будет расширяемым, поскольку типы &lt;code&gt;Union&lt;/code&gt; не могут быть изменены после создания. Однако такой расширяемый набор может быть запрограммирован с помощью шаблона проектирования, который часто называют &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&amp;laquo;священной чертой&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1df2e0e7411bff84daf33858b6c998ccc3af6df2" translate="yes" xml:space="preserve">
          <source>A negative value returned from &lt;code&gt;f&lt;/code&gt; stops the tree walk. A positive value means that the entry will be skipped if &lt;code&gt;post&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Отрицательное значение, возвращаемое функцией &lt;code&gt;f&lt;/code&gt; , останавливает обход дерева. Положительное значение означает , что запись будет пропущена , если &lt;code&gt;post&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d79b805fd70e21e9dc784de34e11e7bbeb08de" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table&quot;&gt;table&lt;/a&gt; for a complete list). Some programming languages require explicitly declaring new variables before using them. Explicit declaration works in Julia too: in any local scope, writing &lt;code&gt;local x&lt;/code&gt; declares a new local variable in that scope, regardless of whether there is already a variable named &lt;code&gt;x&lt;/code&gt; in an outer scope or not. Declaring each new local like this is somewhat verbose and tedious, however, so Julia, like many other languages, considers assignment to a new variable in a local scope to implicitly declare that variable as a new local. Mostly this is pretty intuitive, but as with many things that behave intuitively, the details are more subtle than one might na&amp;iuml;vely imagine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eadc295d0ba924158738dd40574dc88fa55d3a0" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table-1&quot;&gt;table&lt;/a&gt; for a complete list). A local scope inherits all the variables from a parent local scope, both for reading and writing. Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.</source>
          <target state="translated">Новая локальная область видимости вводится в большинстве блоков кода ( полный список см. В &lt;a href=&quot;#man-scope-table-1&quot;&gt;таблице&lt;/a&gt; выше ). Локальная область видимости наследует все переменные родительской локальной области как для чтения, так и для записи. В отличие от глобальных областей, локальные области не являются пространствами имен, поэтому переменные во внутренней области не могут быть получены из родительской области с помощью определенного вида доступа.</target>
        </trans-unit>
        <trans-unit id="d714251afe7092bca2f3b7a144d31cf965234924" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; значение типа Float16 .</target>
        </trans-unit>
        <trans-unit id="2193a2ca1ad4d9733b4b0300e7ecba88f3943810" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; значение типа Float32 .</target>
        </trans-unit>
        <trans-unit id="81968f8bb93ba2bc693aa91379d45e0967799536" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; значение типа Float64 .</target>
        </trans-unit>
        <trans-unit id="91d3c0787a3293d9e014f25bc097c52cd39aa358" translate="yes" xml:space="preserve">
          <source>A numeric literal placed directly before an identifier or parentheses, e.g. &lt;code&gt;2x&lt;/code&gt; or &lt;code&gt;2(x+y)&lt;/code&gt;, is treated as a multiplication, except with higher precedence than other binary operations. See &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;Numeric Literal Coefficients&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0553a64a83d6adf63b024a57032beb1f6f23e7" translate="yes" xml:space="preserve">
          <source>A one-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Одномерный &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="763a944bd46fad5722e83f3b2781f484dab35fa0" translate="yes" xml:space="preserve">
          <source>A package can only be loaded once per Julia session. If you have run &lt;code&gt;import Example&lt;/code&gt; in the current Julia session, you will have to restart Julia and rerun &lt;code&gt;activate tutorial&lt;/code&gt; in the Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.</source>
          <target state="translated">Пакет можно загрузить только один раз за сеанс Julia. Если вы запустили &lt;code&gt;import Example&lt;/code&gt; в текущем сеансе Julia, вам придется перезапустить Julia и повторно запустить &lt;code&gt;activate tutorial&lt;/code&gt; по активации в Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; может сделать этот процесс значительно более приятным, но его настройка выходит за рамки этого руководства.</target>
        </trans-unit>
        <trans-unit id="d8ea4ea99a9ccce09db2edcbcf21139124c0c674" translate="yes" xml:space="preserve">
          <source>A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</source>
          <target state="translated">Пакет с проектным файлом,но без явного UUID,может зависеть только от пакетов без проектного файла,так как поддельные UUID,присвоенные этим пакетам,являются строго внутренними.</target>
        </trans-unit>
        <trans-unit id="74b114825488547a02a0f9d88544ac2cd2767c9b" translate="yes" xml:space="preserve">
          <source>A package with a project file cannot depend on one without a project file since packages with project files can only load packages in &lt;code&gt;graph&lt;/code&gt; and packages without project files do not appear in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">Пакет с файлом проекта не может зависеть от пакета без файла проекта, поскольку пакеты с файлами проекта могут загружать пакеты только в &lt;code&gt;graph&lt;/code&gt; а пакеты без файлов проекта не отображаются на &lt;code&gt;graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd75d89f707123dd68c78d210bdb2e047dca58d2" translate="yes" xml:space="preserve">
          <source>A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</source>
          <target state="translated">Пакет без файла проекта может зависеть от любой зависимости верхнего уровня,а поскольку каждый пакет в каталоге пакета доступен на верхнем уровне,он может импортировать все пакеты в окружение.</target>
        </trans-unit>
        <trans-unit id="5392bfe5103ecd0e6030986407ee36c2237b3b31" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56c2cd76cad76c5809c4c87d958f6925a4c437f" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements-1&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="translated">Абзац - это блок простого текста, возможно, содержащий любое количество встроенных элементов, определенных в разделе &amp;laquo; &lt;a href=&quot;#Inline-elements-1&quot;&gt;Встроенные элементы&lt;/a&gt; &amp;raquo; выше, с одной или несколькими пустыми строками над и под ним.</target>
        </trans-unit>
        <trans-unit id="6007e06cc6ef0228d827b11a1334d34e7c3bc855" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f9c9755a3a3b90210c6624d61e0b0a1f59e0fa" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="translated">Особенно полезным случаем типа &lt;code&gt;Union&lt;/code&gt; является &lt;code&gt;Union{T, Nothing}&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; может быть любым типом, а &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; - это одноэлементный тип, единственным экземпляром которого является объект &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; . Этот шаблон является эквивалентом типов &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; , &lt;code&gt;Option&lt;/code&gt; или &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt; в других языках для Julia . Объявление аргумента функции или поля как &lt;code&gt;Union{T, Nothing}&lt;/code&gt; позволяет установить либо значение типа &lt;code&gt;T&lt;/code&gt; , либо &lt;code&gt;nothing&lt;/code&gt; чтобы указать, что значение отсутствует. См. &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;Этот раздел часто задаваемых вопросов&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c0f8b8ac2cfde0d10f30bb94c874c9e1f1def48e" translate="yes" xml:space="preserve">
          <source>A pointer to the data block</source>
          <target state="translated">Указатель на блок данных</target>
        </trans-unit>
        <trans-unit id="6b9ee627484ba20558d37b2c66115f6d170670ea" translate="yes" xml:space="preserve">
          <source>A positive &lt;code&gt;Int&lt;/code&gt; that determines how much time the max-sum subroutine &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default &lt;code&gt;1&lt;/code&gt;, and larger values correspond to larger amounts of time.</source>
          <target state="translated">Положительное значение &lt;code&gt;Int&lt;/code&gt; , определяющее, сколько времени подпрограмма max-sum &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; распознавателя зависимостей пакетов будет посвящать попыткам удовлетворения ограничений, прежде чем отказаться: это значение по умолчанию равно &lt;code&gt;1&lt;/code&gt; , а большие значения соответствуют большему количеству времени.</target>
        </trans-unit>
        <trans-unit id="30e83519d088c9c533da7a48902b81020f8078b5" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided.</source>
          <target state="translated">Может быть предоставлено предварительно вычисленное &lt;code&gt;mean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d945dad8bbc2c247c2aec246f6c166ddc81c4918" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided. When &lt;code&gt;dims&lt;/code&gt; is specified, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cb212a617bce583ce37ac7b92063a39d21aed2" translate="yes" xml:space="preserve">
          <source>A prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is used on an argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</source>
          <target state="translated">Префикс &lt;code&gt;&amp;amp;&lt;/code&gt; используется в аргументе для &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; ,&lt;/a&gt; чтобы указать, что указатель на скалярный аргумент должен быть передан вместо самого скалярного значения (требуется для всех аргументов функции Fortran, как указано выше). В следующем примере вычисляется скалярное произведение с использованием функции BLAS.</target>
        </trans-unit>
        <trans-unit id="1649f26efb9cb12037079805dd99e4da0fb754f9" translate="yes" xml:space="preserve">
          <source>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</source>
          <target state="translated">Примитивный тип-это конкретный тип,данные которого состоят из обычных старых битов.Классическими примерами примитивных типов являются целые числа и значения с плавающей точкой.В отличие от большинства языков,Julia позволяет объявлять свои собственные типы примитивов,вместо того,чтобы предоставлять только фиксированный набор встроенных типов.Фактически,все стандартные типы примитивов определяются в самом языке:</target>
        </trans-unit>
        <trans-unit id="f4a9df194804c22a7662de8018248499081325a7" translate="yes" xml:space="preserve">
          <source>A project environment is determined by a directory containing a project file called &lt;code&gt;Project.toml&lt;/code&gt;, and optionally a manifest file called &lt;code&gt;Manifest.toml&lt;/code&gt;. These files may also be called &lt;code&gt;JuliaProject.toml&lt;/code&gt; and &lt;code&gt;JuliaManifest.toml&lt;/code&gt;, in which case &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are ignored. This allows for coexistence with other tools that might consider files called &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; significant. For pure Julia projects, however, the names &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are preferred.</source>
          <target state="translated">Среда проекта определяется каталогом, содержащим файл проекта с именем &lt;code&gt;Project.toml&lt;/code&gt; и, необязательно, файл &lt;code&gt;Manifest.toml&lt;/code&gt; именем Manifest.toml . Эти файлы также могут называться &lt;code&gt;JuliaProject.toml&lt;/code&gt; и &lt;code&gt;JuliaManifest.toml&lt;/code&gt; , и в этом случае &lt;code&gt;Project.toml&lt;/code&gt; и &lt;code&gt;Manifest.toml&lt;/code&gt; игнорируются. Это позволяет сосуществовать с другими инструментами, которые могут рассматривать файлы &lt;code&gt;Project.toml&lt;/code&gt; и &lt;code&gt;Manifest.toml&lt;/code&gt; как важные. Однако для чистых проектов Julia предпочтительнее использовать имена &lt;code&gt;Project.toml&lt;/code&gt; и &lt;code&gt;Manifest.toml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69645bb907ec77da55ad793cb959dcc26c6879c9" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.</source>
          <target state="translated">Чистая функция может зависеть только от неизменной информации. Это также означает, что функция &lt;code&gt;@pure&lt;/code&gt; не может использовать какое-либо глобальное изменяемое состояние, включая общие функции. Вызов общих функций зависит от таблиц методов, которые являются изменяемым глобальным состоянием. Используйте с осторожностью, неправильная аннотация &lt;code&gt;@pure&lt;/code&gt; функции может затруднить выявление ошибок. Дважды проверьте вызовы общих функций.</target>
        </trans-unit>
        <trans-unit id="a38ae91b9307c68d0e967bb52415d492ca7b2c6c" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions. This macro is intended for internal compiler use and may be subject to changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceda790c7683875242632789b7229b6b3328dc5d" translate="yes" xml:space="preserve">
          <source>A quoted piece of code, that does not support interpolation. See the &lt;a href=&quot;../../manual/metaprogramming/index#man-quote-node&quot;&gt;manual section about QuoteNodes&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f0f859ed475e8984520389a632de12d979f1bf" translate="yes" xml:space="preserve">
          <source>A range &lt;code&gt;r&lt;/code&gt; where &lt;code&gt;r[i]&lt;/code&gt; produces values of type &lt;code&gt;T&lt;/code&gt; (in the second form, &lt;code&gt;T&lt;/code&gt; is deduced automatically), parameterized by a &lt;code&gt;ref&lt;/code&gt;erence value, a &lt;code&gt;step&lt;/code&gt;, and the &lt;code&gt;len&lt;/code&gt;gth. By default &lt;code&gt;ref&lt;/code&gt; is the starting value &lt;code&gt;r[1]&lt;/code&gt;, but alternatively you can supply it as the value of &lt;code&gt;r[offset]&lt;/code&gt; for some other index &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt;. In conjunction with &lt;code&gt;TwicePrecision&lt;/code&gt; this can be used to implement ranges that are free of roundoff error.</source>
          <target state="translated">Диапазон &lt;code&gt;r&lt;/code&gt; , где &lt;code&gt;r[i]&lt;/code&gt; производит значения типа &lt;code&gt;T&lt;/code&gt; (во второй форме, &lt;code&gt;T&lt;/code&gt; выводится автоматически), параметризирован &lt;code&gt;ref&lt;/code&gt; значение разностной, на &lt;code&gt;step&lt;/code&gt; , и &lt;code&gt;len&lt;/code&gt; GTH. По умолчанию &lt;code&gt;ref&lt;/code&gt; является начальным значением &lt;code&gt;r[1]&lt;/code&gt; , но в качестве альтернативы вы можете указать его как значение &lt;code&gt;r[offset]&lt;/code&gt; для некоторого другого индекса &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt; . В сочетании с &lt;code&gt;TwicePrecision&lt;/code&gt; это можно использовать для реализации диапазонов без ошибок округления.</target>
        </trans-unit>
        <trans-unit id="c9b444cdaa1ec0c32645903217d293c523a2b655" translate="yes" xml:space="preserve">
          <source>A range parameterized by a &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;, filled with elements spaced by &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;start&lt;/code&gt; until &lt;code&gt;stop&lt;/code&gt; is exceeded. The syntax &lt;code&gt;a:b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; both &lt;code&gt;Integer&lt;/code&gt;s creates a &lt;code&gt;UnitRange&lt;/code&gt;.</source>
          <target state="translated">Диапазон, параметризованный &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; , заполненный элементами, расположенными с интервалом &lt;code&gt;1&lt;/code&gt; от &lt;code&gt;start&lt;/code&gt; до превышения &lt;code&gt;stop&lt;/code&gt; . Синтаксис &lt;code&gt;a:b&lt;/code&gt; с &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; как &lt;code&gt;Integer&lt;/code&gt; s создает &lt;code&gt;UnitRange&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f1f96e933c37623ad62bee872115dc2545ea76" translate="yes" xml:space="preserve">
          <source>A range with &lt;code&gt;len&lt;/code&gt; linearly spaced elements between its &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The size of the spacing is controlled by &lt;code&gt;len&lt;/code&gt;, which must be an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Диапазон с &lt;code&gt;len&lt;/code&gt; линейно разнесенными элементами между его &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; . Размер интервала контролируется параметром &lt;code&gt;len&lt;/code&gt; , который должен быть &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="706e2d69e0228bb191f57826b2fe6dee1a0d2fd7" translate="yes" xml:space="preserve">
          <source>A related strategy exploits &lt;code&gt;promote&lt;/code&gt; to bring &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to a common type:</source>
          <target state="translated">Эксплойты связанной стратегии &lt;code&gt;promote&lt;/code&gt; приведению &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; к общему типу:</target>
        </trans-unit>
        <trans-unit id="d7c0e6452fd18c0732cb625754236d5f55a408f6" translate="yes" xml:space="preserve">
          <source>A related third strategy is to use a yield-free queue. We don't currently have a lock-free queue implemented in Base, but &lt;code&gt;Base.InvasiveLinkedListSynchronized{T}&lt;/code&gt; is suitable. This can frequently be a good strategy to use for code with event loops. For example, this strategy is employed by &lt;code&gt;Gtk.jl&lt;/code&gt; to manage lifetime ref-counting. In this approach, we don't do any explicit work inside the &lt;code&gt;finalizer&lt;/code&gt;, and instead add it to a queue to run at a safer time. In fact, Julia's task scheduler already uses this, so defining the finalizer as &lt;code&gt;x -&amp;gt; @spawn do_cleanup(x)&lt;/code&gt; is one example of this approach. Note however that this doesn't control which thread &lt;code&gt;do_cleanup&lt;/code&gt; runs on, so &lt;code&gt;do_cleanup&lt;/code&gt; would still need to acquire a lock. That doesn't need to be true if you implement your own queue, as you can explicitly only drain that queue from your thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aacdb7c22de01fd91d580f3ce3c32f6aebf1795" translate="yes" xml:space="preserve">
          <source>A remote call returns a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, and you can obtain the full value of the result using &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">Удаленный вызов возвращает результат &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; . Удаленные звонки возвращаются немедленно; процесс, выполнивший вызов, переходит к своей следующей операции, в то время как удаленный вызов происходит в другом месте. Вы можете дождаться завершения удаленного вызова, вызвав &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; для возвращенного &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; , и вы можете получить полное значение результата с помощью &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c718be7a47524e3c8c121a2838b8196bfca32d81" translate="yes" xml:space="preserve">
          <source>A return type can also be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="translated">Тип возврата также можно указать в объявлении функции с помощью оператора &lt;code&gt;::&lt;/code&gt; . Это преобразует возвращаемое значение в указанный тип.</target>
        </trans-unit>
        <trans-unit id="f794450cdef21a1d306e7fb59ec235acfc19011a" translate="yes" xml:space="preserve">
          <source>A return type can be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487eaf5a6ef062e68fb2638581518230a5bbf1cb" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return i.e. C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;Union{}&lt;/code&gt; означает, что функция не вернет, например, C ++ 11 &lt;code&gt;[[noreturn]]&lt;/code&gt; или C11 &lt;code&gt;_Noreturn&lt;/code&gt; (например, &lt;code&gt;jl_throw&lt;/code&gt; или &lt;code&gt;longjmp&lt;/code&gt; ). Не используйте это для функций, которые не возвращают значения ( &lt;code&gt;void&lt;/code&gt; ), но возвращают, вместо этого используйте &lt;code&gt;Cvoid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0df8658c1a2663d5b4b16580728c11544340a3ac" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return, i.e., C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d36c3c7861e0bdac1682c4b5f59e170ca861f5e" translate="yes" xml:space="preserve">
          <source>A rich language of types for constructing and describing objects, that can also optionally be used to make type declarations</source>
          <target state="translated">Богатый язык типов для построения и описания объектов,который также может быть опционально использован для объявления типов</target>
        </trans-unit>
        <trans-unit id="3b35eab36ca2f92e10ca8fc1b981602576d246ef" translate="yes" xml:space="preserve">
          <source>A sampler for types, containing no other information. The default fallback for &lt;code&gt;Sampler&lt;/code&gt; when called with types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72264caef899e2b19ef0b87abaee4b3d2fbc99bb" translate="yes" xml:space="preserve">
          <source>A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.</source>
          <target state="translated">Профилировщик выборки не обеспечивает полного линейного покрытия,так как обратные трассы происходят с интервалами (по умолчанию 1 мс на Unix-системах и 10 мс на Windows,хотя фактическое планирование зависит от загрузки операционной системы).Более того,как будет рассмотрено ниже,поскольку выборки собираются в разреженном подмножестве всех точек выполнения,данные,собранные профилировщиком выборки,подвержены статистическому шуму.</target>
        </trans-unit>
        <trans-unit id="1c43fdae247597897ddce375dd4bc720d67a5129" translate="yes" xml:space="preserve">
          <source>A scalar index. By default this includes:</source>
          <target state="translated">Скалярный индекс.По умолчанию он включает в себя:</target>
        </trans-unit>
        <trans-unit id="2e149e1fe6cf738b9500f7f73419a47eddcaa861" translate="yes" xml:space="preserve">
          <source>A second strategy, employed by Base in a couple places, is to explicitly delay a finalizer until it may be able to acquire its lock non-recursively. The following example demonstrates how this strategy could be applied to &lt;code&gt;Distributed.finalize_ref&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55191124d22706cdd504c425bc25474c70cfe4b" translate="yes" xml:space="preserve">
          <source>A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial &lt;code&gt;len&lt;/code&gt; hexadecimal digits of &lt;code&gt;hash&lt;/code&gt; (the remaining digits are ignored).</source>
          <target state="translated">Сокращенный идентификатор объекта git, который может использоваться для идентификации объекта git, если он уникален, состоящий из начальных &lt;code&gt;len&lt;/code&gt; шестнадцатеричных цифр &lt;code&gt;hash&lt;/code&gt; (остальные цифры игнорируются).</target>
        </trans-unit>
        <trans-unit id="077f5f2c61a2286cb303f8e0203873661f4fb602" translate="yes" xml:space="preserve">
          <source>A simple TCP example</source>
          <target state="translated">Простой пример TCP</target>
        </trans-unit>
        <trans-unit id="a9e3389d4f0df30d0d029c511221cff89bde7e83" translate="yes" xml:space="preserve">
          <source>A simple example is an iterable sequence of square numbers with a defined length:</source>
          <target state="translated">Простой пример-это итерабельная последовательность квадратных чисел с заданной длиной:</target>
        </trans-unit>
        <trans-unit id="74210b965c13b3f0a92488bc76d8ed6610e194df" translate="yes" xml:space="preserve">
          <source>A simple sampler without pre-computed data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f74541df487be036520d1a453fae53d9f7cabea" translate="yes" xml:space="preserve">
          <source>A simple use of this script is from the command line. Assuming that &lt;code&gt;julia-config.jl&lt;/code&gt; is located in &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt;, it can be invoked on the command line directly and takes any combination of 3 flags:</source>
          <target state="translated">Простое использование этого сценария - из командной строки. Предполагая, что &lt;code&gt;julia-config.jl&lt;/code&gt; находится в &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt; , он может быть вызван напрямую из командной строки и принимает любую комбинацию из 3 флагов:</target>
        </trans-unit>
        <trans-unit id="fa70eb6573e06a90b5cea95755e1d5d87242bd36" translate="yes" xml:space="preserve">
          <source>A singleton of this type provides a hash table interface to environment variables.</source>
          <target state="translated">Одиночная кнопка этого типа предоставляет интерфейс хэш-таблицы к переменным окружения.</target>
        </trans-unit>
        <trans-unit id="742dc31813ae03b1c856e52c5abe6409c9fab8c0" translate="yes" xml:space="preserve">
          <source>A special syntax exists for broadcasting: &lt;code&gt;f.(args...)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, and nested &lt;code&gt;f.(g.(args...))&lt;/code&gt; calls are fused into a single broadcast loop.</source>
          <target state="translated">Для широковещательной передачи существует специальный синтаксис: &lt;code&gt;f.(args...)&lt;/code&gt; эквивалентен &lt;code&gt;broadcast(f, args...)&lt;/code&gt; , а вложенные вызовы &lt;code&gt;f.(g.(args...))&lt;/code&gt; объединяются в один цикл широковещательной передачи. ,</target>
        </trans-unit>
        <trans-unit id="c0fbd3b8f6db43e593e0be31ea0f379f85f1e4ca" translate="yes" xml:space="preserve">
          <source>A stack of &quot;depot&quot; locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:</source>
          <target state="translated">Стек &quot;депо&quot;,где менеджер пакетов,а также механизмы загрузки кода Julia,ищет реестры пакетов,установленные пакеты,именованные окружения,репо-клоны,кэшированные скомпилированные образы пакетов и конфигурационные файлы.По умолчанию он включает в себя:</target>
        </trans-unit>
        <trans-unit id="83cbeda4e6c8af61ba213e9c4a7b5e87e7da5098" translate="yes" xml:space="preserve">
          <source>A strided array is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt; whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps a standard &lt;code&gt;Array&lt;/code&gt; with additional structure.</source>
          <target state="translated">Построенный массив - это подтип &lt;code&gt;AbstractArray&lt;/code&gt; , записи которого сохраняются в памяти с фиксированным шагом. При условии, что тип элемента массива совместим с BLAS, разделенный массив может использовать процедуры BLAS и LAPACK для более эффективных процедур линейной алгебры. Типичным примером определяемого пользователем последовательного массива является массив, который обертывает стандартный &lt;code&gt;Array&lt;/code&gt; дополнительной структурой.</target>
        </trans-unit>
        <trans-unit id="1b1c35701525a8cf6b4348121d4ed856a675b22b" translate="yes" xml:space="preserve">
          <source>A string containing the build triple.</source>
          <target state="translated">Строка,содержащая тройку сборки.</target>
        </trans-unit>
        <trans-unit id="8f5d09501ae972f4c8432e623c2b5b34015798e0" translate="yes" xml:space="preserve">
          <source>A string containing the full path to the directory containing the &lt;code&gt;julia&lt;/code&gt; executable.</source>
          <target state="translated">Строка, содержащая полный путь к каталогу, содержащему исполняемый файл &lt;code&gt;julia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd4ca3ee2c70681a147013214927fa8b03d2dc0" translate="yes" xml:space="preserve">
          <source>A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Строка, содержащая имя сценария, переданная Джулии из командной строки. Обратите внимание, что имя сценария остается неизменным из включенных файлов. В качестве альтернативы см. &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0797e0a3c7343edc1c5ee87f67440aa1e7a16452" translate="yes" xml:space="preserve">
          <source>A string giving the literal bit representation of a number.</source>
          <target state="translated">Строка,дающая буквальное битовое представление числа.</target>
        </trans-unit>
        <trans-unit id="99fade2fd2012046282e2903a7ae0c96b265f5e9" translate="yes" xml:space="preserve">
          <source>A struct can also declare an abstract super type via &lt;code&gt;&amp;lt;:&lt;/code&gt; syntax:</source>
          <target state="translated">Структура также может объявлять абстрактный супертип с помощью синтаксиса &lt;code&gt;&amp;lt;:&lt;/code&gt; ::</target>
        </trans-unit>
        <trans-unit id="d8c381a5b7c7400aeadc10868e02841473506c28" translate="yes" xml:space="preserve">
          <source>A successful invocation indicates that the request has been accepted for execution on the remote node.</source>
          <target state="translated">Успешный вызов означает,что запрос был принят к исполнению на удаленном узле.</target>
        </trans-unit>
        <trans-unit id="62cc4725cdcde932b6f43e77c33829a7243aa044" translate="yes" xml:space="preserve">
          <source>A symbol in the current scope is not defined.</source>
          <target state="translated">Символ в текущем диапазоне не определен.</target>
        </trans-unit>
        <trans-unit id="c20565dfe8ced2501d963ee2eb2804c69c838706" translate="yes" xml:space="preserve">
          <source>A symbol representing the architecture of the build configuration.</source>
          <target state="translated">Символ,представляющий архитектуру конфигурации сборки.</target>
        </trans-unit>
        <trans-unit id="1630c742579320a925646310ce24a54343db4200" translate="yes" xml:space="preserve">
          <source>A symbol representing the name of the operating system, as returned by &lt;code&gt;uname&lt;/code&gt; of the build configuration.</source>
          <target state="translated">Символ, представляющий имя операционной системы, возвращенное &lt;code&gt;uname&lt;/code&gt; конфигурации сборки.</target>
        </trans-unit>
        <trans-unit id="55d0851ad9930d2d2a1ce1a82a1321a9316a97a9" translate="yes" xml:space="preserve">
          <source>A symbol representing the operator associativity can also be found by calling the built-in function &lt;code&gt;Base.operator_associativity&lt;/code&gt;:</source>
          <target state="translated">Символ, представляющий ассоциативность оператора, также можно найти, вызвав встроенную функцию &lt;code&gt;Base.operator_associativity&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="31ca630f0d77e0cda110e0b86407ebc755d3a20f" translate="yes" xml:space="preserve">
          <source>A system call failed with an error code (in the &lt;code&gt;errno&lt;/code&gt; global variable).</source>
          <target state="translated">Системный вызов завершился неудачно с кодом ошибки (в глобальной переменной &lt;code&gt;errno&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7383f155bc43b22861eb93ff761378a3dfd82ac" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9449233a2f73e499e6bb945337a8062b4696d604" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;, or using the &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; macro (see &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt; for more details).</source>
          <target state="translated">Задача, созданная явно путем вызова &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; , изначально не известна планировщику. Это позволяет вам управлять задачами вручную, используя &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; ,&lt;/a&gt; если хотите. Однако, когда такая задача ожидает события, она по-прежнему автоматически перезапускается, когда событие происходит, как и следовало ожидать. Также можно заставить планировщик запускать задачу всякий раз, когда это возможно, не дожидаясь каких-либо событий. Это делается путем вызова &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; или использования макроса &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt; (подробнее см. В разделе &amp;laquo; &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Параллельные вычисления&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="98741cc98ee16d9ab3a998adf5789df91d6bd8b6" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Condition&quot;&gt; &lt;code&gt;Base.Condition&lt;/code&gt; &lt;/a&gt; версия Base.Condition .</target>
        </trans-unit>
        <trans-unit id="edef5e7571427a5f91f025df54f077af0dd3024e" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;../parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b58805de54debccfbd0e801ac822dbec053b647" translate="yes" xml:space="preserve">
          <source>A tuple of input types, corresponding to the function signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742c13a103d2480e968af031241292dc13ffa910" translate="yes" xml:space="preserve">
          <source>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</source>
          <target state="translated">Кортеж входного типа.Типы входных данных должны быть записаны как буквальный кортеж,а не как переменная или выражение,имеющее значение кортежа.</target>
        </trans-unit>
        <trans-unit id="02ac3688690ac8c45320416c8e40058c167fb818" translate="yes" xml:space="preserve">
          <source>A two-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Двумерный &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cae43ab9952736150051924872c889307cc7b33" translate="yes" xml:space="preserve">
          <source>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</source>
          <target state="translated">Ошибка утверждения типа или вызов intrinsic-функции с неверным типом аргумента.</target>
        </trans-unit>
        <trans-unit id="6c65420499bd2ab6c38a5269a2949906fd25fe5c" translate="yes" xml:space="preserve">
          <source>A type representing a standard internet data format. &quot;MIME&quot; stands for &quot;Multipurpose Internet Mail Extensions&quot;, since the standard was originally used to describe multimedia attachments to email messages.</source>
          <target state="translated">Тип,представляющий стандартный формат данных в Интернете.&quot;MIME&quot; означает &quot;Multipurpose Internet Mail Extensions&quot;,так как стандарт изначально использовался для описания мультимедийных вложений в сообщения электронной почты.</target>
        </trans-unit>
        <trans-unit id="fa12877ef329dc75c9fda25bdec3c035fe723779" translate="yes" xml:space="preserve">
          <source>A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a &lt;code&gt;head&lt;/code&gt;&lt;code&gt;Symbol&lt;/code&gt; identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a &lt;code&gt;Vector{Any}&lt;/code&gt; field called &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Тип, представляющий составные выражения в разобранном коде julia (AST). Каждое выражение состоит из &lt;code&gt;head&lt;/code&gt; &lt;code&gt;Symbol&lt;/code&gt; идентифицирующей , какой вид выражения оно (например, для вызова цикла, условного оператора и т.д.), а также подвыражения (например , аргументы вызова). Подвыражения хранятся в поле &lt;code&gt;Vector{Any}&lt;/code&gt; называется &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12166025929849592cdb9b904ad437a429f4da9f" translate="yes" xml:space="preserve">
          <source>A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">Объединение типов - это специальный абстрактный тип, который включает в качестве объектов все экземпляры любого из своих типов аргументов, построенных с использованием специального ключевого слова &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c659722eaa7a1851dcf2b15fa8b1da6d2c52b7b1" translate="yes" xml:space="preserve">
          <source>A type union is an abstract type which includes all instances of any of its argument types. The empty union &lt;a href=&quot;#Union%7B%7D&quot;&gt;&lt;code&gt;Union{}&lt;/code&gt;&lt;/a&gt; is the bottom type of Julia.</source>
          <target state="translated">Объединение типов - это абстрактный тип, который включает в себя все экземпляры любого из своих типов аргументов. Пустое объединение &lt;a href=&quot;#Union%7B%7D&quot;&gt; &lt;code&gt;Union{}&lt;/code&gt; &lt;/a&gt; - это нижний тип Julia.</target>
        </trans-unit>
        <trans-unit id="d4feddb63143773f90aec3aa6e9e79164c040b57" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;a href=&quot;#Base.round-Tuple%7BType,Any%7D&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt; function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a19252283d099431e9543c48dcfeb2c0c70cdb" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;code&gt;round&lt;/code&gt; function).</source>
          <target state="translated">Тип, используемый для управления режимом округления операций с плавающей запятой (через функции &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;setrounding&lt;/code&gt; округления ) или в качестве дополнительных аргументов для округления до ближайшего целого числа (через функцию &lt;code&gt;round&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cce4e44b3212d47f6685805f453e4928d3ab1723" translate="yes" xml:space="preserve">
          <source>A type with no fields that is the type of &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип без полей, который является типом &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8120bb7a13d8189f767168488ba78dd50f96b4" translate="yes" xml:space="preserve">
          <source>A type with no fields whose singleton instance &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; is used to represent missing values.</source>
          <target state="translated">Тип без полей, у которого &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; одноэлементный экземпляр, используется для представления отсутствующих значений.</target>
        </trans-unit>
        <trans-unit id="306e436a1878b67ebef890bd34b67f5c57414a92" translate="yes" xml:space="preserve">
          <source>A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple &quot;destructuring&quot; that facilitates this:</source>
          <target state="translated">Типичное использование такой пары возвращаемых значений,однако,извлекает каждое значение в переменную.Джулия поддерживает простую &quot;деструкцию&quot; кортежа,которая облегчает это:</target>
        </trans-unit>
        <trans-unit id="913d40733121bbdbb40702c29375806cce6f85d2" translate="yes" xml:space="preserve">
          <source>A union of types over all values of a type parameter. &lt;code&gt;UnionAll&lt;/code&gt; is used to describe parametric types where the values of some parameters are not known.</source>
          <target state="translated">Объединение типов по всем значениям параметра типа. &lt;code&gt;UnionAll&lt;/code&gt; используется для описания параметрических типов, где значения некоторых параметров неизвестны.</target>
        </trans-unit>
        <trans-unit id="a657ba8f21c293af12b12dfaacd8ec7d70ec5e5a" translate="yes" xml:space="preserve">
          <source>A useful tool for measuring performance is the &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; macro. We here repeat the example with the global variable above, but this time with the type annotation removed:</source>
          <target state="translated">Полезным инструментом для измерения производительности является макрос &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; . Здесь мы повторяем пример с глобальной переменной выше, но на этот раз без аннотации типа:</target>
        </trans-unit>
        <trans-unit id="c5253993e5fc44814c87723bb62dfda7d99d25d2" translate="yes" xml:space="preserve">
          <source>A variable name can be &quot;reserved&quot; without assigning to it by declaring it as &lt;code&gt;global x&lt;/code&gt;. This prevents name conflicts for globals initialized after load time.</source>
          <target state="translated">Имя переменной можно &amp;laquo;зарезервировать&amp;raquo; без присвоения ему, объявив его &lt;code&gt;global x&lt;/code&gt; . Это предотвращает конфликты имен для глобальных объектов, инициализированных после загрузки.</target>
        </trans-unit>
        <trans-unit id="7fd534d23374f6545f94032e172165c5e2ffe3bb" translate="yes" xml:space="preserve">
          <source>A variable referring to the last computed value, automatically set at the interactive prompt.</source>
          <target state="translated">Переменная,относящаяся к последнему вычисленному значению,автоматически устанавливается в интерактивной подсказке.</target>
        </trans-unit>
        <trans-unit id="9301af4052e23061aeab00f8629595c8531efad3" translate="yes" xml:space="preserve">
          <source>A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that you obtained after some math, for example) for later use. For example:</source>
          <target state="translated">Переменная,в Юлии,это имя,связанное (или привязанное)со значением.Она полезна,когда вы хотите сохранить значение (которое вы получили после некоторых математических вычислений,например)для последующего использования.Например:</target>
        </trans-unit>
        <trans-unit id="343ec2d984e66e00b3ae00539feb443a8166ee65" translate="yes" xml:space="preserve">
          <source>A variation on this approach, which avoids the appearance of type instability is to merge the &lt;code&gt;Int&lt;/code&gt; and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach &lt;em&gt;can&lt;/em&gt; be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots &amp;ndash; large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps &amp;ndash; situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; этого подхода, который позволяет избежать появления нестабильности типа, является объединение типов &lt;code&gt;Int&lt;/code&gt; и BigInt в один гибридный целочисленный тип, который внутренне изменяет представление, когда результат больше не соответствует размеру машинного целого числа. Хотя это внешне позволяет избежать нестабильности типов на уровне кода Джулии, он просто скрывает проблему, навязывая все те же трудности коду C, реализующему этот гибридный целочисленный тип. Такой подход &lt;em&gt;может&lt;/em&gt;заставить работать и даже во многих случаях может быть сделано довольно быстро, но имеет несколько недостатков. Одна из проблем заключается в том, что представление целых чисел и массивов целых чисел в памяти больше не соответствует естественному представлению, используемому в C, Fortran и других языках с машинными целыми числами. Таким образом, для взаимодействия с этими языками нам в любом случае потребуется ввести собственные целочисленные типы. Любое неограниченное представление целых чисел не может иметь фиксированное количество битов и, следовательно, не может храниться в массиве со слотами фиксированного размера - большие целочисленные значения всегда требуют отдельного хранилища, выделенного кучей. И, конечно же, независимо от того, насколько умна вы используете гибридную целочисленную реализацию, всегда есть ловушки производительности - ситуации, когда производительность неожиданно падает. Сложное представление, отсутствие взаимодействия с C и Fortran,Невозможность представления целочисленных массивов без дополнительного хранилища в куче и непредсказуемые характеристики производительности делают даже самые умные гибридные целочисленные реализации плохим выбором для высокопроизводительной численной работы.</target>
        </trans-unit>
        <trans-unit id="e58331c965191dacd80a8789c7e948a53ee2b04e" translate="yes" xml:space="preserve">
          <source>A very special macro is &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt;&lt;code&gt;@generated&lt;/code&gt;&lt;/a&gt;, which allows you to define so-called &lt;em&gt;generated functions&lt;/em&gt;. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.</source>
          <target state="translated">Совершенно особый макрос - &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt; &lt;code&gt;@generated&lt;/code&gt; &lt;/a&gt; , который позволяет вам определять так называемые &lt;em&gt;сгенерированные функции&lt;/em&gt; . Они имеют возможность генерировать специализированный код в зависимости от типов своих аргументов с большей гибкостью и / или меньшим количеством кода, чем то, что может быть достигнуто с помощью множественной отправки. Хотя макросы работают с выражениями во время синтаксического анализа и не могут получить доступ к типам своих входных данных, сгенерированная функция расширяется в то время, когда типы аргументов известны, но функция еще не скомпилирована.</target>
        </trans-unit>
        <trans-unit id="141d8c5657b1c8b0553ace4a61596a7c1734a9a6" translate="yes" xml:space="preserve">
          <source>A wrapper type used in &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; to distinguish between the absence of a value (&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;) and the presence of a &lt;code&gt;nothing&lt;/code&gt; value (i.e. &lt;code&gt;Some(nothing)&lt;/code&gt;).</source>
          <target state="translated">Тип оболочки, используемый в &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; чтобы различать отсутствие значения ( &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; ) и наличие значения &amp;laquo; &lt;code&gt;nothing&lt;/code&gt; (то есть &lt;code&gt;Some(nothing)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="80d305c58f97edfae92a3627f5a66d9bef4d8d46" translate="yes" xml:space="preserve">
          <source>AM</source>
          <target state="translated">AM</target>
        </trans-unit>
        <trans-unit id="89c25a6e98b7d12432623429744aea6cf501424a" translate="yes" xml:space="preserve">
          <source>API reference</source>
          <target state="translated">ссылка API</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="a1df128dfacd3f460cbb61bb4087bb92287d3fcb" translate="yes" xml:space="preserve">
          <source>ARI</source>
          <target state="translated">ARI</target>
        </trans-unit>
        <trans-unit id="cade2543bf82eecb0447ba12066fcc5daa136208" translate="yes" xml:space="preserve">
          <source>ASCII characters and ASCII escapes produce a single byte.</source>
          <target state="translated">ASCII-символы и ASCII-беги дают один байт.</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="33a783add30fb01fc6df3bfeb87611c9fd6e0247" translate="yes" xml:space="preserve">
          <source>Abbr.</source>
          <target state="translated">Abbr.</target>
        </trans-unit>
        <trans-unit id="125c32f24e67f8006c45d7fdea568e01f28fd48b" translate="yes" xml:space="preserve">
          <source>Abbreviated days of the week</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d634b593f2d04c176e6178cce99b9871b914261f" translate="yes" xml:space="preserve">
          <source>Above, it was pointed out that one can resolve ambiguities like</source>
          <target state="translated">Выше было отмечено,что можно разрешить такие двусмысленности,как</target>
        </trans-unit>
        <trans-unit id="444368fcd88ae8ee9706df79374d2260c8851efb" translate="yes" xml:space="preserve">
          <source>Abstract Arrays</source>
          <target state="translated">абстрактные массивы</target>
        </trans-unit>
        <trans-unit id="afab87d7da169104e68739efdca076e3028a0b71" translate="yes" xml:space="preserve">
          <source>Abstract Types</source>
          <target state="translated">Абстрактные типы</target>
        </trans-unit>
        <trans-unit id="3731303601cb9a5262dd9843918c4065a4b09ed2" translate="yes" xml:space="preserve">
          <source>Abstract containers and element types</source>
          <target state="translated">Абстрактные контейнеры и типы элементов</target>
        </trans-unit>
        <trans-unit id="b81afa6e965e7c1908221b1c01f57fb3e1ed309d" translate="yes" xml:space="preserve">
          <source>Abstract number types</source>
          <target state="translated">Абстрактные числовые типы</target>
        </trans-unit>
        <trans-unit id="203bf0ca60eba0b4df86ca193ff6564bf1f08046" translate="yes" xml:space="preserve">
          <source>Abstract supertype describing types that implement the synchronization primitives: &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Base.islocked&quot;&gt;&lt;code&gt;islocked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Абстрактный супертип, описывающий типы, реализующие примитивы синхронизации: &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Base.islocked&quot;&gt; &lt;code&gt;islocked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="161cfe5f22c6ec0c5c1636e00ae6b86b4dfab7b0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for IP addresses. &lt;a href=&quot;#Sockets.IPv4&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Sockets.IPv6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; are subtypes of this.</source>
          <target state="translated">Абстрактный супертип для IP-адресов. &lt;a href=&quot;#Sockets.IPv4&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Sockets.IPv6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; являются подтипами этого.</target>
        </trans-unit>
        <trans-unit id="7ec52c1e034eaa75fbf55c8ad047e12dee7c43d5" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all floating point numbers.</source>
          <target state="translated">Абстрактный супертип для всех чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d3c5cb7bbcaf4de0abc6af421aee06fd1805c5f7" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all integers.</source>
          <target state="translated">Абстрактный супертип для всех целых чисел.</target>
        </trans-unit>
        <trans-unit id="c2307397eab7e7e325b924259a7acd689ce9202f" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all number types.</source>
          <target state="translated">Абстрактный супертип для всех типов чисел.</target>
        </trans-unit>
        <trans-unit id="8137ecd293ea0b9f148b79a2c5d9ef23135b11e0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all real numbers.</source>
          <target state="translated">Абстрактный супертип для всех реальных чисел.</target>
        </trans-unit>
        <trans-unit id="5d4c24eb8dfef4792ccde0796267cae116c984c2" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all signed integers.</source>
          <target state="translated">Абстрактный супертип для всех значащих целых чисел.</target>
        </trans-unit>
        <trans-unit id="98c1a75aa7f0d6a8990b451bf94db6a410025a03" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all unsigned integers.</source>
          <target state="translated">Абстрактный супертип для всех беззнаковых целых чисел.</target>
        </trans-unit>
        <trans-unit id="93e4098f9689d748060c11ebe52324df10ec1351" translate="yes" xml:space="preserve">
          <source>Abstract supertype for rich display output devices. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt;&lt;code&gt;TextDisplay&lt;/code&gt;&lt;/a&gt; is a subtype of this.</source>
          <target state="translated">Абстрактный супертип для устройств вывода на дисплей. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt; &lt;code&gt;TextDisplay&lt;/code&gt; &lt;/a&gt; - это подтип этого.</target>
        </trans-unit>
        <trans-unit id="5e9597d58105eaf8a30d20d99c956a69b4d700ba" translate="yes" xml:space="preserve">
          <source>Abstract type for &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix factorizations&lt;/a&gt; a.k.a. matrix decompositions. See &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;online documentation&lt;/a&gt; for a list of available matrix factorizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76cd9a3f07be7d40989b1baf043119bf5df6066e" translate="yes" xml:space="preserve">
          <source>Abstract type of all functions.</source>
          <target state="translated">Абстрактный тип всех функций.</target>
        </trans-unit>
        <trans-unit id="84e429cc9f28682f2f27e8d636ad9613a3b2da6d" translate="yes" xml:space="preserve">
          <source>Abstract types are declared using the &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt;&lt;code&gt;abstract type&lt;/code&gt;&lt;/a&gt; keyword. The general syntaxes for declaring an abstract type are:</source>
          <target state="translated">Абстрактные типы объявляются с помощью ключевого слова &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt; &lt;code&gt;abstract type&lt;/code&gt; &lt;/a&gt; . Общие синтаксисы для объявления абстрактного типа:</target>
        </trans-unit>
        <trans-unit id="c58fec15e5232080566685f01231f0dc1e49a918" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.</source>
          <target state="translated">Абстрактные типы не могут быть конкретизированы и служат только узлами на типовом графе,тем самым описывая наборы связанных конкретных типов:те конкретные типы,которые являются их потомками.Мы начинаем с абстрактных типов,несмотря на то,что они не имеют конкретизации,поскольку являются основой системы типов:они формируют концептуальную иерархию,которая делает систему типов Юлии больше,чем просто набор реализаций объектов.</target>
        </trans-unit>
        <trans-unit id="99f8f0ef23e181287cd6d3022637085c03e3e6b8" translate="yes" xml:space="preserve">
          <source>AbstractDict</source>
          <target state="translated">AbstractDict</target>
        </trans-unit>
        <trans-unit id="c0458876d81208a95087a4de5e1caaa1d2000c99" translate="yes" xml:space="preserve">
          <source>AbstractDisplay &lt;code&gt;x&lt;/code&gt; using the topmost applicable display in the display stack, typically using the richest supported multimedia output for &lt;code&gt;x&lt;/code&gt;, with plain-text &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output as a fallback. The &lt;code&gt;display(d, x)&lt;/code&gt; variant attempts to display &lt;code&gt;x&lt;/code&gt; on the given display &lt;code&gt;d&lt;/code&gt; only, throwing a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;d&lt;/code&gt; cannot display objects of this type.</source>
          <target state="translated">AbstractDisplay &lt;code&gt;x&lt;/code&gt; , используя верхний дисплей , применимый в стеке дисплея, как правило , с использованием самого богатыми поддерживаемой мультимедиа выхода для &lt;code&gt;x&lt;/code&gt; , с обычным текстом &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; выводом в качестве запасного варианта. Вариант &lt;code&gt;display(d, x)&lt;/code&gt; пытается отобразить &lt;code&gt;x&lt;/code&gt; только на данном отображении &lt;code&gt;d&lt;/code&gt; , &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;d&lt;/code&gt; не может отображать объекты этого типа.</target>
        </trans-unit>
        <trans-unit id="7eaed6a73d55c164395b7a1a21e441cbb954faed" translate="yes" xml:space="preserve">
          <source>AbstractIrrational</source>
          <target state="translated">AbstractIrrational</target>
        </trans-unit>
        <trans-unit id="bf18f60e42cfb0779a9b4f7ddad8d2d330b3942c" translate="yes" xml:space="preserve">
          <source>AbstractLock</source>
          <target state="translated">AbstractLock</target>
        </trans-unit>
        <trans-unit id="b088bdfb0583418c7216120363be65d53cfb24c4" translate="yes" xml:space="preserve">
          <source>AbstractMatrix</source>
          <target state="translated">AbstractMatrix</target>
        </trans-unit>
        <trans-unit id="1a85fd0dbacd4a4cf6bcd5291fb7d75e1f9be36d" translate="yes" xml:space="preserve">
          <source>AbstractRange</source>
          <target state="translated">AbstractRange</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="1d4be86b60074a8c81bb5c652c7352a1af4f56bd" translate="yes" xml:space="preserve">
          <source>AbstractUnitRange</source>
          <target state="translated">AbstractUnitRange</target>
        </trans-unit>
        <trans-unit id="69ac868610201e6a40f57ef6a33cac3933afa73e" translate="yes" xml:space="preserve">
          <source>AbstractVecOrMat</source>
          <target state="translated">AbstractVecOrMat</target>
        </trans-unit>
        <trans-unit id="6167adb4464ed99a679a24201ae93baff8fe87bb" translate="yes" xml:space="preserve">
          <source>AbstractVector</source>
          <target state="translated">AbstractVector</target>
        </trans-unit>
        <trans-unit id="ff33b5833701038044ed7a8bf95bb5da1639a716" translate="yes" xml:space="preserve">
          <source>Abusing this will corrupt the runtime system and cause undefined behavior:</source>
          <target state="translated">Злоупотребление этим повлечет за собой повреждение системы исполнения и приведет к неопределенному поведению:</target>
        </trans-unit>
        <trans-unit id="1067d0a82d1d5a296a37f79af88170005dbcf1e6" translate="yes" xml:space="preserve">
          <source>Ac Current</source>
          <target state="translated">Активный ток</target>
        </trans-unit>
        <trans-unit id="d1e31fbd4f9f4072d2446b9b7e8c1f20663d7c76" translate="yes" xml:space="preserve">
          <source>Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.</source>
          <target state="translated">Принимает соединение на данном сервере и возвращает соединение клиенту.Может быть предоставлен неинициализированный клиентский поток,в этом случае он будет использоваться вместо создания нового потока.</target>
        </trans-unit>
        <trans-unit id="5a231d65a330d9d9348434455d2fcc49d60050da" translate="yes" xml:space="preserve">
          <source>Access arrays in memory order, along columns</source>
          <target state="translated">Массивы доступа в порядке памяти,вдоль столбцов</target>
        </trans-unit>
        <trans-unit id="b34a6bc7b1bae42bda9d01ca1c470c5375ab7fb7" translate="yes" xml:space="preserve">
          <source>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index reads) or &quot;scatters&quot; (random-index writes).</source>
          <target state="translated">Доступы должны иметь шаблон шаблонов и не могут быть &quot;сейсмограммами&quot; (случайно-индексные чтения)или &quot;рассеивателями&quot; (случайно-индексная запись).</target>
        </trans-unit>
        <trans-unit id="04dff1094ca04d8d22abd4cb907396dab9a3d50f" translate="yes" xml:space="preserve">
          <source>Accessing Data through a Pointer</source>
          <target state="translated">Доступ к данным через указатель</target>
        </trans-unit>
        <trans-unit id="4e0aa606654432d6afe63016328a7456acbf5548" translate="yes" xml:space="preserve">
          <source>Accessing Documentation</source>
          <target state="translated">Доступ к документации</target>
        </trans-unit>
        <trans-unit id="5effc224ab155ff163fdf8204037715e80f5787f" translate="yes" xml:space="preserve">
          <source>Accessing Global Variables</source>
          <target state="translated">Доступ к глобальным переменным</target>
        </trans-unit>
        <trans-unit id="eece63f5b1a8127dcc472656346b5e65a1a16b4d" translate="yes" xml:space="preserve">
          <source>Accessing Returned Arrays</source>
          <target state="translated">Доступ к возвращаемым массивам</target>
        </trans-unit>
        <trans-unit id="06321d9fadb0d72695135f33706dc1e00ad6f5c5" translate="yes" xml:space="preserve">
          <source>Accessing memory of an object directly via a &lt;code&gt;Ptr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94331919d037782e6104eb270ff9d9fb7da43903" translate="yes" xml:space="preserve">
          <source>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. &lt;code&gt;x.a&lt;/code&gt;, or using &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;x[:a]&lt;/code&gt;. A tuple of the names can be obtained using &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, and a tuple of the values can be obtained using &lt;a href=&quot;../collections/index#Base.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Доступ к значению, связанному с именем в именованном кортеже, может быть выполнен с использованием синтаксиса доступа к полю, например &lt;code&gt;x.a&lt;/code&gt; , или с помощью &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; , например &lt;code&gt;x[:a]&lt;/code&gt; . Кортеж имен можно получить с помощью &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; , а кортеж значений можно получить с помощью &lt;a href=&quot;../collections/index#Base.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e66b7f3723702c43ff6e0aa8ffbcb4594a04f89" translate="yes" xml:space="preserve">
          <source>Accessor Functions</source>
          <target state="translated">Функции аксессуара</target>
        </trans-unit>
        <trans-unit id="d2767f0a53b5589f58d10c2a600ba9c937b4860b" translate="yes" xml:space="preserve">
          <source>Accumulation and clearing</source>
          <target state="translated">Накопление и очистка</target>
        </trans-unit>
        <trans-unit id="8d4bc1e3633428932020325ab9038391aedb805b" translate="yes" xml:space="preserve">
          <source>Accurate natural logarithm of &lt;code&gt;1+x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments less than -1.</source>
          <target state="translated">Точный натуральный логарифм &lt;code&gt;1+x&lt;/code&gt; . Выдает &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; для &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; аргументов меньше , чем -1.</target>
        </trans-unit>
        <trans-unit id="daec25040f3792b222435be23467b3ab6876b7a5" translate="yes" xml:space="preserve">
          <source>Accurately compute $e^x-1$.</source>
          <target state="translated">Точно рассчитайте $e^x-1$.</target>
        </trans-unit>
        <trans-unit id="11d200c26fa49e2ce4befb8e0cf46e14cd0db2d8" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt; when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="translated">Получите &lt;code&gt;lock&lt;/code&gt; когда она станет доступной. Если блокировка уже заблокирована другой задачей / потоком, подождите, пока она станет доступной.</target>
        </trans-unit>
        <trans-unit id="1b62ab8ac8364cef9cfdb46dc16347ea263ed957" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt;, execute &lt;code&gt;f&lt;/code&gt; with the &lt;code&gt;lock&lt;/code&gt; held, and release the &lt;code&gt;lock&lt;/code&gt; when &lt;code&gt;f&lt;/code&gt; returns. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111fa83b00bb4738853e63e06a10c68a0195c86f" translate="yes" xml:space="preserve">
          <source>Acquire the lock if it is available, and return &lt;code&gt;true&lt;/code&gt; if successful. If the lock is already locked by a different task/thread, return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Получите блокировку, если она доступна, и верните &lt;code&gt;true&lt;/code&gt; в случае успеха. Если блокировка уже заблокирована другой задачей / потоком, верните &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2342ed0f0b229a0d03ed8168b59f19edf073636" translate="yes" xml:space="preserve">
          <source>Acute Angle</source>
          <target state="translated">Острый угол</target>
        </trans-unit>
        <trans-unit id="4e210cb6cb9deed65bd9b851c840063ddc24f3fc" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Добавить &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; в очередь планировщика. Это приводит к тому, что задача будет выполняться постоянно, когда система в противном случае простаивает, если только задача не выполняет операцию блокировки, такую ​​как &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba7029093da6b4c90c7e27d2113f54b848408051" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;fetch&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to fetch from.</source>
          <target state="translated">Добавьте ссылку на &lt;em&gt;выборку&lt;/em&gt; для указанного &lt;code&gt;rmt&lt;/code&gt; . Этот refspec будет содержать информацию о том, из какой ветки (веток) производить выборку.</target>
        </trans-unit>
        <trans-unit id="bc32e59f77d37df698d49af8f9d944b43a7af79c" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;push&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to push to.</source>
          <target state="translated">Добавьте &lt;em&gt;push&lt;/em&gt; refspec для указанного &lt;code&gt;rmt&lt;/code&gt; . Этот refspec будет содержать информацию о том, в какую ветвь (-а) нажать.</target>
        </trans-unit>
        <trans-unit id="7d2e4a20c94af16618f42a95303b58afe01cacad" translate="yes" xml:space="preserve">
          <source>Add a mark at the current position of stream &lt;code&gt;s&lt;/code&gt;. Return the marked position.</source>
          <target state="translated">Добавьте отметку в текущей позиции потока &lt;code&gt;s&lt;/code&gt; . Верните отмеченную позицию.</target>
        </trans-unit>
        <trans-unit id="c81d1e9a4af83f24f843b4a0dd03ec8759d823af" translate="yes" xml:space="preserve">
          <source>Add all the files with paths specified by &lt;code&gt;files&lt;/code&gt; to the index &lt;code&gt;idx&lt;/code&gt; (or the index of the &lt;code&gt;repo&lt;/code&gt;). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. &lt;code&gt;files&lt;/code&gt; may contain glob patterns which will be expanded and any matching files will be added (unless &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; is set, see below). If a file has been ignored (in &lt;code&gt;.gitignore&lt;/code&gt; or in the config), it &lt;em&gt;will not&lt;/em&gt; be added, &lt;em&gt;unless&lt;/em&gt; it is already being tracked in the index, in which case it &lt;em&gt;will&lt;/em&gt; be updated. The keyword argument &lt;code&gt;flags&lt;/code&gt; is a set of bit-flags which control the behavior with respect to ignored files:</source>
          <target state="translated">Добавьте все файлы с путями, указанными в &lt;code&gt;files&lt;/code&gt; в индекс &lt;code&gt;idx&lt;/code&gt; (или индекс &lt;code&gt;repo&lt;/code&gt; ). Если файл уже существует, запись индекса будет обновлена. Если файл еще не существует, он будет снова добавлен в индекс. &lt;code&gt;files&lt;/code&gt; могут содержать шаблоны глобусов, которые будут расширены, и любые соответствующие файлы будут добавлены (если не установлен &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; , см. ниже). Если файл был проигнорирован (в &lt;code&gt;.gitignore&lt;/code&gt; или в конфигурации), он &lt;em&gt;не&lt;/em&gt; будет добавлен, &lt;em&gt;если&lt;/em&gt; он уже не отслеживается в индексе, и в этом случае он &lt;em&gt;будет&lt;/em&gt; обновлен. &lt;code&gt;flags&lt;/code&gt; аргумента ключевого слова представляет собой набор битовых флагов, которые управляют поведением игнорируемых файлов:</target>
        </trans-unit>
        <trans-unit id="f9859b5e151c0d4dccb9ba69eeb3e7174642b756" translate="yes" xml:space="preserve">
          <source>Add processes on remote machines via SSH. Requires &lt;code&gt;julia&lt;/code&gt; to be installed in the same location on each node, or to be available via a shared file system.</source>
          <target state="translated">Добавляйте процессы на удаленные машины через SSH. Требуется, чтобы &lt;code&gt;julia&lt;/code&gt; была установлена ​​в одном месте на каждом узле или была доступна через общую файловую систему.</target>
        </trans-unit>
        <trans-unit id="c93d7a95d43dad0a2e3566faa9380568c513bf49" translate="yes" xml:space="preserve">
          <source>Add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">Добавьте элементы &lt;code&gt;collection2&lt;/code&gt; в конец &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="8f60daef6009f4b56c282cccb45652345ff90737" translate="yes" xml:space="preserve">
          <source>Addition operator. &lt;code&gt;x+y+z+...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">Оператор сложения. &lt;code&gt;x+y+z+...&lt;/code&gt; вызывает эту функцию со всеми аргументами, т.е. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23397c083849f8b996730f9a8baa14e28dc8e903" translate="yes" xml:space="preserve">
          <source>Additional examples and tests are available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дополнительные примеры и тесты доступны в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="685ef1698c6666c2bd0d492d0ee46828879da80d" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt; (except for &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt;) as a &quot;scalar&quot;.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; не ограничивается массивами (см. Документацию по функциям), она также обрабатывает кортежи и обрабатывает любой аргумент, не являющийся массивом, кортежем или &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt; (кроме &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; ), как &amp;laquo;скаляр&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="945097f233edb04921a995b222a7aba704c8bec8" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation); it also handles scalars, tuples and other collections. By default, only some argument types are considered scalars, including (but not limited to) &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;code&gt;missing&lt;/code&gt; and &lt;code&gt;nothing&lt;/code&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f79534c24bf8f2a16bd71a1b6a3a39a544a8226" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt;&lt;code&gt;sinpi(x)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt;&lt;code&gt;cospi(x)&lt;/code&gt;&lt;/a&gt; are provided for more accurate computations of &lt;code&gt;sin(pi*x)&lt;/code&gt; and &lt;code&gt;cos(pi*x)&lt;/code&gt; respectively.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt; &lt;code&gt;sinpi(x)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt; &lt;code&gt;cospi(x)&lt;/code&gt; &lt;/a&gt; предоставляются для более точных вычислений &lt;code&gt;sin(pi*x)&lt;/code&gt; и &lt;code&gt;cos(pi*x)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="6351bb5c94d5c92615addcb5b2795472a480f027" translate="yes" xml:space="preserve">
          <source>Additionally, Julia is not memory safe in the presence of a data race. Be very careful about reading a global variable (or closure variable) if another thread might write to it! Instead, always use the lock pattern above when changing any data (such as assigning to a global) visible to multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3a3f7bf5e98e1e5497ee4fe9676516a92be473" translate="yes" xml:space="preserve">
          <source>Additionally, code blocks can be enclosed using triple backticks with an optional &quot;language&quot; to specify how a block of code should be highlighted.</source>
          <target state="translated">Кроме того,блоки кода могут быть вложены с помощью тройных обратных ссылок с дополнительным &quot;языком&quot;,чтобы указать,как блок кода должен быть выделен.</target>
        </trans-unit>
        <trans-unit id="1f4cc224a45b05b5c73175d158a7eca11aff2c5e" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6d0dd52c8f973d7d02448858d93589ccb8e270" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="translated">Кроме того, на основе этих примитивных числовых типов построена полная поддержка &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;сложных и рациональных чисел&lt;/a&gt; . Все числовые типы взаимодействуют естественным образом без явного приведения типов, благодаря гибкой, расширяемой пользователем &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;системе продвижения типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccda9828ec19af11c51796660b5ccb16a7d0e952" translate="yes" xml:space="preserve">
          <source>Additionally, normal and exponential distributions are implemented for some &lt;code&gt;AbstractFloat&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt; types, see &lt;a href=&quot;#Base.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Random.randexp&quot;&gt;&lt;code&gt;randexp&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Кроме того, для некоторых типов &lt;code&gt;AbstractFloat&lt;/code&gt; и &lt;code&gt;Complex&lt;/code&gt; реализованы нормальные и экспоненциальные распределения , подробности см. В &lt;a href=&quot;#Base.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Random.randexp&quot;&gt; &lt;code&gt;randexp&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99173595dabed80445cea4531dee6a385768b591" translate="yes" xml:space="preserve">
          <source>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</source>
          <target state="translated">Кроме того,выражения в скобках могут использоваться в качестве коэффициентов к переменным,что подразумевает умножение выражения на переменную:</target>
        </trans-unit>
        <trans-unit id="fc43d556aa5aff0175b36169557918148740e7bb" translate="yes" xml:space="preserve">
          <source>Additionally, some exception types take one or more arguments that are used for error reporting:</source>
          <target state="translated">Кроме того,некоторые типы исключений принимают один или несколько аргументов,которые используются для сообщения об ошибках:</target>
        </trans-unit>
        <trans-unit id="7c53242e98f029fd9fd99fe8ac859128c91d92ea" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[begin]&lt;/code&gt; and &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the first and last valid indices, respectively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af66c1813abced10595ff4db44c8598650f35a8" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the last valid index. It is recommended to also define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; to specify the first valid index:</source>
          <target state="translated">Кроме того, для поддержки синтаксиса &lt;code&gt;S[end]&lt;/code&gt; мы должны определить &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; ,&lt;/a&gt; чтобы указать последний действительный индекс. Также рекомендуется определить &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt; &lt;code&gt;firstindex&lt;/code&gt; ,&lt;/a&gt; чтобы указать первый действительный индекс:</target>
        </trans-unit>
        <trans-unit id="0d6e9dda2992ae61bd194a5d6431ac6a6fc0e4af" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each of which should be a documentable expression. This syntax is equivalent to</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , каждая из которых должна быть документированным выражением. Этот синтаксис эквивалентен</target>
        </trans-unit>
        <trans-unit id="8943e54e348b67270f56f401533e4c55795efd88" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к выражению, сгенерированному расширением &lt;code&gt;@m expression&lt;/code&gt; . Это позволяет &lt;code&gt;@inline&lt;/code&gt; выражения, украшенные @inline , &lt;code&gt;@noinline&lt;/code&gt; , &lt;code&gt;@generated&lt;/code&gt; или любым другим макросом, так же, как выражения без декорирования.</target>
        </trans-unit>
        <trans-unit id="c5cf536102070d30975cbdc29561f68968871a8c" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;@m(::Any)&lt;/code&gt; macro definition.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; в определение &lt;code&gt;@m(::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84e25857657b333b201a4364df19960589319dca" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Binding&lt;/code&gt;s &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; в &lt;code&gt;Binding&lt;/code&gt; s &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f9a2f04c857c99469b4786ce6042e5c04d6c307" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;M&lt;/code&gt;. Adding the docstring above the &lt;code&gt;Module&lt;/code&gt; is the preferred syntax, however both are equivalent.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;M&lt;/code&gt; . Добавление строки документации над &lt;code&gt;Module&lt;/code&gt; является предпочтительным синтаксисом, однако оба они эквивалентны.</target>
        </trans-unit>
        <trans-unit id="82e1da815004f8c82f5b3b4ddf196b362c9b6b8a" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d607a4ba66a2defbbbd671ccd4f1fc3f1e66348d" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the function &lt;code&gt;f&lt;/code&gt;. The first version is the preferred syntax, however both are equivalent.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к функции &lt;code&gt;f&lt;/code&gt; . Первая версия является предпочтительным синтаксисом, однако обе эквивалентны.</target>
        </trans-unit>
        <trans-unit id="015afea43fcf05b33dc7ee7ee68bca2953573884" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the macro named &lt;code&gt;@m&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; в макрос с именем &lt;code&gt;@m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="827af43a45abefcd341e6f719f9f401e5c730792" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the method &lt;code&gt;f(::Any)&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к методу &lt;code&gt;f(::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b443c2f582d2d534bd4dd25c05fdf4fba408aed1" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. However, it is preferred that &lt;code&gt;sym&lt;/code&gt; is documented where it is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8df7e7a7df772447527b2f26ed82b0a9c8b23e3" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. Users should prefer documenting &lt;code&gt;sym&lt;/code&gt; at its definition.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к значению, связанному с &lt;code&gt;sym&lt;/code&gt; . Пользователи должны предпочесть документирование &lt;code&gt;sym&lt;/code&gt; в его определении.</target>
        </trans-unit>
        <trans-unit id="7496f9703fbec9a9c078ee921645986d1520779f" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to two &lt;code&gt;Method&lt;/code&gt;s, namely &lt;code&gt;f(::Any)&lt;/code&gt; and &lt;code&gt;f(::Any, ::Any)&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к двум &lt;code&gt;Method&lt;/code&gt; s, а именно &lt;code&gt;f(::Any)&lt;/code&gt; и &lt;code&gt;f(::Any, ::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8aaa795c4bb3bd668d398ed223b6d5b98c3053" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt; to field &lt;code&gt;T.x&lt;/code&gt; and &lt;code&gt;&quot;y&quot;&lt;/code&gt; to field &lt;code&gt;T.y&lt;/code&gt;. Also applicable to &lt;code&gt;mutable struct&lt;/code&gt; types.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к типу &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;&quot;x&quot;&lt;/code&gt; к полю &lt;code&gt;T.x&lt;/code&gt; и &lt;code&gt;&quot;y&quot;&lt;/code&gt; к полю &lt;code&gt;T.y&lt;/code&gt; . Также применимо к &lt;code&gt;mutable struct&lt;/code&gt; типам структур .</target>
        </trans-unit>
        <trans-unit id="509ef7b304e0d5048959f5a1e066b6245d575e62" translate="yes" xml:space="preserve">
          <source>Adds the docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to types &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;T2&lt;/code&gt;, and &lt;code&gt;T3&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к типам &lt;code&gt;T1&lt;/code&gt; , &lt;code&gt;T2&lt;/code&gt; и &lt;code&gt;T3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9a51c66a638e61a03f3ba3bc6a5ae7966f901a4" translate="yes" xml:space="preserve">
          <source>Adjuster Functions</source>
          <target state="translated">Функции регулятора</target>
        </trans-unit>
        <trans-unit id="3ed15208c269239266d3575007709a349ee8dcb4" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; by iterating at most &lt;code&gt;limit&lt;/code&gt; iterations by &lt;code&gt;step&lt;/code&gt; increments until &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must take a single &lt;code&gt;TimeType&lt;/code&gt; argument and return a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;same&lt;/code&gt; allows &lt;code&gt;dt&lt;/code&gt; to be considered in satisfying &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Регулирует &lt;code&gt;dt&lt;/code&gt; , повторяя не более &lt;code&gt;limit&lt;/code&gt; итераций с &lt;code&gt;step&lt;/code&gt; пока &lt;code&gt;func&lt;/code&gt; не вернет &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;func&lt;/code&gt; должен принимать единственный аргумент &lt;code&gt;TimeType&lt;/code&gt; и возвращать &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;same&lt;/code&gt; позволяет рассматривать &lt;code&gt;dt&lt;/code&gt; при выполнении &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="542b7e7c2fd74f8d271308bdddf4ad37b5294110" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Monday of its week.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на понедельник своей недели.</target>
        </trans-unit>
        <trans-unit id="ba3476b1421df6e3edaa8e17f787d5952e83be65" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Sunday of its week.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на воскресенье своей недели.</target>
        </trans-unit>
        <trans-unit id="3224cd68e5551ff4e3fc4fc6b2b947ffc7f24a64" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the first &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к первому &lt;code&gt;dow&lt;/code&gt; месяца. В качестве альтернативы, &lt;code&gt;of=Year&lt;/code&gt; будет соответствовать первому &lt;code&gt;dow&lt;/code&gt; года.</target>
        </trans-unit>
        <trans-unit id="85f046851c6e044a73b6195b73c28ea067eb7654" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its month.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на первый день месяца.</target>
        </trans-unit>
        <trans-unit id="f4430fe642c3e3cf011a04583f6d0f8ce92cdee6" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its quarter.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к первому дню квартала.</target>
        </trans-unit>
        <trans-unit id="84bc65bd05f794b2297c4096e727f0dd2edbb9dd" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its year.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к первому дню года.</target>
        </trans-unit>
        <trans-unit id="2f0c9a334203505d658bff6209e3cc9cb72c986e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the last &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к последнему &lt;code&gt;dow&lt;/code&gt; месяца. В качестве альтернативы &lt;code&gt;of=Year&lt;/code&gt; будет соответствовать последнему &lt;code&gt;dow&lt;/code&gt; года.</target>
        </trans-unit>
        <trans-unit id="78d3c49adba39ac1f401e060e547fe0cc0d6d99c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its month.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на последний день месяца.</target>
        </trans-unit>
        <trans-unit id="64612df263c1926bf9efeecdbaf1b82e9cd07b8e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its quarter.</source>
          <target state="translated">Корректирует &lt;code&gt;dt&lt;/code&gt; до последнего дня квартала.</target>
        </trans-unit>
        <trans-unit id="91489c37594baa78e3476045075dafd7e9ef8e93" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its year.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на последний день года.</target>
        </trans-unit>
        <trans-unit id="f360011526f7451524f23fc8d46d352e948cc7d3" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the next day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the next &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на следующий день недели , соответствующий &lt;code&gt;dow&lt;/code&gt; с &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . Установка &lt;code&gt;same=true&lt;/code&gt; позволяет рассматривать текущий &lt;code&gt;dt&lt;/code&gt; как следующий &lt;code&gt;dow&lt;/code&gt; , не допуская никаких корректировок.</target>
        </trans-unit>
        <trans-unit id="068372d2e011960d73021d80afa760372bcf985c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the previous day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the previous &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на предыдущий день недели, соответствующий &lt;code&gt;dow&lt;/code&gt; с &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . Д. Установка &lt;code&gt;same=true&lt;/code&gt; позволяет рассматривать текущее значение &lt;code&gt;dt&lt;/code&gt; как предыдущее значение &lt;code&gt;dow&lt;/code&gt; без возможности корректировки.</target>
        </trans-unit>
        <trans-unit id="59c3f81e00ff6162254f4463064f47b013b2418f" translate="yes" xml:space="preserve">
          <source>Admonitions</source>
          <target state="translated">Admonitions</target>
        </trans-unit>
        <trans-unit id="836a223dfb6110b2db06c9c781ddc336919a8a06" translate="yes" xml:space="preserve">
          <source>Admonitions, like most other toplevel elements, can contain other toplevel elements.</source>
          <target state="translated">Допущения,как и большинство других элементов топ-уровня,могут содержать и другие элементы топ-уровня.</target>
        </trans-unit>
        <trans-unit id="b83b0b84935203a338ba6594cae9f540216d121e" translate="yes" xml:space="preserve">
          <source>Advance the iterator to obtain the next element. If no elements remain, &lt;code&gt;nothing&lt;/code&gt; should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</source>
          <target state="translated">Переместите итератор, чтобы получить следующий элемент. Если никаких элементов не осталось, &lt;code&gt;nothing&lt;/code&gt; должно быть возвращено. В противном случае должен быть возвращен кортеж из двух элементов следующего элемента и новое состояние итерации.</target>
        </trans-unit>
        <trans-unit id="4b6a7abaa616c69342aad0f3bc06d227b49b3cf3" translate="yes" xml:space="preserve">
          <source>Advance the stream &lt;code&gt;io&lt;/code&gt; such that the next-read character will be the first remaining for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If the keyword argument &lt;code&gt;linecomment&lt;/code&gt; is specified, all characters from that character until the start of the next line are ignored.</source>
          <target state="translated">Продвиньте поток &lt;code&gt;io&lt;/code&gt; так, чтобы следующий прочитанный символ был первым оставшимся, для которого &lt;code&gt;predicate&lt;/code&gt; вернул &lt;code&gt;false&lt;/code&gt; . Если указано ключевое слово аргумент &lt;code&gt;linecomment&lt;/code&gt; , все символы от этого символа до начала следующей строки игнорируются.</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">Расширенное использование</target>
        </trans-unit>
        <trans-unit id="ff26be938424cf2d67217e2575645ca68557c533" translate="yes" xml:space="preserve">
          <source>Aerial Tramway</source>
          <target state="translated">Аэродромный трамвай</target>
        </trans-unit>
        <trans-unit id="c3753451b13262a44f9a5817e07e24e560603141" translate="yes" xml:space="preserve">
          <source>After a call like &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt;, you would get the expected result: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt;. However, now suppose that &lt;code&gt;*=&lt;/code&gt;, when used with matrices, instead mutated the left hand side. There would be two problems:</source>
          <target state="translated">После звонка типа &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt; , вы получите ожидаемый результат: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt; . Однако теперь предположим, что &lt;code&gt;*=&lt;/code&gt; , когда используется с матрицами, вместо этого изменяет левую часть. Было бы две проблемы:</target>
        </trans-unit>
        <trans-unit id="ad5164f2f115375c06ec8f88153f96f0d31b808d" translate="yes" xml:space="preserve">
          <source>After a task starts running on a certain thread (e.g. via &lt;code&gt;@spawn&lt;/code&gt;), it will always be restarted on the same thread after blocking. In the future this limitation will be removed, and tasks will migrate between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db34be90d58adae735cb60ab04365869aa56065b" translate="yes" xml:space="preserve">
          <source>Airplane</source>
          <target state="translated">Airplane</target>
        </trans-unit>
        <trans-unit id="80135999396a20e42730a1c2e1dfae947e0952c1" translate="yes" xml:space="preserve">
          <source>Alarm Clock</source>
          <target state="translated">Будильник</target>
        </trans-unit>
        <trans-unit id="4c76737983211c324879531ef47ac946ce297c2e" translate="yes" xml:space="preserve">
          <source>Alef Symbol / First Transfinite Cardinal</source>
          <target state="translated">Символ Алефа/Первый трансформированный кардинал</target>
        </trans-unit>
        <trans-unit id="f2f34a33d9ae0109b50986f6079e5b5b8422fa27" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;UndefInitializer()&lt;/code&gt;, which constructs an instance of the singleton type &lt;a href=&quot;#Core.UndefInitializer&quot;&gt;&lt;code&gt;UndefInitializer&lt;/code&gt;&lt;/a&gt;, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.</source>
          <target state="translated">Псевдоним для &lt;code&gt;UndefInitializer()&lt;/code&gt; , который создает экземпляр одноэлементного типа &lt;a href=&quot;#Core.UndefInitializer&quot;&gt; &lt;code&gt;UndefInitializer&lt;/code&gt; &lt;/a&gt; , используемый при инициализации массива, чтобы указать, что вызывающий конструктор массива хотел бы получить неинициализированный массив.</target>
        </trans-unit>
        <trans-unit id="38d75bc82e2c72130349f85ee2dea5673d201a42" translate="yes" xml:space="preserve">
          <source>Alien Monster</source>
          <target state="translated">Чужеродные монстры</target>
        </trans-unit>
        <trans-unit id="0c70d0069c9dc176b6060d55ab195149b38ec01a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;export&lt;/code&gt;ed names (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;), &lt;code&gt;MyModule.x&lt;/code&gt;, &lt;code&gt;MyModule.y&lt;/code&gt; and &lt;code&gt;MyModule.p&lt;/code&gt;</source>
          <target state="translated">Все &lt;code&gt;export&lt;/code&gt; имена ( &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; ), &lt;code&gt;MyModule.x&lt;/code&gt; , &lt;code&gt;MyModule.y&lt;/code&gt; и &lt;code&gt;MyModule.p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f95289d7bb9f459a113b14aa6caea6d6b0ee5b" translate="yes" xml:space="preserve">
          <source>All Equal To</source>
          <target state="translated">Все равны</target>
        </trans-unit>
        <trans-unit id="59150af6415167841703220f4f97802416f10725" translate="yes" xml:space="preserve">
          <source>All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; explicitly allows for other tasks to be scheduled.</source>
          <target state="translated">Все задачи ввода-вывода, таймеры, команды REPL и т. Д. Мультиплексируются в один поток ОС через цикл событий. Исправленная версия libuv ( &lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt; ) предоставляет эту функцию. Точки доходности обеспечивают совместное планирование нескольких задач в одном потоке ОС. Задачи ввода-вывода и таймеры неявно уступают место в ожидании наступления события. Вызов &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; явно позволяет планировать другие задачи.</target>
        </trans-unit>
        <trans-unit id="e522896e2dfc730e2866839376a2a265314c5b2a" translate="yes" xml:space="preserve">
          <source>All Julia streams expose at least a &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method, taking the stream as their first argument, e.g.:</source>
          <target state="translated">Все потоки Julia предоставляют по крайней мере методы &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; , принимая поток в качестве первого аргумента, например:</target>
        </trans-unit>
        <trans-unit id="c6a6b81f53852c577455dd25f826592290abcb2e" translate="yes" xml:space="preserve">
          <source>All Objects</source>
          <target state="translated">Все объекты</target>
        </trans-unit>
        <trans-unit id="dd1ab7575b34c95371319e3c78f1e648aa0611b0" translate="yes" xml:space="preserve">
          <source>All Unicode code points (&lt;code&gt;\U&lt;/code&gt; with 1-8 trailing hex digits; max value = 0010ffff)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b272413234229118c2015aaa68ca35bdb9c75799" translate="yes" xml:space="preserve">
          <source>All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a &lt;strong&gt;global&lt;/strong&gt; variable. Variables defined at top level scope inside modules are also global.</source>
          <target state="translated">Весь код в REPL оценивается в глобальной области, поэтому переменная, определенная и назначенная на верхнем уровне, будет &lt;strong&gt;глобальной&lt;/strong&gt; переменной. Переменные, определенные на верхнем уровне внутри модулей, также являются глобальными.</target>
        </trans-unit>
        <trans-unit id="d45486021b7cdd7677275ec32e5637b641c26f3c" translate="yes" xml:space="preserve">
          <source>All comma-separated expressions after &lt;code&gt;for&lt;/code&gt; are interpreted as ranges. Adding parentheses lets us add a third argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Все выражения, разделенные запятыми после &lt;code&gt;for&lt;/code&gt; , интерпретируются как диапазоны. Добавление круглых скобок позволяет нам добавить третий аргумент в &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e1833bbb77ee3eab574ef8615d776277ec2b68aa" translate="yes" xml:space="preserve">
          <source>All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</source>
          <target state="translated">Все соединения аутентифицируются с обеих сторон,чтобы гарантировать,что только рабочие,запущенные мастером,могут подключаться друг к другу.</target>
        </trans-unit>
        <trans-unit id="9ad5ec5b3a4aaf8bd9fb90db1fc3be44898322c8" translate="yes" xml:space="preserve">
          <source>All declared types (the &lt;code&gt;DataType&lt;/code&gt; variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.</source>
          <target state="translated">Все объявленные типы ( разнообразие &lt;code&gt;DataType&lt;/code&gt; ) могут быть параметризованы с использованием одного и того же синтаксиса в каждом случае. Мы обсудим их в следующем порядке: сначала параметрические составные типы, затем параметрические абстрактные типы и, наконец, параметрические примитивные типы.</target>
        </trans-unit>
        <trans-unit id="d9c5dd854b32fb08dbc64da03bc88b2f5ca50052" translate="yes" xml:space="preserve">
          <source>All instances of some abstract types are by default considered &quot;sufficiently similar&quot; that a universal &lt;code&gt;convert&lt;/code&gt; definition is provided in Julia Base. For example, this definition states that it's valid to &lt;code&gt;convert&lt;/code&gt; any &lt;code&gt;Number&lt;/code&gt; type to any other by calling a 1-argument constructor:</source>
          <target state="translated">Все экземпляры некоторых абстрактных типов по умолчанию считаются &amp;laquo;достаточно похожими&amp;raquo;, &lt;code&gt;convert&lt;/code&gt; в Julia Base предоставляется универсальное определение преобразования . Например, это определение гласит, что можно &lt;code&gt;convert&lt;/code&gt; любой &lt;code&gt;Number&lt;/code&gt; тип в любой другой, вызвав конструктор с одним аргументом:</target>
        </trans-unit>
        <trans-unit id="40a2b8b6f65bf4cf79d2f004dafadcaa12f30e1e" translate="yes" xml:space="preserve">
          <source>All interface customization is done through the keyword only &lt;code&gt;TerminalMenus.config()&lt;/code&gt; function.</source>
          <target state="translated">Вся настройка интерфейса выполняется с помощью функции &lt;code&gt;TerminalMenus.config()&lt;/code&gt; только для ключевых слов .</target>
        </trans-unit>
        <trans-unit id="5e93c45e883f28df975e96b20e62c4d715867d52" translate="yes" xml:space="preserve">
          <source>All non-real parts of the diagonal will be ignored.</source>
          <target state="translated">Все нереальные части диагонали будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="7f36c1fb18a59b1d9f547660c394427791f475ab" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Все макросы журналирования &lt;code&gt;@debug&lt;/code&gt; , &lt;code&gt;@info&lt;/code&gt; , &lt;code&gt;@warn&lt;/code&gt; и &lt;code&gt;@error&lt;/code&gt; имеют общие функции, которые подробно описаны в документации для более общего макроса &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec4e52b5ca9f88c6fa22f8c3f3902856d9403989" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Logging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97250d85e46e2f0063062a4fe00d04b5c8c86241" translate="yes" xml:space="preserve">
          <source>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</source>
          <target state="translated">Все операции с разреженными матрицами тщательно выполняются,чтобы использовать структуру данных CSC для повышения производительности и избежать дорогостоящих операций.</target>
        </trans-unit>
        <trans-unit id="d92bd72fff847012d04881678e278a18d2126812" translate="yes" xml:space="preserve">
          <source>All other combinations of arguments default to returning an &lt;code&gt;Array&lt;/code&gt;, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</source>
          <target state="translated">Все другие комбинации аргументов по умолчанию возвращают &lt;code&gt;Array&lt;/code&gt; , но пользовательские типы контейнеров могут определять свою собственную реализацию и правила, подобные продвижению, для настройки результата, когда они появляются в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="de25475b274a168126e2d504207af50116291e77" translate="yes" xml:space="preserve">
          <source>All processes can directly communicate with each other.</source>
          <target state="translated">Все процессы могут напрямую взаимодействовать друг с другом.</target>
        </trans-unit>
        <trans-unit id="7feddee30f64db86bbc24d86a29d550a804d3b31" translate="yes" xml:space="preserve">
          <source>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</source>
          <target state="translated">Все процессы в кластере используют один и тот же куки-файл,который по умолчанию является случайно сгенерированной строкой на мастер-процессе:</target>
        </trans-unit>
        <trans-unit id="ad59be0f62242de6d2f5d39eccfa83593fd9484b" translate="yes" xml:space="preserve">
          <source>All string types are subtypes of the abstract type &lt;code&gt;AbstractString&lt;/code&gt;, and external packages define additional &lt;code&gt;AbstractString&lt;/code&gt; subtypes (e.g. for other encodings). If you define a function expecting a string argument, you should declare the type as &lt;code&gt;AbstractString&lt;/code&gt; in order to accept any string type.</source>
          <target state="translated">Все строковые типы являются подтипами абстрактного типа &lt;code&gt;AbstractString&lt;/code&gt; , а внешние пакеты определяют дополнительные подтипы &lt;code&gt;AbstractString&lt;/code&gt; (например, для других кодировок). Если вы определяете функцию, ожидающую строкового аргумента, вы должны объявить тип как &lt;code&gt;AbstractString&lt;/code&gt; , чтобы принять любой строковый тип.</target>
        </trans-unit>
        <trans-unit id="b0dc699cc676b22c3459d4cf16d1eaa2e5774729" translate="yes" xml:space="preserve">
          <source>All subtypes of &lt;code&gt;AbstractDateToken&lt;/code&gt; must define this method in order to be able to print a Date / DateTime object according to a &lt;code&gt;DateFormat&lt;/code&gt; containing that token.</source>
          <target state="translated">Все подтипы &lt;code&gt;AbstractDateToken&lt;/code&gt; должны определять этот метод, чтобы иметь возможность печатать объект Date / DateTime в соответствии с &lt;code&gt;DateFormat&lt;/code&gt; , содержащим этот токен.</target>
        </trans-unit>
        <trans-unit id="1c882b6f017fe5d01060c9bf473577d13959404c" translate="yes" xml:space="preserve">
          <source>All the sorting and order related functions rely on a &quot;less than&quot; relation defining a total order on the values to be manipulated. The &lt;code&gt;isless&lt;/code&gt; function is invoked by default, but the relation can be specified via the &lt;code&gt;lt&lt;/code&gt; keyword.</source>
          <target state="translated">Все функции, связанные с сортировкой и упорядочением, полагаются на отношение &amp;laquo;меньше&amp;raquo;, определяющее общий порядок значений, которыми нужно управлять. Функция &lt;code&gt;isless&lt;/code&gt; вызывается по умолчанию, но отношение можно указать с помощью ключевого слова &lt;code&gt;lt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c82535675951a4a1fb997658084e8ecb7b3e47f" translate="yes" xml:space="preserve">
          <source>All the standard trigonometric and hyperbolic functions are also defined:</source>
          <target state="translated">Также определены все стандартные тригонометрические и гиперболические функции:</target>
        </trans-unit>
        <trans-unit id="47776a059f25c3e9e75665d89b25759946e151d9" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6670e96208b5b1af061bdf66066d2386e48cd71d" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="translated">Все воркеры в кластере используют тот же &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;файл cookie,&lt;/a&gt; что и главный. Когда cookie не &lt;code&gt;--worker&lt;/code&gt; , то есть с параметром --worker , воркер пытается прочитать его со стандартного ввода. &lt;code&gt;LocalManager&lt;/code&gt; и &lt;code&gt;SSHManager&lt;/code&gt; передают cookie вновь запущенным рабочим через свои стандартные входы.</target>
        </trans-unit>
        <trans-unit id="cc1f71fefd88bfe7d7be3a2017ea32033d467364" translate="yes" xml:space="preserve">
          <source>Allocation of output container</source>
          <target state="translated">Распределение выходного контейнера</target>
        </trans-unit>
        <trans-unit id="dbd9853a9ad8ada702240986063881992112c9e5" translate="yes" xml:space="preserve">
          <source>Allowed Variable Names</source>
          <target state="translated">Допустимые переменные имена</target>
        </trans-unit>
        <trans-unit id="91b9aa574b0fcbb72864d68cfe9f2b306633c73a" translate="yes" xml:space="preserve">
          <source>Allowed within</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ef6092b26e1508d93983ee74a79d58892de4c1" translate="yes" xml:space="preserve">
          <source>Almost Equal Or Equal To</source>
          <target state="translated">Почти равны или равны</target>
        </trans-unit>
        <trans-unit id="1fbf3e4677335672b3087596163b48e552785b56" translate="yes" xml:space="preserve">
          <source>Almost Equal To</source>
          <target state="translated">Почти равный</target>
        </trans-unit>
        <trans-unit id="7475fcee6d3c9395bedceacb414c243d6b969b91" translate="yes" xml:space="preserve">
          <source>Almost Equal To With Circumflex Accent</source>
          <target state="translated">Почти одинаково с акцентом циркумфлекс.</target>
        </trans-unit>
        <trans-unit id="2c35923911b4ba37311dbb677458e2c0adca9382" translate="yes" xml:space="preserve">
          <source>Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...</source>
          <target state="translated">Хорошо,теперь,когда мы лучше понимаем,как работают генерируемые функции,давайте используем их,чтобы построить более продвинутую (и действующую)функциональность...</target>
        </trans-unit>
        <trans-unit id="c2ff920784db1defb83bee5378709d9aaacf2e45" translate="yes" xml:space="preserve">
          <source>Also notice the difference between &lt;code&gt;max.(a,b)&lt;/code&gt;, which &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; elementwise over &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum(a)&lt;/code&gt;&lt;/a&gt;, which finds the largest value within &lt;code&gt;a&lt;/code&gt;. The same relationship holds for &lt;code&gt;min.(a,b)&lt;/code&gt; and &lt;code&gt;minimum(a)&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание на разницу между &lt;code&gt;max.(a,b)&lt;/code&gt; , который &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; поэлементно через &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , и &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum(a)&lt;/code&gt; &lt;/a&gt; , который находит наибольшее значение в &lt;code&gt;a&lt;/code&gt; . Такое же соотношение сохраняется для &lt;code&gt;minimum(a)&lt;/code&gt; &lt;code&gt;min.(a,b)&lt;/code&gt; и минимума (a) .</target>
        </trans-unit>
        <trans-unit id="9c0081a46476345434d3719172fe53c135ada9e3" translate="yes" xml:space="preserve">
          <source>Also observe the significant distinction between &lt;code&gt;\xff&lt;/code&gt; and &lt;code&gt;\uff&lt;/code&gt;: the former escape sequence encodes the &lt;em&gt;byte 255&lt;/em&gt;, whereas the latter escape sequence represents the &lt;em&gt;code point 255&lt;/em&gt;, which is encoded as two bytes in UTF-8:</source>
          <target state="translated">Также &lt;code&gt;\xff&lt;/code&gt; внимание на существенное различие между \ xff и &lt;code&gt;\uff&lt;/code&gt; : первая escape-последовательность кодирует &lt;em&gt;байт 255&lt;/em&gt; , тогда как последняя escape-последовательность представляет собой &lt;em&gt;кодовую точку 255&lt;/em&gt; , которая закодирована как два байта в UTF-8:</target>
        </trans-unit>
        <trans-unit id="6bc9da3cb0ed97f96102bee03dd8744d00eda6b1" translate="yes" xml:space="preserve">
          <source>Also recommended is Bruce Dawson's &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;series of blog posts on floating-point numbers&lt;/a&gt;.</source>
          <target state="translated">Также рекомендуется &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;серия публикаций&lt;/a&gt; Брюса Доусона о числах с плавающей запятой .</target>
        </trans-unit>
        <trans-unit id="3be1a8ba3f90adcceb5c1de0a45416e04c2e2aa6" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d960a868768098e1ba53fb3f2c0df8ab0a40a7" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="translated">Кроме того, &lt;em&gt;каждый&lt;/em&gt; бинарный оператор поддерживает &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;версию&lt;/a&gt; с точкой, которая может применяться к массивам (и комбинациям массивов и скаляров) в таких объединенных &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;операциях широковещательной передачи&lt;/a&gt; , например &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef09b3cc10de506de44d97115e3fd6f71c9ee1fa" translate="yes" xml:space="preserve">
          <source>Also, the function that arguments are splatted into need not be a varargs function (although it often is):</source>
          <target state="translated">Кроме того,функция,в которую разбиваются аргументы,не обязательно должна быть функцией varargs (хотя это часто бывает):</target>
        </trans-unit>
        <trans-unit id="a36cb69e8042fa50a20647f8ee8afd7f80876eda" translate="yes" xml:space="preserve">
          <source>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of &lt;code&gt;mode&lt;/code&gt; correspond to those from &lt;code&gt;fopen(3)&lt;/code&gt; or Perl &lt;code&gt;open&lt;/code&gt;, and are equivalent to setting the following boolean groups:</source>
          <target state="translated">Альтернативный синтаксис для open, где спецификатор режима на основе строки используется вместо пяти логических значений. Значения &lt;code&gt;mode&lt;/code&gt; соответствуют значениям из &lt;code&gt;fopen(3)&lt;/code&gt; или Perl &lt;code&gt;open&lt;/code&gt; и эквивалентны установке следующих булевых групп:</target>
        </trans-unit>
        <trans-unit id="a084d20c27ad4b5e370e6e41af49a7a8b0bbbe9c" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;using Module&lt;/code&gt; will import all exported &lt;code&gt;Module&lt;/code&gt; functions into the current namespace.</source>
          <target state="translated">В качестве альтернативы, &lt;code&gt;using Module&lt;/code&gt; импортирует все экспортированные функции &lt;code&gt;Module&lt;/code&gt; в текущее пространство имен.</target>
        </trans-unit>
        <trans-unit id="cfd0514a347606051a7fccfba50cde275fcde17f" translate="yes" xml:space="preserve">
          <source>Alternatively, a sequence of pair arguments may be passed.</source>
          <target state="translated">В качестве альтернативы может быть передана последовательность аргументов пары.</target>
        </trans-unit>
        <trans-unit id="05c4eee40518a92290ba5caa4623a48a40f59cc6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="translated">В качестве альтернативы, более &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt; управление и дополнительные преобразования могут быть получены путем вызова Unicode.normalize (s; keywords ...) , где указано любое количество следующих логических параметров ключевых слов (для всех которых по умолчанию установлено значение &lt;code&gt;false&lt;/code&gt; , кроме &lt;code&gt;compose&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="afdfa160e58c5d1c29ca9c36c54e36dba734b5d6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010a2642adb5dc50cd6b75461c8c6c62daaeaa3c" translate="yes" xml:space="preserve">
          <source>Alternatively, for all methods but one you can insist that there is at least one element in the tuple:</source>
          <target state="translated">В качестве альтернативы,для всех методов,кроме одного,можно настоять на том,чтобы в кортеже был хотя бы один элемент:</target>
        </trans-unit>
        <trans-unit id="658838e4feeee97296786aaec18103d8deb93854" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</source>
          <target state="translated">В качестве альтернативы,если вы уже выделили массив,вы можете сгенерировать тонкую обертку вокруг его данных:</target>
        </trans-unit>
        <trans-unit id="09d124820084afee646f363e2b5b6737ae2fc063" translate="yes" xml:space="preserve">
          <source>Alternatively, look at the &lt;code&gt;embedding.c&lt;/code&gt; program in the Julia source tree in the &lt;code&gt;test/embedding/&lt;/code&gt; folder. The file &lt;code&gt;ui/repl.c&lt;/code&gt; program is another simple example of how to set &lt;code&gt;jl_options&lt;/code&gt; options while linking against &lt;code&gt;libjulia&lt;/code&gt;.</source>
          <target state="translated">Или посмотрите программу &lt;code&gt;embedding.c&lt;/code&gt; в дереве исходных текстов Julia в папке &lt;code&gt;test/embedding/&lt;/code&gt; . Программа файла &lt;code&gt;ui/repl.c&lt;/code&gt; - еще один простой пример того, как установить параметры &lt;code&gt;jl_options&lt;/code&gt; при линковке с &lt;code&gt;libjulia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0651e957590c9ae374820826fa54266e498875fb" translate="yes" xml:space="preserve">
          <source>Alternatively, one of the four &quot;normal forms&quot; of the Unicode standard can be specified: &lt;code&gt;normalform&lt;/code&gt; can be &lt;code&gt;:NFC&lt;/code&gt;, &lt;code&gt;:NFD&lt;/code&gt;, &lt;code&gt;:NFKC&lt;/code&gt;, or &lt;code&gt;:NFKD&lt;/code&gt;. Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact. Normal forms KC and KD additionally canonicalize &quot;compatibility equivalents&quot;: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138af7c8699b17e1331dd202694df9508d5db6a5" translate="yes" xml:space="preserve">
          <source>Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</source>
          <target state="translated">Хотя пользователи MATLAB могут найти синтаксис Джулии знакомым,Джулия не является клоном MATLAB.Существуют значительные синтаксические и функциональные различия.Ниже приведены некоторые примечательные различия,которые могут сбить с толку пользователей Julia,привыкших к MATLAB:</target>
        </trans-unit>
        <trans-unit id="995141b8a0f9c91fdda45a6f5368f07495906a19" translate="yes" xml:space="preserve">
          <source>Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:</source>
          <target state="translated">Хотя,как правило,хорошо возвращать полностью инициализированный объект из внутреннего конструктора,можно возвращать и не полностью инициализированные объекты:</target>
        </trans-unit>
        <trans-unit id="37777e78887373deee2eff18df3fa452fb79fe3f" translate="yes" xml:space="preserve">
          <source>Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</source>
          <target state="translated">Хотя это кажется простым понятием,многократная диспетчеризация по типам значений является,пожалуй,самой мощной и центральной особенностью языка Julia.Операции с ядром,как правило,имеют десятки методов:</target>
        </trans-unit>
        <trans-unit id="29da1b638100965fc90d2d714395923c89f62871" translate="yes" xml:space="preserve">
          <source>Although one could, in principle, define methods for the &lt;code&gt;promote&lt;/code&gt; function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of &lt;code&gt;promote&lt;/code&gt; is defined in terms of an auxiliary function called &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt;&lt;code&gt;promote_rule&lt;/code&gt;&lt;/a&gt;, which one can provide methods for. The &lt;code&gt;promote_rule&lt;/code&gt; function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</source>
          <target state="translated">Хотя в принципе можно было бы определять методы для функции &lt;code&gt;promote&lt;/code&gt; напрямую, это потребовало бы множества избыточных определений для всех возможных перестановок типов аргументов. Вместо этого поведение &lt;code&gt;promote&lt;/code&gt; определяется в терминах вспомогательной функции, называемой &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt; &lt;code&gt;promote_rule&lt;/code&gt; &lt;/a&gt; , для которой можно предоставить методы. Функция &lt;code&gt;promote_rule&lt;/code&gt; принимает пару объектов типа и возвращает объект другого типа, так что экземпляры типов аргументов будут повышены до возвращаемого типа. Таким образом, определяя правило:</target>
        </trans-unit>
        <trans-unit id="b980acb1a668eb7b397d3aa918a20ac9dccd65cc" translate="yes" xml:space="preserve">
          <source>Although one sometimes speaks of dynamic languages as being &quot;typeless&quot;, they are definitely not: every object, whether primitive or user-defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can &amp;ndash; and usually must &amp;ndash; annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.</source>
          <target state="translated">Хотя иногда говорят о динамических языках как о &amp;laquo;лишенных типа&amp;raquo;, это определенно не так: каждый объект, будь то примитивный или определяемый пользователем, имеет тип. Однако отсутствие объявлений типов в большинстве динамических языков означает, что нельзя проинструктировать компилятор о типах значений и часто вообще нельзя явно говорить о типах. В статических языках, с другой стороны, хотя можно и обычно необходимо аннотировать типы для компилятора, типы существуют только во время компиляции и не могут быть обработаны или выражены во время выполнения. В Julia типы сами по себе являются объектами времени выполнения и также могут использоваться для передачи информации компилятору.</target>
        </trans-unit>
        <trans-unit id="125f5076dabfcecbce55bdc53934ea25594cddd6" translate="yes" xml:space="preserve">
          <source>Although this seems innocent enough, the problem is that &lt;code&gt;0&lt;/code&gt; is an integer (of type &lt;code&gt;Int&lt;/code&gt;) and &lt;code&gt;x&lt;/code&gt; might be of any type. Thus, depending on the value of &lt;code&gt;x&lt;/code&gt;, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</source>
          <target state="translated">Хотя это кажется достаточно невинным, проблема в том, что &lt;code&gt;0&lt;/code&gt; - целое число (типа &lt;code&gt;Int&lt;/code&gt; ), а &lt;code&gt;x&lt;/code&gt; может быть любого типа. Таким образом, в зависимости от значения &lt;code&gt;x&lt;/code&gt; эта функция может возвращать значение любого из двух типов. Такое поведение разрешено и может быть желательным в некоторых случаях. Но это легко исправить следующим образом:</target>
        </trans-unit>
        <trans-unit id="0ec497a089c99ee5c6f04e61edfbbd31dd8344ae" translate="yes" xml:space="preserve">
          <source>Always gives the opposite answer as &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Всегда дает противоположный ответ: &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4fd498143f69490fe006adbf63236a973c15889" translate="yes" xml:space="preserve">
          <source>Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.</source>
          <target state="translated">Всегда показывайте подпись функции в верхней части документации,с четырехпробным отступом,чтобы она была распечатана как код Julia.</target>
        </trans-unit>
        <trans-unit id="660916a9bd0a5e0c60196e069f980a7e1234e2f9" translate="yes" xml:space="preserve">
          <source>Amalgamation Or Coproduct</source>
          <target state="translated">Амальгамация или продукт</target>
        </trans-unit>
        <trans-unit id="6ed272289e5ab5f2571a80ecd7c9ab3c53aaab06" translate="yes" xml:space="preserve">
          <source>Ambulance</source>
          <target state="translated">Ambulance</target>
        </trans-unit>
        <trans-unit id="6d1fa3121887df24f251a0892c85ff68056930fd" translate="yes" xml:space="preserve">
          <source>American Football</source>
          <target state="translated">американский футбол</target>
        </trans-unit>
        <trans-unit id="f035eead5c54745562ec49798968d1579aa5f09e" translate="yes" xml:space="preserve">
          <source>An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a &lt;code&gt;Serializer&lt;/code&gt; and use it as the first argument to &lt;code&gt;serialize&lt;/code&gt; instead. See also &lt;a href=&quot;#Serialization.writeheader&quot;&gt;&lt;code&gt;Serialization.writeheader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сначала в поток записывается 8-байтовый идентифицирующий заголовок. Чтобы избежать написания заголовка, &lt;code&gt;Serializer&lt;/code&gt; &lt;code&gt;serialize&lt;/code&gt; вместо этого используйте его в качестве первого аргумента для сериализации . См. Также &lt;a href=&quot;#Serialization.writeheader&quot;&gt; &lt;code&gt;Serialization.writeheader&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8eb9358e7cc36217bd2b82eb7c1c39f3757d67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; that allows reading and performs writes by appending. Seeking and truncating are not supported. See &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; for the available constructors. If &lt;code&gt;data&lt;/code&gt; is given, creates a &lt;code&gt;PipeBuffer&lt;/code&gt; to operate on a data vector, optionally specifying a size beyond which the underlying &lt;code&gt;Array&lt;/code&gt; may not be grown.</source>
          <target state="translated">&lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; , что позволяет читать и выполняет пишет, присоединяя. Поиск и усечение не поддерживаются. См. Доступные конструкторы в &lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;data&lt;/code&gt; заданы, создает &lt;code&gt;PipeBuffer&lt;/code&gt; для работы с вектором данных, при необходимости указывая размер, за пределами которого базовый &lt;code&gt;Array&lt;/code&gt; не может быть увеличен .</target>
        </trans-unit>
        <trans-unit id="46a38d582619a610af47f792a125ea49f7521df6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; is raised if all workers cannot be terminated before the requested &lt;code&gt;waitfor&lt;/code&gt; seconds.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; повышается , если все работники не могут быть прекращены до запрошенного &lt;code&gt;waitfor&lt;/code&gt; секунд.</target>
        </trans-unit>
        <trans-unit id="1bb56954c25d718243d7106afdb56cc9d480c633" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AbstractRange&lt;/code&gt; giving the indices of the &lt;code&gt;k&lt;/code&gt;th diagonal of the matrix &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AbstractRange&lt;/code&gt; давая индексы &lt;code&gt;k&lt;/code&gt; - й диагонали матрицы &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213f54bf4207eca3291be6421983a526dc7b3d7a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; отбрасывается , если &lt;code&gt;itr&lt;/code&gt; содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения. Используйте &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; функцию , чтобы опустить &lt;code&gt;missing&lt;/code&gt; записи и вычисление квантилей , не являющихся пропущенными значений.</target>
        </trans-unit>
        <trans-unit id="6168a5d96f0d40b398487557f6a06e26763f063a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; отбрасывается , если &lt;code&gt;v&lt;/code&gt; содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения.</target>
        </trans-unit>
        <trans-unit id="273b5060458d33a00226d8a4b324524243edaee5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0265152d952d723c42ab1da85aac224914443f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;N&lt;/code&gt; dimensional &lt;em&gt;strided&lt;/em&gt; array with elements of type &lt;code&gt;T&lt;/code&gt;. These arrays follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array interface&lt;/a&gt;. If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; мерный &lt;em&gt;strided&lt;/em&gt; массив с элементами типа &lt;code&gt;T&lt;/code&gt; . Эти массивы следуют &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;интерфейсу&lt;/a&gt; с полосатым массивом . Если &lt;code&gt;A&lt;/code&gt; - &lt;code&gt;StridedArray&lt;/code&gt; , то его элементы хранятся в памяти со смещениями, которые могут варьироваться в зависимости от измерения, но являются постоянными в пределах измерения. Например, &lt;code&gt;A&lt;/code&gt; может иметь шаг 2 в измерении 1 и шаг 3 в измерении 2. При увеличении &lt;code&gt;A&lt;/code&gt; по измерению &lt;code&gt;d&lt;/code&gt; происходит скачок в памяти на [ &lt;code&gt;strides(A, d)&lt;/code&gt; ] слотов. Массивы с штриховкой особенно важны и полезны, потому что иногда их можно передавать напрямую как указатели на библиотеки иностранного языка, такие как BLAS.</target>
        </trans-unit>
        <trans-unit id="aa4010002940515c72a60f1328742b5780fa5172" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;NTuple&lt;/code&gt; of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt;s used to represent the dimensions of an &lt;a href=&quot;#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NTuple&lt;/code&gt; из &lt;code&gt;N&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; ы используется для представления размеров в &lt;a href=&quot;#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86ab7a7129a70bb02730939dd401c0c0cf3528b7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;environment&lt;/em&gt; determines what &lt;code&gt;import X&lt;/code&gt; and &lt;code&gt;using X&lt;/code&gt; mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:</source>
          <target state="translated">&lt;em&gt;Среда&lt;/em&gt; определяет то , что &lt;code&gt;import X&lt;/code&gt; и с &lt;code&gt;using X&lt;/code&gt; означает в различных кодовых контексты и какие файлы эти заявления вызывают к загрузке. Джулия понимает два типа окружения:</target>
        </trans-unit>
        <trans-unit id="d4692c48e17766970146c81604672bba8f6ba8a0" translate="yes" xml:space="preserve">
          <source>An HTML renderer would display this as: &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0</source>
          <target state="translated">Средство визуализации HTML отобразит это как: Комплексное число &lt;code&gt;Polar{Float64}&lt;/code&gt; : 3,0</target>
        </trans-unit>
        <trans-unit id="f5d640fb430f989eb8d86d4a923189e2c2ab6f36" translate="yes" xml:space="preserve">
          <source>An action signature (e.g. for committers, taggers, etc). Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Подпись действия (например, для коммиттеров, тегеров и т. Д.). Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="831ca4165fd1236bfdc4d70ab9d199abd7cc83b7" translate="yes" xml:space="preserve">
          <source>An advanced example</source>
          <target state="translated">Продвинутый пример</target>
        </trans-unit>
        <trans-unit id="d38eace5e9dd251808391417899bd07eb120ad72" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;Vector{StackFrame}&lt;/code&gt; provided for convenience; returned by calls to &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;Vector{StackFrame}&lt;/code&gt; предоставлен для удобства; возвращается вызовами &lt;code&gt;stacktrace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90783e8e994e5b4a2ae87f94a62cbca8637e0361" translate="yes" xml:space="preserve">
          <source>An alternative is to create a &quot;view&quot; of the array, which is an array object (a &lt;code&gt;SubArray&lt;/code&gt;) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt;&lt;code&gt;view&lt;/code&gt;&lt;/a&gt;, or more simply for a whole expression or block of code by putting &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; in front of that expression. For example:</source>
          <target state="translated">Альтернативой является создание &amp;laquo;представления&amp;raquo; массива, которое представляет собой объект массива ( &lt;code&gt;SubArray&lt;/code&gt; ), который фактически ссылается на данные исходного массива на месте, без создания копии. (Если вы пишете в представление, оно также изменяет данные исходного массива.) Это можно сделать для отдельных срезов, вызвав &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt; &lt;code&gt;view&lt;/code&gt; &lt;/a&gt; , или, проще говоря, для всего выражения или блока кода, поместив &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt; перед этим выражением. Например:</target>
        </trans-unit>
        <trans-unit id="885d0eebcc9f4c68f23331045091c9a5f90ade43" translate="yes" xml:space="preserve">
          <source>An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab&amp;trade; does:</source>
          <target state="translated">Альтернативой использованию гибридных целых чисел или продвижению в BigInts является использование насыщающей целочисленной арифметики, когда добавление к наибольшему целочисленному значению оставляет его неизменным, а также для вычитания из наименьшего целочисленного значения. Именно это делает Matlab &amp;trade;:</target>
        </trans-unit>
        <trans-unit id="91592a446374cc055177971cd79c3aca7e004b7f" translate="yes" xml:space="preserve">
          <source>An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from &lt;code&gt;@name [a b] * v&lt;/code&gt;):</source>
          <target state="translated">Альтернативный способ вызвать макрос над литералом массива (или пониманием) - это сопоставить оба без использования скобок. В этом случае массив будет единственным выражением, загружаемым в макрос. Следующий синтаксис эквивалентен (и отличается от &lt;code&gt;@name [a b] * v&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f03a7e8903dd9860d01fd9cd12eaf55e1fc8996a" translate="yes" xml:space="preserve">
          <source>An analogous &quot;type-stability&quot; problem exists for variables used repeatedly within a function:</source>
          <target state="translated">Аналогичная проблема &quot;тип-стабильность&quot; существует для переменных,многократно используемых внутри функции:</target>
        </trans-unit>
        <trans-unit id="743741f9ed42719bff5265ccfe550c12e7459fce" translate="yes" xml:space="preserve">
          <source>An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; is passed, or to a branch head described using &lt;code&gt;GitReference&lt;/code&gt;.</source>
          <target state="translated">Аннотированный коммит git содержит информацию о том, как он был найден и почему, так что операции перебазирования или слияния имеют больше информации о контексте коммита. Файлы конфликтов содержат информацию, например, об исходной / целевой ветвях в слиянии, которые конфликтуют. Аннотированная фиксация может относиться к концу удаленной ветки, например, когда &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; , или к &lt;code&gt;GitReference&lt;/code&gt; ветки, описанному с помощью GitReference .</target>
        </trans-unit>
        <trans-unit id="0977e50dcc26db8fee5c84903315951fecb439bb" translate="yes" xml:space="preserve">
          <source>An anonymous function accepting multiple arguments can be written using the syntax &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt;. A zero-argument anonymous function is written as &lt;code&gt;()-&amp;gt;3&lt;/code&gt;. The idea of a function with no arguments may seem strange, but is useful for &quot;delaying&quot; a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Анонимная функция, принимающая несколько аргументов, может быть написана с использованием синтаксиса &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt; . Анонимная функция без аргументов записывается как &lt;code&gt;()-&amp;gt;3&lt;/code&gt; . Идея функции без аргументов может показаться странной, но она полезна для &amp;laquo;задержки&amp;raquo; вычислений. В этом случае блок кода заключен в функцию с нулевым аргументом, которая позже вызывается, вызывая ее как &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="670132e18df0dbda4c7927cbfa1f5f772c1b879a" translate="yes" xml:space="preserve">
          <source>An array allowing for &lt;code&gt;missing&lt;/code&gt; values but which does not contain any such value can be converted back to an array which does not allow for missing values using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;. If the array contains &lt;code&gt;missing&lt;/code&gt; values, a &lt;code&gt;MethodError&lt;/code&gt; is thrown during conversion</source>
          <target state="translated">Массив, допускающий &lt;code&gt;missing&lt;/code&gt; значения, но не содержащий таких значений, может быть преобразован обратно в массив, который не допускает пропущенных значений с помощью &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; . Если массив содержит &lt;code&gt;missing&lt;/code&gt; значения, во время преобразования &lt;code&gt;MethodError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1aa345a94617c2935e2b045aa7c4690942cd7adb" translate="yes" xml:space="preserve">
          <source>An array is &quot;strided&quot; if it is stored in memory with well-defined spacings (strides) between its elements. A strided array with a supported element type may be passed to an external (non-Julia) library like BLAS or LAPACK by simply passing its &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt; and the stride for each dimension. The &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A, d)&lt;/code&gt;&lt;/a&gt; is the distance between elements along dimension &lt;code&gt;d&lt;/code&gt;. For example, the builtin &lt;code&gt;Array&lt;/code&gt; returned by &lt;code&gt;rand(5,7,2)&lt;/code&gt; has its elements arranged contiguously in column major order. This means that the stride of the first dimension &amp;mdash; the spacing between elements in the same column &amp;mdash; is &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ac00a0bf9a5b610ef1696b9ce7b1bd86b26f82" translate="yes" xml:space="preserve">
          <source>An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;. For most computational purposes, arrays should contain objects of a more specific type, such as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Массив - это набор объектов, хранящихся в многомерной сетке. В самом общем случае массив может содержать объекты типа &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; . Для большинства вычислительных целей массивы должны содержать объекты более определенного типа, например &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ca0d5271db66618f81cc70b668cef389e0b4f2d" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe522b01ac3a23b4adab253f39d747e24150892" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="translated">Массив путей для операторов &lt;code&gt;using&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; , рассматриваемых как среды проекта или каталоги пакетов при загрузке кода. Он заполняется на &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt; &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; &lt;/a&gt; переменной среды JULIA_LOAD_PATH, если она установлена; в противном случае по умолчанию используется &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; . Записи, начинающиеся с &lt;code&gt;@&lt;/code&gt; , имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="cfcaca5094f1a9b10cd4725d7c73753c4f7c3e54" translate="yes" xml:space="preserve">
          <source>An array of scalar indices. This includes:</source>
          <target state="translated">Массив скалярных индексов.Это включает в себя:</target>
        </trans-unit>
        <trans-unit id="81e3e729218c7a16f9993c281c977ad17183e8f6" translate="yes" xml:space="preserve">
          <source>An array of the command line arguments passed to Julia, as strings.</source>
          <target state="translated">Массив аргументов командной строки,переданных Джулии,в виде строк.</target>
        </trans-unit>
        <trans-unit id="a0af30d315d1e58152feb3e6efd0b431012c6b41" translate="yes" xml:space="preserve">
          <source>An array with a specific element type can be constructed using the syntax &lt;code&gt;T[A, B, C, ...]&lt;/code&gt;. This will construct a 1-d array with element type &lt;code&gt;T&lt;/code&gt;, initialized to contain elements &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, etc. For example, &lt;code&gt;Any[x, y, z]&lt;/code&gt; constructs a heterogeneous array that can contain any values.</source>
          <target state="translated">Массив с определенным типом элемента может быть построен с использованием синтаксиса &lt;code&gt;T[A, B, C, ...]&lt;/code&gt; . Это создаст 1-мерный массив с типом элемента &lt;code&gt;T&lt;/code&gt; , инициализированный для содержания элементов &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; и т. Д. Например, &lt;code&gt;Any[x, y, z]&lt;/code&gt; создает гетерогенный массив, который может содержать любые значения.</target>
        </trans-unit>
        <trans-unit id="d49e95020e020a9b4ba7b0d2bd91635b96ade391" translate="yes" xml:space="preserve">
          <source>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</source>
          <target state="translated">Утверждение может быть отключено на различных уровнях оптимизации.Поэтому assert должен использоваться только как отладочный инструмент и не должен использоваться для проверки подлинности (например,для верификации паролей),а также не должен использовать внутри assert побочные эффекты,необходимые для корректной работы функции.</target>
        </trans-unit>
        <trans-unit id="71e89ce9e3702ca0f3496a7358d3f83d3e141bca" translate="yes" xml:space="preserve">
          <source>An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:</source>
          <target state="translated">Присвоение,вводящее переменную,используемую внутри функции,типа или определения макроса,не обязательно должно предшествовать ее внутреннему использованию:</target>
        </trans-unit>
        <trans-unit id="d60802623cdaa53cdbcd142bd02b31e05d1a86f4" translate="yes" xml:space="preserve">
          <source>An easy way to find out is to extract the body into another (regular) function:</source>
          <target state="translated">Легкий способ выяснить это-извлечь организм в другую (регулярную)функцию:</target>
        </trans-unit>
        <trans-unit id="1b60a8e096bfa335613b61303e86087f18cd47ed" translate="yes" xml:space="preserve">
          <source>An entirely independent approach to profile visualization is &lt;a href=&quot;https://github.com/vchuravy/PProf.jl&quot;&gt;PProf.jl&lt;/a&gt;, which uses the external &lt;code&gt;pprof&lt;/code&gt; tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ba7cfd59f985e2f5eac9d9bfbe0747c5db6475" translate="yes" xml:space="preserve">
          <source>An environment's graph is a multilevel map which assigns, for each &lt;code&gt;context&lt;/code&gt; UUID, a map from names to UUIDs, similar to the roots map but specific to that &lt;code&gt;context&lt;/code&gt;. When Julia sees &lt;code&gt;import X&lt;/code&gt; in the code of the package whose UUID is &lt;code&gt;context&lt;/code&gt;, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;graph[context][:X]&lt;/code&gt;. In particular, this means that &lt;code&gt;import X&lt;/code&gt; can refer to different packages depending on &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">Граф среды - это многоуровневая карта, которая назначает для каждого UUID &lt;code&gt;context&lt;/code&gt; карту от имен к UUID, аналогичную карте корней, но специфичную для этого &lt;code&gt;context&lt;/code&gt; . Когда Джулия видит &lt;code&gt;import X&lt;/code&gt; в коде пакета, UUID которого является &lt;code&gt;context&lt;/code&gt; , он ищет идентификатор &lt;code&gt;X&lt;/code&gt; как &lt;code&gt;graph[context][:X]&lt;/code&gt; . В частности, это означает, что &lt;code&gt;import X&lt;/code&gt; может ссылаться на разные пакеты в зависимости от &lt;code&gt;context&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e064b0051e803a86c003daf19461cf607e832da" translate="yes" xml:space="preserve">
          <source>An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in &lt;code&gt;Main&lt;/code&gt;). When Julia encounters &lt;code&gt;import X&lt;/code&gt; in the main project, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;roots[:X]&lt;/code&gt;.</source>
          <target state="translated">Карта корней среды присваивает имена пакетов UUID для всех зависимостей верхнего уровня, которые среда делает доступными для основного проекта (т. Е. Тех, которые могут быть загружены в &lt;code&gt;Main&lt;/code&gt; ). Когда Джулия встречает &lt;code&gt;import X&lt;/code&gt; в основном проекте, она ищет идентификатор &lt;code&gt;X&lt;/code&gt; как &lt;code&gt;roots[:X]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a6b075a0dfee676c2586ba796e8721ea7d846f5" translate="yes" xml:space="preserve">
          <source>An error occurred when running a module's &lt;code&gt;__init__&lt;/code&gt; function. The actual error thrown is available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">Произошла ошибка при запуске функции &lt;code&gt;__init__&lt;/code&gt; модуля . Фактическая ошибка доступна в поле &lt;code&gt;.error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f872e576e1623149d829361d58e2cd908722e2d7" translate="yes" xml:space="preserve">
          <source>An error occurred when trying to access &lt;code&gt;str&lt;/code&gt; at index &lt;code&gt;i&lt;/code&gt; that is not valid.</source>
          <target state="translated">Произошла ошибка при попытке доступа к &lt;code&gt;str&lt;/code&gt; по &lt;code&gt;i&lt;/code&gt; индексу i .</target>
        </trans-unit>
        <trans-unit id="f33bd5b60514925c67cf1bcd27c0b818d1eaa51d" translate="yes" xml:space="preserve">
          <source>An error occurred while &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;ing, &lt;a href=&quot;#Base.require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;ing, or &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; a file. The error specifics should be available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">Произошла ошибка при &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; файла. Сведения об ошибке должны быть доступны в поле &lt;code&gt;.error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07364c5431123506298c1f1b97819a8211a7dee0" translate="yes" xml:space="preserve">
          <source>An example of correct usage of &lt;code&gt;Val&lt;/code&gt; would be:</source>
          <target state="translated">Пример правильного использования &lt;code&gt;Val&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25c5e7a2c4027183bf26e4e9c2615052f9de37e7" translate="yes" xml:space="preserve">
          <source>An example of overflow behavior and how to potentially resolve it is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c493074be2f87d14f247d6f580604d1e79d5ee3a" translate="yes" xml:space="preserve">
          <source>An exception is raised if a global constant is requested to be cleared.</source>
          <target state="translated">Исключение делается в том случае,если требуется очистить глобальную константу.</target>
        </trans-unit>
        <trans-unit id="74b831638ce2bece413802b1ce5999bdb817b935" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;global&lt;/code&gt; is needed to assign to a global variable:</source>
          <target state="translated">Явный &lt;code&gt;global&lt;/code&gt; необходим для присвоения глобальной переменной:</target>
        </trans-unit>
        <trans-unit id="fa929fb7568ac9e14759cbe89ba07ba8ca4d3c90" translate="yes" xml:space="preserve">
          <source>An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.</source>
          <target state="translated">Выражение,обернутое таким образом,оставляется макрорасширителем и просто вставляется в выходной файл дословно.Поэтому оно будет разрешено в среде вызова макросов.</target>
        </trans-unit>
        <trans-unit id="4f8ce9f561ef25fa8ebcdf84d21250bf4af4d01b" translate="yes" xml:space="preserve">
          <source>An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</source>
          <target state="translated">Неизменный объект может содержать мутирующие объекты,такие как массивы,например,поля.Содержащиеся в нем объекты останутся мутируемыми;только поля самого неизменяемого объекта не могут быть изменены,чтобы указывать на различные объекты.</target>
        </trans-unit>
        <trans-unit id="a6b2f30177c22471afdf680fdefbc947052099b3" translate="yes" xml:space="preserve">
          <source>An implementation of an &lt;code&gt;AbstractWorkerPool&lt;/code&gt;. &lt;a href=&quot;#Distributed.remote&quot;&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall_fetch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</source>
          <target state="translated">Реализация &lt;code&gt;AbstractWorkerPool&lt;/code&gt; . &lt;a href=&quot;#Distributed.remote&quot;&gt; &lt;code&gt;remote&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall_fetch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; (и другие удаленные вызовы, выполняющие функции удаленно) выигрывают от кэширования сериализованных / десериализованных функций на рабочих узлах, особенно закрытий (которые могут захватывать большие объемы данных).</target>
        </trans-unit>
        <trans-unit id="22b306a470a7687a028d866f374bb4a4513c3bca" translate="yes" xml:space="preserve">
          <source>An implementation of distributed memory parallel computing is provided by module &lt;code&gt;Distributed&lt;/code&gt; as part of the standard library shipped with Julia.</source>
          <target state="translated">Реализация параллельных вычислений с распределенной памятью обеспечивается модулем &lt;code&gt;Distributed&lt;/code&gt; как часть стандартной библиотеки, поставляемой с Julia.</target>
        </trans-unit>
        <trans-unit id="d783ac603cd4b08c0d7cd2a76549bc1da1d2e64a" translate="yes" xml:space="preserve">
          <source>An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types &amp;ndash; one for each possible combination of parameter values. There are many languages that support some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</source>
          <target state="translated">Важной и мощной особенностью системы типов Джулии является то, что она является параметрической: типы могут принимать параметры, так что объявления типов фактически вводят целое семейство новых типов - по одному для каждой возможной комбинации значений параметров. Есть много языков, которые поддерживают некоторую версию &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;общего программирования.&lt;/a&gt;, при этом структуры данных и алгоритмы для управления ими могут быть указаны без указания конкретных задействованных типов. Например, некоторая форма общего программирования существует в ML, Haskell, Ada, Eiffel, C ++, Java, C #, F # и Scala, и это лишь некоторые из них. Некоторые из этих языков поддерживают истинный параметрический полиморфизм (например, ML, Haskell, Scala), в то время как другие поддерживают специальные стили общего программирования на основе шаблонов (например, C ++, Java). Имея так много различных разновидностей общего программирования и параметрических типов на разных языках, мы даже не будем пытаться сравнивать параметрические типы Джулии с другими языками, а вместо этого сосредоточимся на объяснении системы Джулии как таковой. Отметим, однако, что, поскольку Julia - это язык с динамической типизацией, которому не нужно принимать все решения о типе во время компиляции,со многими традиционными трудностями, встречающимися в статических системах параметрического типа, можно относительно легко справиться.</target>
        </trans-unit>
        <trans-unit id="cbe22d7af0ef7feda8cfd84ded555dd181a687db" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-abstract-container&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a620af1ece25f934c185b8ddc35721eeb3f3fac2" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="translated">Важно отметить, что нет потери в производительности, если программист полагается на функцию, аргументы которой являются абстрактными типами, потому что она перекомпилируется для каждого кортежа конкретных типов аргументов, с которыми она вызывается. (Однако может возникнуть проблема с производительностью в случае аргументов функции, которые являются контейнерами абстрактных типов; см. &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Советы по производительности&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a9c84445e53230deb0eebf338b52d84f7d83ccf2" translate="yes" xml:space="preserve">
          <source>An important property of this design is that any code that executes in a file without a warning will behave the same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to file, if it behaves differently than it did in the REPL, then you will get a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a07f992d12e5a1cbc667f425042e464cb426b62" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that, once fetched, a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; will cache its value locally. Further &lt;code&gt;fetch&lt;/code&gt; calls do not entail a network hop. Once all referencing &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s have fetched, the remote stored value is deleted.</source>
          <target state="translated">Важно помнить, что после получения &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; кэширует свое значение локально. Дальнейшие вызовы &lt;code&gt;fetch&lt;/code&gt; не влекут за собой сетевых переходов. После того, как будут получены все ссылки &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; , удаленное сохраненное значение удаляется.</target>
        </trans-unit>
        <trans-unit id="4b9125cf95c1847e0bf4f4e8c480c3ff78274eac" translate="yes" xml:space="preserve">
          <source>An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</source>
          <target state="translated">Важным использованием абстрактных типов является предоставление реализаций по умолчанию для конкретных типов.Чтобы привести простой пример,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="46c08a285690627fd53df02bea8440f31cc7ca2d" translate="yes" xml:space="preserve">
          <source>An indexing operation into an &lt;code&gt;AbstractDict&lt;/code&gt; (&lt;code&gt;Dict&lt;/code&gt;) or &lt;code&gt;Set&lt;/code&gt; like object tried to access or delete a non-existent element.</source>
          <target state="translated">Операция индексации в объект &lt;code&gt;AbstractDict&lt;/code&gt; ( &lt;code&gt;Dict&lt;/code&gt; ) или &lt;code&gt;Set&lt;/code&gt; , подобный объекту, попыталась получить доступ или удалить несуществующий элемент.</target>
        </trans-unit>
        <trans-unit id="c0ef57c4e27de9e0e08cd005dba316af8fe9863a" translate="yes" xml:space="preserve">
          <source>An indexing operation into an array, &lt;code&gt;a&lt;/code&gt;, tried to access an out-of-bounds element at index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Операция индексации в массиве &lt;code&gt;a&lt;/code&gt; попыталась получить доступ к элементу за пределами диапазона по индексу &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba7dc87158f89283a983f53bb3f993c869462761" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Float64}&lt;/code&gt; can be represented compactly and efficiently as an immediate pair of 64-bit values;</source>
          <target state="translated">Экземпляр &lt;code&gt;Point{Float64}&lt;/code&gt; можно компактно и эффективно представить как непосредственную пару 64-битных значений;</target>
        </trans-unit>
        <trans-unit id="81188cb690cdf51aa857fee109d4a9ecc33db0cb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be able to hold any pair of instances of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;. Since objects that are instances of &lt;code&gt;Real&lt;/code&gt; can be of arbitrary size and structure, in practice an instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be represented as a pair of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects.</source>
          <target state="translated">Экземпляр &lt;code&gt;Point{Real}&lt;/code&gt; должен иметь возможность содержать любую пару экземпляров &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; . Поскольку объекты, являющиеся экземплярами &lt;code&gt;Real&lt;/code&gt; , могут иметь произвольный размер и структуру, на практике экземпляр &lt;code&gt;Point{Real}&lt;/code&gt; должен быть представлен как пара указателей на индивидуально выделенные объекты &lt;code&gt;Real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12aa0088bc6a62b5d720f6445639bc7feea0dfd4" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49ef831f7376a07158e43b82f759fbd73bc08a0" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="translated">Проблема, которая возникает в более сложных макросах, - это проблема &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;гигиены&lt;/a&gt; . Короче говоря, макросы должны гарантировать, что переменные, которые они вводят в возвращаемых выражениях, случайно не конфликтуют с существующими переменными в окружающем коде, в который они расширяются. И наоборот, выражения, которые передаются в макрос в качестве аргументов, часто &lt;em&gt;ожидаются.&lt;/em&gt;для оценки в контексте окружающего кода, взаимодействуя с существующими переменными и изменяя их. Другая проблема возникает из-за того, что макрос может вызываться в другом модуле, отличном от того, в котором он был определен. В этом случае нам нужно убедиться, что все глобальные переменные разрешены в правильный модуль. У Джулии уже есть большое преимущество перед языками с текстовым расширением макросов (например, C) в том, что ей нужно учитывать только возвращаемое выражение. Все другие переменные (например, &lt;code&gt;msg&lt;/code&gt; в &lt;code&gt;@assert&lt;/code&gt; выше) следуют &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;обычному поведению блока области видимости&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5758b288cd7216deea6832521aad4c2142aa23b0" translate="yes" xml:space="preserve">
          <source>An iterator that accesses each element of the array &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;i =&amp;gt; x&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index for the element and &lt;code&gt;x = A[i]&lt;/code&gt;. Identical to &lt;code&gt;pairs(A)&lt;/code&gt;, except that the style of index can be selected. Also similar to &lt;code&gt;enumerate(A)&lt;/code&gt;, except &lt;code&gt;i&lt;/code&gt; will be a valid index for &lt;code&gt;A&lt;/code&gt;, while &lt;code&gt;enumerate&lt;/code&gt; always counts from 1 regardless of the indices of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Итератор, который обращается к каждому элементу массива &lt;code&gt;A&lt;/code&gt; , возвращая &lt;code&gt;i =&amp;gt; x&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - индекс элемента, а &lt;code&gt;x = A[i]&lt;/code&gt; . Идентично &lt;code&gt;pairs(A)&lt;/code&gt; , за исключением того, что можно выбрать стиль индекса. Также похоже на &lt;code&gt;enumerate(A)&lt;/code&gt; , за исключением того, &lt;code&gt;i&lt;/code&gt; будет допустимый индекс для &lt;code&gt;A&lt;/code&gt; , в то время как &lt;code&gt;enumerate&lt;/code&gt; всегда рассчитывает с 1 независимо от показателей &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7a506ba2a82dcb065490fadb0cc0de3162d7501" translate="yes" xml:space="preserve">
          <source>An iterator that counts forever, starting at &lt;code&gt;start&lt;/code&gt; and incrementing by &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">Итератора , который подсчитывает навсегда, начиная с &lt;code&gt;start&lt;/code&gt; и увеличивается на &lt;code&gt;step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48922b72538924c877a99f16d2a1501116dd1387" translate="yes" xml:space="preserve">
          <source>An iterator that cycles through &lt;code&gt;iter&lt;/code&gt; forever. If &lt;code&gt;iter&lt;/code&gt; is empty, so is &lt;code&gt;cycle(iter)&lt;/code&gt;.</source>
          <target state="translated">Итератор, который бесконечно проходит через &lt;code&gt;iter&lt;/code&gt; . Если &lt;code&gt;iter&lt;/code&gt; пуст, &lt;code&gt;cycle(iter)&lt;/code&gt; - тоже .</target>
        </trans-unit>
        <trans-unit id="99ec5bfacc5e607a59f3f0e21acc0539e9b04968" translate="yes" xml:space="preserve">
          <source>An iterator that drops element from &lt;code&gt;iter&lt;/code&gt; as long as predicate &lt;code&gt;pred&lt;/code&gt; is true, afterwards, returns every element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2529486fdd6052d642060ef494ef6207d50e0319" translate="yes" xml:space="preserve">
          <source>An iterator that generates all but the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Итератор, который генерирует все элементы &lt;code&gt;iter&lt;/code&gt; , кроме первых &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="225cd1fc20e6b5e9157d6660f2d5a16cf5eaa208" translate="yes" xml:space="preserve">
          <source>An iterator that generates at most the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Итератор, который генерирует не более первых &lt;code&gt;n&lt;/code&gt; элементов &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d764aa048a3e74537873dd366c614add03dee409" translate="yes" xml:space="preserve">
          <source>An iterator that generates element from &lt;code&gt;iter&lt;/code&gt; as long as predicate &lt;code&gt;pred&lt;/code&gt; is true, afterwards, drops every element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e73058facca13f8b20620aa03238c21f3f77bff" translate="yes" xml:space="preserve">
          <source>An iterator that generates the value &lt;code&gt;x&lt;/code&gt; forever. If &lt;code&gt;n&lt;/code&gt; is specified, generates &lt;code&gt;x&lt;/code&gt; that many times (equivalent to &lt;code&gt;take(repeated(x), n)&lt;/code&gt;).</source>
          <target state="translated">Итератор, который навсегда генерирует значение &lt;code&gt;x&lt;/code&gt; . Если указано &lt;code&gt;n&lt;/code&gt; , генерирует &lt;code&gt;x&lt;/code&gt; столько раз (эквивалент &lt;code&gt;take(repeated(x), n)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36e9bbba550395bdb9417724cabe5c648e9c151a" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;(i, x)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is a counter starting at 1, and &lt;code&gt;x&lt;/code&gt; is the &lt;code&gt;i&lt;/code&gt;th value from the given iterator. It's useful when you need not only the values &lt;code&gt;x&lt;/code&gt; over which you are iterating, but also the number of iterations so far. Note that &lt;code&gt;i&lt;/code&gt; may not be valid for indexing &lt;code&gt;iter&lt;/code&gt;; it's also possible that &lt;code&gt;x != iter[i]&lt;/code&gt;, if &lt;code&gt;iter&lt;/code&gt; has indices that do not start at 1. See the &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; method if you want to ensure that &lt;code&gt;i&lt;/code&gt; is an index.</source>
          <target state="translated">Итератор, который возвращает &lt;code&gt;(i, x)&lt;/code&gt; где &lt;code&gt;i&lt;/code&gt; - счетчик, начинающийся с 1, а &lt;code&gt;x&lt;/code&gt; - это &lt;code&gt;i&lt;/code&gt; - е значение из данного итератора. Это полезно, когда вам нужны не только значения &lt;code&gt;x&lt;/code&gt; , по которым вы повторяете, но также количество итераций на данный момент. Обратите внимание, что &lt;code&gt;i&lt;/code&gt; может быть недействительным для индексации &lt;code&gt;iter&lt;/code&gt; ; также возможно, что &lt;code&gt;x != iter[i]&lt;/code&gt; , если у &lt;code&gt;iter&lt;/code&gt; есть индексы, которые не начинаются с 1. Если вы хотите убедиться, что &lt;code&gt;i&lt;/code&gt; является индексом, посмотрите метод &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="266c36edd3f7797ff58b1ca95649bcf6b5c4372b" translate="yes" xml:space="preserve">
          <source>An iterator that yields the same elements as &lt;code&gt;iter&lt;/code&gt;, but starting at the given &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">Итератор, который возвращает те же элементы, что и &lt;code&gt;iter&lt;/code&gt; , но начиная с заданного &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5702ee8b32ef9343efe014a1fb61b5e64e3eeb50" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt;, representing an identity matrix of any size.</source>
          <target state="translated">Объект типа &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; , представляющий единичную матрицу любого размера.</target>
        </trans-unit>
        <trans-unit id="71c4c33f82250491a99ad21209540c93bfa32676" translate="yes" xml:space="preserve">
          <source>An object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;. By default this includes:</source>
          <target state="translated">Объект, который представляет собой массив скалярных индексов и может быть преобразован в него с помощью &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt; . По умолчанию это включает:</target>
        </trans-unit>
        <trans-unit id="d4b6750cc125525c2ec2f6b1301138ae1f12a25d" translate="yes" xml:space="preserve">
          <source>An object that safely references data of type &lt;code&gt;T&lt;/code&gt;. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the &lt;code&gt;Ref&lt;/code&gt; itself is referenced.</source>
          <target state="translated">Объект , который безопасно ссылки на данные типа &lt;code&gt;T&lt;/code&gt; . Этот тип гарантированно указывает на допустимую, выделенную Julia память правильного типа. Базовые данные защищены от освобождения сборщиком мусора, пока есть &lt;code&gt;Ref&lt;/code&gt; сам Ref .</target>
        </trans-unit>
        <trans-unit id="89e56b05f03b0a54be4311a52e3844ad08220010" translate="yes" xml:space="preserve">
          <source>An object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.</source>
          <target state="translated">Объект с неизменяемым типом может быть свободно скопирован компилятором,так как его неизменяемость делает невозможным программно отличить исходный объект от копии.</target>
        </trans-unit>
        <trans-unit id="85eb57c0af1152d6c55f74e29c04701d2792e006" translate="yes" xml:space="preserve">
          <source>An operation allocated too much memory for either the system or the garbage collector to handle properly.</source>
          <target state="translated">Операция,на которую выделяется слишком много памяти,чтобы система или сборщик мусора могли справиться с ней надлежащим образом.</target>
        </trans-unit>
        <trans-unit id="51b16b4dd3a608065010ab050f1c044d587e4984" translate="yes" xml:space="preserve">
          <source>An operation tried to write to memory that is read-only.</source>
          <target state="translated">Операция пыталась записать в память,которая доступна только для чтения.</target>
        </trans-unit>
        <trans-unit id="0cdeff47b1133140cdc39aa6281a4193e4a3fd25" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-matrix operations is available</source>
          <target state="translated">Доступен оптимизированный метод матрично-матричных операций</target>
        </trans-unit>
        <trans-unit id="0f3dca7e150e49f15f11e7561b432ec79e089bf1" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-scalar operations is available</source>
          <target state="translated">Доступен оптимизированный метод матрично-скалярных операций.</target>
        </trans-unit>
        <trans-unit id="061f7a534d622ec7d7b76381cb35a581642e8473" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-vector operations is available</source>
          <target state="translated">Доступен оптимизированный метод матрично-векторных операций</target>
        </trans-unit>
        <trans-unit id="1459d918f4690c46e6b424c4fc07b16a81bb1321" translate="yes" xml:space="preserve">
          <source>An optimized method to find all the characteristic values and/or vectors is available</source>
          <target state="translated">Доступен оптимизированный метод поиска всех характерных значений и/или векторов</target>
        </trans-unit>
        <trans-unit id="cf356b7797f09dd430255cabba22e6b669b5778d" translate="yes" xml:space="preserve">
          <source>An optimized method to find the &lt;code&gt;il&lt;/code&gt;th through the &lt;code&gt;ih&lt;/code&gt;th characteristic values are available</source>
          <target state="translated">Доступен оптимизированный метод нахождения значений характеристик с &lt;code&gt;il&lt;/code&gt; - го по &lt;code&gt;ih&lt;/code&gt; - е.</target>
        </trans-unit>
        <trans-unit id="55662dcd806465abd15ea9ee92465cc49d4f4bb3" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic values in the interval [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vh&lt;/code&gt;] is available</source>
          <target state="translated">Доступен оптимизированный метод нахождения характеристических значений в интервале [ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vh&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="06771105d28cfe0fe650b94de200ff6d276e071c" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic vectors corresponding to the characteristic values &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; is available</source>
          <target state="translated">Оптимизирован способ найти собственные векторы , соответствующие характеристических значений &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; доступен</target>
        </trans-unit>
        <trans-unit id="f744563fd636d437613d62cd83f1a88cf9af7cbd" translate="yes" xml:space="preserve">
          <source>An optimized sampler with pre-computed data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a93e7d7160ec681ea6d7e4c04a7926b5ad27e7" translate="yes" xml:space="preserve">
          <source>An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.</source>
          <target state="translated">Заказанный список может начинаться с номера,отличного от номера,как во втором списке вышеприведенного примера,где он пронумерован от пяти.Как и в случае с неупорядоченными списками,упорядоченные списки могут содержать вложенные элементы верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="03ca662d4f2c4b45816c66be6d31e3cf1480577f" translate="yes" xml:space="preserve">
          <source>An unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) that sets the maximum number of threads available to Julia. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">64-разрядное целое число без знака ( &lt;code&gt;uint64_t&lt;/code&gt; ), которое устанавливает максимальное количество потоков, доступных для Julia. Если &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; превышает количество доступных физических ядер ЦП, то количество потоков устанавливается равным количеству ядер. Если &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; не является положительным или не задано, или если количество ядер ЦП не может быть определено с помощью системных вызовов, то количество потоков устанавливается на &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d32b092601fd9ebd2ac1ea5cb15d47455e3d9c4d" translate="yes" xml:space="preserve">
          <source>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</source>
          <target state="translated">Оператор обновления переманивает переменную с левой стороны.В результате тип переменной может измениться.</target>
        </trans-unit>
        <trans-unit id="8f8c77e7404ca30dcccf92c73c985f04a86420e7" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Anchor</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
