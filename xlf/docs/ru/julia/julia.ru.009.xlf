<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="de317509d863583987ae78748b3c0fbd35bb5918" translate="yes" xml:space="preserve">
          <source>It is common to want to create a task and schedule it right away, so the macro &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; is provided for that purpose &amp;ndash;- &lt;code&gt;@async x&lt;/code&gt; is equivalent to &lt;code&gt;schedule(@task x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c8e496514b2a89c93f19599f4b3b4a2fbaa739" translate="yes" xml:space="preserve">
          <source>It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:</source>
          <target state="translated">Удобно иметь возвращаемые захваты в виде массива,чтобы можно было использовать синтаксис деструкции для привязки их к локальным переменным:</target>
        </trans-unit>
        <trans-unit id="d47b317b6ddbcdcb526b152229f01524e725a05a" translate="yes" xml:space="preserve">
          <source>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</source>
          <target state="translated">Крайне важно точно сопоставить объявленный тип C с его декларацией в Джулии.Несоответствие может привести к тому,что код,корректно работающий на одной системе,выйдет из строя или даст неопределенный результат на другой системе.</target>
        </trans-unit>
        <trans-unit id="fed6b1dba676362bbdda7d92763627e5b989669b" translate="yes" xml:space="preserve">
          <source>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</source>
          <target state="translated">Он объявляется внутри блока объявления типа,а не вне его,как обычные методы.</target>
        </trans-unit>
        <trans-unit id="be90e9f486db27a87a15823d4ded324a5b8722df" translate="yes" xml:space="preserve">
          <source>It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</source>
          <target state="translated">Хорошей практикой является предоставление как можно меньшего количества внутренних методов конструктора:только тех,которые явно принимают все аргументы и обеспечивают проверку и преобразование существенных ошибок.Дополнительные удобные методы-конструкторы,поставляющие значения по умолчанию или вспомогательные преобразования,должны быть предоставлены в виде внешних конструкторов,которые вызывают внутренние конструкторы для выполнения тяжелого подъема.Такое разделение,как правило,является вполне естественным.</target>
        </trans-unit>
        <trans-unit id="055af1e6d77e563e261b9cddc84477b0892ca389" translate="yes" xml:space="preserve">
          <source>It is good practice to use such special versions in comparisons (particularly, the trailing &lt;code&gt;-&lt;/code&gt; should always be used on upper bounds unless there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</source>
          <target state="translated">Хорошей практикой является использование таких специальных версий при сравнении (в частности, завершающие &lt;code&gt;-&lt;/code&gt; всегда следует использовать для верхних границ, если нет веской причины не делать этого), но они не должны использоваться в качестве фактического номера версии чего-либо, поскольку они недопустим в семантической схеме управления версиями.</target>
        </trans-unit>
        <trans-unit id="94f57801215f48bd353cec6fcbf15e2489fd5bd7" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the &lt;code&gt;show&lt;/code&gt; function within the macro body:</source>
          <target state="translated">Важно подчеркнуть, что макросы получают свои аргументы в виде выражений, литералов или символов. Один из способов изучить аргументы макроса - вызвать функцию &lt;code&gt;show&lt;/code&gt; в теле макроса:</target>
        </trans-unit>
        <trans-unit id="02a6b6b86295c683044f57772927ffaa28e3765b" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;em&gt;when&lt;/em&gt; an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</source>
          <target state="translated">Важно отметить , что , &lt;em&gt;когда&lt;/em&gt; объект находится на месте сборки мусора зависит от размера объекта и текущего давления памяти в системе.</target>
        </trans-unit>
        <trans-unit id="600388b971e8fe9fe40cf23408b11ce42cda8c10" translate="yes" xml:space="preserve">
          <source>It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the &lt;code&gt;parent&lt;/code&gt; object was just allocated and garbage collection was not run since then. Remember that most &lt;code&gt;jl_...&lt;/code&gt; functions can sometimes invoke garbage collection.</source>
          <target state="translated">Как правило, невозможно предсказать, какие значения будут устаревшими во время выполнения, поэтому барьер записи должен быть вставлен после всех явных сохранений. Одно примечательное исключение - если &lt;code&gt;parent&lt;/code&gt; объект был только что выделен и с тех пор сборка мусора не выполнялась. Помните, что большинство функций &lt;code&gt;jl_...&lt;/code&gt; иногда могут вызывать сборку мусора.</target>
        </trans-unit>
        <trans-unit id="1e58853c75f92756885fe162715552efead15275" translate="yes" xml:space="preserve">
          <source>It is not permitted to modify the value of an immutable type.</source>
          <target state="translated">Не разрешается изменять значение неизменяемого типа.</target>
        </trans-unit>
        <trans-unit id="737fc29ba3e3878487296ae0904e3501ba8b3de3" translate="yes" xml:space="preserve">
          <source>It is not possible to violate the invariants provided by the type's constructors.</source>
          <target state="translated">Невозможно нарушить инварианты,предоставляемые конструкторами типов.</target>
        </trans-unit>
        <trans-unit id="9c82744b33d4a8c920b021b98d324b0dd36c7c0d" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last argument with an ellipsis:</source>
          <target state="translated">Часто бывает удобно иметь возможность записывать функции,принимающие произвольное количество аргументов.Такие функции традиционно называют функциями &quot;varargs&quot;,что в переводе с английского означает &quot;переменное количество аргументов&quot;.Функцию varargs можно определить,следуя за последним аргументом с помощью эллипсиса:</target>
        </trans-unit>
        <trans-unit id="03d37775863d3d8aefef1deee1f9fba7a5cc77f8" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last positional argument with an ellipsis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67322f4620eb4bffc38ad6db6fb50c1b9b16e04a" translate="yes" xml:space="preserve">
          <source>It is often convenient to work with data structures that may contain values of any type (arrays of type &lt;code&gt;Array{Any}&lt;/code&gt;). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</source>
          <target state="translated">Часто бывает удобно работать со структурами данных, которые могут содержать значения любого типа (массивы типа &lt;code&gt;Array{Any}&lt;/code&gt; ). Но, если вы используете одну из этих структур и знаете тип элемента, это поможет поделиться этими знаниями с компилятором:</target>
        </trans-unit>
        <trans-unit id="096c719abfea35b0b455d36ba64fc9420aa68bfd" translate="yes" xml:space="preserve">
          <source>It is often possible to provide sensible default values for function arguments. This can save users from having to pass every argument on every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4293de250d5dd5832be57fecdaa6e0a3c7af489c" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284677cc407d046b65013c8fed718805f3d17cb7" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">Можно ограничить количество значений, передаваемых в качестве аргумента переменной; это будет обсуждаться позже в &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;методах Varargs с параметрическими ограничениями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a70320747de27e26b4b70f213eeadabc7679b96a" translate="yes" xml:space="preserve">
          <source>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</source>
          <target state="translated">Можно определить набор методов функций таким образом,чтобы не было уникального наиболее специфического метода,применимого к некоторым комбинациям аргументов:</target>
        </trans-unit>
        <trans-unit id="637c214ddc147146d30043be14f7af002a6afb37" translate="yes" xml:space="preserve">
          <source>It is possible to make use of metaprogramming to assist in the creation of documentation. When using string-interpolation within the docstring you will need to use an extra &lt;code&gt;$&lt;/code&gt; as shown with &lt;code&gt;$($name)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deea519c4200e4fe336ac8810c406887e0570f07" translate="yes" xml:space="preserve">
          <source>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</source>
          <target state="translated">Можно передавать функции Юлии родным функциям C,которые принимают аргументы-поинтервалы функций.Например,чтобы соответствовать прототипам формы на C:</target>
        </trans-unit>
        <trans-unit id="b862a89ec67717dcb808d8174cdd3cd9cf5de933" translate="yes" xml:space="preserve">
          <source>It is possible to write definitions like the following:</source>
          <target state="translated">Можно написать такие определения,как следующие:</target>
        </trans-unit>
        <trans-unit id="079123703d5fe6500844bec9cf4fbeb95441a39c" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">Рекомендуется, чтобы подтипы &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; переопределяли следующую сигнатуру метода для обеспечения более эффективных реализаций: &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4972fa162a33587e78213cfd46e68a922aa11ce5" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">Рекомендуется, чтобы подтипы &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; переопределяли следующую сигнатуру метода для обеспечения более эффективных реализаций: &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e657552abcb773fba2d1c58477efeff3641733f" translate="yes" xml:space="preserve">
          <source>It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</source>
          <target state="translated">Рекомендуется сначала определить метод дезагрегирования,так как в противном случае неоднозначность существует,если она существует временами,до тех пор,пока не будет определен более конкретный метод.</target>
        </trans-unit>
        <trans-unit id="3205262d1b20d05a3ec0c7f09158500e89b8710e" translate="yes" xml:space="preserve">
          <source>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</source>
          <target state="translated">Безопасно выполнять итерации в произвольном порядке или в перекрывающемся,с особым учетом восстановительных переменных.</target>
        </trans-unit>
        <trans-unit id="d10887452da1b7a8299e792daec58426383fc305" translate="yes" xml:space="preserve">
          <source>It is significant that like &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, the expressions before and after the &lt;code&gt;:&lt;/code&gt; are only evaluated if the condition expression evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively:</source>
          <target state="translated">Важно отметить, что, как и &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; , выражения до и после &lt;code&gt;:&lt;/code&gt; оцениваются только в том случае, если выражение условия оценивается как &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , соответственно:</target>
        </trans-unit>
        <trans-unit id="6b7dd92481471c3be503cbed8b0ada7bae73d043" translate="yes" xml:space="preserve">
          <source>It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way. The former operation requires division &amp;mdash; a very costly operation &amp;mdash; whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an &lt;code&gt;IndexCartesian&lt;/code&gt; array than it is to use Cartesian indexing with an &lt;code&gt;IndexLinear&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6abc534e54f65480aad0f619aee6267faddc4174" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient to terminate the repetition of a &lt;code&gt;while&lt;/code&gt; before the test condition is falsified or stop iterating in a &lt;code&gt;for&lt;/code&gt; loop before the end of the iterable object is reached. This can be accomplished with the &lt;code&gt;break&lt;/code&gt; keyword:</source>
          <target state="translated">Иногда бывает удобно прервать повторение за некоторое &lt;code&gt;while&lt;/code&gt; до того, как условие теста будет фальсифицировано, или прекратить итерацию в цикле &lt;code&gt;for&lt;/code&gt; до достижения конца итеративного объекта. Это можно сделать с помощью ключевого слова &lt;code&gt;break&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="20dfcec28a6dd8951f574998a3986a215e74fce8" translate="yes" xml:space="preserve">
          <source>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; enables you to toggle module precompilation on and off. When Julia is started with &lt;code&gt;--compiled-modules=no&lt;/code&gt; the serialized modules in the compile cache are ignored when loading modules and module dependencies. &lt;code&gt;Base.compilecache&lt;/code&gt; can still be called manually. The state of this command line flag is passed to &lt;code&gt;Pkg.build&lt;/code&gt; to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</source>
          <target state="translated">Иногда во время разработки модуля полезно отключить инкрементную предварительную компиляцию. Флаг командной строки &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; позволяет включать и отключать предварительную компиляцию модуля . Когда Julia запускается с &lt;code&gt;--compiled-modules=no&lt;/code&gt; , сериализованные модули в кэше компиляции игнорируются при загрузке модулей и зависимостей модулей. &lt;code&gt;Base.compilecache&lt;/code&gt; по- прежнему можно вызывать вручную. Состояние этого флага командной строки передается в &lt;code&gt;Pkg.build&lt;/code&gt; , чтобы отключить автоматический запуск предварительной компиляции при установке, обновлении и явной сборке пакетов.</target>
        </trans-unit>
        <trans-unit id="94baf48d740dae1d64cb4dabcdca4ac61d569c1b" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the &lt;code&gt;Libdl&lt;/code&gt; functions to manage the library explicitly, such as:</source>
          <target state="translated">Иногда бывает полезно закрыть (выгрузить) библиотеку, чтобы ее можно было перезагрузить. Например, при разработке кода C для использования с Julia может потребоваться скомпилировать, вызвать код C из Julia, затем закрыть библиотеку, внести изменения, перекомпилировать и загрузить новые изменения. Можно либо перезапустить Джулию, либо использовать функции &lt;code&gt;Libdl&lt;/code&gt; для явного управления библиотекой, например:</target>
        </trans-unit>
        <trans-unit id="32e81dce90195c032e275e55f3bfa20c146074b3" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</source>
          <target state="translated">Иногда бывает полезно выполнять пошаговые двоичные операции с массивами различного размера,например,добавлять вектор в каждый столбец матрицы.Неэффективным способом сделать это было бы повторить вектор до размера матрицы:</target>
        </trans-unit>
        <trans-unit id="58d81677369240f5f99e6de14b72f59ff777800d" translate="yes" xml:space="preserve">
          <source>It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and modifed post the call. In such cases it may be appropriate to store a &lt;code&gt;deepcopy&lt;/code&gt; of the object.</source>
          <target state="translated">Следует отметить, что обычно это не проблема. Это нужно учитывать только в том случае, если объект одновременно хранится локально и изменяется после вызова. В таких случаях может оказаться целесообразным сохранить &lt;code&gt;deepcopy&lt;/code&gt; объекта.</target>
        </trans-unit>
        <trans-unit id="4930241b205d76b9c3d495f83abf296392db54b7" translate="yes" xml:space="preserve">
          <source>It is usually best to avoid capturing references to instances of internal metadata objects such as &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;MethodInstance&lt;/code&gt;, &lt;code&gt;MethodTable&lt;/code&gt;, &lt;code&gt;TypeMapLevel&lt;/code&gt;, &lt;code&gt;TypeMapEntry&lt;/code&gt; and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</source>
          <target state="translated">Обычно лучше избегать захвата ссылок на экземпляры объектов внутренних метаданных, таких как &lt;code&gt;Method&lt;/code&gt; , &lt;code&gt;MethodInstance&lt;/code&gt; , &lt;code&gt;MethodTable&lt;/code&gt; , &lt;code&gt;TypeMapLevel&lt;/code&gt; , &lt;code&gt;TypeMapEntry&lt;/code&gt; и поля этих объектов, поскольку это может сбить с толку сериализатор и может не привести к желаемому результату. Это не обязательно является ошибкой, но вам просто нужно быть готовым к тому, что система попытается скопировать одни из них и создать единственный уникальный экземпляр других.</target>
        </trans-unit>
        <trans-unit id="b19a6924f8364edbfe868e5511ad36bcb64fff31" translate="yes" xml:space="preserve">
          <source>It is usually not much help to construct arrays like the following:</source>
          <target state="translated">Как правило,построение массивов,как правило,не очень помогает:</target>
        </trans-unit>
        <trans-unit id="e4380a1b0acd2209a89981ccd04cfa0fd834aaba" translate="yes" xml:space="preserve">
          <source>It is very important that the called function does not call back into Julia, as it will segfault.</source>
          <target state="translated">Очень важно,чтобы вызываемая функция не вызывала Юлию,так как она будет сегрегирована.</target>
        </trans-unit>
        <trans-unit id="334c0921872b88ab33e359bc32c0c7cf09fbdeba" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that strides are about offsets in memory rather than indexing. If you are looking to convert between linear (single-index) indexing and cartesian (multi-index) indexing, see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805fdc406fb3dba1fb93a133c29b22878b4c87dc" translate="yes" xml:space="preserve">
          <source>It may take optional keyword arguments:</source>
          <target state="translated">Для этого могут потребоваться необязательные аргументы по ключевым словам:</target>
        </trans-unit>
        <trans-unit id="9d3c85b9245c7315a1b23d4e146f385ddcbfb243" translate="yes" xml:space="preserve">
          <source>It means that the type of the output is predictable from the types of the inputs. In particular, it means that the type of the output cannot vary depending on the &lt;em&gt;values&lt;/em&gt; of the inputs. The following code is &lt;em&gt;not&lt;/em&gt; type-stable:</source>
          <target state="translated">Это означает, что тип выхода предсказуем из типов входов. В частности, это означает, что тип выхода не может меняться в зависимости от &lt;em&gt;значений&lt;/em&gt; входов. Следующий код &lt;em&gt;не&lt;/em&gt; тип-конюшни:</target>
        </trans-unit>
        <trans-unit id="c3b7dcbf1418595d94f20981812341bdb45796ab" translate="yes" xml:space="preserve">
          <source>It only makes sense to take ratios of integer values, so the parameter type &lt;code&gt;T&lt;/code&gt; is restricted to being a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, and a ratio of integers represents a value on the real number line, so any &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; is an instance of the &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; abstraction.</source>
          <target state="translated">Имеет смысл принимать только отношения целочисленных значений, поэтому тип параметра &lt;code&gt;T&lt;/code&gt; ограничен подтипом &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , а отношение целых чисел представляет значение в строке вещественных чисел, поэтому любой &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; является экземпляром абстракции &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a692191dac5658d6e6f21b53ff80758c81d0148d" translate="yes" xml:space="preserve">
          <source>It provides a mutable wrapper around an iterator and its iteration state.</source>
          <target state="translated">Он обеспечивает мутирующую обертку вокруг итератора и его состояние итерации.</target>
        </trans-unit>
        <trans-unit id="1341640325353ec21dd6ae9c9b69ddf97792b73e" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it must be able to cope with values of both types, which makes it hard to produce fast machine code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d07a5f3996139947136e92cd3660ed889424cf" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.</source>
          <target state="translated">Он возвращает либо &lt;code&gt;Int&lt;/code&gt; , либо &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; в&lt;/a&gt; зависимости от значения своего аргумента. Поскольку Джулия не может предсказать тип возвращаемого значения этой функции во время компиляции, любое вычисление, использующее ее, должно будет защищать от возможного возникновения обоих типов, что затрудняет создание быстрого машинного кода.</target>
        </trans-unit>
        <trans-unit id="e13bba493365e2c5b2e76f0ae39f91eaa1b27bd1" translate="yes" xml:space="preserve">
          <source>It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the &lt;code&gt;mynorm&lt;/code&gt; example.</source>
          <target state="translated">Однако следует отметить, что компилятор довольно эффективно оптимизирует мертвые ветки в коде, написанном как пример &lt;code&gt;mynorm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="429ea7fe9a07243d9d929909311d0c5286ba8da0" translate="yes" xml:space="preserve">
          <source>It turns an iterator-like abstraction into a &lt;code&gt;Channel&lt;/code&gt;-like abstraction.</source>
          <target state="translated">Он превращает абстракцию, подобную итератору, в абстракцию, подобную &lt;code&gt;Channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85d168e5e85b9af5b4b41b997ebf680755497e13" translate="yes" xml:space="preserve">
          <source>It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):</source>
          <target state="translated">Хорошей идеей будет сначала запустить код,который вы собираетесь профилировать хотя бы один раз (если только вы не хотите профилировать JIT-компилятор Julia):</target>
        </trans-unit>
        <trans-unit id="6aa7c46c7a469a8066f30e0a6330c5f7107a8c6d" translate="yes" xml:space="preserve">
          <source>It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:</source>
          <target state="translated">В самой документации Julia можно добавлять также перекрестные ссылки на другие документированные функции/методы/переменные.Например:</target>
        </trans-unit>
        <trans-unit id="d58241f9f697434c4e06081f155d61314cbdb71e" translate="yes" xml:space="preserve">
          <source>It's an iterator that mutates to become its own rest iterator whenever an item is produced.</source>
          <target state="translated">Это итератор,который мутирует,чтобы стать своим собственным итератором покоя всякий раз,когда изделие производится.</target>
        </trans-unit>
        <trans-unit id="4aa36d32a2c02cf6990c1d5d08f2ca5067ed910f" translate="yes" xml:space="preserve">
          <source>It's easiest to illustrate this with an example. We can declare a generated function &lt;code&gt;foo&lt;/code&gt; as</source>
          <target state="translated">Проще всего это проиллюстрировать на примере. Мы можем объявить сгенерированную функцию &lt;code&gt;foo&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="7ecf0f0b27cffd70c113f40a095f8c8f53901430" translate="yes" xml:space="preserve">
          <source>It's far less clear what should happen here. Since &lt;code&gt;x + &quot;hello&quot;&lt;/code&gt; is a method error, it seems probable that the intention is for &lt;code&gt;x&lt;/code&gt; to be local to the &lt;code&gt;for&lt;/code&gt; loop. But runtime values and what methods happen to exist cannot be used to determine the scopes of variables. With the Julia &amp;le; 0.6 behavior, it's especially concerning that someone might have written the &lt;code&gt;for&lt;/code&gt; loop first, had it working just fine, but later when someone else adds a new global far away&amp;mdash;possibly in a different file&amp;mdash;the code suddenly changes meaning and either breaks noisily or, worse still, silently does the wrong thing. This kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)&quot;&gt;&quot;spooky action at a distance&quot;&lt;/a&gt; is something that good programming language designs should prevent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38dda39f4395bbec3e9a522986faf60e028082c7" translate="yes" xml:space="preserve">
          <source>It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;tricky issues&lt;/a&gt; to deal with (though much less so for day-precision types).</source>
          <target state="translated">При использовании любой структуры языка / даты рекомендуется знать, как обрабатывается арифметика даты и периода, поскольку есть некоторые &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;сложные проблемы,&lt;/a&gt; с которыми приходится иметь дело (хотя гораздо меньше для типов с точностью до дня).</target>
        </trans-unit>
        <trans-unit id="0640f8fda4ec7bf5464b3cee97ae0f4dda5ee1e4" translate="yes" xml:space="preserve">
          <source>It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:</source>
          <target state="translated">Важно знать о потенциально опасных ситуациях,таких как конкатенация недействительных строк UTF-8.Полученная строка может содержать символы,отличные от входных строк,а ее количество символов может быть меньше суммы символов конкатенированных строк,например</target>
        </trans-unit>
        <trans-unit id="3dbecc240e8c1b98fcd4c298d9a96ae72e276750" translate="yes" xml:space="preserve">
          <source>It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays &amp;mdash; like &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; itself &amp;mdash; are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays &amp;mdash; like &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; &amp;mdash; need the full set of cartesian indices to do their lookup (see &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt; to introspect which is which). As such, when iterating over an entire array, it's much better to iterate over &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex(A)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;1:length(A)&lt;/code&gt;. Not only will the former be much faster in cases where &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;IndexCartesian&lt;/code&gt;, but it will also support OffsetArrays, too.</source>
          <target state="translated">Важно отметить, что существует очень большая асимметрия в производительности этих преобразований. Преобразование линейного индекса в набор декартовых индексов требует деления и взятия остатка, в то время как другой путь - просто умножение и добавление. В современных процессорах целочисленное деление может быть в 10-50 раз медленнее, чем умножение. В то время как некоторые массивы - например, сам &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; - реализованы с использованием линейного фрагмента памяти и напрямую используют линейный индекс в своих реализациях, другим массивам, таким как &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; ,&lt;/a&gt; нужен полный набор декартовых индексов для поиска (см. &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt; для интроспекции, которая является который). Таким образом, при итерации по всему массиву гораздо лучше перебирать &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex(A)&lt;/code&gt; &lt;/a&gt; вместо &lt;code&gt;1:length(A)&lt;/code&gt; . &lt;code&gt;IndexCartesian&lt;/code&gt; будет не только намного быстрее в случаях, когда &lt;code&gt;A&lt;/code&gt; является IndexCartesian , но также будет поддерживать OffsetArrays.</target>
        </trans-unit>
        <trans-unit id="2ae198b8fe13fc0c80ed5149210f17463c0121d1" translate="yes" xml:space="preserve">
          <source>It's no longer convenient to copy and paste the code from inside a function body into the REPL to debug it&amp;mdash;you have to add &lt;code&gt;global&lt;/code&gt; annotations and then remove them again to go back;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f0c889cfa216f7a561510a3ad57de629360e4b" translate="yes" xml:space="preserve">
          <source>It's now possible to get a sampler with &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt;, and use &lt;code&gt;sp&lt;/code&gt; instead of &lt;code&gt;die&lt;/code&gt; in any &lt;code&gt;rand&lt;/code&gt; call involving &lt;code&gt;rng&lt;/code&gt;. In the simplistic example above, &lt;code&gt;die&lt;/code&gt; doesn't need to be stored in &lt;code&gt;SamplerDie&lt;/code&gt; but this is often the case in practice.</source>
          <target state="translated">Теперь можно получить семплер с помощью &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt; и использовать &lt;code&gt;sp&lt;/code&gt; вместо &lt;code&gt;die&lt;/code&gt; в любом вызове &lt;code&gt;rand&lt;/code&gt; , включающем &lt;code&gt;rng&lt;/code&gt; . В приведенном выше упрощенном примере &lt;code&gt;die&lt;/code&gt; не нужно хранить в &lt;code&gt;SamplerDie&lt;/code&gt; , но на практике так часто бывает.</target>
        </trans-unit>
        <trans-unit id="435e5d30b709899a41a3dc97d975e671346837d6" translate="yes" xml:space="preserve">
          <source>It's quite instructive to compare the sheer amount code generated for a simple function</source>
          <target state="translated">Весьма поучительно сравнить количество кода,сгенерированного для простой функции.</target>
        </trans-unit>
        <trans-unit id="485af6f7d5c0b66af203ac099b1bf7b0eba726ba" translate="yes" xml:space="preserve">
          <source>It's worth emphasizing that &lt;code&gt;localindices&lt;/code&gt; exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a &lt;code&gt;SharedArray&lt;/code&gt;, all indices should be equally fast for each worker process.</source>
          <target state="translated">Стоит подчеркнуть, что &lt;code&gt;localindices&lt;/code&gt; существует исключительно для удобства, и вы можете разделить работу над массивом между рабочими процессами любым способом. Для &lt;code&gt;SharedArray&lt;/code&gt; все индексы должны быть одинаково быстрыми для каждого рабочего процесса.</target>
        </trans-unit>
        <trans-unit id="948d6de7c32c1a31093f07d2e218322318e4b407" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read &lt;a href=&quot;../performance-tips/index#man-performance-value-type&quot;&gt;the more extensive discussion in the performance tips&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5d6404960db7e0b184fd1dfa040fb8f1124932" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read the more extensive discussion in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;the performance tips&lt;/a&gt;.</source>
          <target state="translated">Стоит отметить, что очень легко неправильно использовать параметрические типы &amp;laquo;значения&amp;raquo;, включая &lt;code&gt;Val&lt;/code&gt; ; в неблагоприятных случаях вы легко можете значительно &lt;em&gt;ухудшить&lt;/em&gt; производительность вашего кода . В частности, вы никогда не захотите писать реальный код, как показано выше. Для получения дополнительной информации о правильном (и неправильном) использовании &lt;code&gt;Val&lt;/code&gt; , пожалуйста, прочтите более подробное обсуждение в &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;советах по производительности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b9b0722d0d43e4d14ff92cca723a64b8e24e4f0" translate="yes" xml:space="preserve">
          <source>Italics</source>
          <target state="translated">Italics</target>
        </trans-unit>
        <trans-unit id="c218bb3261ced0b188316d903cb0484a6a43b61a" translate="yes" xml:space="preserve">
          <source>Iterable Collections</source>
          <target state="translated">Масштабные коллекции</target>
        </trans-unit>
        <trans-unit id="81a99e5d5fc07b72d6b1647c497a7c5192f69fad" translate="yes" xml:space="preserve">
          <source>Iterate over a collection &lt;code&gt;n&lt;/code&gt; elements at a time.</source>
          <target state="translated">Перебирать коллекцию &lt;code&gt;n&lt;/code&gt; элементов за раз.</target>
        </trans-unit>
        <trans-unit id="7878c863963cb51356acf7ca3e8ea44be505a483" translate="yes" xml:space="preserve">
          <source>Iterated dispatch</source>
          <target state="translated">итерационная отправка</target>
        </trans-unit>
        <trans-unit id="42206b6c92650b3931037fd07719156176dc0314" translate="yes" xml:space="preserve">
          <source>Iterating over the &lt;code&gt;CartesianIndices&lt;/code&gt; of the &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; and using indexing with the resulting &lt;code&gt;CartesianIndex&lt;/code&gt; object to compute the result.</source>
          <target state="translated">Итерация над &lt;code&gt;CartesianIndices&lt;/code&gt; этих &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; и с помощью индексации с результирующим &lt;code&gt;CartesianIndex&lt;/code&gt; объекта для вычисления результата.</target>
        </trans-unit>
        <trans-unit id="a4979919b853dff1595ccf476a13a01680f6c472" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Q&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, &lt;code&gt;F.&amp;alpha;&lt;/code&gt;, and &lt;code&gt;F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">Итерация разложение производит компоненты &lt;code&gt;F.S&lt;/code&gt; , &lt;code&gt;F.T&lt;/code&gt; , &lt;code&gt;F.Q&lt;/code&gt; , &lt;code&gt;F.Z&lt;/code&gt; , &lt;code&gt;F.&amp;alpha;&lt;/code&gt; и &lt;code&gt;F.&amp;beta;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc67e8a927f1aa6eff5ad47840e758df966f518f" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, and &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">Итерация разложение производит компоненты &lt;code&gt;F.T&lt;/code&gt; , &lt;code&gt;F.Z&lt;/code&gt; , и &lt;code&gt;F.values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4d4ad8d2cf2c1ee9c60ddef640294bbac58cbc2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.values&lt;/code&gt; and &lt;code&gt;F.vectors&lt;/code&gt;.</source>
          <target state="translated">Итерация разложения дает компоненты &lt;code&gt;F.values&lt;/code&gt; и &lt;code&gt;F.vectors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86506020c8187a26d343a03489380c16723ff386" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">Итерация разложения производит компоненты , &lt;code&gt;Q&lt;/code&gt; и &lt;code&gt;R&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eea487785d89d96fdac640a6604fc8fe54c944d" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Итерация разложения дает компоненты &lt;code&gt;Q&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; и &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cab411fc4fe9253bda3d235df40d5dfd6ef9668c" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and if extant &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Итерация разложения дает компоненты &lt;code&gt;Q&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; и, если существует &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3b6360c2464673a0e4fb9b1ed45a041967155d6" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">Итерация декомпозиции дает компоненты &lt;code&gt;S.D&lt;/code&gt; , &lt;code&gt;S.U&lt;/code&gt; или &lt;code&gt;S.L&lt;/code&gt; в зависимости от заданных &lt;code&gt;S.uplo&lt;/code&gt; и &lt;code&gt;S.p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f77bd282f84af7bfe48cdf3c4e7e8dc8c570cc8e" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.L&lt;/code&gt; and &lt;code&gt;S.Q&lt;/code&gt;.</source>
          <target state="translated">Итерация декомпозиции дает компоненты &lt;code&gt;S.L&lt;/code&gt; и &lt;code&gt;S.Q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89ebce396ac9da86f707ddc5cfcf6229ef6143e2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Итерация разложения производит компоненту &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c715668f8440af4b021f6c74fa32fef39d559c06" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;, &lt;code&gt;D2&lt;/code&gt;, and &lt;code&gt;R0&lt;/code&gt;.</source>
          <target state="translated">Итерация разложения дает компоненты &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;Q&lt;/code&gt; , &lt;code&gt;D1&lt;/code&gt; , &lt;code&gt;D2&lt;/code&gt; и &lt;code&gt;R0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58ad8afd3ef50f0b4cdfded417b61d5f6036a1c3" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q, F.H, F.&amp;mu;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09a0a43519ceb489793a2ede6c213029b86bdfc" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q&lt;/code&gt; and &lt;code&gt;F.H&lt;/code&gt;.</source>
          <target state="translated">Итерация разложения дает множители &lt;code&gt;F.Q&lt;/code&gt; и &lt;code&gt;F.H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f58aa126be8fea0928c97cbc1c2e33d08204701b" translate="yes" xml:space="preserve">
          <source>Iterating the factorization produces the components &lt;code&gt;F.L&lt;/code&gt;, &lt;code&gt;F.U&lt;/code&gt;, and &lt;code&gt;F.p&lt;/code&gt;.</source>
          <target state="translated">Итерация факторизации дает компоненты &lt;code&gt;F.L&lt;/code&gt; , &lt;code&gt;F.U&lt;/code&gt; и &lt;code&gt;F.p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca49cf020b23404ede665f3ef9ef58b961aea893" translate="yes" xml:space="preserve">
          <source>Iteration over &lt;code&gt;NamedTuple&lt;/code&gt;s produces the &lt;em&gt;values&lt;/em&gt; without the names. (See example below.) To iterate over the name-value pairs, use the &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; по NamedTuple s дает &lt;em&gt;значения&lt;/em&gt; без имен. (См. Пример ниже.) Для перебора пар имя-значение используйте функцию &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="029d5196356372d794cb53808ecda6f8a64c6198" translate="yes" xml:space="preserve">
          <source>Iteration utilities</source>
          <target state="translated">утилиты для итерации</target>
        </trans-unit>
        <trans-unit id="bc1f336bbebec9ed2484b3179ad56691be7b079d" translate="yes" xml:space="preserve">
          <source>IteratorEltype</source>
          <target state="translated">IteratorEltype</target>
        </trans-unit>
        <trans-unit id="762bcf9ad00a1c98c7dfe72f3f1da300a726ae97" translate="yes" xml:space="preserve">
          <source>IteratorSize</source>
          <target state="translated">IteratorSize</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="ade312c99a3f29ec263e6761dccc45de6d98af27" translate="yes" xml:space="preserve">
          <source>Iterators.Pairs</source>
          <target state="translated">Iterators.Pairs</target>
        </trans-unit>
        <trans-unit id="7f99860914bab93742ec0677d93601e7f754aab7" translate="yes" xml:space="preserve">
          <source>Iterators.Stateful</source>
          <target state="translated">Iterators.Stateful</target>
        </trans-unit>
        <trans-unit id="4b22c43fb78a467e966bea6e6bf82f640caa802a" translate="yes" xml:space="preserve">
          <source>Iterators.countfrom()</source>
          <target state="translated">Iterators.countfrom()</target>
        </trans-unit>
        <trans-unit id="6e9ea1a37868f81f1c387104af3ddce669dd91f6" translate="yes" xml:space="preserve">
          <source>Iterators.cycle()</source>
          <target state="translated">Iterators.cycle()</target>
        </trans-unit>
        <trans-unit id="15fc1b0f962745a0f7d6dddec1a5029f764fddf9" translate="yes" xml:space="preserve">
          <source>Iterators.drop()</source>
          <target state="translated">Iterators.drop()</target>
        </trans-unit>
        <trans-unit id="b622262f6019cdcf33dc40c2166a76e9968c2d6f" translate="yes" xml:space="preserve">
          <source>Iterators.enumerate()</source>
          <target state="translated">Iterators.enumerate()</target>
        </trans-unit>
        <trans-unit id="18c6e2577f1cb3f1df18e8349820ab2df102ed03" translate="yes" xml:space="preserve">
          <source>Iterators.filter()</source>
          <target state="translated">Iterators.filter()</target>
        </trans-unit>
        <trans-unit id="1c4406a3948ea47560dd3a48a99cedb41058481a" translate="yes" xml:space="preserve">
          <source>Iterators.flatten()</source>
          <target state="translated">Iterators.flatten()</target>
        </trans-unit>
        <trans-unit id="e6b2ae68200d1658f8b9b58b1bda15c7a94398ec" translate="yes" xml:space="preserve">
          <source>Iterators.partition()</source>
          <target state="translated">Iterators.partition()</target>
        </trans-unit>
        <trans-unit id="8d055b9ee1bc21393531304979f760c0dcaf8ed7" translate="yes" xml:space="preserve">
          <source>Iterators.product()</source>
          <target state="translated">Iterators.product()</target>
        </trans-unit>
        <trans-unit id="f82f74da2e638549fe42f2abf5e3d47275b9d6dc" translate="yes" xml:space="preserve">
          <source>Iterators.repeated()</source>
          <target state="translated">Iterators.repeated()</target>
        </trans-unit>
        <trans-unit id="d0a4aaf299b047ef88d9088cb3265b8c9ec460f8" translate="yes" xml:space="preserve">
          <source>Iterators.rest()</source>
          <target state="translated">Iterators.rest()</target>
        </trans-unit>
        <trans-unit id="78c5327cecfd4b16a167206d910e94f07f9e5a1d" translate="yes" xml:space="preserve">
          <source>Iterators.reverse()</source>
          <target state="translated">Iterators.reverse()</target>
        </trans-unit>
        <trans-unit id="1780ae66e17e617d0386e7c850f35f9a46563eec" translate="yes" xml:space="preserve">
          <source>Iterators.take()</source>
          <target state="translated">Iterators.take()</target>
        </trans-unit>
        <trans-unit id="38d733610a11317778f298c2adaafc9ed0e772f3" translate="yes" xml:space="preserve">
          <source>Iterators.zip()</source>
          <target state="translated">Iterators.zip()</target>
        </trans-unit>
        <trans-unit id="e5c9811ac9fab746e9ba97b16b953053ef624d64" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndex</source>
          <target state="translated">IteratorsMD.CartesianIndex</target>
        </trans-unit>
        <trans-unit id="dab2cf0daf838d270ad35eb4a74061238bf4a503" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndices</source>
          <target state="translated">IteratorsMD.CartesianIndices</target>
        </trans-unit>
        <trans-unit id="30ab5c44fe067198393909d62c86b0c386a162b7" translate="yes" xml:space="preserve">
          <source>Its second argument &lt;code&gt;args&lt;/code&gt; is an array of &lt;code&gt;jl_value_t*&lt;/code&gt; arguments and &lt;code&gt;nargs&lt;/code&gt; is the number of arguments.</source>
          <target state="translated">Его второй аргумент &lt;code&gt;args&lt;/code&gt; - это массив аргументов &lt;code&gt;jl_value_t*&lt;/code&gt; а &lt;code&gt;nargs&lt;/code&gt; - количество аргументов.</target>
        </trans-unit>
        <trans-unit id="286bb02d594ea15955d87681e8267067be410857" translate="yes" xml:space="preserve">
          <source>Izakaya Lantern</source>
          <target state="translated">Изакая Фонарь</target>
        </trans-unit>
        <trans-unit id="2f5fc08c12a2ccfd9c859b035ca12cb9526ce0af" translate="yes" xml:space="preserve">
          <source>J R Bunch and L Kaufman, Some stable methods for calculating inertia</source>
          <target state="translated">J R Bunch и L Kaufman,Некоторые стабильные методы для вычисления инерции</target>
        </trans-unit>
        <trans-unit id="831fdbe2f742b632acf268054e5932135a416335" translate="yes" xml:space="preserve">
          <source>Jack-O-Lantern</source>
          <target state="translated">Jack-O-Lantern</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="ad6d155a582ef676e9240bfd2300a9eb9553e4f3" translate="yes" xml:space="preserve">
          <source>Japanese Castle</source>
          <target state="translated">Японский замок</target>
        </trans-unit>
        <trans-unit id="ed8bfe0cf71057039bd166fcb8a33ed47c1d1057" translate="yes" xml:space="preserve">
          <source>Japanese Dolls</source>
          <target state="translated">японские куклы</target>
        </trans-unit>
        <trans-unit id="97302784bd85c6fc3ccdcadbac4da292edfbb8ba" translate="yes" xml:space="preserve">
          <source>Japanese Goblin</source>
          <target state="translated">японский гоблин</target>
        </trans-unit>
        <trans-unit id="7263dbff30ade45b8568943da751abb88bf70826" translate="yes" xml:space="preserve">
          <source>Japanese Ogre</source>
          <target state="translated">японец людоед</target>
        </trans-unit>
        <trans-unit id="134fe6f595c84ed345de3ae0637be6654696bcaa" translate="yes" xml:space="preserve">
          <source>Japanese Post Office</source>
          <target state="translated">Почтовое отделение Японии</target>
        </trans-unit>
        <trans-unit id="0239b1f09d4f7c4b093fb50eb113f3c45f2d4d30" translate="yes" xml:space="preserve">
          <source>Japanese Symbol For Beginner</source>
          <target state="translated">Японский символ для новичков</target>
        </trans-unit>
        <trans-unit id="d1e9767d8a0bd6d2bf67011d187d114cce67abb1" translate="yes" xml:space="preserve">
          <source>Jeans</source>
          <target state="translated">Jeans</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="3b3813dad3290588a2d14e75a092fcd63a072388" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter (if any) between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76788f50771e86fe282c9d53f0b06082b3018e7d" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Объедините массив &lt;code&gt;strings&lt;/code&gt; в одну строку, вставив заданный разделитель между соседними строками. Если указано &lt;code&gt;last&lt;/code&gt; , оно будет использоваться вместо &lt;code&gt;delim&lt;/code&gt; между двумя последними строками. Если задано &lt;code&gt;io&lt;/code&gt; , результат записывается в &lt;code&gt;io&lt;/code&gt; , а не возвращается как &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0499501b2bb39022852369c1a09b6f3fb6fc16a6" translate="yes" xml:space="preserve">
          <source>Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn't match the drive computed for the join of the preceding paths, then prior components are dropped.</source>
          <target state="translated">Соедините компоненты пути в полный путь.Если некоторый аргумент является абсолютным или (в Windows)имеет спецификацию диска,не соответствующую диску,вычисленному для объединения предыдущих путей,то предыдущие компоненты отбрасываются.</target>
        </trans-unit>
        <trans-unit id="e64d664b335757ab1b0ed70dc6883a5f412be34b" translate="yes" xml:space="preserve">
          <source>Julia</source>
          <target state="translated">Julia</target>
        </trans-unit>
        <trans-unit id="34915350c4729155e12aa2a18e1437b46a254b8d" translate="yes" xml:space="preserve">
          <source>Julia 1.1</source>
          <target state="translated">Джулия 1.1</target>
        </trans-unit>
        <trans-unit id="20d44d7c210bfc70cdc873c771c707c9f3303af5" translate="yes" xml:space="preserve">
          <source>Julia 1.2</source>
          <target state="translated">Джулия 1.2</target>
        </trans-unit>
        <trans-unit id="8b642007f455f270d5f4ca8eeb353a9cd627fd87" translate="yes" xml:space="preserve">
          <source>Julia 1.2 Documentation</source>
          <target state="translated">Джулия 1.2 Документация</target>
        </trans-unit>
        <trans-unit id="735bc5320f837b1441f2cfffa31dd786468645d6" translate="yes" xml:space="preserve">
          <source>Julia 1.5 Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858ca45563192af10cdc21c94e7d577c6f26612b" translate="yes" xml:space="preserve">
          <source>Julia Base Type</source>
          <target state="translated">Базовый тип Джулии</target>
        </trans-unit>
        <trans-unit id="c3d7a86babfba0e54357fb2d1ed82f5bfe9ac6bf" translate="yes" xml:space="preserve">
          <source>Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages. Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.</source>
          <target state="translated">Julia Base содержит ряд функций и макросов,подходящих для выполнения научных и численных вычислений,но при этом не уступает по широте многим языкам программирования общего назначения.Дополнительные функциональные возможности доступны из растущей коллекции доступных пакетов.Функции сгруппированы по темам ниже.</target>
        </trans-unit>
        <trans-unit id="ecea329751a7da4bad931e777e922977157ad8f8" translate="yes" xml:space="preserve">
          <source>Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;), and others which are just modifying (e.g., &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt;&lt;code&gt;pop!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt;&lt;code&gt;splice!&lt;/code&gt;&lt;/a&gt;). It is typical for such functions to also return the modified array for convenience.</source>
          <target state="translated">Julia Base использует эту конвенцию во всем и содержит примеры функций как с копирования и модифицирующих форм (например, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; ), И другие , которые просто модифицирующие (например, &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt; &lt;code&gt;pop!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt; &lt;code&gt;splice!&lt;/code&gt; &lt;/a&gt; ). Такие функции также для удобства возвращают модифицированный массив.</target>
        </trans-unit>
        <trans-unit id="7694e2fcb791d9c25c404da14cf2f301a28f48ea" translate="yes" xml:space="preserve">
          <source>Julia Coroutines (Green Threading)</source>
          <target state="translated">Джулия Корутина (Зеленая нить)</target>
        </trans-unit>
        <trans-unit id="79e749c34e72bbae64d0f791f7a71e619f74aae2" translate="yes" xml:space="preserve">
          <source>Julia GPU man pages</source>
          <target state="translated">страницы руководства Julia GPU</target>
        </trans-unit>
        <trans-unit id="a42ee146344a47614f0b605c9369dddac1347289" translate="yes" xml:space="preserve">
          <source>Julia Releases</source>
          <target state="translated">Джулия Релизы</target>
        </trans-unit>
        <trans-unit id="799d12425163528cdf3dbdb65e3972da06d0f30c" translate="yes" xml:space="preserve">
          <source>Julia Tasks allow suspending and resuming computations for I/O, event handling, producer-consumer processes, and similar patterns. Tasks can synchronize through operations like &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch&lt;/code&gt;, and communicate via &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8d2a4a743981227407130fd283bf2436f883ac" translate="yes" xml:space="preserve">
          <source>Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some advantages of Julia over comparable systems include:</source>
          <target state="translated">Джулия стремится создать беспрецедентную комбинацию простоты использования,мощности и эффективности на одном языке.В дополнение к вышесказанному,некоторые преимущества Julia по сравнению с сопоставимыми системами включают в себя:</target>
        </trans-unit>
        <trans-unit id="05d11d59ee07392ef31079bd1e459ad76c3f824e" translate="yes" xml:space="preserve">
          <source>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, &lt;code&gt;x[1,]&lt;/code&gt; in R would return the first row of a matrix; in Julia, however, the comma is ignored, so &lt;code&gt;x[1,] == x[1]&lt;/code&gt;, and will return the first element. To extract a row, be sure to use &lt;code&gt;:&lt;/code&gt;, as in &lt;code&gt;x[1,:]&lt;/code&gt;.</source>
          <target state="translated">Джулия допускает необязательную конечную запятую, если эта запятая не меняет смысл кода. Это может вызвать путаницу у пользователей R при индексировании в массивы. Например, &lt;code&gt;x[1,]&lt;/code&gt; в R вернет первую строку матрицы; в Julia, однако, запятая игнорируется, поэтому &lt;code&gt;x[1,] == x[1]&lt;/code&gt; и вернет первый элемент. Чтобы извлечь строку, обязательно используйте &lt;code&gt;:&lt;/code&gt; , как в &lt;code&gt;x[1,:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c83ba6941f781ea6f95d544e9edf743cc32b5bdb" translate="yes" xml:space="preserve">
          <source>Julia also defines the types &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;UInt&lt;/code&gt;, which are aliases for the system's signed and unsigned native integer types respectively:</source>
          <target state="translated">Джулия также определяет типы &lt;code&gt;Int&lt;/code&gt; и &lt;code&gt;UInt&lt;/code&gt; , которые являются псевдонимами для системных целочисленных типов со знаком и без знака соответственно:</target>
        </trans-unit>
        <trans-unit id="5b4f0844a2699d5ea273cd05f5a3f5753244a2f6" translate="yes" xml:space="preserve">
          <source>Julia also provides &lt;code&gt;*&lt;/code&gt; for string concatenation:</source>
          <target state="translated">Юлия также предоставляет &lt;code&gt;*&lt;/code&gt; для конкатенации строк:</target>
        </trans-unit>
        <trans-unit id="42a5af28aae285694adf3f30e69a77a9764131d7" translate="yes" xml:space="preserve">
          <source>Julia also provides the &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt;&lt;code&gt;nextfloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt;&lt;code&gt;prevfloat&lt;/code&gt;&lt;/a&gt; functions which return the next largest or smallest representable floating-point number to the argument respectively:</source>
          <target state="translated">Джулия также предоставляет функции &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt; &lt;code&gt;nextfloat&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt; &lt;code&gt;prevfloat&lt;/code&gt; ,&lt;/a&gt; которые возвращают в аргумент следующее наибольшее или наименьшее представимое число с плавающей запятой соответственно:</target>
        </trans-unit>
        <trans-unit id="06ed8be5c06d7dc93b6c0404ce3653f58e45b54f" translate="yes" xml:space="preserve">
          <source>Julia also supports &lt;a href=&quot;#man-multithreading-1&quot;&gt;experimental multi-threading&lt;/a&gt;, where execution is forked and an anonymous function is run across all threads. Known as the fork-join approach, parallel threads execute independently, and must ultimately be joined in Julia's main thread to allow serial execution to continue. Multi-threading is supported using the &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt;&lt;code&gt;Base.Threads&lt;/code&gt;&lt;/a&gt; module that is still considered experimental, as Julia is not yet fully thread-safe. In particular segfaults seem to occur during I/O operations and task switching. As an up-to-date reference, keep an eye on &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;the issue tracker&lt;/a&gt;. Multi-Threading should only be used if you take into consideration global variables, locks and atomics, all of which are explained later.</source>
          <target state="translated">Джулия также поддерживает &lt;a href=&quot;#man-multithreading-1&quot;&gt;экспериментальную многопоточность&lt;/a&gt; , при которой выполнение разветвляется, а анонимная функция выполняется во всех потоках. Известный как подход fork-join, параллельные потоки выполняются независимо и в конечном итоге должны быть объединены в основном потоке Джулии, чтобы обеспечить продолжение последовательного выполнения. Многопоточность поддерживается с &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt; &lt;code&gt;Base.Threads&lt;/code&gt; &lt;/a&gt; модуля Base.Threads, который все еще считается экспериментальным, поскольку Julia еще не полностью поддерживает потоки . В частности, во время операций ввода-вывода и переключения задач возникают сбои. В качестве актуальной ссылки следите за &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;системой отслеживания проблем&lt;/a&gt; . Многопоточность следует использовать только в том случае, если вы принимаете во внимание глобальные переменные, блокировки и атомики, которые будут объяснены позже.</target>
        </trans-unit>
        <trans-unit id="ab93a47c44a4029660cdea5a681e67f3452b925f" translate="yes" xml:space="preserve">
          <source>Julia and C can share array data without copying. The next example will show how this works.</source>
          <target state="translated">Джулия и С могут совместно использовать данные массива без копирования.Следующий пример покажет,как это работает.</target>
        </trans-unit>
        <trans-unit id="989b4bbc6cbc89a53b5cc95fd259449cc83265cf" translate="yes" xml:space="preserve">
          <source>Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</source>
          <target state="translated">Julia и ее пакетная экосистема включает в себя инструменты,которые могут помочь вам диагностировать проблемы и улучшить производительность вашего кода:</target>
        </trans-unit>
        <trans-unit id="bb6140d98b962ed45444f6097b48c1ab7b34b758" translate="yes" xml:space="preserve">
          <source>Julia applies the following order and associativity of operations, from highest precedence to lowest:</source>
          <target state="translated">Юлия применяет следующий порядок и ассоциативность операций,от высшего приоритета до низшего:</target>
        </trans-unit>
        <trans-unit id="a2d556e852ab5ec005eba2ee374bde91855e354e" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e54f86310ed0d0b6726cbc9118645ff3e41ba9" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Массивы Julia упорядочены по столбцам (в порядке Fortran), тогда как массивы C / C ++ по умолчанию упорядочены по строкам. Чтобы получить оптимальную производительность при обходе массивов, порядок циклов в Julia должен быть изменен на обратный по сравнению с C / C ++ (см. Соответствующий раздел &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Советы&lt;/a&gt; по производительности ).</target>
        </trans-unit>
        <trans-unit id="c5aee379485d3e8989f69a590d396666e706c30b" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101c9a575d6ee596869371a0022ecfe27370c862" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Массивы Julia являются основными по столбцам (в порядке Fortran), тогда как массивы NumPy по умолчанию являются основными по строкам (в порядке C). Чтобы получить оптимальную производительность при обходе массивов, порядок циклов в Julia должен быть изменен на обратный по сравнению с NumPy (см. Соответствующий раздел &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Советы&lt;/a&gt; по производительности ).</target>
        </trans-unit>
        <trans-unit id="4295a55355c53bb69700ac344333d3ad56193792" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, &lt;code&gt;A[i,j]&lt;/code&gt;.</source>
          <target state="translated">Массивы Julia помечаются квадратными скобками, &lt;code&gt;A[i,j]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee791aabb20af6c1bfdaa172e030af0dec26574" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, and can have more than one dimension &lt;code&gt;A[i,j]&lt;/code&gt;. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</source>
          <target state="translated">Массивы Julia индексируются квадратными скобками и могут иметь более одного измерения &lt;code&gt;A[i,j]&lt;/code&gt; . Этот синтаксис - не просто синтаксический сахар для ссылки на указатель или адрес, как в C / C ++. См. Документацию Julia для получения информации о синтаксисе построения массива (он менялся в разных версиях).</target>
        </trans-unit>
        <trans-unit id="4b072870337da75d87b7efdc10a5b80a2cf3a54d" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well.</source>
          <target state="translated">Массивы Julia не копируются при присвоении другой переменной. После того, как &lt;code&gt;A = B&lt;/code&gt; , изменяющиеся элементы &lt;code&gt;B&lt;/code&gt; будет изменять &lt;code&gt;A&lt;/code&gt; , а также.</target>
        </trans-unit>
        <trans-unit id="ee983dec29328f6ef30dd7f19c04408b414cdba1" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well. Updating operators like &lt;code&gt;+=&lt;/code&gt; do not operate in-place, they are equivalent to &lt;code&gt;A = A + B&lt;/code&gt; which rebinds the left-hand side to the result of the right-hand side expression.</source>
          <target state="translated">Массивы Julia не копируются при присвоении другой переменной. После того, как &lt;code&gt;A = B&lt;/code&gt; , изменяющиеся элементы &lt;code&gt;B&lt;/code&gt; будет изменять &lt;code&gt;A&lt;/code&gt; , а также. Операторы обновления, такие как &lt;code&gt;+=&lt;/code&gt; , не работают на месте, они эквивалентны &lt;code&gt;A = A + B&lt;/code&gt; который повторно связывает левую часть с результатом выражения правой части.</target>
        </trans-unit>
        <trans-unit id="f8885b17b4a7f2b903bda15b50d42d46540e083d" translate="yes" xml:space="preserve">
          <source>Julia arrays are represented in C by the datatype &lt;code&gt;jl_array_t*&lt;/code&gt;. Basically, &lt;code&gt;jl_array_t&lt;/code&gt; is a struct that contains:</source>
          <target state="translated">Массивы Julia представлены в C &lt;code&gt;jl_array_t*&lt;/code&gt; данных jl_array_t * . По сути, &lt;code&gt;jl_array_t&lt;/code&gt; - это структура, которая содержит:</target>
        </trans-unit>
        <trans-unit id="f90d5ad1f221d4a17d6ad64fe11db8244636641f" translate="yes" xml:space="preserve">
          <source>Julia automatically inserts calls to the &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; function to convert each argument to the specified type. For example, the following call:</source>
          <target state="translated">Джулия автоматически вставляет вызовы функции &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; ,&lt;/a&gt; чтобы преобразовать каждый аргумент в указанный тип. Например, такой звонок:</target>
        </trans-unit>
        <trans-unit id="94aa685212fa097b84259cd91052f6a151ab1143" translate="yes" xml:space="preserve">
          <source>Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing</source>
          <target state="translated">Джулия заимствует обратную нотацию для команд из оболочки,Перла и Руби.Однако,в Джулии,пишущей</target>
        </trans-unit>
        <trans-unit id="1e4dcf624482d6017b9073977072d06f0c1e1383" translate="yes" xml:space="preserve">
          <source>Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way from within Julia. Supposing that you want to set the environment variable &lt;code&gt;JULIA_EDITOR&lt;/code&gt; to &lt;code&gt;vim&lt;/code&gt;, you can type &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; in the user's home directory to have a permanent effect. The current value of the same environment variable can be determined by evaluating &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt;.</source>
          <target state="translated">Julia может быть настроена с помощью ряда переменных среды, установленных обычным способом для каждой операционной системы или переносимым способом из Julia. Предположим, вы хотите установить для переменной среды &lt;code&gt;JULIA_EDITOR&lt;/code&gt; значение &lt;code&gt;vim&lt;/code&gt; , вы можете ввести &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (например, в REPL), чтобы вносить это изменение в каждом конкретном случае, или добавить то же самое в файл конфигурации пользователя &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; в домашнем каталоге пользователя, чтобы иметь постоянный эффект. Текущее значение той же переменной среды можно определить, оценив &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25624934c68cd4d66c22470ba9dffff20f4e4703" translate="yes" xml:space="preserve">
          <source>Julia can be started in parallel mode with either the &lt;code&gt;-p&lt;/code&gt; or the &lt;code&gt;--machine-file&lt;/code&gt; options. &lt;code&gt;-p n&lt;/code&gt; will launch an additional &lt;code&gt;n&lt;/code&gt; worker processes, while &lt;code&gt;--machine-file file&lt;/code&gt; will launch a worker for each line in file &lt;code&gt;file&lt;/code&gt;. The machines defined in &lt;code&gt;file&lt;/code&gt; must be accessible via a password-less &lt;code&gt;ssh&lt;/code&gt; login, with Julia installed at the same location as the current host. Each machine definition takes the form &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. &lt;code&gt;count&lt;/code&gt; is the number of workers to spawn on the node, and defaults to 1. The optional &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; specifies the IP address and port that other workers should use to connect to this worker.</source>
          <target state="translated">Julia можно запустить в параллельном режиме с помощью параметров &lt;code&gt;-p&lt;/code&gt; или &lt;code&gt;--machine-file&lt;/code&gt; . &lt;code&gt;-p n&lt;/code&gt; запустит еще &lt;code&gt;n&lt;/code&gt; рабочих процессов, а &lt;code&gt;--machine-file file&lt;/code&gt; запустит одного рабочего для каждой строки в файле &lt;code&gt;file&lt;/code&gt; . Машины, определенные в &lt;code&gt;file&lt;/code&gt; должны быть доступны через &lt;code&gt;ssh&lt;/code&gt; логин без пароля, при этом Julia установлена ​​в том же месте, что и текущий хост. Каждое определение машины имеет вид &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt; . &lt;code&gt;user&lt;/code&gt; умолчанию - текущий пользователь, &lt;code&gt;port&lt;/code&gt; на стандартный порт ssh. &lt;code&gt;count&lt;/code&gt; - это количество рабочих &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; на узле, по умолчанию 1. Необязательный параметр bind-to bind_addr [: port] указывает IP-адрес и порт, которые другие рабочие должны использовать для подключения к этому рабочему процессу .</target>
        </trans-unit>
        <trans-unit id="1aef7868e131aa3765142ca6c54c8fa0eb438e27" translate="yes" xml:space="preserve">
          <source>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</source>
          <target state="translated">Джулия может создавать подстроки,индексируя их в строки.В R строки должны быть преобразованы в символьные векторы перед созданием подстрок.</target>
        </trans-unit>
        <trans-unit id="5f876f801dbf3de94a121a0fbe557fe7c2dabadb" translate="yes" xml:space="preserve">
          <source>Julia can run multiple commands in parallel:</source>
          <target state="translated">Джулия может выполнять несколько команд параллельно:</target>
        </trans-unit>
        <trans-unit id="d72c9df952d8a93730d24273b050dd7a87c41b99" translate="yes" xml:space="preserve">
          <source>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt;.</source>
          <target state="translated">Джулия не может назначать результаты вызовов функций в левой части операции присваивания: вы не можете писать &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b5bf6c00b042abbcf8493eca58ab2e8c4ebfcf" translate="yes" xml:space="preserve">
          <source>Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt;:</source>
          <target state="translated">Кластеры Julia предназначены для выполнения в уже защищенных средах инфраструктуры, например локальных портативных компьютерах, кластерах отделов или даже в облаке. В этом разделе рассматриваются требования сетевой безопасности для встроенных &lt;code&gt;LocalManager&lt;/code&gt; и &lt;code&gt;SSHManager&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbe512ceba50dc3b08408e0b7101fcd9582324dd" translate="yes" xml:space="preserve">
          <source>Julia code can throw exceptions. For example, consider:</source>
          <target state="translated">Код Джулии может бросать исключения.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="d4d45a9c6d816f57f235a4b45d059535efea33d0" translate="yes" xml:space="preserve">
          <source>Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the &lt;code&gt;julia&lt;/code&gt; executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling &lt;code&gt;julia&lt;/code&gt; with no arguments or double-clicking on the executable:</source>
          <target state="translated">Julia поставляется с полнофункциональным интерактивным REPL командной строки (цикл чтения-оценки-печати), встроенным в исполняемый файл &lt;code&gt;julia&lt;/code&gt; . Помимо возможности быстрой и простой оценки операторов Julia, он имеет историю с возможностью поиска, завершение по табуляции, множество полезных сочетаний клавиш, а также специальные режимы справки и оболочки. REPL можно запустить, просто вызвав &lt;code&gt;julia&lt;/code&gt; без аргументов или дважды щелкнув исполняемый файл:</target>
        </trans-unit>
        <trans-unit id="04f431b0e99b100c80ed3b37854b8baa69220c9e" translate="yes" xml:space="preserve">
          <source>Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at &lt;code&gt;8&lt;/code&gt; (or the number of your cores).</source>
          <target state="translated">Джулия компилирует и использует свою собственную копию OpenBLAS с ограничением потоков до &lt;code&gt;8&lt;/code&gt; (или количества ваших ядер).</target>
        </trans-unit>
        <trans-unit id="0463aec28ff8f6050169511f8bc7eb9f0e64fcdf" translate="yes" xml:space="preserve">
          <source>Julia constructs vectors using brackets. Julia's &lt;code&gt;[1, 2, 3]&lt;/code&gt; is the equivalent of R's &lt;code&gt;c(1, 2, 3)&lt;/code&gt;.</source>
          <target state="translated">Юля строит векторы с помощью скобок. &lt;code&gt;[1, 2, 3]&lt;/code&gt; Джулии эквивалентен R's &lt;code&gt;c(1, 2, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c3022b87e47f6ac9e21545c147897ab28a7faa7" translate="yes" xml:space="preserve">
          <source>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in &lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;packages&lt;/a&gt; under the &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats organization&lt;/a&gt;. For example:</source>
          <target state="translated">Джулия не рекомендует заполнять основное пространство имен функциями. Большинство статистической функциональности Джулии находится в &lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;пакетах&lt;/a&gt; под &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;организацией JuliaStats&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="4d3373777de6110679b5b20361db329af8df4ef4" translate="yes" xml:space="preserve">
          <source>Julia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output.</source>
          <target state="translated">Джулия не рекомендует использовать точку с запятой в конце операторов. Результаты операторов не печатаются автоматически (кроме интерактивной подсказки), и строки кода не должны заканчиваться точкой с запятой. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt; можно использовать для печати определенного вывода.</target>
        </trans-unit>
        <trans-unit id="04e059ffc127f6546f46c24be663b53bb5ca0e7a" translate="yes" xml:space="preserve">
          <source>Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB &lt;code&gt;a(4) = 3.2&lt;/code&gt; can create the array &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; and &lt;code&gt;a(5) = 7&lt;/code&gt; can grow it into &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt;, the corresponding Julia statement &lt;code&gt;a[5] = 7&lt;/code&gt; throws an error if the length of &lt;code&gt;a&lt;/code&gt; is less than 5 or if this statement is the first use of the identifier &lt;code&gt;a&lt;/code&gt;. Julia has &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;, which grow &lt;code&gt;Vector&lt;/code&gt;s much more efficiently than MATLAB's &lt;code&gt;a(end+1) = val&lt;/code&gt;.</source>
          <target state="translated">Джулия не увеличивает массивы автоматически в операторе присваивания. В то время как в MATLAB &lt;code&gt;a(4) = 3.2&lt;/code&gt; может создать массив &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; а &lt;code&gt;a(5) = 7&lt;/code&gt; может вырастить его в &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt; , соответствующий оператор Julia &lt;code&gt;a[5] = 7&lt;/code&gt; вызывает ошибку, если длина &lt;code&gt;a&lt;/code&gt; меньше 5 или если этот оператор является первым использованием идентификатора &lt;code&gt;a&lt;/code&gt; . У Юлии &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt; , которые растут &lt;code&gt;Vector&lt;/code&gt; s намного эффективнее, чем MATLAB &lt;code&gt;a(end+1) = val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="113852d54ae1eab98b745b5419ac194b68416265" translate="yes" xml:space="preserve">
          <source>Julia does not have an analog of MATLAB's &lt;code&gt;clear&lt;/code&gt; function; once a name is defined in a Julia session (technically, in module &lt;code&gt;Main&lt;/code&gt;), it is always present.</source>
          <target state="translated">У Джулии нет аналога функции &lt;code&gt;clear&lt;/code&gt; MATLAB ; как только имя определено в сеансе Julia (технически в модуле &lt;code&gt;Main&lt;/code&gt; ), оно всегда присутствует.</target>
        </trans-unit>
        <trans-unit id="976166bb189635ca72f2fa234ae3939afd751bdc" translate="yes" xml:space="preserve">
          <source>Julia does not provide &lt;code&gt;nrow&lt;/code&gt; and &lt;code&gt;ncol&lt;/code&gt;. Instead, use &lt;code&gt;size(M, 1)&lt;/code&gt; for &lt;code&gt;nrow(M)&lt;/code&gt; and &lt;code&gt;size(M, 2)&lt;/code&gt; for &lt;code&gt;ncol(M)&lt;/code&gt;.</source>
          <target state="translated">Юля не предоставляет &lt;code&gt;nrow&lt;/code&gt; и &lt;code&gt;ncol&lt;/code&gt; . Вместо этого используйте &lt;code&gt;size(M, 1)&lt;/code&gt; для &lt;code&gt;nrow(M)&lt;/code&gt; и &lt;code&gt;size(M, 2)&lt;/code&gt; для &lt;code&gt;ncol(M)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9006bf61e6f8840d28990bf4b3458318711564d6" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">Джулия не требует скобок при написании операторов &lt;code&gt;if&lt;/code&gt; или циклов &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; : используйте &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; вместо &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; и &lt;code&gt;if i == 1&lt;/code&gt; вместо &lt;code&gt;if (i == 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef86462da92aecc95d832b0a401463ce19d89f34" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">Джулия не требует скобок при написании операторов &lt;code&gt;if&lt;/code&gt; или циклов &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; : используйте &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; вместо &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; и &lt;code&gt;if i == 1&lt;/code&gt; вместо &lt;code&gt;if (i == 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dab151404329caee20c7d4f7fc1cfb9d014b7b4" translate="yes" xml:space="preserve">
          <source>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output. In the REPL, &lt;code&gt;;&lt;/code&gt; can be used to suppress output. &lt;code&gt;;&lt;/code&gt; also has a different meaning within &lt;code&gt;[ ]&lt;/code&gt;, something to watch out for. &lt;code&gt;;&lt;/code&gt; can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</source>
          <target state="translated">Джулия не требует использования точек с запятой в конце операторов. Результаты выражений не печатаются автоматически (кроме интерактивной подсказки, т. Е. REPL), и строки кода не должны заканчиваться точкой с запятой. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt; можно использовать для печати определенного вывода. В РЕПЛ, &lt;code&gt;;&lt;/code&gt; может использоваться для подавления вывода. &lt;code&gt;;&lt;/code&gt; также имеет другое значение внутри &lt;code&gt;[ ]&lt;/code&gt; , на что следует обратить внимание. &lt;code&gt;;&lt;/code&gt; могут использоваться для разделения выражений в одной строке, но во многих случаях это не является строго необходимым, а скорее способствует удобочитаемости.</target>
        </trans-unit>
        <trans-unit id="3aeb7f64792ed5618bd5020762501e30791645d0" translate="yes" xml:space="preserve">
          <source>Julia does not support negative indices. In particular, the last element of a list or array is indexed with &lt;code&gt;end&lt;/code&gt; in Julia, not &lt;code&gt;-1&lt;/code&gt; as in Python.</source>
          <target state="translated">Юля не поддерживает отрицательные показатели. В частности, последний элемент списка или массива индексируется &lt;code&gt;end&lt;/code&gt; в Julia, а не &lt;code&gt;-1&lt;/code&gt; , как в Python.</target>
        </trans-unit>
        <trans-unit id="f5ece5c5877f48513873a461f405e2da3018d04a" translate="yes" xml:space="preserve">
          <source>Julia does not support the &lt;code&gt;NULL&lt;/code&gt; type. The closest equivalent is &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, but it behaves like a scalar value rather than like a list. Use &lt;code&gt;x === nothing&lt;/code&gt; instead of &lt;code&gt;is.null(x)&lt;/code&gt;.</source>
          <target state="translated">Юлия не поддерживает тип &lt;code&gt;NULL&lt;/code&gt; . Ближайший эквивалент - &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; , но ведет себя как скалярное значение, а не как список. Используйте &lt;code&gt;x === nothing&lt;/code&gt; вместо &lt;code&gt;is.null(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5112c931f9c26dffeeec5c85f5a9032e0c2b42" translate="yes" xml:space="preserve">
          <source>Julia does not treat the numbers &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as Booleans. You cannot write &lt;code&gt;if (1)&lt;/code&gt; in Julia, because &lt;code&gt;if&lt;/code&gt; statements accept only booleans. Instead, you can write &lt;code&gt;if true&lt;/code&gt;, &lt;code&gt;if Bool(1)&lt;/code&gt;, or &lt;code&gt;if 1==1&lt;/code&gt;.</source>
          <target state="translated">Джулия не считает числа &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; логическими. Вы не можете написать &lt;code&gt;if (1)&lt;/code&gt; в Julia, потому &lt;code&gt;if&lt;/code&gt; операторы if принимают только логические значения. Вместо этого вы можете написать &lt;code&gt;if true&lt;/code&gt; , &lt;code&gt;if Bool(1)&lt;/code&gt; или &lt;code&gt;if 1==1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d0ea94ce19e9b69c6095b45e92d65e847fbab5" translate="yes" xml:space="preserve">
          <source>Julia doesn't require parens around conditions in &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;. Write:</source>
          <target state="translated">Джулии не нужны скобки вокруг условий в &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;while&lt;/code&gt; . Напишите:</target>
        </trans-unit>
        <trans-unit id="c7d384a3039a9f94436def1f2e231fafa1ebc407" translate="yes" xml:space="preserve">
          <source>Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.</source>
          <target state="translated">Julia позволяет разработчикам пакетов и пользователям легко документировать функции,типы и другие объекты с помощью встроенной системы документирования,начиная с Julia 0.4.</target>
        </trans-unit>
        <trans-unit id="a610a30b8a22b7162af81fa68a40648223fcdceb" translate="yes" xml:space="preserve">
          <source>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that &lt;code&gt;table(x::TypeA)&lt;/code&gt; and &lt;code&gt;table(x::TypeB)&lt;/code&gt; act like R's &lt;code&gt;table.TypeA(x)&lt;/code&gt; and &lt;code&gt;table.TypeB(x)&lt;/code&gt;.</source>
          <target state="translated">Джулия призывает пользователей писать свои собственные типы, которые проще использовать, чем объекты S3 или S4 в системе множественной диспетчеризации R. Julia означает, что &lt;code&gt;table(x::TypeA)&lt;/code&gt; и &lt;code&gt;table(x::TypeB)&lt;/code&gt; действуют как &lt;code&gt;table.TypeA(x)&lt;/code&gt; и &lt;code&gt;table.TypeB(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93dbc5f2b7cd97919b61b2ba139686426c401f37" translate="yes" xml:space="preserve">
          <source>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function &lt;code&gt;f(x=rand()) = x&lt;/code&gt; returns a new random number every time it is invoked without argument. On the other hand, the function &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; returns &lt;code&gt;[1,2,3]&lt;/code&gt; every time it is called as &lt;code&gt;g()&lt;/code&gt;.</source>
          <target state="translated">Джулия оценивает значения аргументов функции по умолчанию каждый раз, когда вызывается метод, в отличие от Python, где значения по умолчанию оцениваются только один раз, когда функция определена. Например, функция &lt;code&gt;f(x=rand()) = x&lt;/code&gt; возвращает новое случайное число каждый раз, когда она вызывается без аргументов. С другой стороны, функция &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; возвращает &lt;code&gt;[1,2,3]&lt;/code&gt; каждый раз, когда она вызывается как &lt;code&gt;g()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96712ad66b3fa51cd94fd25a53b3080e67ce2f4b" translate="yes" xml:space="preserve">
          <source>Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;just-in-time (JIT) compilation&lt;/a&gt;, implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;. It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, including &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;.</source>
          <target state="translated">Julia имеет опциональную типизацию, множественную отправку и хорошую производительность, достигаемую с помощью вывода типа и &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;JIT-компиляции&lt;/a&gt; , реализованной с использованием &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt; . Это мультипарадигма, сочетающая в себе особенности императивного, функционального и объектно-ориентированного программирования. Julia обеспечивает простоту и выразительность для высокоуровневых численных вычислений так же, как такие языки, как R, MATLAB и Python, но также поддерживает общее программирование. Чтобы достичь этого, Джулия опирается на родословную языков математического программирования, но также много заимствует из популярных динамических языков, включая &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt; и &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20fa6f6d170887fa888519e147a5de3f67149aab" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5383570d2537e5c864f51ec5fa00e7be9531d0" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters-1&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">Julia полностью поддерживает символы и строки Unicode. Как &lt;a href=&quot;#man-characters-1&quot;&gt;обсуждалось выше&lt;/a&gt; , в символьных литералах кодовые точки Unicode могут быть представлены с использованием escape-последовательностей Unicode &lt;code&gt;\u&lt;/code&gt; и &lt;code&gt;\U&lt;/code&gt; , а также всех стандартных escape-последовательностей C. Их также можно использовать для записи строковых литералов:</target>
        </trans-unit>
        <trans-unit id="ddd78f6e5bc711118d9be3c491d9cc07a50a79b9" translate="yes" xml:space="preserve">
          <source>Julia function arguments follow a convention sometimes called &quot;pass-by-sharing&quot;, which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable &lt;em&gt;bindings&lt;/em&gt; (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as &lt;code&gt;Array&lt;/code&gt;s) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.</source>
          <target state="translated">Аргументы функции Julia следуют соглашению, иногда называемому &amp;laquo;передача через совместное использование&amp;raquo;, что означает, что значения не копируются при передаче в функции. Сами аргументы функции действуют как новые &lt;em&gt;привязки&lt;/em&gt; переменных (новые местоположения, которые могут ссылаться на значения), но значения, на которые они ссылаются, идентичны переданным значениям. Изменения изменяемых значений (например, &lt;code&gt;Array&lt;/code&gt; s), сделанные в функции, будут видны вызывающей стороне. Это то же поведение, что и в Scheme, большинстве Lisps, Python, Ruby и Perl, среди других динамических языков.</target>
        </trans-unit>
        <trans-unit id="f080283d31381a5962b780da17f950587890e071" translate="yes" xml:space="preserve">
          <source>Julia has Perl-compatible regular expressions (regexes), as provided by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library (a description of the syntax can be found &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;here&lt;/a&gt;). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with &lt;code&gt;r&lt;/code&gt;. The most basic regular expression literal without any options turned on just uses &lt;code&gt;r&quot;...&quot;&lt;/code&gt;:</source>
          <target state="translated">У Джулии есть Perl-совместимые регулярные выражения (regexes), предоставляемые библиотекой &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; (описание синтаксиса можно найти &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;здесь&lt;/a&gt; ). Регулярные выражения связаны со строками двумя способами: очевидная связь состоит в том, что регулярные выражения используются для поиска регулярных шаблонов в строках; другая связь заключается в том, что регулярные выражения сами вводятся как строки, которые анализируются в конечном автомате, который может использоваться для эффективного поиска шаблонов в строках. В Julia регулярные выражения вводятся с использованием нестандартных строковых литералов с префиксом различных идентификаторов, начинающихся с &lt;code&gt;r&lt;/code&gt; . Самый простой литерал регулярного выражения без включенных опций просто использует &lt;code&gt;r&quot;...&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1bf49a0edfd1fa830fafecd8986f8d037e52871d" translate="yes" xml:space="preserve">
          <source>Julia has a built-in data structure called a &lt;em&gt;tuple&lt;/em&gt; that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is &lt;em&gt;immutable&lt;/em&gt;). Tuples are constructed with commas and parentheses, and can be accessed via indexing:</source>
          <target state="translated">У Джулии есть встроенная структура данных, называемая &lt;em&gt;кортежем,&lt;/em&gt; которая тесно связана с аргументами функции и возвращаемыми значениями. Кортеж - это контейнер фиксированной длины, который может содержать любые значения, но не может быть изменен (он &lt;em&gt;неизменен&lt;/em&gt; ). Кортежи состоят из запятых и круглых скобок, и к ним можно получить доступ через индексирование:</target>
        </trans-unit>
        <trans-unit id="c552e8e0854f7810a14a1b85cee7a089274fe437" translate="yes" xml:space="preserve">
          <source>Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">У Джулии есть тип рационального числа для представления точных соотношений целых чисел. Рационалы создаются с использованием оператора &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f16da71d7eefd561befb9a12573735daa1e67ea2" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40bd35bfba54a15cc9852aeface053edb4835d0" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">Джулия имеет специальный &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;точечный синтаксис&lt;/a&gt; , который преобразует любой скалярной функции в &amp;laquo;векторизованную&amp;raquo; вызов функции, и любой оператор в &amp;laquo;векторизованную&amp;raquo; оператора, с особым свойством , что вложенная &amp;laquo;усеивают вызовы&amp;raquo; являются &lt;em&gt;сплавления&lt;/em&gt; : они объединяются на уровне синтаксиса в единый цикл, без выделения временных массивов. Если вы используете &lt;code&gt;.=&lt;/code&gt; И аналогичные операторы присваивания, результат также можно сохранить на месте в заранее выделенном массиве (см. Выше).</target>
        </trans-unit>
        <trans-unit id="d6c4ab07a2249226dfaeff8c414c6f4ecccc5db7" translate="yes" xml:space="preserve">
          <source>Julia has a specialized version of &lt;code&gt;ntuple&lt;/code&gt; that accepts a &lt;code&gt;Val{::Int}&lt;/code&gt; instance as the second parameter; by passing &lt;code&gt;N&lt;/code&gt; as a type-parameter, you make its &quot;value&quot; known to the compiler. Consequently, this version of &lt;code&gt;array3&lt;/code&gt; allows the compiler to predict the return type.</source>
          <target state="translated">У Джулии есть специализированная версия &lt;code&gt;ntuple&lt;/code&gt; , которая принимает экземпляр &lt;code&gt;Val{::Int}&lt;/code&gt; в качестве второго параметра; передавая &lt;code&gt;N&lt;/code&gt; как параметр типа, вы сообщаете компилятору его &quot;значение&quot;. Следовательно, эта версия &lt;code&gt;array3&lt;/code&gt; позволяет компилятору предсказать возвращаемый тип.</target>
        </trans-unit>
        <trans-unit id="3dbaaf5104fbb919890d9bf95a666a5ce54dc8a0" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0467e099e9e6d5ba4caf88a327947c41a492c3" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types-1&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">У Джулии есть система преобразования аргументов математических операторов в общий тип, которая упоминалась в различных других разделах, включая &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;целые числа и числа с плавающей запятой&lt;/a&gt; , &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;математические операции и элементарные функции&lt;/a&gt; , &lt;a href=&quot;../types/index#man-types-1&quot;&gt;типы&lt;/a&gt; и &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;методы&lt;/a&gt; . В этом разделе мы объясняем, как работает эта система продвижения, а также как расширить ее на новые типы и применить ее к функциям помимо встроенных математических операторов. Традиционно языки программирования делятся на два лагеря в отношении поддержки арифметических аргументов:</target>
        </trans-unit>
        <trans-unit id="3580c0f9206e567ece3500a7602b2f938ef0cdc5" translate="yes" xml:space="preserve">
          <source>Julia has an enumeration type, expressed using the macro &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; For example: &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</source>
          <target state="translated">У Джулии есть перечисляемый тип, выраженный с помощью макроса &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; Например: &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e22281e2e9ddb304102a3e2035cc1b7d70261e86" translate="yes" xml:space="preserve">
          <source>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:</source>
          <target state="translated">Юлия имеет обширный,гибкий API для сортировки и взаимодействия с уже отсортированными массивами значений.По умолчанию Юлия выбирает разумные алгоритмы и сортировки в стандартном порядке возрастания:</target>
        </trans-unit>
        <trans-unit id="bf9ed794914c3a1a76c39f0be8423b02c7aa0fa9" translate="yes" xml:space="preserve">
          <source>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</source>
          <target state="translated">У Юлии нет синтаксиса продолжения строки:если в конце строки вход до сих пор является полным выражением,то это считается выполненным;в противном случае вход продолжается.Один из способов заставить выражение продолжить-заключить его в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="6e3f85fe865aed948db80d8506da1145de6fdbbe" translate="yes" xml:space="preserve">
          <source>Julia has several functions that can mutate their arguments. For example, it has both &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">У Джулии есть несколько функций, которые могут изменять свои аргументы. Например, в нем есть и &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="dced25e0f1eb19647f27c26102392f9de718e8bc" translate="yes" xml:space="preserve">
          <source>Julia has support for sparse vectors and &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;sparse matrices&lt;/a&gt; in the &lt;code&gt;SparseArrays&lt;/code&gt; stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</source>
          <target state="translated">У Джулии есть поддержка разреженных векторов и &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;разреженных матриц&lt;/a&gt; в &lt;code&gt;SparseArrays&lt;/code&gt; SparseArrays stdlib. Разреженные массивы - это массивы, которые содержат достаточно нулей, поэтому их хранение в специальной структуре данных приводит к экономии места и времени выполнения по сравнению с плотными массивами.</target>
        </trans-unit>
        <trans-unit id="7e110deec010cf13200f416e320f962b03651cd3" translate="yes" xml:space="preserve">
          <source>Julia has true one-dimensional arrays. Column vectors are of size &lt;code&gt;N&lt;/code&gt;, not &lt;code&gt;Nx1&lt;/code&gt;. For example, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand(N)&lt;/code&gt;&lt;/a&gt; makes a 1-dimensional array.</source>
          <target state="translated">У Джулии есть настоящие одномерные массивы. Векторы-столбцы имеют размер &lt;code&gt;N&lt;/code&gt; , а не &lt;code&gt;Nx1&lt;/code&gt; . Например, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand(N)&lt;/code&gt; &lt;/a&gt; создает одномерный массив.</target>
        </trans-unit>
        <trans-unit id="0821ee6b098b6e9c3f3f70ea62ba30df9ae8eca8" translate="yes" xml:space="preserve">
          <source>Julia has two mechanisms for loading code:</source>
          <target state="translated">У Джулии есть два механизма для загрузки кода:</target>
        </trans-unit>
        <trans-unit id="c7c1de145d34e5e8002d957a023c35b25d8ff0be" translate="yes" xml:space="preserve">
          <source>Julia has two right-shift operators, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; performs an arithmetic shift, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; always performs a logical shift, unlike C/C++, where the meaning of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; depends on the type of the value being shifted.</source>
          <target state="translated">У Джулии есть два оператора сдвига вправо, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; выполняет арифметический сдвиг, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; всегда выполняет логический сдвиг, в отличие от C / C ++, где значение &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; зависит от типа сдвигаемого значения.</target>
        </trans-unit>
        <trans-unit id="a82ef00db4da7adcbac13bd1f8a38ec016519663" translate="yes" xml:space="preserve">
          <source>Julia identifiers and code excerpts should always appear between backticks &lt;code&gt;`&lt;/code&gt; to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks &lt;code&gt;``&lt;/code&gt;. Use Unicode characters rather than their LaTeX escape sequence, i.e. &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; rather than &lt;code&gt;``\\alpha = 1``&lt;/code&gt;.</source>
          <target state="translated">Идентификаторы Julia и фрагменты кода всегда должны располагаться между обратными кавычками &lt;code&gt;`&lt;/code&gt; для включения выделения. Уравнения в синтаксисе LaTeX можно вставлять между двойными обратными кавычками &lt;code&gt;``&lt;/code&gt; . Используйте символы Unicode, а не их escape-последовательность LaTeX, то есть &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; а не &lt;code&gt;``\\alpha = 1``&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad9eda654d6c5b8e4f3d947e9256ba07cba9012f" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556d3efaca190f2ea064a6e9ec15d293042ee9a4" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Julia включает предопределенные типы как для комплексных, так и для рациональных чисел, а также поддерживает все стандартные &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;математические операции и элементарные функции&lt;/a&gt; для них. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Преобразование и продвижение&lt;/a&gt; определены таким образом, что операции с любой комбинацией предопределенных числовых типов, будь то примитивные или составные, ведут себя должным образом.</target>
        </trans-unit>
        <trans-unit id="7ddd4e3aafc825251162512ccf2a33928bb02903" translate="yes" xml:space="preserve">
          <source>Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download and install Julia by following the instructions at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;.</source>
          <target state="translated">Установка Julia проста как при использовании предварительно скомпилированных двоичных файлов, так и при компиляции из исходного кода. Загрузите и установите Julia, следуя инструкциям на &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd85d8192dfa3106e5516cbab7ad06e8387fb26" translate="yes" xml:space="preserve">
          <source>Julia is careful to distinguish scalars, vectors and matrices. In R, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;c(1)&lt;/code&gt; are the same. In Julia, they cannot be used interchangeably.</source>
          <target state="translated">Джулия старается различать скаляры, векторы и матрицы. В R &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;c(1)&lt;/code&gt; одинаковы. В Юлии они не могут быть взаимозаменяемыми.</target>
        </trans-unit>
        <trans-unit id="b86e5dd8d3107ffdd2a0b40698efdff29052007c" translate="yes" xml:space="preserve">
          <source>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</source>
          <target state="translated">Джулия с нетерпением ждет оценки и не поддерживает R-стиль ленивой оценки.Для большинства пользователей это означает,что существует очень мало нецитируемых выражений или названий столбцов.</target>
        </trans-unit>
        <trans-unit id="3107ebb99f64b1456a558b1a35edcbfee43840dd" translate="yes" xml:space="preserve">
          <source>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with &lt;code&gt;make test&lt;/code&gt;. In a binary install, you can run the test suite using &lt;code&gt;Base.runtests()&lt;/code&gt;.</source>
          <target state="translated">Julia находится в стадии быстрой разработки и имеет обширный набор тестов для проверки функциональности на нескольких платформах. Если вы собираете Julia из исходного кода, вы можете запустить этот набор тестов с помощью &lt;code&gt;make test&lt;/code&gt; . При двоичной установке вы можете запустить набор тестов с помощью &lt;code&gt;Base.runtests()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9746bea5d9fab2c69edf57da506dab8c4cb797c1" translate="yes" xml:space="preserve">
          <source>Julia lacks the equivalent of R's &lt;code&gt;assign&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt;.</source>
          <target state="translated">Julia отсутствует эквивалент АиР &lt;code&gt;assign&lt;/code&gt; или &lt;code&gt;get&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0362643e3d8faddbbdc08525668acd4db05eb64" translate="yes" xml:space="preserve">
          <source>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the &lt;code&gt;@&lt;/code&gt; character, and have both a function-like syntax, &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt;, and a statement-like syntax, &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt;. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed &lt;code&gt;for&lt;/code&gt; construct: &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt;. Where the end of the macro construct may be unclear, use the function-like form.</source>
          <target state="translated">Макросы Julia работают с проанализированными выражениями, а не с текстом программы, что позволяет им выполнять сложные преобразования кода Julia. Имена макросов начинаются с символа &lt;code&gt;@&lt;/code&gt; и имеют как функциональный синтаксис, &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt; , так и синтаксис, &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt; , @mymacro arg1 arg2 arg3 . Формы взаимозаменяемы; подобная функциям форма особенно полезна, если макрос появляется в другом выражении и часто является самым ясным. Форма, подобная оператору, часто используется для аннотирования блоков, например, в конструкции distribution &lt;code&gt;for&lt;/code&gt; : &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt; . Если конец макроконструкции может быть неясным, используйте функциональную форму.</target>
        </trans-unit>
        <trans-unit id="7722324abb1e33c9620fc5bb1dbd294982f5257b" translate="yes" xml:space="preserve">
          <source>Julia performs matrix transposition using the &lt;code&gt;transpose&lt;/code&gt; function and conjugated transposition using the &lt;code&gt;'&lt;/code&gt; operator or the &lt;code&gt;adjoint&lt;/code&gt; function. Julia's &lt;code&gt;transpose(A)&lt;/code&gt; is therefore equivalent to R's &lt;code&gt;t(A)&lt;/code&gt;. Additionally a non-recursive transpose in Julia is provided by the &lt;code&gt;permutedims&lt;/code&gt; function.</source>
          <target state="translated">Джулия выполняет транспонирование матрицы с помощью функции &lt;code&gt;transpose&lt;/code&gt; и сопряженное транспонирование с использованием оператора &lt;code&gt;'&lt;/code&gt; или &lt;code&gt;adjoint&lt;/code&gt; функции. Джулии &lt;code&gt;transpose(A)&lt;/code&gt; , следовательно , эквивалентна R в &lt;code&gt;t(A)&lt;/code&gt; . Кроме того, нерекурсивное транспонирование в Julia обеспечивается функцией &lt;code&gt;permutedims&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52ca89425115cf081b45ea4b026826f1b8b7932f" translate="yes" xml:space="preserve">
          <source>Julia provides &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which gives the distance between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable floating-point value:</source>
          <target state="translated">Джулия предоставляет &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; , который дает расстояние между &lt;code&gt;1.0&lt;/code&gt; и следующим более крупным представимым значением с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="b5151abe259ad1efc62c73fed3cdaac381488d9a" translate="yes" xml:space="preserve">
          <source>Julia provides a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; mechanism for solving this problem. A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.</source>
          <target state="translated">Юлия предоставляет механизм &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; для решения этой проблемы. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; является waitable первым в первом из очереди , которая может иметь несколько задач чтения и записи на него.</target>
        </trans-unit>
        <trans-unit id="476c4c45db4a5f4592324ce839944c2c37cd8d0a" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6a50d7fd1b9d32a07f2f0f7b72bc0c75328556" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Julia предоставляет широкий спектр примитивных числовых типов, и над ними определен полный набор арифметических и побитовых операторов, а также стандартных математических функций. Они отображаются непосредственно на числовые типы и операции, которые изначально поддерживаются на современных компьютерах, что позволяет Джулии в полной мере использовать вычислительные ресурсы. Кроме того, Julia предоставляет программную поддержку &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;арифметики произвольной точности&lt;/a&gt; , которая может обрабатывать операции с числовыми значениями, которые не могут быть эффективно представлены в собственных представлениях оборудования, но за счет относительно более низкой производительности.</target>
        </trans-unit>
        <trans-unit id="5e01948cafe564bc35cc3886e5615297521aba0b" translate="yes" xml:space="preserve">
          <source>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</source>
          <target state="translated">Julia предоставляет полную коллекцию основных арифметических и битовых операторов всех своих числовых примитивных типов,а также обеспечивает портативную,эффективную реализацию комплексной коллекции стандартных математических функций.</target>
        </trans-unit>
        <trans-unit id="123ae94e81e1f4b6a65e379d812783d382dbfd58" translate="yes" xml:space="preserve">
          <source>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</source>
          <target state="translated">Юлия предоставляет исчерпывающую коллекцию математических функций и операторов.Эти математические операции определяются как широкий класс числовых значений,позволяющий принимать разумные определения,включая целые числа,числа с плавающей точкой,нормированные и комплексные числа,везде,где такие определения имеют смысл.</target>
        </trans-unit>
        <trans-unit id="07cfc6f69cd91f9494ead12f841604f628160c20" translate="yes" xml:space="preserve">
          <source>Julia provides a reserved word &lt;code&gt;do&lt;/code&gt; for rewriting this code more clearly:</source>
          <target state="translated">Джулия предлагает зарезервированное слово &lt;code&gt;do&lt;/code&gt; для более четкого переписывания этого кода:</target>
        </trans-unit>
        <trans-unit id="657c78188298a00e823c4644aeb3647f8f14a312" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea9a879394b78dc7fcabf301d30239602afa073" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Julia предоставляет богатый интерфейс для работы с объектами потокового ввода-вывода, такими как терминалы, каналы и сокеты TCP. Этот интерфейс, хотя и асинхронный на системном уровне, представляется программисту синхронно, и обычно нет необходимости думать о лежащей в основе асинхронной операции. Это достигается за счет интенсивного использования функциональных возможностей совместной работы с потоками ( &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;сопрограммы&lt;/a&gt; ) Julia .</target>
        </trans-unit>
        <trans-unit id="abe3cae0b0fe31f45bb29933297244a39702e5dd" translate="yes" xml:space="preserve">
          <source>Julia provides a variety of control flow constructs:</source>
          <target state="translated">Джулия предоставляет различные конструкции регулирующих потоков:</target>
        </trans-unit>
        <trans-unit id="379525ee528141070933df39d7ce42ca05dd4bf0" translate="yes" xml:space="preserve">
          <source>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</source>
          <target state="translated">Джулия предоставляет дополнительные функции для проверки чисел на специальные значения,которые могут быть полезны в таких ситуациях,как сравнение хэш-ключей:</target>
        </trans-unit>
        <trans-unit id="e0540cb6db7126d29223e3d70501bf3d70244816" translate="yes" xml:space="preserve">
          <source>Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).</source>
          <target state="translated">Джулия предоставляет чрезвычайно гибкую систему именования переменных.Имена переменных чувствительны к регистру и не имеют семантического значения (то есть язык не будет относиться к переменным по-разному,основываясь на их именах).</target>
        </trans-unit>
        <trans-unit id="eab744df916b515fec425ab1cfaf69348d24b932" translate="yes" xml:space="preserve">
          <source>Julia provides built-in, efficient functions to test for oddness and evenness called &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt;&lt;code&gt;iseven&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt;&lt;code&gt;isodd&lt;/code&gt;&lt;/a&gt; so the above definitions should only be considered to be examples of scope, not efficient design.</source>
          <target state="translated">Julia предоставляет встроенные эффективные функции для проверки нечетности и четности, называемые &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt; &lt;code&gt;iseven&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt; &lt;code&gt;isodd&lt;/code&gt; ,&lt;/a&gt; поэтому приведенные выше определения следует рассматривать только как примеры объема, а не как эффективный дизайн.</target>
        </trans-unit>
        <trans-unit id="378329d878ac43129f252ba96bb3ab40b65f2250" translate="yes" xml:space="preserve">
          <source>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</source>
          <target state="translated">Юлия предоставляет функции,которые возвращают литералы 0 и 1,соответствующие указанному типу или типу заданной переменной.</target>
        </trans-unit>
        <trans-unit id="affb7609b4adcfecba8a7c2be6b8ababed17f3bf" translate="yes" xml:space="preserve">
          <source>Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists. Missing values are represented via the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object, which is the singleton instance of the type &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;missing&lt;/code&gt; is equivalent to &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;&lt;code&gt;NULL&lt;/code&gt; in SQL&lt;/a&gt; and &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;&lt;code&gt;NA&lt;/code&gt; in R&lt;/a&gt;, and behaves like them in most situations.</source>
          <target state="translated">Джулия обеспечивает поддержку для представления пропущенных значений в статистическом смысле, то есть для ситуаций, когда для переменной в наблюдении нет значения, но допустимое значение теоретически существует. Отсутствующие значения представлены через &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; объект, который является экземпляром синглтона типа &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;missing&lt;/code&gt; эквивалентно &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt; &lt;code&gt;NULL&lt;/code&gt; в SQL&lt;/a&gt; и &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt; &lt;code&gt;NA&lt;/code&gt; в R&lt;/a&gt; и ведет себя как они в большинстве ситуаций.</target>
        </trans-unit>
        <trans-unit id="105b1a0ce6d2b2d8bfa2faba37832a7982f4eb0d" translate="yes" xml:space="preserve">
          <source>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt;, use &lt;code&gt;(1, 2)&lt;/code&gt; or &lt;code&gt;(a=1, b=2)&lt;/code&gt;.</source>
          <target state="translated">Джулия предоставляет кортежи и настоящие хэш-таблицы, но не списки в стиле R. При возврате нескольких элементов обычно следует использовать кортеж или именованный кортеж: вместо &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt; используйте &lt;code&gt;(1, 2)&lt;/code&gt; или &lt;code&gt;(a=1, b=2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12d6b550dc7735e370a3f8c010496abe63394b14" translate="yes" xml:space="preserve">
          <source>Julia provides two in-built cluster managers:</source>
          <target state="translated">Джулия предоставляет двух встроенных кластерных менеджеров:</target>
        </trans-unit>
        <trans-unit id="46d26e39331065ec318009a2e11c1e691fbfaee6" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; for indexing until the last element. &lt;code&gt;x[1:]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[2:end]&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65c2e80d135867ac3b507bcd217f7ad2507c745" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; to end a block. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">Джулии требуется &lt;code&gt;end&lt;/code&gt; до конца блока. В отличие от Python, у Джулии нет ключевого слова &lt;code&gt;pass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42da913aac127180e179863fc35f1ca348a1d911" translate="yes" xml:space="preserve">
          <source>Julia should load our new code. Let's test it:</source>
          <target state="translated">Джулия должна загрузить наш новый код.Давай проверим его:</target>
        </trans-unit>
        <trans-unit id="50af488570ea82992b042e6982e9d5b39f404c93" translate="yes" xml:space="preserve">
          <source>Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c7299bbee239f4f34ffd5f256e5fa27242ff3f" translate="yes" xml:space="preserve">
          <source>Julia supports accessing and modifying values &lt;em&gt;atomically&lt;/em&gt;, that is, in a thread-safe way to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;race conditions&lt;/a&gt;. A value (which must be of a primitive type) can be wrapped as &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt;&lt;code&gt;Threads.Atomic&lt;/code&gt;&lt;/a&gt; to indicate it must be accessed in this way. Here we can see an example:</source>
          <target state="translated">Джулия поддерживает доступ и изменение значений &lt;em&gt;атомарно&lt;/em&gt; , то есть потокобезопасным способом, чтобы избежать &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;состояний гонки&lt;/a&gt; . Значение (которое должно быть примитивного типа) можно обернуть как &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt; &lt;code&gt;Threads.Atomic&lt;/code&gt; ,&lt;/a&gt; чтобы указать, что к нему необходимо получить доступ таким образом. Вот пример:</target>
        </trans-unit>
        <trans-unit id="b32a099891e5d6d1de5f4e3ebb7913c9c9d83a6a" translate="yes" xml:space="preserve">
          <source>Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The &lt;code&gt;Pkg&lt;/code&gt; package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).</source>
          <target state="translated">Julia поддерживает федеративное управление пакетами, что означает, что несколько независимых сторон могут поддерживать как общедоступные, так и частные пакеты и реестры пакетов, и что проекты могут зависеть от сочетания общедоступных и частных пакетов из разных реестров. Пакеты из разных реестров устанавливаются и управляются с помощью общего набора инструментов и рабочих процессов. Менеджер пакетов &lt;code&gt;Pkg&lt;/code&gt; , поставляемый с Julia, позволяет вам устанавливать зависимости ваших проектов и управлять ими. Он помогает в создании и управлении файлами проекта (которые описывают, от каких других проектов зависит ваш проект) и файлами манифеста (которые представляют собой точные копии полного графа зависимостей вашего проекта).</target>
        </trans-unit>
        <trans-unit id="3e86dc9fbf230d572664966d4794a26de9273668" translate="yes" xml:space="preserve">
          <source>Julia supports parallel loops using the &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; macro. This macro is affixed in front of a &lt;code&gt;for&lt;/code&gt; loop to indicate to Julia that the loop is a multi-threaded region:</source>
          <target state="translated">Джулия поддерживает параллельные циклы с помощью макроса &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt; . Этот макрос ставится перед циклом &lt;code&gt;for&lt;/code&gt; , чтобы указать Джулии, что цикл является многопоточной областью:</target>
        </trans-unit>
        <trans-unit id="a5283fbcd3917bac5a655bc39180ded4c3af822e" translate="yes" xml:space="preserve">
          <source>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</source>
          <target state="translated">Юлия поддерживает три формы численного преобразования,которые отличаются друг от друга при работе с неточными преобразованиями.</target>
        </trans-unit>
        <trans-unit id="8cd4a62b540f64bfcf5a4bbfe0bf9740f9b0515a" translate="yes" xml:space="preserve">
          <source>Julia supports three main categories of features for concurrent and parallel programming:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e2d62c4e474d2e3cdad1aedacbc766563cd1d6" translate="yes" xml:space="preserve">
          <source>Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;index offsets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0cbf25806d0b9c5fc2aa6aef5c6cef44171513" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;lexical scoping&lt;/a&gt;, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the &lt;code&gt;x&lt;/code&gt; inside &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;x&lt;/code&gt; in the global scope of its module &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Джулия использует &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;лексическую область видимости&lt;/a&gt; , что означает, что область видимости функции наследуется не от области ее вызывающего, а от области, в которой функция была определена. Например, в следующем коде &lt;code&gt;x&lt;/code&gt; внутри &lt;code&gt;foo&lt;/code&gt; относится к &lt;code&gt;x&lt;/code&gt; в глобальной области видимости его модуля &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3c73ac079b0c4f92a7cd6345869462d4c4c72df" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;, because of the operator precedence.</source>
          <target state="translated">Джулия использует &lt;code&gt;end&lt;/code&gt; для обозначения конца условных блоков, таких как &lt;code&gt;if&lt;/code&gt; , блоков цикла, таких как &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; и functions. Вместо однострочного &lt;code&gt;if ( cond ) statement&lt;/code&gt; Julia разрешены операторы вида &lt;code&gt;if cond; statement; end&lt;/code&gt; , &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; и &lt;code&gt;!cond || statement&lt;/code&gt; . Операторы присваивания в последних двух синтаксисах должны быть явно заключены в круглые скобки, например &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; , из-за приоритета оператора.</target>
        </trans-unit>
        <trans-unit id="0cabc05bc6f900c3729476582490d063a944c3f3" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;.</source>
          <target state="translated">Джулия использует &lt;code&gt;end&lt;/code&gt; для обозначения конца условных блоков, таких как &lt;code&gt;if&lt;/code&gt; , блоков цикла, таких как &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; и functions. Вместо однострочного &lt;code&gt;if ( cond ) statement&lt;/code&gt; Julia разрешены операторы вида &lt;code&gt;if cond; statement; end&lt;/code&gt; , &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; и &lt;code&gt;!cond || statement&lt;/code&gt; . Операторы присваивания в последних двух синтаксисах должны быть явно заключены в круглые скобки, например, &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07096f6426ddf7d6431c3e711ca9f0c89cf1dd4d" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;nothing&lt;/code&gt; of type &lt;code&gt;Nothing&lt;/code&gt; to represent a null value, whereas Python uses &lt;code&gt;None&lt;/code&gt; of type &lt;code&gt;NoneType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1da921baa95047321b954687696b91e15a78b61" translate="yes" xml:space="preserve">
          <source>Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</source>
          <target state="translated">Джулия использует машинную арифметику для целочисленных вычислений. Это означает, что диапазон значений &lt;code&gt;Int&lt;/code&gt; ограничен и оборачивается с любого конца, так что сложение, вычитание и умножение целых чисел может переполняться или уменьшаться, что приводит к некоторым результатам, которые поначалу могут вызывать беспокойство:</target>
        </trans-unit>
        <trans-unit id="89c53eee9d134c8dd587da06fe96b8ba48e316ee" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51011bd7d0e6585180df272ca646802fbeb44e3f" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">Джулия по умолчанию использует кодировку UTF-8, а поддержка новых кодировок может быть добавлена ​​пакетами. Например, &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; пакет реализует &lt;code&gt;UTF16String&lt;/code&gt; и &lt;code&gt;UTF32String&lt;/code&gt; типы. Дополнительное обсуждение других кодировок и того, как реализовать их поддержку, пока выходит за рамки этого документа. Для дальнейшего обсуждения проблем с кодировкой UTF-8 см. Раздел ниже, посвященный &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;литералам байтовых массивов&lt;/a&gt; . Функция &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt; предназначена для преобразования данных между различными кодировками UTF-xx, в первую очередь для работы с внешними данными и библиотеками.</target>
        </trans-unit>
        <trans-unit id="5e0e9c6a66c5fa559fda71e594a3ae5240a6637e" translate="yes" xml:space="preserve">
          <source>Julia uses the first of these that exists to try to load the public &lt;code&gt;Priv&lt;/code&gt; package from the file &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; in the depot where it was found.</source>
          <target state="translated">Юлия использует первый из них , который существует , чтобы попытаться загрузить публичный &lt;code&gt;Priv&lt;/code&gt; пакет из файла &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; в депо , где он был найден.</target>
        </trans-unit>
        <trans-unit id="30edeef56ee9d985332259b8e62139e00973bd46" translate="yes" xml:space="preserve">
          <source>Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; input forms. In addition to these Unicode escape forms, all of &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C's traditional escaped input forms&lt;/a&gt; can also be used:</source>
          <target state="translated">Джулия использует языковой стандарт и языковые настройки вашей системы, чтобы определить, какие символы могут быть напечатаны как есть, а какие должны быть выведены с использованием общих, экранированных форм ввода &lt;code&gt;\u&lt;/code&gt; или &lt;code&gt;\U&lt;/code&gt; В дополнение к этим escape-формам Unicode также могут использоваться все &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;традиционные экранированные входные формы C&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bd0dc71ebce3799f196e4c40689f527bedaa69fb" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">Значения Юлии не копируются при назначении или передаче в функцию.Если функция изменяет массив,изменения будут видны вызывающему абоненту.</target>
        </trans-unit>
        <trans-unit id="7ac4008d58382151203baf7753fcd45089959029" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">Значения Джулии не копируются при передаче в функцию.Если функция модифицирует массив,изменения будут видны вызывающему абоненту.</target>
        </trans-unit>
        <trans-unit id="8837407288696b8f56b310a5e7e527268f191a69" translate="yes" xml:space="preserve">
          <source>Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):</source>
          <target state="translated">Джулия даже позволит вам при необходимости переопределить встроенные константы и функции (хотя это не рекомендуется,чтобы избежать возможных путаниц):</target>
        </trans-unit>
        <trans-unit id="bbfd1a84071c3afc3da5111c8fd03dbd6cb9cfcf" translate="yes" xml:space="preserve">
          <source>Julia workers must NOT be started with &lt;code&gt;--worker&lt;/code&gt;. Starting with &lt;code&gt;--worker&lt;/code&gt; will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.</source>
          <target state="translated">Julia &lt;code&gt;--worker&lt;/code&gt; НЕ должен начинаться с --worker . Запуск с &lt;code&gt;--worker&lt;/code&gt; приведет к тому, что вновь запущенные рабочие процессы по умолчанию будут использовать реализацию транспорта сокетов TCP / IP.</target>
        </trans-unit>
        <trans-unit id="d2e71f463c75ed1f922e909db643a6a01be0bb01" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; takes the function first, then its arguments, unlike &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; in R. Similarly Julia's equivalent of &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; in R is &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt;&lt;code&gt;mapslices&lt;/code&gt;&lt;/a&gt; where the function is the first argument.</source>
          <target state="translated">&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; Джулии сначала принимает функцию, а затем ее аргументы, в отличие от &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; в R. Точно так же эквивалент Джулии для &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; в R - это &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt; &lt;code&gt;mapslices&lt;/code&gt; &lt;/a&gt; где функция это первый аргумент.</target>
        </trans-unit>
        <trans-unit id="f5bb002ee0de69716a37fbfcd112bddd1aed44f5" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; are different from their counterparts in R. They all accept an optional keyword argument &lt;code&gt;dims&lt;/code&gt;, which indicates the dimensions, over which the operation is carried out. For instance, let &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; in Julia and &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; be the same matrix in R. Then &lt;code&gt;sum(A)&lt;/code&gt; gives the same result as &lt;code&gt;sum(B)&lt;/code&gt;, but &lt;code&gt;sum(A, dims=1)&lt;/code&gt; is a row vector containing the sum over each column and &lt;code&gt;sum(A, dims=2)&lt;/code&gt; is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate &lt;code&gt;colSums(B)&lt;/code&gt; and &lt;code&gt;rowSums(B)&lt;/code&gt; functions provide these functionalities. If the &lt;code&gt;dims&lt;/code&gt; keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt;. It should be noted that there is no error checking regarding the second argument.</source>
          <target state="translated">&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt; Джулии отличаются от своих аналогов в R. Все они принимают необязательный аргумент ключевого слова &lt;code&gt;dims&lt;/code&gt; , который указывает размеры, над которыми выполняется операция. Например, пусть &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; в Julia и &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; та же матрица в R. Тогда &lt;code&gt;sum(A)&lt;/code&gt; дает тот же результат, что и &lt;code&gt;sum(B)&lt;/code&gt; , но &lt;code&gt;sum(A, dims=1)&lt;/code&gt; - вектор-строка, содержащий сумму по каждому столбцу, а &lt;code&gt;sum(A, dims=2)&lt;/code&gt; - вектор-столбец, содержащий сумму по каждой строке. Это контрастирует с поведением R, где отдельные &lt;code&gt;colSums(B)&lt;/code&gt; и &lt;code&gt;rowSums(B)&lt;/code&gt; предоставляют эти функции. Если аргумент ключевого слова &lt;code&gt;dims&lt;/code&gt; является вектором, то он определяет все измерения, по которым выполняется сумма, сохраняя при этом размеры суммированного массива, например &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt; , Следует отметить, что второй аргумент не проверяет ошибки.</target>
        </trans-unit>
        <trans-unit id="fa67fe88be62afc80adeb10ce9e92a9b5f6f9cf4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; are the equivalent of &lt;code&gt;pmax&lt;/code&gt; and &lt;code&gt;pmin&lt;/code&gt; respectively in R, but both arguments need to have the same dimensions. While &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; replace &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; in R, there are important differences.</source>
          <target state="translated">&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; Джулии эквивалентны &lt;code&gt;pmax&lt;/code&gt; и &lt;code&gt;pmin&lt;/code&gt; соответственно в R, но оба аргумента должны иметь одинаковые размеры. Хотя &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt; заменяют &lt;code&gt;max&lt;/code&gt; и &lt;code&gt;min&lt;/code&gt; в R, есть важные различия.</target>
        </trans-unit>
        <trans-unit id="948bcc3b1298520e6e2ce90508494e37d41ff33b" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; is designed for the case where each function call does a large amount of work. In contrast, &lt;code&gt;@distributed for&lt;/code&gt; can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;@distributed for&lt;/code&gt; for the parallel computation. In case of &lt;code&gt;@distributed for&lt;/code&gt;, the final reduction is done on the calling process.</source>
          <target state="translated">Джулии &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; предназначен для случая , когда каждый вызов функции делает большой объем работы. Напротив, &lt;code&gt;@distributed for&lt;/code&gt; может обрабатывать ситуации, когда каждая итерация крошечная, возможно, просто суммируя два числа. Как &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; ,так&lt;/a&gt; и &lt;code&gt;@distributed for&lt;/code&gt; параллельных вычислений используются только рабочие процессы . В случае &lt;code&gt;@distributed for&lt;/code&gt; окончательное сокращение выполняется для вызывающего процесса.</target>
        </trans-unit>
        <trans-unit id="1dee74c8ab40f9a1e425f6d177c82bc6b08fa25e" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt;&lt;code&gt;diag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt;&lt;code&gt;diagm&lt;/code&gt;&lt;/a&gt; are not like R's.</source>
          <target state="translated">Джулии &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt; &lt;code&gt;diag&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt; &lt;code&gt;diagm&lt;/code&gt; &lt;/a&gt; не похожи на R - х.</target>
        </trans-unit>
        <trans-unit id="05bb4ea25c67464af30f3b1789a99b7d0ce690d4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; returns singular values as a vector instead of as a dense diagonal matrix.</source>
          <target state="translated">Джулии &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; возвращает сингулярные значения в качестве вектора , а не как плотной диагональной матрицей.</target>
        </trans-unit>
        <trans-unit id="aa13bfca9375abd93cb6c7683cece63cd5fd2582" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;*&lt;/code&gt; operator can perform matrix multiplication, unlike in R. If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, then &lt;code&gt;A * B&lt;/code&gt; denotes a matrix multiplication in Julia, equivalent to R's &lt;code&gt;A %*% B&lt;/code&gt;. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">Джулии &lt;code&gt;*&lt;/code&gt; оператор может выполнить умножение матриц, в отличие от R. Если и &lt;code&gt;B&lt;/code&gt; являются матрицами, то &lt;code&gt;A * B&lt;/code&gt; обозначает умножение матриц в Julia, что эквивалентно R в &lt;code&gt;A %*% B&lt;/code&gt; . В R эта же нотация будет выполнять поэлементное (по Адамару) произведение. Чтобы получить операцию поэлементного умножения, вам нужно написать &lt;code&gt;A .* B&lt;/code&gt; в Julia. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb6c182bb057e6aaee719738d353d529a33805be" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function, it does not access a member via a pointer.</source>
          <target state="translated">Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; создает анонимную функцию, она не обращается к члену через указатель.</target>
        </trans-unit>
        <trans-unit id="0862128440ff742c36348e2d0db0ca8e8f8925ae" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function.</source>
          <target state="translated">Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; создает анонимную функцию.</target>
        </trans-unit>
        <trans-unit id="5ae5cdad8a8956ce245f1722cb08571c8a10bd0f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;Char&lt;/code&gt; type is 32 bits, which is not the same as the wide character type (&lt;code&gt;wchar_t&lt;/code&gt; or &lt;code&gt;wint_t&lt;/code&gt;) on all platforms.</source>
          <target state="translated">Тип &lt;code&gt;Char&lt;/code&gt; для Джулии - 32 бита, что не совпадает с типом широких символов ( &lt;code&gt;wchar_t&lt;/code&gt; или &lt;code&gt;wint_t&lt;/code&gt; ) на всех платформах.</target>
        </trans-unit>
        <trans-unit id="b385c4d6332873c3dcd00293c1c25f1adc3ec233" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;^&lt;/code&gt; is exponentiation (pow), not bitwise XOR as in C/C++ (use &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;, in Julia)</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; Джулии - это возведение в степень (pow), а не побитовое XOR, как в C / C ++ (используйте &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; в Julia)</target>
        </trans-unit>
        <trans-unit id="b992e2bb2c187c81d565dd2576257e75a4ff2ac1" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python.</source>
          <target state="translated">Блоки Julia &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; и т. Д. Завершаются ключевым словом &lt;code&gt;end&lt;/code&gt; . Уровень отступа не имеет значения, как в Python.</target>
        </trans-unit>
        <trans-unit id="4f389c4a1d318e9dd00a0e8de7e401cb98f80629" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5e37d3fa53f0bf640b0dba96a1ab8faecfac9f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;struct&lt;/code&gt;s do not support dynamically adding fields at runtime, unlike MATLAB's &lt;code&gt;class&lt;/code&gt;es. Instead, use a &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; Джулии не поддерживают динамическое добавление полей во время выполнения, в отличие от &lt;code&gt;class&lt;/code&gt; es в MATLAB . Вместо этого используйте &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4b03ee02a08f7deb55748f11f6cdeb8e4ae72ba" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\M-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;\ex&quot;&lt;/code&gt;, and Control plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\C-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb62051205cdc85bbd2ca3341a23ca3df8234a6b" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Привязки клавиш REPL Джулии можно полностью настроить в соответствии с предпочтениями пользователя, передав словарь в &lt;code&gt;REPL.setup_interface&lt;/code&gt; . Ключи этого словаря могут быть символами или строками. Ключ &lt;code&gt;'*'&lt;/code&gt; относится к действию по умолчанию. Привязки управляющего плюс символа &lt;code&gt;x&lt;/code&gt; обозначаются как &lt;code&gt;&quot;^x&quot;&lt;/code&gt; . Meta plus &lt;code&gt;x&lt;/code&gt; можно записать как &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt; . Значения настраиваемой раскладки клавиатуры не должны быть &lt;code&gt;nothing&lt;/code&gt; (что означает, что ввод следует игнорировать) или функциями, которые принимают подпись &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; . Функция &lt;code&gt;REPL.setup_interface&lt;/code&gt; должна быть вызвана до инициализации REPL путем регистрации операции с помощью&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt; . Например, чтобы связать клавиши со стрелками вверх и вниз для перемещения по истории без поиска по префиксу, можно поместить следующий код в &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5dfc06368777a16cdc231cc0f47af0adaed5f388" translate="yes" xml:space="preserve">
          <source>Julia's advantage is that good performance is not limited to a small subset of &amp;ldquo;built-in&amp;rdquo; types and operations, and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient. Types in languages like Python simply don't provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3f30910627d9bc09b7bdaeca1a62844f17b994" translate="yes" xml:space="preserve">
          <source>Julia's base library has a an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">В базовой библиотеке Джулии есть внутренняя функция &lt;code&gt;sub2ind&lt;/code&gt; для вычисления линейного индекса в n-мерном массиве на основе набора из n полилинейных индексов - другими словами, для вычисления индекса &lt;code&gt;i&lt;/code&gt; , который можно использовать для индексации в массив &lt;code&gt;A&lt;/code&gt; , используя &lt;code&gt;A[i]&lt;/code&gt; вместо &lt;code&gt;A[x,y,z,...]&lt;/code&gt; . Одна из возможных реализаций следующая:</target>
        </trans-unit>
        <trans-unit id="c2b028dd5553cdb221b0a0e50311b3fadf26a8fa" translate="yes" xml:space="preserve">
          <source>Julia's base library has an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c2555d21a070c01d642324e7f2023f9aae7e60" translate="yes" xml:space="preserve">
          <source>Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of &lt;code&gt;a&lt;/code&gt; during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of &lt;code&gt;fill_twos!&lt;/code&gt; for different types of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Компилятор Джулии специализирует код для типов аргументов на границах функций, поэтому в исходной реализации он не знает тип &lt;code&gt;a&lt;/code&gt; во время цикла (поскольку он выбирается случайным образом). Следовательно, вторая версия обычно быстрее, так как внутренний цикл может быть перекомпилирован как часть &lt;code&gt;fill_twos!&lt;/code&gt; для разных типов &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33f4b2b5366e275dc9d4f8493361eee0738216e2" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Реализация передачи сообщений Джулии отличается от других сред, таких как MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; . Коммуникация в Julia обычно &amp;laquo;односторонняя&amp;raquo;, что означает, что программист должен явно управлять только одним процессом в двухпроцессной операции. Более того, эти операции обычно не похожи на &amp;laquo;отправку сообщения&amp;raquo; и &amp;laquo;получение сообщения&amp;raquo;, а скорее напоминают операции более высокого уровня, такие как вызовы пользовательских функций.</target>
        </trans-unit>
        <trans-unit id="6c32163901432dfb93ac8223e9799a51677fe0b8" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI&lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d95266cdef29852b478ae12f711e31b88ca02d5" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">Внутренний механизм индексирования Джулии будет автоматически (и невидимо)преобразовывать все операции индексирования в предпочтительный стиль.Это позволяет пользователям получать доступ к элементам вашего массива с использованием любого стиля индексации,даже если явные методы не были предусмотрены.</target>
        </trans-unit>
        <trans-unit id="e29a0ad9426578653cfa0a913517c4cd61d66687" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b1a2fb20181eebd075a05851e2cc85e0131235" translate="yes" xml:space="preserve">
          <source>Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt;&lt;code&gt;gensym&lt;/code&gt;&lt;/a&gt; function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; will refer to the Julia Base definitions.</source>
          <target state="translated">Макроэкспандер Джулии решает эти проблемы следующим образом. Во-первых, переменные в результате макроса классифицируются как локальные или глобальные. Переменная считается локальной, если она назначена (а не объявлена ​​глобальной), объявлена ​​локальной или используется в качестве имени аргумента функции. В противном случае он считается глобальным. Затем локальные переменные переименовываются в уникальные (с помощью функции &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt; &lt;code&gt;gensym&lt;/code&gt; &lt;/a&gt; , которая генерирует новые символы), а глобальные переменные разрешаются в среде определения макроса. Таким образом, обе вышеуказанные проблемы решены; локальные переменные макроса не будут конфликтовать ни с какими пользовательскими переменными, а &lt;code&gt;time&lt;/code&gt; и &lt;code&gt;println&lt;/code&gt; будут ссылаться на определения Julia Base.</target>
        </trans-unit>
        <trans-unit id="86edf724d95c13484ea1286ad4816e866d0db9af" translate="yes" xml:space="preserve">
          <source>Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual &lt;code&gt;show&lt;/code&gt; methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.</source>
          <target state="translated">Уценка Джулии поддерживает интерполяцию, очень похожую на базовые строковые литералы, с той разницей, что он сохранит сам объект в дереве Markdown (в отличие от преобразования его в строку). При рендеринге содержимого Markdown будут вызваны обычные методы &lt;code&gt;show&lt;/code&gt; , которые можно как обычно переопределить. Такой дизайн позволяет расширять Markdown с помощью произвольно сложных функций (например, ссылок), не загромождая основной синтаксис.</target>
        </trans-unit>
        <trans-unit id="f193759d498fbc023e5548ecbd3efb90a55de4f4" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0901cb4cceb0fa7182b9eca38ef424535bdbefb3" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities-1&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">Полиморфизм метода Джулии - одна из его самых мощных функций, но использование этой силы может создать проблемы проектирования. В частности, в более сложных иерархиях методов нередко возникают &lt;a href=&quot;#man-ambiguities-1&quot;&gt;неоднозначности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23f2c84d6fee04af47b767e6d6e002d54d481014" translate="yes" xml:space="preserve">
          <source>Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</source>
          <target state="translated">Многомерные массивы Джулии хранятся в памяти в порядке столбцов-мажор.Вот некий код,который создает 2D массив и получает доступ к его свойствам:</target>
        </trans-unit>
        <trans-unit id="5f52e87d6645fc0ed7cad30b976ecccc50cc320e" translate="yes" xml:space="preserve">
          <source>Julia's parallel programming platform uses &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (aka Coroutines)&lt;/a&gt; to switch among multiple computations. To express an order of execution between lightweight threads communication primitives are necessary. Julia offers &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; that creates a new task from &lt;code&gt;func&lt;/code&gt;, binds it to a new channel of type &lt;code&gt;ctype&lt;/code&gt; and size &lt;code&gt;csize&lt;/code&gt; and schedule the task. &lt;code&gt;Channels&lt;/code&gt; can serve as a way to communicate between tasks, as &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; creates a buffered channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;sz&lt;/code&gt;. Whenever code performs a communication operation like &lt;code&gt;fetch&lt;/code&gt; or &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.</source>
          <target state="translated">Платформа параллельного программирования Джулии использует &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;задачи (также известные как сопрограммы)&lt;/a&gt; для переключения между несколькими вычислениями. Чтобы выразить порядок выполнения между легковесными потоками, необходимы примитивы связи. Джулия предлагает &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; который создает новую задачу из &lt;code&gt;func&lt;/code&gt; , связывает ее с новым каналом типа &lt;code&gt;ctype&lt;/code&gt; и размером &lt;code&gt;csize&lt;/code&gt; и планирует задачу. &lt;code&gt;Channels&lt;/code&gt; могут служить средством связи между задачами, поскольку &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; создает буферизованный канал типа &lt;code&gt;T&lt;/code&gt; и размера &lt;code&gt;sz&lt;/code&gt; . Всякий раз, когда код выполняет операцию связи, такую ​​как &lt;code&gt;fetch&lt;/code&gt; или&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , текущая задача приостанавливается, и планировщик выбирает другую задачу для запуска. Задача перезапускается, когда событие, которого она ожидает, завершается.</target>
        </trans-unit>
        <trans-unit id="8fbc199e2173262fbbf9a789a4bc09af6495b0ec" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b466bf8ce3736bba15b2ecdae9872de461ea3a56" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">Система продвижения Джулии заставляет арифметические операции со смесями типов аргументов &quot;просто работать&quot; естественно и автоматически. См. &amp;laquo; &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Преобразование и продвижение&amp;raquo;&lt;/a&gt; для получения подробной информации о системе продвижения.</target>
        </trans-unit>
        <trans-unit id="34b8049f71f2dca17e15f3a691f349cd09ad4d7f" translate="yes" xml:space="preserve">
          <source>Julia's range indexing has the format of &lt;code&gt;x[start:step:stop]&lt;/code&gt;, whereas Python's format is &lt;code&gt;x[start:(stop+1):step]&lt;/code&gt;. Hence, &lt;code&gt;x[0:10:2]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[1:2:10]&lt;/code&gt; in Julia. Similarly, &lt;code&gt;x[::-1]&lt;/code&gt; in Python, which refers to the reversed array, is equivalent to &lt;code&gt;x[end:-1:1]&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c3a6166fa4f354bffc12e579d7219f7b110624c" translate="yes" xml:space="preserve">
          <source>Julia's single quotes enclose characters, not strings.</source>
          <target state="translated">Одиночные кавычки Джулии содержат символы,а не строки.</target>
        </trans-unit>
        <trans-unit id="5826232507a46053a3ad6eca3433bcfcdddedfd4" translate="yes" xml:space="preserve">
          <source>Julia's slice indexing includes the last element, unlike in Python. &lt;code&gt;a[2:3]&lt;/code&gt; in Julia is &lt;code&gt;a[1:3]&lt;/code&gt; in Python.</source>
          <target state="translated">В отличие от Python, индексирование срезов Джулии включает последний элемент. &lt;code&gt;a[2:3]&lt;/code&gt; в Julia - &lt;code&gt;a[1:3]&lt;/code&gt; в Python.</target>
        </trans-unit>
        <trans-unit id="d3f2b1b2df721c7080cd008996870d53e3376216" translate="yes" xml:space="preserve">
          <source>Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</source>
          <target state="translated">Система типа Julia разработана,чтобы быть мощной и выразительной,но в то же время понятной,интуитивной и ненавязчивой.Многие программисты Julia могут никогда не почувствовать необходимость писать код,который явно использует типы.Некоторые виды программирования,однако,становятся яснее,проще,быстрее и надежнее с объявленными типами.</target>
        </trans-unit>
        <trans-unit id="328e404443e1e3ee36bbd28ef0bec3925e10b36e" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2601bca815fd3b23be75d3eb7a5f70824d2baba0" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">Система типов Джулии является динамической, но получает некоторые преимущества систем статических типов, позволяя указывать, что определенные значения относятся к определенным типам. Это может оказаться большим подспорьем в создании эффективного кода, но, что еще более важно, позволяет диспетчеру методов для типов аргументов функции быть глубоко интегрированными с языком. Диспетчеризация &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;методов&lt;/a&gt; подробно рассматривается в разделе &quot; Методы&quot; , но она основана на представленной здесь системе типов.</target>
        </trans-unit>
        <trans-unit id="452075601195cf61defe5474343bae547d7dc931" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060a807b9436918cd4c19176ffcd9bf4c0ffdec4" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Операторы обновления Джулии (например, &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , ...) &lt;em&gt;не на месте,&lt;/em&gt; тогда как NumPy. Это означает, что &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; не изменяет значения в &lt;code&gt;A&lt;/code&gt; , а скорее повторно связывает имя &lt;code&gt;B&lt;/code&gt; с результатом правой части &lt;code&gt;B = B + 3&lt;/code&gt; , которая является новым массивом. Для работы на месте используйте &lt;code&gt;B .+= 3&lt;/code&gt; (см. Также &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;точечные операторы&lt;/a&gt; ), явные циклы или &lt;code&gt;InplaceOps.jl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd01ffb3135bea5db94d9c0cd4c8376ed4d4ff72" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29157447971e1b4b6b81d91fd76c285c2b275482" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">Julia, как и большинство технических языков программирования, предоставляет первоклассную реализацию массива. Большинство языков технических вычислений уделяют много внимания реализации своих массивов за счет других контейнеров. Юля не обрабатывает массивы как-то особым образом. Библиотека массивов почти полностью реализована в самой Julia, а производительность зависит от компилятора, как и любой другой код, написанный на Julia. Таким образом, также можно определять настраиваемые типы массивов, унаследовав от &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; . См. &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Раздел руководства по интерфейсу AbstractArray&lt;/a&gt; для получения дополнительных сведений о реализации настраиваемого типа массива.</target>
        </trans-unit>
        <trans-unit id="88d1577dcc4f245ab6ce133765fe78bb8913aa7f" translate="yes" xml:space="preserve">
          <source>Jupiter</source>
          <target state="translated">Jupiter</target>
        </trans-unit>
        <trans-unit id="baa896b33786524acff2009a8d27bd6b3009cef2" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;^R&lt;/code&gt; is a reverse search, &lt;code&gt;^S&lt;/code&gt; is a forward search, with the prompt &lt;code&gt;(i-search)`':&lt;/code&gt;. The two may be used in conjunction with each other to move through the previous or next matching results, respectively.</source>
          <target state="translated">Подобно тому, как &lt;code&gt;^R&lt;/code&gt; - обратный поиск, &lt;code&gt;^S&lt;/code&gt; - прямой поиск с подсказкой &lt;code&gt;(i-search)`':&lt;/code&gt; . Эти два могут использоваться вместе друг с другом для перемещения по предыдущему или следующему результату сопоставления соответственно.</target>
        </trans-unit>
        <trans-unit id="9365c41bee7315e2eb3ab59d3b982ca7ca4bb4b9" translate="yes" xml:space="preserve">
          <source>Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as &lt;code&gt;?&lt;/code&gt; entered help mode when at the beginning of the line, a semicolon (&lt;code&gt;;&lt;/code&gt;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">Так же, как режим справки полезен для быстрого доступа к документации, другой распространенной задачей является использование системной оболочки для выполнения системных команд. Просто как &lt;code&gt;?&lt;/code&gt; вошел в режим справки, когда в начале строки точка с запятой ( &lt;code&gt;;&lt;/code&gt; ) войдет в режим оболочки. И из него можно выйти, нажав клавишу возврата в начале строки.</target>
        </trans-unit>
        <trans-unit id="456f4e9fab32e1339e01f38c693667415e6a7374" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e330a59e23d168a0ce147528d526c6c70e235165" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Так же, как в &lt;a href=&quot;#man-array-indexing-1&quot;&gt;индексировании&lt;/a&gt; , ключевое слово &lt;code&gt;end&lt;/code&gt; может использоваться для представления последнего индекса каждого измерения в скобках индексации, как это определяется размером массива, которому назначается. Синтаксис индексированного присваивания без ключевого слова &lt;code&gt;end&lt;/code&gt; эквивалентен вызову &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="129fdfb9651f86a9c5a6d204baf7fd51a6f897e9" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">Подобно тому, как вывод текста выполняется с помощью &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; а пользовательские типы могут указывать свое текстовое представление путем перегрузки &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; , Julia предоставляет стандартизированный механизм для вывода мультимедийных данных (например, изображений, форматированного текста или даже аудио и видео), состоящего из трех частей. :</target>
        </trans-unit>
        <trans-unit id="03d45fce37a205fcf4faeb89d82409711b9d7cca" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c6961e570c4d224922a2a92f75eca4d8e9afac" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31418705dc05a56f9681110f63d545eb15e8a22" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">Так же, как вы можете установить ограничения подтипа на параметры типа в объявлениях типа (см. &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Параметрические типы&lt;/a&gt; ), вы также можете ограничить параметры типа методов:</target>
        </trans-unit>
        <trans-unit id="3a5b8319210d6e829092640e9c9931c8b6b93159" translate="yes" xml:space="preserve">
          <source>Just like condition expressions used in &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt; or the ternary operator, the operands of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; must be boolean values (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:</source>
          <target state="translated">Подобно выражениям условий, используемым в &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elseif&lt;/code&gt; или тернарном операторе, операнды &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; или &lt;code&gt;||&lt;/code&gt; должны быть логическими значениями ( &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; ). Использование не-логического значения где угодно, кроме последней записи в условной цепочке, является ошибкой:</target>
        </trans-unit>
        <trans-unit id="89b905a2ec6630efe24e67a128976a957febd0eb" translate="yes" xml:space="preserve">
          <source>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</source>
          <target state="translated">Синтаксис сопоставленных литеральных коэффициентов может конфликтовать с двумя синтаксисами числовых литералов:шестнадцатеричными целыми литералами и инженерной нотацией для литералов с плавающей точкой.Вот некоторые ситуации,в которых возникают синтаксические конфликты:</target>
        </trans-unit>
        <trans-unit id="9ec40672083b66df6ef7fbca9db99f5cc01dc9d5" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">Имейте в виду, что некоторые функции Julia в настоящее время не поддерживаются CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; , особенно некоторые функции, такие как &lt;code&gt;sin&lt;/code&gt; , нужно будет заменить на &lt;code&gt;CUDAnative.sin&lt;/code&gt; (cc: @maleadt).</target>
        </trans-unit>
        <trans-unit id="ed1dc2aa59f2bcc19af822ca3015689f0776b65a" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="2f019ec46ab9548a295fae40fb32bbf280932bb8" translate="yes" xml:space="preserve">
          <source>Key bindings</source>
          <target state="translated">Крепления для ключей</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="23f6f8047d85e8db9b2a5eaadf76de7dfe565d74" translate="yes" xml:space="preserve">
          <source>Keybinding</source>
          <target state="translated">Keybinding</target>
        </trans-unit>
        <trans-unit id="59ba1e5a90c9cfee0b263032ac6574298fc3c42e" translate="yes" xml:space="preserve">
          <source>Keycap Ten</source>
          <target state="translated">Кейкэп-10</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="db32172db3cd21ae36313d815fba0dd39bd7127a" translate="yes" xml:space="preserve">
          <source>Keyword Arguments</source>
          <target state="translated">Ключевое слово Аргументы</target>
        </trans-unit>
        <trans-unit id="37a1398f40ad5a5758f3118ecb2e0028c1f656ac" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; or &lt;code&gt;:none&lt;/code&gt; (default), to specify the verbosity of code comments.</source>
          <target state="translated">Аргумент &lt;code&gt;debuginfo&lt;/code&gt; слова debuginfo может принимать одно из &lt;code&gt;:source&lt;/code&gt; значений : source или &lt;code&gt;:none&lt;/code&gt; (по умолчанию), чтобы указать подробность комментариев кода.</target>
        </trans-unit>
        <trans-unit id="64ff3dfa226c767a3f6429283e3a4ecc260532b6" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;init&lt;/code&gt; is added in Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eec148d4683d6a5be8244fa8544e4bc73995042" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;lazy=true|false&lt;/code&gt; only affects &lt;code&gt;topology&lt;/code&gt; option &lt;code&gt;:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for &lt;code&gt;lazy&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;code&gt;:all_to_all&lt;/code&gt; слова &lt;code&gt;lazy=true|false&lt;/code&gt; влияет только на параметр &lt;code&gt;topology&lt;/code&gt; : all_to_all . Если &lt;code&gt;true&lt;/code&gt; , кластер запускается с мастером, подключенным ко всем рабочим. Конкретные соединения рабочий-рабочий устанавливаются при первом удаленном вызове между двумя рабочими. Это помогает уменьшить начальные ресурсы, выделяемые для внутрикластерной связи. Соединения настраиваются в зависимости от требований времени выполнения параллельной программы. Значение по умолчанию для &lt;code&gt;lazy&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a85841ebcc4fbb3f6bb0af53f5f74a1d1107441b" translate="yes" xml:space="preserve">
          <source>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</source>
          <target state="translated">Значения аргумента ключевого слова по умолчанию вычисляются только при необходимости (когда соответствующий аргумент ключевого слова не передан),и в порядке слева направо.Поэтому выражения по умолчанию могут ссылаться на предыдущие аргументы ключевых слов.</target>
        </trans-unit>
        <trans-unit id="cd222673b8a5eeb28c17fea40269820af080e4d5" translate="yes" xml:space="preserve">
          <source>Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</source>
          <target state="translated">Ключевые аргументы ведут себя совсем не так,как обычные позиционные аргументы.В частности,они не участвуют в диспетчеризации методов.Методы рассылаются только на основе позиционных аргументов,при этом аргументы ключевых слов обрабатываются после идентификации метода соответствия.</target>
        </trans-unit>
        <trans-unit id="a802505edaa907c65ced69e373b2128c6752ff80" translate="yes" xml:space="preserve">
          <source>Keyword arguments can also be used in varargs functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f80b2c92c551f95f3994cdc90a44e035d56013" translate="yes" xml:space="preserve">
          <source>Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Аргументы ключевого слова, если таковые имеются, передаются в &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8804a97595c6605af997f797488e9f7a887cea7" translate="yes" xml:space="preserve">
          <source>Keyword arguments:</source>
          <target state="translated">Ключевые аргументы:</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e42f478ffbc394a252424af959d3abd0a98e41e6" translate="yes" xml:space="preserve">
          <source>Keywords are also displayed in the suggested methods after &lt;code&gt;;&lt;/code&gt;, see below line where &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;keepempty&lt;/code&gt; are keyword arguments:</source>
          <target state="translated">Ключевые слова также отображаются в предлагаемых методах после &lt;code&gt;;&lt;/code&gt; см. строку ниже, где &lt;code&gt;limit&lt;/code&gt; и &lt;code&gt;keepempty&lt;/code&gt; являются аргументами ключевого слова:</target>
        </trans-unit>
        <trans-unit id="924acc699e5835f0f13e0c55c14fdfbfa6ba40d8" translate="yes" xml:space="preserve">
          <source>Kimono</source>
          <target state="translated">Kimono</target>
        </trans-unit>
        <trans-unit id="4dbc43957024c86f07374b147dcca5a43c62318b" translate="yes" xml:space="preserve">
          <source>Kiss</source>
          <target state="translated">Kiss</target>
        </trans-unit>
        <trans-unit id="23d1162dbd548a5b7ebb3cb6c2092223a1165283" translate="yes" xml:space="preserve">
          <source>Kiss Mark</source>
          <target state="translated">Поцелуй Марка</target>
        </trans-unit>
        <trans-unit id="bc19b3dfb9379c314c1b8e3bb9dc5e6a2b26f09b" translate="yes" xml:space="preserve">
          <source>Kissing Cat Face With Closed Eyes</source>
          <target state="translated">Целующая кошачья морда с закрытыми глазами</target>
        </trans-unit>
        <trans-unit id="b58aa4e85bf24740360e2d6b347305a564dca4a1" translate="yes" xml:space="preserve">
          <source>Kissing Face</source>
          <target state="translated">Целующееся лицо</target>
        </trans-unit>
        <trans-unit id="2fe6ec1bfe77e7354379b52c0bee899a96c21add" translate="yes" xml:space="preserve">
          <source>Kissing Face With Closed Eyes</source>
          <target state="translated">Целующее лицо с закрытыми глазами</target>
        </trans-unit>
        <trans-unit id="fcaff6a193904e107dc7d4aa4f3190493c405457" translate="yes" xml:space="preserve">
          <source>Kissing Face With Smiling Eyes</source>
          <target state="translated">Целующее лицо с улыбающимися глазами</target>
        </trans-unit>
        <trans-unit id="74ae77190d30e9483b1024a2bf19d64715a77757" translate="yes" xml:space="preserve">
          <source>Koala</source>
          <target state="translated">Koala</target>
        </trans-unit>
        <trans-unit id="9afe7e71a0cd3f5b45d3038779f47e6ab11c4a9d" translate="yes" xml:space="preserve">
          <source>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi:10.1109/29.1585&lt;/a&gt;</source>
          <target state="translated">Константинос Константинидес и Кунг Яо, &amp;laquo;Статистический анализ эффективных сингулярных значений при определении ранга матрицы&amp;raquo;, IEEE Transactions по акустике, обработке речи и сигналов, 36 (5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;DOI: 10,1109 / 29,1585&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4a94c6e095d242bfd65b4080bf588284c946f8c" translate="yes" xml:space="preserve">
          <source>Kronecker tensor product of two vectors or two matrices.</source>
          <target state="translated">Тензор Kronecker изготовлен из двух векторов или двух матриц.</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="d4e9710203cf5806e211a4382bda892c104cc46d" translate="yes" xml:space="preserve">
          <source>LAPACK Functions</source>
          <target state="translated">Функции LAPACK</target>
        </trans-unit>
        <trans-unit id="d12a2cf0b16bda2d0e8799f01c41ee6d60d4d6a5" translate="yes" xml:space="preserve">
          <source>LAPACK functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f1b6f39a46d5337c0aad867bbe073b5b049053" translate="yes" xml:space="preserve">
          <source>LDL(T) factorization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4aff6bdb4998cc3553c7001845a94833e9f4e43" translate="yes" xml:space="preserve">
          <source>LDLt (see &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LDLt (см. &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt; &lt;code&gt;ldlt&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="26214decf703290192f10270d6b0b515c7511762" translate="yes" xml:space="preserve">
          <source>LLVM Interface</source>
          <target state="translated">LLVM-интерфейс</target>
        </trans-unit>
        <trans-unit id="f5f4f14ed2c38473c6c2d9123249c93ff3ece227" translate="yes" xml:space="preserve">
          <source>LOAD_PATH</source>
          <target state="translated">LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="160e7ef90659bedaf209eec44edbbe3caf988121" translate="yes" xml:space="preserve">
          <source>LU (see &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LU (см. &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="23dbe335a346e4f78af48a087f0c1292440d8cc7" translate="yes" xml:space="preserve">
          <source>LU factorization</source>
          <target state="translated">факторизация LU</target>
        </trans-unit>
        <trans-unit id="a905567226043f1b393e816a77aec998343c78b4" translate="yes" xml:space="preserve">
          <source>LU factorization for &lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; matrices</source>
          <target state="translated">Факторизация LU для &lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt; матриц</target>
        </trans-unit>
        <trans-unit id="366152a7d098555665a4453404d639ac8b476b7a" translate="yes" xml:space="preserve">
          <source>Labels a statement with the symbolic label &lt;code&gt;name&lt;/code&gt;. The label marks the end-point of an unconditional jump with &lt;a href=&quot;#Base.@goto&quot;&gt;&lt;code&gt;@goto name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Отмечает утверждение символьным &lt;code&gt;name&lt;/code&gt; метки . Метка отмечает конечную точку безусловного перехода с &lt;a href=&quot;#Base.@goto&quot;&gt; &lt;code&gt;@goto name&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8f52e27fbdf435514705d351e8d01e3dd57b73" translate="yes" xml:space="preserve">
          <source>Lady Beetle</source>
          <target state="translated">Леди Жук</target>
        </trans-unit>
        <trans-unit id="4dee08e75e78fb7f2ea26537626acf062390bc00" translate="yes" xml:space="preserve">
          <source>Large $\LaTeX$ equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the &quot;language&quot; &lt;code&gt;math&lt;/code&gt; as in the example below.</source>
          <target state="translated">Большие уравнения $ \ LaTeX $, которые не помещаются в строку внутри абзаца, могут быть записаны как уравнения отображения с использованием изолированного блока кода с &lt;code&gt;math&lt;/code&gt; &amp;laquo;языка&amp;raquo;, как в примере ниже.</target>
        </trans-unit>
        <trans-unit id="8f95211a940e3d08b42c29bbf9dbc496ccfe208b" translate="yes" xml:space="preserve">
          <source>Large Blue Circle</source>
          <target state="translated">Большой синий круг</target>
        </trans-unit>
        <trans-unit id="68e7dfd86e1bad5177b243cce59909605d2d63ff" translate="yes" xml:space="preserve">
          <source>Large Blue Diamond</source>
          <target state="translated">Большой голубой бриллиант</target>
        </trans-unit>
        <trans-unit id="1489faea46cdb0a914888faa83aaccbf1a1018b6" translate="yes" xml:space="preserve">
          <source>Large Circle</source>
          <target state="translated">Большой круг</target>
        </trans-unit>
        <trans-unit id="47d39efcf737a8cb7cff31b45c3eae3b9768a070" translate="yes" xml:space="preserve">
          <source>Large Down Tack</source>
          <target state="translated">Large Down Tack</target>
        </trans-unit>
        <trans-unit id="19d1a6d4bde006ab21ff3b1a9ce0c5b1f656efbe" translate="yes" xml:space="preserve">
          <source>Large Orange Diamond</source>
          <target state="translated">Большой Оранжевый Алмаз</target>
        </trans-unit>
        <trans-unit id="2be06620aa858eeb1cfd65e452ba545d7194c263" translate="yes" xml:space="preserve">
          <source>Large Red Circle</source>
          <target state="translated">Большой красный круг</target>
        </trans-unit>
        <trans-unit id="93780c9bf758bfc5b064c94682265b362eac13d6" translate="yes" xml:space="preserve">
          <source>Large Up Tack</source>
          <target state="translated">Large Up Tack</target>
        </trans-unit>
        <trans-unit id="c567cf1fe685a9b85ba876a5fdec9645963ce55b" translate="yes" xml:space="preserve">
          <source>Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</source>
          <target state="translated">Загрузка больших модулей может занять несколько секунд,так как выполнение всех операторов в модуле часто связано с компиляцией большого количества кода.Джулия создает прекомпилированные кэши модуля,чтобы сократить это время.</target>
        </trans-unit>
        <trans-unit id="836cd86751bc175f6a1c3513d9545f0269900a32" translate="yes" xml:space="preserve">
          <source>Larger Than</source>
          <target state="translated">Больше,чем</target>
        </trans-unit>
        <trans-unit id="8fc4e576fc574f75bb7c600973def67858d8bb40" translate="yes" xml:space="preserve">
          <source>Larger Than Or Equal To</source>
          <target state="translated">Больше,чем или равнозначно</target>
        </trans-unit>
        <trans-unit id="d737eee8172d65bba64271f9c8b335b8b815d284" translate="yes" xml:space="preserve">
          <source>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</source>
          <target state="translated">Большие целые литералы,которые не могут быть представлены,используя только 32 бита,но могут быть представлены в 64 бита,всегда создают 64-битные целые числа,независимо от системного типа:</target>
        </trans-unit>
        <trans-unit id="2c5201c8ea16b6383c4f6c269ee86f7c5d37bb84" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">Наибольшее целое число, меньшее или равное &lt;code&gt;x/y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1b42ea4b0b1e511fffb01ce016fa0bdcff72dd5" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;. Equivalent to &lt;code&gt;div(x, y, RoundDown)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e54723a9bf0cd3ba0bd2155ce7b7bac5bfafd9" translate="yes" xml:space="preserve">
          <source>Largest value</source>
          <target state="translated">Наибольшее значение</target>
        </trans-unit>
        <trans-unit id="af72fbc94064a4c9a0a644731e497dc5dc7beff9" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon</source>
          <target state="translated">последний квартал Луны</target>
        </trans-unit>
        <trans-unit id="4d7f319a09451056e084d65cad158f125e2020cc" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon Symbol</source>
          <target state="translated">Символ последней четверти Луны</target>
        </trans-unit>
        <trans-unit id="a7b4069351f71ce4f08da44121a5414042cbca4b" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon With Face</source>
          <target state="translated">Последний квартал Луна с лицом</target>
        </trans-unit>
        <trans-unit id="18cf37d7758974150aba5efc169a132701c98591" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring</source>
          <target state="translated">Латинская заглавная буква А с кольцом выше/латинская заглавная буква А кольцо</target>
        </trans-unit>
        <trans-unit id="387186c7a8fff866e6fbacb8a7a99c078e963118" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Ae / Latin Capital Letter A E</source>
          <target state="translated">Латинская заглавная буква Ae/латинская заглавная буква A E</target>
        </trans-unit>
        <trans-unit id="f2c0864bdd70eeadaffc0e4bf8122d6178ff53bb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter D With Stroke / Latin Capital Letter D Bar</source>
          <target state="translated">Латинская заглавная буква D с помощью штриха/латинской заглавной буквы D Bar</target>
        </trans-unit>
        <trans-unit id="18ee11f5dfc96b5ea1e522af1744aced409d9ff1" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eng</source>
          <target state="translated">латинская заглавная буква англ.</target>
        </trans-unit>
        <trans-unit id="7e38029cb2d0c6ce87bf45f5170886022a280556" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eth</source>
          <target state="translated">Латинская заглавная буква Эт</target>
        </trans-unit>
        <trans-unit id="261b92b2c69498043ebd035666aae447dd5fc40c" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter L With Stroke / Latin Capital Letter L Slash</source>
          <target state="translated">Латинская заглавная буква L с инсультом/латинская заглавная буква L косой чертой</target>
        </trans-unit>
        <trans-unit id="81f5aedd8e8fccac1ab8a6bc67c43be5b7c7e7f6" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter O With Stroke / Latin Capital Letter O Slash</source>
          <target state="translated">Латинская заглавная буква O с инсультом/латинская заглавная буква O косой чертой</target>
        </trans-unit>
        <trans-unit id="3e1d1bce5c9a11240957721f8ef29a635e048ab3" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Thorn</source>
          <target state="translated">Латинская заглавная буква Торн</target>
        </trans-unit>
        <trans-unit id="4b4cf2ef98d43801be6875ab83c9e3c993eddbbb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar</source>
          <target state="translated">Латинская заглавная буква Z с штрихом/латинская заглавная буква Z Бар</target>
        </trans-unit>
        <trans-unit id="5ae3e818634045d7a9130d2b676f3527521e0150" translate="yes" xml:space="preserve">
          <source>Latin Capital Ligature Oe / Latin Capital Letter O E</source>
          <target state="translated">Латинская заглавная лигатура Oe/латинская заглавная буква O E</target>
        </trans-unit>
        <trans-unit id="957520bb4ae3c78ec831bd317cdfd85081025ee6" translate="yes" xml:space="preserve">
          <source>Latin Letter Alveolar Click / Latin Letter Pipe Double Bar</source>
          <target state="translated">Латинская буква Alveolar Нажмите кнопку/латинская буква трубы двойной бар</target>
        </trans-unit>
        <trans-unit id="43073b60cf8171df59d1497357356aa7115c7db3" translate="yes" xml:space="preserve">
          <source>Latin Letter Glottal Stop</source>
          <target state="translated">Латинская буква Глотальная остановка</target>
        </trans-unit>
        <trans-unit id="fc36244b6362ae3e3d6d20e2d335c02a7af88997" translate="yes" xml:space="preserve">
          <source>Latin Letter Inverted Glottal Stop</source>
          <target state="translated">Инвертированная латинская буква Glottal Stop</target>
        </trans-unit>
        <trans-unit id="680f41038e731ff5fdc7bf24ce99313a70d99990" translate="yes" xml:space="preserve">
          <source>Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop</source>
          <target state="translated">Латинская буква Голос глотки Fricative/латинская буква Reversed Glottal Stop</target>
        </trans-unit>
        <trans-unit id="7e9e2bfa072cd28ac12f89b807c22a2d9b6b5f07" translate="yes" xml:space="preserve">
          <source>Latin Small Letter A With Ring Above / Latin Small Letter A Ring</source>
          <target state="translated">Латинская маленькая буква А с кольцом выше/латинская маленькая буква А кольцо</target>
        </trans-unit>
        <trans-unit id="aeaa4f1f1687667c2f5fc22a10bca6a0268c7e52" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ae / Latin Small Letter A E</source>
          <target state="translated">Маленькая латинская буква Ae/Маленькая латинская буква A E</target>
        </trans-unit>
        <trans-unit id="bd81bee974151364620b17177c4955612e0e03fa" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Closed Omega</source>
          <target state="translated">Маленькая латинская буква Закрытая Омега</target>
        </trans-unit>
        <trans-unit id="c4abfd40c74b3eb74040658788c6847cb7128777" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Stroke / Latin Small Letter D Bar</source>
          <target state="translated">Маленькая латинская буква D с штрихом/латинская маленькая буква D Bar</target>
        </trans-unit>
        <trans-unit id="79664c84e38ddc705c095d22df17f6ba110cb657" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook</source>
          <target state="translated">Латинская маленькая буква D с хвостом/латинская маленькая буква D ретрофлекс крюк</target>
        </trans-unit>
        <trans-unit id="0bae965510de34e4507ca1c9f6442e6f063065a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh</source>
          <target state="translated">Латинская Маленькая Буква Деж Цифровой График/латинская Маленькая Буква D Yogh</target>
        </trans-unit>
        <trans-unit id="93c7ebd3f43b49c98f8c0737391432699e082aa6" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless I</source>
          <target state="translated">Маленькая латинская буква без точек.</target>
        </trans-unit>
        <trans-unit id="0639f709a04d29a7d92f491504f4b15becbc375e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless J</source>
          <target state="translated">Маленькая латинская буква Dotless J</target>
        </trans-unit>
        <trans-unit id="cf365327a81aadb5e405df4d0f48b32472c24b2e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eng</source>
          <target state="translated">Маленькая латинская буква Eng</target>
        </trans-unit>
        <trans-unit id="93c2ec38cecdf8e443b85db5de563a216ffd9d34" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Esh</source>
          <target state="translated">латинская буква Small Letter Esh</target>
        </trans-unit>
        <trans-unit id="2e8a26241b482f37e00adb250b979246ca85beea" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eth</source>
          <target state="translated">Маленькая латинская буква Эт</target>
        </trans-unit>
        <trans-unit id="40104027bfc2f3a58be7509f94be97c17e39f2f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ezh / Latin Small Letter Yogh</source>
          <target state="translated">Латинская маленькая буква Ezh/латинская маленькая буква Yogh</target>
        </trans-unit>
        <trans-unit id="f9e515806fd1b60b14e5fc8f3af7f90ac6e9364a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Gamma</source>
          <target state="translated">Гамма из латинских букв</target>
        </trans-unit>
        <trans-unit id="97085caf81a24ef927fdc386fc6b04e27e1f72b9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter H With Stroke / Latin Small Letter H Bar</source>
          <target state="translated">Маленькая латинская буква H с штрихом/латинская маленькая буква H Bar</target>
        </trans-unit>
        <trans-unit id="399d282443390fef914db664bba2883747b928af" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Hv / Latin Small Letter H V</source>
          <target state="translated">Латинская маленькая буква Hv/латинская маленькая буква H V</target>
        </trans-unit>
        <trans-unit id="2422e4f11c03b366715aa80ec860fc60eae0c461" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Belt / Latin Small Letter L Belt</source>
          <target state="translated">Маленькая латинская буква L с поясом/латинская маленькая буква L поясом</target>
        </trans-unit>
        <trans-unit id="82d31c79255d3b522eb37fa11b7bb67ebf6d75a1" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook</source>
          <target state="translated">Латинская буква L с ретрофлексным крючком/латинская буква L ретрофлексный крючок</target>
        </trans-unit>
        <trans-unit id="432e37bd3e31540f66f1af3dfdcfd97516ca52f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Stroke / Latin Small Letter L Slash</source>
          <target state="translated">Латинская маленькая буква L с инсультом/латинская маленькая буква L косой чертой</target>
        </trans-unit>
        <trans-unit id="c6dc1b09cb591ac95922c661ff9481278d4d2de7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter M With Hook / Latin Small Letter M Hook</source>
          <target state="translated">Маленькая латинская буква М с крючком/латинская маленькая буква М крючок</target>
        </trans-unit>
        <trans-unit id="0218525707cb4bb564235a036cc2842ec67b0748" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Left Hook / Latin Small Letter N Hook</source>
          <target state="translated">Латинская маленькая буква N с левым крючком/латинская маленькая буква N крючок</target>
        </trans-unit>
        <trans-unit id="b20690f24cf5bf99ca0c7018eee110ebe0e15a04" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Long Right Leg</source>
          <target state="translated">Маленькая латинская буква N с длинной правой ножкой</target>
        </trans-unit>
        <trans-unit id="31ec66aaa00a79d775f1c857d59f5c7a74247d09" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook</source>
          <target state="translated">Латинская маленькая буква N с ретрофлексным крючком/латинская маленькая буква N ретрофлексный крючок</target>
        </trans-unit>
        <trans-unit id="7874ede875d3c7ae94e73df07ed062477861ae44" translate="yes" xml:space="preserve">
          <source>Latin Small Letter O With Stroke / Latin Small Letter O Slash</source>
          <target state="translated">Латинская маленькая буква O с инсультом/латинская маленькая буква O косой чертой</target>
        </trans-unit>
        <trans-unit id="07add9523a52497c0c262c0382ad46de39eb16bd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Open O</source>
          <target state="translated">Маленькая латинская буква Открыть O</target>
        </trans-unit>
        <trans-unit id="1b7b0f5e96e58726dfbb7a30f8602204b9a71f82" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Phi</source>
          <target state="translated">Маленькая латинская буква Фи</target>
        </trans-unit>
        <trans-unit id="ff12afa374c372c8fc23589cff50c4ee6f2f6cde" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R</source>
          <target state="translated">Латинская маленькая буква R с рыбьим крючком/латинская маленькая буква рыбьим крючком R</target>
        </trans-unit>
        <trans-unit id="591234998559d2fb9e34782769a6a85e552ca14a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Long Leg</source>
          <target state="translated">Маленькая латинская буква R с длинной ногой</target>
        </trans-unit>
        <trans-unit id="c1a50f7f5584c407c2b721281ea3abe4e34d13d4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Tail / Latin Small Letter R Hook</source>
          <target state="translated">Латинская маленькая буква R с хвостом/латинская маленькая буква R крючок</target>
        </trans-unit>
        <trans-unit id="ef19cd34955161980d339367d254aafdd02b4cb7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma</source>
          <target state="translated">Латинская Маленькая Буква Рамс Горн/Латинская Маленькая Буква Детская Гамма</target>
        </trans-unit>
        <trans-unit id="bf1d74257f1f62e2e52e3dc8b76fe85f6a2c3e96" translate="yes" xml:space="preserve">
          <source>Latin Small Letter S With Hook / Latin Small Letter S Hook</source>
          <target state="translated">Латинская маленькая буква S с крючком/латинская маленькая буква S крючок</target>
        </trans-unit>
        <trans-unit id="f17b9219c1288784e62e066762b90b3f1e0e55a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Schwa</source>
          <target state="translated">Маленькая латинская буква Шва</target>
        </trans-unit>
        <trans-unit id="19e904077d5fb0771a0c4bf22aebcb8d18879d02" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Sharp S</source>
          <target state="translated">Маленькая латинская буква S</target>
        </trans-unit>
        <trans-unit id="4e3c130c920943099dd727660677e4cfb89ea723" translate="yes" xml:space="preserve">
          <source>Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook</source>
          <target state="translated">Латинская маленькая буква Т с ретрофлексным крючком/латинская маленькая буква Т ретрофлексный крючок</target>
        </trans-unit>
        <trans-unit id="b4aa5dce4f194d4f86cea8db7ef720a452c10472" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Tesh Digraph / Latin Small Letter T Esh</source>
          <target state="translated">Латинская Маленькая Буква Тэш Цифровой График/Латинская Маленькая Буква Т Тэш</target>
        </trans-unit>
        <trans-unit id="9a88a6a40f3264cff644fc36d6ea39b7e80dee4b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Thorn</source>
          <target state="translated">латинская буква &quot;Торн</target>
        </trans-unit>
        <trans-unit id="206fdfa3558c503d9e843533aa39ca8750c5100a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned A</source>
          <target state="translated">Маленькая латинская буква превратилась в букву A</target>
        </trans-unit>
        <trans-unit id="44391e675633f27178e360e38182fb1c89dcc786" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A</source>
          <target state="translated">Латинская Маленькая буква Перевёрнутый Альфа/латинская Маленькая буква Перевёрнутый Шрифт A</target>
        </trans-unit>
        <trans-unit id="a45dfaa69d6b3db6daa54b07a19c0a16bc93f9c4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned H</source>
          <target state="translated">Маленькая латинская буква H</target>
        </trans-unit>
        <trans-unit id="d0a8378f24aaa4a7fd08ad76eab02d85f9db34c3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned K</source>
          <target state="translated">Маленькая латинская буква,повернутая K</target>
        </trans-unit>
        <trans-unit id="f60605b6d90f4154d38bac9031c2a73d3e7fb2fd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M</source>
          <target state="translated">Маленькая латинская буква М</target>
        </trans-unit>
        <trans-unit id="80870744996553dd1a355c5c68035612071c93d5" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M With Long Leg</source>
          <target state="translated">Маленькая латинская буква превратила M с длинной ножкой</target>
        </trans-unit>
        <trans-unit id="4e330127b9bd74c3ac0ed39785e51192a2a6804b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R</source>
          <target state="translated">Маленькая латинская буква,повернутая R</target>
        </trans-unit>
        <trans-unit id="7f2283c2045b7461f57d11ba1b67518361b943d3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook</source>
          <target state="translated">Латинская маленькая буква превратилась R с крючком/латинская маленькая буква превратилась R крюк</target>
        </trans-unit>
        <trans-unit id="78ca75233c25b210f82d0fa683b1e829340273d9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Long Leg</source>
          <target state="translated">Латинская маленькая буква повернула R с длинной ногой</target>
        </trans-unit>
        <trans-unit id="b693ad995bba90f1295c3eb3fa51e43c784b64eb" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned T</source>
          <target state="translated">Маленькая латинская буква T</target>
        </trans-unit>
        <trans-unit id="5209a0d49366580ead3e1dad9d6ff2475775f51f" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned V</source>
          <target state="translated">Маленькая латинская буква,повернутая V</target>
        </trans-unit>
        <trans-unit id="450f985cc65d78122edf815571e08094f13be358" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned W</source>
          <target state="translated">Маленькая латинская буква,повернутая W</target>
        </trans-unit>
        <trans-unit id="d4b68356f1e5f3312b5bc8059eb8f75757a7c22d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Y</source>
          <target state="translated">Маленькая латинская буква повернулась Y</target>
        </trans-unit>
        <trans-unit id="1c50afa8247e2b596bb5484c0bdf31af4356cb8d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Upsilon</source>
          <target state="translated">латинская Маленькая буква Упсилон</target>
        </trans-unit>
        <trans-unit id="cf80e9e2586cd62109287c1d07560fe914a80d16" translate="yes" xml:space="preserve">
          <source>Latin Small Letter V With Hook / Latin Small Letter Script V</source>
          <target state="translated">Маленькая латинская буква V с крючком/латинская маленькая буква Сценарий V</target>
        </trans-unit>
        <trans-unit id="6a5f81b7b582dc216e4c1f24b62d26cf5af68967" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook</source>
          <target state="translated">Латинская маленькая буква Z с ретрофлексным крючком/латинская маленькая буква Z ретрофлексный крючок</target>
        </trans-unit>
        <trans-unit id="e2c17f6ce613463c3e30d1a4aed82bceb3d0bf26" translate="yes" xml:space="preserve">
          <source>Latin Small Ligature Oe / Latin Small Letter O E</source>
          <target state="translated">Латинская мелкая вязь Oe/латинская мелкая буква O E</target>
        </trans-unit>
        <trans-unit id="ab095c443113e11acf431c2bb30a86ce8ce57bb6" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter A</source>
          <target state="translated">Латинский Подпись Маленькая буква А</target>
        </trans-unit>
        <trans-unit id="fff77fcf01dc719ec1ab77e81e213e93b8d0115a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter E</source>
          <target state="translated">Латинский Подпись Маленькая буква Е</target>
        </trans-unit>
        <trans-unit id="363c386941760c298d65628800930f8354b1c700" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter H</source>
          <target state="translated">Латинский Подпись Маленькая буква H</target>
        </trans-unit>
        <trans-unit id="982401be038720a241d1e68deecf4cf7746b55ab" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter I</source>
          <target state="translated">Латинский Подпись Маленькая буква I</target>
        </trans-unit>
        <trans-unit id="f36b34411ebc69050abaa08db12014b29b018b19" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter J</source>
          <target state="translated">Латинский Подпись Маленькая буква J</target>
        </trans-unit>
        <trans-unit id="5d9192cce944b6338e9e19cf0e5aff75bc6458e0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter K</source>
          <target state="translated">Латинский Подпись Маленькая буква K</target>
        </trans-unit>
        <trans-unit id="98e7def8db7a6c66ec697114dd36225f86e432d0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter L</source>
          <target state="translated">Латинский Подпись Маленькая буква L</target>
        </trans-unit>
        <trans-unit id="c88fe2a6e8d4931c9b29a2de9c39672213e2a09e" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter M</source>
          <target state="translated">Латинский Подпись Маленькая буква М</target>
        </trans-unit>
        <trans-unit id="09020dd38fd21fc2f0e9c9b2f5cd4719b876181a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter N</source>
          <target state="translated">Латинский Подпись Маленькая буква N</target>
        </trans-unit>
        <trans-unit id="bf874a171794f22663d7decf77255804ee48a4b5" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter O</source>
          <target state="translated">Латинский Подпись Маленькая буква O</target>
        </trans-unit>
        <trans-unit id="2f2d68aab8bef5631b7658f2f25cb157fe1312d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter P</source>
          <target state="translated">Латинский Подпись Маленькая буква P</target>
        </trans-unit>
        <trans-unit id="6ae5998c63d2b847c715037212f1596e577e11d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter R</source>
          <target state="translated">Латинский Подпись Маленькая буква R</target>
        </trans-unit>
        <trans-unit id="cbfb24f449387bbaf3bab5247af9c1ad7c5a2e87" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter S</source>
          <target state="translated">Латинский Подпись Маленькая буква S</target>
        </trans-unit>
        <trans-unit id="54984068e00469db35d3a41626ebb9a634073396" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter Schwa</source>
          <target state="translated">Латинский Подпись Маленькая буква Шва</target>
        </trans-unit>
        <trans-unit id="24e9ea8cb7bc17431bfd5069bebcda4cd2e0d7f4" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter T</source>
          <target state="translated">Латинский Подпись Маленькая буква T</target>
        </trans-unit>
        <trans-unit id="c11091f07852038d224bf6a198262288070ac4af" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter U</source>
          <target state="translated">Латинский Подпись Маленькая буква U</target>
        </trans-unit>
        <trans-unit id="59e0fc501529d38b3e42a1402845967ae6868b9c" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter V</source>
          <target state="translated">Латинский Подпись Маленькая буква V</target>
        </trans-unit>
        <trans-unit id="87def54837d4f750a3ac2cc91c670222eecf573b" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter X</source>
          <target state="translated">Латинский Подпись Маленькая буква X</target>
        </trans-unit>
        <trans-unit id="96f66def5d4a8c399dd4712422d81130f5b17cc9" translate="yes" xml:space="preserve">
          <source>Launches worker processes via the specified cluster manager.</source>
          <target state="translated">Запускает рабочие процессы через указанный менеджер кластера.</target>
        </trans-unit>
        <trans-unit id="230ffdc98fdacb0f873a14dccabfdda12422305b" translate="yes" xml:space="preserve">
          <source>Launches workers using the in-built &lt;code&gt;LocalManager&lt;/code&gt; which only launches workers on the local host. This can be used to take advantage of multiple cores. &lt;code&gt;addprocs(4)&lt;/code&gt; will add 4 processes on the local machine. If &lt;code&gt;restrict&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, binding is restricted to &lt;code&gt;127.0.0.1&lt;/code&gt;. Keyword args &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;exename&lt;/code&gt;, &lt;code&gt;exeflags&lt;/code&gt;, &lt;code&gt;topology&lt;/code&gt;, &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;enable_threaded_blas&lt;/code&gt; have the same effect as documented for &lt;code&gt;addprocs(machines)&lt;/code&gt;.</source>
          <target state="translated">Запускает &lt;code&gt;LocalManager&lt;/code&gt; с помощью встроенного LocalManager, который запускает воркеры только на локальном хосте. Это можно использовать для использования нескольких ядер. &lt;code&gt;addprocs(4)&lt;/code&gt; добавит 4 процесса на локальный компьютер. Если &lt;code&gt;restrict&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , связывание ограничивается &lt;code&gt;127.0.0.1&lt;/code&gt; . Ключевые слова args &lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;exename&lt;/code&gt; , &lt;code&gt;exeflags&lt;/code&gt; , &lt;code&gt;topology&lt;/code&gt; , &lt;code&gt;lazy&lt;/code&gt; и &lt;code&gt;enable_threaded_blas&lt;/code&gt; имеют тот же эффект, что и задокументированный для &lt;code&gt;addprocs(machines)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5651fa0fd68350a3db0e0ce46acc644a6f99f032" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition) (also postfix &lt;code&gt;'&lt;/code&gt;). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">Ленивый сопряженный (сопряженная транспозиция) (также постфиксный &lt;code&gt;'&lt;/code&gt; ). Обратите внимание, что &lt;code&gt;adjoint&lt;/code&gt; рекурсивно применяется к элементам.</target>
        </trans-unit>
        <trans-unit id="1a484bd65bd99903b9e6433e56a7ce5feb1a88b4" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dabe105e2961d8642efb76e1ebd7539fca5122b" translate="yes" xml:space="preserve">
          <source>Lazy transpose. Mutating the returned object should appropriately mutate &lt;code&gt;A&lt;/code&gt;. Often, but not always, yields &lt;code&gt;Transpose(A)&lt;/code&gt;, where &lt;code&gt;Transpose&lt;/code&gt; is a lazy transpose wrapper. Note that this operation is recursive.</source>
          <target state="translated">Ленивый перенос. Мутирование возвращенный объект должен соответствующим образом мутируют &lt;code&gt;A&lt;/code&gt; . Часто, но не всегда, возвращает &lt;code&gt;Transpose(A)&lt;/code&gt; , где &lt;code&gt;Transpose&lt;/code&gt; - ленивая оболочка транспонирования. Обратите внимание, что эта операция рекурсивная.</target>
        </trans-unit>
        <trans-unit id="52790bab6c96ca4ca79f6c9dcbc5f04f90742a02" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Transpose&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип ленивой оболочки для транспонированного представления базового объекта линейной алгебры, обычно это &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; , но также , например, некоторая &lt;code&gt;Factorization&lt;/code&gt; . Обычно конструктор &lt;code&gt;Transpose&lt;/code&gt; не следует вызывать напрямую, вместо этого используйте &lt;a href=&quot;#Base.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt; . Чтобы материализовать представление, используйте &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea87c3f92c6c2a81bda14868b1fa3651e1788be6" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Adjoint&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.adjoint&quot;&gt;&lt;code&gt;adjoint&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ленивый тип-оболочка для сопряженного представления базового объекта линейной алгебры, обычно это &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; , но также , например, некоторая &lt;code&gt;Factorization&lt;/code&gt; . Обычно конструктор &lt;code&gt;Adjoint&lt;/code&gt; не следует вызывать напрямую, вместо этого используйте &lt;a href=&quot;#Base.adjoint&quot;&gt; &lt;code&gt;adjoint&lt;/code&gt; &lt;/a&gt; . Чтобы материализовать представление, используйте &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c31303ce475bc8493699e997a666b0db70d41d90" translate="yes" xml:space="preserve">
          <source>Leaf Fluttering In Wind</source>
          <target state="translated">Порхание листьев на ветру</target>
        </trans-unit>
        <trans-unit id="22d214839b787ba0cbf83b35c8637e398eb00b60" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple.</source>
          <target state="translated">Наименее распространенное (неотрицательное)кратное.</target>
        </trans-unit>
        <trans-unit id="df7cd86f236b8cca642b834576ccdcaabf497db7" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple. The arguments may be integer and rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa2f31ee7ccbdf2fc8c6c567cdca2fb29dac2a6" translate="yes" xml:space="preserve">
          <source>Ledger</source>
          <target state="translated">Ledger</target>
        </trans-unit>
        <trans-unit id="8ae1c34bd37fad49cc5f8e02da648a78e89c3ed8" translate="yes" xml:space="preserve">
          <source>Left</source>
          <target state="translated">Left</target>
        </trans-unit>
        <trans-unit id="75d0899e95136f2da4eac284be2b987384e5c533" translate="yes" xml:space="preserve">
          <source>Left Arrow With Circled Plus</source>
          <target state="translated">Левая стрелка с закрученным плюсом</target>
        </trans-unit>
        <trans-unit id="72aee17ac3f066d41059e365fe7ffff8c87f2b40" translate="yes" xml:space="preserve">
          <source>Left Arrow With Small Circle</source>
          <target state="translated">Стрелка влево с малым кругом</target>
        </trans-unit>
        <trans-unit id="e4186034491319e4fea56b94c110018858b681a3" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Down Harpoon</source>
          <target state="translated">Левая Барб Вниз Правая Барб Вниз Гарпун</target>
        </trans-unit>
        <trans-unit id="ae21e1eb75451dd870d85a61a1cfa6bc8df2ba78" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Up Harpoon</source>
          <target state="translated">Левая Барб Внизу Правая Барб Вверх Гарпун</target>
        </trans-unit>
        <trans-unit id="bcae4f39e04c712debc4107f48695498ba926272" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Down Harpoon</source>
          <target state="translated">Левая Барб Вверх Правая Барб Вниз Гарпун</target>
        </trans-unit>
        <trans-unit id="f15664f5c11100645f7ec0fc503d10e242c811c4" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Up Harpoon</source>
          <target state="translated">Левая Барб Верхняя Правая Барб Верхняя Гарпун</target>
        </trans-unit>
        <trans-unit id="a3c4bf704acbb06ce3404e8185007c7d40dd50dc" translate="yes" xml:space="preserve">
          <source>Left Ceiling</source>
          <target state="translated">Левый потолок</target>
        </trans-unit>
        <trans-unit id="72a9f53c8c863fcc58b749c2d802910b9dd69204" translate="yes" xml:space="preserve">
          <source>Left Double Quotation Mark / Double Turned Comma Quotation Mark</source>
          <target state="translated">Левая двойная кавычка Марк/двойная перевёрнутая запятая Команда кавычки Марк</target>
        </trans-unit>
        <trans-unit id="33ab45e60f973d03d477e320c9c21d10102209f2" translate="yes" xml:space="preserve">
          <source>Left Floor</source>
          <target state="translated">Левый этаж</target>
        </trans-unit>
        <trans-unit id="acdcba05803275d77a8ff9d944d257c2f355cc32" translate="yes" xml:space="preserve">
          <source>Left Half Black Circle</source>
          <target state="translated">Левая половина черного круга</target>
        </trans-unit>
        <trans-unit id="98f2260c432833cdcda74a0d3fd1bcf7149895fd" translate="yes" xml:space="preserve">
          <source>Left Half Block</source>
          <target state="translated">Левая половина блока</target>
        </trans-unit>
        <trans-unit id="b2d1cb4617e2395b9bcddfaba836b4ff2e6e68a3" translate="yes" xml:space="preserve">
          <source>Left Luggage</source>
          <target state="translated">Левый багаж</target>
        </trans-unit>
        <trans-unit id="6fc8b4239d1345e60f61ab6561b7d80a0e196edc" translate="yes" xml:space="preserve">
          <source>Left Normal Factor Semidirect Product</source>
          <target state="translated">Левый нормальный коэффициент полупрямого продукта</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">Левый Внешнее Присоединение</target>
        </trans-unit>
        <trans-unit id="bea5ba9ebfbff15c8175b8c30772408ad172251f" translate="yes" xml:space="preserve">
          <source>Left Right Arrow</source>
          <target state="translated">Левая правая стрелка</target>
        </trans-unit>
        <trans-unit id="92b57eec514e84ae8d71456c14f7cff82b10a548" translate="yes" xml:space="preserve">
          <source>Left Right Arrow Through Small Circle</source>
          <target state="translated">Стрелка вправо налево по малому кругу</target>
        </trans-unit>
        <trans-unit id="8f9b98c29f15c9b6eaf2eadce9578f5dc5b96041" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Double Vertical Stroke</source>
          <target state="translated">Стрелка вправо налево с двойным вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="09fe21e697a5fa104980be3384a847b808e4d81a" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Stroke</source>
          <target state="translated">Стрелка вправо и влево с ходуном</target>
        </trans-unit>
        <trans-unit id="c3c516b47151666dadcf1dd0a1b3b7ab23f3f3ab" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Vertical Stroke</source>
          <target state="translated">Стрелка вправо налево с вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="4f5213e5966d1dc7812d67e6434bf47c9574b0b4" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow</source>
          <target state="translated">Левая правая двойная стрелка</target>
        </trans-unit>
        <trans-unit id="83ed63f2653f9ec7aef827c095dc0fd80a9657f8" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Stroke</source>
          <target state="translated">Левая правая двойная стрелка с инсультом</target>
        </trans-unit>
        <trans-unit id="a2ff1377f747643672f8858987628f93747b7eb2" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Vertical Stroke</source>
          <target state="translated">Левая правая двойная стрелка с вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="172365e73cff74845a1277eb1fb198684eed94bd" translate="yes" xml:space="preserve">
          <source>Left Right Open-Headed Arrow</source>
          <target state="translated">Левая правая открытая стрелка</target>
        </trans-unit>
        <trans-unit id="8055689a32aa93576b189b393a7f7e70b68fbc3d" translate="yes" xml:space="preserve">
          <source>Left Right Wave Arrow</source>
          <target state="translated">Стрелка левой правой волны</target>
        </trans-unit>
        <trans-unit id="37d876c1c2c475cd47f27703a88e7f2f9166fd62" translate="yes" xml:space="preserve">
          <source>Left Semidirect Product</source>
          <target state="translated">Левый полупрямой продукт</target>
        </trans-unit>
        <trans-unit id="62324b102cc4b4bf016fb9203c38bec07856133a" translate="yes" xml:space="preserve">
          <source>Left Single Quotation Mark / Single Turned Comma Quotation Mark</source>
          <target state="translated">Левый знак одиночной котировки/Однократная перевёрнутая кома-карта Команда Знак котировки</target>
        </trans-unit>
        <trans-unit id="19e4168df09f34516f6fddcc4e445fc021594bcb" translate="yes" xml:space="preserve">
          <source>Left Square Bracket Lower Corner</source>
          <target state="translated">Кронштейн левой площади Нижний угол</target>
        </trans-unit>
        <trans-unit id="ac1fd430a7759464f468517dfa51418639f0abf8" translate="yes" xml:space="preserve">
          <source>Left Tack</source>
          <target state="translated">Левый валет</target>
        </trans-unit>
        <trans-unit id="07241f21177a787dd3313c67746b03f50c2d9592" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar</source>
          <target state="translated">Левый треугольник рядом с вертикальным баром</target>
        </trans-unit>
        <trans-unit id="3b3a0479d1df49711a0b5dda01c8a9f250ee53e9" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Левый треугольник рядом с вертикальной планкой+комбинированное наложение длинных солидусов/нешаблонное наложение длинных косых черт</target>
        </trans-unit>
        <trans-unit id="24f6c1c79f67d997809b3110481aa58d9f740e6a" translate="yes" xml:space="preserve">
          <source>Left Vertical Box Line</source>
          <target state="translated">Левая вертикальная бокс-линия</target>
        </trans-unit>
        <trans-unit id="e2e904284d118de6f14c002567a428193497055e" translate="yes" xml:space="preserve">
          <source>Left arrow, &lt;code&gt;^B&lt;/code&gt;</source>
          <target state="translated">Стрелка влево, &lt;code&gt;^B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c75bdc1fa38ddb43ed3abfdf3e4dda383f45ac" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;B&lt;/code&gt; with elements shifted &lt;code&gt;n&lt;/code&gt; positions backwards, filling with &lt;code&gt;false&lt;/code&gt; values. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, elements are shifted forwards. Equivalent to &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">Оператор сдвига левого бита, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt; . Для &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; результатом будет &lt;code&gt;B&lt;/code&gt; с элементами, сдвинутыми на &lt;code&gt;n&lt;/code&gt; позиций назад, заполненными &lt;code&gt;false&lt;/code&gt; значениями. Если &lt;code&gt;n &amp;lt; 0&lt;/code&gt; , элементы сдвигаются вперед. Эквивалентно &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="700db7c2e4663e2dc271d4c36173f17b6c63b025" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;x&lt;/code&gt; shifted left by &lt;code&gt;n&lt;/code&gt; bits, filling with &lt;code&gt;0&lt;/code&gt;s. This is equivalent to &lt;code&gt;x * 2^n&lt;/code&gt;. For &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, this is equivalent to &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">Оператор сдвига влево, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; . Для &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; результатом будет &lt;code&gt;x&lt;/code&gt; , сдвинутый влево на &lt;code&gt;n&lt;/code&gt; бит, заполнение &lt;code&gt;0&lt;/code&gt; с. Это эквивалентно &lt;code&gt;x * 2^n&lt;/code&gt; . Для &lt;code&gt;n &amp;lt; 0&lt;/code&gt; это эквивалентно &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47e029a3c897df6f4c0de3d067011451de3151f3" translate="yes" xml:space="preserve">
          <source>Left division operator: multiplication of &lt;code&gt;y&lt;/code&gt; by the inverse of &lt;code&gt;x&lt;/code&gt; on the left. Gives floating-point results for integer arguments.</source>
          <target state="translated">Оператор левого деления: умножение &lt;code&gt;y&lt;/code&gt; на обратное &lt;code&gt;x&lt;/code&gt; слева. Выдает результаты с плавающей запятой для целочисленных аргументов.</target>
        </trans-unit>
        <trans-unit id="5ddde4aec1f53e97b5a1f34009e407e1cb187578" translate="yes" xml:space="preserve">
          <source>Left-Pointing Magnifying Glass</source>
          <target state="translated">Левостороннее увеличительное стекло</target>
        </trans-unit>
        <trans-unit id="35088a4f27322015e328e0637be16cff0df478d9" translate="yes" xml:space="preserve">
          <source>Left-rotate matrix &lt;code&gt;A&lt;/code&gt; 90 degrees counterclockwise an integer &lt;code&gt;k&lt;/code&gt; number of times. If &lt;code&gt;k&lt;/code&gt; is a multiple of four (including zero), this is equivalent to a &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="translated">Повернуть матрицу &lt;code&gt;A&lt;/code&gt; влево на 90 градусов против часовой стрелки &lt;code&gt;k&lt;/code&gt; целое число раз. Если &lt;code&gt;k&lt;/code&gt; кратно четырем (включая ноль), это эквивалентно &lt;code&gt;copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af413d32c0aefe9e0a6c5345832116ac3819cfc9" translate="yes" xml:space="preserve">
          <source>Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="927f085de46b51d7752a0f754c30861f6cbe6126" translate="yes" xml:space="preserve">
          <source>Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b0da9967a31e27b91c5f79f61cda48210161da5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow / Left Arrow</source>
          <target state="translated">Стрелка влево/Стрелка влево</target>
        </trans-unit>
        <trans-unit id="bb62e777d053b849a3960927799605c68d6f5eca" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Almost Equal To</source>
          <target state="translated">Стрелка влево Стрелка выше почти равной К</target>
        </trans-unit>
        <trans-unit id="c453288b80fc56c56e06ba24b30f84f5dac9e172" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Almost Equal To</source>
          <target state="translated">Стрелка влево Стрелка над задним ходом Почти равна</target>
        </trans-unit>
        <trans-unit id="c80976998c602bbf7e0960e57864b997e7fa3170" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Tilde Operator</source>
          <target state="translated">Стрелка влево Стрелка над оператором обратного тильда</target>
        </trans-unit>
        <trans-unit id="b339bc529a24441191ee0d608b29a79c5db84b52" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar / Left Arrow From Bar</source>
          <target state="translated">Стрелка влево от бара/Стрелка влево от бара</target>
        </trans-unit>
        <trans-unit id="1e84d429549228a5c098aec3446031d7ead6505a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar To Black Diamond</source>
          <target state="translated">Стрелка влево от бара к черному бриллианту</target>
        </trans-unit>
        <trans-unit id="3b47b1dfc544dad6abdaf2ebcb4206c54487efc5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow</source>
          <target state="translated">Стрелка влево Стрелка вправо Стрелка вправо/Стрелка влево Стрелка вправо Стрелка вправо</target>
        </trans-unit>
        <trans-unit id="ae9989b5442d5772a5dadc97fcf089e63cd8bb1f" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Through X</source>
          <target state="translated">Стрелка влево через X</target>
        </trans-unit>
        <trans-unit id="ae63102c5c00038eb021088d9b27a739caf11f6e" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar / Left Arrow To Bar</source>
          <target state="translated">Стрелка влево на планку/Стрелка влево на планку</target>
        </trans-unit>
        <trans-unit id="ba54e194d48c6e6846ca63e167eaa511daf10b83" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar</source>
          <target state="translated">Стрелка влево на бар Стрелка вправо на бар/стрелка вправо на бар Стрелка влево на бар Стрелка вправо на бар</target>
        </trans-unit>
        <trans-unit id="352323837c59795cd0e83f313a7f1aad09357b67" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Black Diamond</source>
          <target state="translated">Стрелка влево на черный бриллиант</target>
        </trans-unit>
        <trans-unit id="0dbfe3aca18f61d6f1a6e05b8ae3c26d1725c775" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Dotted Stem</source>
          <target state="translated">Стрелка влево с точечным стеблем</target>
        </trans-unit>
        <trans-unit id="b5f4b7ef2746d70757e6dc984fb3961f86960c29" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Double Vertical Stroke</source>
          <target state="translated">Стрелка влево с двойным вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="42e353d97e79c0c1b091dc7d9378f532aaef3b3d" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Hook / Left Arrow With Hook</source>
          <target state="translated">Стрелка влево с крюком/Стрелка влево с крюком</target>
        </trans-unit>
        <trans-unit id="023d9a3502015dcd3b3f76fa14c946cbbc2d6f32" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Loop / Left Arrow With Loop</source>
          <target state="translated">Стрелка влево с петлей/стрелка влево с петлей</target>
        </trans-unit>
        <trans-unit id="9e22f7f96528d90c3397d6b157c1fdc2594ea742" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Plus Below</source>
          <target state="translated">Стрелка влево с плюсом ниже</target>
        </trans-unit>
        <trans-unit id="cc480573c42bb17cb0e2940abfedd3c8ea38e8ea" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Stroke / Left Arrow With Stroke</source>
          <target state="translated">Стрелка влево с ходуном/стрелка влево с ходуном</target>
        </trans-unit>
        <trans-unit id="52d1604edf7ef87df0bdda8c2b40df8871c49a60" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail / Left Arrow With Tail</source>
          <target state="translated">Стрелка влево с хвостом/Стрелка влево с хвостом</target>
        </trans-unit>
        <trans-unit id="88f9604cfadba8964cc29be77251abe676f9051a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">Стрелка влево с хвостом с двойным вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="390234b436d1a22d91a1f9368ac90420d25a50f9" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Vertical Stroke</source>
          <target state="translated">Стрелка влево с хвостом с вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="11ebeb1eafd67ffeeffad131d7ac82c3b52085be" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Vertical Stroke</source>
          <target state="translated">Стрелка влево с вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="c87c24a3eb1d8323b9fa96777c93ec260174835d" translate="yes" xml:space="preserve">
          <source>Leftwards Black Arrow</source>
          <target state="translated">Левая черная стрелка</target>
        </trans-unit>
        <trans-unit id="33cfca8919d0753ef59ada74348c2a4c4b3bf344" translate="yes" xml:space="preserve">
          <source>Leftwards Dashed Arrow / Left Dashed Arrow</source>
          <target state="translated">Левая пунктирная стрелка/левая пунктирная стрелка</target>
        </trans-unit>
        <trans-unit id="8a19ba0a75d89ee68704a7ebb90ffd71f1e1b278" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow / Left Double Arrow</source>
          <target state="translated">Левая двойная стрелка/Левая двойная стрелка</target>
        </trans-unit>
        <trans-unit id="60c9a06f1f5b3ab83b89088f525d893f40459a8e" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow From Bar</source>
          <target state="translated">Двойная стрелка слева от бара</target>
        </trans-unit>
        <trans-unit id="0d8615420d5ad768b1f26184a0a7a40704148a7d" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke</source>
          <target state="translated">Двойная стрелка влево с инсультом/двойная стрелка влево с инсультом</target>
        </trans-unit>
        <trans-unit id="4f6b99ebd5ed363e088c4f88602ef903b8e06f64" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Vertical Stroke</source>
          <target state="translated">Двойная стрелка влево с вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="4f794063524482bcc21c38eae616ca798ede37a8" translate="yes" xml:space="preserve">
          <source>Leftwards Double Dash Arrow</source>
          <target state="translated">Стрелка влево Двойная тире</target>
        </trans-unit>
        <trans-unit id="39e96a986704f562e46fbf1d03e4f9e54add9f77" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon</source>
          <target state="translated">Левый гарпун Над правым гарпуном/Левый гарпун Над правым гарпуном</target>
        </trans-unit>
        <trans-unit id="690c48df2218ae792864eaf9456cf6955b424427" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down</source>
          <target state="translated">Левый гарпун с Барб внизу справа вверху гарпун с Барб вниз</target>
        </trans-unit>
        <trans-unit id="2a8c5adb9efda04b9d2fabf980287f590ba155e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Below Long Dash</source>
          <target state="translated">Левый гарпун с Барб вниз под длинным тире.</target>
        </trans-unit>
        <trans-unit id="d60c5396df85f38cca433173bdcae8dd56a90b18" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down From Bar</source>
          <target state="translated">Левый гарпун с Барб Даун из бара.</target>
        </trans-unit>
        <trans-unit id="93c5200b6461e9ba3314eb9a0b244de1ac0949de" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down To Bar</source>
          <target state="translated">Левый гарпун с Барб до бара.</target>
        </trans-unit>
        <trans-unit id="b6d93e8905d73cadcac079a3790b467b97f9e3ec" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down</source>
          <target state="translated">Левый гарпун с Барб вниз/левый гарпун с Барб вниз</target>
        </trans-unit>
        <trans-unit id="662b3d2cbb862798f1987f0dd2c11e4c77a5182f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down</source>
          <target state="translated">Левый гарпун с Барб выше левый гарпун с Барб вниз</target>
        </trans-unit>
        <trans-unit id="b0567c46db77bd91abd63923235b4420e5bd82e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Long Dash</source>
          <target state="translated">Левый гарпун с Барб вверх над длинным тире.</target>
        </trans-unit>
        <trans-unit id="0084ef3852a19447620ab7c0dfc2d2b12aeeb77d" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up</source>
          <target state="translated">Левый гарпун с Барб вверх справа гарпун с Барб вверх</target>
        </trans-unit>
        <trans-unit id="730216336dfd2e32435830075fdb2df0dfaa397f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up From Bar</source>
          <target state="translated">Левый гарпун с Барб из бара.</target>
        </trans-unit>
        <trans-unit id="4cbc38b13463300c356dd264e992f7457f26d5f3" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up To Bar</source>
          <target state="translated">Левый гарпун с Барб до бара.</target>
        </trans-unit>
        <trans-unit id="42c26ac6b35b0c13895bf055d9cecb545b0ec09a" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up</source>
          <target state="translated">Левый гарпун с Барб вверх/левый гарпун с Барб вверх</target>
        </trans-unit>
        <trans-unit id="5439409c437a7e20e57d117b3dc53bfc59be5b1e" translate="yes" xml:space="preserve">
          <source>Leftwards Open-Headed Arrow</source>
          <target state="translated">Открытая стрелка влево</target>
        </trans-unit>
        <trans-unit id="fb802d31c4d84700fe501788c56f0616bde89895" translate="yes" xml:space="preserve">
          <source>Leftwards Paired Arrows / Left Paired Arrows</source>
          <target state="translated">Левые парные стрелки/Левые парные стрелки</target>
        </trans-unit>
        <trans-unit id="1e30b6357af1b8210adc5e8500513f1780a44b86" translate="yes" xml:space="preserve">
          <source>Leftwards Quadruple Arrow</source>
          <target state="translated">Четырехкратная стрелка влево</target>
        </trans-unit>
        <trans-unit id="e990b5a5a1b8966a349729643a9904c9a464f8f2" translate="yes" xml:space="preserve">
          <source>Leftwards Squiggle Arrow / Left Squiggle Arrow</source>
          <target state="translated">Стрелка &quot;тильда&quot; слева/Стрелка &quot;тильда&quot; слева</target>
        </trans-unit>
        <trans-unit id="40ef7c42edfad6e4a2b0c741f7a2e57b2d0a3d17" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Arrow / Left Triple Arrow</source>
          <target state="translated">Левая тройная стрелка/левая тройная стрелка</target>
        </trans-unit>
        <trans-unit id="e443b0f54a32ffe38d3c2940e3150615527deb02" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Dash Arrow</source>
          <target state="translated">Тройная тиревая стрелка влево</target>
        </trans-unit>
        <trans-unit id="0e6ace611eb46c42c60ebf869526d6d80107ee54" translate="yes" xml:space="preserve">
          <source>Leftwards Two Headed Arrow / Left Two Headed Arrow</source>
          <target state="translated">Влево Две головные стрелки/Влево Две головные стрелки</target>
        </trans-unit>
        <trans-unit id="73e956493780be5029f93be5ee242950d63a7b37" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow From Bar</source>
          <target state="translated">Двухголовая стрелка слева от бара.</target>
        </trans-unit>
        <trans-unit id="c8fe728344df16251ef3411400150ba0b2c50044" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Double Vertical Stroke</source>
          <target state="translated">Двухголовая стрелка влево с двойным вертикальным штрихом</target>
        </trans-unit>
        <trans-unit id="19a7c2f943c6a266d93318b4faccd25877a453bc" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail</source>
          <target state="translated">Двухголовая стрелка слева с хвостом</target>
        </trans-unit>
        <trans-unit id="fad45cb4bffed0212e02a7dd5b2b9636aeff862a" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">Стрелка влево двуглавая с хвостом с двойным вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="5354b323327ab9574144f2502eac42843f5fcc1b" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Vertical Stroke</source>
          <target state="translated">Стрелка влево двуглавая с хвостом с вертикальным ходом</target>
        </trans-unit>
        <trans-unit id="be95b8e9e0c8c9337712cb0f314c9ab2a05f3613" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Vertical Stroke</source>
          <target state="translated">Двунаправленная стрелка влево с вертикальным штрихом</target>
        </trans-unit>
        <trans-unit id="43f10f58eb0471f466412a154b6c2de8a4b85793" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Triple Dash Arrow</source>
          <target state="translated">Двухголовая тройная стрелка слева.</target>
        </trans-unit>
        <trans-unit id="54be3ecc08f6dfc79a630a29d3be179ecc6e1de9" translate="yes" xml:space="preserve">
          <source>Leftwards Wave Arrow / Left Wave Arrow</source>
          <target state="translated">Стрелка влево/Стрелка левой волны</target>
        </trans-unit>
        <trans-unit id="a8988dc4aff78fbf3d6dec72ae6a15340f71c39b" translate="yes" xml:space="preserve">
          <source>Leftwards White Arrow / White Left Arrow</source>
          <target state="translated">Левая белая стрелка/белая левая стрелка</target>
        </trans-unit>
        <trans-unit id="53789e63c0a26b06f6ee3389f57916b3259c1e85" translate="yes" xml:space="preserve">
          <source>Legend:</source>
          <target state="translated">Legend:</target>
        </trans-unit>
        <trans-unit id="4459b791a680572873dc2cf033487dc21edfcb9c" translate="yes" xml:space="preserve">
          <source>Lemon</source>
          <target state="translated">Lemon</target>
        </trans-unit>
        <trans-unit id="cfaf50ac3721461bd3a2d27ef5f35e144901fbb6" translate="yes" xml:space="preserve">
          <source>Leo</source>
          <target state="translated">Leo</target>
        </trans-unit>
        <trans-unit id="3ee924e59f48f89881e4cde275cb373a5ca3ccb1" translate="yes" xml:space="preserve">
          <source>Leopard</source>
          <target state="translated">Leopard</target>
        </trans-unit>
        <trans-unit id="2b515baec988fd996a77420ccdf808df339479aa" translate="yes" xml:space="preserve">
          <source>Less-Than Above Double-Line Equal Above Greater-Than</source>
          <target state="translated">Меньше чем выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше двойной линии,равный выше одинаковый равновесный.</target>
        </trans-unit>
        <trans-unit id="5132ce6dbd42eef8696f2795c98fbde608c55ddc" translate="yes" xml:space="preserve">
          <source>Less-Than Above Greater-Than Above Double-Line Equal</source>
          <target state="translated">Меньше,чем выше,чем выше,чем выше,чем двойная линия.</target>
        </trans-unit>
        <trans-unit id="0996bf12be96a0c9cfd35d9c3d1cd4d7ae0dc489" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Above Greater-Than</source>
          <target state="translated">Меньше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше,чем выше.</target>
        </trans-unit>
        <trans-unit id="f47dca757b69c3cbb5c4318a3148b185aa51ad59" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Or Equal</source>
          <target state="translated">Меньше чем выше похожих или равных</target>
        </trans-unit>
        <trans-unit id="d46f5f3bf1beaa31682309e60c70c4c4589a153d" translate="yes" xml:space="preserve">
          <source>Less-Than Above Slanted Equal Above Greater-Than Above Slanted Equal</source>
          <target state="translated">Меньше,чем наклоненные равномерно выше,больше,чем наклоненные равномерно.</target>
        </trans-unit>
        <trans-unit id="713b9a189c39738ac2705479504dc75c64634c14" translate="yes" xml:space="preserve">
          <source>Less-Than And Not Approximate</source>
          <target state="translated">Меньше,и не приблизительный</target>
        </trans-unit>
        <trans-unit id="2796bb948b259786fd87ad28f516271749c20d52" translate="yes" xml:space="preserve">
          <source>Less-Than And Single-Line Not Equal To</source>
          <target state="translated">Меньше,чем в одной строке,и не равнозначно</target>
        </trans-unit>
        <trans-unit id="709360d5eb9bea213909aadcf59a29aa892cbe75" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To</source>
          <target state="translated">Меньше,но не равнозначно/менее,но не равнозначно</target>
        </trans-unit>
        <trans-unit id="e453412818d96e7a4f420ee26bac5ea434246d68" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">Меньше,но не равны/меньше,чем равны,но не равны+селектор вариантов-1</target>
        </trans-unit>
        <trans-unit id="2f4b9cde7d599f1fdfcdcd2d149da1761281cf59" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equivalent To / Less Than But Not Equivalent To</source>
          <target state="translated">Меньше,но не эквивалентно/меньше,но не эквивалентно</target>
        </trans-unit>
        <trans-unit id="d47b00bfbef46bd9077401979c412c7c9f4f06db" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve</source>
          <target state="translated">Меньше чем закрыто кривой</target>
        </trans-unit>
        <trans-unit id="e9bc15ca0894be74c91d83dd7307ed3d4d198f47" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">Меньше чем закрыто кривой выше наклонной равномерной.</target>
        </trans-unit>
        <trans-unit id="22c4db9e780b7f321b3a098f0b550b5d05360802" translate="yes" xml:space="preserve">
          <source>Less-Than Equal To Or Greater-Than / Less Than Equal To Or Greater Than</source>
          <target state="translated">Меньше,чем равны или больше,чем равны или больше.</target>
        </trans-unit>
        <trans-unit id="125980c6753f24cfef91a7aee66e7177aefa9911" translate="yes" xml:space="preserve">
          <source>Less-Than Or Approximate</source>
          <target state="translated">Менее чем или приблизительно</target>
        </trans-unit>
        <trans-unit id="c6b5679738cc00d2db14ba6a2056c401ded59619" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equal To / Less Than Or Equal To</source>
          <target state="translated">Меньше или равнозначно/меньше или равнозначно</target>
        </trans-unit>
        <trans-unit id="35d27cfb30206b75fdeb27b601c10d1aad047c85" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equivalent To / Less Than Or Equivalent To</source>
          <target state="translated">Меньше или эквивалентна/меньше чем</target>
        </trans-unit>
        <trans-unit id="b9b477ee81eb35999da4d54deb44ce4b860fe5f0" translate="yes" xml:space="preserve">
          <source>Less-Than Or Greater-Than / Less Than Or Greater Than</source>
          <target state="translated">Меньше,или больше,или меньше,или больше,или больше.</target>
        </trans-unit>
        <trans-unit id="cfd32ee1a60232f0de86d5e566782496b87faa45" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To</source>
          <target state="translated">Меньше,или наклонен равный</target>
        </trans-unit>
        <trans-unit id="c2210b5afd5a3271bd637771d340007b9651af50" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Меньше чем та или наклонная равна+комбинация длинного наложения сольдуса/непериодического наложения длинного наклона коса.</target>
        </trans-unit>
        <trans-unit id="a5250f1e7fd00d514cf7de98b151fff6e960ca41" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">Меньше чем та,или наклонен равный с точкой выше.</target>
        </trans-unit>
        <trans-unit id="08ee594bef0f1ebfc9a347365790474b8aa06aae" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above Right</source>
          <target state="translated">Меньше чем с точкой выше справа или наклонен равномерно.</target>
        </trans-unit>
        <trans-unit id="6028a8d9f280a98196c48a63aa608f95a5002030" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">Меньше чем это или наклонен равный с точкой внутри</target>
        </trans-unit>
        <trans-unit id="a654d5c89ef59a82d905f082b763c64619e9d053" translate="yes" xml:space="preserve">
          <source>Less-Than Over Equal To / Less Than Over Equal To</source>
          <target state="translated">Меньше,чем больше,чем больше,чем больше,чем больше.</target>
        </trans-unit>
        <trans-unit id="3cd5d177f863b189035a69ddc7dc355152c827d7" translate="yes" xml:space="preserve">
          <source>Less-Than With Circle Inside</source>
          <target state="translated">Меньше чем с кругом внутри</target>
        </trans-unit>
        <trans-unit id="f5f82e2a0d06ff7d257c2989f80e7e63fdfcc406" translate="yes" xml:space="preserve">
          <source>Less-Than With Dot / Less Than With Dot</source>
          <target state="translated">Меньше чем с точкой/меньше чем с точкой</target>
        </trans-unit>
        <trans-unit id="e8d2d29dc34fdea25f29dead5f22ec63a8a158fd" translate="yes" xml:space="preserve">
          <source>Less-Than With Question Mark Above</source>
          <target state="translated">Меньше чем с вопросительным знаком выше.</target>
        </trans-unit>
        <trans-unit id="98215ce56f609905c57ffcaa9fd368bd9a664b9f" translate="yes" xml:space="preserve">
          <source>Less-than comparison operator. Falls back to &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt;. Because of the behavior of floating-point NaN values, this operator implements a partial order.</source>
          <target state="translated">Оператор сравнения меньше. Падение обратно в &lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt; . Из-за поведения значений NaN с плавающей запятой этот оператор реализует частичный порядок.</target>
        </trans-unit>
        <trans-unit id="6b17017e386fc2cfd407cedbcefdc1a56529ec61" translate="yes" xml:space="preserve">
          <source>Less-than-or-equals comparison operator. Falls back to &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt;.</source>
          <target state="translated">Оператор сравнения &amp;laquo;меньше или равно&amp;raquo;. Возвращается к &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7223264dca9d07a87ce4ee4c3f4c203febf05b3c" translate="yes" xml:space="preserve">
          <source>Let Blocks</source>
          <target state="translated">Пусть Блоки</target>
        </trans-unit>
        <trans-unit id="7a4b5aa264a12a56a65beda1765bedfd0c0c5b4a" translate="yes" xml:space="preserve">
          <source>Let us explore the low level construct &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; to understand how task switching works. &lt;code&gt;yieldto(task,value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="translated">Давайте исследуем низкоуровневую конструкцию &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; ,&lt;/a&gt; чтобы понять, как работает переключение задач. &lt;code&gt;yieldto(task,value)&lt;/code&gt; приостанавливает текущую задачу, переключается на указанную &lt;code&gt;task&lt;/code&gt; и заставляет последний вызов &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; этой задачи вернуть указанное &lt;code&gt;value&lt;/code&gt; . Обратите внимание, что &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; - единственная операция, необходимая для использования потока управления в стиле задачи; вместо того, чтобы звонить и возвращаться, мы всегда просто переключаемся на другую задачу. Вот почему эту функцию также называют &amp;laquo;симметричными сопрограммами&amp;raquo;; каждая задача переключается на один и тот же механизм и обратно.</target>
        </trans-unit>
        <trans-unit id="67246c5c8735d7e8441000a86e3cb7192688e453" translate="yes" xml:space="preserve">
          <source>Let us illustrate this principle with the logical &quot;or&quot; operator &lt;code&gt;|&lt;/code&gt;. Following the rules of boolean logic, if one of the operands is &lt;code&gt;true&lt;/code&gt;, the value of the other operand does not have an influence on the result, which will always be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Проиллюстрируем этот принцип логическим оператором &amp;laquo;или&amp;raquo; &lt;code&gt;|&lt;/code&gt; , Следуя правилам логической логики, если один из операндов &lt;code&gt;true&lt;/code&gt; , значение другого операнда не влияет на результат, который всегда будет &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5989117a8f456835a0f1be3863e508fbd507b1e1" translate="yes" xml:space="preserve">
          <source>Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into each location.</source>
          <target state="translated">Будем работать с этим массивом одновременно,используя 4 потока.Каждый поток запишет свой идентификатор потока в каждое место.</target>
        </trans-unit>
        <trans-unit id="6183c7c4afe71ef5b8231a90fffb2c5978fa45fa" translate="yes" xml:space="preserve">
          <source>Let's consider some of the abstract types that make up Julia's numerical hierarchy:</source>
          <target state="translated">Рассмотрим некоторые абстрактные типы,составляющие числовую иерархию Юлии:</target>
        </trans-unit>
        <trans-unit id="01a2c551d7b29ee2d56fdf88a3feffacdd9828c3" translate="yes" xml:space="preserve">
          <source>Let's define a producer task, which produces values via the &lt;code&gt;put!&lt;/code&gt; call. To consume values, we need to schedule the producer to run in a new task. A special &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then &lt;code&gt;take!&lt;/code&gt; values repeatedly from the channel object:</source>
          <target state="translated">Давайте определим задачу производителя, которая производит значения через &lt;code&gt;put!&lt;/code&gt; вызов. Чтобы использовать значения, нам нужно запланировать запуск производителя в новой задаче. Для запуска задачи, привязанной к каналу, можно использовать специальный конструктор &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; ,&lt;/a&gt; который принимает в качестве аргумента функцию с 1 аргументом. Можем тогда &lt;code&gt;take!&lt;/code&gt; значения повторно из объекта канала:</target>
        </trans-unit>
        <trans-unit id="d05f0c73a4331f267ffda8d64fbec89860b0ccf5" translate="yes" xml:space="preserve">
          <source>Let's dig into the fact that the &lt;code&gt;for&lt;/code&gt; loop body has its own scope for a second by writing a slightly more verbose variation which we'll call &lt;code&gt;sum_to&amp;prime;&lt;/code&gt;, in which we save the sum &lt;code&gt;s + i&lt;/code&gt; in a variable &lt;code&gt;t&lt;/code&gt; before updating &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df15ca83d0947dbf1751a612bf2340b275f4ac4" translate="yes" xml:space="preserve">
          <source>Let's first discuss the two positional arguments, and later the keyword arguments:</source>
          <target state="translated">Рассмотрим сначала два аргумента позиционирования,а затем аргументы ключевых слов:</target>
        </trans-unit>
        <trans-unit id="6418114a78265d3efb7f605d5f750649435cf8a7" translate="yes" xml:space="preserve">
          <source>Let's jump right in with a simple example involving TCP sockets. This functionality is in a standard library package called &lt;code&gt;Sockets&lt;/code&gt;. Let's first create a simple server:</source>
          <target state="translated">Давайте сразу перейдем к простому примеру с TCP-сокетами. Эта функция находится в стандартном библиотечном пакете &lt;code&gt;Sockets&lt;/code&gt; . Сначала создадим простой сервер:</target>
        </trans-unit>
        <trans-unit id="9d1274ee3906a8208793462a30f6e28d1823afa2" translate="yes" xml:space="preserve">
          <source>Let's move onto some more ambiguous cases covered by the soft scope rule. We'll explore this by extracting the bodies of the &lt;code&gt;greet&lt;/code&gt; and &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; functions into soft scope contexts. First, let's put the body of &lt;code&gt;greet&lt;/code&gt; in a &lt;code&gt;for&lt;/code&gt; loop&amp;mdash;which is soft, rather than hard&amp;mdash;and evaluate it in the REPL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1122c34c203c69e459bc638ef4ea480a5b8130e2" translate="yes" xml:space="preserve">
          <source>Let's say you want to create an &lt;code&gt;N&lt;/code&gt;-dimensional array that has size 3 along each axis. Such arrays can be created like this:</source>
          <target state="translated">Допустим, вы хотите создать &lt;code&gt;N&lt;/code&gt; -мерный массив размером 3 по каждой оси. Такие массивы можно создавать так:</target>
        </trans-unit>
        <trans-unit id="8748cf620bf48795063bf239466aafbea94faee0" translate="yes" xml:space="preserve">
          <source>Let's set up a new environment so we may experiment. To set the active environment, use &lt;code&gt;activate&lt;/code&gt;:</source>
          <target state="translated">Давайте настроим новую среду, чтобы мы могли поэкспериментировать. Чтобы установить активную среду, используйте &lt;code&gt;activate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c76b2235d981c65461960877af26f1dbe64a8ee1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df8e39d6c6cb9f345698606b67ad54d1b7ae227" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a &lt;code&gt;Die&lt;/code&gt; with a random number of up to 20 sides (and at least 4):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ba98ed632749544ae49e36ff83983c01e402b0" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a die with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">Возьмем следующий пример: мы реализуем тип &lt;code&gt;Die&lt;/code&gt; с переменным числом сторон &lt;code&gt;n&lt;/code&gt; , пронумерованными от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;n&lt;/code&gt; . Мы хотим, чтобы &lt;code&gt;rand(Die)&lt;/code&gt; создавал кубик со случайным числом до 20 сторон (и не менее 4):</target>
        </trans-unit>
        <trans-unit id="f3530d6febbeb3af1b1c75ff5864143019e5c7e9" translate="yes" xml:space="preserve">
          <source>Let's try it out. First we modify the file at &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; and add a simple function:</source>
          <target state="translated">Давай попробуем. Сначала мы изменяем файл в &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; и добавляем простую функцию:</target>
        </trans-unit>
        <trans-unit id="d9f3d5d59e7aa3d7e910a3c03fcdc92c22584287" translate="yes" xml:space="preserve">
          <source>Let's try this out. Starting with &lt;code&gt;julia -p n&lt;/code&gt; provides &lt;code&gt;n&lt;/code&gt; worker processes on the local machine. Generally it makes sense for &lt;code&gt;n&lt;/code&gt; to equal the number of CPU threads (logical cores) on the machine. Note that the &lt;code&gt;-p&lt;/code&gt; argument implicitly loads module &lt;code&gt;Distributed&lt;/code&gt;.</source>
          <target state="translated">Давайте попробуем это. Начиная с &lt;code&gt;julia -p n&lt;/code&gt; на локальном компьютере предоставляется &lt;code&gt;n&lt;/code&gt; рабочих процессов. Обычно имеет смысл для &lt;code&gt;n&lt;/code&gt; равняться количеству потоков ЦП (логических ядер) на машине. Обратите внимание, что аргумент &lt;code&gt;-p&lt;/code&gt; неявно загружает модуль &lt;code&gt;Distributed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b446a4746adc500fc9039decd4f98dd1f28494be" translate="yes" xml:space="preserve">
          <source>Let's verify there are 4 threads at our disposal.</source>
          <target state="translated">Давайте проверим,что в нашем распоряжении есть 4 нити.</target>
        </trans-unit>
        <trans-unit id="a857063978f61fa4bd1f41b325d1aa75b04e9d5e" translate="yes" xml:space="preserve">
          <source>Let's work a simple example using our native threads. Let us create an array of zeros:</source>
          <target state="translated">Давайте рассмотрим простой пример,используя наши родные потоки.Создадим массив нулей:</target>
        </trans-unit>
        <trans-unit id="01ca76f755ba1afdf88a6b78abbe4839783a3a4d" translate="yes" xml:space="preserve">
          <source>Let's work with a simple test case:</source>
          <target state="translated">Давайте поработаем с простым тестовым делом:</target>
        </trans-unit>
        <trans-unit id="7dd0810d04c75d2aee9682c9c0e389c01969f9df" translate="yes" xml:space="preserve">
          <source>Lets start Julia with 4 threads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8556898b2b9f9b2564fd6a9f4e2eeba1821894" translate="yes" xml:space="preserve">
          <source>LibGit2</source>
          <target state="translated">LibGit2</target>
        </trans-unit>
        <trans-unit id="76b53f15ef89ba2bfb2e2f62f34201129332b916" translate="yes" xml:space="preserve">
          <source>Libc</source>
          <target state="translated">Libc</target>
        </trans-unit>
        <trans-unit id="60368a5f4bc52be83598e88566f2089a47f21a35" translate="yes" xml:space="preserve">
          <source>Libc.FormatMessage()</source>
          <target state="translated">Libc.FormatMessage()</target>
        </trans-unit>
        <trans-unit id="41585a339c2503f89fb1f9aa92fdc8fb9adcdd4d" translate="yes" xml:space="preserve">
          <source>Libc.GetLastError()</source>
          <target state="translated">Libc.GetLastError()</target>
        </trans-unit>
        <trans-unit id="a85a19153d65e87480d301d0383428f7125ed99b" translate="yes" xml:space="preserve">
          <source>Libc.RawFD</source>
          <target state="translated">Libc.RawFD</target>
        </trans-unit>
        <trans-unit id="b9d6e139e984d53b5bcde695421e487faedd7c51" translate="yes" xml:space="preserve">
          <source>Libc.TmStruct</source>
          <target state="translated">Libc.TmStruct</target>
        </trans-unit>
        <trans-unit id="bc871e61e3ca821c6cfe4accdd2d8e0693a588e4" translate="yes" xml:space="preserve">
          <source>Libc.calloc()</source>
          <target state="translated">Libc.calloc()</target>
        </trans-unit>
        <trans-unit id="1f4d269c85f0cdd9201cbed97992b84adebdf595" translate="yes" xml:space="preserve">
          <source>Libc.errno()</source>
          <target state="translated">Libc.errno()</target>
        </trans-unit>
        <trans-unit id="0848e3c16acc14bb2ec577b598d650c18e77b315" translate="yes" xml:space="preserve">
          <source>Libc.flush_cstdio()</source>
          <target state="translated">Libc.flush_cstdio()</target>
        </trans-unit>
        <trans-unit id="3ce556c3b59d7aa2c3af19ecb0b6877f650470df" translate="yes" xml:space="preserve">
          <source>Libc.free()</source>
          <target state="translated">Libc.free()</target>
        </trans-unit>
        <trans-unit id="b0704af4d5eaf445364159bc7d46c36ac0dd99b9" translate="yes" xml:space="preserve">
          <source>Libc.gethostname()</source>
          <target state="translated">Libc.gethostname()</target>
        </trans-unit>
        <trans-unit id="34f021f7afa28bfc40d0c964b655d57537eeeb56" translate="yes" xml:space="preserve">
          <source>Libc.getpid()</source>
          <target state="translated">Libc.getpid()</target>
        </trans-unit>
        <trans-unit id="b3ae4ddcce36b5e6214d98b8603cc79d72f7795f" translate="yes" xml:space="preserve">
          <source>Libc.malloc()</source>
          <target state="translated">Libc.malloc()</target>
        </trans-unit>
        <trans-unit id="755d16743ca50b746f3e9f832dc2d5638fe7b1d4" translate="yes" xml:space="preserve">
          <source>Libc.realloc()</source>
          <target state="translated">Libc.realloc()</target>
        </trans-unit>
        <trans-unit id="189c473490df982a84b81ce12725d8d1b054705a" translate="yes" xml:space="preserve">
          <source>Libc.strerror()</source>
          <target state="translated">Libc.strerror()</target>
        </trans-unit>
        <trans-unit id="9c2a2e1ec6af2d38549c677ba7248e856a349879" translate="yes" xml:space="preserve">
          <source>Libc.strftime()</source>
          <target state="translated">Libc.strftime()</target>
        </trans-unit>
        <trans-unit id="291439a5e7bded77e555ba7822b85155ea0e9ab9" translate="yes" xml:space="preserve">
          <source>Libc.strptime()</source>
          <target state="translated">Libc.strptime()</target>
        </trans-unit>
        <trans-unit id="50e854ed1dcc836eb5e225047ee11442a2f80cd3" translate="yes" xml:space="preserve">
          <source>Libc.systemsleep()</source>
          <target state="translated">Libc.systemsleep()</target>
        </trans-unit>
        <trans-unit id="81d6424efbc87c9c17b0813b0c148152bd3c2475" translate="yes" xml:space="preserve">
          <source>Libc.time()</source>
          <target state="translated">Libc.time()</target>
        </trans-unit>
        <trans-unit id="f9ac7f64b772b55f84e761baea56c702c55005b2" translate="yes" xml:space="preserve">
          <source>Libdl.RTLD_NOW</source>
          <target state="translated">Libdl.RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="754e38c44e40a9e9cb516d0f693c9b5afa0d7ec7" translate="yes" xml:space="preserve">
          <source>Libdl.dlclose()</source>
          <target state="translated">Libdl.dlclose()</target>
        </trans-unit>
        <trans-unit id="b20c01d11dde97a5fa90df2ec685adbcf15207ab" translate="yes" xml:space="preserve">
          <source>Libdl.dlext</source>
          <target state="translated">Libdl.dlext</target>
        </trans-unit>
        <trans-unit id="bbe848e2a374e3e28b9be1468210bde354760df9" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen()</source>
          <target state="translated">Libdl.dlopen()</target>
        </trans-unit>
        <trans-unit id="bc44712bf06d7cde2930672cea24ac5283dc04d2" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen_e()</source>
          <target state="translated">Libdl.dlopen_e()</target>
        </trans-unit>
        <trans-unit id="f76c025cd327748a8ae48ab21c1d0d6937ee6cf3" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym()</source>
          <target state="translated">Libdl.dlsym()</target>
        </trans-unit>
        <trans-unit id="ddc83875e28b579f9ad7f02bee458a0c03e115cf" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym_e()</source>
          <target state="translated">Libdl.dlsym_e()</target>
        </trans-unit>
        <trans-unit id="e5858af9f095388c617c420aefd6c16e0594c3bf" translate="yes" xml:space="preserve">
          <source>Libdl.find_library()</source>
          <target state="translated">Libdl.find_library()</target>
        </trans-unit>
        <trans-unit id="cb8e2b307865af7fc3116bd1827bf102132b7b87" translate="yes" xml:space="preserve">
          <source>Libra</source>
          <target state="translated">Libra</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="8a1bb5e870bb9b77202596bab439b6db423dbba2" translate="yes" xml:space="preserve">
          <source>Light Rail</source>
          <target state="translated">Легкий железнодорожный транспорт</target>
        </trans-unit>
        <trans-unit id="4944819e2ca85d61a3c9e24619e3eb246b5a52a9" translate="yes" xml:space="preserve">
          <source>Light Shade</source>
          <target state="translated">Светлый оттенок</target>
        </trans-unit>
        <trans-unit id="9921ca32d9a43716da2c222cd03f37ec5fd109a5" translate="yes" xml:space="preserve">
          <source>Lightweight &quot;green&quot; threading (&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;coroutines&lt;/a&gt;)</source>
          <target state="translated">Легкая &amp;laquo;зеленая&amp;raquo; потоковая передача ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;сопрограммы&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8a26ac5926eeae89368f7fb44a40e4b026751c42" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, but store the result of &lt;code&gt;broadcast(f, As...)&lt;/code&gt; in the &lt;code&gt;dest&lt;/code&gt; array. Note that &lt;code&gt;dest&lt;/code&gt; is only used to store the result, and does not supply arguments to &lt;code&gt;f&lt;/code&gt; unless it is also listed in the &lt;code&gt;As&lt;/code&gt;, as in &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; to perform &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt;.</source>
          <target state="translated">Аналогично &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; , но сохраните результат &lt;code&gt;broadcast(f, As...)&lt;/code&gt; в массиве &lt;code&gt;dest&lt;/code&gt; . Обратите внимание, что &lt;code&gt;dest&lt;/code&gt; используется только для хранения результата и не предоставляет аргументы для &lt;code&gt;f&lt;/code&gt; , если он также не указан в &lt;code&gt;As&lt;/code&gt; , как в &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; для выполнения &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1bc834338e49af8951a520f98a93394195b34a0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions for people who neither own the file nor are a member of the group owning the file</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; ,&lt;/a&gt; но получает разрешения для людей, которые не владеют файлом и не являются членами группы, владеющей файлом</target>
        </trans-unit>
        <trans-unit id="52da4e2a0d663a1dbba38c505be636c82ff3a124" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions of the group owning the file.</source>
          <target state="translated">Как &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; ,&lt;/a&gt; но получает права группы, владеющей файлом.</target>
        </trans-unit>
        <trans-unit id="28e1f410620d4fc1c47d7926e96c9bea23f8d4c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt; the same size as &lt;code&gt;v&lt;/code&gt;, which is used to store (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b69ac4b886c93cd981119d2156a08505ea6f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(ix)&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt; , но принимает предварительно выделенный вектор индекса &lt;code&gt;ix&lt;/code&gt; . Если значение &lt;code&gt;initialized&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; (по умолчанию), &lt;code&gt;ix&lt;/code&gt; инициализируется и содержит значения &lt;code&gt;1:length(ix)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="529e4e84127591bc458006a7c31028da87258a93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;, but stores output in &lt;code&gt;results&lt;/code&gt; rather than returning a collection.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt; , но сохраняет вывод в &lt;code&gt;results&lt;/code&gt; а не возвращает коллекцию.</target>
        </trans-unit>
        <trans-unit id="06d62bd10c05ce2bf6e378f3ac0cebfd0dc1f43e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, except reads code from the given string rather than from a file.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; , за исключением того, что читает код из заданной строки, а не из файла.</target>
        </trans-unit>
        <trans-unit id="33fc1f575b86086215aa1689af4abbedb592d014" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but stores the result in &lt;code&gt;destination&lt;/code&gt; rather than a new collection. &lt;code&gt;destination&lt;/code&gt; must be at least as large as the first collection.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; , но сохраняет результат в &lt;code&gt;destination&lt;/code&gt; а не в новой коллекции. &lt;code&gt;destination&lt;/code&gt; должен быть не меньше размера первой коллекции.</target>
        </trans-unit>
        <trans-unit id="9053e0f6dd39d888ac2c2e819878de129f87dfec" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity, as in &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt; , но с гарантированной левой ассоциативностью, как в &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt; . Если указано, ключевое слово аргумент &lt;code&gt;init&lt;/code&gt; будет использоваться только один раз. В общем, нужно будет предоставить &lt;code&gt;init&lt;/code&gt; для работы с пустыми коллекциями.</target>
        </trans-unit>
        <trans-unit id="ffe977f18117519aca83d726747101ffed876b72" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity, as in &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt; , но с гарантированной правой ассоциативностью, как в &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; &lt;/a&gt; . Если указано, ключевое слово аргумент &lt;code&gt;init&lt;/code&gt; будет использоваться только один раз. В общем, нужно будет предоставить &lt;code&gt;init&lt;/code&gt; для работы с пустыми коллекциями.</target>
        </trans-unit>
        <trans-unit id="9d8eaa8363c2e7fc8a90587868e4968a125caadc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, but returns either a value of the requested type, or &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; if the string does not contain a valid number.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; , но возвращает либо значение запрошенного типа, либо &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; если строка не содержит действительного числа.</target>
        </trans-unit>
        <trans-unit id="51eaec3c8abd237c8d9e9bba6cf07e3a4cb08010" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;permute!&lt;/code&gt;&lt;/a&gt;, but the inverse of the given permutation is applied.</source>
          <target state="translated">Нравится &lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;permute!&lt;/code&gt; &lt;/a&gt;, но применяется обратная к данной перестановке.</target>
        </trans-unit>
        <trans-unit id="4756a006313f096261885c0ef2037e8fe0a50c17" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как &lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt; , но для &lt;a href=&quot;#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f085d340882a97bb66329f21bdf7b61cf3ba9878" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;. Note that the order of the return tuple is still &lt;code&gt;(rd, wr)&lt;/code&gt;, i.e. data to be read from &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; may be written to &lt;code&gt;wr&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt; , но для &lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что порядок возвращаемого кортежа по-прежнему &lt;code&gt;(rd, wr)&lt;/code&gt; , т.е. данные, считываемые из &lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; ,&lt;/a&gt; могут быть записаны в &lt;code&gt;wr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5dd7f815a4d7bf1a89e4740bb5b8ac9a464da9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">Как и &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; , но с гарантированной левой ассоциативностью. Если указано, ключевое слово аргумент &lt;code&gt;init&lt;/code&gt; будет использоваться только один раз. В общем, нужно будет предоставить &lt;code&gt;init&lt;/code&gt; для работы с пустыми коллекциями.</target>
        </trans-unit>
        <trans-unit id="024595a61bd923552b757965d3ba72515fa95986" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">Вроде &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; , но с гарантированной правильной ассоциативностью. Если указано, ключевое слово аргумент &lt;code&gt;init&lt;/code&gt; будет использоваться только один раз. В общем, нужно будет предоставить &lt;code&gt;init&lt;/code&gt; для работы с пустыми коллекциями.</target>
        </trans-unit>
        <trans-unit id="1ef0876ab486f437b72ce65e44751d3b6dbccac7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.sortperm&quot;&gt;&lt;code&gt;sortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(v)&lt;/code&gt;.</source>
          <target state="translated">Как &lt;a href=&quot;#Base.sortperm&quot;&gt; &lt;code&gt;sortperm&lt;/code&gt; &lt;/a&gt; , но принимает предварительно выделенный индексный вектор &lt;code&gt;ix&lt;/code&gt; . Если значение &lt;code&gt;initialized&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; (по умолчанию), &lt;code&gt;ix&lt;/code&gt; инициализируется и содержит значения &lt;code&gt;1:length(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08026f6d5cc67e6a499233d241ca672fd865f4fa" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; , но для символьных ссылок получает информацию о самой ссылке, а не о файле, на который она ссылается. Эта функция должна вызываться для пути к файлу, а не для объекта файла или дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="f60e04278b9015f6c3e9ffaf7e10b12cd6419309" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.systemerror&quot;&gt;&lt;code&gt;systemerror&lt;/code&gt;&lt;/a&gt;, but for Windows API functions that use &lt;a href=&quot;../libc/index#Base.Libc.GetLastError&quot;&gt;&lt;code&gt;GetLastError&lt;/code&gt;&lt;/a&gt; to return an error code instead of setting &lt;a href=&quot;../libc/index#Base.Libc.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3086501e29c75ea565e72a0019576b980b02fe5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt;, but the results are stored in &lt;code&gt;S&lt;/code&gt; (which is resized as needed).</source>
          <target state="translated">Как &lt;a href=&quot;#Random.randsubseq&quot;&gt; &lt;code&gt;randsubseq&lt;/code&gt; &lt;/a&gt; , но результаты сохраняются в &lt;code&gt;S&lt;/code&gt; (размер которого изменяется по мере необходимости).</target>
        </trans-unit>
        <trans-unit id="eb969f16d7c8b092d782534c60f5aa57438f02b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Statistics.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, but may overwrite the input vector.</source>
          <target state="translated">Подобно &lt;a href=&quot;#Statistics.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; , но может перезаписать входной вектор.</target>
        </trans-unit>
        <trans-unit id="c740cd8f4daa963edb800319e0b46fdd4c9b8a9e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent array &lt;code&gt;A&lt;/code&gt; with the given indices instead of making a copy. Calling &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;SubArray&lt;/code&gt; computes the indices to the parent array on the fly without checking bounds.</source>
          <target state="translated">Подобно &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; , но вместо создания копии возвращает представление в родительский массив &lt;code&gt;A&lt;/code&gt; с заданными индексами. Вызов &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;на возвращенном &lt;code&gt;SubArray&lt;/code&gt; вычисляет индексы родительского массива &amp;laquo;на лету&amp;raquo; без проверки границ.</target>
        </trans-unit>
        <trans-unit id="a4ecbe47eb2e0c87296b762b01d3e9398f50b6c5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent string &lt;code&gt;s&lt;/code&gt; within range &lt;code&gt;i:j&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; respectively instead of making a copy.</source>
          <target state="translated">Подобно &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; , но вместо копирования возвращает представление в родительскую строку &lt;code&gt;s&lt;/code&gt; в диапазоне &lt;code&gt;i:j&lt;/code&gt; или &lt;code&gt;r&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="c974955b45097854e43f11799b1b6bcc9d8f3eee" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SamplerDie&lt;/code&gt;, any custom sampler must be a subtype of &lt;code&gt;Sampler{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the type of the generated values. Note that &lt;code&gt;SamplerSimple(x, data) isa Sampler{eltype(x)}&lt;/code&gt;, so this constrains what the first argument to &lt;code&gt;SamplerSimple&lt;/code&gt; can be (it's recommended to use &lt;code&gt;SamplerSimple&lt;/code&gt; like in the &lt;code&gt;Die&lt;/code&gt; example, where &lt;code&gt;x&lt;/code&gt; is simply forwarded while defining a &lt;code&gt;Sampler&lt;/code&gt; method). Similarly, &lt;code&gt;SamplerTrivial(x) isa Sampler{eltype(x)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807404638eb67f1a49cc813e53a998bea5df9d33" translate="yes" xml:space="preserve">
          <source>Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt;&lt;code&gt;AbstractChar&lt;/code&gt;&lt;/a&gt;. The built-in &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; subtype of &lt;code&gt;AbstractChar&lt;/code&gt; is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).</source>
          <target state="translated">Подобно C и Java, но в отличие от большинства динамических языков, Julia имеет первоклассный тип для представления одного символа, называемый &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt; &lt;code&gt;AbstractChar&lt;/code&gt; &lt;/a&gt; . Встроенный подтип &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt; в &lt;code&gt;AbstractChar&lt;/code&gt; - это 32-битный примитивный тип, который может представлять любой символ Юникода (и основан на кодировке UTF-8).</target>
        </trans-unit>
        <trans-unit id="b144d1ab3b4daafe713dd1906d84dd6576675e14" translate="yes" xml:space="preserve">
          <source>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">Как и ccall,все эти аргументы будут вычислены во время компиляции,когда будет определен содержащий метод.</target>
        </trans-unit>
        <trans-unit id="d14af23f7b07876d0e17dec387b3e911da07b564" translate="yes" xml:space="preserve">
          <source>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; is valid R but the equivalent &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; will throw an error in Julia.</source>
          <target state="translated">Как и многие языки, Julia не всегда допускает операции с векторами разной длины, в отличие от R, где векторы должны иметь только общий диапазон индексов. Например, &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; является допустимым R, но эквивалент &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; вызовет ошибку в Julia.</target>
        </trans-unit>
        <trans-unit id="76129ab650b5177af08ad48252475d8daddeec47" translate="yes" xml:space="preserve">
          <source>Like many other environments, Julia has an &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; function, which takes a filename and returns an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object that you can use to read and write things from the file. For example, if we have a file, &lt;code&gt;hello.txt&lt;/code&gt;, whose contents are &lt;code&gt;Hello, World!&lt;/code&gt;:</source>
          <target state="translated">Как и во многих других средах, у Julia есть функция &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; , которая принимает имя файла и возвращает объект &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; ,&lt;/a&gt; который вы можете использовать для чтения и записи из файла. Например, если у нас есть файл &lt;code&gt;hello.txt&lt;/code&gt; , содержимое которого - &lt;code&gt;Hello, World!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f57deb1de610f6542b69d3ee454e00aa561ce8c" translate="yes" xml:space="preserve">
          <source>Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal &lt;code&gt;custom`literal`&lt;/code&gt; is parsed as &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt;. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the &lt;code&gt;_cmd&lt;/code&gt; suffix instead of the &lt;code&gt;_str&lt;/code&gt; suffix, non-standard command literals behave exactly like non-standard string literals.</source>
          <target state="translated">Как и нестандартные строковые литералы, нестандартные командные литералы существуют с использованием префиксного варианта синтаксиса командного литерала. Командный литерал &lt;code&gt;custom`literal`&lt;/code&gt; разбирается как &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt; . Сама Julia не содержит нестандартных командных литералов, но пакеты могут использовать этот синтаксис. Помимо другого синтаксиса и суффикса &lt;code&gt;_cmd&lt;/code&gt; вместо суффикса &lt;code&gt;_str&lt;/code&gt; , нестандартные командные литералы ведут себя точно так же, как нестандартные строковые литералы.</target>
        </trans-unit>
        <trans-unit id="ca04337635b1b8ca769f7475dd5bb9a710a07316" translate="yes" xml:space="preserve">
          <source>Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</source>
          <target state="translated">Как и удаленные ссылки,общие массивы также зависят от сбора мусора на создающем узле,чтобы выпустить ссылки от всех участвующих рабочих.Код,создающий множество короткоживущих объектов общих массивов,выиграет от явной доработки этих объектов как можно быстрее.Это приводит к тому,что как память,так и файловые дескрипторы,отображающие общий сегмент,освобождаются быстрее.</target>
        </trans-unit>
        <trans-unit id="bc02118fe44dfd1db0138406f1b30a59afe69954" translate="yes" xml:space="preserve">
          <source>Likewise, the global variable &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; determines a relative path to the configuration file directory. Then Julia searches for a &lt;code&gt;startup.jl&lt;/code&gt; file at</source>
          <target state="translated">Точно так же глобальная переменная &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; определяет относительный путь к каталогу файла конфигурации. Затем Юлия ищет файл &lt;code&gt;startup.jl&lt;/code&gt; по адресу</target>
        </trans-unit>
        <trans-unit id="40654ee5f02852c7196e6e2f00f07fee2fb0ef03" translate="yes" xml:space="preserve">
          <source>Limit usage of CPU features up to &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt;; set to &lt;code&gt;help&lt;/code&gt; to see the available options</source>
          <target state="translated">Ограничить использование функций ЦП до &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; ; установите, чтобы &lt;code&gt;help&lt;/code&gt; увидеть доступные параметры</target>
        </trans-unit>
        <trans-unit id="8d96ce8bb4e79cb43743b90921151985b53e510c" translate="yes" xml:space="preserve">
          <source>LinRange</source>
          <target state="translated">LinRange</target>
        </trans-unit>
        <trans-unit id="d937e9c2df56b1e58e5b8819252e720563fa79ea" translate="yes" xml:space="preserve">
          <source>Line 3 of &lt;code&gt;myfunc&lt;/code&gt; contains the call to &lt;code&gt;maximum&lt;/code&gt;, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in &lt;code&gt;base/reduce.jl&lt;/code&gt; that carry out the time-consuming operations in the &lt;code&gt;maximum&lt;/code&gt; function for this type of input data.</source>
          <target state="translated">Строка 3 &lt;code&gt;myfunc&lt;/code&gt; содержит вызов до &lt;code&gt;maximum&lt;/code&gt; , и здесь было выполнено 28 трассировок (из 80). Ниже вы можете увидеть определенные места в &lt;code&gt;base/reduce.jl&lt;/code&gt; , которые выполняют трудоемкие операции в функции &lt;code&gt;maximum&lt;/code&gt; для этого типа входных данных.</target>
        </trans-unit>
        <trans-unit id="677b9ff91279f2c92df14e8f98feaaad0ff02671" translate="yes" xml:space="preserve">
          <source>Line Integration Not Including The Pole</source>
          <target state="translated">Интеграция линии без учета полюса</target>
        </trans-unit>
        <trans-unit id="aa862b80ca648d32974899a07b490c840367365f" translate="yes" xml:space="preserve">
          <source>Line Integration With Rectangular Path Around Pole</source>
          <target state="translated">Интеграция линии с прямоугольной трассой вокруг полюса</target>
        </trans-unit>
        <trans-unit id="cd235d8e390a116750618564e9fef4ddd8d815c0" translate="yes" xml:space="preserve">
          <source>Line Integration With Semicircular Path Around Pole</source>
          <target state="translated">Интеграция линии с полукруглой траекторией вокруг полюса</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">Линейная алгебра</target>
        </trans-unit>
        <trans-unit id="3ab90484838b94648400b6fcaea9c0833f594271" translate="yes" xml:space="preserve">
          <source>Linear algebra functions in Julia are largely implemented by calling functions from &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;. Sparse factorizations call functions from &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;.</source>
          <target state="translated">Функции линейной алгебры в Julia в значительной степени реализуются путем вызова функций из &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt; . Разреженные факторизации вызывают функции из &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1c65bd6bdbd1cc3a07c925c8d1f63a9ef479713" translate="yes" xml:space="preserve">
          <source>Linear index to cartesian index conversion exploits the fact that a &lt;code&gt;CartesianIndices&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt; and can be indexed linearly:</source>
          <target state="translated">Преобразование линейного индекса в декартово индексирование использует тот факт, что &lt;code&gt;CartesianIndices&lt;/code&gt; является &lt;code&gt;AbstractArray&lt;/code&gt; и может индексироваться линейно:</target>
        </trans-unit>
        <trans-unit id="c1c4acc4812d010d9f4c5b8b2c947ad6bf3a9bbc" translate="yes" xml:space="preserve">
          <source>Linear indexing</source>
          <target state="translated">Линейная индексация</target>
        </trans-unit>
        <trans-unit id="a4c16b0102a66cf314085c9fb0015204063e6fd3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Adjoint</source>
          <target state="translated">LinearAlgebra.Adjoint</target>
        </trans-unit>
        <trans-unit id="f15dbf32eea38f12565a79b8c505de8f87a92ec9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS</source>
          <target state="translated">LinearAlgebra.BLAS</target>
        </trans-unit>
        <trans-unit id="e45107bca3f2265e5d9c85ca1c9fec27cc17de1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.asum()</source>
          <target state="translated">LinearAlgebra.BLAS.asum()</target>
        </trans-unit>
        <trans-unit id="0372d64ede3f868ef8099f9d2d0ba0d26301cae5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.blascopy!()</source>
          <target state="translated">LinearAlgebra.BLAS.blascopy!()</target>
        </trans-unit>
        <trans-unit id="d13717e84d8e032e30650fc47582fb7cd32b85c2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotc()</source>
          <target state="translated">LinearAlgebra.BLAS.dotc()</target>
        </trans-unit>
        <trans-unit id="80b561d6fb654a4f5dbc4d039a743babeb78f05a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotu()</source>
          <target state="translated">LinearAlgebra.BLAS.dotu()</target>
        </trans-unit>
        <trans-unit id="182543675c48dfba38aa5478d8ce3279d26d4ef4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv!()</target>
        </trans-unit>
        <trans-unit id="6cec9f631b39a94bb3001b07c15c7364aacddbae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv()</target>
        </trans-unit>
        <trans-unit id="59202f7fad0ff0f17101364487458d9228718112" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm!()</target>
        </trans-unit>
        <trans-unit id="a90dea0e894e7db5d100f0da8dd99eb55becb11a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm()</target>
        </trans-unit>
        <trans-unit id="9c43130d6006aefdd06d70d7199a76e138e6d41f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv!()</target>
        </trans-unit>
        <trans-unit id="9e7d057213847eff9fcee5278de6f9c65c129248" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv()</target>
        </trans-unit>
        <trans-unit id="7de983e341dd493a6005bdeccd16b2008abe1b4c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.ger!()</source>
          <target state="translated">LinearAlgebra.BLAS.ger!()</target>
        </trans-unit>
        <trans-unit id="c508786b30abc595e3c001798b77caf3e83ceab1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.her!()</source>
          <target state="translated">LinearAlgebra.BLAS.her!()</target>
        </trans-unit>
        <trans-unit id="01f3abbc9926c6680a10dada97213576f68220e4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk!()</source>
          <target state="translated">LinearAlgebra.BLAS.herk!()</target>
        </trans-unit>
        <trans-unit id="7ca416ce67850358cd75772ae19bf13edb1e3145" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk()</source>
          <target state="translated">LinearAlgebra.BLAS.herk()</target>
        </trans-unit>
        <trans-unit id="ae660954410680fe7bf17073b8a5a13e3d858105" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.iamax()</source>
          <target state="translated">LinearAlgebra.BLAS.iamax()</target>
        </trans-unit>
        <trans-unit id="cd1a2671bbd0fd5d0123954f4b697032be1e635c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.nrm2()</source>
          <target state="translated">LinearAlgebra.BLAS.nrm2()</target>
        </trans-unit>
        <trans-unit id="e90dcf81b0d3bcd42a1f41c82cba29bfcb9a2dc1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv!()</target>
        </trans-unit>
        <trans-unit id="726229488f087bf6f4b29c015474123c38acb7e3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv()</target>
        </trans-unit>
        <trans-unit id="e38b1b5860121c691bed2ff0a82bb4bddb43aeda" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal!()</source>
          <target state="translated">LinearAlgebra.BLAS.scal!()</target>
        </trans-unit>
        <trans-unit id="4a5ae3b0e35b9b56d0ca4f544caed75fc4410c97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal()</source>
          <target state="translated">LinearAlgebra.BLAS.scal()</target>
        </trans-unit>
        <trans-unit id="bd2ae45b248f17f2163a416ae8b1b8f316599548" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.set_num_threads()</source>
          <target state="translated">LinearAlgebra.BLAS.set_num_threads()</target>
        </trans-unit>
        <trans-unit id="0ee907ef539363efacff8c904278837def446859" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm!()</source>
          <target state="translated">LinearAlgebra.BLAS.symm!()</target>
        </trans-unit>
        <trans-unit id="2ca89af9829c4450e1da15d694b423f02feaf2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm()</source>
          <target state="translated">LinearAlgebra.BLAS.symm()</target>
        </trans-unit>
        <trans-unit id="c4ff899252dc161c59c729ece50db7c6e510be1f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv!()</source>
          <target state="translated">LinearAlgebra.BLAS.symv!()</target>
        </trans-unit>
        <trans-unit id="c3f814d8d8c968ce7e35bf9e0c795e7503d54b00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv()</source>
          <target state="translated">LinearAlgebra.BLAS.symv()</target>
        </trans-unit>
        <trans-unit id="5668a0235a5cc16113ef6c829d5f4f3cb946eb77" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syr!()</source>
          <target state="translated">LinearAlgebra.BLAS.syr!()</target>
        </trans-unit>
        <trans-unit id="0ea3ba86e685fafe1804ca06ce2cc0aa30792e4d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk!()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk!()</target>
        </trans-unit>
        <trans-unit id="2910b73b192710f5034193e1b67ded6bb10699b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk()</target>
        </trans-unit>
        <trans-unit id="c657c078868b4b49e269336d3ff46af071f8fa01" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm!()</target>
        </trans-unit>
        <trans-unit id="04b9bf86a921535849558977a38bc7efdcdd3272" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm()</target>
        </trans-unit>
        <trans-unit id="9d8cb1ea03abc954f9254445e2db3781f49756de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv!()</target>
        </trans-unit>
        <trans-unit id="72558d3ed3ecbb2cf81ea6ad3401440af8b8f050" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv()</target>
        </trans-unit>
        <trans-unit id="218cea369dcdb92ba6f1e8b45bda62d05efdb29f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm!()</target>
        </trans-unit>
        <trans-unit id="05197b08bc46d65744a62e5816cecfcc72ef9983" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm()</target>
        </trans-unit>
        <trans-unit id="a147ea56a9e55d82d2590cd764be5c11a28ac42c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv!()</target>
        </trans-unit>
        <trans-unit id="3205efa3be1bef6bfc936054e89c97d514d48dc9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv()</target>
        </trans-unit>
        <trans-unit id="6364f45353271734da7f68207b58b49b90c519aa" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Bidiagonal</source>
          <target state="translated">LinearAlgebra.Bidiagonal</target>
        </trans-unit>
        <trans-unit id="b0cf658cc297affd7bac8f29cb18f8d5898c988a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Diagonal</source>
          <target state="translated">LinearAlgebra.Diagonal</target>
        </trans-unit>
        <trans-unit id="1b39c6247cb769989ac9ddbddb50b7a2c7340d63" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Givens</source>
          <target state="translated">LinearAlgebra.Givens</target>
        </trans-unit>
        <trans-unit id="202cd7384296c88f891bea55496b32195e848e3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Hermitian</source>
          <target state="translated">LinearAlgebra.Hermitian</target>
        </trans-unit>
        <trans-unit id="79fc319c7c269772fed2f361672bd676a3520fae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.I</source>
          <target state="translated">LinearAlgebra.I</target>
        </trans-unit>
        <trans-unit id="2a1626ced0dce6995c5f58e8d3def911fe7d751f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK</source>
          <target state="translated">LinearAlgebra.LAPACK</target>
        </trans-unit>
        <trans-unit id="6952bafd874a0b24bee2d594a25adae4924e4368" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsdc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsdc!()</target>
        </trans-unit>
        <trans-unit id="8d0c6a0d204bac9380f45220c8b25a01fbcacfc6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsqr!()</target>
        </trans-unit>
        <trans-unit id="21f727539d33d03dc8b986b7ecf7ebc53925b185" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrf!()</target>
        </trans-unit>
        <trans-unit id="2bb72a67df1d100e66f590117e79a6b1fe23456f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrs!()</target>
        </trans-unit>
        <trans-unit id="042b17e7fbbcced06624b5d18cecc1aa4880dfbf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebak!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebak!()</target>
        </trans-unit>
        <trans-unit id="5d6511493ba85c27c966c3e62df9148d39254215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebal!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebal!()</target>
        </trans-unit>
        <trans-unit id="3f829c89a9fa98bb138c195dfc567bcd88556869" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebrd!()</target>
        </trans-unit>
        <trans-unit id="7b9eae4d91dc7949a3ab26f80620c6913329a279" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gecon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gecon!()</target>
        </trans-unit>
        <trans-unit id="bb09b2b974d5f60b025547cb0fa46b9c45f6eabf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gees!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gees!()</target>
        </trans-unit>
        <trans-unit id="4adfdd0d27bb95b254d684fb07bba4182c2a0a10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geev!()</target>
        </trans-unit>
        <trans-unit id="f5fc1d59d033c8ca0452a21a055c7e9b2cdc3409" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geevx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geevx!()</target>
        </trans-unit>
        <trans-unit id="4162f14b7f241061ff814adad6bc4880eae0e215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gehrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gehrd!()</target>
        </trans-unit>
        <trans-unit id="8e52c2ea87a7196909af8b847322a690fcef6a4f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelqf!()</target>
        </trans-unit>
        <trans-unit id="b7bb54e5159886ceee34f20483cdbbf42f4c1539" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gels!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gels!()</target>
        </trans-unit>
        <trans-unit id="7f10b1dc3cf7af9a395a67850e24907c94936d00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsd!()</target>
        </trans-unit>
        <trans-unit id="80af9020ee1658e044f9880edaa420f6156e7344" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsy!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsy!()</target>
        </trans-unit>
        <trans-unit id="0287631b489ed93feb1a00a1ebe340392e903cd8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gemqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gemqrt!()</target>
        </trans-unit>
        <trans-unit id="756fb9e8e80236b54ccbf1725c3d3d72fe14d0a7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqlf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqlf!()</target>
        </trans-unit>
        <trans-unit id="0fa233b136691bcd50a971792940b70a927e194d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqp3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqp3!()</target>
        </trans-unit>
        <trans-unit id="965cf80f5d69f9b2fe0863a82cdd4b368ed4eba1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrf!()</target>
        </trans-unit>
        <trans-unit id="47893a6fd6bd1458706a0673e1d64d54be6d20ec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt!()</target>
        </trans-unit>
        <trans-unit id="94f19bfcd3971a4989d673487abd3bd487d293d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt3!()</target>
        </trans-unit>
        <trans-unit id="19ff37cfcf822fda7f988e77f92c195943446d8b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gerqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gerqf!()</target>
        </trans-unit>
        <trans-unit id="c47fe5b7f34f49ec65d1767c07d0c357d6c12e20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesdd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesdd!()</target>
        </trans-unit>
        <trans-unit id="5abf4ebce7739a88e07c58cc2ab150c8e79b9a6f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesv!()</target>
        </trans-unit>
        <trans-unit id="f900ac3ce3ebbd4997a5abaafa85072405326271" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvd!()</target>
        </trans-unit>
        <trans-unit id="3a69b9c0d56562dd7ea697ae7f5eea3c3217e8c4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvx!()</target>
        </trans-unit>
        <trans-unit id="997ad4b85fe561bd14fecda4a9185c9be5de7367" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrf!()</target>
        </trans-unit>
        <trans-unit id="d93427849097672e5ca2dd0b81aead36db3bffe6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getri!()</target>
        </trans-unit>
        <trans-unit id="46614120fda23ffee34b46ef06a4d2717d89fb72" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrs!()</target>
        </trans-unit>
        <trans-unit id="3d14f5edf2f52561c8b1cfcc015d4eefd5e8344a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gges!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gges!()</target>
        </trans-unit>
        <trans-unit id="7a73e7bdeb2ad0938d68fd93e6f27345108ba8b1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggev!()</target>
        </trans-unit>
        <trans-unit id="3ae17e2685021efceba3fcfa226528ce1e41d6a9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gglse!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gglse!()</target>
        </trans-unit>
        <trans-unit id="3100382b56a5f6703f1da34614842b2f9fd9e2ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd!()</target>
        </trans-unit>
        <trans-unit id="61dfaab553dd3ccfaacf89bcaa2704beb947b945" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd3!()</target>
        </trans-unit>
        <trans-unit id="db05e9a4a5c735805bf40092dca7033de637b064" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gtsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gtsv!()</target>
        </trans-unit>
        <trans-unit id="9b6b3e96efd10abaf039016da8b07d6fdefa2dac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrf!()</target>
        </trans-unit>
        <trans-unit id="7d5b231fee9480951dc3ad4ba6239425f9a1a69e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrs!()</target>
        </trans-unit>
        <trans-unit id="56b45916f3c5b6ccae7d5897efff708c77670fe9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hesv!()</target>
        </trans-unit>
        <trans-unit id="1dd5d2c561afecfbda18ff5f8f3e44ea02e6d2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrf!()</target>
        </trans-unit>
        <trans-unit id="cf6a921b989ce1adbf03be52e76504708a3db4ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetri!()</target>
        </trans-unit>
        <trans-unit id="a535b2e2552fdefb2e31ef5cf705c68b406e0e4e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrs!()</target>
        </trans-unit>
        <trans-unit id="3c7e4832c831bf40fdec955ad64e7df4981b628e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orghr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orghr!()</target>
        </trans-unit>
        <trans-unit id="9afd9979936c6db6319fad409953eb23f579d5ca" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orglq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orglq!()</target>
        </trans-unit>
        <trans-unit id="72fc39a42e1ba3ec988e4e34aca8961c7d4dd43b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgql!()</target>
        </trans-unit>
        <trans-unit id="3f36d991b78dd60e8ba960e3ddf5db19bd097fb8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgqr!()</target>
        </trans-unit>
        <trans-unit id="18eb3015f314ddb831889efa958dd72893b66864" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgrq!()</target>
        </trans-unit>
        <trans-unit id="ee585149aad96671646932b1d3634278142c13f9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormlq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormlq!()</target>
        </trans-unit>
        <trans-unit id="bdfbc8d40444d8bafd90c67f455d3b34e73228cf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormql!()</target>
        </trans-unit>
        <trans-unit id="1087b8488a465127e32826863adc779bd9d1327c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormqr!()</target>
        </trans-unit>
        <trans-unit id="a2fb188b73bde57195bb1d824030a4ed0bbd608b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrq!()</target>
        </trans-unit>
        <trans-unit id="ffa8283f30595d57d465f23f206871d42b88b987" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrz!()</target>
        </trans-unit>
        <trans-unit id="c7253e7d1bd1dce84f707a9c7bb94c23529af18b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.posv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.posv!()</target>
        </trans-unit>
        <trans-unit id="9686f05e5f67aa477b854f99ab98169e47b19084" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrf!()</target>
        </trans-unit>
        <trans-unit id="a162ea4f7602eae7842c83604fa469aeb77c3bfd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potri!()</target>
        </trans-unit>
        <trans-unit id="22fdc042984e65bbd42e11f87af366faeef74622" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrs!()</target>
        </trans-unit>
        <trans-unit id="2e152451a9c97ebf916e592216ff01087a6982bd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pstrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pstrf!()</target>
        </trans-unit>
        <trans-unit id="9a048d5b8589397c46ecf7dd3a023271382559b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ptsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ptsv!()</target>
        </trans-unit>
        <trans-unit id="6bd4c3257dbbd4280e5dfb016628a7275adf1a33" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrf!()</target>
        </trans-unit>
        <trans-unit id="959a9d0a79a973f313fff6fc55c623c797c6c7f7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrs!()</target>
        </trans-unit>
        <trans-unit id="6d7e0b67347ba1e8b9a711859117ac575684e8e1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stebz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stebz!()</target>
        </trans-unit>
        <trans-unit id="e4c4102de134bdf1c8c27920913760be8971f8a2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stegr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stegr!()</target>
        </trans-unit>
        <trans-unit id="09e672928c1ecc7dda3783503f4b5dded92b9673" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stein!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stein!()</target>
        </trans-unit>
        <trans-unit id="eace3492602beabe1f2ab7981e7d9209cfc2204c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stev!()</target>
        </trans-unit>
        <trans-unit id="66d07521e84ded0664c8e6d24cb062cfa0abf44c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syconv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syconv!()</target>
        </trans-unit>
        <trans-unit id="e37c017154e2c1fa3c47a038f981c9a2f9b128ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syev!()</target>
        </trans-unit>
        <trans-unit id="371acb573fdc2cfe58acc84371e930aa7f66f883" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syevr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syevr!()</target>
        </trans-unit>
        <trans-unit id="4489b4eba27fe6a94403f8fc257631ee4a85b0d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sygvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sygvd!()</target>
        </trans-unit>
        <trans-unit id="f6128668d243c8ac355a7d5c46c06adfedbfe0c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sysv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sysv!()</target>
        </trans-unit>
        <trans-unit id="022ac6bcea134ce5fe3a89f3bf4383107b51b2a0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrf!()</target>
        </trans-unit>
        <trans-unit id="a8bb80be7fdb78fb2ac23b9a1ad4b26eace9add4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytri!()</target>
        </trans-unit>
        <trans-unit id="9d2a23098c970b0a82d03a2a452ca8118a4c74c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrs!()</target>
        </trans-unit>
        <trans-unit id="83c634bcfc2f6365a7a5ab5dac799d6cefa5dae1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tgsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tgsen!()</target>
        </trans-unit>
        <trans-unit id="b190b8b87f953db3f01614e0cef9f46ab8ddef6c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trcon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trcon!()</target>
        </trans-unit>
        <trans-unit id="81c93a5fe65faa5e18e25557226f1e29499c9834" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trevc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trevc!()</target>
        </trans-unit>
        <trans-unit id="0fde83f3dc9a18889586b82aefe631e75f1ca0a5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trexc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trexc!()</target>
        </trans-unit>
        <trans-unit id="e0a6fb5f31ac808c6c4c2d58c9bd3c8bf4547c3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trrfs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trrfs!()</target>
        </trans-unit>
        <trans-unit id="b4a63b08edea3206f96883f52f887e335290d30c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsen!()</target>
        </trans-unit>
        <trans-unit id="0981f544b1017b88401f0c0d727a8512e3a16911" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsyl!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsyl!()</target>
        </trans-unit>
        <trans-unit id="0dd13d83537af1986304c93341975314e0a3cb92" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtri!()</target>
        </trans-unit>
        <trans-unit id="6ace8e21c229caf81f057c6691dc06ea1d7feacb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtrs!()</target>
        </trans-unit>
        <trans-unit id="9f4a95aa5cd6a48d65dcce0dfbc0c2104db08ddb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tzrzf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tzrzf!()</target>
        </trans-unit>
        <trans-unit id="8dc3928b7aacf4bc69fb8fb480397c2bd0754291" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LowerTriangular</source>
          <target state="translated">LinearAlgebra.LowerTriangular</target>
        </trans-unit>
        <trans-unit id="d296a34551600570579f05eb52f68d858500b6d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.PosDefException</source>
          <target state="translated">LinearAlgebra.PosDefException</target>
        </trans-unit>
        <trans-unit id="1a5ee969e2fda57a234091ffc7169bb0717b4b55" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QR</source>
          <target state="translated">LinearAlgebra.QR</target>
        </trans-unit>
        <trans-unit id="f252432902b3e7d2b6f5a1f541fab2b2b837e497" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRCompactWY</source>
          <target state="translated">LinearAlgebra.QRCompactWY</target>
        </trans-unit>
        <trans-unit id="f69a9de928f655bcff2c3bb620374afc9c7adc36" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRPivoted</source>
          <target state="translated">LinearAlgebra.QRPivoted</target>
        </trans-unit>
        <trans-unit id="91c43501578d11cc7b806496b694bc7fb0798c40" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SingularException</source>
          <target state="translated">LinearAlgebra.SingularException</target>
        </trans-unit>
        <trans-unit id="21fa708b4606d3744276dbdb6504d1d33fb0880d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SymTridiagonal</source>
          <target state="translated">LinearAlgebra.SymTridiagonal</target>
        </trans-unit>
        <trans-unit id="c49662dfefa654d140f37c4f501e68d902dc9896" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Symmetric</source>
          <target state="translated">LinearAlgebra.Symmetric</target>
        </trans-unit>
        <trans-unit id="0b7bcff88afd509726e928a1da4371d5aad48e96" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Transpose</source>
          <target state="translated">LinearAlgebra.Transpose</target>
        </trans-unit>
        <trans-unit id="2f6e7904ca2d80d08fecb44ff694e5529ca8a0d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Tridiagonal</source>
          <target state="translated">LinearAlgebra.Tridiagonal</target>
        </trans-unit>
        <trans-unit id="bcd3cd958cfc2292b170f7eb25170c03f9af2ed5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UniformScaling</source>
          <target state="translated">LinearAlgebra.UniformScaling</target>
        </trans-unit>
        <trans-unit id="5441959246e16a93a832c57343376624fe880467" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitLowerTriangular</source>
          <target state="translated">LinearAlgebra.UnitLowerTriangular</target>
        </trans-unit>
        <trans-unit id="828cc10c694c730e1acddbbb4fe2c09ed2dca433" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitUpperTriangular</source>
          <target state="translated">LinearAlgebra.UnitUpperTriangular</target>
        </trans-unit>
        <trans-unit id="fa757c0838038ffc2a6e801a13ed5a7b6a193380" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UpperTriangular</source>
          <target state="translated">LinearAlgebra.UpperTriangular</target>
        </trans-unit>
        <trans-unit id="738beaba8ed2df6f31a673ee2db8f7e43295d515" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.adjoint!()</source>
          <target state="translated">LinearAlgebra.adjoint!()</target>
        </trans-unit>
        <trans-unit id="9920d50dc92a459847aa3353d4531d0f64c48729" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.axpy!()</source>
          <target state="translated">LinearAlgebra.axpy!()</target>
        </trans-unit>
        <trans-unit id="8382532f0eba26f9bafb22dc5faa9989630741b4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman!()</source>
          <target state="translated">LinearAlgebra.bunchkaufman!()</target>
        </trans-unit>
        <trans-unit id="f1ff255591a788d659f39c668b504aff71f28694" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman()</source>
          <target state="translated">LinearAlgebra.bunchkaufman()</target>
        </trans-unit>
        <trans-unit id="49b3835122bf27c1a5c23bc1f6af4df7016dfd20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.checksquare()</source>
          <target state="translated">LinearAlgebra.checksquare()</target>
        </trans-unit>
        <trans-unit id="f296f09ff80bdc588b439135e7b625bce1f0d744" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky!()</source>
          <target state="translated">LinearAlgebra.cholesky!()</target>
        </trans-unit>
        <trans-unit id="2614d615a16d87a3a50db7af9f3788e4b71855b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky()</source>
          <target state="translated">LinearAlgebra.cholesky()</target>
        </trans-unit>
        <trans-unit id="848b264dd28237efb792aa43901c5f8f5aab83f0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cond()</source>
          <target state="translated">LinearAlgebra.cond()</target>
        </trans-unit>
        <trans-unit id="763a7ceb07efeb8156da716b3ef8c72573b2e7a4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.condskeel()</source>
          <target state="translated">LinearAlgebra.condskeel()</target>
        </trans-unit>
        <trans-unit id="639f206bebf5466d93a4ba2c03f4c4a29b6d5ea5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cross()</source>
          <target state="translated">LinearAlgebra.cross()</target>
        </trans-unit>
        <trans-unit id="d362f85f49e425d14c9978220ba2468f026a4067" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.det()</source>
          <target state="translated">LinearAlgebra.det()</target>
        </trans-unit>
        <trans-unit id="9abda27c81a472d3c63a1a657c4bee31686d49bc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diag()</source>
          <target state="translated">LinearAlgebra.diag()</target>
        </trans-unit>
        <trans-unit id="a7c7cacbbacea0c74222541b31910df567bdb6fb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagind()</source>
          <target state="translated">LinearAlgebra.diagind()</target>
        </trans-unit>
        <trans-unit id="1aef8c46a780d7765016e06dcf0a60d28ea11f98" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagm()</source>
          <target state="translated">LinearAlgebra.diagm()</target>
        </trans-unit>
        <trans-unit id="a943f01470875cdccf0a181e83dd06c730b15424" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.dot()</source>
          <target state="translated">LinearAlgebra.dot()</target>
        </trans-unit>
        <trans-unit id="03ea5670e94fee3cdb29e27ac132cc775f5e56ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen!()</source>
          <target state="translated">LinearAlgebra.eigen!()</target>
        </trans-unit>
        <trans-unit id="cc8ed4ca720004997b29c2c20ec5efc0988c78b6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen()</source>
          <target state="translated">LinearAlgebra.eigen()</target>
        </trans-unit>
        <trans-unit id="2006a7e56e96f08e8b101a5a98e0ce5438f051fd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmax()</source>
          <target state="translated">LinearAlgebra.eigmax()</target>
        </trans-unit>
        <trans-unit id="495e81e9aba12ed4873afb4fbfc9910161c06935" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmin()</source>
          <target state="translated">LinearAlgebra.eigmin()</target>
        </trans-unit>
        <trans-unit id="26373fb486681d828210b9eb0ada3db569ae5c9f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals!()</source>
          <target state="translated">LinearAlgebra.eigvals!()</target>
        </trans-unit>
        <trans-unit id="0ea943b4827b5ab3ec563686a13cb3fa1fff55de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals()</source>
          <target state="translated">LinearAlgebra.eigvals()</target>
        </trans-unit>
        <trans-unit id="28aa4c8f8bdda4caedf38b6c3a8bdcbdcb929bd5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvecs()</source>
          <target state="translated">LinearAlgebra.eigvecs()</target>
        </trans-unit>
        <trans-unit id="c1f95e8750fd563a65769748339ff1021d07a664" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.factorize()</source>
          <target state="translated">LinearAlgebra.factorize()</target>
        </trans-unit>
        <trans-unit id="245f91f9f7fc9cc2df2bdf9c6e80f2d0014ba521" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.givens()</source>
          <target state="translated">LinearAlgebra.givens()</target>
        </trans-unit>
        <trans-unit id="42383aca01a3095d7de60dfdd23a34e7aff90f64" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg!()</source>
          <target state="translated">LinearAlgebra.hessenberg!()</target>
        </trans-unit>
        <trans-unit id="4470ba44b04e09b558f06c669c830f27803c6604" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg()</source>
          <target state="translated">LinearAlgebra.hessenberg()</target>
        </trans-unit>
        <trans-unit id="6c9988c8648ff7a78199a102f477a45b0d53eb2c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isdiag()</source>
          <target state="translated">LinearAlgebra.isdiag()</target>
        </trans-unit>
        <trans-unit id="86f33205a580fff63ee19ac4843205922d3b8fbe" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ishermitian()</source>
          <target state="translated">LinearAlgebra.ishermitian()</target>
        </trans-unit>
        <trans-unit id="bad9e76616b147a9a6b22ef39daed46e374592df" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef!()</source>
          <target state="translated">LinearAlgebra.isposdef!()</target>
        </trans-unit>
        <trans-unit id="a3eff21980aaad7c0e8ab2571fde20cb7f9a4ac3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef()</source>
          <target state="translated">LinearAlgebra.isposdef()</target>
        </trans-unit>
        <trans-unit id="f184fbce8f26db2479a19308ee554a971eb91845" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issuccess()</source>
          <target state="translated">LinearAlgebra.issuccess()</target>
        </trans-unit>
        <trans-unit id="3b45090c87a6e9b6490c1b86caef6bc289e9811b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issymmetric()</source>
          <target state="translated">LinearAlgebra.issymmetric()</target>
        </trans-unit>
        <trans-unit id="27361a0db065863449e5514f392695a8843c50d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istril()</source>
          <target state="translated">LinearAlgebra.istril()</target>
        </trans-unit>
        <trans-unit id="154536c971d912aac5c55987e04b500058382262" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istriu()</source>
          <target state="translated">LinearAlgebra.istriu()</target>
        </trans-unit>
        <trans-unit id="8702b95d8a1b1c5f29f2af932f7b339f131fc979" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldiv!()</source>
          <target state="translated">LinearAlgebra.ldiv!()</target>
        </trans-unit>
        <trans-unit id="f628486016bf8bb2592d19dea3a4ef558655d6d8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt!()</source>
          <target state="translated">LinearAlgebra.ldlt!()</target>
        </trans-unit>
        <trans-unit id="c666984e1b5f4107efe1cc308dd23df3742d794b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt()</source>
          <target state="translated">LinearAlgebra.ldlt()</target>
        </trans-unit>
        <trans-unit id="87445caeed19ddaad799f1582737a52e40bde9e9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lmul!()</source>
          <target state="translated">LinearAlgebra.lmul!()</target>
        </trans-unit>
        <trans-unit id="f5e67426386e0244313c54bbe9e11137664a7611" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logabsdet()</source>
          <target state="translated">LinearAlgebra.logabsdet()</target>
        </trans-unit>
        <trans-unit id="a6c4efc9dcb4f29a594919d0a4a0c4ecc1b0eb49" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logdet()</source>
          <target state="translated">LinearAlgebra.logdet()</target>
        </trans-unit>
        <trans-unit id="aed69ea345782519298a7b83289a6fd2a0d20a22" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate!()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate!()</target>
        </trans-unit>
        <trans-unit id="065afe0c96edc42ef451662159895201fbe9f74e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate()</target>
        </trans-unit>
        <trans-unit id="10584a564acc8cafcbd880790d5a3223c614e997" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate!()</source>
          <target state="translated">LinearAlgebra.lowrankupdate!()</target>
        </trans-unit>
        <trans-unit id="952be3b610fe2e74216ee89053ff75f7419d4b28" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate()</source>
          <target state="translated">LinearAlgebra.lowrankupdate()</target>
        </trans-unit>
        <trans-unit id="47c1af320726090525f6d61978444c2ea6c9d0ab" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq!()</source>
          <target state="translated">LinearAlgebra.lq!()</target>
        </trans-unit>
        <trans-unit id="5375dc727ff35daa144ad173772170766a77fc84" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq()</source>
          <target state="translated">LinearAlgebra.lq()</target>
        </trans-unit>
        <trans-unit id="19c721bb8412a08453cd493f076ec151ec21919f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu!()</source>
          <target state="translated">LinearAlgebra.lu!()</target>
        </trans-unit>
        <trans-unit id="416610984f232609e5a5300d47b309939683e378" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu()</source>
          <target state="translated">LinearAlgebra.lu()</target>
        </trans-unit>
        <trans-unit id="e5fa084cafc39d82b66f8c8dc2e12353e03f3704" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lyap()</source>
          <target state="translated">LinearAlgebra.lyap()</target>
        </trans-unit>
        <trans-unit id="7c99824c12d49750627f623ddd871e015e24c8c8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.mul!()</source>
          <target state="translated">LinearAlgebra.mul!()</target>
        </trans-unit>
        <trans-unit id="24933f7d1d932d73149fe8820b01ff0b8033488b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.norm()</source>
          <target state="translated">LinearAlgebra.norm()</target>
        </trans-unit>
        <trans-unit id="1639614f72f390991f3c415b26fb661709818686" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize!()</source>
          <target state="translated">LinearAlgebra.normalize!()</target>
        </trans-unit>
        <trans-unit id="bfa13b34d43df925bb276eb2b2712a5d9852eb7e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize()</source>
          <target state="translated">LinearAlgebra.normalize()</target>
        </trans-unit>
        <trans-unit id="123d380f57ea839fe9386bdced9ecbd4bfa56d19" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.nullspace()</source>
          <target state="translated">LinearAlgebra.nullspace()</target>
        </trans-unit>
        <trans-unit id="c473c4d32b408a10287aa2043ce1410d94d0f8ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.opnorm()</source>
          <target state="translated">LinearAlgebra.opnorm()</target>
        </trans-unit>
        <trans-unit id="27873174504747d088813d705a5c2057e78a6fa4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur!()</source>
          <target state="translated">LinearAlgebra.ordschur!()</target>
        </trans-unit>
        <trans-unit id="a0cf19c8a32916092aead5343f54d5c29799bf44" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur()</source>
          <target state="translated">LinearAlgebra.ordschur()</target>
        </trans-unit>
        <trans-unit id="f7c256ca3b590fa1c68a6c5c968889de72035a1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.peakflops()</source>
          <target state="translated">LinearAlgebra.peakflops()</target>
        </trans-unit>
        <trans-unit id="3b416155a9648251a3dab2c1f86f654cbc45f766" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.pinv()</source>
          <target state="translated">LinearAlgebra.pinv()</target>
        </trans-unit>
        <trans-unit id="24a51a0a6b9a091503d04d18751653ab70e63907" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr!()</source>
          <target state="translated">LinearAlgebra.qr!()</target>
        </trans-unit>
        <trans-unit id="32cd922076c561139a5133388ff3de86aee2f838" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr()</source>
          <target state="translated">LinearAlgebra.qr()</target>
        </trans-unit>
        <trans-unit id="25c16b6062a5721edfc89f6f1b58866c9999fd30" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rank()</source>
          <target state="translated">LinearAlgebra.rank()</target>
        </trans-unit>
        <trans-unit id="292d72424657c4aa082122899b52a2ca37500f51" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rdiv!()</source>
          <target state="translated">LinearAlgebra.rdiv!()</target>
        </trans-unit>
        <trans-unit id="12f33b8246f53c039178bae0493a696a7aff5605" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rmul!()</source>
          <target state="translated">LinearAlgebra.rmul!()</target>
        </trans-unit>
        <trans-unit id="3ce18ca8ac025f0f6376582ad516bf09b60beb97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur!()</source>
          <target state="translated">LinearAlgebra.schur!()</target>
        </trans-unit>
        <trans-unit id="d1c7d7a7be766a0227fceaaeba6b125494ecacc5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur()</source>
          <target state="translated">LinearAlgebra.schur()</target>
        </trans-unit>
        <trans-unit id="875a6969d0c4c9e685666728e0a075eb8c05fd34" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.stride1()</source>
          <target state="translated">LinearAlgebra.stride1()</target>
        </trans-unit>
        <trans-unit id="e830629f4eb2b2f684c386f2e83c4cd8d40d08c7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd!()</source>
          <target state="translated">LinearAlgebra.svd!()</target>
        </trans-unit>
        <trans-unit id="9ac0ee09de07e5d20a225d6487f69df6607076ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd()</source>
          <target state="translated">LinearAlgebra.svd()</target>
        </trans-unit>
        <trans-unit id="988da18329a53e16de1bd6da5c1f8e417469db10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals!()</source>
          <target state="translated">LinearAlgebra.svdvals!()</target>
        </trans-unit>
        <trans-unit id="5f88c1d8eeb98c086bcbe1a4efbb1ecfea5359dd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals()</source>
          <target state="translated">LinearAlgebra.svdvals()</target>
        </trans-unit>
        <trans-unit id="08228eabf0d0dbc8efbc58ae8f1948646134de59" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.sylvester()</source>
          <target state="translated">LinearAlgebra.sylvester()</target>
        </trans-unit>
        <trans-unit id="b64e39526f66a386113f15a1ffcc6de69561a7ea" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tr()</source>
          <target state="translated">LinearAlgebra.tr()</target>
        </trans-unit>
        <trans-unit id="421907594b9500deaf9ebf0a78b09e30e97d0969" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.transpose!()</source>
          <target state="translated">LinearAlgebra.transpose!()</target>
        </trans-unit>
        <trans-unit id="9e11fafcc7c6da90f84fe85de7b987df1ab51a50" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril!()</source>
          <target state="translated">LinearAlgebra.tril!()</target>
        </trans-unit>
        <trans-unit id="943eef9228abf32d3acece710a792a24018ad5d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril()</source>
          <target state="translated">LinearAlgebra.tril()</target>
        </trans-unit>
        <trans-unit id="a45cd5a2a1e79b5eba2cf22f01b2ab8a64dcfeec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu!()</source>
          <target state="translated">LinearAlgebra.triu!()</target>
        </trans-unit>
        <trans-unit id="6fa6a88dc15e19a67b21c0de2d88e00b6f996707" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu()</source>
          <target state="translated">LinearAlgebra.triu()</target>
        </trans-unit>
        <trans-unit id="3c8e04f396865f7c2a68d63b51786aa52075e28e" translate="yes" xml:space="preserve">
          <source>LinearIndices</source>
          <target state="translated">LinearIndices</target>
        </trans-unit>
        <trans-unit id="97539d497456e8ae64ab21e30e72713379418284" translate="yes" xml:space="preserve">
          <source>Link Symbol</source>
          <target state="translated">Символ связи</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="6b94a7684e8c9e36ac262755ad390b4f84d2ef0f" translate="yes" xml:space="preserve">
          <source>Links to each of these download types can be found on the download page at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;. Note that not all versions of Julia are available for all platforms.</source>
          <target state="translated">Ссылки на каждый из этих типов загрузки можно найти на странице загрузки по адресу &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt; . Обратите внимание, что не все версии Julia доступны для всех платформ.</target>
        </trans-unit>
        <trans-unit id="0bd309fe8c158ca93bf01439f879abad96a2d9ae" translate="yes" xml:space="preserve">
          <source>Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="translated">Ссылки на внешние или внутренние адреса могут быть записаны с использованием следующего синтаксиса, где текст, заключенный в квадратные скобки, &lt;code&gt;[ ]&lt;/code&gt; - это имя ссылки, а текст, заключенный в круглые скобки, &lt;code&gt;( )&lt;/code&gt; , - это URL.</target>
        </trans-unit>
        <trans-unit id="800618f12f938e53d9c627356df00435b9a51301" translate="yes" xml:space="preserve">
          <source>Links to either external or internal targets can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f988d8955026b4558444945785c9b5dbc82a7b4f" translate="yes" xml:space="preserve">
          <source>Lipstick</source>
          <target state="translated">Lipstick</target>
        </trans-unit>
        <trans-unit id="97c285fe5eb710455fe67ecf43ec5d1858f0c7b3" translate="yes" xml:space="preserve">
          <source>Lisp-like macros and other metaprogramming facilities</source>
          <target state="translated">Макросы,похожие на лизу,и другие средства метапрограммирования</target>
        </trans-unit>
        <trans-unit id="17810a1438ef5dd3fd5dc6cdd00bf4fbecb5795c" translate="yes" xml:space="preserve">
          <source>List the number of revisions between &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; (committish OIDs in string form). Since &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; may be on different branches, &lt;code&gt;revcount&lt;/code&gt; performs a &quot;left-right&quot; revision list (and count), returning a tuple of &lt;code&gt;Int&lt;/code&gt;s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.</source>
          <target state="translated">Перечислите количество ревизий между &lt;code&gt;commit1&lt;/code&gt; и &lt;code&gt;commit2&lt;/code&gt; (OID фиксации в строковой форме). Поскольку &lt;code&gt;commit1&lt;/code&gt; и &lt;code&gt;commit2&lt;/code&gt; могут находиться в разных ветвях, &lt;code&gt;revcount&lt;/code&gt; выполняет &amp;laquo;левый-правый&amp;raquo; список ревизий (и счетчик), возвращая кортеж &lt;code&gt;Int&lt;/code&gt; s - количество левых и правых коммитов соответственно. Левая (или правая) фиксация относится к тому, с какой стороны симметричной разницы в дереве фиксация доступна.</target>
        </trans-unit>
        <trans-unit id="388721610609dc9098cd8f36e62807e84d1fade7" translate="yes" xml:space="preserve">
          <source>Listen on port on the address specified by &lt;code&gt;addr&lt;/code&gt;. By default this listens on &lt;code&gt;localhost&lt;/code&gt; only. To listen on all interfaces pass &lt;code&gt;IPv4(0)&lt;/code&gt; or &lt;code&gt;IPv6(0)&lt;/code&gt; as appropriate. &lt;code&gt;backlog&lt;/code&gt; determines how many connections can be pending (not having called &lt;a href=&quot;#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;) before the server will begin to reject them. The default value of &lt;code&gt;backlog&lt;/code&gt; is 511.</source>
          <target state="translated">Слушайте порт по адресу, указанному в &lt;code&gt;addr&lt;/code&gt; . По умолчанию это прослушивает только &lt;code&gt;localhost&lt;/code&gt; . Чтобы прослушивать все интерфейсы, передайте &lt;code&gt;IPv4(0)&lt;/code&gt; или &lt;code&gt;IPv6(0)&lt;/code&gt; в зависимости от ситуации. &lt;code&gt;backlog&lt;/code&gt; определяет, сколько соединений может быть отложено (без вызова &lt;a href=&quot;#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; ), прежде чем сервер начнет их отклонять. Значение по умолчанию &lt;code&gt;backlog&lt;/code&gt; составляет 511.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="8aa67be98327d7646247b7e62d87af940b94fc8a" translate="yes" xml:space="preserve">
          <source>Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.</source>
          <target state="translated">Списки могут содержать другие вложенные элементы верхнего уровня,такие как списки,блоки кода или квадрат.Пустая строка должна быть оставлена между каждым элементом списка при включении любых элементов верхнего уровня в список.</target>
        </trans-unit>
        <trans-unit id="4c9fcbea9e81be568fdc5a4af6993f666806fde2" translate="yes" xml:space="preserve">
          <source>Literal floating-point numbers are represented in the standard formats, using &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;E-notation&lt;/a&gt; when necessary:</source>
          <target state="translated">Литеральные числа с плавающей запятой представлены в стандартных форматах, при необходимости с использованием &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;электронной нотации&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3562cae13eedce4e4d416c818141141826f44ea7" translate="yes" xml:space="preserve">
          <source>Literal integers are represented in the standard manner:</source>
          <target state="translated">Буквальные целые числа представлены стандартным образом:</target>
        </trans-unit>
        <trans-unit id="2ab27329d47948b21415226c577e214e77fab191" translate="yes" xml:space="preserve">
          <source>Literal one of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Буквальный один типа &lt;code&gt;x&lt;/code&gt; или типа переменной &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a585d71445ba7f9e68c5da186d786f4437873367" translate="yes" xml:space="preserve">
          <source>Literal zero and one</source>
          <target state="translated">Буквальный ноль и один</target>
        </trans-unit>
        <trans-unit id="24e8678ee4be704fc611c4a474de77fa54f1d95f" translate="yes" xml:space="preserve">
          <source>Literal zero of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Буквальный ноль типа &lt;code&gt;x&lt;/code&gt; или типа переменной &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="c6a4e1f3b4978cbaedfb2e99a34a61a5e64f4b8d" translate="yes" xml:space="preserve">
          <source>Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.</source>
          <target state="translated">Буквы следует использовать при написании текста,который ссылается на имена переменных,функций или других частей программы Julia.</target>
        </trans-unit>
        <trans-unit id="cccfebf2b6bb84af7b7416c30102f0fb5345d20a" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; immediately on all processors</source>
          <target state="translated">Загрузить &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; немедленно на всех процессорах</target>
        </trans-unit>
        <trans-unit id="221a8e52842df5b19245cbcdd992a3dedaa109d5" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;</source>
          <target state="translated">Загрузите &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea8d49a8f75a3b101a94caadd4a63e8ab235d750" translate="yes" xml:space="preserve">
          <source>Load a shared library, returning an opaque handle.</source>
          <target state="translated">Загрузить общую библиотеку,вернуть непрозрачную ручку.</target>
        </trans-unit>
        <trans-unit id="c25f7156c983ea8a18f757a2b60fb37dd817a64d" translate="yes" xml:space="preserve">
          <source>Load a value of type &lt;code&gt;T&lt;/code&gt; from the address of the &lt;code&gt;i&lt;/code&gt;th element (1-indexed) starting at &lt;code&gt;p&lt;/code&gt;. This is equivalent to the C expression &lt;code&gt;p[i-1]&lt;/code&gt;.</source>
          <target state="translated">Загрузите значение типа &lt;code&gt;T&lt;/code&gt; с адреса &lt;code&gt;i&lt;/code&gt; - го элемента (с индексом 1), начиная &lt;code&gt;p&lt;/code&gt; . Это эквивалентно выражению C &lt;code&gt;p[i-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37f3c2f4c2bbe8c48d77f7372d4681f5071a6c1b" translate="yes" xml:space="preserve">
          <source>Load or save history</source>
          <target state="translated">Загрузить или сохранить историю</target>
        </trans-unit>
        <trans-unit id="2a3d64c128591f94e5fcdc12bbe22bc691844af1" translate="yes" xml:space="preserve">
          <source>Load the file using &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, evaluate all expressions, and return the value of the last one.</source>
          <target state="translated">Загрузите файл с помощью &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; , оцените все выражения и верните значение последнего.</target>
        </trans-unit>
        <trans-unit id="1c25d02a3443b64be0a5e8874e859825f3a072cf" translate="yes" xml:space="preserve">
          <source>Loads a source file, in the context of the &lt;code&gt;Main&lt;/code&gt; module, on every active node, searching standard locations for files. &lt;code&gt;require&lt;/code&gt; is considered a top-level operation, so it sets the current &lt;code&gt;include&lt;/code&gt; path but does not use it to search for files (see help for &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;). This function is typically used to load library code, and is implicitly called by &lt;code&gt;using&lt;/code&gt; to load packages.</source>
          <target state="translated">Загружает исходный файл в контексте &lt;code&gt;Main&lt;/code&gt; модуля на каждый активный узел, выполняя поиск файлов в стандартных местах. &lt;code&gt;require&lt;/code&gt; считается операцией верхнего уровня, поэтому он устанавливает текущий путь &lt;code&gt;include&lt;/code&gt; но не использует его для поиска файлов (см. справку по &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; ). Эта функция обычно используется для загрузки кода библиотеки и неявно вызывается при &lt;code&gt;using&lt;/code&gt; для загрузки пакетов.</target>
        </trans-unit>
        <trans-unit id="2aaca902d4d3758e11a3b458199407392409931c" translate="yes" xml:space="preserve">
          <source>Local Scope</source>
          <target state="translated">Локальный охват</target>
        </trans-unit>
        <trans-unit id="53e6be3ba94721357dc8f1cd8a4a35bc46260d53" translate="yes" xml:space="preserve">
          <source>Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.</source>
          <target state="translated">Местные константы совершенно разные.Компилятор способен автоматически определять,когда локальная переменная является константной,поэтому локальные константные объявления не нужны и на самом деле на данный момент не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="7bc74c802188a5ae5dd86ce1121ca4599d93af45" translate="yes" xml:space="preserve">
          <source>Local invocations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea223f531a712477fac84f8fcf490b4f65ae3a6" translate="yes" xml:space="preserve">
          <source>Local invocations(@id man-distributed-local-invocations)</source>
          <target state="translated">Локальные вызовы(@id man-distributed-local-invocations)</target>
        </trans-unit>
        <trans-unit id="40051a807238da75ab231f8a8a71c830f614ed27" translate="yes" xml:space="preserve">
          <source>Local variable &lt;code&gt;x&lt;/code&gt; starts as an integer, and after one loop iteration becomes a floating-point number (the result of &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:</source>
          <target state="translated">Локальная переменная &lt;code&gt;x&lt;/code&gt; начинается с целого числа и после одной итерации цикла становится числом с плавающей запятой (результат оператора &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; ). Это затрудняет компилятору оптимизацию тела цикла. Есть несколько возможных исправлений:</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="7e9d4e021d5117e7b0d661a7918f799df5c20541" translate="yes" xml:space="preserve">
          <source>Lock With Ink Pen</source>
          <target state="translated">Замок с чернильным пером</target>
        </trans-unit>
        <trans-unit id="2d7a18ee66cedde04088fccb894adfaa5d0be6f1" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; to be used as a key to identify the log statement when filtering.</source>
          <target state="translated">Записать сообщение в &lt;code&gt;logger&lt;/code&gt; на &lt;code&gt;level&lt;/code&gt; . Логическое расположение, в котором было сгенерировано сообщение, задается модулем &lt;code&gt;_module&lt;/code&gt; и &lt;code&gt;group&lt;/code&gt; ; расположение источника по &lt;code&gt;file&lt;/code&gt; и &lt;code&gt;line&lt;/code&gt; . &lt;code&gt;id&lt;/code&gt; - произвольный уникальный &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; который будет использоваться в качестве ключа для идентификации оператора журнала при фильтрации.</target>
        </trans-unit>
        <trans-unit id="2db3a05837e9b250facfd93e1fe4f8c7f938c9cc" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique value (typically a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;) to be used as a key to identify the log statement when filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ccff841d7f5fb35e7f3223eae831d879121ed8" translate="yes" xml:space="preserve">
          <source>Log event structure</source>
          <target state="translated">Журнал событийная структура</target>
        </trans-unit>
        <trans-unit id="5de4f5e761f85511e1c9dded76464677e6b5b91b" translate="yes" xml:space="preserve">
          <source>Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The &lt;code&gt;Test&lt;/code&gt; module provides a &lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt;&lt;code&gt;@test_logs&lt;/code&gt;&lt;/a&gt; macro that can be used to pattern match against the log event stream.</source>
          <target state="translated">События журнала - это побочный эффект выполнения обычного кода, но вы можете захотеть проверить определенные информационные сообщения и предупреждения. Модуль &lt;code&gt;Test&lt;/code&gt; предоставляет макрос &lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt; &lt;code&gt;@test_logs&lt;/code&gt; ,&lt;/a&gt; который можно использовать для сопоставления шаблонов с потоком событий журнала.</target>
        </trans-unit>
        <trans-unit id="39e0c0b6171a5e937cc4b913037f6617883ef778" translate="yes" xml:space="preserve">
          <source>Log levels less than &lt;code&gt;min_level&lt;/code&gt; are filtered out.</source>
          <target state="translated">Уровни журнала ниже &lt;code&gt;min_level&lt;/code&gt; отфильтровываются.</target>
        </trans-unit>
        <trans-unit id="b95a88cbf9b7104d12a1c6e6be0a2df585c9c414" translate="yes" xml:space="preserve">
          <source>Log of absolute value of matrix determinant. Equivalent to &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">Журнал абсолютного значения определителя матрицы. Эквивалентен &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt; , но может обеспечить повышенную точность и / или скорость.</target>
        </trans-unit>
        <trans-unit id="25e0bc59a9512a0f503efed371b6e58c737cb2b5" translate="yes" xml:space="preserve">
          <source>Log of matrix determinant. Equivalent to &lt;code&gt;log(det(M))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">Лог определителя матрицы. Эквивалентно &lt;code&gt;log(det(M))&lt;/code&gt; , но может обеспечить повышенную точность и / или скорость.</target>
        </trans-unit>
        <trans-unit id="09b41ebbca90f28e72616fb548aed5c2cdb190af" translate="yes" xml:space="preserve">
          <source>Logger installation and inspection:</source>
          <target state="translated">Установка и проверка логгеров:</target>
        </trans-unit>
        <trans-unit id="3e0a58fce8ac790c3d3776b2f9cb69da4b8e968b" translate="yes" xml:space="preserve">
          <source>Logger which disables all messages and produces no output - the logger equivalent of /dev/null.</source>
          <target state="translated">Журнализатор,который отключает все сообщения и не производит вывод-эквивалент логгера /dev/null.</target>
        </trans-unit>
        <trans-unit id="c489f7460af4426236655b519a2e843c0796afcf" translate="yes" xml:space="preserve">
          <source>Logger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.</source>
          <target state="translated">Логгер с оптимизированным для читаемости форматированием в текстовой консоли,например,интерактивная работа с Julia REPL.</target>
        </trans-unit>
        <trans-unit id="012294fbc07fc652fdbbd3b8b48183b6e7925dda" translate="yes" xml:space="preserve">
          <source>Loggers</source>
          <target state="translated">Loggers</target>
        </trans-unit>
        <trans-unit id="ab6dfdab464b019150c40525f7d8fef7f42317d8" translate="yes" xml:space="preserve">
          <source>Loggers that are supplied with the system:</source>
          <target state="translated">Логгеры,которые поставляются вместе с системой:</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="84dd6708d003df0c49c9ba90e02bb2e238e90fae" translate="yes" xml:space="preserve">
          <source>Logging module</source>
          <target state="translated">Модуль регистрации</target>
        </trans-unit>
        <trans-unit id="89da04acc02b6d97d3dda5b51691b7f2df8ab3f2" translate="yes" xml:space="preserve">
          <source>Logical (or boolean) operators &lt;code&gt;|&lt;/code&gt;, &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; are another special case, as they only propagate &lt;code&gt;missing&lt;/code&gt; values when it is logically required. For these operators, whether or not the result is uncertain depends on the particular operation, following the well-established rules of &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;three-valued logic&lt;/em&gt;&lt;/a&gt; which are also implemented by &lt;code&gt;NULL&lt;/code&gt; in SQL and &lt;code&gt;NA&lt;/code&gt; in R. This abstract definition actually corresponds to a relatively natural behavior which is best explained via concrete examples.</source>
          <target state="translated">Логические (или булевы) операторы &lt;code&gt;|&lt;/code&gt; , &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; - еще один особый случай, поскольку они распространяют &lt;code&gt;missing&lt;/code&gt; значения только тогда, когда это логически необходимо. Для этих операторов, является ли результат неопределенным, зависит от конкретной операции, следуя хорошо установленным правилам &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;трехзначной логики,&lt;/em&gt;&lt;/a&gt; которые также реализуются с помощью &lt;code&gt;NULL&lt;/code&gt; в SQL и &lt;code&gt;NA&lt;/code&gt; в R. Это абстрактное определение фактически соответствует относительно естественному поведение, которое лучше всего объяснить на конкретных примерах.</target>
        </trans-unit>
        <trans-unit id="786908e4097f50192db248aa36b5528e31277867" translate="yes" xml:space="preserve">
          <source>Logical And</source>
          <target state="translated">Логический И</target>
        </trans-unit>
        <trans-unit id="67c3357e4a7007cce9dad8abe1e464a6faaed6cf" translate="yes" xml:space="preserve">
          <source>Logical And With Dot Above</source>
          <target state="translated">Логический и с точкой выше</target>
        </trans-unit>
        <trans-unit id="ad73258bccc391936166d8f628d173e6ce3c7d3d" translate="yes" xml:space="preserve">
          <source>Logical And With Double Overbar</source>
          <target state="translated">Логический и с двойной перебор</target>
        </trans-unit>
        <trans-unit id="3a27d20134d696f264e94d803f411cd413383e05" translate="yes" xml:space="preserve">
          <source>Logical And With Double Underbar</source>
          <target state="translated">Логический и с двойным подбарабанье</target>
        </trans-unit>
        <trans-unit id="cb54d54f9d2ab29ccd05e2998f6679b7b0a51e55" translate="yes" xml:space="preserve">
          <source>Logical And With Horizontal Dash</source>
          <target state="translated">Логический и с горизонтальным тире.</target>
        </trans-unit>
        <trans-unit id="f6e1b3f2c2e3537f4121f6786ee7d2f1fdcc7214" translate="yes" xml:space="preserve">
          <source>Logical And With Middle Stem</source>
          <target state="translated">Логический и со средним стеблем</target>
        </trans-unit>
        <trans-unit id="cee1bd132c4db9d40b5015470294a3309557d652" translate="yes" xml:space="preserve">
          <source>Logical And With Underbar</source>
          <target state="translated">Логический и с подбалкой</target>
        </trans-unit>
        <trans-unit id="fed4dc8cd8f466453469c24bdf945b136419ffef" translate="yes" xml:space="preserve">
          <source>Logical Operations on Arrays</source>
          <target state="translated">Логические операции с массивами</target>
        </trans-unit>
        <trans-unit id="6b4765205b7632c3acd6f4b0016fe8b785f2d3e7" translate="yes" xml:space="preserve">
          <source>Logical Or</source>
          <target state="translated">Логический или</target>
        </trans-unit>
        <trans-unit id="090611a42c7037c3c2bfae57153874d16efc59fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Dot Above</source>
          <target state="translated">Логический или с точкой выше</target>
        </trans-unit>
        <trans-unit id="563b798880b958c47070de3da511383e45a77828" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Overbar</source>
          <target state="translated">Логический или с двойной перебор</target>
        </trans-unit>
        <trans-unit id="7d683350404e6e9be8c9e2e65c1b673dedd263fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Underbar</source>
          <target state="translated">Логический или с двойным подбарабанье</target>
        </trans-unit>
        <trans-unit id="66977fa56bf367cf9edb7c775c7703db1cb43216" translate="yes" xml:space="preserve">
          <source>Logical Or With Horizontal Dash</source>
          <target state="translated">Логический или с горизонтальным тире</target>
        </trans-unit>
        <trans-unit id="04ee9b0a538e88f1af58f8f182ea27dfc50a851f" translate="yes" xml:space="preserve">
          <source>Logical Or With Middle Stem</source>
          <target state="translated">Логический или со средним стволом</target>
        </trans-unit>
        <trans-unit id="daaabe581776a9024a83133896be28214c21d330" translate="yes" xml:space="preserve">
          <source>Logical indexing</source>
          <target state="translated">Логическая индексация</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">Логические операторы</target>
        </trans-unit>
        <trans-unit id="621d5dc0716b80a4b24a2ab36703beb47f8e9970" translate="yes" xml:space="preserve">
          <source>Lollipop</source>
          <target state="translated">Lollipop</target>
        </trans-unit>
        <trans-unit id="3dd8963fe38f95d47b45ad8afdc61266eb3c705b" translate="yes" xml:space="preserve">
          <source>Long Left Right Arrow</source>
          <target state="translated">Длинная левая правая стрелка</target>
        </trans-unit>
        <trans-unit id="c35393bc1526e081d6c45ef1fbb48cf17d0c8bf0" translate="yes" xml:space="preserve">
          <source>Long Left Right Double Arrow</source>
          <target state="translated">Длинная левая правая двойная стрелка</target>
        </trans-unit>
        <trans-unit id="e284c1dcf57b9e16654ce906eebd4ade05f805b3" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow</source>
          <target state="translated">Длинная левая стрелка</target>
        </trans-unit>
        <trans-unit id="0b53faa1153d8df2a62532b492821e710a37aaad" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow From Bar</source>
          <target state="translated">Стрелка влево от бара</target>
        </trans-unit>
        <trans-unit id="88125db03adc91c18e4b911d1e8543cb06fb2b1b" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow</source>
          <target state="translated">Длинная левая стрелка Двойная стрелка</target>
        </trans-unit>
        <trans-unit id="f84697639bf777eba1549b50e7d78fe9fc6c3b1a" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow From Bar</source>
          <target state="translated">Двойная левая длинная стрелка от бара</target>
        </trans-unit>
        <trans-unit id="b98fbfea9069a23125b4969bdb4539cfde1d985c" translate="yes" xml:space="preserve">
          <source>Long Leftwards Squiggle Arrow</source>
          <target state="translated">Длинная левая Стрелка-болтунья</target>
        </trans-unit>
        <trans-unit id="ea5233fe4b9cd95205a27a4dce0a7bbfb8aae26f" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow</source>
          <target state="translated">длинная стрелка вправо</target>
        </trans-unit>
        <trans-unit id="529625a98773524bc52c828a69957fbaaca9fd91" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow From Bar</source>
          <target state="translated">Стрелка вправо от бара</target>
        </trans-unit>
        <trans-unit id="0e2515e3d0dae9c81aaf0c44bf451d94396badbf" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow</source>
          <target state="translated">Двойная стрелка вправо и влево</target>
        </trans-unit>
        <trans-unit id="1278f556f7a008b8d9f849c9d7f07ad7d2fda02a" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow From Bar</source>
          <target state="translated">Двойная стрелка вправо и влево от барной стойки</target>
        </trans-unit>
        <trans-unit id="3c3264b81769074f17253d6ac449ae0214eb0511" translate="yes" xml:space="preserve">
          <source>Long Rightwards Squiggle Arrow</source>
          <target state="translated">Стрелка-ударник с длинным правым поворотом</target>
        </trans-unit>
        <trans-unit id="f9731487237a7d36eb57c97e02893eb0fcbe12b9" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using its name and URL. Uses the default fetch refspec.</source>
          <target state="translated">Ищите удалённый git-репозиторий,используя его имя и URL.Использует стандартный fetch refspec.</target>
        </trans-unit>
        <trans-unit id="f3e71ff4dab9481f1e14a82514827c17c83dee43" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using only its URL, not its name.</source>
          <target state="translated">Ищите удалённый git-репозиторий,используя только его URL,а не имя.</target>
        </trans-unit>
        <trans-unit id="6d614bcd7bb6dd66d43226d39894a37944a369ee" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using the repository's name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).</source>
          <target state="translated">Ищите удалённый git-репозиторий,используя имя и URL репозитория,а также спецификации для получения с удалённого (например,с какой удалённой ветки получать).</target>
        </trans-unit>
        <trans-unit id="297e4906774f5b0f9f9ea2352dd36b66f2c9d575" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, return callable function pointer on success.</source>
          <target state="translated">Ищите символ из разделяемого дескриптора библиотеки,при успешном вызове возвращаете указатель на вызываемую функцию.</target>
        </trans-unit>
        <trans-unit id="b2554c797a77ef5cd564f4094822fce342e2ced7" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, silently return &lt;code&gt;C_NULL&lt;/code&gt; on lookup failure. This method is now deprecated in favor of &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt;.</source>
          <target state="translated">Найдите символ в дескрипторе разделяемой библиотеки, без &lt;code&gt;C_NULL&lt;/code&gt; верните C_NULL при ошибке поиска. Этот метод теперь устарел и &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c18a26a0372be6990fb3f7d9280fb8a4395903a4" translate="yes" xml:space="preserve">
          <source>Look up the value of a key in the current task's task-local storage.</source>
          <target state="translated">Ищите значение ключа в локальном хранилище задач текущей задачи.</target>
        </trans-unit>
        <trans-unit id="1a5964da6a0276ac045eacedf1ca054ba281575e" translate="yes" xml:space="preserve">
          <source>Lookup the name of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;repo&lt;/code&gt; is currently detached, return the name of the HEAD it's detached from.</source>
          <target state="translated">Поиск имени текущей главы мерзавец хранилище &lt;code&gt;repo&lt;/code&gt; . Если &lt;code&gt;repo&lt;/code&gt; в настоящее время отсоединено, вернуть имя ГОЛОВКИ, от которой оно отсоединено.</target>
        </trans-unit>
        <trans-unit id="c7d22d27b21054a2d862fb3e778055ec62497845" translate="yes" xml:space="preserve">
          <source>Lookup the object id of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">Поиск объекта идентификатор текущей главы мерзавца хранилища &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2897343d4dfca50b3dbd880e6b406397dfc276be" translate="yes" xml:space="preserve">
          <source>Lookup the status of the file at &lt;code&gt;path&lt;/code&gt; in the git repository &lt;code&gt;repo&lt;/code&gt;. For instance, this can be used to check if the file at &lt;code&gt;path&lt;/code&gt; has been modified and needs to be staged and committed.</source>
          <target state="translated">Поиск статус файла на &lt;code&gt;path&lt;/code&gt; в мерзавца хранилище &lt;code&gt;repo&lt;/code&gt; . Например, это можно использовать, чтобы проверить, был ли файл по &lt;code&gt;path&lt;/code&gt; изменен и должен ли быть поставлен и зафиксирован.</target>
        </trans-unit>
        <trans-unit id="e83f1c0d81e570990421db9c6c5103dd52bab5e9" translate="yes" xml:space="preserve">
          <source>Loops and Comprehensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292714b14a57c3b911bea2bc02c843a11e53cd72" translate="yes" xml:space="preserve">
          <source>Loudly Crying Face</source>
          <target state="translated">Громко плачущее лицо</target>
        </trans-unit>
        <trans-unit id="68479172d96d6399ed79d6c3cc2275a9e4cb417d" translate="yes" xml:space="preserve">
          <source>Love Hotel</source>
          <target state="translated">Отель любви</target>
        </trans-unit>
        <trans-unit id="e8ed5bf829210dcfddc85b2455095cf9764bc443" translate="yes" xml:space="preserve">
          <source>Love Letter</source>
          <target state="translated">Любовное письмо</target>
        </trans-unit>
        <trans-unit id="1e20259076165d87571f777f8f501c9eec6cf077" translate="yes" xml:space="preserve">
          <source>Low Brightness Symbol</source>
          <target state="translated">Низкая яркость Символ</target>
        </trans-unit>
        <trans-unit id="3c768d286c3fa1a1be3b0b32968dce7e2bf6df5f" translate="yes" xml:space="preserve">
          <source>Low-level (C kernel) based operations &lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl&lt;/a&gt; which are respectively an OpenCL interface and a CUDA wrapper.</source>
          <target state="translated">Низкоуровневые (ядро C) операции &lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt; и &lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl,&lt;/a&gt; которые являются соответственно интерфейсом OpenCL и оболочкой CUDA.</target>
        </trans-unit>
        <trans-unit id="0d470f206b953bd94a63cddee039b55b43eb02d8" translate="yes" xml:space="preserve">
          <source>Low-level (Julia Kernel) interfaces like &lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jl&lt;/a&gt; which is a Julia native CUDA implementation.</source>
          <target state="translated">Низкоуровневые (Julia Kernel) интерфейсы, такие как &lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jl,&lt;/a&gt; который является собственной реализацией CUDA для Julia.</target>
        </trans-unit>
        <trans-unit id="8a939192d22d6941f17735b112fcce8351ea8eba" translate="yes" xml:space="preserve">
          <source>Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.</source>
          <target state="translated">Низкоуровневый макрос,используемый для маркировки выражений,возвращаемых макросом,который должен быть задокументирован.Если помечено более одного выражения,то к каждому из них применяется одна и та же строка.</target>
        </trans-unit>
        <trans-unit id="93d0030ec86c684d10a9c49e09b2634f0ca13492" translate="yes" xml:space="preserve">
          <source>Low-level matrix operations</source>
          <target state="translated">Низкоуровневые матричные операции</target>
        </trans-unit>
        <trans-unit id="c33ae1bfbf8999a2bc79cecceab734ada1f32053" translate="yes" xml:space="preserve">
          <source>Low-level synchronization primitives</source>
          <target state="translated">Низкоуровневые примитивы синхронизации</target>
        </trans-unit>
        <trans-unit id="69c6e547fabb23ad635ac8fe93ede5712392e080" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt;</source>
          <target state="translated">Нижняя &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;треугольная матрица&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23a4f4335d144fa2497d4fe37f2b528b18f4e240" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt; with unit diagonal</source>
          <target state="translated">Опустить &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;треугольную матрицу&lt;/a&gt; с единичной диагональю</target>
        </trans-unit>
        <trans-unit id="e67838aee8be4e7755da1c297ec68ae6e282902c" translate="yes" xml:space="preserve">
          <source>Lower Half Block</source>
          <target state="translated">Нижний блок</target>
        </trans-unit>
        <trans-unit id="b7bfddef31a484ac690f541d1587c0a82f9ea2c7" translate="yes" xml:space="preserve">
          <source>Lower Half Circle</source>
          <target state="translated">Нижний полукруг</target>
        </trans-unit>
        <trans-unit id="0a46dc7d5d38dbb0f9593bbac09bb5a5e1168df1" translate="yes" xml:space="preserve">
          <source>Lower Half Inverse White Circle</source>
          <target state="translated">Нижний полуобратный белый круг</target>
        </trans-unit>
        <trans-unit id="19c077435147598603f42bc8543d280b80283f3c" translate="yes" xml:space="preserve">
          <source>Lower Left Quadrant Circular Arc</source>
          <target state="translated">Нижний левый квадрант Круговая дуга</target>
        </trans-unit>
        <trans-unit id="a3a82cb0d0923582f86a3cfde8b8e51e4ca1a96a" translate="yes" xml:space="preserve">
          <source>Lower Left Triangle</source>
          <target state="translated">Нижний левый треугольник</target>
        </trans-unit>
        <trans-unit id="01b22a0cc9e2a392fdb90f606abf5d1b88f864a7" translate="yes" xml:space="preserve">
          <source>Lower Right Quadrant Circular Arc</source>
          <target state="translated">Круговая дуга нижнего правого квадранта</target>
        </trans-unit>
        <trans-unit id="70aee1ac83a2f1a5579bf9159c07bceb364ffd0e" translate="yes" xml:space="preserve">
          <source>Lower Right Triangle</source>
          <target state="translated">Нижний правый треугольник</target>
        </trans-unit>
        <trans-unit id="fe9cd1617eaf77e57754425b931c1afef95157bf" translate="yes" xml:space="preserve">
          <source>Lower bound for log level of accepted events</source>
          <target state="translated">Нижняя граница для уровня журнала принятых событий</target>
        </trans-unit>
        <trans-unit id="44e79a7195ba19b673d8eec03c4e37479443f063" translate="yes" xml:space="preserve">
          <source>Lower triangle of a matrix, overwriting &lt;code&gt;M&lt;/code&gt; in the process. See also &lt;a href=&quot;#LinearAlgebra.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Нижний треугольник матрицы, перезапись &lt;code&gt;M&lt;/code&gt; в процессе. Также &lt;a href=&quot;#LinearAlgebra.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b635a689678f453635c9ee1b78fc69558f89e909" translate="yes" xml:space="preserve">
          <source>Lower triangle of a matrix.</source>
          <target state="translated">Нижний треугольник матрицы.</target>
        </trans-unit>
        <trans-unit id="3b856a21fe98568ae306d713f4ed924f2bea5deb" translate="yes" xml:space="preserve">
          <source>Lozenge</source>
          <target state="translated">Lozenge</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
