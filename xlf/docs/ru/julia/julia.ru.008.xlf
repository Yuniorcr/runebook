<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="dab8916b317afa94c1e7d2eb18cfc9628289063b" translate="yes" xml:space="preserve">
          <source>Good performance, approaching that of statically-compiled languages like C</source>
          <target state="translated">Хорошая производительность,приближенная к производительности статически скомпилированных языков,таких как C</target>
        </trans-unit>
        <trans-unit id="85116c6b5a5273ba053319524800267c175695d4" translate="yes" xml:space="preserve">
          <source>Graduation Cap</source>
          <target state="translated">Скидка на выпускной балл</target>
        </trans-unit>
        <trans-unit id="0de47448267ba383673ef343ee1313af6fa63b74" translate="yes" xml:space="preserve">
          <source>Grapes</source>
          <target state="translated">Grapes</target>
        </trans-unit>
        <trans-unit id="2ef67b67ccfcf902b5da0d871f7bce811117ba2c" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Double-Line Equal Above Less-Than</source>
          <target state="translated">Больше,чем выше двойная линия,равная выше меньше,чем та.</target>
        </trans-unit>
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">Больше,чем выше,чем выше,чем выше,чем двойная линия равна.</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">Больше,чем выше,чем выше,чем меньше.</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">Больше-Тана выше похожих или равных</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">Больше,чем наклоненные равны,меньше,чем наклоненные равны.</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">Больше тана и не приблизительный</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">Больше тана и одной линии,не равной</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">Большой-Тан рядом с Меньше-Тана</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">Больше,но не равнозначно/больше,чем но не равнозначно</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">Больше,но не равны/больше,чем равны,но не равны+селектор вариантов-1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">Больше,но не эквивалентно/больше,чем,но не эквивалентно</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">Большой-Тан Закрыто Кривой</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">Большой-Тан закрыт кривой выше наклонной равномерно</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">Больше,чем равны или меньше,чем равны или меньше.</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">Больше тана или около того</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">Больше,чем/больше,чем или равны</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">Больше,чем/больше,чем или эквивалентно</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">Больше,или меньше,или больше,или меньше...</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">Больше тана или наклонен равномерно</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Большой тангенс или наклон равный+комбинация длинного наложения сольдуса/нешаблонного наложения длинного наклада косой черты</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">Больше тана или наклонен равный с точкой выше</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">Больше тана или наклонен равны с точкой выше левой стороны</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">Больше тана или наклонных равны с точкой внутри</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">Больше,чем равное или больше,чем равное...</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">Перекрытие Большого тана Меньше тана</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">Большой-Тан с кругом внутри</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">Больше,чем с точкой/больше,чем с точкой</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">Больше-Тан с вопросительным знаком выше</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">Оператор сравнения &quot;больше чем&quot;. Возвращается к &lt;code&gt;y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">Оператор сравнения &quot;больше или равно&quot;. Возвращается к &lt;code&gt;y &amp;lt;= x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">Наибольший общий (положительный) делитель (или ноль, если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; равны нулю).</target>
        </trans-unit>
        <trans-unit id="b3c118d12ee713605454a73fa83e73fd62da99f2" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero). The arguments may be integer and rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">Греческий бета-символ/греческая маленькая буква свернутая бета-бета</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">греческая заглавная буква Альфа</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">Греческая заглавная буква Бета</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">греческая заглавная буква Чи</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">Греческая заглавная буква Дельта</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">греческая заглавная буква Эпсилон</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">греческая заглавная буква Эта</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">Гамма греческой заглавной буквы</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">Греческая заглавная буква Иота</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">греческая заглавная буква Каппа</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">Греческая заглавная буква Ламда/греческая заглавная буква Ламда</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">греческая заглавная буква Му</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">греческая заглавная буква Ну</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">греческая заглавная буква Омега</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">греческая заглавная буква Omicron</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">греческая заглавная буква Фи</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">греческая заглавная буква Пи</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">греческая заглавная буква Сі</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">Греческая заглавная буква Ро</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">греческая заглавная буква Сигма</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">Греческая заглавная буква Тау</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">греческая заглавная буква Тета</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">Упсилон греческой заглавной буквы</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">греческая заглавная буква Си</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">греческая заглавная буква Зета</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">греческая столица Тета Символ</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">Греческий Каппа Символ/греческий Маленькая буква Сценарий Каппа</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">греческая буква Архаич Коппа</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">Греческая буква Дигамма/греческая заглавная буква Дигамма</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">Греческая буква Коппа/греческая заглавная буква Коппа</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">Греческая буква Сампи/греческая заглавная буква Сампи</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">Стигма греческой буквы/Стигма греческой заглавной буквы</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">греческий лунный эпсилонский символ</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">Греческий фи Символ/греческий Маленькая буква Сценарий фи</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">Греческий Символ Пи/греческая Маленькая буква Омега Пи</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">Греческий реверсивный лунный эпсилонский символ</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">Греческий Rho символ/греческий Маленькая буква хвостового Rho</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">греческая буква Альфа</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">Греческая мелкая буква Архаичная Коппа</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">греческая мелкая буква Бета</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">греческая мелкая буква Ци</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">Дельта греческой буквы</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">греческая мелкая буква Дигамма</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">греческая буква Эпсилон</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">греческая маленькая буква Эта</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">Маленькая греческая буква финальная сигма</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">Гамма из греческой мелкой буквы</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">греческая маленькая буква Iota</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">греческая мелкая буква Каппа</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">греческая мелкая буква Коппа</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">Греческая Маленькая буква Ламда/греческая Маленькая буква Ламда</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">греческая буква Му</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">греческая мелкая буква Ну</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">греческая маленькая буква Омега</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">греческая маленькая буква Omicron</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">греческая мелкая буква Фи</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">греческая маленькая буква Пи</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">греческая маленькая буква Сі</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">греческая мелкая буква Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">греческая мелкая буква Сампи</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">греческая маленькая буква Сигма</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">Стигма греческой мелкой буквы</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">греческая маленькая буква Тау</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">греческая мелкая буква Тета</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">греческая Маленькая буква Упсилон</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">греческая маленькая буква Си</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">греческая мелкая буква Зета</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">Греческий Подписчик Маленькая буква Бета</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">Греческий Подписчик Маленькая буква Чи</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">Греческий Подписчик Маленькая буквенная гамма</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">Греческий Подписчик Маленькая буква Фи</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">Греческий Подписчик Маленькая буква Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">Греческий Символ Тэта/греческий Маленькая буква Сценарий Тэта</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">Зелёное яблоко</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">Зеленая книга</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">Зелёное сердце</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">Ужасное лицо</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">Улыбающаяся кошачья морда с улыбающимися глазами</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">Улыбающееся лицо</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">Улыбающееся лицо с улыбающимися глазами</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">Растущее сердце</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">Если бы мы попытались сделать дополнение без атомного тега,мы могли бы получить неправильный ответ из-за состояния гонки.Пример того,что случилось бы,если бы мы не избежали гонки:</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">Волосы пространство</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">Также поддерживаются числа с плавающей запятой половинной точности ( &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; ), но они реализованы программно и используют &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; для вычислений.</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">хомячье лицо</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">Обращаться с журналом событий</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">Обращаться с избыточным разнообразием аргументов в вызывающем абоненте</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">Вариация операционной системы</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">Счастливый человек поднимает одну руку</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">Вылупившаяся цыпочка</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">Слышная обезьяна</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">Украшение сердца</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">Сердце со стрелой</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">Сердце с лентой</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">Тяжелое черное сердце</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">Тяжелый контрольный знак</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">Знак тяжелого дивизиона</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">Тяжелый знак доллара</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">Символ сильного восклицательного знака</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">Тяжелый большой круг</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">Тяжелый знак минуса</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">Тяжелое умножение X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">Тяжелый знак плюс</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">Тяжелая звездочка с каплей слеза</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">Режим справки</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">Выход из режима справки осуществляется нажатием на пробел в начале строки.</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">Здесь &quot;inline&quot; относится к элементам,которые можно найти внутри блоков текста,т.е.параграфов.К ним относятся следующие элементы.</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">Здесь снова был нажат Enter, чтобы Джулия прочитала новую строку. Теперь, как вы можете видеть из этого примера, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; принимает данные для записи в качестве второго аргумента, а &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; принимает тип данных для чтения в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">Приведем несколько примеров,чтобы показать,какие типы массивов имеют ссадины,а какие-нет:</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">Вот несколько примеров с битовыми операторами:</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">Приведем несколько простых примеров использования арифметических операторов:</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">Вот несколько простых примеров:</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">Вот несколько советов для эффективной работы с Джулией.</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">Здесь каждая итерация применяет &lt;code&gt;f&lt;/code&gt; к случайно выбранной выборке из вектора &lt;code&gt;a&lt;/code&gt; , общего для всех процессов.</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">Вот соответствующая корневая структура,представленная в виде словаря:</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">Вот более сложный пример,все еще использующий Markdown:</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">Вот связанный с этим случай, в котором ожидаемое поведение не обязательно очевидно: что происходит, когда мы округляемся до ближайшего &lt;code&gt;P(2)&lt;/code&gt; , где &lt;code&gt;P&lt;/code&gt; - это тип &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; ? В некоторых случаях (в частности, когда &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ) ответ очевиден :</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">Вот представление карты возможных путей для нашего примера среды проекта &lt;code&gt;App&lt;/code&gt; , как указано в манифесте, приведенном выше для графа зависимостей, после поиска в локальной файловой системе:</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">Приведем второй пример,обертывающий соответствующий деструктор:</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">Вот простой пример оболочки C, которая возвращает тип &lt;code&gt;Ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Вот упрощенное определение макроса &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; Джулии&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ac903f23df192b2cec33704052829cedd04df512" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname. In this example, the networking library code is assumed to be in a shared library named &quot;libc&quot;. In practice, this function is usually part of the C standard library, and so the &quot;libc&quot; portion should be omitted, but we wish to show here the usage of this syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">Вот немного более сложный пример,который обнаруживает имя хоста локальной машины:</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">Вот третий пример,проходящий мимо массивов Джулии:</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">Вот еще более сложный многоступенчатый пример &quot;производитель-потребитель&quot;:</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">Вот пример &quot;составной функции&quot;,которая действительно должна быть написана как несколько определений:</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">Вот пример со всеми тремя видами разметки.Сначала программа вычисляет конечную разность одномерного массива,а затем вычисляет L2-форму результата:</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">Вот пример с &lt;code&gt;@inbounds&lt;/code&gt; и &lt;code&gt;@simd&lt;/code&gt; (здесь мы используем &lt;code&gt;@noinline&lt;/code&gt; , чтобы оптимизатор не попытался быть слишком умным и победить наш тест):</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">Вот необычайно простой макрос:</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">Вот правильный шаблон кода для возврата типа элемента &lt;code&gt;T&lt;/code&gt; любого произвольного подтипа &lt;code&gt;AbstractArray&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">Вот соответствующая структура графа,представленная в виде словаря:</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">Здесь модуль &lt;code&gt;Parent&lt;/code&gt; содержит подмодуль &lt;code&gt;Utils&lt;/code&gt; , а код в &lt;code&gt;Parent&lt;/code&gt; хочет, чтобы содержимое &lt;code&gt;Utils&lt;/code&gt; было видимым. Это делается путем начала &lt;code&gt;using&lt;/code&gt; пути с точки. Добавление дополнительных ведущих периодов перемещает дополнительные уровни в иерархии модулей. Например , &lt;code&gt;using ..Utils&lt;/code&gt; будет искать &lt;code&gt;Utils&lt;/code&gt; в &lt;code&gt;Parent&lt;/code&gt; &amp;laquo;S ограждающих модуль , а не &lt;code&gt;Parent&lt;/code&gt; сам.</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">Здесь &lt;code&gt;1:5&lt;/code&gt; - объект диапазона, представляющий последовательность чисел 1, 2, 3, 4, 5. Цикл &lt;code&gt;for&lt;/code&gt; выполняет итерацию по этим значениям, присваивая каждое из них по очереди переменной &lt;code&gt;i&lt;/code&gt; . Один довольно важное различие между предыдущей в &lt;code&gt;while&lt;/code&gt; формой контура и &lt;code&gt;for&lt;/code&gt; контура формой является областью , в течение которого переменная видна. Если переменная &lt;code&gt;i&lt;/code&gt; не была введена в другую область видимости, в форме цикла &lt;code&gt;for&lt;/code&gt; , она видна только внутри цикла &lt;code&gt;for&lt;/code&gt; , а не вне / после. Для проверки вам понадобится либо новый экземпляр интерактивного сеанса, либо другое имя переменной:</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">Здесь вызов &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; может быть обработан методом &lt;code&gt;g(Float64, Any)&lt;/code&gt; или &lt;code&gt;g(Any, Float64)&lt;/code&gt; , и ни один из них не является более конкретным, чем другой. В таких случаях Джулия вызывает &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; вместо того, чтобы произвольно выбирать метод. Вы можете избежать неоднозначности метода, указав соответствующий метод для случая пересечения:</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">Здесь первая цифра печатается с задержкой в две секунды,затем быстро печатаются следующие цифры.</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Здесь пользовательское выражение &lt;code&gt;ex&lt;/code&gt; - это вызов &lt;code&gt;time&lt;/code&gt; , но не та же функция &lt;code&gt;time&lt;/code&gt; которую использует макрос. Это явно относится к &lt;code&gt;MyModule.time&lt;/code&gt; . Поэтому мы должны организовать разрешение кода в &lt;code&gt;ex&lt;/code&gt; в среде вызова макроса. Это делается &quot;экранированием&quot; выражения с помощью &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">Здесь метод конструктора с нулевым аргументом вызывает метод конструктора с одним аргументом, который, в свою очередь, вызывает автоматически предоставленный метод конструктора с двумя аргументами. По причинам, которые станут понятны очень скоро, дополнительные методы конструктора, объявленные как обычные методы, подобные этому, называются методами &lt;em&gt;внешнего&lt;/em&gt; конструктора. Методы внешнего конструктора могут создавать новый экземпляр только путем вызова другого метода конструктора, такого как автоматически предоставленные методы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">Здесь мы создаем и сохраняем два замыкания, возвращающих переменную &lt;code&gt;i&lt;/code&gt; . Однако это всегда одна &lt;code&gt;i&lt;/code&gt; та же переменная i , поэтому два замыкания ведут себя одинаково. Мы можем использовать &lt;code&gt;let&lt;/code&gt; для создания новой привязки для &lt;code&gt;i&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">Здесь мы создали функцию &lt;code&gt;change_array!&lt;/code&gt; , который присваивает &lt;code&gt;5&lt;/code&gt; первому элементу переданного массива (привязанному к &lt;code&gt;x&lt;/code&gt; в месте вызова и привязанному к &lt;code&gt;A&lt;/code&gt; внутри функции). Обратите внимание, что после вызова функции &lt;code&gt;x&lt;/code&gt; по-прежнему привязан к тому же массиву, но содержимое этого массива изменилось: переменные &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; были разными привязками, относящимися к одному и тому же изменяемому объекту &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36a8f92884e992830034696fb443df46cbb7f016" translate="yes" xml:space="preserve">
          <source>Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a &lt;code&gt;SamplerTrivial&lt;/code&gt; sampler, which is in fact the &lt;em&gt;default fallback for values&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">Здесь мы создали тип &lt;code&gt;BitVector&lt;/code&gt; , который не имеет параметров, но в котором тип элемента все еще полностью задан, а &lt;code&gt;T&lt;/code&gt; равно &lt;code&gt;Bool&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="5afb8d5acf60ecdcd4dfe5d3e5a47e7bac7660ac" translate="yes" xml:space="preserve">
          <source>Here we use &lt;a href=&quot;../../base/base/index#Base.include_string&quot;&gt;&lt;code&gt;include_string&lt;/code&gt;&lt;/a&gt;, to evaluate &lt;code&gt;code&lt;/code&gt; as though it were the contents of a file. We could also save &lt;code&gt;code&lt;/code&gt; to a file and then call &lt;code&gt;include&lt;/code&gt; on that file&amp;mdash;the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let's break down what's happening here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">Вот краткий пример:</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">Вот простой пример запуска внешней программы:</target>
        </trans-unit>
        <trans-unit id="1cdb1c514a8c4179306e34bfddd814358210098d" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">Здесь &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; сначала открывает файл для записи, а затем передает результирующий выходной поток анонимной функции, которую вы определили в блоке &lt;code&gt;do ... end&lt;/code&gt; . После выхода из функции &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; гарантирует, что поток закрыт должным образом, независимо от того, завершилась ли функция нормально или сгенерировала исключение. (Конструкция &lt;code&gt;try/finally&lt;/code&gt; будет описана в &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;разделе &amp;laquo;Поток управления&amp;raquo;&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b6b3a9234aa3e202da30078d8340c4a596ef7790" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; and the first argument &amp;mdash; the element type &amp;mdash; is optional, defaulting to &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;(2, 3)&lt;/code&gt; - &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;count&lt;/code&gt; находит количество &lt;code&gt;GitHash&lt;/code&gt; по пути с определенным GitHash . Поскольку &lt;code&gt;GitHash&lt;/code&gt; уникален для фиксации, &lt;code&gt;cnt&lt;/code&gt; будет &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;map&lt;/code&gt; посещает каждый коммит с помощью &lt;code&gt;GitRevWalker&lt;/code&gt; и находит его &lt;code&gt;GitHash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;sp.data&lt;/code&gt; относится ко второму параметру в вызове конструктора &lt;code&gt;SamplerSimple&lt;/code&gt; (в данном случае равняется &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; ), а к объекту &lt;code&gt;Die&lt;/code&gt; можно получить доступ через &lt;code&gt;sp[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">Здесь Джулия смогла обнаружить, что &lt;code&gt;B&lt;/code&gt; на самом деле симметрична, и использовала более подходящую факторизацию. Часто можно написать более эффективный код для матрицы, которая, как известно, обладает определенными свойствами, например, симметричной или трехдиагональной. Джулия предоставляет несколько специальных типов, чтобы вы могли &amp;laquo;пометить&amp;raquo; матрицы как имеющие эти свойства. Например:</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Здесь оценка объекта выражения приводит к присвоению значения глобальной переменной &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6153340adbaa08a931cc654aec620e3452eb7b03" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">Здесь вход &lt;code&gt;p&lt;/code&gt; объявлен как &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; тип Ref {gsl_permutation} , что означает, что память, на которую указывает &lt;code&gt;p&lt;/code&gt; , может управляться Джулией или C. Указатель на память, выделенный C, должен иметь тип &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; , но он может быть преобразован с помощью &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; и, следовательно, может использоваться в том же (ковариантном) контексте входного аргумента для &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; . Указатель на память, выделенную Джулией, должен иметь тип &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; , чтобы гарантировать, что указанный адрес памяти действителен и что сборщик мусора Джулии правильно управляет фрагментом памяти, на который указывает указанная память. Следовательно, &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; объявление позволяет использовать указатели, управляемые C или Julia.</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">Здесь параметр &lt;code&gt;--math-mode=ieee&lt;/code&gt; отключает макрос &lt;code&gt;@fastmath&lt;/code&gt; , чтобы мы могли сравнивать результаты.</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">Здесь сумма, полученная с помощью &lt;code&gt;sum&lt;/code&gt; , передается в функцию &lt;code&gt;sqrt&lt;/code&gt; . Эквивалентный состав будет:</target>
        </trans-unit>
        <trans-unit id="4e8ac284e43281c0f4a614327786f479a4ecc8c6" translate="yes" xml:space="preserve">
          <source>Here, though, we'll use the text-based display that comes with the standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">Здесь мы случайно узнали, что первым элементом &lt;code&gt;a&lt;/code&gt; будет &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; . Создание такой аннотации имеет дополнительное преимущество: она вызовет ошибку времени выполнения, если значение не соответствует ожидаемому типу, что потенциально может привести к обнаружению определенных ошибок раньше.</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">Здесь мы хотим, чтобы &lt;code&gt;t0&lt;/code&gt; , &lt;code&gt;t1&lt;/code&gt; и &lt;code&gt;val&lt;/code&gt; были частными временными переменными, и мы хотим, чтобы &lt;code&gt;time&lt;/code&gt; ссылалось на функцию &lt;code&gt;time&lt;/code&gt; в Julia Base, а не на любую &lt;code&gt;time&lt;/code&gt; переменную, которая может быть у пользователя (то же самое относится к &lt;code&gt;println&lt;/code&gt; ). Представьте себе проблемы, которые могли бы возникнуть, если бы пользовательское выражение &lt;code&gt;ex&lt;/code&gt; также содержало назначения переменной с именем &lt;code&gt;t0&lt;/code&gt; или определяло свою собственную переменную &lt;code&gt;time&lt;/code&gt; . Мы можем получить ошибки или загадочно неправильное поведение.</target>
        </trans-unit>
        <trans-unit id="9694586c6d84150f32d012165fb51d66a0071dfd" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">Здесь мы добавили функцию настраиваемого конструктора, чтобы он мог принимать аргументы различных типов &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;преобразовывать&lt;/a&gt; их в общий тип (см. &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Конструкторы&lt;/a&gt; и Преобразование и продвижение ). (Конечно, нам пришлось бы определить множество других методов, чтобы заставить его действовать как &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; , например, &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;one&lt;/code&gt; , &lt;code&gt;zero&lt;/code&gt; , правила продвижения и т. Д.) По умолчанию экземпляры этого типа отображаются довольно просто , с информацией об имени типа и значениях полей, например, &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">Здесь, как вы создали ту же проблему снова и снова: компилятор не может угадать , что &lt;code&gt;n&lt;/code&gt; есть, поэтому он не знает &lt;em&gt;тип&lt;/em&gt; из &lt;code&gt;Val(n)&lt;/code&gt; . Попытка использовать &lt;code&gt;Val&lt;/code&gt; , но сделанная это неправильно, может легко &lt;em&gt;ухудшить&lt;/em&gt; производительность во многих ситуациях. (Только в ситуациях, когда вы эффективно комбинируете &lt;code&gt;Val&lt;/code&gt; с уловкой с функциональным барьером, чтобы сделать функцию ядра более эффективной, следует использовать код, подобный приведенному выше.)</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">гермитианская матрица конъюгата</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">гермитская матрица</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">разложение Гессенберга</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">Шестнадцатеричные байты ( &lt;code&gt;\x&lt;/code&gt; с 1-2 завершающими шестнадцатеричными цифрами)</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">Шестнадцатеричные литералы с плавающей запятой также допустимы, но только как значения &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , где &lt;code&gt;p&lt;/code&gt; предшествует показателю с основанием 2:</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">Символ высокой яркости</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">Знак высокого напряжения</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">Туфля на высоком каблуке</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">Эмбеджирование на высоком уровне</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">Высокоуровневое встраивание в Windows с помощью Visual Studio</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">Высокоскоростной поезд</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">Высокоскоростной поезд с носом пули</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">Библиотеки высокого уровня, такие как &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; и &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">Специфичные для поставщика абстракции высокого уровня, такие как &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; и &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">Подожди:почему макросы?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">Содержит ссылку на объект типа &lt;code&gt;T&lt;/code&gt; , гарантируя, что доступ к нему осуществляется только атомарно, то есть потокобезопасным способом.</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">Главная, &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">Медовый горшок</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">Подключение к &lt;code&gt;Random&lt;/code&gt; API</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">Горизонтальный Чёрный Шестигранник</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">Горизонтальная Эллипсис</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">Горизонтальный светофор</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">Горизонтальная и вертикальная конкатенация в одном вызове.Эта функция вызывается для синтаксиса блочных матриц.Первый аргумент определяет количество аргументов для конкатенирования в каждой строке блока.</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">горизонтальные правила</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">Лошадиное лицо</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">Конные скачки</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">Горячий напиток</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">Горячие источники</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="c29e8e28d3952318903de2fb6079804d2ed9d9e6" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) with a minimum width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">Песочные часы с проточным песком</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">Строительство домов</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">Дом с садом</target>
        </trans-unit>
        <trans-unit id="75af347bffc8062b7ea5afa0a699184af65b1a37" translate="yes" xml:space="preserve">
          <source>How can I constrain or compute type parameters?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">Как я могу изменить декларацию типа в моем сеансе?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">Как цитируется имя файла? Джулия знает, что &lt;code&gt;file&lt;/code&gt; предназначен для интерполяции как один аргумент, поэтому она цитирует это слово за вас. На самом деле это не совсем точно: значение &lt;code&gt;file&lt;/code&gt; никогда не интерпретируется оболочкой, поэтому нет необходимости в цитировании; цитаты вставляются только для представления пользователю. Это будет работать даже, если вы интерполируете значение как часть слова оболочки:</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">Как поймать CTRL-C в сценарии?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">Как проверить,выполняется ли текущий файл в качестве основного скрипта?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">Как удалить объект в памяти?</target>
        </trans-unit>
        <trans-unit id="07788c6091915f1a67274d44211a41dbc53e6935" translate="yes" xml:space="preserve">
          <source>How do I manage precompilation caches in distributed file systems?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">Как передать параметры &lt;code&gt;julia&lt;/code&gt; с помощью &lt;code&gt;#!/usr/bin/env&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">Как &quot;недействительность&quot;,&quot;небытие&quot; или &quot;мимолетность&quot; работают в Юлии?</target>
        </trans-unit>
        <trans-unit id="b5188f1df50966f544cd1288a28b80d8b68a2b7f" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">Как создать объект &lt;code&gt;Point&lt;/code&gt; ? Можно определить пользовательские конструкторы для составных типов, которые будут подробно обсуждаться в разделе &amp;laquo; &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Конструкторы&amp;raquo;&lt;/a&gt; , но при отсутствии каких-либо специальных объявлений конструкторов есть два способа создания новых составных объектов по умолчанию, один из которых явно дает параметры типа. и другой, в котором они подразумеваются аргументами конструктора объекта.</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">Как эти аргументы инициализируются, зависит от &amp;laquo;внешней&amp;raquo; функции; здесь &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; будет последовательно устанавливать &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; , вызывая анонимную функцию для каждого, как это происходит в синтаксической &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">Как вы используете эту информацию, зависит от вас. Очевидно, было бы лучше всего исправить &lt;code&gt;pos&lt;/code&gt; , чтобы он был стабильным по типу: если вы это сделаете, все переменные в &lt;code&gt;f&lt;/code&gt; будут конкретными, и его производительность будет оптимальной. Однако бывают обстоятельства, при которых такая нестабильность &lt;em&gt;эфемерного&lt;/em&gt; типа может не иметь большого значения: например, если &lt;code&gt;pos&lt;/code&gt; никогда не используется изолированно, тот факт, что вывод &lt;code&gt;f&lt;/code&gt; является &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; -стабильным (для Float64input) защитит более поздний код от распространяющихся эффектов нестабильности типа. Это особенно актуально в тех случаях, когда исправить нестабильность типа сложно или невозможно. В таких случаях приведенные выше советы (например, добавление аннотаций типов и / или разделение функций) - ваши лучшие инструменты для сдерживания &amp;laquo;ущерба&amp;raquo; от нестабильности типов. Также обратите внимание, что даже в Julia Base есть функции нестабильного типа. Например, функция &lt;code&gt;findfirst&lt;/code&gt; возвращает индекс в массив, в котором найден ключ, или &lt;code&gt;nothing&lt;/code&gt; если он не найден, нестабильность явного типа. Чтобы упростить поиск нестабильностей типов, которые могут быть важны, &lt;code&gt;Union&lt;/code&gt; содержит либо &lt;code&gt;missing&lt;/code&gt; либо &lt;code&gt;nothing&lt;/code&gt; выделяются желтым цветом, а не красным.</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">Однако следует помнить,что макродиспетчеризация основана на типах АСТ,которые передаются макросу,а не на типах,которые оцениваются АСТ во время выполнения:</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">Однако вся информация, которая нам нужна для цикла, встроена в информацию о типе аргументов. Таким образом, мы можем использовать сгенерированные функции для перемещения итерации во время компиляции; на языке компилятора мы используем сгенерированные функции, чтобы вручную развернуть цикл. Тело становится почти идентичным, но вместо вычисления линейного индекса мы строим &lt;em&gt;выражение,&lt;/em&gt; которое вычисляет индекс:</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">Однако,это также будет очень медленным и утечка памяти,поэтому обычно следует избегать этого и вместо этого продолжать чтение.В следующем разделе рассматривается,как использовать косвенные вызовы для эффективного достижения подобного эффекта.</target>
        </trans-unit>
        <trans-unit id="d98a9aa4753704d7124f1d48bec32b6c3a7df644" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">Однако,для изменяемых объектов предупреждение выводится,как и ожидалось:</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">Однако в будущих вызовах &lt;code&gt;tryeval&lt;/code&gt; будет по-прежнему отображаться определение &lt;code&gt;newfun&lt;/code&gt; , как это было &lt;em&gt;в предыдущем операторе REPL&lt;/em&gt; , и, следовательно, до этого вызова &lt;code&gt;tryeval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2749cf17a2b4294f113fe7c480d466ff1081a71" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you &lt;em&gt;can&lt;/em&gt; change its content. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">Однако при необходимости вы можете сосредоточиться на любом или на всех этих аргументах. Последний аргумент &lt;code&gt;bc&lt;/code&gt; - это ленивое представление (потенциально объединенной) операции &lt;code&gt;Broadcasted&lt;/code&gt; объекта Broadcasted . Для этих целей наиболее важными полями оболочки являются &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;args&lt;/code&gt; , описывающие соответственно функцию и список аргументов. Обратите внимание, что список аргументов может включать и часто включает другие вложенные &lt;code&gt;Broadcasted&lt;/code&gt; оболочки.</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">Однако,если вы попытаетесь переопределить встроенную константу или уже используемую функцию,Джулия выдаст вам ошибку:</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">Однако нетрудно построить случаи,когда это не удастся:</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">Однако иногда бывает полезно повторно использовать существующую локальную переменную в качестве переменной итерации. Это удобно сделать, добавив ключевое слово &lt;code&gt;outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">Тем не менее, все еще возможно, например, отправить &lt;code&gt;MyType&lt;/code&gt; процессу, который загрузил &lt;code&gt;DummyModule&lt;/code&gt; , даже если он не входит в область действия:</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">Однако использование таких методов может быть на удивление тонким. Например, не поможет, если вы вызвали &lt;code&gt;array3&lt;/code&gt; из такой функции:</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">Однако другие подобные звонки до сих пор не работают:</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">Однако, поскольку нельзя полагаться на автоматическую векторизацию, в будущем использование будет в основном через библиотеки, использующие &lt;code&gt;llvmcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">Однако,поскольку это немного громоздко,существует несколько удобных методов.Например,мы могли бы написать выше как:</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">Однако некоторые модули содержат подмодули, что означает, что иногда вам нужно получить доступ к модулю не верхнего уровня. Есть два способа сделать это. Первый - использовать абсолютный путь, например, &lt;code&gt;using Base.Sort&lt;/code&gt; . Второй - использовать относительный путь, который упрощает импорт подмодулей текущего модуля или любого из его включающих модулей:</target>
        </trans-unit>
        <trans-unit id="5f8e9c86265d52a44715f5ea3dcba697bb6fdada" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">Однако иногда имеет смысл оставить первую букву в верхнем регистре, например, если аргумент функции - заглавная буква: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">Однако выражение внешней &lt;code&gt;quote&lt;/code&gt; может интерполировать значения внутри символа &lt;code&gt;$&lt;/code&gt; во внутренней кавычке. Это делается с помощью нескольких &lt;code&gt;$&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">Однако бывают случаи, когда вам может потребоваться объявить разные версии внешней функции для разных типов элементов или типов &lt;code&gt;AbstractVector&lt;/code&gt; поля &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;MySimpleContainer&lt;/code&gt; . Сделать это можно так:</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">Однако,есть три ключевых отличия:</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">Однако делать это &lt;em&gt;не&lt;/em&gt; рекомендуется. Вместо этого используйте более эффективную &lt;code&gt;complex&lt;/code&gt; функцию для построения комплексного значения непосредственно из его реальной и мнимой частей:</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">Однако &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; типов между примитивными типами, указанными выше, и BigInt / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; не происходит автоматически и должно быть явно указано.</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">Однако мы не делаем этого по уважительной причине: упаковка &lt;code&gt;expr&lt;/code&gt; в новый блок области видимости (анонимная функция) также немного изменяет значение выражения (область видимости любых переменных в нем), в то время как мы хотим, чтобы &lt;code&gt;@time&lt;/code&gt; было быть пригодным для использования с минимальным влиянием на упакованный код.</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">Однако, хотя макет типа должен быть известен статически для вычисления предполагаемого C ABI, статические параметры функции считаются частью этой статической среды. Статические параметры функции могут использоваться в качестве параметров типа в сигнатуре вызова, если они не влияют на макет типа. Например, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; допустимо, поскольку &lt;code&gt;Ptr&lt;/code&gt; всегда является примитивным типом размером в слово. Но &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; недопустим, так как макет типа &lt;code&gt;T&lt;/code&gt; статически неизвестен.</target>
        </trans-unit>
        <trans-unit id="08e25fd1d8072dc28d6c1dfa6f07c1fbd4ffc288" translate="yes" xml:space="preserve">
          <source>However, you can get access to &lt;code&gt;PowerShell&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">Символ сотни пунктов</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">Оттопыренное лицо</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Хайндман, Р. Дж. И Фан, Ю. (1996) &quot;Выборочные квантили в статистических пакетах&quot;, &lt;em&gt;The American Statistician&lt;/em&gt; , Vol. 50, No. 4, pp. 361-365</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">I (интервал)</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">Я передал аргумент &lt;code&gt;x&lt;/code&gt; функции, изменил его внутри этой функции, но снаружи переменная &lt;code&gt;x&lt;/code&gt; все еще не изменилась. Зачем?</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">Т.е. значение, возвращаемое &lt;code&gt;codeunit(s, i)&lt;/code&gt; относится к типу, возвращаемому &lt;code&gt;codeunit(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">Вход/выход и сеть</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">идентификатор устройства,содержащего файл</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">Контекстуальные свойства выходного сигнала ввода-вывода</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">IO Перенаправление может быть достигнуто путем передачи аргументов ключевых слов &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; к &lt;code&gt;pipeline&lt;/code&gt; функции:</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">Мороженое</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">Аналогично</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">Идентичная и наклонная параллель.</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">Идентично с точкой выше</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">Если $n$ отрицательный,то он определяется с точки зрения идентичности.</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">Если $ n $ неотрицательно, то это количество способов выбрать &lt;code&gt;k&lt;/code&gt; из &lt;code&gt;n&lt;/code&gt; элементов:</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; не имеет отрицательного действительного собственного значения, вычислите логарифм главной матрицы &lt;code&gt;A&lt;/code&gt; , то есть единственную матрицу $ X $ такую, что $ e ^ X = A $ и $ - \ pi &amp;lt;Im (\ lambda) &amp;lt;\ pi $ для всех собственные значения $ \ lambda $ оператора $ X $. Если &lt;code&gt;A&lt;/code&gt; имеет неположительные собственные значения, по возможности возвращается неглавная матричная функция.</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; не имеет отрицательных действительных собственных значений, вычислите квадратный корень главной матрицы из &lt;code&gt;A&lt;/code&gt; , то есть единственную матрицу $ X $ с собственными значениями, имеющими положительную действительную часть, такую ​​что $ X ^ 2 = A $. В противном случае возвращается неглавный квадратный корень.</target>
        </trans-unit>
        <trans-unit id="390ecc8380adb6dd4fff37f515d8dc55040ad6a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt; or real-&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt;, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and &lt;code&gt;F.H&lt;/code&gt; is of type &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e08a2a0f6796f08007ab9fdda2c45c43480624f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d3df34d4b0d8669771d98ccd80e4361eb22b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is real-symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. For such matrices, eigenvalues &amp;lambda; that appear to be slightly negative due to roundoff errors are treated as if they were zero More precisely, matrices with all eigenvalues &lt;code&gt;&amp;ge; -rtol*(max |&amp;lambda;|)&lt;/code&gt; are treated as semidefinite (yielding a Hermitian square root), with negative eigenvalues taken to be zero. &lt;code&gt;rtol&lt;/code&gt; is a keyword argument to &lt;code&gt;sqrt&lt;/code&gt; (in the Hermitian/real-symmetric case only) that defaults to machine precision scaled by &lt;code&gt;size(A,1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( собственное разложение ) используется для вычисления косинуса. В противном случае косинус определяется вызовом &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( собственное ) используется для вычисления обратного косинуса. В противном случае обратный косинус определяется с помощью &lt;code&gt;log&lt;/code&gt; и &lt;code&gt;sqrt&lt;/code&gt; . Теорию и логарифмические формулы, используемые для вычисления этой функции, см. В &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="656a2e02dd9901a5d5d038f1484c6e9a0c0da179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_1&quot; id=&quot;citeref-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( eigen ) используется для вычисления обратного синуса. В противном случае обратный синус определяется с помощью &lt;code&gt;log&lt;/code&gt; и &lt;code&gt;sqrt&lt;/code&gt; . Теорию и логарифмические формулы, используемые для вычисления этой функции, см. В &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c57d54383c6569d422099f76dc516cae4a4a6b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_2&quot; id=&quot;citeref-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( собственное ) используется для вычисления арктангенса. В противном случае арктангенс определяется с помощью &lt;code&gt;log&lt;/code&gt; . Теорию и логарифмические формулы, используемые для вычисления этой функции, см. В &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88a24bd15ac5a68c08c00b78778d22ccaac3c21f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_3&quot; id=&quot;citeref-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( собственное ) используется для вычисления синуса. В противном случае синус определяется вызовом &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( eigen ) используется для вычисления квадратного корня. В противном случае квадратный корень определяется с помощью метода &lt;a href=&quot;#footnote-BH83&quot;&gt;Бьорка-Хаммарлинга [BH83]&lt;/a&gt; , который вычисляет комплексную форму Шура ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; ), а затем комплексный квадратный корень из треугольного множителя.</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( собственное ) используется для вычисления касательной. В противном случае касательная определяется вызовом &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является симметричным или эрмитовым, используется его &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( собственное разложение ), если &lt;code&gt;A&lt;/code&gt; треугольное, используется улучшенная версия метода обратного масштабирования и возведения в квадрат (см. &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; и &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt; ). Для общих матриц вычисляется комплексная форма Шура ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; ) и треугольный алгоритм используется для треугольного множителя.</target>
        </trans-unit>
        <trans-unit id="7cd81f11c1d70424b51ccffe350316108e01c22e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;sup&gt;&lt;a href=&quot;#footnote-AH12&quot; id=&quot;citeref-AH12&quot;&gt;[AH12]&lt;/a&gt;&lt;/sup&gt; and &lt;sup&gt;&lt;a href=&quot;#footnote-AHR13&quot; id=&quot;citeref-AHR13&quot;&gt;[AHR13]&lt;/a&gt;&lt;/sup&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">Если &lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; не имеет определенного размера, выдается ошибка.</target>
        </trans-unit>
        <trans-unit id="65a78265c4f32be6b8f80e6ff2b5005fabff1e58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Eigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c71436c7107833fddd5b4b5c6ae6ac2cda922a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedEigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01e4881f70ca748aeb84922a14f5f7db186c9f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedSchur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factors can be obtained via &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors via &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt;, and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab48030073624eeb674b91b0955f920e2a071342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Hessenberg&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4e73df12d848cb37ff07b3e198fc0482a106ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::SVD&lt;/code&gt; is the factorization object, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; can be obtained via &lt;code&gt;F.U&lt;/code&gt;, &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.V&lt;/code&gt; and &lt;code&gt;F.Vt&lt;/code&gt;, such that &lt;code&gt;A = U * Diagonal(S) * Vt&lt;/code&gt;. The singular values in &lt;code&gt;S&lt;/code&gt; are sorted in descending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f171f3d3fce677fec26e12b57715e21774c193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Schur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factor can be obtained via either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors via &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">Если &lt;code&gt;I_1&lt;/code&gt; заменяется на двумерную матрицу, то &lt;code&gt;X&lt;/code&gt; становится &lt;code&gt;n+1&lt;/code&gt; -мерным массивом формы &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; . Матрица добавляет измерение.</target>
        </trans-unit>
        <trans-unit id="2337775037e3e4a6505e42024632bd3eb4bbd6dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::BunchKaufman&lt;/code&gt; is the factorization object, the components can be obtained via &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c942e11644bfa14cfe833c922c7cc44bc3db5861" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::LQ&lt;/code&gt; is the factorization object, the lower triangular component can be obtained via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; равно &lt;code&gt;Any&lt;/code&gt; , то предполагается, что память содержит ссылку на объект Julia ( &lt;code&gt;jl_value_t*&lt;/code&gt; ), результатом будет ссылка на этот объект, и объект не будет скопирован. В этом случае вы должны быть осторожны, чтобы убедиться, что объект всегда был виден сборщику мусора (указатели не учитываются, но новая ссылка учитывается), чтобы память не была освобождена преждевременно. Обратите внимание: если объект не был изначально выделен Джулией, новый объект никогда не будет завершен сборщиком мусора Джулии. Если &lt;code&gt;Ptr&lt;/code&gt; сам на самом деле &lt;code&gt;jl_value_t*&lt;/code&gt; , он может быть преобразован обратно в ссылку на объект Julia по &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt; . (Джулия ценит &lt;code&gt;v&lt;/code&gt; может быть преобразован в указатели &lt;code&gt;jl_value_t*&lt;/code&gt; , как &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; , путем вызова &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; типа, то он возвращает ближайшее значение к &lt;code&gt;x&lt;/code&gt; представимому &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - это тип коллекции, а &lt;code&gt;x&lt;/code&gt; - коллекция, результат &lt;code&gt;convert(T, x)&lt;/code&gt; может быть псевдонимом всего или части &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом с плавающей запятой, результатом является ближайшее представимое значение, которое может быть положительной или отрицательной бесконечностью.</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - числовой тип, результатом является массив этого типа с любыми нечисловыми элементами, такими как &lt;code&gt;NaN&lt;/code&gt; для типов с плавающей запятой или ноль. Другие полезные значения &lt;code&gt;T&lt;/code&gt; включают &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;AbstractString&lt;/code&gt; и &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5708e9143fa5c221a25e2fd582d17441adb4aff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union of types containing &lt;code&gt;Missing&lt;/code&gt;, return a new type with &lt;code&gt;Missing&lt;/code&gt; removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; представляет собой &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; типа, &lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; будет повышен , если &lt;code&gt;x&lt;/code&gt; не представим &lt;code&gt;T&lt;/code&gt; , например , если &lt;code&gt;x&lt;/code&gt; не являются целочисленным, или находится вне диапазона , поддерживаемый &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; представляет собой целочисленный тип, &lt;code&gt;InexactError&lt;/code&gt; возникает , если &lt;code&gt;x&lt;/code&gt; не представим &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;X/Project.toml&lt;/code&gt; существует, но &lt;em&gt;не&lt;/em&gt; имеет записи UUID верхнего уровня, &lt;code&gt;uuid&lt;/code&gt; является фиктивным UUID, созданным путем хеширования канонического (реального) пути к &lt;code&gt;X/Project.toml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">Если &lt;code&gt;X/Project.toml&lt;/code&gt; существует и имеет запись &lt;code&gt;uuid&lt;/code&gt; , тогда &lt;code&gt;uuid&lt;/code&gt; является этим значением.</target>
        </trans-unit>
        <trans-unit id="b0ad6875ad056062a02a932f0ca014f6680202e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alg = DivideAndConquer()&lt;/code&gt; a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is &lt;code&gt;alg = QRIteration()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">Если &lt;code&gt;all&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; (по умолчанию), то эта функция будет блокировать несколько раз пытается прочитать все запрошенные байты, пока ошибка или наступает конец файла не происходит. Если &lt;code&gt;all&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; , выполняется не более одного вызова &lt;code&gt;read&lt;/code&gt; , а объем возвращаемых данных зависит от устройства. Обратите внимание, что не все типы потоков поддерживают параметр &lt;code&gt;all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">Если &lt;code&gt;b&lt;/code&gt; представляет собой степень 2 или 10, следует использовать &lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; , так как они обычно будут быстрее и точнее. Например,</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">Если &lt;code&gt;batch_size&lt;/code&gt; , коллекция обрабатывается в пакетном режиме. Тогда &lt;code&gt;f&lt;/code&gt; должна быть функцией, которая должна принимать &lt;code&gt;Vector&lt;/code&gt; кортежей аргументов и должна возвращать вектор результатов. Входной вектор будет иметь длину &lt;code&gt;batch_size&lt;/code&gt; или меньше.</target>
        </trans-unit>
        <trans-unit id="9a514f5181b462b5cf60570457a733a924782944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;collection&lt;/code&gt; is ordered, use &lt;a href=&quot;#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt; to add all the elements of another collection to it. The result of the preceding example is equivalent to &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt;. For &lt;code&gt;AbstractSet&lt;/code&gt; objects, &lt;a href=&quot;#Base.union!&quot;&gt;&lt;code&gt;union!&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">Если &lt;code&gt;dims&lt;/code&gt; является кортежем, порядок измерений в &lt;code&gt;dims&lt;/code&gt; имеет значение и определяет линейный порядок срезов. Например, если &lt;code&gt;A&lt;/code&gt; является трехмерным, а &lt;code&gt;dims&lt;/code&gt; равно &lt;code&gt;(1, 2)&lt;/code&gt; , порядок первых двух измерений переупорядочивается так, что срезы (оставшегося третьего измерения) сортируются. Если вместо этого &lt;code&gt;dims&lt;/code&gt; равно &lt;code&gt;(2, 1)&lt;/code&gt; , будут взяты те же срезы, но вместо этого будет порядок результатов по основным строкам.</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;dlm&lt;/code&gt; опущен, по умолчанию используется &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">Если &lt;code&gt;factorize&lt;/code&gt; вызывается, например, для эрмитовой положительно определенной матрицы, то &lt;code&gt;factorize&lt;/code&gt; вернет факторизацию Холецкого.</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;follow_symlinks=false&lt;/code&gt; и &lt;code&gt;src&lt;/code&gt; является символической ссылкой, &lt;code&gt;dst&lt;/code&gt; будет создан как символическая ссылка. Если &lt;code&gt;follow_symlinks=true&lt;/code&gt; и &lt;code&gt;src&lt;/code&gt; является символической ссылкой, &lt;code&gt;dst&lt;/code&gt; будет копией файла или каталога, на который ссылается &lt;code&gt;src&lt;/code&gt; . Вернуть &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">Если &lt;code&gt;full = false&lt;/code&gt; (по умолчанию), возвращается &quot;тонкий&quot; SVD. Для матрицы &lt;code&gt;A&lt;/code&gt; $ M \ times N $ в полной факторизации &lt;code&gt;U&lt;/code&gt; равно &lt;code&gt;M \times M&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; равно &lt;code&gt;N \times N&lt;/code&gt; , тогда как в тонкой факторизации &lt;code&gt;U&lt;/code&gt; равно &lt;code&gt;M \times K&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; равно &lt;code&gt;N \times K&lt;/code&gt; , где &lt;code&gt;K = \min(M,N)&lt;/code&gt; - количество сингулярных значений.</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">Если &lt;code&gt;fussy_sqrt&lt;/code&gt; вызывается с отрицательным значением из другой функции, вместо попытки продолжить выполнение вызывающей функции, он немедленно возвращается, отображая сообщение об ошибке в интерактивном сеансе:</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">Если &lt;code&gt;generated&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; , возвращаемые &lt;code&gt;CodeInfo&lt;/code&gt; экземпляры будут соответствовать Откат реализации. Если не существует резервной реализации, выдается ошибка. Если &lt;code&gt;generated&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , эти &lt;code&gt;CodeInfo&lt;/code&gt; экземпляры будут соответствовать методу тел , полученных в результате расширения генераторов.</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;header&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , первая строка данных будет считана как заголовок, а кортеж &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; будет возвращен вместо только &lt;code&gt;data_cells&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;i&lt;/code&gt; находится в границах в &lt;code&gt;s&lt;/code&gt; , вернуть индекс начала символа, частью которого является единица кода кодирования &lt;code&gt;i&lt;/code&gt; . Другими словами, если &lt;code&gt;i&lt;/code&gt; - начало символа, верните &lt;code&gt;i&lt;/code&gt; ; если &lt;code&gt;i&lt;/code&gt; не является началом символа, перемотать до начала символа и вернуть этот индекс. Если &lt;code&gt;i&lt;/code&gt; равно 0 или &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; верните &lt;code&gt;i&lt;/code&gt; . Во всех остальных случаях бросайте &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;i&lt;/code&gt; находится в границах &lt;code&gt;s&lt;/code&gt; , вернуть индекс начала символа, кодировка которого начинается после индекса &lt;code&gt;i&lt;/code&gt; . Другими словами, если &lt;code&gt;i&lt;/code&gt; - начало символа, вернуть начало следующего символа; если &lt;code&gt;i&lt;/code&gt; не является началом символа, двигаться вперед до начала символа и вернуть этот индекс. Если &lt;code&gt;i&lt;/code&gt; равно &lt;code&gt;0&lt;/code&gt; , верните &lt;code&gt;1&lt;/code&gt; . Если &lt;code&gt;i&lt;/code&gt; находится в границах, но больше или равно &lt;code&gt;lastindex(str)&lt;/code&gt; верните &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; . В противном случае бросьте &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;i&lt;/code&gt; находится в границах &lt;code&gt;s&lt;/code&gt; , верните индекс начала символа, кодировка которого начинается до индекса &lt;code&gt;i&lt;/code&gt; . Другими словами, если &lt;code&gt;i&lt;/code&gt; - начало символа, вернуть начало предыдущего символа; если &lt;code&gt;i&lt;/code&gt; не является началом символа, перемотать до начала символа и вернуть этот индекс. Если &lt;code&gt;i&lt;/code&gt; равно &lt;code&gt;1&lt;/code&gt; , верните &lt;code&gt;0&lt;/code&gt; . Если &lt;code&gt;i&lt;/code&gt; равен &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; верните &lt;code&gt;lastindex(str)&lt;/code&gt; . В противном случае бросьте &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ebe5e40c213fd1e7b9dc945437a4e812c30e543" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), then &lt;code&gt;ix&lt;/code&gt; is initialized to contain the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fcfeccc007b268d4af436c2f9443a9d036bba79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, but &lt;code&gt;ix&lt;/code&gt; does not contain (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;, the behavior of &lt;code&gt;partialsortperm!&lt;/code&gt; is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">Если &lt;code&gt;io&lt;/code&gt; не указан, для подключения используются &lt;code&gt;host&lt;/code&gt; и &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">Если указан &lt;code&gt;io&lt;/code&gt; , он используется для чтения информации о хосте / порте. Рабочий Julia распечатывает свой адрес привязки и порт при запуске. Это позволяет работникам Julia прослушивать любой свободный доступный порт, вместо того, чтобы настраивать рабочие порты вручную.</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">Если &lt;code&gt;irange&lt;/code&gt; не равно &lt;code&gt;1:n&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - размерность &lt;code&gt;A&lt;/code&gt; , то возвращенная факторизация будет &lt;em&gt;усеченной&lt;/em&gt; факторизацией.</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;isless(x, y)&lt;/code&gt; определено, то также &lt;code&gt;isless(y, x)&lt;/code&gt; и &lt;code&gt;isequal(x, y)&lt;/code&gt; , и ровно один из этих трех дает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">Если &lt;code&gt;itr&lt;/code&gt; содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, результат также &lt;code&gt;NaN&lt;/code&gt; или &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; имеет приоритет, если &lt;code&gt;itr&lt;/code&gt; содержит оба). Используйте &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; функцию , чтобы опустить &lt;code&gt;missing&lt;/code&gt; данные и вычислить медиану , не являющихся пропущенными значениями.</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">Если &lt;code&gt;itr&lt;/code&gt; содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, результат также &lt;code&gt;NaN&lt;/code&gt; или &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; имеет приоритет, если массив содержит оба). Используйте функцию пропуска, чтобы пропустить &lt;code&gt;missing&lt;/code&gt; записи и вычислить среднее значение из &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; значений.</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;itr&lt;/code&gt; является &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; могут быть предоставлены для вычисления стандартного отклонения по размерам, а &lt;code&gt;m&lt;/code&gt; может содержать средства для каждого измерения &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;itr&lt;/code&gt; является &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; могут быть предоставлены для вычисления стандартного отклонения по размерам, а &lt;code&gt;means&lt;/code&gt; могут содержать средства для каждого измерения &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a062a8f0de1a26806b03ecc36f3c075df17d6625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;itr&lt;/code&gt; является &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; могут быть предоставлены для вычисления дисперсии по измерениям, а &lt;code&gt;m&lt;/code&gt; может содержать средства для каждого измерения &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;itr&lt;/code&gt; является &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; могут быть предоставлены для вычисления дисперсии по измерениям, а &lt;code&gt;mean&lt;/code&gt; может содержать средства для каждого измерения &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990c04cdd5ec49c07722688547969ed041fe0726" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c42d84f4d44608418a9c06e641987a8cc6e81e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Если &lt;code&gt;length&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; указаны, а &lt;code&gt;step&lt;/code&gt; - нет, размер шага будет вычисляться автоматически, так что в диапазоне есть линейно разнесенные по &lt;code&gt;length&lt;/code&gt; элементы ( &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a704a76b38109c4ddf6a00329dc6ebcf8c7f4fac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d6d1b8a88beec41cb040befac543132aff1625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;overlap=true&lt;/code&gt;, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">Если &lt;code&gt;pids&lt;/code&gt; не указан , общий массив будет отображен на все процессы на текущем хосте, включая мастер. Но &lt;code&gt;localindices&lt;/code&gt; и &lt;code&gt;indexpids&lt;/code&gt; будут относиться только к рабочим процессам. Это упрощает код распределения работы для использования рабочих для фактических вычислений с главным процессом, действующим в качестве драйвера.</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">Если &lt;code&gt;quotes&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , столбцы заключены в двойные кавычки ( &quot;) символы могут содержать новые строки и разделители столбцов. Дважды кавычки в кавычках поля должны быть экранированы с другой двойной кавычки. Указание &lt;code&gt;dims&lt;/code&gt; как кортеж из ожидаемых строки и столбцы (включая заголовок, если таковой имеется) могут ускорить чтение больших файлов. Если &lt;code&gt;comments&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , строки, начинающиеся с &lt;code&gt;comment_char&lt;/code&gt; , и текст, следующий за &lt;code&gt;comment_char&lt;/code&gt; в любой строке, игнорируются.</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">Если &lt;code&gt;reuseaddr=true&lt;/code&gt; , несколько потоков или процессов могут без ошибок связываться с одним и тем же адресом, если все они устанавливают &lt;code&gt;reuseaddr=true&lt;/code&gt; , но только последний из них получит трафик.</target>
        </trans-unit>
        <trans-unit id="88b9f6afde6b8b83ebdb2719c69ddd36ee622e38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rng&lt;/code&gt; is not specified, it defaults to seeding the state of the shared thread-local generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">Если &lt;code&gt;rook&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , используются ладья поворотный. Если &lt;code&gt;rook&lt;/code&gt; ложная, поворот ладьи не используется.</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">Если &lt;code&gt;skipblanks&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , пустые строки во входном будут игнорироваться.</target>
        </trans-unit>
        <trans-unit id="01862aa97c770501d33a4692799d52e5b5e3dee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;spawn = true&lt;/code&gt;, the Task created for &lt;code&gt;func&lt;/code&gt; may be scheduled on another thread in parallel, equivalent to creating a task via &lt;a href=&quot;../multi-threading/index#Base.Threads.@spawn&quot;&gt;&lt;code&gt;Threads.@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Если &lt;code&gt;step&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; указаны, а &lt;code&gt;length&lt;/code&gt; не &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt; , общая длина диапазона будет вычисляться автоматически, так что элементы будут разнесены на &lt;code&gt;step&lt;/code&gt; ( StepRange ).</target>
        </trans-unit>
        <trans-unit id="a062e99e636224da62916657b0080cc837347ab0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a505616ea56a3e3c587fbb37c2a52b74909df91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;InterruptException&lt;/code&gt; is not thrown by Ctrl-C. Running code upon such event requires &lt;a href=&quot;../base/index#Base.atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;. This is the default behavior in Julia script run without &lt;code&gt;-i&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;types&lt;/code&gt; являются абстрактным типом, возвращается метод, который будет вызываться при &lt;code&gt;invoke&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99dfe42909a3f5fda34b5da4dc246c9c5fb25583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, return an array of methods whose types match. If &lt;code&gt;module&lt;/code&gt; is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">Если &lt;code&gt;types&lt;/code&gt; указаны, возвращает массив методов, типы которых совпадают.</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">Если &lt;code&gt;use_mmap&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , то файл , указанный &lt;code&gt;source&lt;/code&gt; является отображенные на память для потенциальных ускорений. По умолчанию &lt;code&gt;true&lt;/code&gt; кроме Windows. В Windows вы можете указать &lt;code&gt;true&lt;/code&gt; , если файл большой и читается только один раз, а не записывается.</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">Если &lt;code&gt;wait&lt;/code&gt; ложно, процесс выполняется асинхронно. Позже вы можете дождаться его и проверить его статус выхода, вызвав &lt;code&gt;success&lt;/code&gt; для возвращенного объекта процесса.</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - число, это по сути то же самое, что &lt;code&gt;one(x)/x&lt;/code&gt; , но для некоторых типов &lt;code&gt;inv(x)&lt;/code&gt; может быть немного более эффективным.</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является типом, вернуть &amp;laquo;больший&amp;raquo; тип, определенный так, чтобы арифметические операции &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;-&lt;/code&gt; гарантированно не переполнялись и не теряли точность для любой комбинации значений, которые тип &lt;code&gt;x&lt;/code&gt; может содержать.</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является значением, оно преобразуется в &lt;code&gt;widen(typeof(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - ссылка на объект, все элементы будут ссылаться на один и тот же объект. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; вернет массив, заполненный результатом однократной оценки &lt;code&gt;Foo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c793973e3f101c15348a8c798bb0a96d340155d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не является &lt;code&gt;AbstractArray&lt;/code&gt; , но поддерживает &lt;code&gt;axes&lt;/code&gt; , индексацию, а его тип поддерживает &lt;code&gt;ndims&lt;/code&gt; , тогда можно реализовать &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; , который просто возвращает себя. Кроме того, если &lt;code&gt;x&lt;/code&gt; определяет свой собственный &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; , он должен определить свой &lt;code&gt;broadcastable&lt;/code&gt; метод, чтобы вернуть себя, чтобы пользовательский стиль имел какой-либо эффект.</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; поддерживает итерацию, возвращаемое значение должно иметь те же &lt;code&gt;axes&lt;/code&gt; и поведение индексации, что и &lt;code&gt;collect(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; является литералом &lt;code&gt;Int&lt;/code&gt; (например, &lt;code&gt;2&lt;/code&gt; в &lt;code&gt;x^2&lt;/code&gt; или &lt;code&gt;-3&lt;/code&gt; в &lt;code&gt;x^-3&lt;/code&gt; ), код Юлии &lt;code&gt;x^y&lt;/code&gt; преобразуется компилятором в &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; , чтобы включить специализацию времени компиляции на значении экспоненты. (В качестве запасного &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; по умолчанию у нас есть Base.literal_pow (^, x, Val (y)) = ^ (x, y) , где обычно &lt;code&gt;^ == Base.^&lt;/code&gt; Если &lt;code&gt;^&lt;/code&gt; не был определен в вызывающем пространстве имен.)</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">Если &lt;code&gt;yes&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; , последующие операции с плавающей запятой подчиняются правилам арифметики IEEE для субнормальных значений (&amp;laquo;денормальных&amp;raquo;). В противном случае операции с плавающей запятой разрешены (но не требуются) для преобразования субнормальных входов или выходов в ноль. Возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;yes==true&lt;/code&gt; но оборудование не поддерживает обнуление субнормальных чисел.</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Если Джулия была языком , который сделал более либеральное использование ASCII символов, то прихлебывая оператор может быть записан в виде &lt;code&gt;&amp;lt;-...&lt;/code&gt; вместо &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Если Джулия была языком , который сделал более либеральное использование ASCII символов, оператор splatting может быть записан в виде &lt;code&gt;...-&amp;gt;&lt;/code&gt; вместо &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">Если [ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vu&lt;/code&gt; ] не содержит всех собственных значений &lt;code&gt;A&lt;/code&gt; , то возвращенная факторизация будет &lt;em&gt;усеченной&lt;/em&gt; факторизацией.</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">Если &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; пуст, считыватели (при вызове &lt;code&gt;take!&lt;/code&gt; ) Будут блокироваться до тех пор, пока данные не станут доступны.</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">Если &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; заполнен, писатели (при вызове &lt;code&gt;put!&lt;/code&gt; ) Будут блокироваться до тех пор, пока не освободится место.</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">Если подпрограмма C / C ++ имеет аргумент или возвращаемое значение, которое является собственным типом SIMD, соответствующий тип Julia является однородным кортежем &lt;code&gt;VecElement&lt;/code&gt; , который естественным образом отображается на тип SIMD. В частности:</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">Если функция Julia возвращает массив, возвращаемое значение &lt;code&gt;jl_eval_string&lt;/code&gt; и &lt;code&gt;jl_call&lt;/code&gt; может быть &lt;code&gt;jl_array_t*&lt;/code&gt; в jl_array_t * :</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">Если составной тип объявлен с &lt;code&gt;mutable struct&lt;/code&gt; вместо &lt;code&gt;struct&lt;/code&gt; , то его экземпляры могут быть изменены:</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">Если имя функции требует нескольких слов,подумайте,может ли оно представлять более одного понятия и лучше разбиться на части.</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">Если аргументу ключевого слова не присвоено значение по умолчанию в определении метода, то это &lt;em&gt;необходимо&lt;/em&gt; : будет &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt; исключение UndefKeywordError , если вызывающий объект не присвоит ему значение:</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">Если имя &lt;code&gt;Base.sin&lt;/code&gt; (например, Base.sin ), то к нему можно получить доступ, даже если оно не экспортируется. Это часто бывает полезно при отладке. К нему также могут быть добавлены методы с использованием полного имени в качестве имени функции. Однако из-за возникающих синтаксических неоднозначностей, если вы хотите добавить методы к функции в другом модуле, имя которого содержит только символы, например, оператор &lt;code&gt;Base.+&lt;/code&gt; , Вы должны использовать &lt;code&gt;Base.:+&lt;/code&gt; для ссылки на него. , Если длина оператора превышает один символ, вы должны &lt;code&gt;Base.:(==)&lt;/code&gt; его в квадратные скобки, например: Base.:(==) .</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">Если число не имеет точного представления с плавающей запятой, оно должно быть округлено до подходящего представимого значения. Однако способ, которым выполняется это округление, может быть изменен, если требуется, в соответствии с режимами округления, представленными в &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;стандарте IEEE 754&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">Если в подкаталоге пакета есть файл проекта, то запись графика для его UUID - это карта &lt;code&gt;[deps]&lt;/code&gt; файла проекта, которая считается пустой, если раздел отсутствует.</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">Если в подкаталоге пакета нет файла проекта,то он опускается из графа,а операторы импорта в его коде рассматриваются как топ-уровень,как и основной проект и REPL.</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">Если регулярное выражение действительно совпадает, значение, возвращаемое &lt;code&gt;RegexMatch&lt;/code&gt; &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; ,&lt;/a&gt; является объектом RegexMatch . Эти объекты записывают, как выражение соответствует, включая подстроку, которой соответствует шаблон, и любые захваченные подстроки, если они есть. Этот пример захватывает только ту часть подстроки, которая соответствует, но, возможно, мы хотим захватить любой непустой текст после символа комментария. Мы могли сделать следующее:</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">Если &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; второй аргумент &lt;code&gt;val&lt;/code&gt; , он будет передан задаче (через возвращаемое значение yieldto ) при повторном запуске . Если &lt;code&gt;error&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , то значение возводится в качестве исключения в задаче разбудили.</target>
        </trans-unit>
        <trans-unit id="731b72f6b2ff317794a532fdec183702202f0468" translate="yes" xml:space="preserve">
          <source>If a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents &lt;code&gt;&amp;radic;n&lt;/code&gt; for integers &lt;code&gt;n&lt;/code&gt; will give a rational result when &lt;code&gt;n&lt;/code&gt; is a perfect square), then it should also implement &lt;code&gt;isinteger&lt;/code&gt;, &lt;code&gt;iszero&lt;/code&gt;, &lt;code&gt;isone&lt;/code&gt;, and &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;Real&lt;/code&gt; values (since all of these default to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;AbstractIrrational&lt;/code&gt; types), as well as defining &lt;a href=&quot;../base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; to equal that of the corresponding &lt;code&gt;Rational&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">Если тест постоянно терпит неудачу, его можно изменить, чтобы использовать макрос &lt;code&gt;@test_broken&lt;/code&gt; . Это будет обозначать тест как &lt;code&gt;Broken&lt;/code&gt; , если тест по-прежнему терпит неудачу, и предупреждает пользователя через &lt;code&gt;Error&lt;/code&gt; , если тест завершается успешно.</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">Если предоставляется кортеж имен аргументов ключевых слов &lt;code&gt;kwnames&lt;/code&gt; , это также проверяет, имеет ли метод &lt;code&gt;f&lt;/code&gt; , соответствующий &lt;code&gt;t&lt;/code&gt; , заданные имена аргументов ключевого слова. Если метод сопоставления принимает переменное количество аргументов ключевого слова, например, с &lt;code&gt;kwargs...&lt;/code&gt; , любые имена, указанные в &lt;code&gt;kwnames&lt;/code&gt; , считаются допустимыми. В противном случае предоставленные имена должны быть подмножеством аргументов ключевого слова метода.</target>
        </trans-unit>
        <trans-unit id="abfdad8cad5f7ab5488ad45c94b34a153640fd97" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">Если тип определяется как подтип &lt;code&gt;AbstractArray&lt;/code&gt; , он наследует очень большой набор разнообразных поведений, включая итерацию и многомерное индексирование, построенные на основе одноэлементного доступа. См. &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;Страницу руководства&lt;/a&gt; по массивам и &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;раздел Julia Base&lt;/a&gt; для получения дополнительных сведений о поддерживаемых методах.</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">Если тип фактически является перечислением,то его следует определить как единственный (в идеале неизменяемая структура или примитивный)тип,при этом значения перечисления являются его примерами.Конструкторы и преобразования могут проверить,являются ли значения действительными.Такая конструкция предпочтительнее,чем абстрактный тип перечисления,в котором &quot;значения&quot; являются подтипами.</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">Если пользователю предлагается запрос учетных данных, он может прервать запрос, набрав &lt;code&gt;^D&lt;/code&gt; (нажав клавишу управления вместе с клавишей &lt;code&gt;d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">Если пул рабочих не указан,используются все доступные рабочие,т.е.пул рабочих по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">Если все данные будут числовыми,то результатом будет числовой массив.Если некоторые элементы не могут быть разобраны как числа,то возвращается неоднородный массив чисел и строк.</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">Если все индексы &lt;code&gt;I_k&lt;/code&gt; являются целыми числами, то значение в месте &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; из &lt;code&gt;A&lt;/code&gt; переписывается со значением &lt;code&gt;X&lt;/code&gt; , &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; ИНГ к &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; из &lt;code&gt;A&lt;/code&gt; , если это необходимо.</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">Если , например, все индексы &lt;code&gt;I_k&lt;/code&gt; являются векторами, то форма &lt;code&gt;X&lt;/code&gt; будет &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; с местоположением &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; из &lt;code&gt;X&lt;/code&gt; , содержащий значение &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">Если все аргументы являются скалярами или нулевыми массивами,то возвращается развернутый скаляр.</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">Если все индексы скаляры, то результат &lt;code&gt;X&lt;/code&gt; представляет собой один элемент из массива &lt;code&gt;A&lt;/code&gt; . В противном случае &lt;code&gt;X&lt;/code&gt; - это массив с тем же числом измерений, что и сумма размерностей всех индексов.</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">Если все эти проверки проходят, пары &amp;laquo;сообщение&amp;raquo; и &amp;laquo;ключ-значение&amp;raquo; полностью оцениваются и передаются в текущий &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt; через функцию Logging.handle_message . &lt;code&gt;handle_message()&lt;/code&gt; может выполнять дополнительную фильтрацию по мере необходимости и отображать событие на экране, сохранять его в файл и т. д.</target>
        </trans-unit>
        <trans-unit id="80169baf9571e6bf174d6f8272d7aa9246651030" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Logging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">Если &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; функция &lt;code&gt;init&lt;/code&gt; типа initfn (S :: SharedArray) , она вызывается для всех участвующих рабочих процессов .</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">Если &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; функция &lt;code&gt;init&lt;/code&gt; с подписью initfn (S :: SharedArray) , она вызывается для всех участвующих рабочих процессов . Вы можете указать, что каждый рабочий запускает функцию &lt;code&gt;init&lt;/code&gt; в отдельной части массива, тем самым распараллеливая инициализацию.</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">Если массив eltype Ptr &lt;code&gt;Ptr{T}&lt;/code&gt; передается как аргумент &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; , Base.cconvert сначала попытается сделать копию массива с &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; при этом каждый элемент будет заменен его версией Base.cconvert . Это позволяет, например, передать массив указателей &lt;code&gt;argv&lt;/code&gt; типа &lt;code&gt;Vector{String}&lt;/code&gt; аргументу типа &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">Если возникают какие-либо конфликты, которые не могут быть разрешены автоматически, перебазирование будет прервано, оставляя репозиторий и рабочее дерево в исходном состоянии, и функция выдаст &lt;code&gt;GitError&lt;/code&gt; . Это примерно эквивалентно следующему оператору командной строки:</target>
        </trans-unit>
        <trans-unit id="cb2726b6f11cf6d744cc2e0de08cc88e0caae92f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">Если какой-либо индекс &lt;code&gt;I_k&lt;/code&gt; выбирает более одного местоположения, то правая сторона &lt;code&gt;X&lt;/code&gt; должна быть массивом той же формы, что и результат индексации &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; или вектором с тем же количеством элементов. , Значение в &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; из &lt;code&gt;A&lt;/code&gt; перезаписывается значением &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; , при необходимости преобразовывая. Оператор поэлементного присваивания &lt;code&gt;.=&lt;/code&gt; Может использоваться для &lt;a href=&quot;#Broadcasting-1&quot;&gt;широковещательной рассылки &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; по выбранным местоположениям:</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">Если определен какой-либо метод внутреннего конструктора, метод конструктора по умолчанию не предоставляется: предполагается, что вы предоставили себе все необходимые внутренние конструкторы. Конструктор по умолчанию эквивалентен написанию собственного метода внутреннего конструктора, который принимает все поля объекта в качестве параметров (ограничивается правильным типом, если соответствующее поле имеет тип) и передает их &lt;code&gt;new&lt;/code&gt; , возвращая полученный объект:</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">Если любой из этих результатов завершится успешно, путь к точке входа в исходный код будет либо этим результатом, либо относительным путем от этого результата плюс &lt;code&gt;src/X.jl&lt;/code&gt; ; в противном случае отображение пути для &lt;code&gt;uuid&lt;/code&gt; отсутствует . При загрузке &lt;code&gt;X&lt;/code&gt; , если путь к исходному коду не найден, поиск завершится неудачно, и пользователю может быть предложено установить соответствующую версию пакета или предпринять другие корректирующие действия (например, объявить &lt;code&gt;X&lt;/code&gt; как зависимость).</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">Если массив содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, результат также будет &lt;code&gt;NaN&lt;/code&gt; или &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; имеет приоритет, если массив содержит оба). Используйте &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; функцию , чтобы опустить &lt;code&gt;missing&lt;/code&gt; данные и вычислить стандартное отклонение , не являющихся пропущенными значениями.</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">Если массив содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, результат также будет &lt;code&gt;NaN&lt;/code&gt; или &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; имеет приоритет, если массив содержит оба). Используйте &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; функцию , чтобы опустить &lt;code&gt;missing&lt;/code&gt; данные и вычислить дисперсию , не являющихся пропущенными значениями.</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">Если хотя бы один аргумент-кортеж,а все остальные-скаляры или нулевые массивы,то он возвращает кортеж.</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">Если вызывается с необязательным аргументом &lt;code&gt;stream&lt;/code&gt; , возвращает сам &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">Если захваченные переменные используются в критическом с точки зрения производительности разделе кода,то следующие советы помогут убедиться в том,что их использование является работоспособным.Во-первых,если известно,что захваченная переменная не изменяет своего типа,то она может быть объявлена явно с примечанием типа (на переменной,а не на правой стороне):</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">При указании типов полей происходит преобразование аргументов.В противном случае типы аргументов используются напрямую.</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">Если вместо этого вы хотите специализироваться на целевом типе &lt;code&gt;DestType&lt;/code&gt; , не специализируясь на &lt;code&gt;DestStyle&lt;/code&gt; , вам следует определить метод со следующей сигнатурой:</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">Если у него нет файла проекта, он может импортировать любой пакет верхнего уровня, то есть те же самые пакеты, которые могут быть загружены в &lt;code&gt;Main&lt;/code&gt; или REPL.</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">Если в нем есть запись &lt;code&gt;git-tree-sha1&lt;/code&gt; , вычислите детерминированную хеш-функцию &lt;code&gt;uuid&lt;/code&gt; и &lt;code&gt;git-tree-sha1&lt;/code&gt; - назовите ее &lt;code&gt;slug&lt;/code&gt; - и найдите каталог с именем &lt;code&gt;packages/X/$slug&lt;/code&gt; в каждом каталоге в глобальном массиве Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; , Используйте первый такой каталог, который существует.</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">Если у него есть запись &lt;code&gt;path&lt;/code&gt; , используйте этот путь (относительно каталога, содержащего файл манифеста).</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">Если у него есть файл проекта, он может импортировать только те пакеты, которые указаны в разделе &lt;code&gt;[deps]&lt;/code&gt; файла проекта.</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">Если требуется удерживать указатель на переменную между функциями (или областями действия блока), то использовать &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; невозможно . В этом случае необходимо создать и сохранить ссылку на переменную в глобальной области видимости Julia. Один простой способ добиться этого - использовать глобальный &lt;code&gt;IdDict&lt;/code&gt; , который будет содержать ссылки, избегая освобождения сборщиком мусора . Однако этот метод будет правильно работать только с изменяемыми типами.</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">Если это &lt;code&gt;n&lt;/code&gt; - й раз, когда &lt;code&gt;jl_gc_collect()&lt;/code&gt; , и &lt;code&gt;n&lt;/code&gt; принадлежит арифметической последовательности, представленной &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; , то печатаются подсчеты количества вызовов &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; и &lt;code&gt;maybe_collect()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">Если &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; был вызван &lt;code&gt;n&lt;/code&gt; - й раз , и &lt;code&gt;n&lt;/code&gt; принадлежит арифметической последовательности, представленной &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; , сборка мусора выполняется принудительно.</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">Если это &lt;code&gt;n&lt;/code&gt; - й раз, когда &lt;code&gt;maybe_collect()&lt;/code&gt; , и &lt;code&gt;n&lt;/code&gt; принадлежит арифметической последовательности, представленной &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; , то сборка мусора выполняется принудительно.</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Если ключевое слово &lt;code&gt;supertypes&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , а также возвращать аргументы с родительским типом &lt;code&gt;typ&lt;/code&gt; , за исключением типа &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">Если вас беспокоит использование памяти, вы всегда можете заменить объекты на те, которые потребляют меньше памяти. Например, если &lt;code&gt;A&lt;/code&gt; - это массив размером в гигабайт, который вам больше не нужен, вы можете освободить память с помощью &lt;code&gt;A = nothing&lt;/code&gt; . Память будет освобождена при следующем запуске сборщика мусора; вы можете заставить это произойти с помощью &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt; . Более того, попытка использовать &lt;code&gt;A&lt;/code&gt; , скорее всего, приведет к ошибке, потому что большинство методов не определены для типа &lt;code&gt;Nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">Если большая часть времени выполнения уходит на выполнение определенной строки кода, эта строка будет часто отображаться в наборе всех трассировок. Другими словами, &amp;laquo;стоимость&amp;raquo; данной строки - или на самом деле стоимость последовательности вызовов функций до этой строки включительно - пропорциональна тому, как часто она появляется в наборе всех трассировок.</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">При необходимости можно выбрать алгоритм сортировки:</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">Если аргумент &lt;code&gt;type&lt;/code&gt; не указан, по умолчанию используется &lt;code&gt;Vector{UInt8}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если аргумент не передан, задача блокируется на неопределенный период. Задача может быть перезапущена только явным вызовом функции &lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">Если пользовательский тип набора тестов не указан, по умолчанию создается &lt;code&gt;DefaultTestSet&lt;/code&gt; . &lt;code&gt;DefaultTestSet&lt;/code&gt; записывает все результаты и, если есть какие-либо &lt;code&gt;Fail&lt;/code&gt; s или &lt;code&gt;Error&lt;/code&gt; s, генерирует исключение в конце набора тестов верхнего уровня (не вложенного) вместе со сводкой результатов теста.</target>
        </trans-unit>
        <trans-unit id="9b7b804c01f85b077652b971d063a65bcf5b1f8e" translate="yes" xml:space="preserve">
          <source>If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is invoked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Если это возможно, &lt;code&gt;one(x)&lt;/code&gt; возвращает значение того же типа, что и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;one(T)&lt;/code&gt; возвращает значение типа &lt;code&gt;T&lt;/code&gt; . Однако это может быть не так для типов, представляющих размерные количества (например, время в днях), поскольку мультипликативная идентичность должна быть безразмерной. В этом случае &lt;code&gt;one(x)&lt;/code&gt; должен возвращать значение идентичности той же точности (и формы для матриц), что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">Если задана строка, начинающаяся с подстроки &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; учета регистра , то вращающиеся потоки никогда не спят. В противном случае &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; интерпретируется как 64-битное целое число без знака ( &lt;code&gt;uint64_t&lt;/code&gt; ) и дает в наносекундах количество времени, по истечении которого вращающиеся потоки должны спать.</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">Если установлено любое значение, кроме &lt;code&gt;0&lt;/code&gt; , то политика потоков Джулии согласуется с работой на выделенной машине: главный поток находится на процессе 0, а потоки аффинитизированы. В противном случае Джулия позволяет операционной системе обрабатывать политику потоков.</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">Если установлено любое значение, кроме &lt;code&gt;0&lt;/code&gt; , то сборщик мусора Julia никогда не выполняет &amp;laquo;быстрые очистки&amp;raquo; памяти.</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">Если установлено любое значение, кроме &lt;code&gt;0&lt;/code&gt; , тогда сборщик мусора Julia будет ждать подключения отладчика вместо прерывания при возникновении критической ошибки.</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">Если установлено любое значение, кроме &lt;code&gt;0&lt;/code&gt; , компилятор создаст и зарегистрирует прослушиватель событий для профилирования точно в срок (JIT).</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если установлено, то Джулия печатает подробную информацию о кэше в процессе загрузки &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Если установлено, эти переменные среды принимают строки, которые необязательно начинаются с символа &lt;code&gt;'r'&lt;/code&gt; , за которым следует строковая интерполяция списка из трех 64-разрядных целых чисел со &lt;code&gt;int64_t&lt;/code&gt; ( int64_t ). Эта тройка целых чисел &lt;code&gt;a:b:c&lt;/code&gt; представляет собой арифметическую последовательность &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a + b&lt;/code&gt; , &lt;code&gt;a + 2*b&lt;/code&gt; , ... &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; окружения JULIA_DEPOT_PATH уже установлена, к ее старому значению будет добавлено &lt;code&gt;/foo/bar&lt;/code&gt; . С другой стороны, если &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; не установлен, тогда он будет установлен в &lt;code&gt;/foo/bar:&lt;/code&gt; что приведет к добавлению &lt;code&gt;/foo/bar&lt;/code&gt; к пути депо по умолчанию. Если для &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; задана пустая строка, она расширяется до пустого &lt;code&gt;DEPOT_PATH&lt;/code&gt; массив. Другими словами, пустая строка интерпретируется как массив с нулевым элементом, а не как массив с одним элементом пустой строки. Это поведение было выбрано так, чтобы можно было установить пустой путь депо через переменную окружения. Если вы хотите путь к депо по умолчанию, либо снято с охраной переменным окружения или если оно должно иметь значение, установите его в строку &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">Если &lt;code&gt;JULIA_DIR&lt;/code&gt; среды JULIA_DIR не была настроена, добавьте ее с помощью панели &amp;laquo;Система&amp;raquo; перед запуском Visual Studio. &lt;code&gt;bin&lt;/code&gt; папка под JULIA_DIR должна быть системной переменной PATH.</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; окружения JULIA_LOAD_PATH уже установлена, к ее старому значению будет добавлено &lt;code&gt;/foo/bar&lt;/code&gt; . С другой стороны, если &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; не установлен, тогда он будет установлен в &lt;code&gt;/foo/bar:&lt;/code&gt; который расширится до значения &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; . Если для &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; задана пустая строка, она расширяется до пустой &lt;code&gt;LOAD_PATH&lt;/code&gt; массив. Другими словами, пустая строка интерпретируется как массив с нулевым элементом, а не как массив с одним элементом пустой строки. Такое поведение было выбрано таким образом, чтобы можно было установить пустой путь загрузки через переменную среды. Если вы хотите путь нагрузки по умолчанию, либо снято с охраной переменным окружения или если оно должно иметь значение, установите его в строку &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Если указан аргумент ключевого слова &lt;code&gt;digits&lt;/code&gt; , он округляется до указанного числа цифр после десятичного знака (или до него, если оно отрицательное) в базовой &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">Если ключевое слово &lt;code&gt;optimize&lt;/code&gt; не задано, код будет показан перед оптимизацией LLVM. Все метаданные и вызовы dbg. * Удаляются из напечатанного битового кода. Для полного IR установите для ключевого слова &lt;code&gt;raw&lt;/code&gt; значение true. Чтобы выгрузить весь модуль, который инкапсулирует функцию (с объявлениями), установите для &lt;code&gt;dump_module&lt;/code&gt; слова dump_module значение true. Аргумент &lt;code&gt;debuginfo&lt;/code&gt; слова debuginfo может быть одним из источников (по умолчанию) или отсутствовать, чтобы указать степень детализации комментариев кода.</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;sigdigits&lt;/code&gt; аргумент ключевого слова sigdigits , он округляется до указанного количества значащих цифр в базовой &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">Если оболочка C никогда не ожидает, что пользователь будет передавать указатели в память, управляемую Джулией, то также допустимо использование &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; для сигнатуры метода оболочки и аналогичным образом в &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">Если исходный код приведенного выше примера сохранен в файле &lt;code&gt;embed_example.c&lt;/code&gt; , то следующая команда скомпилирует его в работающую программу в Linux и Windows (среда MSYS2) или, если в OS / X, замените &lt;code&gt;clang&lt;/code&gt; на &lt;code&gt;gcc&lt;/code&gt; .:</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">Если вышеуказанное не соответствует действительности, и файл проекта имеет соответствующий файл манифеста, а манифест содержит строфу, соответствующую &lt;code&gt;uuid&lt;/code&gt; , тогда:</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">Если псевдоним задокументирован, а не настоящее определение, тогда система документации ( режим &lt;code&gt;?&lt;/code&gt; ) Не будет возвращать строку документации, прикрепленную к псевдониму, при поиске реального определения.</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">Если аргумент &lt;code&gt;Future&lt;/code&gt; принадлежит другому узлу, этот вызов будет заблокирован для ожидания ответа. Вместо этого рекомендуется дождаться &lt;code&gt;rr&lt;/code&gt; в отдельной задаче или использовать локальный &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; в качестве прокси:</target>
        </trans-unit>
        <trans-unit id="a730ef6e1a231827c433cc4447592ea8e3ba9efc" translate="yes" xml:space="preserve">
          <source>If the arguments inside the square brackets are separated by semicolons (&lt;code&gt;;&lt;/code&gt;) or newlines instead of commas, then their contents are &lt;em&gt;vertically concatenated&lt;/em&gt; together instead of the arguments being used as elements themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">Если условие не может быть оценено из-за того, что было сгенерировано исключение, что происходит в этом случае, потому что &lt;code&gt;length&lt;/code&gt; не определена для символов, возвращается объект &lt;code&gt;Error&lt;/code&gt; и генерируется исключение:</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">Если выражение условие &lt;code&gt;x &amp;lt; y&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , то соответствующий блок оценки; в противном случае вычисляется выражение условия &lt;code&gt;x &amp;gt; y&lt;/code&gt; , и если оно &lt;code&gt;true&lt;/code&gt; , оценивается соответствующий блок; если ни одно из выражений не является истинным, оценивается блок &lt;code&gt;else&lt;/code&gt; . Вот он в действии:</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">Если выражение условия &lt;code&gt;x &amp;lt; y&lt;/code&gt; истинно, то оценивается соответствующий блок; в противном случае вычисляется выражение условия &lt;code&gt;x &amp;gt; y&lt;/code&gt; , и если оно истинно, оценивается соответствующий блок; если ни одно из выражений не является истинным, оценивается блок &lt;code&gt;else&lt;/code&gt; . В &lt;code&gt;elseif&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; блоки не являются обязательными, а также многие &lt;code&gt;elseif&lt;/code&gt; блоков , как желательно могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">Если условие ложно, то возвращается &lt;code&gt;Fail&lt;/code&gt; и выдается исключение:</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">Если условие истинно, возвращается &lt;code&gt;Pass&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">Если выражение &lt;code&gt;x &amp;lt; y&lt;/code&gt; истинно, все выражение тернарного оператора оценивается как строка &lt;code&gt;&quot;less than&quot;&lt;/code&gt; а в противном случае - как строка &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; . Исходный трехсторонний пример требует объединения нескольких использований тернарного оператора:</target>
        </trans-unit>
        <trans-unit id="07cadc79598faa1c956be711a85436f8d736e63e" translate="yes" xml:space="preserve">
          <source>If the file does not exist a new file is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">Если первый аргумент - одно целое число &lt;code&gt;n&lt;/code&gt; , то предполагается, что все строки блока имеют &lt;code&gt;n&lt;/code&gt; столбцов блока.</target>
        </trans-unit>
        <trans-unit id="87ae95240cbc769b0a9964dbc95f1267c9ef783f" translate="yes" xml:space="preserve">
          <source>If the index vector &lt;code&gt;ix&lt;/code&gt; is initialized with the indices of &lt;code&gt;v&lt;/code&gt; (or a permutation thereof), &lt;code&gt;initialized&lt;/code&gt; should be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Если входные данные содержат &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, верните &lt;code&gt;missing&lt;/code&gt; если все не пропущенные значения являются &lt;code&gt;false&lt;/code&gt; (или, что эквивалентно, если входные данные не содержат &lt;code&gt;true&lt;/code&gt; значения), следуя &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначной логике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Если входные данные содержат &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, верните &lt;code&gt;missing&lt;/code&gt; если все не пропущенные значения &lt;code&gt;true&lt;/code&gt; (или, что эквивалентно, если входные данные не содержат &lt;code&gt;false&lt;/code&gt; значений), следуя &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначной логике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Если входные данные содержат &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, верните &lt;code&gt;missing&lt;/code&gt; если все не пропущенные значения являются &lt;code&gt;false&lt;/code&gt; (или, что эквивалентно, если входные данные не содержат &lt;code&gt;true&lt;/code&gt; значения), следуя &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначной логике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Если входные данные содержат &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения, верните &lt;code&gt;missing&lt;/code&gt; если все не пропущенные значения &lt;code&gt;true&lt;/code&gt; (или, что эквивалентно, если входные данные не содержат &lt;code&gt;false&lt;/code&gt; значений), следуя &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначной логике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">Если программе julia требуется доступ к символам из основного исполняемого файла, может потребоваться добавить флаг компоновщика &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; во время компиляции в Linux в дополнение к &lt;code&gt;julia-config.jl&lt;/code&gt; , сгенерированным julia-config.jl, описанным ниже. В этом нет необходимости при компиляции разделяемой библиотеки.</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">Если аргумент ключевого слова &lt;code&gt;parallel&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;peakflops&lt;/code&gt; выполняется параллельно на всех рабочих процессорах. Возвращается частота ошибок всего параллельного компьютера. При параллельной работе используется только 1 поток BLAS. Аргумент &lt;code&gt;n&lt;/code&gt; по- прежнему относится к размеру проблемы, которая решается на каждом процессоре.</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">Если последняя составляющая пути содержит точку,разделите путь на все до точки,а также на все,включая и после точки.В противном случае верните кортеж аргумента немодифицированный и пустую строку.</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">Если библиотеку не удается найти, этот метод выдает ошибку, если только для ключевого аргумента &lt;code&gt;throw_error&lt;/code&gt; не задано значение &lt;code&gt;false&lt;/code&gt; , и в этом случае этот метод &lt;code&gt;nothing&lt;/code&gt; возвращает .</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">Если главному процессу не удается установить соединение с вновь запущенным исполнителем в течение 60,0 секунд, рабочий рассматривает это как фатальную ситуацию и завершает работу. Этим таймаутом можно управлять с помощью переменной окружения &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; . Значение &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; в главном процессе указывает количество секунд, в течение которых новый запущенный рабочий процесс ожидает установления соединения.</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">Если память уже принадлежит Джулии или относится к типу &lt;code&gt;isbits&lt;/code&gt; и заведомо не имеет значения NULL:</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">Если память принадлежит С:</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">Если числитель и знаменатель рационального имеют общие факторы,то они сводятся к нижним терминам таким образом,что знаменатель является неотрицательным:</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">Если указан необязательный вектор собственных значений собственных &lt;code&gt;eigvals&lt;/code&gt; , &lt;code&gt;eigvecs&lt;/code&gt; возвращает конкретные соответствующие собственные векторы.</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">Если интересующий указатель представляет собой массив простых данных (примитивный тип или неизменяемая структура), функция &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; может быть более полезной. Последний параметр должен иметь значение true, если Джулия должна &amp;laquo;стать владельцем&amp;raquo; базового буфера и не вызывать &lt;code&gt;free(ptr)&lt;/code&gt; когда возвращаемый объект &lt;code&gt;Array&lt;/code&gt; завершен. Если &lt;code&gt;own&lt;/code&gt; параметр опущен или равен false, вызывающая сторона должна обеспечить существование буфера до тех пор, пока не будет завершен весь доступ.</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">Если файл проекта в каталоге совпадает с &lt;code&gt;uuid&lt;/code&gt; и именем &lt;code&gt;X&lt;/code&gt; , тогда либо:</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">Если регулярное выражение не соответствует заданной строке, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; возвращает - специальное значение, которое ничего не выводит в интерактивном приглашении. Помимо отсутствия печати, это вполне нормальное значение, и вы можете проверить его программно:</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">Если бы тип был объявлен &lt;code&gt;mutable&lt;/code&gt; , вы могли бы напрямую изменить значения поля, чтобы нарушить этот инвариант. Конечно, возиться с внутренним устройством объекта без приглашения - плохая практика. Вы (или кто-то другой) также можете предоставить дополнительные методы внешнего конструктора в любой более поздний момент, но после объявления типа невозможно добавить дополнительные методы внутреннего конструктора. Поскольку методы внешнего конструктора могут создавать объекты только путем вызова других методов конструктора, в конечном итоге для создания объекта должен быть вызван некоторый внутренний конструктор. Это гарантирует, что все объекты объявленного типа должны появиться в результате вызова одного из методов внутреннего конструктора, предоставленных с типом, тем самым обеспечивая некоторую степень принудительного исполнения инвариантов типа.</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">Если значение переменной среды начинается с символа &lt;code&gt;'r'&lt;/code&gt; , то интервал между событиями сборки мусора выбирается случайным образом.</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">Если переменная неизменяема, то она должна быть заключена в эквивалентный изменяемый контейнер или, предпочтительно, в &lt;code&gt;RefValue{Any}&lt;/code&gt; прежде чем она будет &lt;code&gt;IdDict&lt;/code&gt; в IdDict . В этом подходе контейнер должен быть создан или заполнен с помощью кода C, например, с помощью функции &lt;code&gt;jl_new_struct&lt;/code&gt; . Если контейнер создан &lt;code&gt;jl_call*&lt;/code&gt; , вам нужно будет перезагрузить указатель, который будет использоваться в коде C.</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">Если эти определения по умолчанию не нужны, вместо них можно определить модули с помощью ключевого слова &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt; (примечание: &lt;code&gt;Core&lt;/code&gt; все еще импортируется, как указано выше). В терминах &lt;code&gt;baremodule&lt;/code&gt; стандартный &lt;code&gt;module&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Если этот пример был переписаны , чтобы использовать &lt;code&gt;for&lt;/code&gt; ключевого слова для каждого переменного, то результат будет иным: второе и четвертое значение будет содержать &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">Если этот файл относится к устройству,то идентификатор устройства,к которому он относится</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">Если это рекурсивная блокировка,которая была получена ранее,декрементируйте внутренний счетчик и немедленно возвращайтесь.</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">Если все это сильно сбивает с толку, попробуйте прочитать &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&amp;laquo;Абсолютный минимум, который должен знать каждый разработчик программного обеспечения о Unicode и наборах символов&amp;raquo;&lt;/a&gt; . Это отличное введение в Unicode и UTF-8, которое может помочь устранить некоторую путаницу в этом вопросе.</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">Если не указано &lt;code&gt;rmprocs&lt;/code&gt; , rmprocs будет ждать, пока &lt;code&gt;pids&lt;/code&gt; будут удалены все запрошенные pid .</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">Если мы также хотим протестировать сообщения отладки, их необходимо включить с помощью &lt;code&gt;min_level&lt;/code&gt; слова min_level :</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">Если мы создадим &lt;code&gt;SharedArray&lt;/code&gt; и зададим время для этих функций, мы получим следующие результаты (с &lt;code&gt;julia -p 4&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">Если мы ожидаем, что при вычислении выражения &lt;em&gt;должно &lt;/em&gt; &lt;code&gt;@test_throws&lt;/code&gt; исключение, мы можем использовать @test_throws, чтобы проверить, что это происходит:</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">Если вместо этого мы передадим &lt;code&gt;x&lt;/code&gt; в качестве аргумента функции, она больше не будет выделять память (указанное ниже выделение связано с запуском макроса &lt;code&gt;@time&lt;/code&gt; в глобальной области видимости) и будет значительно быстрее после первого вызова:</target>
        </trans-unit>
        <trans-unit id="f2aae1a0bcfd34dce76c0f68b8969fc76cde279d" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">Если мы хотим, чтобы вместо этого он отображался как &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; , мы должны определить следующий метод для печати объекта в заданный выходной объект &lt;code&gt;io&lt;/code&gt; (представляющий файл, терминал, буфер и т.д.; см. &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Сеть и потоки&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">Если вы применяете &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; к другим объектам типа (или объектам не типа), возникает &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">Если вы определяете метод &quot;каскад&quot;,который поставляет значения по умолчанию,будьте осторожны при отказе от любых аргументов,которые соответствуют потенциальным значениям по умолчанию.Например,предположим,что вы пишете алгоритм цифровой фильтрации и у вас есть метод,который обрабатывает края сигнала,применяя подкладку:</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">Если вы определяете тип массива, который допускает нетрадиционную индексацию (индексы, начинающиеся не с 1), вам следует специализировать &lt;code&gt;axes&lt;/code&gt; . Вы должны также специализироваться &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; , так что &lt;code&gt;dims&lt;/code&gt; аргумент (обычно &lt;code&gt;Dims&lt;/code&gt; размер кортежи) может принимать &lt;code&gt;AbstractUnitRange&lt;/code&gt; объектов, возможно , диапазоны типы &lt;code&gt;Ind&lt;/code&gt; вашего собственного дизайна. Дополнительные сведения см. В разделе &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Массивы с настраиваемыми индексами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24ace472fa970e0efc7d5e99433a90005d823df2" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">Если вы когда-нибудь застряли, вы можете попросить помощи у &lt;code&gt;Pkg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">Если вы используете API Julia C на языке, который поддерживает исключения (например, Python, C #, C ++), имеет смысл &lt;code&gt;libjulia&lt;/code&gt; каждый вызов в libjulia с помощью функции, которая проверяет, было ли выбрано исключение, а затем повторно генерирует исключение в принимающий язык.</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">Если вы вызываете его в интерактивной сессии без назначения возвращаемого значения где-либо,вы увидите возвращаемый кортеж:</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">Если вы определяете оба стиля индексации для своего &lt;code&gt;AbstractArray&lt;/code&gt; , эту черту можно использовать для выбора наиболее производительного стиля индексации. Некоторые методы проверяют эту черту на своих входах и отправляют на разные алгоритмы в зависимости от наиболее эффективного шаблона доступа. В частности, &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; создает итератор, тип которого зависит от настройки этого трейта.</target>
        </trans-unit>
        <trans-unit id="9ff95da549c7d7e30f1529ab4e07584cdcd87231" translate="yes" xml:space="preserve">
          <source>If you define custom exception types, your &lt;code&gt;showerror&lt;/code&gt; method can support hints by calling &lt;a href=&quot;#Base.Experimental.show_error_hints&quot;&gt;&lt;code&gt;Experimental.show_error_hints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">Если вы изучите содержимое &lt;code&gt;hello.txt&lt;/code&gt; на этом этапе, вы заметите, что он пуст; на диск еще ничего не записано. Это связано с тем, что &lt;code&gt;IOStream&lt;/code&gt; должен быть закрыт до того, как запись будет фактически сброшена на диск:</target>
        </trans-unit>
        <trans-unit id="61d643164ec2351bd9d6fcf481fa957527066f53" translate="yes" xml:space="preserve">
          <source>If you have a matrix &lt;code&gt;A&lt;/code&gt; that is slightly non-Hermitian due to roundoff errors in its construction, wrap it in &lt;code&gt;Hermitian(A)&lt;/code&gt; before passing it to &lt;code&gt;cholesky&lt;/code&gt; in order to treat it as perfectly Hermitian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">Если у вас есть тип,использующий нативный указатель:</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Если у вас есть код, который вы хотите выполнять при каждом запуске Julia, вы можете поместить его в &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">Если у вас есть данные в формате CSC из другого приложения или библиотеки и вы хотите импортировать их в Julia, убедитесь, что вы используете индексирование на основе 1. Индексы строк в каждом столбце необходимо отсортировать. Если ваш объект &lt;code&gt;SparseMatrixCSC&lt;/code&gt; содержит несортированные индексы строк, один из быстрых способов их отсортировать - выполнить двойное транспонирование.</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">Если вы интерполируете массив как часть слова оболочки, Джулия эмулирует генерацию аргумента оболочки &lt;code&gt;{a,b,c}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">Если вы знаете , что модуль &lt;em&gt;не&lt;/em&gt; безопасно прекомпилировать ваш модуль (например, для одной из причин , описанных ниже), вы должны поставить &lt;code&gt;__precompile__(false)&lt;/code&gt; в файле модуля (обычно помещается в верхней части). Это приведет к тому, что &lt;code&gt;Base.compilecache&lt;/code&gt; выдаст ошибку и вызовет &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; для загрузки его непосредственно в текущий процесс и пропуска предварительной компиляции и кеширования. Это также предотвращает импорт модуля любым другим предварительно скомпилированным модулем.</target>
        </trans-unit>
        <trans-unit id="8e09fd6adcf3b546269be2b7ff41cc7243507fad" translate="yes" xml:space="preserve">
          <source>If you need a reference to the created task, pass a &lt;code&gt;Ref{Task}&lt;/code&gt; object via the keyword argument &lt;code&gt;taskref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">Если вам нужно диспетчеризация по нескольким аргументам,и существует много откатов с слишком большим количеством комбинаций,чтобы сделать практическим определение всех возможных вариантов,то подумайте о введении &quot;каскада имен&quot;,где (например)вы диспетчеризируете по первому аргументу,а затем вызываете внутренний метод:</target>
        </trans-unit>
        <trans-unit id="5c6a0fa6b882b862c349ff5b92d17fa1f5f4c109" translate="yes" xml:space="preserve">
          <source>If you need to guarantee exact reproducibility of random data, it is advisable to simply &lt;em&gt;save the data&lt;/em&gt; (e.g. as a supplementary attachment in a scientific publication). (You can also, of course, specify a particular Julia version and package manifest, especially if you require bit reproducibility.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">Если вам нужно получить действительные индексы для строки, вы можете использовать функции &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt; для увеличения / уменьшения до следующего / предыдущего допустимого индекса, как упомянуто выше. Вы также можете использовать функцию &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; для перебора допустимых индексов символов:</target>
        </trans-unit>
        <trans-unit id="ffe59bec712e7149856d034145a9690621f691b0" translate="yes" xml:space="preserve">
          <source>If you need to solve many systems of the form &lt;code&gt;(A+&amp;mu;I)x = b&lt;/code&gt; for the same &lt;code&gt;A&lt;/code&gt; and different &lt;code&gt;&amp;mu;&lt;/code&gt;, it might be beneficial to first compute the Hessenberg factorization &lt;code&gt;F&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; via the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function. Given &lt;code&gt;F&lt;/code&gt;, Julia employs an efficient algorithm for &lt;code&gt;(F+&amp;mu;*I) \ b&lt;/code&gt; (equivalent to &lt;code&gt;(A+&amp;mu;*I)x \ b&lt;/code&gt;) and related operations like determinants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c200e4c125ec6f24cad360d6dae92d524d5333" translate="yes" xml:space="preserve">
          <source>If you prefer to use the environment variable you can set it as follows in Bash (Linux/macOS):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e449fc3b5ae85ea55ddb2c14a81e3b450b101b1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;multiplex=true&lt;/code&gt; as an option to &lt;code&gt;addprocs&lt;/code&gt;, SSH multiplexing is used to create a tunnel between the master and workers. If you have configured SSH multiplexing on your own and the connection has already been established, SSH multiplexing is used regardless of &lt;code&gt;multiplex&lt;/code&gt; option. If multiplexing is enabled, forwarding is set by using the existing connection (&lt;code&gt;-O forward&lt;/code&gt; option in ssh). This is beneficial if your servers require password authentication; you can avoid authentication in Julia by logging in to the server ahead of &lt;code&gt;addprocs&lt;/code&gt;. The control socket will be located at &lt;code&gt;~/.ssh/julia-%r@%h:%p&lt;/code&gt; during the session unless the existing multiplexing connection is used. Note that bandwidth may be limited if you create multiple processes on a node and enable multiplexing, because in that case processes share a single multiplexing TCP connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">Если вы укажете &lt;code&gt;branch&lt;/code&gt; , это необходимо сделать в формате ссылки, поскольку строка будет преобразована в &lt;code&gt;GitReference&lt;/code&gt; . Например, если вы хотите объединить ветку &lt;code&gt;branch_a&lt;/code&gt; , вы должны вызвать &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">Если вы предоставите более одного аргумента &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;eachindex&lt;/code&gt; создаст итерируемый объект, который будет быстрым для всех аргументов ( &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; ,&lt;/a&gt; если все входные данные имеют быструю линейную индексацию, в противном случае - &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; ). Если массивы имеют разные размеры и / или размерности, &lt;code&gt;eachindex&lt;/code&gt; будет возвращать итерацию, охватывающую наибольший диапазон по каждому измерению.</target>
        </trans-unit>
        <trans-unit id="f56a6f95645242ddef63028fd0be36ad60f0ec75" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad751359c9250bca5bb370e9aaa6dde27fda5aad" translate="yes" xml:space="preserve">
          <source>If you try this in the REPL, you will see that &lt;code&gt;schedule&lt;/code&gt; returns immediately. That is because it simply adds &lt;code&gt;t&lt;/code&gt; to an internal queue of tasks to run. Then, the REPL will print the next prompt and wait for more input. Waiting for keyboard input provides an opportunity for other tasks to run, so at that point &lt;code&gt;t&lt;/code&gt; will start. &lt;code&gt;t&lt;/code&gt; calls &lt;a href=&quot;../../base/parallel/index#Base.sleep&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt;, which sets a timer and stops execution. If other tasks have been scheduled, they could run then. After five seconds, the timer fires and restarts &lt;code&gt;t&lt;/code&gt;, and you will see &lt;code&gt;done&lt;/code&gt; printed. &lt;code&gt;t&lt;/code&gt; is then finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вам нужна величина того же типа, что и &lt;code&gt;x&lt;/code&gt; , или типа &lt;code&gt;T&lt;/code&gt; , даже если &lt;code&gt;x&lt;/code&gt; размерен, используйте вместо этого &lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">Если вы хотите &lt;em&gt;избежать&lt;/em&gt; добавления точек для выбранных вызовов функций в &lt;code&gt;expr&lt;/code&gt; , объедините эти вызовы функций с помощью &lt;code&gt;$&lt;/code&gt; . Например, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; эквивалентен &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (без точки для &lt;code&gt;sort&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">Если вы хотите извлечь символ из строки,вы проиндексируете его:</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">Если вы хотите прочитать вывод внешней команды, вместо этого можно использовать &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9ee9527d2c41ad82a10f035e6e19f07b44c36b95" translate="yes" xml:space="preserve">
          <source>If you want to test that some particular messages are generated while ignoring the rest, you can set the keyword &lt;code&gt;match_mode=:any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">Если вы хотите использовать протоколирование в качестве аудиторского следа,вам следует отключить его для вашего типа регистратора.</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">Если вы хотите записать в файл, вы можете открыть его с помощью флага записи ( &lt;code&gt;&quot;w&quot;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">Если бы вы профилировали &lt;code&gt;dumbsum3&lt;/code&gt; , и во время выполнения &lt;code&gt;dumbsum(1)&lt;/code&gt; была сделана обратная трассировка, обратная трассировка выглядела бы так:</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">Если вы хотите специализироваться на определенном стиле &lt;code&gt;DestStyle&lt;/code&gt; , определите метод для</target>
        </trans-unit>
        <trans-unit id="9416eec2408335a70a9403f87954e9d92bc5beb6" translate="yes" xml:space="preserve">
          <source>If you would like to define your own block, for example a &lt;code&gt;terminology&lt;/code&gt; block used like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">Если вы пишете собственный тип &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; , вы можете указать, что он имеет быструю линейную индексацию, используя</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">Если вы пишете общий код,который обрабатывает числа,и от которого можно ожидать,что он будет работать с множеством аргументов числового типа,попробуйте использовать литералы числового типа,которые будут как можно меньше влиять на аргументы посредством продвижения по службе.</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">Если ваш тип массива имеет фиксированные требования к размерности, вам следует подтип &lt;code&gt;AbstractArrayStyle&lt;/code&gt; . Например, код разреженного массива имеет следующие определения:</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">Если в вашем коде есть рекурсия,то одной из потенциально путаных точек является то,что строка в &quot;дочерней&quot; функции может накапливать больше отсчетов,чем суммарных обратных ссылок.Рассмотрим следующие определения функций:</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">Если ваша функция возвращает &lt;code&gt;Array&lt;/code&gt; или какой-либо другой сложный тип, возможно, ей придется выделить память. К сожалению, зачастую выделение памяти и его обратное, сборка мусора, являются существенными узкими местами.</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">Если же , с другой стороны, Юлька загрузок &lt;em&gt;другого &lt;/em&gt; &lt;code&gt;Priv&lt;/code&gt; -пакет один с UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; -это находит свою строфу в манифесте, вижу , что оно &lt;em&gt;не&lt;/em&gt; имеет &lt;code&gt;path&lt;/code&gt; запись, но что это есть запись &lt;code&gt;git-tree-sha1&lt;/code&gt; . Затем он вычисляет &lt;code&gt;slug&lt;/code&gt; для этой пары UUID / SHA-1, которым является &lt;code&gt;HDkrT&lt;/code&gt; (точные детали этого вычисления не важны, но они согласованы и детерминированы). Это означает , что путь к этому &lt;code&gt;Priv&lt;/code&gt; пакет будет &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; в одном из пакетов депо. Пусть содержимое &lt;code&gt;DEPOT_PATH&lt;/code&gt; является &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; , тогда Юлия просмотрит следующие пути, чтобы узнать, существуют ли они:</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">Изображение</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">Изображение или примерно равное</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Немедленно запустить финализаторы, зарегистрированные для объекта &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">Непреложные составные типы без полей-это синглоны,может быть только один экземпляр таких типов:</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict-это словарь,реализованный в виде незыблемого связанного списка,который оптимален для маленьких словарей,построенных по множеству отдельных вставок Обратите внимание,что невозможно удалить значение,хотя его можно частично переопределить и скрыть,вставив новое значение с тем же ключом.</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">Реализуется менеджерами кластера с использованием настраиваемых транспортов. Он должен установить логическое соединение с воркером с идентификатором &lt;code&gt;pid&lt;/code&gt; , указанным в &lt;code&gt;config&lt;/code&gt; , и вернуть пару объектов &lt;code&gt;IO&lt;/code&gt; . Сообщения от &lt;code&gt;pid&lt;/code&gt; к текущему процессу будут считываться из &lt;code&gt;instrm&lt;/code&gt; , а сообщения, которые будут отправлены на &lt;code&gt;pid&lt;/code&gt; , будут записаны в &lt;code&gt;outstrm&lt;/code&gt; . Реализация настраиваемого транспорта должна гарантировать, что сообщения доставляются и принимаются полностью и в порядке. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; устанавливает соединения сокетов TCP / IP между рабочими.</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">Реализуется менеджерами кластера. Для каждого работника Юлия запущенного с помощью этой функции, она должна присоединять &lt;code&gt;WorkerConfig&lt;/code&gt; запись в &lt;code&gt;launched&lt;/code&gt; и уведомить &lt;code&gt;launch_ntfy&lt;/code&gt; . Функция ДОЛЖНА завершиться после того, как все рабочие процессы, запрошенные &lt;code&gt;manager&lt;/code&gt; , будут запущены. &lt;code&gt;params&lt;/code&gt; - это словарь всех ключевых аргументов, с &lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; был вызван addprocs .</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Реализуется менеджерами кластера. Он вызывается в главном процессе &lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; . Это должно привести к выходу удаленного работника, указанного в &lt;code&gt;pid&lt;/code&gt; . &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; выполняет удаленный &lt;code&gt;exit()&lt;/code&gt; для &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">Реализуется менеджерами кластера. Он вызывается в главном процессе в течение жизни работника с соответствующими значениями &lt;code&gt;op&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d46cc8d098f423748bfcc369918df042e230bb1" translate="yes" xml:space="preserve">
          <source>Implicit names from identifiers and dot expressions are available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">командование импортом</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">В &lt;code&gt;MyModule&lt;/code&gt; выше MyModule мы хотели добавить метод к стандартной функции &lt;code&gt;show&lt;/code&gt; , поэтому нам пришлось написать &lt;code&gt;import Base.show&lt;/code&gt; . Функции, имена которых видны только при &lt;code&gt;using&lt;/code&gt; не могут быть расширены.</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">В &lt;em&gt;очень редких&lt;/em&gt; случаях это может иметь смысл для конструктора &lt;code&gt;T(x)&lt;/code&gt; , чтобы вернуть объект не типа &lt;code&gt;T&lt;/code&gt; . Это могло произойти, если тип оболочки является своим собственным инверсным (например, &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; ), или для поддержки старого синтаксиса вызова для обратной совместимости при реструктуризации библиотеки. Но &lt;code&gt;convert(T, x)&lt;/code&gt; всегда должен возвращать значение типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">В C ++ или Java, например, при вызове метода, такого как &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; , объект obj &quot;получает&quot; вызов метода и неявно передается методу через ключевое слово &lt;code&gt;this&lt;/code&gt; , а не как явный аргумент метода. , Когда текущий объект &lt;code&gt;this&lt;/code&gt; является получателем вызова метода, его можно вообще опустить, написав только &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; , подразумевая &lt;code&gt;this&lt;/code&gt; как получающий объект.</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">В C ++ по умолчанию используется статическая диспетчеризация, то есть вам необходимо аннотировать функцию как виртуальную, чтобы иметь динамическую диспетчеризацию. С другой стороны, в Julia каждый метод является &amp;laquo;виртуальным&amp;raquo; (хотя он более общий, поскольку методы отправляются для каждого типа аргумента, а не только для &lt;code&gt;this&lt;/code&gt; , с использованием правила наиболее точного объявления).</target>
        </trans-unit>
        <trans-unit id="848c2eb8261286f9fd639a07ac24e094cd08249a" translate="yes" xml:space="preserve">
          <source>In Julia &amp;le; 0.6, all global scopes did work like the current REPL: when &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; occurred in a loop (or &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, or &lt;code&gt;struct&lt;/code&gt; body) but outside of a function body (or &lt;code&gt;let&lt;/code&gt; block or comprehension), it was decided based on whether a global named &lt;code&gt;x&lt;/code&gt; was defined or not whether &lt;code&gt;x&lt;/code&gt; should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it's quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it's bad for programming &quot;at scale.&quot; When you see a small piece of code in one place like this, it's quite clear what's going on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">В Julia (как и в большинстве научных вычислений) операции плотной линейной алгебры основаны на &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;библиотеке LAPACK&lt;/a&gt; , которая, в свою очередь, построена на основе базовых строительных блоков линейной алгебры, известных как &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt; . Существуют высокооптимизированные реализации BLAS, доступные для любой компьютерной архитектуры, и иногда в высокопроизводительных программах линейной алгебры полезно вызывать функции BLAS напрямую.</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">В Julia 1.0 этот метод поддерживал только квадратную матрицу назначения.В Юлии 1.1.добавлена поддержка прямоугольной матрицы.</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">В Julia 1.0 значение по умолчанию &lt;code&gt;--project=@.&lt;/code&gt; опция не выполняла поиск файла &lt;code&gt;Project.toml&lt;/code&gt; в корневом каталоге репозитория Git . Начиная с версии Julia 1.1 и далее.</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">В Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; возвращает вектор &lt;code&gt;v&lt;/code&gt; с &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; а в Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">В Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; возвращает вектор &lt;code&gt;v&lt;/code&gt; с &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; а в Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f25573f2ef6b2638e0373e20cdd6eceb2e703331" translate="yes" xml:space="preserve">
          <source>In Julia 1.5 and above the number of threads can also be specified on startup using the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">В Julia &lt;code&gt;%&lt;/code&gt; - это оператор остатка, а в Python - это модуль.</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">В вызовах &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; кода Julia для внешних подпрограмм C обычные (не указатели) данные должны быть объявлены как данные типа &lt;code&gt;T&lt;/code&gt; внутри ccall , поскольку они передаются по значению. Для кода C, принимающего указатели, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; обычно следует использовать для типов входных аргументов, что позволяет использовать указатели на память, управляемую либо Julia, либо C посредством неявного вызова &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; . Напротив, указатели, возвращаемые вызываемой функцией C, должны быть объявлены как &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt; выходной тип Ptr {T} , отражая, что указанная память управляется только C. Указатели, содержащиеся в структурах C, должны быть представлены как поля типа &lt;code&gt;Ptr{T}&lt;/code&gt; внутри соответствующих структурных типов Julia, предназначенных для имитации внутренней структуры соответствующих структур C.</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">В вызовах обертывания кода Julia для внешних подпрограмм Fortran все входные аргументы должны быть объявлены как &lt;code&gt;Ref{T}&lt;/code&gt; тип Ref {T} , поскольку Fortran передает все переменные указателями в ячейки памяти. Возвращаемый тип должен быть либо &lt;code&gt;Cvoid&lt;/code&gt; для Фортрана подпрограмм, или &lt;code&gt;T&lt;/code&gt; для функций Фортрана возвращающихся типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">В Джулии каждый модуль имеет свой собственный глобальный охват/пространство имен,в то время как в MATLAB-только один глобальный охват.</target>
        </trans-unit>
        <trans-unit id="a3d6aa810b7eb985858c7d4e38c552636ecace4b" translate="yes" xml:space="preserve">
          <source>In Julia loops are fast, there is no need to write &quot;vectorized&quot; code for performance reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">В режиме Julia REPL поддерживает так называемую &lt;em&gt;вставку подсказок&lt;/em&gt; . Это активируется при вставке текста, который начинается с &lt;code&gt;julia&amp;gt;&lt;/code&gt; , в REPL. В этом случае анализируются только выражения, начинающиеся с &lt;code&gt;julia&amp;gt;&lt;/code&gt; , остальные удаляются. Это позволяет вставить фрагмент кода, скопированный из сеанса REPL, без необходимости удалять подсказки и выходные данные. Эта функция включена по умолчанию, но может быть отключена или включена по желанию с помощью &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; . Если он включен, вы можете попробовать его, вставив блок кода над этим абзацем прямо в REPL. Эта функция не работает в стандартной командной строке Windows из-за ее ограничений при обнаружении момента вставки.</target>
        </trans-unit>
        <trans-unit id="7129a6b15edfb73c2cd4cd30d7a70ed28691edca" translate="yes" xml:space="preserve">
          <source>In Julia the &lt;code&gt;@&lt;/code&gt; symbol refers to a macro, whereas in Python it refers to a decorator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">В Julia &lt;code&gt;&amp;lt;-&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; и &lt;code&gt;-&amp;gt;&lt;/code&gt; не являются операторами присваивания.</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">В Julia &lt;code&gt;...&lt;/code&gt; не используется для продолжения строк кода. Вместо этого неполные выражения автоматически переходят на следующую строку.</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">В Julia объекты &lt;code&gt;Ref&lt;/code&gt; разыменовываются (загружаются или сохраняются) с помощью &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">В Julia &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; производит &lt;code&gt;[1, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В Julia &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; выдает &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">В Julia &lt;code&gt;[x,y,z]&lt;/code&gt; всегда будет создавать массив из 3 элементов, содержащий &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">В Джулии, &lt;code&gt;a:b&lt;/code&gt; и &lt;code&gt;a:b:c&lt;/code&gt; построить &lt;code&gt;AbstractRange&lt;/code&gt; объекты. Чтобы построить полный вектор, как в MATLAB, используйте &lt;code&gt;collect(a:b)&lt;/code&gt; . Однако, как правило, вызывать &lt;code&gt;collect&lt;/code&gt; не требуется . Объект &lt;code&gt;AbstractRange&lt;/code&gt; в большинстве случаев будет действовать как обычный массив, но более эффективен, потому что он лениво вычисляет свои значения. Этот шаблон создания специализированных объектов вместо полных массивов используется часто, а также встречается в таких функциях, как &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , или с итераторами, такими как &lt;code&gt;enumerate&lt;/code&gt; и &lt;code&gt;zip&lt;/code&gt; . Специальные объекты можно использовать, как если бы они были обычными массивами.</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">В Юлии &lt;code&gt;return&lt;/code&gt; не требует скобок.</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">В Julia &lt;code&gt;x += y&lt;/code&gt; заменяется во время синтаксического анализа на &lt;code&gt;x = x + y&lt;/code&gt; . Для массивов это приводит к тому, что вместо сохранения результата в том же месте в памяти, что и &lt;code&gt;x&lt;/code&gt; , он выделяет новый массив для хранения результата.</target>
        </trans-unit>
        <trans-unit id="40831d3e8b132da3257b046df4af0d9dab5df46c" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, because they can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">В Julia функция-это объект,который сопоставляет кортеж значений аргументов с возвращаемым значением.Функции Юлии не являются чистыми математическими функциями в том смысле,что функции могут изменяться и на них может влиять глобальное состояние программы.Основным синтаксисом для определения функций в Юлии является:</target>
        </trans-unit>
        <trans-unit id="1c8982a95e255a5e2cc9c0e2345b6061fd0be88f" translate="yes" xml:space="preserve">
          <source>In Julia, a function may contain multiple concrete implementations (called &lt;em&gt;Methods&lt;/em&gt;), selected via multiple dispatch, whereas functions in Python have a single implementation (no polymorphism).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f670eb9f52ba71aa8ad7654d94717d406c50aa0" translate="yes" xml:space="preserve">
          <source>In Julia, a new local scope is introduced by most code blocks, including loops and &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas &lt;code&gt;if&lt;/code&gt; blocks do not introduce a new local scope in both languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">В Julia диапазон, подобный &lt;code&gt;a:b&lt;/code&gt; , не является сокращением вектора, как в R, а является специализированным объектом &lt;code&gt;AbstractRange&lt;/code&gt; , который используется для итерации без больших накладных расходов на память. Чтобы преобразовать диапазон в вектор, используйте &lt;code&gt;collect(a:b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">В Julia все аргументы функции &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;передаются путем совместного использования&lt;/a&gt; (то есть с помощью указателей). Некоторые языки технических вычислений передают массивы по значению, и хотя это предотвращает случайное изменение вызываемыми объектами значения в вызывающей программе, это затрудняет предотвращение нежелательного копирования массивов. По соглашению, имя функции, оканчивающееся на &lt;code&gt;!&lt;/code&gt; указывает, что он изменит или уничтожит значение одного или нескольких своих аргументов (сравните, например, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; ). Вызываемые должны делать явные копии, чтобы гарантировать, что они не изменяют входные данные, которые они не собираются изменять. Многие немутантные функции реализуются путем вызова одноименной функции с добавленным &lt;code&gt;!&lt;/code&gt; в конце явной копии ввода и возврата этой копии.</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">В Julia выражение &amp;laquo;срез&amp;raquo; &lt;code&gt;array[1:5, :]&lt;/code&gt; такое как array [1: 5,:], создает копию этих данных (кроме левой стороны присваивания, где &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; присваивает вместо этой части &lt;code&gt;array&lt;/code&gt; ). Если вы выполняете много операций со срезом, это может быть хорошо для производительности, потому что более эффективно работать с меньшей непрерывной копией, чем индексировать в исходный массив. С другой стороны, если вы просто выполняете несколько простых операций со срезом, стоимость операций выделения и копирования может быть значительной.</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">В Юлии превышение максимального представляемого значения данного типа приводит к оберточному поведению:</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В Julia, если &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; являются массивами, операции логического сравнения, такие как &lt;code&gt;A == B&lt;/code&gt; , не возвращают массив логических значений. Вместо этого используйте &lt;code&gt;A .== B&lt;/code&gt; и аналогично для других логических операторов, таких как &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1570d580f73be0193694bd4c3eb228fc48008c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing a matrix with arrays like &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a vector that contains the values of cell &lt;code&gt;[1,1]&lt;/code&gt; and &lt;code&gt;[2,3]&lt;/code&gt; in the matrix. &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; in Julia is equivalent with &lt;code&gt;X[np.ix_([0,1],[0,2])]&lt;/code&gt; in Python. &lt;code&gt;X[[0,1], [0,2]]&lt;/code&gt; in Python is equivalent with &lt;code&gt;X[[CartesianIndex(1,1), CartesianIndex(2,3)]]&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">В Юлии индексирование массивов,строк и т.д.основано на 1,а не на 0.</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">В Julia, как и в Python, но в отличие от R, строки можно создавать с тройными кавычками &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; . Этот синтаксис удобен для создания строк, содержащих разрывы строк.</target>
        </trans-unit>
        <trans-unit id="6ff09f4efca3c4661d730a90a1c75212c7df44ad" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">В Julia буквальные числа без десятичной точки (например, &lt;code&gt;42&lt;/code&gt; ) создают целые числа вместо чисел с плавающей запятой. В результате некоторые операции могут вызывать ошибку домена, если они ожидают плавающее число; например, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; вызывает ошибку домена, поскольку результат не является целым числом (подробности см. В &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;разделе часто задаваемых вопросов об ошибках домена&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">В Julia буквальные числа без десятичной точки (например, &lt;code&gt;42&lt;/code&gt; ) создают целые числа со знаком типа &lt;code&gt;Int&lt;/code&gt; , но литералы, слишком большие, чтобы соответствовать размеру машинного слова, будут автоматически преобразованы в тип большего размера, например &lt;code&gt;Int64&lt;/code&gt; (если &lt;code&gt;Int&lt;/code&gt; равен &lt;code&gt;Int32&lt;/code&gt; ), &lt;code&gt;Int128&lt;/code&gt; или произвольно большой тип &lt;code&gt;BigInt&lt;/code&gt; . Не существует числовых буквальных суффиксов, таких как &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;LL&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , &lt;code&gt;ULL&lt;/code&gt; , для обозначения беззнакового и / или подписанного или беззнакового. Десятичные литералы всегда подписаны, а шестнадцатеричные литералы (начинающиеся с &lt;code&gt;0x&lt;/code&gt; как C / C ++), беззнаковые. Шестнадцатеричные литералы также, в отличие от C / C ++ / Java и в отличие от десятичных литералов в Julia, имеют тип, основанный на &lt;em&gt;длине&lt;/em&gt; литерала, включая ведущие нули. Например, &lt;code&gt;0x0&lt;/code&gt; и &lt;code&gt;0x00&lt;/code&gt; имеют тип &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;0x000&lt;/code&gt; и &lt;code&gt;0x0000&lt;/code&gt; имеют тип &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; , тогда литералы с 5-8 шестнадцатеричными цифрами имеют тип &lt;code&gt;UInt32&lt;/code&gt; , от 9 до 16 шестнадцатеричных цифр - &lt;code&gt;UInt64&lt;/code&gt; и от 17 до 32 шестнадцатеричных цифр - &lt;code&gt;UInt128&lt;/code&gt; . Это необходимо учитывать при определении шестнадцатеричных масок, например, &lt;code&gt;~0xf == 0xf0&lt;/code&gt; сильно отличается от &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; . 64 бит &lt;code&gt;Float64&lt;/code&gt; литералы Float64 и 32-битные &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; выражаются как &lt;code&gt;1.0&lt;/code&gt; и &lt;code&gt;1.0f0&lt;/code&gt; соответственно. Литералы с плавающей запятой округляются (и не &lt;code&gt;BigFloat&lt;/code&gt; тип BigFloat ), если они не могут быть точно представлены. Литералы с плавающей запятой по поведению ближе к C / C ++. Восьмеричные (с префиксом &lt;code&gt;0o&lt;/code&gt; ) и двоичные (с префиксом &lt;code&gt;0b&lt;/code&gt; ) литералы также рассматриваются как беззнаковые.</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">В Julia отсутствующие значения представлены &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; объектом, а не &lt;code&gt;NA&lt;/code&gt; . Используйте &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; (или &lt;code&gt;ismissing.(x)&lt;/code&gt; для поэлементных операций с векторами) вместо &lt;code&gt;is.na(x)&lt;/code&gt; . Функция &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; обычно используется вместо &lt;code&gt;na.rm=TRUE&lt;/code&gt; (хотя в некоторых конкретных случаях функции принимают аргумент &lt;code&gt;skipmissing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">В Julia модуль равен &lt;code&gt;mod(a, b)&lt;/code&gt; , а не &lt;code&gt;a %% b&lt;/code&gt; . &lt;code&gt;%&lt;/code&gt; в Юлии - это оператор остатка.</target>
        </trans-unit>
        <trans-unit id="d79893a1ef0fe5a790c5d1bb686e33bb258470f4" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">В Julia большинство операторов - это просто функции с поддержкой специального синтаксиса. (Исключениями являются операторы со специальной семантикой оценки, например &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; . Эти операторы не могут быть функциями, поскольку &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;оценка короткого замыкания&lt;/a&gt; требует, чтобы их операнды не оценивались перед вычислением оператора.) Соответственно, вы также можете применять их, используя списки аргументов в скобках. , как и любую другую функцию:</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">В Julia несколько значений возвращаются и назначаются в виде кортежей, например &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; или &lt;code&gt;a, b = 1, 2&lt;/code&gt; . &lt;code&gt;nargout&lt;/code&gt; MATLAB , который часто используется в MATLAB для выполнения необязательной работы на основе количества возвращенных значений, не существует в Julia. Вместо этого пользователи могут использовать необязательные аргументы и аргументы ключевого слова для достижения аналогичных возможностей.</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">В Джулии не все структуры данных поддерживают логическую индексацию.Более того,логическая индексация в Юлии поддерживается только с векторами длины,равными длине индексируемого объекта.Например:</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">В Джулии возвращается кортеж значений для имитации возврата множественных значений.Однако кортежи можно создавать и уничтожать без использования скобок,создавая иллюзию,что возвращается не одно значение кортежа,а несколько значений.Например,следующая функция возвращает пару значений:</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В Julia необходимо использовать круглые скобки для вызова функции с нулевым аргументом, как в &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">В Julia сокращения, такие как &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; , выполняются для каждого элемента массива при вызове с одним аргументом, как в &lt;code&gt;sum(A)&lt;/code&gt; , даже если &lt;code&gt;A&lt;/code&gt; имеет более одного измерения.</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">В Julia разреженные матрицы хранятся в &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;формате сжатого разреженного столбца (CSC)&lt;/a&gt; . &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt; матрицы Джулии имеют тип SparseMatrixCSC {Tv, Ti} , где &lt;code&gt;Tv&lt;/code&gt; - это тип хранимых значений, а &lt;code&gt;Ti&lt;/code&gt; - целочисленный тип для хранения указателей столбцов и индексов строк. Внутреннее представление &lt;code&gt;SparseMatrixCSC&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a5c3c759720c16030d42ce9ed7346415b8cda62d" translate="yes" xml:space="preserve">
          <source>In Julia, the &lt;code&gt;adjoint&lt;/code&gt; function performs conjugate transposition; in MATLAB, &lt;code&gt;adjoint&lt;/code&gt; provides the &quot;adjugate&quot; or classical adjoint, which is the transpose of the matrix of cofactors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">В Julia привязку переменной &lt;code&gt;x&lt;/code&gt; нельзя изменить, передав &lt;code&gt;x&lt;/code&gt; в качестве аргумента функции. При вызове &lt;code&gt;change_value!(x)&lt;/code&gt; в приведенном выше примере &lt;code&gt;y&lt;/code&gt; - это вновь созданная переменная, изначально привязанная к значению &lt;code&gt;x&lt;/code&gt; , то есть &lt;code&gt;10&lt;/code&gt; ; затем &lt;code&gt;y&lt;/code&gt; восстанавливается до константы &lt;code&gt;17&lt;/code&gt; , а переменная &lt;code&gt;x&lt;/code&gt; внешней области видимости остается нетронутой.</target>
        </trans-unit>
        <trans-unit id="e2d42d83a28f2989051e64390c6b07102af77a3d" translate="yes" xml:space="preserve">
          <source>In Julia, the commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;), unlike in Python, where &lt;code&gt;int&lt;/code&gt; is an arbitrary length integer. This means in Julia the &lt;code&gt;Int&lt;/code&gt; type will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">В Julia элементы коллекции могут быть переданы в качестве аргументов функции с помощью оператора splat &lt;code&gt;...&lt;/code&gt; , как в &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d494edc49792467615a5bbbdd57215d8dd338e99" translate="yes" xml:space="preserve">
          <source>In Julia, the exponentiation operator is &lt;code&gt;^&lt;/code&gt;, not &lt;code&gt;**&lt;/code&gt; as in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">В Julia оператор &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) выполняет побитовую операцию XOR, т.е. &lt;code&gt;^&lt;/code&gt; в C / C ++. Кроме того, побитовые операторы не имеют того же приоритета, что и C / ++, поэтому могут потребоваться скобки.</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">В Юлии операторы &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;|&lt;/code&gt; , и &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) выполняют побитовые операции, эквивалентные &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , и &lt;code&gt;xor&lt;/code&gt; соответственно в MATLAB, и имеют приоритет, аналогичный побитовым операторам Python (в отличие от C). Они могут работать со скалярами или поэлементно в массивах и могут использоваться для объединения логических массивов, но обратите внимание на различие в порядке операций: могут потребоваться круглые скобки (например, для выбора элементов &lt;code&gt;A&lt;/code&gt; , равных 1 или 2, используйте &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e2a4d55a36175a20161ae921b2cf660cd6f7ede" translate="yes" xml:space="preserve">
          <source>In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, &lt;code&gt;A * B&lt;/code&gt; in Julia performs matrix multiplication, not element-wise multiplication as in Python. &lt;code&gt;A * B&lt;/code&gt; in Julia is equivalent with &lt;code&gt;A @ B&lt;/code&gt; in Python, whereas &lt;code&gt;A * B&lt;/code&gt; in Python is equivalent with &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">В Julia значения не копируются при назначении или передаче в функцию.Если функция изменяет массив,изменения будут видны вызывающему абоненту.Это сильно отличается от R и позволяет новым функциям гораздо эффективнее работать с большими структурами данных.</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">В Julia varargs указываются с помощью оператора splat &lt;code&gt;...&lt;/code&gt; , который всегда следует за именем конкретной переменной, в отличие от R, для которого &lt;code&gt;...&lt;/code&gt; может встречаться изолированно.</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">В Julia векторы и матрицы объединяются с использованием &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt; , а не &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;rbind&lt;/code&gt; и &lt;code&gt;cbind&lt;/code&gt; , как в R.</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">В Джулии мы можем получить доступ к частям самостоятельно,чтобы сделать копию этой строки:</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">В Julia,в отличие от C/C++,пробельные символы имеют большое значение,поэтому при добавлении/удалении пробельных символов из программы Julia следует соблюдать осторожность.</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">В Julia вы не можете использовать такие &lt;em&gt;значения&lt;/em&gt; , как &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . Однако вы можете выполнять диспетчеризацию параметрических типов, и Julia позволяет вам включать значения &amp;laquo;простых битов&amp;raquo; (типы, символы, целые числа, числа с плавающей запятой, кортежи и т. Д.) В качестве параметров типа. Типичным примером является параметр размерности в &lt;code&gt;Array{T,N}&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тип (например, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ), а &lt;code&gt;N&lt;/code&gt; - это просто &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">В MATLAB идиоматический способ удаления нежелательных значений - использовать логическое индексирование, например, в выражении &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; или в операторе &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; для изменения &lt;code&gt;x&lt;/code&gt; на месте. В отличие от этого, Джулия предоставляет &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; функций высшего порядка ! , позволяя пользователям писать &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; и &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; качестве альтернативы соответствующим транслитерациям &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; и &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; . Используя &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;уменьшает использование временных массивов.</target>
        </trans-unit>
        <trans-unit id="af1c31248c4802059b749cc923a13d7acffd80c9" translate="yes" xml:space="preserve">
          <source>In Python, the majority of values can be used in logical contexts (e.g. &lt;code&gt;if &quot;a&quot;:&lt;/code&gt; means the following block is executed, and &lt;code&gt;if &quot;&quot;:&lt;/code&gt; means it is not). In Julia, you need explicit conversion to &lt;code&gt;Bool&lt;/code&gt; (e.g. &lt;code&gt;if &quot;a&quot;&lt;/code&gt; throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write &lt;code&gt;if !isempty(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">В R &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; эквивалентно &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">В R &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; эквивалентно &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">В R идиоматический способ удаления нежелательных значений - использовать логическое индексирование, как в выражении &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; или в операторе &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; чтобы изменить &lt;code&gt;x&lt;/code&gt; на месте. В отличие от этого, Джулия предоставляет &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; функций высшего порядка ! , позволяя пользователям писать &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; и &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; качестве альтернативы соответствующим транслитерациям &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; и &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; . Используя &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;уменьшает использование временных массивов.</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">В R производительность требует векторизации.В Юлии же верно почти обратное:лучшая производительность кода часто достигается за счет использования девальвированных циклов.</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">В контексте линейной алгебры это означает, что даже несмотря на то, что определены такие операции, как &lt;code&gt;vector + vector&lt;/code&gt; и &lt;code&gt;vector * scalar&lt;/code&gt; , может быть выгодно вместо этого использовать &lt;code&gt;vector .+ vector&lt;/code&gt; и &lt;code&gt;vector .* scalar&lt;/code&gt; потому что результирующие циклы могут быть объединены с окружающими вычислениями. , Например, рассмотрим две функции:</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">В локальной области видимости все переменные наследуются от родительского блока глобальной области видимости,если только:</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">В модуле, объявить о том , что файл , указанный &lt;code&gt;path&lt;/code&gt; (абсолютной или относительной) представляет собой зависимость для прекомпиляции; то есть модуль необходимо будет перекомпилировать, если этот файл изменится.</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">В некотором смысле Джулия попадает в категорию &amp;laquo;без автоматического продвижения&amp;raquo;: математические операторы - это просто функции со специальным синтаксисом, а аргументы функций никогда не преобразуются автоматически. Однако можно заметить, что применение математических операций к широкому спектру смешанных типов аргументов - это всего лишь крайний случай полиморфной множественной диспетчеризации - то, что системы диспетчеризации и типов Джулии особенно хорошо подходят для обработки. &amp;laquo;Автоматическое&amp;raquo; продвижение математических операндов просто возникает как специальное приложение: Julia поставляется с предопределенными универсальными правилами диспетчеризации для математических операторов, которые вызываются, когда не существует конкретной реализации для некоторой комбинации типов операндов. Эти универсальные правила сначала переводят все операнды к общему типу с помощью определяемых пользователем правил продвижения,а затем вызвать специализированную реализацию рассматриваемого оператора для результирующих значений, теперь того же типа. Типы, определяемые пользователем, могут легко участвовать в этой системе продвижения, определяя методы преобразования в другие типы и из них, и предоставляя несколько правил продвижения, определяющих, в какие типы они должны продвигаться при смешивании с другими типами.</target>
        </trans-unit>
        <trans-unit id="c6a6dfe6183c6c2d1bbad1fc9762d95e2e3097dd" translate="yes" xml:space="preserve">
          <source>In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair &lt;code&gt;name::Symbol =&amp;gt; value&lt;/code&gt; or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">В дополнение к поддержке многомерных массивов (и как ее часть) Julia предоставляет встроенные реализации многих распространенных и полезных операций линейной алгебры, которые можно загрузить с &lt;code&gt;using LinearAlgebra&lt;/code&gt; . Поддерживаются все основные операции, такие как &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;inv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">Помимо &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; , для эффективного использования задач необходимы еще несколько основных функций.</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">В дополнение к &lt;code&gt;using Base&lt;/code&gt; модули также автоматически содержат определения функций &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; , которые оценивают выражения / файлы в глобальной области действия этого модуля.</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">В дополнение ко всем итерируемым и индексируемым методам, указанным выше, эти типы также могут взаимодействовать друг с другом и использовать большинство методов, определенных в Julia Base для &lt;code&gt;AbstractArrays&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">В дополнение к линейной индексации, &lt;code&gt;N&lt;/code&gt; - мерный массив может быть индексированы меньше или больше , чем &lt;code&gt;N&lt;/code&gt; индексов в определенных ситуациях.</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">В дополнение к задачам Julia forwards нативно поддерживает многопотоковую обработку.Обратите внимание,что этот раздел является экспериментальным и интерфейсы могут измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">В дополнение к заданному списку аргументов каждому макросу передаются дополнительные аргументы с именами &lt;code&gt;__source__&lt;/code&gt; и &lt;code&gt;__module__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f681189a6c7a87dd61774b09673a55a0c0fa70a2" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">Кроме того, Джулия предоставляет множество &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;факторизаций,&lt;/a&gt; которые можно использовать для ускорения задач, таких как линейное решение или возведение в степень матрицы, путем предварительной факторизации матрицы в форму, более подходящую (по соображениям производительности или памяти) для задачи. См. Документацию по &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации. Например:</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">Во всех случаях неоднозначность разрешается в пользу интерпретации в виде числовых букв:</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">Во всех вышеперечисленных режимах выполненные строки сохраняются в файл истории, в котором можно искать. Чтобы начать инкрементный поиск в предыдущей истории, введите &lt;code&gt;^R&lt;/code&gt; - управляющую клавишу вместе с клавишей &lt;code&gt;r&lt;/code&gt; . Приглашение изменится на &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; , и по мере ввода поисковый запрос будет отображаться в кавычках. Самый последний результат, соответствующий запросу, будет динамически обновляться справа от двоеточия по мере ввода большего количества символов. Чтобы найти более старый результат с помощью того же запроса, просто введите &lt;code&gt;^R&lt;/code&gt; раз.</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">Во всех этих случаях &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; в&lt;/a&gt; конечном итоге работает с объектом &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; , который отвечает за постановку в очередь и перезапуск задач. Когда задача вызывает &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; для &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; , задача помечается как невыполнимая, добавляется в очередь условия и переключается на планировщик. Затем планировщик выберет другую задачу для запуска или заблокирует ожидание внешних событий. Если все пойдет хорошо, в конце концов , обработчик события будет вызывать &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; о состоянии, которое вызывает задачи в ожидании , что условие , чтобы стать работоспособным снова.</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">Во всех этих случаях &lt;code&gt;x&lt;/code&gt; привязан к кортежу конечных значений, переданных в &lt;code&gt;bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">В топологии &quot;все-все&quot; (по умолчанию)все сотрудники соединяются друг с другом через обычные TCP-разъемы.Политика безопасности на узлах кластера должна,таким образом,обеспечивать свободное соединение между рабочими для эфемерного диапазона портов (варьируется в зависимости от ОС).</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">И в Julia, и в MATLAB переменная &lt;code&gt;ans&lt;/code&gt; устанавливается в значение последнего выражения, выданного в интерактивном сеансе. В Julia, в отличие от MATLAB, &lt;code&gt;ans&lt;/code&gt; не устанавливается, когда код Julia выполняется в неинтерактивном режиме.</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">Как в Julian,так и в справочном режиме REPL,можно ввести первые несколько символов функции или типа,а затем нажать клавишу табуляции,чтобы получить список всех совпадений:</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">В случае удаленных ссылок размер локального ссылочного объекта довольно мал, в то время как значение, хранимое на удаленном узле, может быть довольно большим. Поскольку локальный объект не может быть собран немедленно, рекомендуется явно вызвать &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; для локальных экземпляров &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; или для невыгруженных &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; s. Поскольку вызов &lt;code&gt;fetch&lt;/code&gt; для &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; также удаляет ссылку на него из удаленного хранилища, это не требуется для извлеченных &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; s. Явный вызов &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; приводит к немедленному отправлению удаленному узлу сообщения с просьбой продолжить и удалить ссылку на значение.</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">В случаях, когда &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; нужно взять объект Julia и превратить его в &lt;code&gt;Ptr&lt;/code&gt; , эту функцию следует использовать для определения и выполнения этого преобразования.</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">В случаях, когда &lt;code&gt;x&lt;/code&gt; не может быть безопасно преобразовано в &lt;code&gt;T&lt;/code&gt; , в отличие от &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;cconvert&lt;/code&gt; может возвращать объект типа, отличного от &lt;code&gt;T&lt;/code&gt; , который, однако, подходит для обработки &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; . Результат этой функции должен оставаться действительным (для GC) до тех пор, пока результат &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; больше не понадобится. Это можно использовать для выделения памяти, к которой будет обращаться &lt;code&gt;ccall&lt;/code&gt; . Если необходимо выделить несколько объектов, в качестве возвращаемого значения можно использовать кортеж объектов.</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">В случаях, когда вы хотите иметь возможность смешивать несколько &lt;code&gt;AbstractArrayStyle&lt;/code&gt; и отслеживать размерность, ваш стиль должен поддерживать конструктор &lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">В коде, который выполняет изменения состояния или использует ресурсы, такие как файлы, обычно есть работа по очистке (например, закрытие файлов), которую необходимо выполнить после завершения кода. Исключения потенциально усложняют эту задачу, поскольку они могут привести к выходу блока кода до его нормального завершения. &lt;code&gt;finally&lt;/code&gt; ключевое слово дает возможность запускать код , когда данный блок кода выходов, независимо от того, как он выходит.</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">В отличие от использования оператора &lt;code&gt;...&lt;/code&gt; для обозначения объединения множества разных аргументов в один аргумент при определении функции, оператор &lt;code&gt;...&lt;/code&gt; также используется для разделения одного аргумента функции на множество разных аргументов при использовании в контекст вызова функции. Такое использование &lt;code&gt;...&lt;/code&gt; называется сплаттингом:</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">В отличие от &lt;code&gt;for i = 1:length(A)&lt;/code&gt; , итерация с &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; обеспечивает эффективный способ перебора любого типа массива.</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">Напротив, как только &lt;code&gt;m&lt;/code&gt; построено, тип &lt;code&gt;m.a&lt;/code&gt; не может измениться:</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">В общем, вы можете разместить оператор &lt;code&gt;return&lt;/code&gt; в любом месте тела функции, в том числе внутри глубоко вложенных циклов или условных выражений, но будьте осторожны с блоками &lt;code&gt;do&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">В общем, операция широковещания представлена ​​ленивым контейнером &lt;code&gt;Broadcasted&lt;/code&gt; , который хранит функцию, которая будет применяться вместе со своими аргументами. Эти аргументы могут сами по себе быть более вложенными &lt;code&gt;Broadcasted&lt;/code&gt; контейнерами, образующими большое дерево выражений для оценки. Вложенное дерево &lt;code&gt;Broadcasted&lt;/code&gt; контейнеров строится напрямую с помощью неявного точечного синтаксиса; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; временно представлен, например, &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; . Это невидимо для пользователей, так как это сразу же реализуется через вызов &lt;code&gt;copy&lt;/code&gt; , но именно этот контейнер обеспечивает основу для расширяемости широковещательной рассылки для авторов настраиваемых типов. Затем встроенный механизм широковещания определит тип и размер результата на основе аргументов, выделит его и затем, наконец, скопирует в него реализацию объекта &lt;code&gt;Broadcasted&lt;/code&gt; с помощью &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; по умолчанию . Встроенная резервная &lt;code&gt;broadcast&lt;/code&gt; и &lt;code&gt;broadcast!&lt;/code&gt; методы аналогичным образом создают временное &lt;code&gt;Broadcasted&lt;/code&gt; представление операции, чтобы они могли следовать одному и тому же пути кода. Это позволяет реализациям настраиваемых массивов предоставлять собственные &lt;code&gt;copyto!&lt;/code&gt; специализация по настройке и оптимизации вещания. Это снова определяется вычисленным стилем вещания. Это настолько важная часть операции, что она сохраняется как параметр первого типа для типа &lt;code&gt;Broadcasted&lt;/code&gt; , что позволяет осуществлять отправку и специализацию.</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">В общем, если у вас есть &lt;code&gt;N&lt;/code&gt; выборок, собранных в строке, вы можете ожидать неопределенности порядка &lt;code&gt;sqrt(N)&lt;/code&gt; (за исключением других источников шума, например, насколько загружен компьютер другими задачами). Основным исключением из этого правила является сборка мусора, которая выполняется нечасто, но, как правило, довольно дорого. (Поскольку сборщик мусора Джулии написан на C, такие события можно обнаружить с помощью режима вывода &lt;code&gt;C=true&lt;/code&gt; , описанного ниже, или с помощью &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">В общем, конструкция цикла &lt;code&gt;for&lt;/code&gt; может выполнять итерацию по любому контейнеру. В этих случаях вместо &lt;code&gt;=&lt;/code&gt; обычно используется альтернативное (но полностью эквивалентное) ключевое слово &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; , так как оно делает код более понятным:</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">В общем,синтаксис Julia для обратных ссылок тщательно продуман так,чтобы можно было просто вырезать и вставить команды оболочки,как есть,в обратные ссылки,и они будут работать:поведение экранирования,цитирования и интерполяции такое же,как и в оболочке.Единственное отличие состоит в том,что интерполяция интегрирована и знает концепцию Джулии о том,что такое однострочное значение,и что такое контейнер для множественных значений.Давайте попробуем два вышеприведенных примера в Джулии:</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">В целом,в отличие от многих других технических вычислительных языков,Джулия не ожидает,что программы будут написаны в векторизованном стиле для производительности.Компилятор Julia использует типовой вывод и генерирует оптимизированный код для скалярной индексации массивов,позволяя писать программы в удобном и читаемом стиле,не жертвуя при этом производительностью и используя порой меньше памяти.</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">В общем, вы не можете предполагать, что вывод на &lt;code&gt;display&lt;/code&gt; перейдет в стандартный &lt;code&gt;stdout&lt;/code&gt; (в отличие от &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; ). Например, &lt;code&gt;display(x)&lt;/code&gt; может открывать отдельное окно с изображением. &lt;code&gt;display(x)&lt;/code&gt; означает &amp;laquo;показать &lt;code&gt;x&lt;/code&gt; наилучшим образом для текущего устройства вывода&amp;raquo;. Если вам нужен текстовый вывод, похожий на REPL, который гарантированно переходит на стандартный &lt;code&gt;stdout&lt;/code&gt; , используйте вместо этого &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ec09f4dcceb1c007da785592e4c12f3a7b2638d" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">При интерпретации результатов есть несколько важных деталей. В соответствии с настройками &lt;code&gt;user&lt;/code&gt; первая строка любой функции, вызываемой напрямую из REPL, будет показывать распределение из-за событий, которые происходят в самом коде REPL. Что еще более важно, JIT-компиляция также увеличивает количество выделенных ресурсов, потому что большая часть компилятора Julia написана на Julia (а компиляция обычно требует выделения памяти). Рекомендуемая процедура - принудительно выполнить компиляцию, выполнив все команды, которые вы хотите проанализировать, а затем вызвать &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt; для сброса всех счетчиков распределения. Наконец, выполните нужные команды и &lt;code&gt;.mem&lt;/code&gt; из Julia, чтобы запустить создание файлов .mem .</target>
        </trans-unit>
        <trans-unit id="dfcc306e80c7cf321f53ff98ff95ac030d502bfd" translate="yes" xml:space="preserve">
          <source>In loops and &lt;a href=&quot;../arrays/index#man-comprehensions&quot;&gt;comprehensions&lt;/a&gt;, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block, as demonstrated by this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b38f63219b850b33b9abc3b16ad8edd611a5f30" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">В основных объектно-ориентированных языках, таких как C ++, Java, Python и Ruby, составные типы также имеют связанные с ними именованные функции, и комбинация называется &amp;laquo;объектом&amp;raquo;. В более чистых объектно-ориентированных языках, таких как Ruby или Smalltalk, все значения являются объектами, независимо от того, являются они составными или нет. В менее чистых объектно-ориентированных языках, включая C ++ и Java, некоторые значения, такие как целые числа и значения с плавающей запятой, не являются объектами, в то время как экземпляры определяемых пользователем составных типов являются истинными объектами со связанными методами. В Julia все значения являются объектами, но функции не связаны с объектами, над которыми они работают. Это необходимо, поскольку Джулия выбирает, какой метод функции использовать при многократной отправке, а это означает, что типы &lt;em&gt;всех&lt;/em&gt;аргументов функции учитываются при выборе метода, а не только первого ( дополнительные сведения о методах и отправке см. в разделе &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Методы&lt;/a&gt; ). Таким образом, было бы неуместно, чтобы функции &amp;laquo;принадлежали&amp;raquo; только своему первому аргументу. Организация методов в функциональные объекты, а не именованные пакеты методов &amp;laquo;внутри&amp;raquo; каждого объекта, в конечном итоге является очень полезным аспектом языкового дизайна.</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">Во многих случаях существуют оперативные версии матричных операций, которые позволяют вам предоставить заранее выделенный выходной вектор или матрицу. Это полезно при оптимизации критического кода, чтобы избежать накладных расходов, связанных с повторным распределением. Эти операции на месте имеют суффикс &lt;code&gt;!&lt;/code&gt; ниже (например, &lt;code&gt;mul!&lt;/code&gt; ) в соответствии с обычным соглашением Джулии.</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">Во многих случаях Джулия может автоматически векторизовать внутренние циклы for без использования &lt;code&gt;@simd&lt;/code&gt; . Использование &lt;code&gt;@simd&lt;/code&gt; дает компилятору дополнительную свободу действий, чтобы сделать это возможным в большем количестве ситуаций. В любом случае ваш внутренний цикл должен иметь следующие свойства, чтобы разрешить векторизацию:</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">Во многих случаях аргументы функции имеют разумные значения по умолчанию, и поэтому может не потребоваться явная передача при каждом вызове. Например, функция &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt; из модуля &lt;code&gt;Dates&lt;/code&gt; создает тип &lt;code&gt;Date&lt;/code&gt; для заданного года &lt;code&gt;y&lt;/code&gt; , месяца &lt;code&gt;m&lt;/code&gt; и дня &lt;code&gt;d&lt;/code&gt; . Однако аргументы &lt;code&gt;m&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; необязательны, и их значение по умолчанию равно &lt;code&gt;1&lt;/code&gt; . Это поведение можно кратко выразить как:</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">Во многих случаях излишне указывать тип объекта &lt;code&gt;Point&lt;/code&gt; , который требуется построить, поскольку типы аргументов для вызова конструктора уже неявно предоставляют информацию о типе. По этой причине вы также можете применить сам &lt;code&gt;Point&lt;/code&gt; в качестве конструктора, при условии, что подразумеваемое значение типа параметра &lt;code&gt;T&lt;/code&gt; однозначно:</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">Во многих случаях разрешение, указанное для округления (например, &lt;code&gt;Dates.Second(30)&lt;/code&gt; ), делится поровну на следующий по величине период (в данном случае &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ). Но поведение округления в случаях, когда это неверно, может привести к путанице. Каков ожидаемый результат округления &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; до ближайших 10 часов?</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">Во многих языках с необязательными объявлениями типов добавление объявлений - это основной способ ускорить выполнение кода. Это &lt;em&gt;не&lt;/em&gt; так в Джулию. В Julia компилятор обычно знает типы всех аргументов функции, локальных переменных и выражений. Однако есть несколько конкретных случаев, когда объявления полезны.</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">В математике &lt;code&gt;+&lt;/code&gt; обычно обозначает &lt;em&gt;коммутативную&lt;/em&gt; операцию, где порядок операндов не имеет значения. Примером этого является сложение матриц, где &lt;code&gt;A + B == B + A&lt;/code&gt; для любых матриц &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , имеющих одинаковую форму. Напротив, &lt;code&gt;*&lt;/code&gt; обычно обозначает &lt;em&gt;некоммутативную&lt;/em&gt; операцию, где порядок операндов &lt;em&gt;имеет&lt;/em&gt; значение. Примером этого является умножение матриц, где в общем случае &lt;code&gt;A * B != B * A&lt;/code&gt; . Как и в случае матричного умножения, конкатенация строк некоммутативна: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; . Таким образом, &lt;code&gt;*&lt;/code&gt; является более естественным выбором для оператора конкатенации инфиксных строк, что согласуется с обычным математическим использованием.</target>
        </trans-unit>
        <trans-unit id="d668367cdfd665ad4130e8623549b132951b0865" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">В более сложных случаях разрешение неоднозначности метода включает определенный элемент дизайна; эта тема более подробно рассматривается &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79e9987996de7a2336075063e303687b6133cecc" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">В большинстве случаев, если &lt;code&gt;A&lt;/code&gt; является подтипом &lt;code&gt;S&lt;/code&gt; в &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; с типом элемента &lt;code&gt;T&lt;/code&gt; , поддерживающим &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;/&lt;/code&gt; , возвращаемый тип - &lt;code&gt;LU{T,S{T}}&lt;/code&gt; . Если выбрано вращение (по умолчанию), тип элемента также должен поддерживать &lt;code&gt;abs&lt;/code&gt; и &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b67b5f42c4b6dbeb6aa0f0d5f6894ea2c19994e" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;#catch-ctrl-c&quot;&gt;catch CTRL-C&lt;/a&gt; in the script you can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">Чтобы получить доступ к данным x, мы можем использовать &lt;code&gt;jl_array_data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">Чтобы собрать эту программу, вы должны поместить путь к заголовку Julia в путь включения и ссылку на &lt;code&gt;libjulia&lt;/code&gt; . Например, когда Julia установлена ​​в &lt;code&gt;$JULIA_DIR&lt;/code&gt; , можно скомпилировать вышеуказанную тестовую программу &lt;code&gt;test.c&lt;/code&gt; с помощью &lt;code&gt;gcc&lt;/code&gt; , используя:</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">Для того , чтобы проверить , является ли &lt;code&gt;ret&lt;/code&gt; имеет определенного типа Джулии, мы можем использовать &lt;code&gt;jl_isa&lt;/code&gt; , &lt;code&gt;jl_typeis&lt;/code&gt; , или &lt;code&gt;jl_is_...&lt;/code&gt; функции. Набрав &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; в оболочку Julia, мы увидим, что тип возвращаемого значения - &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;double&lt;/code&gt; в C). Чтобы преобразовать упакованное значение Julia в двойное C, в приведенном выше фрагменте кода используется функция &lt;code&gt;jl_unbox_float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">Чтобы вычислить тригонометрические функции с градусами вместо радианов, добавьте к функции суффикс &lt;code&gt;d&lt;/code&gt; . Например, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt; вычисляет синус &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; указывается в градусах. Полный список тригонометрических функций с вариантами степеней:</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">Чтобы определить новый бэкэнд отображения, необходимо сначала создать подтип &lt;code&gt;D&lt;/code&gt; абстрактного класса &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; . Затем для каждого типа MIME ( строка &lt;code&gt;mime&lt;/code&gt; ), который может отображаться на &lt;code&gt;D&lt;/code&gt; , следует определить функцию &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; которая отображает &lt;code&gt;x&lt;/code&gt; как этот тип MIME, обычно вызывая &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;repr(io, mime, x)&lt;/code&gt; . Ошибка &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; должна быть выдана , если &lt;code&gt;x&lt;/code&gt; не может отображаться как этот тип MIME; это происходит автоматически, если вызывается &lt;code&gt;show&lt;/code&gt; или &lt;code&gt;repr&lt;/code&gt; . Наконец, следует определить функцию &lt;code&gt;display(d::D, x)&lt;/code&gt; который запрашивает &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt; для типов &lt;code&gt;mime&lt;/code&gt; , поддерживаемых &lt;code&gt;D&lt;/code&gt; , и отображает &amp;laquo;лучший&amp;raquo;; &lt;code&gt;MethodError&lt;/code&gt; должен быть выброшен , если не поддерживаемые типы MIME не найдены для &lt;code&gt;x&lt;/code&gt; . Точно так же некоторые подтипы могут захотеть переопределить &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt; . (Опять же, следует &lt;code&gt;import Base.display&lt;/code&gt; чтобы добавить новые методы для &lt;code&gt;display&lt;/code&gt; .) Возвращаемые значения этих функций зависят от реализации (поскольку в некоторых случаях может быть полезно вернуть &amp;laquo;дескриптор&amp;raquo; отображения некоторого типа). Затем функции отображения для &lt;code&gt;D&lt;/code&gt; можно вызывать напрямую, но их также можно вызывать автоматически из &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; просто поместив новый дисплей в стек display-backend с помощью:</target>
        </trans-unit>
        <trans-unit id="704ebdff29ebf61fba245cec0a90e4a3393b7079" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.repr-Tuple%7BMIME,Any%7D&quot;&gt;&lt;code&gt;repr(io, mime, x)&lt;/code&gt;&lt;/a&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc544618a386ab5d58649ad21c68fc6a33673b83" translate="yes" xml:space="preserve">
          <source>In order to define automatically the values of this dictionary at startup time, one can use the &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; function in the &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c036b6a91aa7223777701c5e046f12ec492ccc" translate="yes" xml:space="preserve">
          <source>In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method should be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">Для диспетчеризации многоуровневого списка параметрических аргументов часто лучше всего разделить каждый уровень диспетчеризации на отдельные функции.Это может показаться похожим на подход к однодиспетчеризации,но,как мы увидим ниже,он все же более гибкий.</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">Чтобы реализовать такую &lt;code&gt;copy&lt;/code&gt; или &lt;code&gt;copyto!&lt;/code&gt; , конечно, вы должны работать с оболочкой &lt;code&gt;Broadcasted&lt;/code&gt; для вычисления каждого элемента. Это можно сделать двумя основными способами:</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">Чтобы без потерь представлять произвольные потоки байтов, хранящиеся в &lt;code&gt;String&lt;/code&gt; , значение &lt;code&gt;Char&lt;/code&gt; может хранить информацию, которая не может быть преобразована в &lt;code&gt;UInt32&lt;/code&gt; Unicode - преобразование такого &lt;code&gt;Char&lt;/code&gt; в UInt32 вызовет ошибку. &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt; функция может быть использована для запроса ли &lt;code&gt;c&lt;/code&gt; представляет собой допустимый символ Unicode.</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">Чтобы передать эту функцию в C, мы получаем его адрес с помощью макроса &lt;code&gt;@cfunction&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">Чтобы ссылаться на &lt;code&gt;MyType&lt;/code&gt; во всех процессах, &lt;code&gt;DummyModule.jl&lt;/code&gt; должен быть загружен в каждый процесс. Вызов &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; загружает его только для одного процесса. Чтобы загрузить его в каждый процесс, используйте макрос &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt; (начиная с Julia с &lt;code&gt;julia -p 2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">Для поддержки мутации такие объекты обычно размещаются в куче и имеют стабильные адреса памяти. Изменяемый объект похож на небольшой контейнер, который может хранить разные значения с течением времени, и поэтому его можно надежно идентифицировать только по его адресу. Напротив, экземпляр неизменяемого типа связан с определенными значениями поля - значения поля сами по себе говорят вам все об объекте. Принимая решение о том, следует ли сделать тип изменяемым, спросите, будут ли два экземпляра с одинаковыми значениями полей считаться идентичными или им может потребоваться независимое изменение со временем. Если они будут считаться идентичными, тип, вероятно, должен быть неизменным.</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">В других случаях полезно иметь возможность остановить итерацию и сразу перейти к следующей. &lt;code&gt;continue&lt;/code&gt; совершающие ключевое слово это:</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">Другими словами, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt; истинно тогда и только тогда, когда &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; являются одним и тем же объектом и этот объект является типом. Без параметра &lt;code&gt;Type&lt;/code&gt; - это просто абстрактный тип, экземплярами которого являются все объекты типов, включая, конечно, одиночные типы:</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">Другими словами, говоря языком теории типов, параметры типа Джулии &lt;em&gt;инвариантны&lt;/em&gt; , а не &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;ковариантны (или даже контравариантны)&lt;/a&gt; . Это &lt;code&gt;Point{Float64}&lt;/code&gt; из практических соображений: хотя любой экземпляр Point {Float64} может концептуально походить на экземпляр &lt;code&gt;Point{Real}&lt;/code&gt; , эти два типа имеют разные представления в памяти:</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">В частности,это означает,что сверхдлинные и сверхвысокоуровневые кодовые единичные последовательности и их префиксы рассматриваются как один недействительный символ,а не как несколько недействительных символов.Это правило лучше всего объяснить на примере:</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">В частности, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; обычно представляет собой &quot;красивую&quot; версию &lt;code&gt;x&lt;/code&gt; , предназначенную для потребления человеком. См. Также &lt;code&gt;repr(x)&lt;/code&gt; чтобы вместо этого вернуть строку, соответствующую &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; которая может быть ближе к тому, как значение &lt;code&gt;x&lt;/code&gt; будет введено в Julia.</target>
        </trans-unit>
        <trans-unit id="44f2256825b7ba89fb1041db2fbe0f7cb5785da9" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">В частности, если вы определяете &lt;code&gt;function __init__()&lt;/code&gt; в модуле, тогда Джулия вызовет &lt;code&gt;__init__()&lt;/code&gt; сразу &lt;em&gt;после&lt;/em&gt; загрузки модуля (например, путем &lt;code&gt;import&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;require&lt;/code&gt; ) во время выполнения в &lt;em&gt;первый&lt;/em&gt; раз (т.е. &lt;code&gt;__init__&lt;/code&gt; - это вызывается только один раз и только после того, как все операторы в модуле были выполнены). Потому что он вызывается после того , модуль полностью импортируются, любые подмодули или другие импортируемые модули имеют свои &lt;code&gt;__init__&lt;/code&gt; функций называются &lt;em&gt;перед&lt;/em&gt; тем в &lt;code&gt;__init__&lt;/code&gt; модуля вмещающего.</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">В частности, обратите внимание, что &lt;code&gt;LibGit2.free&lt;/code&gt; следует вызывать позже для объекта &lt;code&gt;Ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В частности, обратите внимание, что &lt;code&gt;missing == missing&lt;/code&gt; возвращает &lt;code&gt;missing&lt;/code&gt; , поэтому &lt;code&gt;==&lt;/code&gt; нельзя использовать для проверки того, отсутствует ли значение. Для того, чтобы проверить , является ли &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;missing&lt;/code&gt; , используйте &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">В частности,это означает,что достаточно маленькие неизменяемые значения,такие как целые числа и с плавающей точкой,обычно передаются в функции в регистрах (или в выделенном стеке).</target>
        </trans-unit>
        <trans-unit id="bd271b290661f2d2dcd371ac877e792e11b0ae4c" translate="yes" xml:space="preserve">
          <source>In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</source>
          <target state="translated">Вместо написанного синтаксиса,во время разбора расширяется вызов макроса до возвращаемого результата.Это эквивалентно записи:</target>
        </trans-unit>
        <trans-unit id="f1faf89b83d5028304b1044be098d4330cb094e6" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">На практике, особенно при предоставлении многоразовой функциональности, обычно &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; использует функции Julia, которые устанавливают аргументы, а затем проверяют наличие ошибок, независимо от того, каким образом функция C или Fortran указывает на них, передавая их вызывающей стороне Julia как исключения. Это особенно важно, поскольку API-интерфейсы C и Fortran, как известно, несовместимы в том, как они указывают на условия ошибки. Например, библиотечная функция &lt;code&gt;getenv&lt;/code&gt; C заключена в следующую функцию Julia, которая представляет собой упрощенную версию фактического определения из &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4ee03fd7f1bb01022cf62529b6c1e2c9383e98c5" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804d748c80f6e79bb9e342f1f2304330f7eae29d" translate="yes" xml:space="preserve">
          <source>In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.</source>
          <target state="translated">В принципе,сам парсер Markdown также может быть произвольно расширен пакетами,или может быть использован полностью пользовательский вкус Markdown,но в целом это должно быть ненужным.</target>
        </trans-unit>
        <trans-unit id="f1e4e6ce2511929e6de42c91eafd73bc415389d8" translate="yes" xml:space="preserve">
          <source>In short, it is an immutable dictionary that is a subclass of &lt;code&gt;IO&lt;/code&gt;. It supports standard dictionary operations such as &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, and can also be used as an I/O stream.</source>
          <target state="translated">Короче говоря, это неизменяемый словарь, который является подклассом &lt;code&gt;IO&lt;/code&gt; . Он поддерживает стандартные словарные операции, такие как &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; , а также может использоваться как поток ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="638b74bbfc0d77182896b29b38f7e41990e9ec77" translate="yes" xml:space="preserve">
          <source>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example, instead of initializing &lt;code&gt;a&lt;/code&gt; with zeros, initialize it with:</source>
          <target state="translated">В некоторых приложениях альтернативой обнулению субнормальных чисел является добавление небольшого шума. Например, вместо того, чтобы инициализировать &lt;code&gt;a&lt;/code&gt; нулями, инициализируйте его с помощью:</target>
        </trans-unit>
        <trans-unit id="c0f7478a3f0be2e5b9c7e0905c13888f63fbab1a" translate="yes" xml:space="preserve">
          <source>In some applications, it is convenient to store explicit zero values in a &lt;code&gt;SparseMatrixCSC&lt;/code&gt;. These &lt;em&gt;are&lt;/em&gt; accepted by functions in &lt;code&gt;Base&lt;/code&gt; (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The &lt;a href=&quot;#SparseArrays.nnz&quot;&gt;&lt;code&gt;nnz&lt;/code&gt;&lt;/a&gt; function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt;&lt;code&gt;count(!iszero, x)&lt;/code&gt;&lt;/a&gt;, which inspects every stored element of a sparse matrix. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;, and the in-place &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;, can be used to remove stored zeros from the sparse matrix.</source>
          <target state="translated">В некоторых приложениях удобно хранить явные нулевые значения в &lt;code&gt;SparseMatrixCSC&lt;/code&gt; . Они &lt;em&gt;будут&lt;/em&gt; приняты функциями в &lt;code&gt;Base&lt;/code&gt; (но нет никакой гарантии , что они будут сохранены в изменяющих операциях). Такие явно сохраненные нули обрабатываются многими подпрограммами как структурные ненулевые. Функция &lt;a href=&quot;#SparseArrays.nnz&quot;&gt; &lt;code&gt;nnz&lt;/code&gt; &lt;/a&gt; возвращает количество элементов, явно сохраненных в разреженной структуре данных, включая структурные ненулевые значения. Чтобы подсчитать точное количество числовых ненулевых значений, используйте &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt; &lt;code&gt;count(!iszero, x)&lt;/code&gt; &lt;/a&gt; , который проверяет каждый сохраненный элемент разреженной матрицы. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt; , и dropzeros на месте &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; , можно использовать для удаления сохраненных нулей из разреженной матрицы.</target>
        </trans-unit>
        <trans-unit id="7200ec90f922f3162b688616528f07bbd46b3f3f" translate="yes" xml:space="preserve">
          <source>In some cases changing the value of a &lt;code&gt;const&lt;/code&gt; variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</source>
          <target state="translated">В некоторых случаях изменение значения &lt;code&gt;const&lt;/code&gt; переменной дает предупреждение вместо ошибки. Однако это может привести к непредсказуемому поведению или нарушить состояние вашей программы, поэтому этого следует избегать. Эта функция предназначена только для удобства во время интерактивного использования.</target>
        </trans-unit>
        <trans-unit id="0bca4b7af7b2c3f590b22d6bdc9c439dda8d86d1" translate="yes" xml:space="preserve">
          <source>In some cases it might be convenient not to have to define &lt;code&gt;MyStyle&lt;/code&gt;, in which case you can leverage one of the general broadcast wrappers:</source>
          <target state="translated">В некоторых случаях может быть удобно не определять &lt;code&gt;MyStyle&lt;/code&gt; , и в этом случае вы можете использовать одну из общих широковещательных оберток:</target>
        </trans-unit>
        <trans-unit id="6f5f29a98f7076181fba48634a540b92f8996002" translate="yes" xml:space="preserve">
          <source>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called &lt;em&gt;parallel map&lt;/em&gt;, implemented in Julia as the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; function. For example, we could compute the singular values of several large random matrices in parallel as follows:</source>
          <target state="translated">В некоторых случаях оператор сокращения не требуется, и мы просто хотим применить функцию ко всем целым числам в некотором диапазоне (или, в более общем смысле, ко всем элементам в некоторой коллекции). Это еще одна полезная операция, называемая &lt;em&gt;параллельным отображением&lt;/em&gt; , реализованная в Julia как функция &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; . Например, мы могли бы вычислить сингулярные значения нескольких больших случайных матриц параллельно следующим образом:</target>
        </trans-unit>
        <trans-unit id="6de51e42bc98441adfec5061cc53937870969a7a" translate="yes" xml:space="preserve">
          <source>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for &lt;code&gt;MersenneTwister&lt;/code&gt;, which natively writes random values in an array.</source>
          <target state="translated">В некоторых случаях для данного типа ГСЧ создание массива случайных значений может быть более эффективным с помощью специального метода, чем просто использование техники разделения, описанной ранее. Это, например, случай для &lt;code&gt;MersenneTwister&lt;/code&gt; , который изначально записывает случайные значения в массив.</target>
        </trans-unit>
        <trans-unit id="f953f89be50274569ebdd1d16dd1091ac2cf9f4a" translate="yes" xml:space="preserve">
          <source>In some cases, it is useful to adjust the behavior of &lt;code&gt;show&lt;/code&gt; methods depending on the context. This can be achieved via the &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our &lt;code&gt;show&lt;/code&gt; method when the &lt;code&gt;:compact&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, falling back to the long representation if the property is &lt;code&gt;false&lt;/code&gt; or absent:</source>
          <target state="translated">В некоторых случаях полезно настроить поведение методов &lt;code&gt;show&lt;/code&gt; в зависимости от контекста. Этого можно добиться с помощью типа &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; , который позволяет передавать контекстные свойства вместе с обернутым потоком ввода-вывода. Например, мы можем построить более короткое представление в нашем методе &lt;code&gt;show&lt;/code&gt; , когда для свойства &lt;code&gt;:compact&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , возвращаясь к длинному представлению, если свойство имеет значение &lt;code&gt;false&lt;/code&gt; или отсутствует:</target>
        </trans-unit>
        <trans-unit id="ef681cb1496bc3731bd754661d5504701ec7c4ad" translate="yes" xml:space="preserve">
          <source>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the &lt;code&gt;Sampler&lt;/code&gt; constructor. Let's assume we defined two helper types for &lt;code&gt;Die&lt;/code&gt;, say &lt;code&gt;SamplerDie1&lt;/code&gt; which should be used to generate only few random values, and &lt;code&gt;SamplerDieMany&lt;/code&gt; for many values. We can use those types as follows:</source>
          <target state="translated">В некоторых случаях выбор алгоритма будет зависеть от того, хотите ли вы сгенерировать только несколько значений или большое количество значений. Это обрабатывается с помощью третьего параметра конструктора &lt;code&gt;Sampler&lt;/code&gt; . Предположим, мы определили два вспомогательных типа для &lt;code&gt;Die&lt;/code&gt; , скажем, &lt;code&gt;SamplerDie1&lt;/code&gt; , который следует использовать для генерации только нескольких случайных значений, и &lt;code&gt;SamplerDieMany&lt;/code&gt; для многих значений. Мы можем использовать эти типы следующим образом:</target>
        </trans-unit>
        <trans-unit id="a8e2e50c5e5c4d32f74208fde4cbb36b4d6312f3" translate="yes" xml:space="preserve">
          <source>In some languages, the empty tuple (&lt;code&gt;()&lt;/code&gt;) is considered the canonical form of nothingness. However, in julia it is best thought of as just a regular tuple that happens to contain zero values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5807b7c193c64d46f5bc3d42f551af1a206e90" translate="yes" xml:space="preserve">
          <source>In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bc7cae3ed284ebaa58a72dfb5ca4f122d19b91" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793adcc5e6d1a8b0006e672f0871fab8bd1ee12e" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools-1&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">В некоторых ситуациях вашей функции может потребоваться выделить память как часть своей работы, и это может усложнить простую картину выше. В таких случаях рассмотрите возможность использования одного из перечисленных ниже &lt;a href=&quot;#tools-1&quot;&gt;инструментов&lt;/a&gt; для диагностики проблем или напишите версию своей функции, которая отделяет распределение от его алгоритмических аспектов (см. &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Предварительное распределение выходных данных&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a0f5f99ad11403dc52acb366ff631558f32f389" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; for the tests.</source>
          <target state="translated">На шаге 2 ниже отредактируйте &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; , чтобы изменить исходный код, и &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; для тестов.</target>
        </trans-unit>
        <trans-unit id="18fa22072854af164b60f3647ea657dba3a66a38" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and create any test file of your choosing.</source>
          <target state="translated">На шаге 2 ниже отредактируйте &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; , чтобы изменить исходный код, и создайте любой тестовый файл по вашему выбору.</target>
        </trans-unit>
        <trans-unit id="4a0eaae9f72d9710fb65a9583dfc845568e81d5f" translate="yes" xml:space="preserve">
          <source>In such cases one should redesign the code to avoid the possibility of a race condition or use &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;synchronization primitives&lt;/a&gt;.</source>
          <target state="translated">В таких случаях следует переработать код, чтобы избежать возможности состояния гонки, или использовать &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;примитивы синхронизации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e9e71bba5509813057399a4f8d90c9c53704d76" translate="yes" xml:space="preserve">
          <source>In such cases, the result is always 1-d.</source>
          <target state="translated">В таких случаях результат всегда 1-d.</target>
        </trans-unit>
        <trans-unit id="de5de110f5af15ec4cd1a61e4b555c94b532b3cc" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c795388eedec3a869fe287bc8b5bbacb71a43dbd" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">В языках технических вычислений обычно используются &amp;laquo;векторизованные&amp;raquo; версии функций, которые просто применяют заданную функцию &lt;code&gt;f(x)&lt;/code&gt; к каждому элементу массива &lt;code&gt;A&lt;/code&gt; , чтобы получить новый массив через &lt;code&gt;f(A)&lt;/code&gt; . Такой синтаксис удобен для обработки данных, но в других языках векторизация также часто требуется для повышения производительности: если циклы медленные, &amp;laquo;векторизованная&amp;raquo; версия функции может вызывать быстрый библиотечный код, написанный на языке низкого уровня. В Julia векторизованные функции &lt;em&gt;не&lt;/em&gt; требуются для повышения производительности, и, действительно, часто полезно писать свои собственные циклы (см. &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Советы по производительности&lt;/a&gt; ), но они все же могут быть удобными. Следовательно, &lt;em&gt;любая&lt;/em&gt; функция Жюлиа &lt;code&gt;f&lt;/code&gt; может применяться поэлементно к любому массиву (или другой коллекции) с синтаксисом &lt;code&gt;f.(A)&lt;/code&gt; . Например, &lt;code&gt;sin&lt;/code&gt; можно применить ко всем элементам вектора &lt;code&gt;A&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="1295513c71d65c30e7efa46afbaa35e5c9e76740" translate="yes" xml:space="preserve">
          <source>In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both &lt;code&gt;echo&lt;/code&gt; processes, and the other end of the pipe is read from by the &lt;code&gt;sort&lt;/code&gt; command.</source>
          <target state="translated">С точки зрения систем UNIX, здесь происходит то, что один объект конвейера UNIX создается и записывается обоими &lt;code&gt;echo&lt;/code&gt; процессами, а другой конец канала считывается командой &lt;code&gt;sort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc29b396f06d90d9310efc41817564ce48560df4" translate="yes" xml:space="preserve">
          <source>In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name &lt;code&gt;&amp;delta;&lt;/code&gt; can be entered by typing &lt;code&gt;\delta&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;, or even &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; by &lt;code&gt;\alpha&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\hat&lt;/code&gt;- &lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\_2&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type &lt;code&gt;?&lt;/code&gt; and then paste the symbol.)</source>
          <target state="translated">В Julia REPL и некоторых других средах редактирования Julia вы можете ввести множество математических символов Unicode, набрав имя символа LaTeX с обратной косой чертой и затем табуляцию. Например, имя переменной &lt;code&gt;&amp;delta;&lt;/code&gt; можно ввести , набрав &lt;code&gt;\delta&lt;/code&gt; - &lt;em&gt;вкладка&lt;/em&gt; , или даже &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; на &lt;code&gt;\alpha&lt;/code&gt; - &lt;em&gt;вкладка&lt;/em&gt; - &lt;code&gt;\hat&lt;/code&gt; - &lt;em&gt;вкладка&lt;/em&gt; - &lt;code&gt;\_2&lt;/code&gt; - &lt;em&gt;вкладка&lt;/em&gt; . (Если вы где-то найдете символ, например, в чужом коде, который вы не умеете печатать, справка REPL скажет вам: просто введите &lt;code&gt;?&lt;/code&gt; И затем вставьте символ.)</target>
        </trans-unit>
        <trans-unit id="7569c827c9a13b3faf85c9b20e363a3375ada161" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;@everywhere module Foo&lt;/code&gt; defined &lt;code&gt;Foo&lt;/code&gt; on all nodes. However the call to &lt;code&gt;Foo.foo()&lt;/code&gt; created a new global binding &lt;code&gt;gvar&lt;/code&gt; on the local node, but this was not found on node 2 resulting in an &lt;code&gt;UndefVarError&lt;/code&gt; error.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;@everywhere module Foo&lt;/code&gt; определил &lt;code&gt;Foo&lt;/code&gt; на всех узлах. Однако вызов &lt;code&gt;Foo.foo()&lt;/code&gt; создал новую глобальную привязку &lt;code&gt;gvar&lt;/code&gt; на локальном узле, но она не была найдена на узле 2, что привело к ошибке &lt;code&gt;UndefVarError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4befd8beabfc58d36d63a701ccb0fcbe3c3991f4" translate="yes" xml:space="preserve">
          <source>In the absence of a type declaration with &lt;code&gt;::&lt;/code&gt;, the type of a method parameter is &lt;code&gt;Any&lt;/code&gt; by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type &lt;code&gt;Any&lt;/code&gt;. Thus, we can define a catch-all method for &lt;code&gt;f&lt;/code&gt; like so:</source>
          <target state="translated">При отсутствии объявления типа с &lt;code&gt;::&lt;/code&gt; типом параметра метода по умолчанию является &lt;code&gt;Any&lt;/code&gt; , что означает, что он не ограничен, поскольку все значения в Julia являются экземплярами абстрактного типа &lt;code&gt;Any&lt;/code&gt; . Таким образом, мы можем определить универсальный метод для &lt;code&gt;f&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="804c2e460ca33d08a52c531b866706df762bfe07" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e6eb62fa9a3db0a4d3297fcd4c7b6e7504f490" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">В форме присваивания тело функции должно быть единственным выражением, хотя оно может быть составным выражением (см. &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Составные выражения&lt;/a&gt; ). В Julia часто встречаются короткие и простые определения функций. Соответственно, краткий синтаксис функций довольно идиоматичен, что значительно снижает как печатный, так и визуальный шум.</target>
        </trans-unit>
        <trans-unit id="8b4a822ba35b7b2a2b87214b87f56abe71bd6a7e" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values &amp;ndash; and any function that was defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function.</source>
          <target state="translated">В теле сгенерированной функции у вас есть доступ только к &lt;em&gt;типам&lt;/em&gt; аргументов - но не к их значениям - и к любой функции, которая была определена &lt;em&gt;до&lt;/em&gt; определения сгенерированной функции.</target>
        </trans-unit>
        <trans-unit id="50c2c4d1cb9a5c5c26d9acf8cbb1ac2672dac8d1" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f8a53fe3cbe9ccdbd0383d96fd01b1b384f1cc" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;Point&lt;/code&gt;, the type of &lt;code&gt;T&lt;/code&gt; is unambiguously implied if and only if the two arguments to &lt;code&gt;Point&lt;/code&gt; have the same type. When this isn't the case, the constructor will fail with a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В случае &lt;code&gt;Point&lt;/code&gt; тип &lt;code&gt;T&lt;/code&gt; однозначно подразумевается тогда и только тогда, когда два аргумента &lt;code&gt;Point&lt;/code&gt; имеют один и тот же тип. Если это не так, конструктор завершится ошибкой &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8083b5b25cdad6fa0ec0e103815341575e54f6a2" translate="yes" xml:space="preserve">
          <source>In the case that the type of &lt;code&gt;a[1]&lt;/code&gt; is not known precisely, &lt;code&gt;x&lt;/code&gt; can be declared via &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt;. The use of the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function allows &lt;code&gt;a[1]&lt;/code&gt; to be any object convertible to an &lt;code&gt;Int32&lt;/code&gt; (such as &lt;code&gt;UInt8&lt;/code&gt;), thus increasing the genericity of the code by loosening the type requirement. Notice that &lt;code&gt;convert&lt;/code&gt; itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even &lt;code&gt;convert&lt;/code&gt;, unless the types of all the function's arguments are known.</source>
          <target state="translated">В случае, если тип &lt;code&gt;a[1]&lt;/code&gt; точно не известен, &lt;code&gt;x&lt;/code&gt; можно объявить через &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt; . Использование функции &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; позволяет &lt;code&gt;a[1]&lt;/code&gt; быть любым объектом, конвертируемым в &lt;code&gt;Int32&lt;/code&gt; (например, &lt;code&gt;UInt8&lt;/code&gt; ), тем самым повышая универсальность кода за счет ослабления требований к типу. Обратите внимание, что &lt;code&gt;convert&lt;/code&gt; само по себе требует аннотации типа в этом контексте для достижения стабильности типа. Это связано с тем, что компилятор не может определить тип возвращаемого значения функции, даже &lt;code&gt;convert&lt;/code&gt; , если не известны типы всех аргументов функции.</target>
        </trans-unit>
        <trans-unit id="7c1119f311ce545842278fe205e3f9855f274299" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831b049ac64422357fdc2a1f1e12b98990a72d96" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">В контексте выражения символы используются для обозначения доступа к переменным; когда выражение оценивается, символ заменяется значением, связанным с этим символом в соответствующей &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;области&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0ccf20285ac1f5e0c9e737c0f406f1f62a6d45" translate="yes" xml:space="preserve">
          <source>In the context of function definitions, the &lt;code&gt;...&lt;/code&gt; operator is used to combine many different arguments into a single argument. This use of &lt;code&gt;...&lt;/code&gt; for combining many different arguments into a single argument is called slurping:</source>
          <target state="translated">В контексте определений функций оператор &lt;code&gt;...&lt;/code&gt; используется для объединения множества разных аргументов в один аргумент. Такое использование &lt;code&gt;...&lt;/code&gt; для объединения множества разных аргументов в один называется прихлебанием:</target>
        </trans-unit>
        <trans-unit id="93652cdf53268e5b525c9968aae662e21595f44e" translate="yes" xml:space="preserve">
          <source>In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process across multiple cores or machines. Also we will mention useful external packages for distributed programming like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">В конце мы представим подход Юлии к распределенным и параллельным вычислениям. Помня о научных вычислениях, Джулия изначально реализует интерфейсы для распределения процесса между несколькими ядрами или машинами. Также мы упомянем полезные внешние пакеты для распределенного программирования, такие как &lt;code&gt;MPI.jl&lt;/code&gt; и &lt;code&gt;DistributedArrays.jl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d323acfd53199deb66ce97dad2e67a0a4f124fda" translate="yes" xml:space="preserve">
          <source>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</source>
          <target state="translated">В случае,если вложенный тестовый набор не имеет сбоев,как это случилось здесь,он будет скрыт в сводке.Если у нас все-таки будет сбой в тесте,то будут показаны только детали для неудачных наборов тестов:</target>
        </trans-unit>
        <trans-unit id="381773d3ab62fd2b5a03a4a6a4af80e1db7c0e67" translate="yes" xml:space="preserve">
          <source>In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; provide non-standard string literal &lt;code&gt;@x_str&lt;/code&gt;, then one can write &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; or &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; to disambiguate between the two.</source>
          <target state="translated">В случае, если два модуля предоставляют нестандартные строковые или командные литералы с одинаковым именем, можно квалифицировать строковый или командный литерал с именем модуля. Например, если и &lt;code&gt;Foo&lt;/code&gt; , и &lt;code&gt;Bar&lt;/code&gt; предоставляют нестандартный строковый литерал &lt;code&gt;@x_str&lt;/code&gt; , тогда можно написать &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; или &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; чтобы устранить неоднозначность между ними.</target>
        </trans-unit>
        <trans-unit id="9a888754236863b7dc502d80ea92bd70226cbd16" translate="yes" xml:space="preserve">
          <source>In the example above, the code between &lt;code&gt;#=&lt;/code&gt; and &lt;code&gt;=#&lt;/code&gt; is run as a &lt;code&gt;bash&lt;/code&gt; script. Julia ignores this part since it is a multi-line comment for Julia. The Julia code after &lt;code&gt;=#&lt;/code&gt; is ignored by &lt;code&gt;bash&lt;/code&gt; since it stops parsing the file once it reaches to the &lt;code&gt;exec&lt;/code&gt; statement.</source>
          <target state="translated">В приведенном выше примере код между &lt;code&gt;#=&lt;/code&gt; и &lt;code&gt;=#&lt;/code&gt; запускается как сценарий &lt;code&gt;bash&lt;/code&gt; . Джулия игнорирует эту часть, так как это многострочный комментарий для Джулии. Код Julia после &lt;code&gt;=#&lt;/code&gt; игнорируется &lt;code&gt;bash&lt;/code&gt; , поскольку он прекращает синтаксический анализ файла, когда достигает оператора &lt;code&gt;exec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fab8ccf3e309196934d3171621e67c5c348c19f" translate="yes" xml:space="preserve">
          <source>In the example below the in-range check for referencing element &lt;code&gt;i&lt;/code&gt; of array &lt;code&gt;A&lt;/code&gt; is skipped to improve performance.</source>
          <target state="translated">В приведенном ниже примере проверка на предмет наличия ссылки на элемент &lt;code&gt;i&lt;/code&gt; массива &lt;code&gt;A&lt;/code&gt; пропускается для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="93579590b1d00912366971a9f1eaa55dfd5a9050" translate="yes" xml:space="preserve">
          <source>In the example manifest file above, to find the path of the first &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;&amp;mdash;Julia looks for its stanza in the manifest file, sees that it has a &lt;code&gt;path&lt;/code&gt; entry, looks at &lt;code&gt;deps/Priv&lt;/code&gt; relative to the &lt;code&gt;App&lt;/code&gt; project directory&amp;mdash;let's suppose the &lt;code&gt;App&lt;/code&gt; code lives in &lt;code&gt;/home/me/projects/App&lt;/code&gt;&amp;mdash;sees that &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; exists and therefore loads &lt;code&gt;Priv&lt;/code&gt; from there.</source>
          <target state="translated">В этом примере файл манифеста выше, чтобы найти путь к первой &lt;code&gt;Priv&lt;/code&gt; пакета-один с UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; -Julia ищет его строфы в файле манифеста, видит , что у него есть &lt;code&gt;path&lt;/code&gt; записи, внешний вид в &lt;code&gt;deps/Priv&lt;/code&gt; относительно каталога проекта &lt;code&gt;App&lt;/code&gt; - предположим, что код &lt;code&gt;App&lt;/code&gt; в &lt;code&gt;/home/me/projects/App&lt;/code&gt; - видит, что &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; существует, и поэтому загружает &lt;code&gt;Priv&lt;/code&gt; оттуда.</target>
        </trans-unit>
        <trans-unit id="d5f7b0ad7d3e9a880bbfbe0e4c7c117bb4c01b0c" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt;, each &lt;code&gt;I_k&lt;/code&gt; may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В выражении &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; каждый &lt;code&gt;I_k&lt;/code&gt; может быть скалярным индексом, массивом скалярных индексов или объектом, который представляет массив скалярных индексов и может быть преобразован в таковой с помощью &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fa27a03548fec1bfca9a5a7f95888f72d9a7ae58" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">В выражении &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; подвыражение &lt;code&gt;b&lt;/code&gt; оценивается, только если &lt;code&gt;a&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bac07dea1e6da71dd93fed592d9cea2988762e4a" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a || b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">В выражении &lt;code&gt;a || b&lt;/code&gt; , подвыражение &lt;code&gt;b&lt;/code&gt; оценивается, только если &lt;code&gt;a&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96db94e2ee75dc648cf0225c95d894886287a60b" translate="yes" xml:space="preserve">
          <source>In the first example, the return breaks out of &lt;code&gt;test1&lt;/code&gt; as soon as it hits an even number, so &lt;code&gt;test1([5,6,7])&lt;/code&gt; returns &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">В первом примере return прерывается из &lt;code&gt;test1&lt;/code&gt; , как только встречается четное число, поэтому &lt;code&gt;test1([5,6,7])&lt;/code&gt; возвращает &lt;code&gt;12&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b8c088e43cc4d9778c3e9bd051248b7beb86cd4" translate="yes" xml:space="preserve">
          <source>In the first step, a handle to the Julia function &lt;code&gt;sqrt&lt;/code&gt; is retrieved by calling &lt;code&gt;jl_get_function&lt;/code&gt;. The first argument passed to &lt;code&gt;jl_get_function&lt;/code&gt; is a pointer to the &lt;code&gt;Base&lt;/code&gt; module in which &lt;code&gt;sqrt&lt;/code&gt; is defined. Then, the double value is boxed using &lt;code&gt;jl_box_float64&lt;/code&gt;. Finally, in the last step, the function is called using &lt;code&gt;jl_call1&lt;/code&gt;. &lt;code&gt;jl_call0&lt;/code&gt;, &lt;code&gt;jl_call2&lt;/code&gt;, and &lt;code&gt;jl_call3&lt;/code&gt; functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">На первом этапе дескриптор функции Julia &lt;code&gt;sqrt&lt;/code&gt; извлекается путем вызова &lt;code&gt;jl_get_function&lt;/code&gt; . Первый аргумент, переданный &lt;code&gt;jl_get_function&lt;/code&gt; , - это указатель на &lt;code&gt;Base&lt;/code&gt; модуль, в котором определен &lt;code&gt;sqrt&lt;/code&gt; . Затем двойное значение &lt;code&gt;jl_box_float64&lt;/code&gt; коробку с использованием jl_box_float64 . Наконец, на последнем шаге функция вызывается с использованием &lt;code&gt;jl_call1&lt;/code&gt; . Также существуют функции &lt;code&gt;jl_call0&lt;/code&gt; , &lt;code&gt;jl_call2&lt;/code&gt; и &lt;code&gt;jl_call3&lt;/code&gt; для удобной обработки различного количества аргументов. Чтобы передать больше аргументов, используйте &lt;code&gt;jl_call&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7b958da57c917010bf3ef94ad88b96d1969aed7b" translate="yes" xml:space="preserve">
          <source>In the following REPL session:</source>
          <target state="translated">На следующем сеансе REPL:</target>
        </trans-unit>
        <trans-unit id="c8932c25606bd0610c3cdf0d60756b479ad881b6" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes and call a generic function on it.</source>
          <target state="translated">В следующем примере мы будем использовать как &lt;code&gt;DistributedArrays.jl&lt;/code&gt; ,так и &lt;code&gt;CuArrays.jl&lt;/code&gt; для распределения массива по нескольким процессам и вызова для него общей функции.</target>
        </trans-unit>
        <trans-unit id="7ef78cc2f03187abe5d3245512be5e3c871b1647" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes by first casting it through &lt;code&gt;distribute()&lt;/code&gt; and &lt;code&gt;CuArray()&lt;/code&gt;.</source>
          <target state="translated">В следующем примере мы будем использовать как &lt;code&gt;DistributedArrays.jl&lt;/code&gt; ,так и &lt;code&gt;CuArrays.jl&lt;/code&gt; для распределения массива по нескольким процессам, сначала &lt;code&gt;CuArray()&lt;/code&gt; его через &lt;code&gt;distribute()&lt;/code&gt; и CuArray () .</target>
        </trans-unit>
        <trans-unit id="eddb2dbc7e71b5027d64a28a0762a40add354815" translate="yes" xml:space="preserve">
          <source>In the following examples &lt;code&gt;&quot;...&quot;&lt;/code&gt; is used to illustrate an arbitrary docstring.</source>
          <target state="translated">В следующих примерах &lt;code&gt;&quot;...&quot;&lt;/code&gt; используется для иллюстрации произвольной строки документации.</target>
        </trans-unit>
        <trans-unit id="89782f85382fa4913d7651a1e194d5e19db89926" translate="yes" xml:space="preserve">
          <source>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</source>
          <target state="translated">В следующих разделах мы кратко рассмотрим несколько техник,которые могут помочь сделать ваш код Julia как можно быстрее.</target>
        </trans-unit>
        <trans-unit id="04625a717e704769cefecb369eb2164fdede25ee" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</source>
          <target state="translated">В первом случае целые числа расширяются до размера системного слова,в результате чего получается 128.Во втором случае такого расширения не происходит и целочисленное переполнение приводит к -128.</target>
        </trans-unit>
        <trans-unit id="96b938fab6579b9bca905e7cf7ff960b0076051e" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is &lt;code&gt;Int64[100, 128]&lt;/code&gt;. In the latter case, no such widening happens and integer overflow results in &lt;code&gt;Int8[100, -128]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459cd312cf19872b6f89a3fcbc8f7c42d8e4d02e" translate="yes" xml:space="preserve">
          <source>In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">В последнем примере создается &lt;code&gt;Vector{Any}&lt;/code&gt; ; причина в том, что &lt;code&gt;eltype(Die) == Any&lt;/code&gt; . Чтобы исправить это, нужно определить &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cbf68db8681a41c42664645e9482a6f5917d216" translate="yes" xml:space="preserve">
          <source>In the latter case, the result type is &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigInt&lt;/code&gt; is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; and &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash; the symmetry is implied by the way &lt;code&gt;promote_rule&lt;/code&gt; is used in the promotion process.</source>
          <target state="translated">В последнем случае тип результата - &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; ,&lt;/a&gt; поскольку &lt;code&gt;BigInt&lt;/code&gt; - единственный тип, достаточно большой для хранения целых чисел для целочисленной арифметики произвольной точности. Также обратите внимание на то, что не нужно определять и &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; и &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; - симметрия подразумевается способ &lt;code&gt;promote_rule&lt;/code&gt; используется в процессе продвижения.</target>
        </trans-unit>
        <trans-unit id="53f7c1a582426e8808f0c1bf813e62ee2f97e7c7" translate="yes" xml:space="preserve">
          <source>In the meantime, overflow-safe integer operations can be achieved through the use of external libraries such as &lt;a href=&quot;https://github.com/JeffreySarnoff/SaferIntegers.jl&quot;&gt;SaferIntegers.jl&lt;/a&gt;. Note that, as stated previously, the use of these libraries significantly increases the execution time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it were used for all integer operations. You can follow the status of the discussion &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/855&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898e17acc6c8cf82e0dc07003deafaedea5b3686" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can get the result you want by choosing an &lt;em&gt;input type&lt;/em&gt; that conveys your willingness to accept an &lt;em&gt;output type&lt;/em&gt; in which the result can be represented:</source>
          <target state="translated">В этих и других случаях вы можете получить желаемый результат, выбрав &lt;em&gt;тип ввода,&lt;/em&gt; который выражает вашу готовность принять &lt;em&gt;тип вывода,&lt;/em&gt; в котором может быть представлен результат:</target>
        </trans-unit>
        <trans-unit id="0181a5895aa6ed6a57ecf3e1abb5400987bdae76" translate="yes" xml:space="preserve">
          <source>In these examples, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt;, which has two fields. &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;, which is a primitive bitstype with no fields at all. &lt;code&gt;ex&lt;/code&gt; is an &lt;a href=&quot;#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt;, which has one field.</source>
          <target state="translated">В этих примерах &lt;code&gt;a&lt;/code&gt; - это &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; , у которого есть два поля. &lt;code&gt;b&lt;/code&gt; - это &lt;code&gt;Int&lt;/code&gt; , который представляет собой примитивный битовый тип без полей вообще. &lt;code&gt;ex&lt;/code&gt; - &lt;a href=&quot;#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; , которое имеет одно поле.</target>
        </trans-unit>
        <trans-unit id="e95b83474ed0f82b1495ebdd8823b0e63d6666c2" translate="yes" xml:space="preserve">
          <source>In this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.</source>
          <target state="translated">В этом и всех последующих примерах предполагается,что их верхний уровень представляет собой глобальный масштаб с чистым рабочим пространством,например,недавно запущенная REPL.</target>
        </trans-unit>
        <trans-unit id="ffae775fe01ba274356f2a5f0bbbfa16bf832464" translate="yes" xml:space="preserve">
          <source>In this case &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; MUST be defined in the remote process. Note that &lt;code&gt;A&lt;/code&gt; is a global variable defined in the local workspace. Worker 2 does not have a variable called &lt;code&gt;A&lt;/code&gt; under &lt;code&gt;Main&lt;/code&gt;. The act of shipping the closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; to worker 2 results in &lt;code&gt;Main.A&lt;/code&gt; being defined on 2. &lt;code&gt;Main.A&lt;/code&gt; continues to exist on worker 2 even after the call &lt;code&gt;remotecall_fetch&lt;/code&gt; returns. Remote calls with embedded global references (under &lt;code&gt;Main&lt;/code&gt; module only) manage globals as follows:</source>
          <target state="translated">В этом случае &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; ДОЛЖНА быть определена в удаленном процессе. Обратите внимание, что &lt;code&gt;A&lt;/code&gt; - это глобальная переменная, определенная в локальной рабочей области. Рабочий 2 не имеет переменной с именем &lt;code&gt;A&lt;/code&gt; в разделе &lt;code&gt;Main&lt;/code&gt; . Акт доставки closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; к worker 2 приводит к &lt;code&gt;Main.A&lt;/code&gt; что Main.A определяется на 2. &lt;code&gt;Main.A&lt;/code&gt; продолжает существовать на worker 2 даже после &lt;code&gt;remotecall_fetch&lt;/code&gt; вызова remotecall_fetch . Удаленные вызовы со встроенными глобальными ссылками (только в &lt;code&gt;Main&lt;/code&gt; модуле) управляют глобальными объектами следующим образом:</target>
        </trans-unit>
        <trans-unit id="0560676ee24f0b0b03f58f97d95e6f878eed22df" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; is better. It is also more helpful to the compiler to annotate specific uses (e.g. &lt;code&gt;a[i]::Int&lt;/code&gt;) than to try to pack many alternatives into one type.</source>
          <target state="translated">В этом случае лучше использовать &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; . Для компилятора также более полезно аннотировать конкретные варианты использования (например, &lt;code&gt;a[i]::Int&lt;/code&gt; ), чем пытаться упаковать множество альтернатив в один тип.</target>
        </trans-unit>
        <trans-unit id="e89af6907bd5ca30fed3e340c7ce252f260cfa01" translate="yes" xml:space="preserve">
          <source>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</source>
          <target state="translated">В этом случае кортеж значений сплайнируется в вызов varargs,где точно передается переменное количество аргументов.Однако в этом нет необходимости:</target>
        </trans-unit>
        <trans-unit id="567cd07e5f348036853e90930a72f1f415e7cf4a" translate="yes" xml:space="preserve">
          <source>In this case the final (empty) line before the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; sets the indentation level.</source>
          <target state="translated">В этом случае последняя (пустая) строка перед закрывающим &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; устанавливает уровень отступа.</target>
        </trans-unit>
        <trans-unit id="192b075c1bd1fea405ec3cb3c290131367b6aebf" translate="yes" xml:space="preserve">
          <source>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if &lt;code&gt;q[i,j,t]&lt;/code&gt; is near the end of the block assigned to one worker and &lt;code&gt;q[i,j,t+1]&lt;/code&gt; is near the beginning of the block assigned to another, it's very likely that &lt;code&gt;q[i,j,t]&lt;/code&gt; will not be ready at the time it's needed for computing &lt;code&gt;q[i,j,t+1]&lt;/code&gt;. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the &lt;code&gt;(irange, jrange)&lt;/code&gt; indices assigned to this worker:</source>
          <target state="translated">В этом случае, если мы попытаемся разделить работу с помощью одномерного индекса, мы, скорее всего, столкнемся с проблемой: если &lt;code&gt;q[i,j,t]&lt;/code&gt; находится рядом с концом блока, назначенного одному работнику, а &lt;code&gt;q[i,j,t+1]&lt;/code&gt; находится рядом с началом блока, назначенного другому, очень вероятно, что &lt;code&gt;q[i,j,t]&lt;/code&gt; не будет готов в то время, когда это необходимо для вычисления &lt;code&gt;q[i,j,t+1]&lt;/code&gt; . В таких случаях лучше разбить массив вручную. Давайте разделим по второму измерению. Определите функцию, которая возвращает &lt;code&gt;(irange, jrange)&lt;/code&gt; назначенные этому работнику:</target>
        </trans-unit>
        <trans-unit id="b26744f8a00507231770f287451074d8e90f3846" translate="yes" xml:space="preserve">
          <source>In this case, the character &lt;code&gt;&amp;forall;&lt;/code&gt; is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind(s,1)&lt;/code&gt;&lt;/a&gt;, and the next index after that by &lt;code&gt;nextind(s,4)&lt;/code&gt; and so on.</source>
          <target state="translated">В этом случае символ &lt;code&gt;&amp;forall;&lt;/code&gt; является трехбайтовым символом, поэтому индексы 2 и 3 недействительны, а индекс следующего символа равен 4; этот следующий действительный индекс может быть вычислен с помощью &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind(s,1)&lt;/code&gt; &lt;/a&gt; , а следующий индекс после этого - с помощью &lt;code&gt;nextind(s,4)&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="e5db3b629f524d1fec7f4ffc91f2ae6bde25d1db" translate="yes" xml:space="preserve">
          <source>In this case, the speedup due to &lt;code&gt;@fastmath&lt;/code&gt; is a factor of about 3.7. This is unusually large &amp;ndash; in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result &amp;ndash; in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</source>
          <target state="translated">В этом случае ускорение за счет &lt;code&gt;@fastmath&lt;/code&gt; составляет примерно 3,7 раза. Это необычно много - в целом ускорение будет меньше. (В этом конкретном примере рабочий набор теста достаточно мал, чтобы поместиться в кэш L1 процессора, так что задержка доступа к памяти не играет роли, а время вычислений зависит от использования ЦП. Во многих реальных программах это не так.) Также в этом случае данная оптимизация не меняет результат - в целом результат будет немного другим. В некоторых случаях, особенно для численно нестабильных алгоритмов, результат может сильно отличаться.</target>
        </trans-unit>
        <trans-unit id="6188940203c290544c44a0f6a7e7493e9e0ab89b" translate="yes" xml:space="preserve">
          <source>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;.</source>
          <target state="translated">В этом контексте MPI относится к стандарту MPI-1. Начиная с MPI-2, комитет по стандартам MPI представил новый набор механизмов связи, вместе именуемых удаленным доступом к памяти (RMA). Мотивом добавления rma к стандарту MPI было облегчение односторонних шаблонов связи. Для получения дополнительной информации о последнем стандарте MPI см. &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;Https://mpi-forum.org/docs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92a7a3f559dc2f0e3123bf1d2da5d1162f830e7c" translate="yes" xml:space="preserve">
          <source>In this example it is accomplished by defining &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; to create the appropriate wrapped array. (Note that while &lt;code&gt;similar&lt;/code&gt; supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that &lt;code&gt;SparseArray&lt;/code&gt; is mutable (supports &lt;code&gt;setindex!&lt;/code&gt;). Defining &lt;code&gt;similar&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt; and &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; also makes it possible to &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; the array:</source>
          <target state="translated">В этом примере это достигается путем определения &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; для создания соответствующего обернутого массива. (Обратите внимание, что, хотя &lt;code&gt;similar&lt;/code&gt; поддерживает формы с 1 и 2 аргументами, в большинстве случаев вам нужно только специализировать форму с 3 аргументами.) Для этого важно, чтобы &lt;code&gt;SparseArray&lt;/code&gt; был изменяемым (поддерживает &lt;code&gt;setindex!&lt;/code&gt; ). Определение &lt;code&gt;similar&lt;/code&gt; , &lt;code&gt;getindex&lt;/code&gt; и &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; также позволяет &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; массив:</target>
        </trans-unit>
        <trans-unit id="05a24eb92f7d5686dff145712d9c9981f290a66e" translate="yes" xml:space="preserve">
          <source>In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.</source>
          <target state="translated">В этом примере исключение корневой причины (A)сначала находится на стеке,а затем следует еще одно исключение (B).После выхода из обоих блоков catch обычно (т.е.без броска следующего исключения)все исключения удаляются из стека и больше не доступны.</target>
        </trans-unit>
        <trans-unit id="4336cae1e8edd1087fd9411fb166bd6a222c2c06" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;A&lt;/code&gt; is a mutable container that contains one element, which can be set by &lt;code&gt;A[] = 1.0&lt;/code&gt; and retrieved with &lt;code&gt;A[]&lt;/code&gt;. All zero-dimensional arrays have the same size (&lt;code&gt;size(A) == ()&lt;/code&gt;), and length (&lt;code&gt;length(A) == 1&lt;/code&gt;). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</source>
          <target state="translated">В этом примере &lt;code&gt;A&lt;/code&gt; - изменяемый контейнер, содержащий один элемент, который может быть установлен с помощью &lt;code&gt;A[] = 1.0&lt;/code&gt; и извлечен с помощью &lt;code&gt;A[]&lt;/code&gt; . Все нулевые массивы имеют одинаковый размер ( &lt;code&gt;size(A) == ()&lt;/code&gt; ) и длину ( &lt;code&gt;length(A) == 1&lt;/code&gt; ). В частности, нульмерные массивы не пусты. Если вам это покажется нелогичным, вот несколько идей, которые могут помочь понять определение Джулии.</target>
        </trans-unit>
        <trans-unit id="6a0bf2dc540c812cb1923adeb5876321d55dbf26" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;N&lt;/code&gt; is passed as a parameter, so its &quot;value&quot; is known to the compiler. Essentially, &lt;code&gt;Val(T)&lt;/code&gt; works only when &lt;code&gt;T&lt;/code&gt; is either hard-coded/literal (&lt;code&gt;Val(3)&lt;/code&gt;) or already specified in the type-domain.</source>
          <target state="translated">В этом примере &lt;code&gt;N&lt;/code&gt; передается как параметр, поэтому его &quot;значение&quot; известно компилятору. По сути, &lt;code&gt;Val(T)&lt;/code&gt; работает только тогда, когда &lt;code&gt;T&lt;/code&gt; либо жестко запрограммирован / литерал ( &lt;code&gt;Val(3)&lt;/code&gt; ), либо уже указан в типовой области.</target>
        </trans-unit>
        <trans-unit id="92f4b81b4c3f20308317f94d5766f434fb02e58c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;b&lt;/code&gt; is a runnable &lt;code&gt;Task&lt;/code&gt; that hasn't started yet.</source>
          <target state="translated">В этом примере &lt;code&gt;b&lt;/code&gt; - это выполняемая &lt;code&gt;Task&lt;/code&gt; которая еще не началась.</target>
        </trans-unit>
        <trans-unit id="9f7bc1ef4d38fd2e360681f2040c8ad0f73774eb" translate="yes" xml:space="preserve">
          <source>In this example, observe that the new definition for &lt;code&gt;newfun&lt;/code&gt; has been created, but can't be immediately called. The new global is immediately visible to the &lt;code&gt;tryeval&lt;/code&gt; function, so you could write &lt;code&gt;return newfun&lt;/code&gt; (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</source>
          <target state="translated">В этом примере &lt;code&gt;newfun&lt;/code&gt; внимание, что новое определение для newfun было создано, но не может быть немедленно вызвано . Новый глобал сразу виден функции &lt;code&gt;tryeval&lt;/code&gt; , поэтому вы можете написать &lt;code&gt;return newfun&lt;/code&gt; (без скобок). Но ни вы, ни кто-либо из ваших вызывающих, ни вызываемые ими функции и т. Д. Не можете вызывать это новое определение метода!</target>
        </trans-unit>
        <trans-unit id="f0f0d16b1aed858c0d51da9625d8755a2c35d48e" translate="yes" xml:space="preserve">
          <source>In this example, the remote which is being fetched from &lt;em&gt;does&lt;/em&gt; have a file called &lt;code&gt;our_file&lt;/code&gt; in its index, which is why we must reset.</source>
          <target state="translated">В этом примере удаленный пульт, из &lt;em&gt;которого&lt;/em&gt; выполняется &lt;code&gt;our_file&lt;/code&gt; в своем индексе файл с именем our_file , поэтому мы должны выполнить сброс.</target>
        </trans-unit>
        <trans-unit id="a138591f083f547736d80bd3d40dd03ced901f2b" translate="yes" xml:space="preserve">
          <source>In this example, the task ran on pid 2, called from pid 1.</source>
          <target state="translated">В данном примере задача выполнялась на пайде 2,вызываемом из пайда 1.</target>
        </trans-unit>
        <trans-unit id="f39c0221e85d683a6f4024da4ca9271cf6b8c812" translate="yes" xml:space="preserve">
          <source>In this example, the tuple &lt;code&gt;(1,2,3)&lt;/code&gt; is interpolated as an expression into a conditional test:</source>
          <target state="translated">В этом примере кортеж &lt;code&gt;(1,2,3)&lt;/code&gt; интерполируется как выражение в условный тест:</target>
        </trans-unit>
        <trans-unit id="a8e780cf12ef36b63b08a74c8c07d0b380150440" translate="yes" xml:space="preserve">
          <source>In this example, the value of variable &lt;code&gt;a&lt;/code&gt; is interpolated:</source>
          <target state="translated">В этом примере значение переменной &lt;code&gt;a&lt;/code&gt; интерполируется:</target>
        </trans-unit>
        <trans-unit id="d77924d6298476fc4b219142016e1167310fe63c" translate="yes" xml:space="preserve">
          <source>In this example, we can see that the top level function called is in the file &lt;code&gt;event.jl&lt;/code&gt;. This is the function that runs the REPL when you launch Julia. If you examine line 97 of &lt;code&gt;REPL.jl&lt;/code&gt;, you'll see this is where the function &lt;code&gt;eval_user_input()&lt;/code&gt; is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered &lt;code&gt;@profile myfunc()&lt;/code&gt;. The next line reflects actions taken in the &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt;&lt;code&gt;@profile&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">В этом примере мы видим, что вызываемая функция верхнего уровня находится в файле &lt;code&gt;event.jl&lt;/code&gt; . Это функция, которая запускает REPL при запуске Julia. Если вы изучите строку 97 &lt;code&gt;REPL.jl&lt;/code&gt; , вы увидите, что именно здесь вызывается функция &lt;code&gt;eval_user_input()&lt;/code&gt; . Это функция, которая оценивает то, что вы вводите в REPL, и, поскольку мы работаем в интерактивном режиме, эти функции были вызваны, когда мы ввели &lt;code&gt;@profile myfunc()&lt;/code&gt; . Следующая строка отражает действия, предпринятые в макросе &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt; &lt;code&gt;@profile&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c91076ff3785f6e6c7acf1c7077368cdbb7151f" translate="yes" xml:space="preserve">
          <source>In this manner, Julia acts as its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocessor&lt;/a&gt;, and allows code generation from inside the language. The above code could be written slightly more tersely using the &lt;code&gt;:&lt;/code&gt; prefix quoting form:</source>
          <target state="translated">Таким образом, Julia действует как собственный &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;препроцессор&lt;/a&gt; и позволяет генерировать код изнутри языка. Приведенный выше код может быть написано немного более сжато , используя &lt;code&gt;:&lt;/code&gt; префикс квотирования формы:</target>
        </trans-unit>
        <trans-unit id="7bd6fc4b177020a8a663dcee2fb9c4c397754164" translate="yes" xml:space="preserve">
          <source>In this module we export the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; functions (with the keyword &lt;code&gt;export&lt;/code&gt;), and also have the non-exported function &lt;code&gt;p&lt;/code&gt;. There are several different ways to load the Module and its inner functions into the current workspace:</source>
          <target state="translated">В этом модуле мы экспортируем функции &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; (с ключевым словом &lt;code&gt;export&lt;/code&gt; ), а также имеем неэкспортированную функцию &lt;code&gt;p&lt;/code&gt; . Есть несколько разных способов загрузить модуль и его внутренние функции в текущую рабочую область:</target>
        </trans-unit>
        <trans-unit id="dcdbf4c0d317d8b968227eee1bb592e9cd8a0e88" translate="yes" xml:space="preserve">
          <source>In this particular case, the number of elements skipped &lt;em&gt;in memory&lt;/em&gt; matches the number of &lt;em&gt;linear indices&lt;/em&gt; skipped. This is only the case for contiguous arrays like &lt;code&gt;Array&lt;/code&gt; (and other &lt;code&gt;DenseArray&lt;/code&gt; subtypes) and is not true in general. Views with range indices are a good example of &lt;em&gt;non-contiguous&lt;/em&gt; strided arrays; consider &lt;code&gt;V = @view A[1:3:4, 2:2:6, 2:-1:1]&lt;/code&gt;. This view &lt;code&gt;V&lt;/code&gt; refers to the same memory as &lt;code&gt;A&lt;/code&gt; but is skipping and re-arranging some of its elements. The stride of the first dimension of &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; because we're only selecting every third row from our original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fa363c46c4da719440f0a895d038cea7c0f22d" translate="yes" xml:space="preserve">
          <source>In this situation, use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to skip missing values</source>
          <target state="translated">В этой ситуации, используйте &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; функцию , чтобы пропускать отсутствующие значения</target>
        </trans-unit>
        <trans-unit id="9db9e9e3387eacd52cbab3963439723e71f36736" translate="yes" xml:space="preserve">
          <source>In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</source>
          <target state="translated">В этом стиле определения функция генерации кода по сути является необязательной оптимизацией.Компилятор будет использовать ее,если это удобно,но в противном случае может выбрать обычную реализацию.Этот стиль предпочтительнее,так как он позволяет компилятору принимать больше решений и компилировать программы большим количеством способов,а также так как обычный код более читабелен,чем код,генерирующий код.Однако,какая реализация используется,зависит от особенностей реализации компилятора,поэтому важно,чтобы обе реализации вели себя одинаково.</target>
        </trans-unit>
        <trans-unit id="2472bd128ff5a0c2f02732fc91d35900b7540e31" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">В этом примере с игрушкой два метода легко различить и выбрать один из них. Однако в реальной программе для перемещения данных может потребоваться больше размышлений и, вероятно, некоторых измерений. Например, если первому процессу нужна матрица &lt;code&gt;A&lt;/code&gt; , то первый метод может быть лучше. Или, если вычисление &lt;code&gt;A&lt;/code&gt; является дорогостоящим и оно есть только в текущем процессе, перемещение его в другой процесс может быть неизбежным. Или, если текущий процесс имеет очень мало общего между &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;fetch(Bref)&lt;/code&gt; , может быть лучше вообще устранить параллелизм. Или представьте себе, что &lt;code&gt;rand(1000,1000)&lt;/code&gt; заменяется более дорогой операцией. Тогда имеет смысл добавить еще &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; оператор @spawn только для этого шага.</target>
        </trans-unit>
        <trans-unit id="4f15c62fbcd9523fb3f2a21376c6d6f2fb45889e" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf538f8e56ca0f93d90636a083c95bfe08cc9992" translate="yes" xml:space="preserve">
          <source>In this way a mesh network is established, wherein every worker is directly connected with every other worker.</source>
          <target state="translated">Таким образом,создается ячеистая сеть,в которой каждый работник напрямую связан с каждым другим работником.</target>
        </trans-unit>
        <trans-unit id="77e752e41de1e6877a1adbe41bf7b76e4f16d104" translate="yes" xml:space="preserve">
          <source>In-memory representation of a file entry in the index. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt;&lt;code&gt;git_index_entry&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Представление в памяти записи файла в индексе. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt; &lt;code&gt;git_index_entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06c7aeba98a0f145bac3596871ee20c6209a6fe5" translate="yes" xml:space="preserve">
          <source>In-place broadcasting can be supported by defining the appropriate &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; method. Because you might want to specialize either on &lt;code&gt;dest&lt;/code&gt; or the specific subtype of &lt;code&gt;bc&lt;/code&gt;, to avoid ambiguities between packages we recommend the following convention.</source>
          <target state="translated">Вещание на месте может поддерживаться путем определения соответствующего &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; . Поскольку вы можете специализироваться либо на &lt;code&gt;dest&lt;/code&gt; , либо на конкретном подтипе &lt;code&gt;bc&lt;/code&gt; , во избежание двусмысленности между пакетами мы рекомендуем следующее соглашение.</target>
        </trans-unit>
        <trans-unit id="9b8eaa806ba1cb1b5e2ab868bf0bb847fbaf77f5" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc665a97127feb38e6b15a0be58c4193afb4afe7" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;: randomly permute &lt;code&gt;v&lt;/code&gt; in-place, optionally supplying the random-number generator &lt;code&gt;rng&lt;/code&gt;.</source>
          <target state="translated">Версия &lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; : случайным образом переставить &lt;code&gt;v&lt;/code&gt; на месте, опционально предоставив &lt;code&gt;rng&lt;/code&gt; генератора случайных чисел .</target>
        </trans-unit>
        <trans-unit id="ceae787569f3577706adf60b6b428b09067c76dc" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;code&gt;reverse&lt;/code&gt;.</source>
          <target state="translated">На месте версия &lt;code&gt;reverse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d77496985aa0ae694adc6f64d73e36e7d090fe55" translate="yes" xml:space="preserve">
          <source>Inbox Tray</source>
          <target state="translated">Входящий лоток</target>
        </trans-unit>
        <trans-unit id="973cab0f46e932b28084ce2f784990fa4e35559b" translate="yes" xml:space="preserve">
          <source>Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.</source>
          <target state="translated">Включите одно предложение в одну строку,описывающее,что делает функция или что представляет собой объект после упрощенного блока сигнатур.При необходимости подробнее опишите это во втором абзаце после пустой строки.</target>
        </trans-unit>
        <trans-unit id="7962fdf356cdba272a5b5a5a58199f8e50948161" translate="yes" xml:space="preserve">
          <source>Include any code examples in an &lt;code&gt;# Examples&lt;/code&gt; section.</source>
          <target state="translated">Включите любые примеры кода в раздел &lt;code&gt;# Examples&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66cb3917171f2315e55b05172cef1568516a6218" translate="yes" xml:space="preserve">
          <source>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with &quot;safe&quot; versions of some operators:</source>
          <target state="translated">Включение одного и того же кода в различные модули обеспечивает микшиноподобное поведение.Это можно использовать для запуска одного и того же кода с разными базовыми определениями,например,для тестирования кода,запуская его с &quot;безопасными&quot; версиями некоторых операторов:</target>
        </trans-unit>
        <trans-unit id="3677c6602caed5b57fccc20b31958c9939eb0f57" translate="yes" xml:space="preserve">
          <source>Incoming Envelope</source>
          <target state="translated">Входящий конверт</target>
        </trans-unit>
        <trans-unit id="1cebd71683222b1c7af41849d615c19b10f8b1ef" translate="yes" xml:space="preserve">
          <source>Incomplete Initialization</source>
          <target state="translated">Незавершенная инициализация</target>
        </trans-unit>
        <trans-unit id="700503508878aea14fc71ea0dd89adddb349e058" translate="yes" xml:space="preserve">
          <source>Increases As</source>
          <target state="translated">Увеличивается как</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="81769cec07065990cf97fe9de01e67d1dff5a01a" translate="yes" xml:space="preserve">
          <source>Incremental history search, described above</source>
          <target state="translated">Инкрементальный поиск по истории,описанный выше</target>
        </trans-unit>
        <trans-unit id="7777e9a1cc822589b38fa2cf3b16ff5bb4405461" translate="yes" xml:space="preserve">
          <source>IndexCartesian</source>
          <target state="translated">IndexCartesian</target>
        </trans-unit>
        <trans-unit id="0ad6144c812efd669c1e0522b10d3e8d01b0818e" translate="yes" xml:space="preserve">
          <source>IndexLinear</source>
          <target state="translated">IndexLinear</target>
        </trans-unit>
        <trans-unit id="5c7d3a57514b6cbb8c7494df1aa031252a9240c0" translate="yes" xml:space="preserve">
          <source>IndexStyle</source>
          <target state="translated">IndexStyle</target>
        </trans-unit>
        <trans-unit id="8b48578d3b12e1d393eb06b8ea5bee4e6f0ec92a" translate="yes" xml:space="preserve">
          <source>Indexable Collections</source>
          <target state="translated">Индексируемые коллекции</target>
        </trans-unit>
        <trans-unit id="04f77b5a53e8914ea949c0d3dbe59ff927176c3a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="0795ddb093e3d5dd1a985acb78a5e1baf2eef779" translate="yes" xml:space="preserve">
          <source>Indexing and assignment</source>
          <target state="translated">Индексирование и присвоение</target>
        </trans-unit>
        <trans-unit id="4274ea6199202594d8373033384d6bdb729f3196" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</source>
          <target state="translated">Укажите,что функция сортировки должна использовать алгоритм сортировки вставки.Вставляемая сортировка проходит через коллекцию по одному элементу за раз,вставляя каждый элемент в его правильное,отсортированное положение в списке вывода.</target>
        </trans-unit>
        <trans-unit id="1a127225335e9d3a07a6be83a0e208ad31b15ede" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</source>
          <target state="translated">Укажите,что функция сортировки должна использовать алгоритм сортировки слияния.Сортировка слияния разделяет коллекцию на вложенные коллекции и многократно объединяет их,сортируя каждую вложенную коллекцию на каждом шаге,пока вся коллекция не будет перекомбинирована в отсортированном виде.</target>
        </trans-unit>
        <trans-unit id="f0d9438aae14ca6f51f78f417b7df01df9f079a5" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest &lt;code&gt;k&lt;/code&gt; elements sorted from smallest to largest, finding them and sorting them using &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt;&lt;code&gt;QuickSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Укажите, что функция сортировки должна использовать алгоритм частичной быстрой сортировки. Частичная быстрая сортировка возвращает &lt;code&gt;k&lt;/code&gt; наименьших элементов, отсортированных от наименьшего к наибольшему, находя и сортируя их с помощью &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt; &lt;code&gt;QuickSort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c75327b4e50aced7a786e9b2e8496c590cde6e" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the quick sort algorithm, which is &lt;em&gt;not&lt;/em&gt; stable.</source>
          <target state="translated">Укажите , что функция сортировки следует использовать быстрый алгоритм сортировки, который &lt;em&gt;не&lt;/em&gt; стабилен.</target>
        </trans-unit>
        <trans-unit id="a54eb733590aa2b40370b6fb359ea865b8d99e9b" translate="yes" xml:space="preserve">
          <source>Indicate whether &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Укажите , является ли &lt;code&gt;x&lt;/code&gt; это &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efe98c42fb3d546aaef0cbe63f84a3ed426eef2d" translate="yes" xml:space="preserve">
          <source>Indicates a test that should pass but currently consistently fails. Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; or causes an exception. Returns a &lt;code&gt;Broken&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, or an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Указывает, что тест должен пройти, но в настоящее время постоянно не проходит. Проверяет, что выражение &lt;code&gt;ex&lt;/code&gt; принимает значение &lt;code&gt;false&lt;/code&gt; или вызывает исключение. Возвращает &lt;code&gt;Broken&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; , если он делает, или &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; , если выражение имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f58aeaea39a890601871a48e22cb88bfcd1c627a" translate="yes" xml:space="preserve">
          <source>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</source>
          <target state="translated">Указывает на проблемный статус выхода из процесса.При выполнении команд или конвейеров это бросается,чтобы показать,что был возвращен ненулевой код выхода (т.е.что вызванный процесс завершился неудачей).</target>
        </trans-unit>
        <trans-unit id="ff3a5eaf7321b1b596df1bcd003dbd2f9fcf89b1" translate="yes" xml:space="preserve">
          <source>Indices are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Индексы того же типа, что и индексы, возвращаемые &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e9b57819d8a4759652850ab76b4d97192200f0" translate="yes" xml:space="preserve">
          <source>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</source>
          <target state="translated">Индексы могут быть опущены, если все конечные измерения, которые не индексируются, имеют единицу длины. Другими словами, конечные индексы могут быть опущены только в том случае, если существует только одно возможное значение, которое эти пропущенные индексы могут быть для выражения индексации в границах. Например, четырехмерный массив размером &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; может быть проиндексирован только с тремя индексами, поскольку пропускаемое измерение (четвертое измерение) имеет длину один. Обратите внимание, что линейное индексирование имеет приоритет над этим правилом.</target>
        </trans-unit>
        <trans-unit id="a9eddea567bcc33c91213abd188cec156d2bbedc" translate="yes" xml:space="preserve">
          <source>Indices or keys are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Индексы или ключи того же типа, что и &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e37e52d9d94ec6a75ede0c2186d1f73dd06e01f" translate="yes" xml:space="preserve">
          <source>Indirect Calls</source>
          <target state="translated">Косвенные звонки</target>
        </trans-unit>
        <trans-unit id="8b89285e1320e669387b56f7e30bddb1aefce498" translate="yes" xml:space="preserve">
          <source>Individual pointers returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; can be translated into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s by passing them into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt;&lt;code&gt;StackTraces.lookup&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Отдельные указатели, возвращаемые &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; ,&lt;/a&gt; можно преобразовать в StackTraces.StackFrame , передав их в &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt; &lt;code&gt;StackTraces.lookup&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f462554871703067824392ec24cc8ae7c200c6ce" translate="yes" xml:space="preserve">
          <source>Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:</source>
          <target state="translated">Неизбежно хочется писать команды,которые не так просты,и приходится использовать кавычки.Приведем простой пример Perl-одного лайнера в командной строке оболочки:</target>
        </trans-unit>
        <trans-unit id="b24e30d8c474981541dc914b04b492ae2c3460dd" translate="yes" xml:space="preserve">
          <source>Inexact equality comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt;. The default &lt;code&gt;atol&lt;/code&gt; is zero and the default &lt;code&gt;rtol&lt;/code&gt; depends on the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The keyword argument &lt;code&gt;nans&lt;/code&gt; determines whether or not NaN values are considered equal (defaults to false).</source>
          <target state="translated">Неточное сравнение равенства: &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt; . По умолчанию &lt;code&gt;atol&lt;/code&gt; равен нулю , и по умолчанию &lt;code&gt;rtol&lt;/code&gt; зависит от типа &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Аргумент ключевого слова &lt;code&gt;nans&lt;/code&gt; определяет, считаются ли значения NaN равными (по умолчанию false).</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3b4f77ed6217d60a7fd4f6a9b544f27db8d0b2a2" translate="yes" xml:space="preserve">
          <source>Inf16</source>
          <target state="translated">Inf16</target>
        </trans-unit>
        <trans-unit id="f32fd60229b61d38504c1b80cfc905d76eb231a4" translate="yes" xml:space="preserve">
          <source>Inf32</source>
          <target state="translated">Inf32</target>
        </trans-unit>
        <trans-unit id="13b9b86c9d296608a20ee6add58865dfa6405d7b" translate="yes" xml:space="preserve">
          <source>Inference on the generated function may be run at &lt;em&gt;any&lt;/em&gt; time, including while your code is attempting to observe or mutate this state.</source>
          <target state="translated">Логический вывод о сгенерированной функции может быть запущен в &lt;em&gt;любое&lt;/em&gt; время, в том числе пока ваш код пытается наблюдать или изменять это состояние.</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="c7144cf7afebc5115a987ddb86ab81776ccb312f" translate="yes" xml:space="preserve">
          <source>Information Desk Person</source>
          <target state="translated">Лицо информационного стола</target>
        </trans-unit>
        <trans-unit id="ee1bf915e3a7b6dbf22c44b17ef750f99d415033" translate="yes" xml:space="preserve">
          <source>Information Source</source>
          <target state="translated">Источник информации</target>
        </trans-unit>
        <trans-unit id="1bcf6aaebaf6b2210eb3e22e29d6b1d78dde678a" translate="yes" xml:space="preserve">
          <source>Information about the datatype</source>
          <target state="translated">Информация о типе данных</target>
        </trans-unit>
        <trans-unit id="bc0f7289c05621e36794cb837d6af7d6579a4164" translate="yes" xml:space="preserve">
          <source>Information about the sizes of the array</source>
          <target state="translated">Информация о размерах массива</target>
        </trans-unit>
        <trans-unit id="2e1d962528e312390b3433d954b1b586fbe1d39c" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x = 1.0&lt;/code&gt;</source>
          <target state="translated">Инициализировать &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;x = 1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d24f12b12b26a182fb25787fca39632feae214b" translate="yes" xml:space="preserve">
          <source>Initialize with the first loop iteration, to &lt;code&gt;x = 1 / rand()&lt;/code&gt;, then loop &lt;code&gt;for i = 2:10&lt;/code&gt;</source>
          <target state="translated">Инициализировать с первой итерацией цикла, чтобы &lt;code&gt;x = 1 / rand()&lt;/code&gt; , затем цикл &lt;code&gt;for i = 2:10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1daf596559638b5a2545966e4511677e06d2d3d" translate="yes" xml:space="preserve">
          <source>Initially &lt;code&gt;f(x)&lt;/code&gt; has one definition</source>
          <target state="translated">Первоначально &lt;code&gt;f(x)&lt;/code&gt; имеет одно определение</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">Интернет-элементы</target>
        </trans-unit>
        <trans-unit id="45667ade36979348043d403d58a921b295a413f5" translate="yes" xml:space="preserve">
          <source>Inner Constructor Methods</source>
          <target state="translated">Внутренние методы строительства</target>
        </trans-unit>
        <trans-unit id="5b1b953a0d0fba8d5b16a917eed0d32fa9a3dd01" translate="yes" xml:space="preserve">
          <source>Inner local scopes can, however, update variables in their parent scopes:</source>
          <target state="translated">Внутренние локальные области могут,однако,обновлять переменные в родительской области:</target>
        </trans-unit>
        <trans-unit id="8da1f19e44e7c32bb595b50d82bbd6ceb59679ad" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Capital Letters</source>
          <target state="translated">Входной символ для латинских прописных букв</target>
        </trans-unit>
        <trans-unit id="c3dacb4d5649dfd7003c41b511f2d5e28217bcec" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Letters</source>
          <target state="translated">Входной символ для латинских букв</target>
        </trans-unit>
        <trans-unit id="c56fdb4bd109b10836666b2146d13e58e8c262da" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Small Letters</source>
          <target state="translated">Входной символ для латинских маленьких букв</target>
        </trans-unit>
        <trans-unit id="daa856648c7327c1e747ce6132f831c138ebed2c" translate="yes" xml:space="preserve">
          <source>Input Symbol For Numbers</source>
          <target state="translated">Входной символ для цифр</target>
        </trans-unit>
        <trans-unit id="393164c17095f31b175cd1b93cce56c3dedbfb1e" translate="yes" xml:space="preserve">
          <source>Input Symbol For Symbols</source>
          <target state="translated">Входной символ для символов</target>
        </trans-unit>
        <trans-unit id="6ac623d9f5d1fbc2e0f23f9accfd989544cd258f" translate="yes" xml:space="preserve">
          <source>Insert a sequential-consistency memory fence</source>
          <target state="translated">Вставьте забор памяти последовательной согласованности</target>
        </trans-unit>
        <trans-unit id="811acf3875523c22a2281d416b5b4f8370319cc7" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;item&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is the index of &lt;code&gt;item&lt;/code&gt; in the resulting &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Вставьте &lt;code&gt;item&lt;/code&gt; в в данном &lt;code&gt;index&lt;/code&gt; . &lt;code&gt;index&lt;/code&gt; - это индекс &lt;code&gt;item&lt;/code&gt; в результирующем &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="559e8d8937fda6b9aa5389a26a8c99a01c1659f4" translate="yes" xml:space="preserve">
          <source>Insert new line without executing it</source>
          <target state="translated">Вставить новую строку без ее выполнения</target>
        </trans-unit>
        <trans-unit id="db69c06d74ad468e37833a8eff3cd0b19f6c2cae" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the beginning of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">Вставьте один или несколько &lt;code&gt;items&lt;/code&gt; в начало &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e38ad6a771799a9a8891ef79be267ec402e8ceac" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">Вставьте один или несколько &lt;code&gt;items&lt;/code&gt; в конец &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3f950f8d7377ccffdca0b939ba6ac7684b1f51" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; in &lt;code&gt;collection&lt;/code&gt;. If &lt;code&gt;collection&lt;/code&gt; is an ordered container, the items are inserted at the end (in the given order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1912a8c6dfd808836326783d91aa44bc473362" translate="yes" xml:space="preserve">
          <source>Insert the elements of &lt;code&gt;items&lt;/code&gt; to the beginning of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Вставьте элементы &lt;code&gt;items&lt;/code&gt; в начало &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec80463f132fabaec00763dec1737d74a5ca8f8" translate="yes" xml:space="preserve">
          <source>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</source>
          <target state="translated">Вставляет забор памяти с последовательно согласованной семантикой упорядочения.Там,где это необходимо,есть алгоритмы,т.е.там,где порядок приобретения/освобождения недостаточен.</target>
        </trans-unit>
        <trans-unit id="8a79f039f9c26eb844e9abd4767d0e8224e23795" translate="yes" xml:space="preserve">
          <source>Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea0f92c3d70dd355408c14ed7bbf0a9be4aeff9" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;kwargs&lt;/code&gt; will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of &lt;code&gt;Symbol&lt;/code&gt;) can be passed as keyword arguments using a semicolon in a call, e.g. &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt;.</source>
          <target state="translated">Внутри &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;kwargs&lt;/code&gt; будет ключ-значение итератора над именем кортежа. Именованные кортежи (а также словари с ключами &lt;code&gt;Symbol&lt;/code&gt; ) могут быть переданы как аргументы ключевого слова, используя точку с запятой в вызове, например, &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d505904dee884402cee2bfc93d1e5e6eac91aed0" translate="yes" xml:space="preserve">
          <source>Inside a function call, &lt;code&gt;f(a=b)&lt;/code&gt; passes &lt;code&gt;b&lt;/code&gt; as the value of keyword argument &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Внутри вызова функции &lt;code&gt;f(a=b)&lt;/code&gt; передает &lt;code&gt;b&lt;/code&gt; как значение аргумента ключевого слова &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c0628bcc3fe3dc7f18266ed4703a4ef8a1c7fc8" translate="yes" xml:space="preserve">
          <source>Inside a local scope a global variable can be assigned to by using the keyword &lt;a href=&quot;../../base/base/index#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Внутри локальной области глобальная переменная может быть назначена с помощью ключевого слова &lt;a href=&quot;../../base/base/index#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="582d7159a5b73cf78ab92b918e0b2d46bdf1e604" translate="yes" xml:space="preserve">
          <source>Inside a local scope a variable can be forced to be a new local variable using the &lt;a href=&quot;../../base/base/index#local&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">Внутри локальной области видимости переменную можно заставить быть новой локальной переменной с помощью ключевого слова &lt;a href=&quot;../../base/base/index#local&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2d117997a7534c274cbe92ad615675971d22bedb" translate="yes" xml:space="preserve">
          <source>Inside of the &lt;code&gt;greet&lt;/code&gt; function, the assignment &lt;code&gt;x = &quot;hello&quot;&lt;/code&gt; causes &lt;code&gt;x&lt;/code&gt; to be a new local variable in the function's scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local &lt;code&gt;x&lt;/code&gt; variable. Since &lt;code&gt;x&lt;/code&gt; is local, it doesn't matter if there is a global named &lt;code&gt;x&lt;/code&gt; or not. Here for example we define &lt;code&gt;x = 123&lt;/code&gt; before defining and calling &lt;code&gt;greet&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fad0a2de99eca8b6794c525262e6ccd85a1c70" translate="yes" xml:space="preserve">
          <source>Inside parentheses with commas, &lt;code&gt;(a=1,)&lt;/code&gt; constructs a &lt;a href=&quot;#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В скобках с запятыми &lt;code&gt;(a=1,)&lt;/code&gt; создается &lt;a href=&quot;#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="456c6fe8fc3a9803d2d238636df3fddf2e8ebda8" translate="yes" xml:space="preserve">
          <source>Inspects the given UUID and returns its version (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;).</source>
          <target state="translated">Проверяет данный UUID и возвращает его версию (см. &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4ff8674778688251123ee296e21a5f29ce889b67" translate="yes" xml:space="preserve">
          <source>Instances can be constructed from strings via &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, or using the &lt;code&gt;big&lt;/code&gt; string literal.</source>
          <target state="translated">Экземпляры могут быть созданы из строк с помощью &lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; или с использованием &lt;code&gt;big&lt;/code&gt; строкового литерала.</target>
        </trans-unit>
        <trans-unit id="e2cd4547e98e69f493a2391724e35284eddfcf3f" translate="yes" xml:space="preserve">
          <source>Instead of calculating something or performing some action, you return a &lt;em&gt;quoted expression&lt;/em&gt; which, when evaluated, does what you want.</source>
          <target state="translated">Вместо того, чтобы что-то вычислять или выполнять какое-либо действие, вы возвращаете &lt;em&gt;выражение&lt;/em&gt; в &lt;em&gt;кавычках,&lt;/em&gt; которое при оценке делает то, что вы хотите.</target>
        </trans-unit>
        <trans-unit id="e11074b6a3ddd4db91a1d67bb7c4e17f5cc3596e" translate="yes" xml:space="preserve">
          <source>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</source>
          <target state="translated">Вместо прямой сортировки массива можно вычислить перестановку индексов массива,которая приведет массив в порядок сортировки:</target>
        </trans-unit>
        <trans-unit id="d807ed905e686ec4c6c31127918a04393e4003ae" translate="yes" xml:space="preserve">
          <source>Instead of immediately running the command, backticks create a &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; object to represent the command. You can use this object to connect the command to others via pipes, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; it, and &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">Вместо немедленного выполнения команды обратные кавычки создают объект &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; для представления команды. Вы можете использовать этот объект, чтобы соединить команду с другими через каналы, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt; ее, а также &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; в нее.</target>
        </trans-unit>
        <trans-unit id="78863694892c2019c43a79b283ebb340da799f84" translate="yes" xml:space="preserve">
          <source>Instead of loading a registered version of &lt;code&gt;Example&lt;/code&gt;, Julia will load the source code contained in &lt;code&gt;tutorial/dev/Example&lt;/code&gt;.</source>
          <target state="translated">Вместо загрузки зарегистрированной версии &lt;code&gt;Example&lt;/code&gt; Юлия загрузит исходный код, содержащийся в &lt;code&gt;tutorial/dev/Example&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80cddaa6c38b52b1b6910a5df7e62d1058e97067" translate="yes" xml:space="preserve">
          <source>Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</source>
          <target state="translated">Вместо того,чтобы выполнять какое-либо вычисление или действие,сгенерированная декларация функции возвращает цитируемое выражение,которое затем формирует тело метода,соответствующего типам аргументов.При вызове сгенерированной функции возвращаемое ею выражение компилируется и затем выполняется.Чтобы сделать это эффективным,результат обычно кэшируется.А для того,чтобы сделать это возможным,используется только ограниченное подмножество языка.Таким образом,генерируемые функции предоставляют гибкий способ перемещения работы от времени исполнения к времени компиляции за счет больших ограничений на допустимые конструкции.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="a3a52a1be0f1de968cc5d8921a39676d67c34867" translate="yes" xml:space="preserve">
          <source>Instead, use a semicolon or insert a line break after &lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">Вместо этого используйте точку с запятой или вставьте разрыв строки после &lt;code&gt;catch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3f6b46a05cf7ae83de7f241a566b6dcab9f9f12b" translate="yes" xml:space="preserve">
          <source>Integer division (the &lt;code&gt;div&lt;/code&gt; function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt;) by -1. Both of these cases throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt;. The remainder and modulus functions (&lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;) throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt; when their second argument is zero.</source>
          <target state="translated">Целочисленное деление ( функция &lt;code&gt;div&lt;/code&gt; ) имеет два исключительных случая: деление на ноль и деление наименьшего отрицательного числа ( &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; ) на -1. В обоих случаях возникает &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt; . Функции остатка и модуля ( &lt;code&gt;rem&lt;/code&gt; и &lt;code&gt;mod&lt;/code&gt; ) &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt; когда их второй аргумент равен нулю.</target>
        </trans-unit>
        <trans-unit id="27477953a7f5629b70d1f8667b4ce5a95bd7d163" translate="yes" xml:space="preserve">
          <source>Integer division was attempted with a denominator value of 0.</source>
          <target state="translated">Попытка целочисленного деления была предпринята со значением знаменателя 0.</target>
        </trans-unit>
        <trans-unit id="44e36daccd6ac7a9f894c249dbe1f367783e4537" translate="yes" xml:space="preserve">
          <source>Integer square root: the largest integer &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt;.</source>
          <target state="translated">Целочисленный квадратный корень: наибольшее целое число &lt;code&gt;m&lt;/code&gt; такое, что &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0f622cf48cf7d80bd106d7df1f3da91566c330d" translate="yes" xml:space="preserve">
          <source>Integer value N launches N additional local worker processes; &lt;code&gt;auto&lt;/code&gt; launches as many workers as the number of local CPU threads (logical cores)</source>
          <target state="translated">Целочисленное значение N запускает N дополнительных локальных рабочих процессов; &lt;code&gt;auto&lt;/code&gt; запускает столько рабочих, сколько локальных потоков ЦП (логических ядер)</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0be1ec1ce9bd8f5a453ecb566c11ab0a7c7144d0" translate="yes" xml:space="preserve">
          <source>Integers and Floating-Point Numbers</source>
          <target state="translated">Целочисления и Числа с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="cdcba026c96bc24c46aaded28b7a473dd9b651d8" translate="yes" xml:space="preserve">
          <source>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, &lt;code&gt;1&lt;/code&gt; is an integer literal, while &lt;code&gt;1.0&lt;/code&gt; is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</source>
          <target state="translated">Целые числа и значения с плавающей запятой являются основными строительными блоками арифметики и вычислений. Встроенные представления таких значений называются числовыми примитивами, а представления целых чисел и чисел с плавающей запятой в виде непосредственных значений в коде известны как числовые литералы. Например, &lt;code&gt;1&lt;/code&gt; - это целочисленный литерал, а &lt;code&gt;1.0&lt;/code&gt; - литерал с плавающей запятой; их двоичные представления в памяти как объекты являются числовыми примитивами.</target>
        </trans-unit>
        <trans-unit id="be404ce277aac9d3b9b27f0140b709ff517b7820" translate="yes" xml:space="preserve">
          <source>Integers are compared in the standard manner &amp;ndash; by comparison of bits. Floating-point numbers are compared according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;:</source>
          <target state="translated">Целые числа сравниваются стандартным образом - путем сравнения битов. Числа с плавающей запятой сравниваются в соответствии со &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;стандартом IEEE 754&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="70680c64952b0114adcda3eb14a614e1841cd0c6" translate="yes" xml:space="preserve">
          <source>Integral Around A Point Operator</source>
          <target state="translated">Интегральный оператор вокруг точки</target>
        </trans-unit>
        <trans-unit id="425335bd88e128f008b3f48181d1c27b517bcc72" translate="yes" xml:space="preserve">
          <source>Integral Average With Slash</source>
          <target state="translated">Интегральное среднее с косой чертой</target>
        </trans-unit>
        <trans-unit id="c6bac88caff6c11517b441d63dd4587857621bab" translate="yes" xml:space="preserve">
          <source>Integral With Double Stroke</source>
          <target state="translated">Интегральный с двойным ходом</target>
        </trans-unit>
        <trans-unit id="18238ecc8130fd86a404d903215b4901fbd6604e" translate="yes" xml:space="preserve">
          <source>Integral With Intersection</source>
          <target state="translated">Интеграл с пересечением</target>
        </trans-unit>
        <trans-unit id="8a62b59c92abaaa075d87faf375d4d0d5e2fdc39" translate="yes" xml:space="preserve">
          <source>Integral With Overbar</source>
          <target state="translated">Интеграл с перемычкой</target>
        </trans-unit>
        <trans-unit id="08588fc154d2b615a7916934fe8e56ebda68acf8" translate="yes" xml:space="preserve">
          <source>Integral With Times Sign</source>
          <target state="translated">Интеграл со знаком времени</target>
        </trans-unit>
        <trans-unit id="31ecf2a75d24fa7ec2a5569e3665d7f415d4db51" translate="yes" xml:space="preserve">
          <source>Integral With Underbar</source>
          <target state="translated">Интегральная с нижней перекладиной</target>
        </trans-unit>
        <trans-unit id="23eafe62fdaca340d651a852cff8f87d44076b09" translate="yes" xml:space="preserve">
          <source>Integral With Union</source>
          <target state="translated">Интеграция с союзом</target>
        </trans-unit>
        <trans-unit id="2885cb42f64585560c85104eeedf86ba7e0ed77e" translate="yes" xml:space="preserve">
          <source>Intel's &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade; Amplifier&lt;/a&gt; (&lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; in the build configuration), or</source>
          <target state="translated">&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;Усилитель&lt;/a&gt; Intel VTune &amp;trade; (для &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; установлено значение &lt;code&gt;1&lt;/code&gt; в конфигурации сборки) или</target>
        </trans-unit>
        <trans-unit id="207cb56e67212ece90d1329dc4b01521c8f13014" translate="yes" xml:space="preserve">
          <source>Interacting with the contents or methods of &lt;code&gt;Core.Compiler&lt;/code&gt; in any way.</source>
          <target state="translated">&lt;code&gt;Core.Compiler&lt;/code&gt; либо образом взаимодействовать с содержимым или методами Core.Compiler .</target>
        </trans-unit>
        <trans-unit id="d4f66ae8b3da23aee8b514d4076de7a8e09b0b4e" translate="yes" xml:space="preserve">
          <source>Interactive Utilities</source>
          <target state="translated">Интерактивные утилиты</target>
        </trans-unit>
        <trans-unit id="71fefc1d52a78f40748037e8a91fc8ea4f8e2578" translate="yes" xml:space="preserve">
          <source>Interactive mode; REPL runs and &lt;code&gt;isinteractive()&lt;/code&gt; is true</source>
          <target state="translated">Интерактивный режим; REPL запускается, а &lt;code&gt;isinteractive()&lt;/code&gt; истинно</target>
        </trans-unit>
        <trans-unit id="0270e20982d6093d44ba136572cbf822d6290a5d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_llvm</source>
          <target state="translated">InteractiveUtils.@code_llvm</target>
        </trans-unit>
        <trans-unit id="0309be470088530490561ff83d97b95071df357e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_lowered</source>
          <target state="translated">InteractiveUtils.@code_lowered</target>
        </trans-unit>
        <trans-unit id="00a7a46c62638c2b2d4deb9dc4bd43a8d3c3582c" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_native</source>
          <target state="translated">InteractiveUtils.@code_native</target>
        </trans-unit>
        <trans-unit id="4fa27864c86ced13027d392baeedb020be6c560a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_typed</source>
          <target state="translated">InteractiveUtils.@code_typed</target>
        </trans-unit>
        <trans-unit id="1e45473f814223dcb1c417d561e1870e1450bf83" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_warntype</source>
          <target state="translated">InteractiveUtils.@code_warntype</target>
        </trans-unit>
        <trans-unit id="eedef913d7842aa079f915bdbbb5f5e90c47c7f6" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@edit</source>
          <target state="translated">InteractiveUtils.@edit</target>
        </trans-unit>
        <trans-unit id="a6df5f45ac03e2c658d92e8736e88cafa5b98995" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@functionloc</source>
          <target state="translated">InteractiveUtils.@functionloc</target>
        </trans-unit>
        <trans-unit id="49e359f4c318b876f99ccb7d37f63e69deb2003d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@less</source>
          <target state="translated">InteractiveUtils.@less</target>
        </trans-unit>
        <trans-unit id="6e359d1c5b33d4212df3c4f8c3762813890df9ae" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@which</source>
          <target state="translated">InteractiveUtils.@which</target>
        </trans-unit>
        <trans-unit id="2d50f6ed31622302ae5f5a5feebfb95f2c420a04" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.clipboard()</source>
          <target state="translated">InteractiveUtils.clipboard()</target>
        </trans-unit>
        <trans-unit id="c1ad553095bd7ae0c9db5b342934998a5be27479" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_llvm()</source>
          <target state="translated">InteractiveUtils.code_llvm()</target>
        </trans-unit>
        <trans-unit id="a70df8f6770abff941be7ee8196e397ae5bbd4b8" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_native()</source>
          <target state="translated">InteractiveUtils.code_native()</target>
        </trans-unit>
        <trans-unit id="f009b2e3c7cb61122f070c557fb9f4dcd1edf6db" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_warntype()</source>
          <target state="translated">InteractiveUtils.code_warntype()</target>
        </trans-unit>
        <trans-unit id="d4c1c9ee2ecb7996d780a0e5d5ccea921a53d56a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.edit()</source>
          <target state="translated">InteractiveUtils.edit()</target>
        </trans-unit>
        <trans-unit id="424927890145616c60279ce930588fd54c4ac90e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.less()</source>
          <target state="translated">InteractiveUtils.less()</target>
        </trans-unit>
        <trans-unit id="49eeeef411d4549f28b217525726cf46e51440cb" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.methodswith()</source>
          <target state="translated">InteractiveUtils.methodswith()</target>
        </trans-unit>
        <trans-unit id="59973fd047bc66e11de11bff485ff30fc8072b48" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.subtypes()</source>
          <target state="translated">InteractiveUtils.subtypes()</target>
        </trans-unit>
        <trans-unit id="8cc40b484c66058018a0b8c42f2ab741a2014154" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.varinfo()</source>
          <target state="translated">InteractiveUtils.varinfo()</target>
        </trans-unit>
        <trans-unit id="391d124220b1a9c25f8d3323e7bb133c849aadc9" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.versioninfo()</source>
          <target state="translated">InteractiveUtils.versioninfo()</target>
        </trans-unit>
        <trans-unit id="068a8966386d6f477f70dcc54b094caba48a03f4" translate="yes" xml:space="preserve">
          <source>Intercalate</source>
          <target state="translated">Intercalate</target>
        </trans-unit>
        <trans-unit id="a791af570ec4e5730c5e110c39b173c357ea4d3a" translate="yes" xml:space="preserve">
          <source>Interconverts between dense and sparse formats.</source>
          <target state="translated">Преобразование между плотным и редким форматами.</target>
        </trans-unit>
        <trans-unit id="c3229f4e0f20d697072608271bc7f20c5b6d789f" translate="yes" xml:space="preserve">
          <source>Interface to BLAS subroutines.</source>
          <target state="translated">Интерфейс к подпрограммам BLAS.</target>
        </trans-unit>
        <trans-unit id="bcdb1ff794ae28041f3196a504b6115b3dea810a" translate="yes" xml:space="preserve">
          <source>Interface to libc, the C standard library.</source>
          <target state="translated">Интерфейс к libc,стандартная библиотека C.</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="c2b213458be4f2f6fdec41d29483b814cba730b1" translate="yes" xml:space="preserve">
          <source>Interfaces to LAPACK subroutines.</source>
          <target state="translated">Интерфейсы к подпрограммам LAPACK.</target>
        </trans-unit>
        <trans-unit id="a514e8807ceddceeb9d1c2be8e83634758fea386" translate="yes" xml:space="preserve">
          <source>Interior Product</source>
          <target state="translated">Внутренняя отделка Продукт</target>
        </trans-unit>
        <trans-unit id="0c4a9d0a55deb37d51d5b2b7f615f0874ed971d8" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;promote_type&lt;/code&gt; is used inside of &lt;code&gt;promote&lt;/code&gt; to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, which defines the complete promotion mechanism in about 35 lines.</source>
          <target state="translated">Внутренне &lt;code&gt;promote_type&lt;/code&gt; используется внутри &lt;code&gt;promote&lt;/code&gt; чтобы определить, в какие значения аргументов типа следует преобразовать для продвижения. Однако он может быть полезен сам по себе. Любопытный читатель может прочитать код в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt; , который описывает полный механизм продвижения примерно в 35 строках.</target>
        </trans-unit>
        <trans-unit id="818408de3c95448c6a4c8c7cc57f8a8c85a4002d" translate="yes" xml:space="preserve">
          <source>Internally, an &lt;code&gt;AbstractChar&lt;/code&gt; type may use a variety of encodings. Conversion via &lt;code&gt;codepoint(char)&lt;/code&gt; will not reveal this encoding because it always returns the Unicode value of the character. &lt;code&gt;print(io, c)&lt;/code&gt; of any &lt;code&gt;c::AbstractChar&lt;/code&gt; produces an encoding determined by &lt;code&gt;io&lt;/code&gt; (UTF-8 for all built-in &lt;code&gt;IO&lt;/code&gt; types), via conversion to &lt;code&gt;Char&lt;/code&gt; if necessary.</source>
          <target state="translated">Внутренне тип &lt;code&gt;AbstractChar&lt;/code&gt; может использовать множество кодировок. Преобразование через &lt;code&gt;codepoint(char)&lt;/code&gt; не покажет эту кодировку, потому что она всегда возвращает значение Unicode символа. &lt;code&gt;print(io, c)&lt;/code&gt; любого &lt;code&gt;c::AbstractChar&lt;/code&gt; создает кодировку, определяемую &lt;code&gt;io&lt;/code&gt; (UTF-8 для всех встроенных типов &lt;code&gt;IO&lt;/code&gt; - вывода ), путем преобразования в &lt;code&gt;Char&lt;/code&gt; , если необходимо.</target>
        </trans-unit>
        <trans-unit id="4952806e1eda6ad8d06e741bd80f1e6d3a2efafd" translate="yes" xml:space="preserve">
          <source>Internally, this code creates two implementations of the function: a generated one where the first block in &lt;code&gt;if @generated&lt;/code&gt; is used, and a normal one where the &lt;code&gt;else&lt;/code&gt; block is used. Inside the &lt;code&gt;then&lt;/code&gt; part of the &lt;code&gt;if @generated&lt;/code&gt; block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple &lt;code&gt;if @generated&lt;/code&gt; blocks may occur, in which case the generated implementation uses all of the &lt;code&gt;then&lt;/code&gt; blocks and the alternate implementation uses all of the &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">Внутри этот код создает две реализации функции: сгенерированную, в которой используется первый блок в &lt;code&gt;if @generated&lt;/code&gt; , и обычную, в которой используется блок &lt;code&gt;else&lt;/code&gt; . Внутри &lt;code&gt;then&lt;/code&gt; части , &lt;code&gt;if @generated&lt;/code&gt; блока, код имеет ту же семантику, что и другие сгенерированные функции: имена аргументов относятся к типам, а код должен возвращать выражение. Может возникнуть несколько блоков &lt;code&gt;if @generated&lt;/code&gt; , и в этом случае сгенерированная реализация использует все блоки &lt;code&gt;then&lt;/code&gt; , а альтернативная реализация использует все блоки &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="48012c80f49c5c1a3bff1ed20d31a89b4f215742" translate="yes" xml:space="preserve">
          <source>Interpolating into an unquoted expression is not supported and will cause a compile-time error:</source>
          <target state="translated">Интерполяция в нецитируемое выражение не поддерживается и приведет к ошибке во время компиляции:</target>
        </trans-unit>
        <trans-unit id="213daae9f453b89afd1148247dfa9083fa51630b" translate="yes" xml:space="preserve">
          <source>Interpolating values via &lt;code&gt;$&lt;/code&gt; is available as of Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="d67b7c5f52f05b37b77a64fd823fc76a0fce5a66" translate="yes" xml:space="preserve">
          <source>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</source>
          <target state="translated">Интерпретируйте итерабельное слово из пар ключ-значение как именной кортеж,и выполните слияние.</target>
        </trans-unit>
        <trans-unit id="cc53b2acfc42c6cf13c71d4c67ea40578eaaf1f7" translate="yes" xml:space="preserve">
          <source>Interpretation: accessing elements of poorly-typed arrays</source>
          <target state="translated">Интерпретация:доступ к элементам плохо оформленных массивов</target>
        </trans-unit>
        <trans-unit id="7894bb109218bbe3ea53cb08c360e18b2453f383" translate="yes" xml:space="preserve">
          <source>Interpretation: call to a type-unstable function &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">Интерпретация: вызов функции нестабильного типа &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7784e3d882b6a7b4c22ed3b7f03fb99cea250d48" translate="yes" xml:space="preserve">
          <source>Interpretation: function with unstable return type</source>
          <target state="translated">Интерпретация:функция с нестабильным типом возврата</target>
        </trans-unit>
        <trans-unit id="9f71e4dd30d3efc21956f72596ba4278f8921c99" translate="yes" xml:space="preserve">
          <source>Interpretation: getting a field that is of non-leaf type. In this case, &lt;code&gt;ArrayContainer&lt;/code&gt; had a field &lt;code&gt;data::Array{T}&lt;/code&gt;. But &lt;code&gt;Array&lt;/code&gt; needs the dimension &lt;code&gt;N&lt;/code&gt;, too, to be a concrete type.</source>
          <target state="translated">Интерпретация: получение поля, не являющегося листовым. В этом случае &lt;code&gt;ArrayContainer&lt;/code&gt; имеет поле &lt;code&gt;data::Array{T}&lt;/code&gt; . Но &lt;code&gt;Array&lt;/code&gt; также требует, чтобы размерность &lt;code&gt;N&lt;/code&gt; была конкретным типом.</target>
        </trans-unit>
        <trans-unit id="f71c83c811d3e87825b69245ec2c0dff4c1686bd" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.</source>
          <target state="translated">Интерпретация вывода &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; , как и его кузенов &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; &lt;/a&gt; , требует небольшой практики. Ваш код представлен в форме, которая была сильно переварена на пути к генерации скомпилированного машинного кода. Большинство выражений аннотируются типом, обозначенным &lt;code&gt;::T&lt;/code&gt; (где &lt;code&gt;T&lt;/code&gt; может быть , например, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ). Наиболее важной характеристикой &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; является то, что неконкретные типы отображаются красным цветом; в приведенном выше примере такой вывод отображается в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="b25ba536a0a42dea499d4fc2b8979e5924399239" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; since this document is written in Markdown, which has no color, in this document, red text is denoted by uppercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc939bea48b5a28296b21d2be9495aa8bccd0b19" translate="yes" xml:space="preserve">
          <source>Interrupt or cancel</source>
          <target state="translated">Прервать или отменить</target>
        </trans-unit>
        <trans-unit id="23165f09bcddd0acc011e45e34282dbbd91bd4cd" translate="yes" xml:space="preserve">
          <source>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</source>
          <target state="translated">Прерывание текущего выполнения задания на указанных рабочих.Это эквивалентно нажатию клавиши Ctrl-C на локальной машине.Если аргументов нет,то прерываются все рабочие.</target>
        </trans-unit>
        <trans-unit id="658cc9a8a17acd75a5bc21930b12d446eea71552" translate="yes" xml:space="preserve">
          <source>Intersect all passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">Пересечение всех переданных наборов и перезапись &lt;code&gt;s&lt;/code&gt; результатом. Поддерживайте порядок с массивами.</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="7d65fe6f634dc82a5910e500d111d1c2553d45ad" translate="yes" xml:space="preserve">
          <source>Intersection Beside And Joined With Intersection</source>
          <target state="translated">Интерсекция рядом и соединена с Интерсекцией.</target>
        </trans-unit>
        <trans-unit id="f70ced5527bc06ac0250ff3ce0c6433b4fc007ad" translate="yes" xml:space="preserve">
          <source>Intersection With Dot</source>
          <target state="translated">Пересечение с точкой</target>
        </trans-unit>
        <trans-unit id="fea160380c26aea0a6f5cf6d33e5059a2528bb99" translate="yes" xml:space="preserve">
          <source>Intersection With Logical And</source>
          <target state="translated">Пересечение с логическим и</target>
        </trans-unit>
        <trans-unit id="8a447498c8a13bd62bc28a71db064abbbd2ce851" translate="yes" xml:space="preserve">
          <source>Intersection With Overbar</source>
          <target state="translated">Пересечение с перемычкой</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="95010e236dbeb1d0c89e9d5b6ed0ea0da0ed9572" translate="yes" xml:space="preserve">
          <source>Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</source>
          <target state="translated">Интуитивно это соответствует типу аргументов функции,являющемуся подтипом сигнатуры функции (когда сигнатура совпадает).</target>
        </trans-unit>
        <trans-unit id="f4bc4f6c3fe38fa1ef542295504817c8e94651bb" translate="yes" xml:space="preserve">
          <source>Inverse Bullet</source>
          <target state="translated">обратная пуля</target>
        </trans-unit>
        <trans-unit id="a2b80ae8599265e5e4df3c9c6eae5101a072d85a" translate="yes" xml:space="preserve">
          <source>Inverse White Circle</source>
          <target state="translated">Обратный белый круг</target>
        </trans-unit>
        <trans-unit id="f5c93f67585d1f2ce3d07fe77774efdd8e1c494a" translate="yes" xml:space="preserve">
          <source>Inverted Exclamation Mark</source>
          <target state="translated">Инвертированный восклицательный знак</target>
        </trans-unit>
        <trans-unit id="8ed370a70ad4ba84f93ff72e14bb89b2e795837a" translate="yes" xml:space="preserve">
          <source>Inverted Lazy S</source>
          <target state="translated">Инвертированная Ленивая С</target>
        </trans-unit>
        <trans-unit id="7e3bf2655c3d6132b1040ffc28240e0e2706a489" translate="yes" xml:space="preserve">
          <source>Inverted Ohm Sign / Mho</source>
          <target state="translated">Инвертированный знак Ом/Мхо</target>
        </trans-unit>
        <trans-unit id="77352625457aa55d3c246bb35487f40a40f194e5" translate="yes" xml:space="preserve">
          <source>Inverted Question Mark</source>
          <target state="translated">Знак вопроса с инвертированным вопросом</target>
        </trans-unit>
        <trans-unit id="1dc2af95223d452f5604dae81acef5fd3a117e33" translate="yes" xml:space="preserve">
          <source>Invoke a method for the given generic function &lt;code&gt;f&lt;/code&gt; matching the specified types &lt;code&gt;argtypes&lt;/code&gt; on the specified arguments &lt;code&gt;args&lt;/code&gt; and passing the keyword arguments &lt;code&gt;kwargs&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; must conform with the specified types in &lt;code&gt;argtypes&lt;/code&gt;, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</source>
          <target state="translated">Вызвать метод для данной универсальной функции &lt;code&gt;f&lt;/code&gt; , соответствующий указанным типам &lt;code&gt;argtypes&lt;/code&gt; для указанных аргументов &lt;code&gt;args&lt;/code&gt; , и передать ключевое слово arguments &lt;code&gt;kwargs&lt;/code&gt; . Аргументы &lt;code&gt;args&lt;/code&gt; должны соответствовать указанным типам в &lt;code&gt;argtypes&lt;/code&gt; , т. Е. Преобразование не выполняется автоматически. Этот метод позволяет вызвать метод, отличный от самого конкретного метода сопоставления, что полезно, когда явно требуется поведение более общего определения (часто как часть реализации более конкретного метода той же функции).</target>
        </trans-unit>
        <trans-unit id="f0c54c7c50c82bf234e4ed64cb3ce50f2fd86de8" translate="yes" xml:space="preserve">
          <source>Invoke all handlers from &lt;a href=&quot;#Base.Experimental.register_error_hint&quot;&gt;&lt;code&gt;Experimental.register_error_hint&lt;/code&gt;&lt;/a&gt; for the particular exception type &lt;code&gt;typeof(ex)&lt;/code&gt;. &lt;code&gt;args&lt;/code&gt; must contain any other arguments expected by the handler for that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe30ecc758896527e5047bf5e1ab5207bc281f3" translate="yes" xml:space="preserve">
          <source>Irrational</source>
          <target state="translated">Irrational</target>
        </trans-unit>
        <trans-unit id="474a6d17a6faabac287216094db27839ef426282" translate="yes" xml:space="preserve">
          <source>Is Julia named after someone or something?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21fa8512b05ce15e621a0c6aca735529c300b50" translate="yes" xml:space="preserve">
          <source>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</source>
          <target state="translated">Выпуск 8859,&quot;Исправить наименьшее количество квадратов&quot;,https://github.com/JuliaLang/julia/pull/8859.</target>
        </trans-unit>
        <trans-unit id="beadd95d62ed185b3348f8f407f354b8cc251415" translate="yes" xml:space="preserve">
          <source>It also makes writing exponential functions more elegant:</source>
          <target state="translated">Это также делает написание экспоненциальных функций более элегантным:</target>
        </trans-unit>
        <trans-unit id="f6ba82c6b32228a1dcbba192584fb70b95766cb3" translate="yes" xml:space="preserve">
          <source>It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</source>
          <target state="translated">Это может быть более эффективным.Некоторые структуры могут быть эффективно упакованы в массивы,а в некоторых случаях компилятору удается избежать выделения неизменяемых объектов полностью.</target>
        </trans-unit>
        <trans-unit id="2138e5233860592eb48b0938be0063487a8c3bbe" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; is already defined in the &lt;code&gt;Random&lt;/code&gt; module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding &lt;code&gt;SamplerS&lt;/code&gt; type is considered as internal detail, and may be changed without warning.</source>
          <target state="translated">Может случиться так, что &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; уже определен в модуле &lt;code&gt;Random&lt;/code&gt; . Тогда можно было бы пропустить шаг 1) на практике (если кто-то хочет специализировать генерацию для этого конкретного типа RNG), но соответствующий тип &lt;code&gt;SamplerS&lt;/code&gt; считается внутренней деталью и может быть изменен без предупреждения.</target>
        </trans-unit>
        <trans-unit id="b7db5f9d834448c3fd65f59044d31e02c3be0663" translate="yes" xml:space="preserve">
          <source>It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</source>
          <target state="translated">Он может быть профилирован в основной код Julia и даже (опционально)в библиотеки C и Fortran.</target>
        </trans-unit>
        <trans-unit id="c491763305aba9f2c8a952732183092d445bd3cb" translate="yes" xml:space="preserve">
          <source>It decomposes &lt;code&gt;[A; B]&lt;/code&gt; into &lt;code&gt;[UC; VS]H&lt;/code&gt;, where &lt;code&gt;[UC; VS]&lt;/code&gt; is a natural orthogonal basis for the column space of &lt;code&gt;[A; B]&lt;/code&gt;, and &lt;code&gt;H = RQ'&lt;/code&gt; is a natural non-orthogonal basis for the rowspace of &lt;code&gt;[A;B]&lt;/code&gt;, where the top rows are most closely attributed to the &lt;code&gt;A&lt;/code&gt; matrix, and the bottom to the &lt;code&gt;B&lt;/code&gt; matrix. The multi-cosine/sine matrices &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; provide a multi-measure of how much &lt;code&gt;A&lt;/code&gt; vs how much &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; provide directions in which these are measured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10e801b8b0e3436ff2d170e31afdf3876bf67ea" translate="yes" xml:space="preserve">
          <source>It does not return.</source>
          <target state="translated">Он не возвращается.</target>
        </trans-unit>
        <trans-unit id="62d668cd36ba8709a3dd4638a2eee6fedce824d7" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</source>
          <target state="translated">У него есть специальное правило компиляции: однородный кортеж &lt;code&gt;VecElement{T}&lt;/code&gt; отображается в &lt;code&gt;vector&lt;/code&gt; тип LLVM, когда &lt;code&gt;T&lt;/code&gt; является примитивным битовым типом, а длина кортежа находится в наборе {2-6,8-10,16}.</target>
        </trans-unit>
        <trans-unit id="60e06d084730278b0af0749e7022e6e9535b9603" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f1e7a71c8a1cc6e09f468c80045e4456b3f7b6" translate="yes" xml:space="preserve">
          <source>It has a toplevel &lt;code&gt;path&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; will be mapped to that path, interpreted relative to the directory containing the project file.</source>
          <target state="translated">У него есть запись &lt;code&gt;path&lt;/code&gt; верхнего уровня , тогда &lt;code&gt;uuid&lt;/code&gt; будет сопоставлен с этим путем, интерпретируемым относительно каталога, содержащего файл проекта.</target>
        </trans-unit>
        <trans-unit id="5302402dcc63d9a0a8348f68814a706354ef52ba" translate="yes" xml:space="preserve">
          <source>It has access to a special locally existent function called &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; that creates objects of the block's type.</source>
          <target state="translated">Он имеет доступ к специальной локально существующей функции с именем &lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; ,&lt;/a&gt; которая создает объекты типа блока.</target>
        </trans-unit>
        <trans-unit id="e219a846f311411f285e81a3aae4c1e7bf0947a9" translate="yes" xml:space="preserve">
          <source>It is almost always preferable to wrap an existing primitive type in a new composite type than to define your own primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbc8a317cac4fe1eddafff9a3cee6a2e600d5c8" translate="yes" xml:space="preserve">
          <source>It is also important to see how &lt;code&gt;@generated&lt;/code&gt; functions interact with method redefinition. Following the principle that a correct &lt;code&gt;@generated&lt;/code&gt; function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function &lt;em&gt;cannot&lt;/em&gt; call any method that was not defined prior to the &lt;em&gt;definition&lt;/em&gt; of the generated function itself.</source>
          <target state="translated">Также важно увидеть, как &lt;code&gt;@generated&lt;/code&gt; функции взаимодействуют с переопределением метода. Следуя принципу, что правильная функция &lt;code&gt;@generated&lt;/code&gt; не должна наблюдать какое-либо изменяемое состояние или вызывать какие-либо мутации глобального состояния, мы видим следующее поведение. Обратите внимание, что сгенерированная функция &lt;em&gt;не может&lt;/em&gt; вызывать какой-либо метод, который не был определен до &lt;em&gt;определения&lt;/em&gt; самой сгенерированной функции.</target>
        </trans-unit>
        <trans-unit id="acbe3463a0ccc2ec8908f82ece54174f7671b1ae" translate="yes" xml:space="preserve">
          <source>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;1[] == 1&lt;/code&gt;). In particular, if &lt;code&gt;x = 0.0&lt;/code&gt; is defined as a scalar, it is an error to attempt to change its value via &lt;code&gt;x[] = 1.0&lt;/code&gt;. A scalar &lt;code&gt;x&lt;/code&gt; can be converted into a zero-dimensional array containing it via &lt;code&gt;fill(x)&lt;/code&gt;, and conversely, a zero-dimensional array &lt;code&gt;a&lt;/code&gt; can be converted to the contained scalar via &lt;code&gt;a[]&lt;/code&gt;. Another difference is that a scalar can participate in linear algebra operations such as &lt;code&gt;2 * rand(2,2)&lt;/code&gt;, but the analogous operation with a zero-dimensional array &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; is an error.</source>
          <target state="translated">Также важно понимать отличия от обычных скаляров. Скаляры не являются изменяемыми контейнерами (хотя они итерируемы и определяют такие вещи, как &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;getindex&lt;/code&gt; , &lt;em&gt;например, &lt;/em&gt; &lt;code&gt;1[] == 1&lt;/code&gt; ). В частности, если &lt;code&gt;x = 0.0&lt;/code&gt; определяется как скаляр, попытка изменить его значение с помощью &lt;code&gt;x[] = 1.0&lt;/code&gt; является ошибкой . Скаляр &lt;code&gt;x&lt;/code&gt; может быть преобразован в содержащий его нульмерный массив с помощью &lt;code&gt;fill(x)&lt;/code&gt; , и, наоборот, нульмерный массив &lt;code&gt;a&lt;/code&gt; может быть преобразован в содержащийся скаляр с помощью &lt;code&gt;a[]&lt;/code&gt; . Другое отличие состоит в том, что скаляр может участвовать в операциях линейной алгебры, таких как &lt;code&gt;2 * rand(2,2)&lt;/code&gt; , но аналогичная операция с нулевым массивом &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; является ошибкой.</target>
        </trans-unit>
        <trans-unit id="a6aa34f5f096577fc826b15725104feebe319049" translate="yes" xml:space="preserve">
          <source>It is also often useful to allow iteration over a collection in &lt;em&gt;reverse order&lt;/em&gt; by iterating over &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt;&lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt;&lt;/a&gt;. To actually support reverse-order iteration, however, an iterator type &lt;code&gt;T&lt;/code&gt; needs to implement &lt;code&gt;iterate&lt;/code&gt; for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (Given &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt;, the underling iterator of type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;r.itr&lt;/code&gt;.) In our &lt;code&gt;Squares&lt;/code&gt; example, we would implement &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; methods:</source>
          <target state="translated">Также часто бывает полезно разрешить итерацию по коллекции в &lt;em&gt;обратном порядке&lt;/em&gt; , перебирая &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt; &lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt; &lt;/a&gt; . Однако, чтобы фактически поддерживать итерацию в обратном порядке, тип итератора &lt;code&gt;T&lt;/code&gt; должен реализовать &lt;code&gt;iterate&lt;/code&gt; для &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; . (Учитывая &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt; , &lt;code&gt;r.itr&lt;/code&gt; итератором типа &lt;code&gt;T&lt;/code&gt; является r.itr .) В нашем примере &lt;code&gt;Squares&lt;/code&gt; мы бы реализовали методы &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e1077394826061ef79c129bd16ea289c7d0ba39" translate="yes" xml:space="preserve">
          <source>It is also possible to apply boldface formatting by using &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; as a color. For instance, to print answers in boldface font, one can use the following as a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Также можно применить форматирование жирным шрифтом, используя &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; в качестве цвета. Например, чтобы напечатать ответы жирным шрифтом, можно использовать следующее как &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
