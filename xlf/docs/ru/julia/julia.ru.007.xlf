<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="2dc2bf0b85cbb2ea7223a1949ab5e752de1aa1c3" translate="yes" xml:space="preserve">
          <source>Double Nested Greater-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Двойное вложенное большое-Тан+комбинация длинного наложения Solidus/нескользящего длинного наложения Slash.</target>
        </trans-unit>
        <trans-unit id="aacb83632e682c3968d8b1ac37c74e451e5d43cb" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than</source>
          <target state="translated">Двойное гнездо Менее чем</target>
        </trans-unit>
        <trans-unit id="f99a04065879ed38c5083c8327002d7fd1bdcc2e" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Двойное вложенное Меньше Тана+Комбинирование длинного наложения солидуса/нескользящего длинного наложения косой черты</target>
        </trans-unit>
        <trans-unit id="c646760ea02101dd2c78e156bd67fbc1e7939279" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than With Underbar</source>
          <target state="translated">Двойное вложенное меньше,чем с нижней полосой</target>
        </trans-unit>
        <trans-unit id="da273e33c1593b23cc1baf0841e4eb0696481ab6" translate="yes" xml:space="preserve">
          <source>Double Plus</source>
          <target state="translated">Двойной плюс</target>
        </trans-unit>
        <trans-unit id="a4eb216c233e5e31eaaa029b5a6659a1175205bf" translate="yes" xml:space="preserve">
          <source>Double Precedes</source>
          <target state="translated">Двойные прецеденты</target>
        </trans-unit>
        <trans-unit id="94596af0b897ecaa403e2b29d5442ffc485744fa" translate="yes" xml:space="preserve">
          <source>Double Prime</source>
          <target state="translated">Двойная премьера</target>
        </trans-unit>
        <trans-unit id="d4bb3033b81e3e5bf5fe1b3d95ec1e84254a8648" translate="yes" xml:space="preserve">
          <source>Double Square Intersection</source>
          <target state="translated">Двойной квадратный перекресток</target>
        </trans-unit>
        <trans-unit id="1cdd297d02a50e98fc796a7bb474ae2cbf5b341e" translate="yes" xml:space="preserve">
          <source>Double Square Union</source>
          <target state="translated">Двойной квадратный союз</target>
        </trans-unit>
        <trans-unit id="8bec3a437a2b0935e9467004616a12d8b9bac5b1" translate="yes" xml:space="preserve">
          <source>Double Subset</source>
          <target state="translated">Двойной поднабор</target>
        </trans-unit>
        <trans-unit id="1f4f518e5cace96063fb6e4842b29d3c3a0bf8a6" translate="yes" xml:space="preserve">
          <source>Double Succeeds</source>
          <target state="translated">Двойной успех</target>
        </trans-unit>
        <trans-unit id="f64b087e350913f39a60133fc102b9f0f94189cc" translate="yes" xml:space="preserve">
          <source>Double Superset</source>
          <target state="translated">Двойной суперсет</target>
        </trans-unit>
        <trans-unit id="ca2705c17942fca00d32bc39c06af31f76ecd340" translate="yes" xml:space="preserve">
          <source>Double Union</source>
          <target state="translated">Двойной союз</target>
        </trans-unit>
        <trans-unit id="f7eafda32018eb8216c74731243d8bcf503ebd15" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Double Right Turnstile</source>
          <target state="translated">Двойной вертикальный пруток Двойной вертикальный пруток Двойной правый турникет</target>
        </trans-unit>
        <trans-unit id="4e0938d334e779c3d4385d240fa933a4aa60bab1" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Left Turnstile</source>
          <target state="translated">Двойной вертикальный пруток левого турникета</target>
        </trans-unit>
        <trans-unit id="bc9a2fa0502c305faf46fd54f952ef44d055b6f5" translate="yes" xml:space="preserve">
          <source>Double Vertical Line / Double Vertical Bar</source>
          <target state="translated">Двойная вертикальная линия/Двойной вертикальный брусок</target>
        </trans-unit>
        <trans-unit id="0c24baa17889b7dd7c44e226a4bfc6668ff9bdeb" translate="yes" xml:space="preserve">
          <source>Double-Ended Multimap</source>
          <target state="translated">Двухстороннее мультикарточное изображение</target>
        </trans-unit>
        <trans-unit id="5fab79944c7fc8e86540423312b6958371754001" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Greater-Than</source>
          <target state="translated">Двойная линия равна или больше-тань.</target>
        </trans-unit>
        <trans-unit id="09e23fb3335770ae7a2fab59103015e6204ac1a9" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Less-Than</source>
          <target state="translated">Двойная линия равна или меньше того.</target>
        </trans-unit>
        <trans-unit id="81443422e1dbb876dc01a2f2800e2f313209c209" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Greater-Than</source>
          <target state="translated">Двухлинейный наклон равный или больше тана.</target>
        </trans-unit>
        <trans-unit id="298a11392e511e8c4817b6337e56afa525bb120d" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Less-Than</source>
          <target state="translated">Двойная линия наклона равна или меньше.</target>
        </trans-unit>
        <trans-unit id="a39c2d49b33b8171f0335f4d62c054ebe50e2949" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Greater-Than Or Equal To</source>
          <target state="translated">Двухлинейный наклонный больше,чем или равный</target>
        </trans-unit>
        <trans-unit id="1a8936fc614fa8b11ad34af0ae168622fd04d79a" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Less-Than Or Equal To</source>
          <target state="translated">Двойная линия наклона меньше,чем та,или равна</target>
        </trans-unit>
        <trans-unit id="5fcd17070ab099bf225ba4ec089d10cd5befd0d0" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital C / Double-Struck C</source>
          <target state="translated">Double-Struck Capital C/Double-Struck C</target>
        </trans-unit>
        <trans-unit id="7fe3d74449be0c8a16270734ac281959d2434acb" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Gamma</source>
          <target state="translated">Гамма капитала двойных грузовиков</target>
        </trans-unit>
        <trans-unit id="2bc51683b00bc656e8387c2a5971b20973b2e68d" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital H / Double-Struck H</source>
          <target state="translated">Double-Struck Capital H/Double-Struck H</target>
        </trans-unit>
        <trans-unit id="77f2a8e846cb9408cb76519191f8677c811ec6c2" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital N / Double-Struck N</source>
          <target state="translated">Капитал N/Капитал N Двойной Станок</target>
        </trans-unit>
        <trans-unit id="3d9ff0d995aa97605586bd26332422b375e0d4da" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital P / Double-Struck P</source>
          <target state="translated">Капитал Двойной Станки P/Двойной Станки P</target>
        </trans-unit>
        <trans-unit id="8e8bbccb682c6db82d059047113f028c1e9e4935" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Pi</source>
          <target state="translated">Double-Struck Capital Pi</target>
        </trans-unit>
        <trans-unit id="43fb013cca9c4a4a8b1a6e51423770297967de57" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Q / Double-Struck Q</source>
          <target state="translated">Double-Struck Capital Q/Double-Struck Q</target>
        </trans-unit>
        <trans-unit id="a7d9b7fa137bc84092b6dbae26b457a275ea3624" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital R / Double-Struck R</source>
          <target state="translated">Капитал R/Капитал R/Капитал Double-Struck R</target>
        </trans-unit>
        <trans-unit id="31b7923fbdad31f1ec3bcd8a5c5055fe73e937d5" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Z / Double-Struck Z</source>
          <target state="translated">Double-Struck Capital Z/Double-Struck Z</target>
        </trans-unit>
        <trans-unit id="22b10852f9529884fb8ade41480e3db571e4dab1" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Capital D</source>
          <target state="translated">Курсив Двухрельефный Курсивный Капитал D</target>
        </trans-unit>
        <trans-unit id="96df4e88f2bfb97c5cf111112b6793cdf4963d06" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small D</source>
          <target state="translated">Двойной стержень курсив Малый D</target>
        </trans-unit>
        <trans-unit id="0ba03aedaaff708d7df7636d4094ce50661bf52b" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small E</source>
          <target state="translated">Двойной стержень курсив Малый E</target>
        </trans-unit>
        <trans-unit id="33fd110b35ce2a0d08df3e940965ae2eec73859f" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small I</source>
          <target state="translated">Double-Struck Italic Small I</target>
        </trans-unit>
        <trans-unit id="e7b00a215e1cd74b1415dfeb4e53c76b770b6715" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small J</source>
          <target state="translated">Двойной стержень курсив Малый J</target>
        </trans-unit>
        <trans-unit id="78f6994be690e96f674586766d03abe261a0d6c0" translate="yes" xml:space="preserve">
          <source>Double-Struck N-Ary Summation</source>
          <target state="translated">Суммация двойных стволов N-Ари</target>
        </trans-unit>
        <trans-unit id="7522a251652bf308c1e54e228103454ad9e38cf3" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Gamma</source>
          <target state="translated">Двухватка Маленькая Гамма</target>
        </trans-unit>
        <trans-unit id="e9209c0ddacbb74a712ae08d417871541bc2ed5d" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Pi</source>
          <target state="translated">Двухватка Маленькая Пи</target>
        </trans-unit>
        <trans-unit id="e32b900891654ad41d9a370dd7666e75c72537ec" translate="yes" xml:space="preserve">
          <source>Doughnut</source>
          <target state="translated">Doughnut</target>
        </trans-unit>
        <trans-unit id="74b33dde33775abd34211cfb4e20f9d6bde3c7a7" translate="yes" xml:space="preserve">
          <source>Down Right Diagonal Ellipsis</source>
          <target state="translated">Правый нижний диагональный эллипсис</target>
        </trans-unit>
        <trans-unit id="b621fc7da134ad1633ff77f53544dd0b2c6c5e6d" translate="yes" xml:space="preserve">
          <source>Down Tack</source>
          <target state="translated">Вниз по лестнице</target>
        </trans-unit>
        <trans-unit id="05c8ca1a817444b080cfc3aca96ff10f7d2bd3d0" translate="yes" xml:space="preserve">
          <source>Down arrow, &lt;code&gt;^N&lt;/code&gt;</source>
          <target state="translated">Стрелка вниз, &lt;code&gt;^N&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c538452cf7c33c2e1a7c6f852e565ccc86225406" translate="yes" xml:space="preserve">
          <source>Down-Pointing Red Triangle</source>
          <target state="translated">Красный Треугольник с нисходящей ориентацией</target>
        </trans-unit>
        <trans-unit id="8bfd316beaffb49e3a9febd43df2eb2cb5afaace" translate="yes" xml:space="preserve">
          <source>Down-Pointing Small Red Triangle</source>
          <target state="translated">Нисходящий Малый Красный Треугольник</target>
        </trans-unit>
        <trans-unit id="17cff6f253715144bf846cc6cb0ca961d48c99f6" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations.</source>
          <target state="translated">Понизьте факторизацию Холецкого &lt;code&gt;C&lt;/code&gt; вектором &lt;code&gt;v&lt;/code&gt; . Если &lt;code&gt;A = C.U'C.U&lt;/code&gt; то &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; но вычисление &lt;code&gt;CC&lt;/code&gt; использует только &lt;code&gt;O(n^2)&lt;/code&gt; операций.</target>
        </trans-unit>
        <trans-unit id="b97c3860e18211639f16883b11f27c780f8f632f" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations. The input factorization &lt;code&gt;C&lt;/code&gt; is updated in place such that on exit &lt;code&gt;C == CC&lt;/code&gt;. The vector &lt;code&gt;v&lt;/code&gt; is destroyed during the computation.</source>
          <target state="translated">Понизьте факторизацию Холецкого &lt;code&gt;C&lt;/code&gt; вектором &lt;code&gt;v&lt;/code&gt; . Если &lt;code&gt;A = C.U'C.U&lt;/code&gt; то &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; но вычисление &lt;code&gt;CC&lt;/code&gt; использует только &lt;code&gt;O(n^2)&lt;/code&gt; операций. Факторизация ввода &lt;code&gt;C&lt;/code&gt; обновляется на месте, так что при выходе &lt;code&gt;C == CC&lt;/code&gt; . В процессе вычисления вектор &lt;code&gt;v&lt;/code&gt; разрушается.</target>
        </trans-unit>
        <trans-unit id="d64fb6577c643a1a98bcc4d17dd77adc7d4f3749" translate="yes" xml:space="preserve">
          <source>Download a file from the given url, optionally renaming it to the given local file name. If no filename is given this will download into a randomly-named file in your temp directory. Note that this function relies on the availability of external tools such as &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;fetch&lt;/code&gt; to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.</source>
          <target state="translated">Загрузите файл с заданного URL-адреса, при желании переименовав его в заданное имя локального файла. Если имя файла не указано, оно будет загружено в файл со случайным именем в вашем временном каталоге. Обратите внимание, что эта функция зависит от наличия внешних инструментов, таких как &lt;code&gt;curl&lt;/code&gt; , &lt;code&gt;wget&lt;/code&gt; или &lt;code&gt;fetch&lt;/code&gt; , для загрузки файла и предоставляется для удобства. Для производственного использования или ситуаций, в которых необходимы дополнительные параметры, используйте вместо этого пакет, который обеспечивает желаемую функциональность.</target>
        </trans-unit>
        <trans-unit id="08c3c7d3645a4ce6730f3721ad47fc2949dc976a" translate="yes" xml:space="preserve">
          <source>Downwards Arrow / Down Arrow</source>
          <target state="translated">Стрелка вниз/Стрелка вниз</target>
        </trans-unit>
        <trans-unit id="7dce0d557028c5dea3dace158554e15d9784698b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow From Bar / Down Arrow From Bar</source>
          <target state="translated">Стрелка вниз от бара/Стрелка вниз от бара</target>
        </trans-unit>
        <trans-unit id="0d1345aef883b3624d484df6c78fa1499f363962" translate="yes" xml:space="preserve">
          <source>Downwards Arrow Leftwards Of Upwards Arrow</source>
          <target state="translated">Стрелка вниз Стрелка влево Стрелка вниз Стрелка вверх</target>
        </trans-unit>
        <trans-unit id="2156bac33a07bff1c6168c184044e461147f3221" translate="yes" xml:space="preserve">
          <source>Downwards Arrow To Bar</source>
          <target state="translated">Стрелка вниз к барной стойке</target>
        </trans-unit>
        <trans-unit id="6a3f0e1b85e70e46f52c461b297ce3b234dd2b8e" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Corner Leftwards / Down Arrow With Corner Left</source>
          <target state="translated">Стрелка вниз с углами влево/Стрелка вниз с углами влево</target>
        </trans-unit>
        <trans-unit id="22f12c6b38c168555c766d9ecd689bee73798e7b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Double Stroke / Down Arrow With Double Stroke</source>
          <target state="translated">Стрелка вниз с двойным ходом/Стрелка вниз с двойным ходом</target>
        </trans-unit>
        <trans-unit id="3e70b3fbb5e1272dbfb2768c6abc80ebc34f5538" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Horizontal Stroke</source>
          <target state="translated">Стрелка вниз с горизонтальным ходом</target>
        </trans-unit>
        <trans-unit id="c1bc962d484f0e77f2bb2b3688fdfa2d1422bc61" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Leftwards / Down Arrow With Tip Left</source>
          <target state="translated">Стрелка вниз с наконечником влево/Стрелка вниз с наконечником влево</target>
        </trans-unit>
        <trans-unit id="6f17c4c1d048a9705300c820118cf36a53d197eb" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Rightwards / Down Arrow With Tip Right</source>
          <target state="translated">Стрелка вниз с наконечником вправо/Стрелка вниз с наконечником вправо</target>
        </trans-unit>
        <trans-unit id="77827f24b06007c8351d7b42f91be0b4d539c6de" translate="yes" xml:space="preserve">
          <source>Downwards Black Arrow</source>
          <target state="translated">Черная стрелка вниз</target>
        </trans-unit>
        <trans-unit id="b75b010ebb988c0b894244b49f47de83c298a210" translate="yes" xml:space="preserve">
          <source>Downwards Dashed Arrow / Down Dashed Arrow</source>
          <target state="translated">Пробеленная вниз/Пробеленная вниз стрелка</target>
        </trans-unit>
        <trans-unit id="b052c2e01abe8207481638ce404112cf6c895155" translate="yes" xml:space="preserve">
          <source>Downwards Double Arrow / Down Double Arrow</source>
          <target state="translated">Двойная стрелка вниз Двойная стрелка/Стрелка вниз Двойная стрелка</target>
        </trans-unit>
        <trans-unit id="39618206cc6f04a2548c6e3a46f1c96431d17934" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right</source>
          <target state="translated">Нисходящий гарпун с Барб слева рядом вниз гарпун с Барб направо</target>
        </trans-unit>
        <trans-unit id="61e7d9beabf27ce96043173d50a1ffbcb3c8f195" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right</source>
          <target state="translated">Нисходящий гарпун с Барб слева вверх,гарпун с Барб справа.</target>
        </trans-unit>
        <trans-unit id="8f99b76aec3d61f79f81cc67881ebb3880b49671" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left From Bar</source>
          <target state="translated">Внизу гарпун с Барб,слева от бара.</target>
        </trans-unit>
        <trans-unit id="0a957078126f861ff70d4cccc6ee4961501ca412" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left To Bar</source>
          <target state="translated">Гарпун вниз с Барб левой в бар.</target>
        </trans-unit>
        <trans-unit id="20016dc34aed751d644d5eba1c2ce94f4ccb571f" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Leftwards / Down Harpoon With Barb Left</source>
          <target state="translated">Нижний гарпун с Барб налево/Нижний гарпун с Барб налево</target>
        </trans-unit>
        <trans-unit id="43ff08d740eada07edb33d8b4d43a32fe54cdb0c" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right From Bar</source>
          <target state="translated">Гарпун вниз с Барб прямо из бара.</target>
        </trans-unit>
        <trans-unit id="fdcd989ee2f4eed7638bcc66aefc50676e2d0de3" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right To Bar</source>
          <target state="translated">Гарпун вниз с Барб Прямо в бар.</target>
        </trans-unit>
        <trans-unit id="70698ae85402133e06db357acf28e4adb5132348" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Rightwards / Down Harpoon With Barb Right</source>
          <target state="translated">Вниз гарпун с Барб Справа/Вниз гарпун с Барб Справа</target>
        </trans-unit>
        <trans-unit id="e991bdc2966ff71e9f056a8cb1f209c18137ee66" translate="yes" xml:space="preserve">
          <source>Downwards Paired Arrows / Down Paired Arrows</source>
          <target state="translated">Парные стрелки вниз/парные стрелки вниз</target>
        </trans-unit>
        <trans-unit id="708fb5fb1095e517bca56d05c3a07607b86eea24" translate="yes" xml:space="preserve">
          <source>Downwards Quadruple Arrow</source>
          <target state="translated">Четырехкратная стрелка вниз</target>
        </trans-unit>
        <trans-unit id="7832bc44c221f296a0a3557341bf5711ce0ad13e" translate="yes" xml:space="preserve">
          <source>Downwards Triple Arrow</source>
          <target state="translated">Тройная стрелка вниз</target>
        </trans-unit>
        <trans-unit id="71c2a3e9e5d53ca7e448be0dc997a3840d8ffbe4" translate="yes" xml:space="preserve">
          <source>Downwards Two Headed Arrow / Down Two Headed Arrow</source>
          <target state="translated">Вниз Две головные стрелки/Вниз Две головные стрелки</target>
        </trans-unit>
        <trans-unit id="20bd273f7536e79d1e647c7a4805a10cc0a6024f" translate="yes" xml:space="preserve">
          <source>Downwards White Arrow / White Down Arrow</source>
          <target state="translated">Белая стрелка вниз/Белая стрелка вниз</target>
        </trans-unit>
        <trans-unit id="dee70c16d9a7402c3ff7c179d417c02524182f20" translate="yes" xml:space="preserve">
          <source>Downwards Zigzag Arrow / Down Zigzag Arrow</source>
          <target state="translated">Стрелка вниз Стрелка Зигзаг/Стрелка вниз Стрелка Зигзаг</target>
        </trans-unit>
        <trans-unit id="0f0c13b35658b4610aac908bd6f900baccfacc2c" translate="yes" xml:space="preserve">
          <source>Drafting Point Rightwards Arrow / Drafting Point Right Arrow</source>
          <target state="translated">Стрелка &quot;Редактирующая точка вправо&quot;/Стрелка &quot;Редактирующая точка вправо</target>
        </trans-unit>
        <trans-unit id="eb22c5e28adf024cfee08804c00ddb9ac2973892" translate="yes" xml:space="preserve">
          <source>Dragon</source>
          <target state="translated">Dragon</target>
        </trans-unit>
        <trans-unit id="b1d5fd0950f3316f4c616ebe016d1f72cbdff89e" translate="yes" xml:space="preserve">
          <source>Dragon Face</source>
          <target state="translated">Лицо дракона</target>
        </trans-unit>
        <trans-unit id="f61e33bf74dc6cb23e31a4742f4452d5d238daaf" translate="yes" xml:space="preserve">
          <source>Dress</source>
          <target state="translated">Dress</target>
        </trans-unit>
        <trans-unit id="eaae1cbe655bd67615f32293502367c2637ee817" translate="yes" xml:space="preserve">
          <source>Dromedary Camel</source>
          <target state="translated">верблюд-ромадарий</target>
        </trans-unit>
        <trans-unit id="f9b83daeec2460cd138ef6a2f12cc6f1f9046683" translate="yes" xml:space="preserve">
          <source>Droplet</source>
          <target state="translated">Droplet</target>
        </trans-unit>
        <trans-unit id="5462217de65ccce13656393863d3f8b9357c723d" translate="yes" xml:space="preserve">
          <source>Due to its packed storage format, concurrent access to the elements of a &lt;code&gt;BitArray&lt;/code&gt; where at least one of them is a write is not thread safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4743db582f1472d30e534715a34bc56d951fe4b6" translate="yes" xml:space="preserve">
          <source>Due to the colloquial usage of &lt;code&gt;sha256&lt;/code&gt; to refer to &lt;code&gt;sha2_256&lt;/code&gt;, convenience functions are provided, mapping &lt;code&gt;shaxxx()&lt;/code&gt; function calls to &lt;code&gt;sha2_xxx()&lt;/code&gt;. For SHA-3, no such colloquialisms exist and the user must use the full &lt;code&gt;sha3_xxx()&lt;/code&gt; names.</source>
          <target state="translated">Из-за разговорного использования &lt;code&gt;sha256&lt;/code&gt; для ссылки на &lt;code&gt;sha2_256&lt;/code&gt; , предоставляются &lt;code&gt;shaxxx()&lt;/code&gt; функции , отображающие вызовы функций &lt;code&gt;sha2_xxx()&lt;/code&gt; на sha2_xxx () . Для SHA-3 таких разговорных &lt;code&gt;sha3_xxx()&lt;/code&gt; не существует, и пользователь должен использовать полные имена sha3_xxx () .</target>
        </trans-unit>
        <trans-unit id="2ede46a500ade748ac355337b865cbc0acd19bf6" translate="yes" xml:space="preserve">
          <source>Durations/Comparisons</source>
          <target state="translated">Durations/Comparisons</target>
        </trans-unit>
        <trans-unit id="9dfdb39c23a955cc3f51336a0530f2307a456f87" translate="yes" xml:space="preserve">
          <source>Dvd</source>
          <target state="translated">Dvd</target>
        </trans-unit>
        <trans-unit id="34b40a7ef9ec304a622a57c3ab20b2c39518c944" translate="yes" xml:space="preserve">
          <source>Dynamic Linker</source>
          <target state="translated">Динамический связующее звено</target>
        </trans-unit>
        <trans-unit id="dc0def730e20d274cc00210435f7d12be805f16c" translate="yes" xml:space="preserve">
          <source>Dynamic documentation</source>
          <target state="translated">Динамическая документация</target>
        </trans-unit>
        <trans-unit id="085752d538f762ff5754a9aa26842e80bb0818e2" translate="yes" xml:space="preserve">
          <source>E-Mail Symbol</source>
          <target state="translated">иконка электронной почты</target>
        </trans-unit>
        <trans-unit id="7e7d5355c188b846aca335184bbeb5367a48b580" translate="yes" xml:space="preserve">
          <source>E.g., if &lt;code&gt;A&lt;/code&gt; is a matrix, &lt;code&gt;dims=1&lt;/code&gt; will sort rows, &lt;code&gt;dims=2&lt;/code&gt; will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</source>
          <target state="translated">Например, если &lt;code&gt;A&lt;/code&gt; - матрица, &lt;code&gt;dims=1&lt;/code&gt; сортирует строки, &lt;code&gt;dims=2&lt;/code&gt; сортирует столбцы. Обратите внимание, что функция сравнения по умолчанию на одномерных срезах сортируется лексикографически.</target>
        </trans-unit>
        <trans-unit id="1c8872365c161a3e67efcc3a61e6bdd7bd82ccf5" translate="yes" xml:space="preserve">
          <source>ENDIAN_BOM</source>
          <target state="translated">ENDIAN_BOM</target>
        </trans-unit>
        <trans-unit id="086bfb42cb0e1f0682c42f25c92a8f7e76b5bda4" translate="yes" xml:space="preserve">
          <source>ENV</source>
          <target state="translated">ENV</target>
        </trans-unit>
        <trans-unit id="7b9e6e531c95a34720d1a8d1d5a2c5f1c560afeb" translate="yes" xml:space="preserve">
          <source>EOFError</source>
          <target state="translated">EOFError</target>
        </trans-unit>
        <trans-unit id="6c745d78cc4826efc22c10c011aab3cf174ad141" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; contains the function name, file name, line number, lambda info, a flag indicating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer representation of the pointer returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Каждый &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; содержит имя функции, имя файла, номер строки, лямбда-информацию, флаг, указывающий, был ли фрейм встроен, флаг, указывающий, является ли это функцией C (по умолчанию функции C не отображаются в трассировке стека) , и целочисленное представление указателя, возвращаемого &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a765a9a50809d8eeae2747483abc88ca1bb085e7" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b43a1b63da011682c91ea2326629ce626a8f4ec" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;ArgumentValue&lt;/code&gt; to &lt;code&gt;llvmcall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;ArgumentType&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt;.</source>
          <target state="translated">Каждое значение &lt;code&gt;ArgumentValue&lt;/code&gt; в &lt;code&gt;llvmcall&lt;/code&gt; будет преобразовано в соответствующий тип &lt;code&gt;ArgumentType&lt;/code&gt; путем автоматической вставки вызовов &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt; . (Смотрите также документацию по &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt; для получения более подробной информации.) В большинстве случаев это просто приводит к вызову &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3efd270aff2961e629ca01262fed000c080a030f" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;argvalue&lt;/code&gt; to &lt;code&gt;@ccall&lt;/code&gt; is converted to the corresponding &lt;code&gt;argtype&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16639880e3d78941c163af0b97ffa26b4ba639e4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;argvalue&lt;/code&gt; to the &lt;code&gt;ccall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;argtype&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt;.</source>
          <target state="translated">Каждое значение &lt;code&gt;argvalue&lt;/code&gt; для &lt;code&gt;ccall&lt;/code&gt; будет преобразовано в соответствующий &lt;code&gt;argtype&lt;/code&gt; путем автоматической вставки вызовов &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt; . (Смотрите также документацию по &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt; для получения более подробной информации.) В большинстве случаев это просто приводит к вызову &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87cceae9fc7cfd4af0f8243a86a72515045e2992" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;lock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Каждой &lt;code&gt;lock&lt;/code&gt; должна соответствовать &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a58a43e2467e832b243587c5b856d542f30f944" translate="yes" xml:space="preserve">
          <source>Each Julia process thus has 31 communication tasks.</source>
          <target state="translated">Таким образом,каждый процесс Джулии имеет 31 коммуникационную задачу.</target>
        </trans-unit>
        <trans-unit id="90eeb77500114235cd36d8d57b969eb1e5584ef6" translate="yes" xml:space="preserve">
          <source>Each event generates several pieces of data, some provided by the user and some automatically extracted. Let's examine the user-defined data first:</source>
          <target state="translated">Каждое событие генерирует несколько фрагментов данных,часть из которых предоставляется пользователем,а часть автоматически извлекается.Сначала рассмотрим пользовательские данные:</target>
        </trans-unit>
        <trans-unit id="6afa6a3549818bce117962a7026f18062cf8f803" translate="yes" xml:space="preserve">
          <source>Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are implemented) takes in either an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a &lt;code&gt;ByteString&lt;/code&gt; or an &lt;code&gt;IO&lt;/code&gt; object. This makes it trivial to checksum a file:</source>
          <target state="translated">Каждая экспортируемая функция (на момент написания этой статьи реализованы функции SHA-1, SHA-2 224, 256, 384 и 512 и SHA-3 224, 256, 384 и 512) принимает либо &lt;code&gt;Array{UInt8}&lt;/code&gt; , либо &lt;code&gt;ByteString&lt;/code&gt; или &lt;code&gt;IO&lt;/code&gt; объект. Это упрощает вычисление контрольной суммы файла:</target>
        </trans-unit>
        <trans-unit id="a27894f5ec437e16c54a81d270d486f77eb240c6" translate="yes" xml:space="preserve">
          <source>Each kind of environment defines these three maps differently, as detailed in the following sections.</source>
          <target state="translated">Каждый вид среды определяет эти три карты по-разному,как подробно описано в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="1ff693f28cccaa9f352f467474efbdadbcecc29f" translate="yes" xml:space="preserve">
          <source>Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first &quot;field&quot; is the number of backtraces (samples) taken &lt;em&gt;at this line or in any functions executed by this line&lt;/em&gt;. The second field is the file name and line number and the third field is the function name. Note that the specific line numbers may change as Julia's code changes; if you want to follow along, it's best to run this example yourself.</source>
          <target state="translated">Каждая строка этого дисплея представляет собой конкретное место (номер строки) в коде. Отступы используются для обозначения вложенной последовательности вызовов функций, при этом строки с большим отступом становятся глубже в последовательности вызовов. В каждой строке первое &amp;laquo;поле&amp;raquo; - это количество трассировок (выборок), взятых &lt;em&gt;в этой строке или в любых функциях, выполняемых этой строкой&lt;/em&gt; . Второе поле - это имя файла и номер строки, а третье поле - имя функции. Обратите внимание, что конкретные номера строк могут измениться по мере изменения кода Джулии; Если вы хотите продолжить, лучше всего выполнить этот пример самостоятельно.</target>
        </trans-unit>
        <trans-unit id="01a2902c277d245e34b708c7aa314c4d33622ac3" translate="yes" xml:space="preserve">
          <source>Each method of a generated function has its own view of defined functions:</source>
          <target state="translated">Каждый метод генерируемой функции имеет свой взгляд на определенные функции:</target>
        </trans-unit>
        <trans-unit id="b280a43cc4fcfe2d9e44a5ed377411ad6dd61b84" translate="yes" xml:space="preserve">
          <source>Each module introduces a new global scope, separate from the global scope of all other modules&amp;mdash;there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the &lt;a href=&quot;../modules/index#modules&quot;&gt;using or import&lt;/a&gt; statements or through qualified access using the dot-notation, i.e. each module is a so-called &lt;em&gt;namespace&lt;/em&gt; as well as a first-class data structure associating names with values. Note that while variable bindings can be read externally, they can only be changed within the module to which they belong. As an escape hatch, you can always evaluate code inside that module to modify a variable; this guarantees, in particular, that module bindings cannot be modified externally by code that never calls &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3717f137bf0edf07318a78ca822c93213e8ab5c5" translate="yes" xml:space="preserve">
          <source>Each module introduces a new global scope, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;using or import&lt;/a&gt; statements or through qualified access using the dot-notation, i.e. each module is a so-called &lt;em&gt;namespace&lt;/em&gt;. Note that variable bindings can only be changed within their global scope and not from an outside module.</source>
          <target state="translated">Каждый модуль представляет новую глобальную область видимости, отдельную от глобальной области видимости всех других модулей; не существует всеобъемлющей глобальной области. Модули могут вводить переменные других модулей в свою область видимости посредством операторов &lt;a href=&quot;../modules/index#modules-1&quot;&gt;using или import&lt;/a&gt; или посредством квалифицированного доступа с использованием точечной нотации, то есть каждый модуль является так называемым &lt;em&gt;пространством имен&lt;/em&gt; . Обратите внимание, что привязки переменных могут быть изменены только в их глобальной области, а не из внешнего модуля.</target>
        </trans-unit>
        <trans-unit id="bf0da81b3dc87a0fd15f25539852984a31877c54" translate="yes" xml:space="preserve">
          <source>Each process has an associated identifier. The process providing the interactive Julia prompt always has an &lt;code&gt;id&lt;/code&gt; equal to 1. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1.</source>
          <target state="translated">У каждого процесса есть связанный идентификатор. Процесс, предоставляющий интерактивную подсказку Julia, всегда имеет &lt;code&gt;id&lt;/code&gt; равный 1. Процессы, используемые по умолчанию для параллельных операций, называются &amp;laquo;рабочими&amp;raquo;. Когда есть только один процесс, процесс 1 считается рабочим. В противном случае рабочими считаются все процессы, кроме процесса 1.</target>
        </trans-unit>
        <trans-unit id="4cf2bd42913eae23239a3ca6155fa30e146609bc" translate="yes" xml:space="preserve">
          <source>Each process has an associated identifier. The process providing the interactive Julia prompt always has an &lt;code&gt;id&lt;/code&gt; equal to 1. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1. As a result, adding 2 or more processes is required to gain benefits from parallel processing methods like &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt;. Adding a single process is beneficial if you just wish to do other things in the main process while a long computation is running on the worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df120cd43c18561cb64b8f7f625bd660e549595" translate="yes" xml:space="preserve">
          <source>Each scope must have only one call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. Hence, if all variables cannot be pushed once by a single call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:</source>
          <target state="translated">В каждой области должен быть только один вызов &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; . Следовательно, если все переменные не могут быть переданы один раз одним вызовом &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; , или если нужно передать более 6 переменных и использование массива аргументов не является вариантом, тогда можно использовать внутренние блоки:</target>
        </trans-unit>
        <trans-unit id="d282bb8a2c865839d970ad58b137b93bc00c7f72" translate="yes" xml:space="preserve">
          <source>Each successful &lt;code&gt;trylock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Каждая успешная &lt;code&gt;trylock&lt;/code&gt; &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; должна сопровождаться разблокировкой .</target>
        </trans-unit>
        <trans-unit id="22844561d348de2a6b27cf89433a65f8efbcb6b9" translate="yes" xml:space="preserve">
          <source>Each task handles all incoming messages from a single remote worker in a message-processing loop.</source>
          <target state="translated">Каждая задача обрабатывает все входящие сообщения от одного удаленного работника в цикле обработки сообщений.</target>
        </trans-unit>
        <trans-unit id="959d90366413778f223799834532da2e5d798af8" translate="yes" xml:space="preserve">
          <source>Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.</source>
          <target state="translated">Каждый работник привязывается только к одному из локальных интерфейсов и прослушивает эфемерный номер порта,назначенный операционной системой.</target>
        </trans-unit>
        <trans-unit id="7f33a61e2ebfeda0d2e414fecf682c309512f02f" translate="yes" xml:space="preserve">
          <source>Each worker connects to all workers whose &lt;code&gt;id&lt;/code&gt; is less than the worker's own &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">Каждый воркер подключается ко всем воркерам, чей &lt;code&gt;id&lt;/code&gt; меньше собственного &lt;code&gt;id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="296ff54bedf2c4c2f12fadf9f3d4dae7319b0178" translate="yes" xml:space="preserve">
          <source>Each worker starts listening on a free port and writes out its host and port information to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Каждый рабочий начинает прослушивать свободный порт и записывает информацию о своем хосте и порте в стандартный &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b6573c03375a2d09bcdcc1d5adf31597eebb48" translate="yes" xml:space="preserve">
          <source>Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.</source>
          <target state="translated">С нетерпением оцените транспонирование ленивой матрицы/сопряжение.Обратите внимание,что транспозиция применяется рекурсивно к элементам.</target>
        </trans-unit>
        <trans-unit id="27b938020515cf5bb6d2984093bfbe7ab6d70ad5" translate="yes" xml:space="preserve">
          <source>Ear</source>
          <target state="translated">Ear</target>
        </trans-unit>
        <trans-unit id="f97bff7e2b8198bfce99e20d9dc3037ca7cb582c" translate="yes" xml:space="preserve">
          <source>Ear Of Maize</source>
          <target state="translated">Кукурузный ушко</target>
        </trans-unit>
        <trans-unit id="3d9d70794f61bff1149af95c6f4cc244fdd11015" translate="yes" xml:space="preserve">
          <source>Ear Of Rice</source>
          <target state="translated">Рисовое ухо</target>
        </trans-unit>
        <trans-unit id="b212969dc9e512428d09170cadc608095d96ef4b" translate="yes" xml:space="preserve">
          <source>Early filtering and message handling</source>
          <target state="translated">Ранняя фильтрация и обработка сообщений</target>
        </trans-unit>
        <trans-unit id="02013cc67046fdd1aae8de2e9297f90c75b1d103" translate="yes" xml:space="preserve">
          <source>Early filtering of events</source>
          <target state="translated">Ранняя фильтрация событий</target>
        </trans-unit>
        <trans-unit id="45ba28d774fd86488ce1c503089d1e80918e6cda" translate="yes" xml:space="preserve">
          <source>Earth Globe Americas</source>
          <target state="translated">Земля Земля Американский континент</target>
        </trans-unit>
        <trans-unit id="32a31b8413404bbe823a0be0f2215daa04efa961" translate="yes" xml:space="preserve">
          <source>Earth Globe Asia-Australia</source>
          <target state="translated">Земной шар Азия-Австралия</target>
        </trans-unit>
        <trans-unit id="e225e5febaa3e5d132e6c4f42f17f6e28d6415c5" translate="yes" xml:space="preserve">
          <source>Earth Globe Europe-Africa</source>
          <target state="translated">Земля Земля Европа-Африка</target>
        </trans-unit>
        <trans-unit id="38a01a67cf8e4d332986b68f2fc71763c696a896" translate="yes" xml:space="preserve">
          <source>Edit a file or directory optionally providing a line number to edit the file at. Return to the &lt;code&gt;julia&lt;/code&gt; prompt when you quit the editor. The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">Отредактируйте файл или каталог, при необходимости указав номер строки для редактирования файла. Вернитесь к приглашению &lt;code&gt;julia&lt;/code&gt; после выхода из редактора. Редактор можно изменить, установив &lt;code&gt;JULIA_EDITOR&lt;/code&gt; , &lt;code&gt;VISUAL&lt;/code&gt; или &lt;code&gt;EDITOR&lt;/code&gt; в качестве переменной среды.</target>
        </trans-unit>
        <trans-unit id="96bf75cf90aee425bd296ba4a82e787d511340ac" translate="yes" xml:space="preserve">
          <source>Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For modules, open the main source file. The module needs to be loaded with &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; first.</source>
          <target state="translated">Отредактируйте определение функции, при необходимости указав кортеж типов, чтобы указать, какой метод редактировать. Для модулей откройте основной исходный файл. Модуль необходимо сначала загрузить с &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f916e6f9856dcbd1006ae78298c4b5adcd077534" translate="yes" xml:space="preserve">
          <source>Editors which cannot open to a specific line with a command may ignore the &lt;code&gt;line&lt;/code&gt; argument. The &lt;code&gt;fn&lt;/code&gt; callback must return either an appropriate &lt;code&gt;Cmd&lt;/code&gt; object to open a file or &lt;code&gt;nothing&lt;/code&gt; to indicate that they cannot edit this file. Use &lt;code&gt;nothing&lt;/code&gt; to indicate that this editor is not appropriate for the current environment and another editor should be attempted. It is possible to add more general editing hooks that need not spawn external commands by pushing a callback directly to the vector &lt;code&gt;EDITOR_CALLBACKS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c375fe45e00ed5d286a20e4c69197b11257ae1df" translate="yes" xml:space="preserve">
          <source>Efficient algorithms are implemented for &lt;code&gt;H \ b&lt;/code&gt;, &lt;code&gt;det(H)&lt;/code&gt;, and similar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dc07f2fcde6067bce262b5efc8feb032594384" translate="yes" xml:space="preserve">
          <source>Efficient support for &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, including but not limited to &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;</source>
          <target state="translated">Эффективная поддержка &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; , включая, помимо прочего, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="86a35f1cb66a4b67fe0a08c54f9a06ca22ca2502" translate="yes" xml:space="preserve">
          <source>Eight Pointed Black Star</source>
          <target state="translated">Восьмиконечная чёрная звезда</target>
        </trans-unit>
        <trans-unit id="b096e49c067864c8657cc77cb2489f9c7a46a60c" translate="yes" xml:space="preserve">
          <source>Eight Spoked Asterisk</source>
          <target state="translated">Восемь остроконечная звездочка</target>
        </trans-unit>
        <trans-unit id="64b33bc5b072bf67cae39a4367e9262f072d0983" translate="yes" xml:space="preserve">
          <source>Eighth Note</source>
          <target state="translated">Восьмая нота</target>
        </trans-unit>
        <trans-unit id="3e48f6a437e3973638b906ba62fc55ca1cbd9219" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;EltypeUnknown()&lt;/code&gt; or &lt;code&gt;HasEltype()&lt;/code&gt; as appropriate</source>
          <target state="translated">Либо &lt;code&gt;EltypeUnknown()&lt;/code&gt; либо &lt;code&gt;HasEltype()&lt;/code&gt; в зависимости от ситуации.</target>
        </trans-unit>
        <trans-unit id="a0e204f765f5ad928475881aca7c13ef5c65e351" translate="yes" xml:space="preserve">
          <source>Electric Light Bulb</source>
          <target state="translated">Электрическая лампочка</target>
        </trans-unit>
        <trans-unit id="b15c5b6da40c647c02530732f2c154f67995f39b" translate="yes" xml:space="preserve">
          <source>Electric Plug</source>
          <target state="translated">Электрическая вилка</target>
        </trans-unit>
        <trans-unit id="3f114e1bd5e42dad4fb0e15a6f2fe2cdbffd8d5c" translate="yes" xml:space="preserve">
          <source>Electric Torch</source>
          <target state="translated">Электрический фонарик</target>
        </trans-unit>
        <trans-unit id="8bc90f041dc25b644c48594037e5678f3120b766" translate="yes" xml:space="preserve">
          <source>Electrical Intersection</source>
          <target state="translated">Электрический взаимопересечение</target>
        </trans-unit>
        <trans-unit id="94a626de4e05a050364a69d3ed8b52928fa721f2" translate="yes" xml:space="preserve">
          <source>Elegant and extensible conversions and promotions for numeric and other types</source>
          <target state="translated">Элегантные и расширяемые преобразования и акции для числовых и других типов</target>
        </trans-unit>
        <trans-unit id="b145388f2a6c1f663c46cc3fef6df0278b0d0e7b" translate="yes" xml:space="preserve">
          <source>Element Of</source>
          <target state="translated">элемент</target>
        </trans-unit>
        <trans-unit id="c7e75d5c58d3d99fb0549bbb6eebd8b77418f140" translate="yes" xml:space="preserve">
          <source>Element Of Opening Downwards</source>
          <target state="translated">Элемент открытия вниз</target>
        </trans-unit>
        <trans-unit id="ec9d5e51a88871a1e6bce9e1d8f55eddb1be4d6d" translate="yes" xml:space="preserve">
          <source>Element Of Opening Upwards</source>
          <target state="translated">Элемент открытия вверх</target>
        </trans-unit>
        <trans-unit id="eabe348be570b5c3a81b5a78a24f6bc500a5b337" translate="yes" xml:space="preserve">
          <source>Element Of With Dot Above</source>
          <target state="translated">Элемент с точкой выше</target>
        </trans-unit>
        <trans-unit id="17bfb5ca72c4a27f20d3d15f5185aabec39f3a3b" translate="yes" xml:space="preserve">
          <source>Element Of With Long Horizontal Stroke</source>
          <target state="translated">Элемент с длинным горизонтальным ходом</target>
        </trans-unit>
        <trans-unit id="f3443f2657692062978d73b4527d8f3f59f40708" translate="yes" xml:space="preserve">
          <source>Element Of With Overbar</source>
          <target state="translated">Элемент с перекладиной</target>
        </trans-unit>
        <trans-unit id="0335789ad2498b26e35d6c835f82cac2d005c318" translate="yes" xml:space="preserve">
          <source>Element Of With Two Horizontal Strokes</source>
          <target state="translated">Элемент из двух горизонтальных ударов...</target>
        </trans-unit>
        <trans-unit id="71f5f71f9939ea54d51a735c864b74e3967c3ba7" translate="yes" xml:space="preserve">
          <source>Element Of With Underbar</source>
          <target state="translated">Элемент с нижней планкой</target>
        </trans-unit>
        <trans-unit id="256f897f2234cedafe188f182b0344400f8e1c28" translate="yes" xml:space="preserve">
          <source>Element Of With Vertical Bar At End Of Horizontal Stroke</source>
          <target state="translated">Элемент с вертикальной штангой в конце горизонтального хода</target>
        </trans-unit>
        <trans-unit id="86ab7fa25cb358d66e37e0c0a1c13bec1b3787f5" translate="yes" xml:space="preserve">
          <source>Elementary Functions</source>
          <target state="translated">Элементарные функции</target>
        </trans-unit>
        <trans-unit id="97b701a83c60171055869225a728b6d2098cfc55" translate="yes" xml:space="preserve">
          <source>Elementary operations</source>
          <target state="translated">элементарная деятельность</target>
        </trans-unit>
        <trans-unit id="1c6f116ce35bbe8b5c5b3a26cfa9e63c4b7cff24" translate="yes" xml:space="preserve">
          <source>Elephant</source>
          <target state="translated">Elephant</target>
        </trans-unit>
        <trans-unit id="628aee648dc7795c701c3ac4168565c49ba7d8a8" translate="yes" xml:space="preserve">
          <source>Eliminates array bounds checking within expressions.</source>
          <target state="translated">Устраняет проверку границ массивов внутри выражений.</target>
        </trans-unit>
        <trans-unit id="436e5580dafe4837fafc385b6832e44770757da8" translate="yes" xml:space="preserve">
          <source>Em Dash</source>
          <target state="translated">Эм Дэш</target>
        </trans-unit>
        <trans-unit id="54edea64256fec1b9afd042056c683a5e954b05d" translate="yes" xml:space="preserve">
          <source>Em Space</source>
          <target state="translated">Эм Спейс</target>
        </trans-unit>
        <trans-unit id="fd5fa6acc8725853ec64793d0347faa7182d2f81" translate="yes" xml:space="preserve">
          <source>Embedding Julia</source>
          <target state="translated">Эмбеддинг Джулия</target>
        </trans-unit>
        <trans-unit id="8638f2d27f26ab330e90a52d10d3ba6e903a995b" translate="yes" xml:space="preserve">
          <source>Emit bounds checks always or never (ignoring declarations)</source>
          <target state="translated">Всегда или никогда (без учета деклараций)не допускать проверок.</target>
        </trans-unit>
        <trans-unit id="6822793744c195c06628e13a8e25bb8ee807d832" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-1-2</source>
          <target state="translated">Модификатор Emoji Фитцпатрик Тип-1-2</target>
        </trans-unit>
        <trans-unit id="e7d0e508f11f735e99c8bf9621166a5b98508edb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-3</source>
          <target state="translated">Модификатор Emoji Фитцпатрик Тип-3</target>
        </trans-unit>
        <trans-unit id="27052bd6bf6386f71c6cd2f5155906907462e4eb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-4</source>
          <target state="translated">Модификатор Emoji Фитцпатрик Тип-4</target>
        </trans-unit>
        <trans-unit id="1a1f8c73826ca18825ae5fad787b1128670acb3c" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-5</source>
          <target state="translated">Модификатор Emoji Фитцпатрик Тип-5</target>
        </trans-unit>
        <trans-unit id="ddf70184418afb46c24a9ba734226beae8038ce5" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-6</source>
          <target state="translated">Модификатор Emoji Фитцпатрик Тип-6</target>
        </trans-unit>
        <trans-unit id="92732205e250b4761981020982f3419de88cf7db" translate="yes" xml:space="preserve">
          <source>Empty Set</source>
          <target state="translated">Пустой набор</target>
        </trans-unit>
        <trans-unit id="8ec062085bcc2b801f216fc4c40783b689f973cf" translate="yes" xml:space="preserve">
          <source>Empty Set With Left Arrow Above</source>
          <target state="translated">Пустой набор с левой стрелкой выше</target>
        </trans-unit>
        <trans-unit id="d91ae9a03edea62c7bd20d9ba629d7162aa63219" translate="yes" xml:space="preserve">
          <source>Empty Set With Overbar</source>
          <target state="translated">Пустой набор с надбавкой</target>
        </trans-unit>
        <trans-unit id="6d8f951440669eb13bd78e4eb7585eb670aa5993" translate="yes" xml:space="preserve">
          <source>Empty Set With Right Arrow Above</source>
          <target state="translated">Пустой набор со стрелкой вправо выше</target>
        </trans-unit>
        <trans-unit id="43f45b3c27e994f1786fe11853d88094ff3f0d3a" translate="yes" xml:space="preserve">
          <source>Empty Set With Small Circle Above</source>
          <target state="translated">Пустой набор с малым кругом выше</target>
        </trans-unit>
        <trans-unit id="5ebfd6f75b259f38d9a9191637cf54107c71d5e2" translate="yes" xml:space="preserve">
          <source>Empty arrays like &lt;code&gt;[]&lt;/code&gt;, which select no elements</source>
          <target state="translated">Пустые массивы, такие как &lt;code&gt;[]&lt;/code&gt; , которые не выбирают элементы</target>
        </trans-unit>
        <trans-unit id="d1b6081c62b3668f73437e7ef55230193e6e2dec" translate="yes" xml:space="preserve">
          <source>Empty generic functions</source>
          <target state="translated">Пустые общие функции</target>
        </trans-unit>
        <trans-unit id="74006a3cefa65eb24a50f14a080a0a283848825f" translate="yes" xml:space="preserve">
          <source>En Dash</source>
          <target state="translated">Эн Дэш</target>
        </trans-unit>
        <trans-unit id="1628cc600d641d86574721f4cba6f82ac4859ad1" translate="yes" xml:space="preserve">
          <source>En Space</source>
          <target state="translated">En Space</target>
        </trans-unit>
        <trans-unit id="c26082fba43142d1c87a99220a9c21dffcbbcbfe" translate="yes" xml:space="preserve">
          <source>Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)</source>
          <target state="translated">Включить/Установить уровень генерации отладочной информации (по умолчанию уровень 1,если не указан,или 2,если используется без уровня).</target>
        </trans-unit>
        <trans-unit id="cdf7726a55289566143a4b529102535c5730b7a5" translate="yes" xml:space="preserve">
          <source>Enable N threads; &lt;code&gt;auto&lt;/code&gt; currently sets N to the number of local CPU threads but this might change in the future</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89b819c104d36c25c43b4b3679d57166fd8a76d" translate="yes" xml:space="preserve">
          <source>Enable debug logging for a file or module, see &lt;a href=&quot;../../stdlib/logging/index#Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d7732e401f3ac5abd96dcf18eb471bc62eedcf" translate="yes" xml:space="preserve">
          <source>Enable or disable Julia's default signal handlers</source>
          <target state="translated">Включить или выключить обработчики сигналов по умолчанию Джулии.</target>
        </trans-unit>
        <trans-unit id="868de4fff11fc1378b5bf090b18d305dd45bc334" translate="yes" xml:space="preserve">
          <source>Enable or disable color text</source>
          <target state="translated">Включить или выключить цветной текст</target>
        </trans-unit>
        <trans-unit id="5c9a249a64cc4fd650a34fa825cad6ef21b766ee" translate="yes" xml:space="preserve">
          <source>Enable or disable incremental precompilation of modules</source>
          <target state="translated">Включить или выключить инкрементальную прекомпиляцию модулей</target>
        </trans-unit>
        <trans-unit id="a51c0e3a6688b962a589c4b3871584f7a8a45cd2" translate="yes" xml:space="preserve">
          <source>Enable or disable method overwrite warnings</source>
          <target state="translated">Включить или выключить метод перезаписи предупреждений</target>
        </trans-unit>
        <trans-unit id="aca528646e6712e710558c2a4eb1f14f7c2f63c3" translate="yes" xml:space="preserve">
          <source>Enable or disable startup banner</source>
          <target state="translated">Включить или выключить стартовый баннер</target>
        </trans-unit>
        <trans-unit id="2ca0be31a9b9b42744412a3827771e952db1ba08" translate="yes" xml:space="preserve">
          <source>Enable or disable syntax and method deprecation warnings (&lt;code&gt;error&lt;/code&gt; turns warnings into errors)</source>
          <target state="translated">Включение или отключение предупреждений &lt;code&gt;error&lt;/code&gt; устаревании синтаксиса и методов ( ошибка превращает предупреждения в ошибки)</target>
        </trans-unit>
        <trans-unit id="dd61ab9cf22b749efe0c17fd33d2e5ed63c746f4" translate="yes" xml:space="preserve">
          <source>Enable the GC, return previous state as int</source>
          <target state="translated">Включите GC,верните предыдущее состояние как int</target>
        </trans-unit>
        <trans-unit id="8e8469c75c7e1c37ce55e37721cd77e479242109" translate="yes" xml:space="preserve">
          <source>Enables or disables Nagle's algorithm on a given TCP server or socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab95ff490fda9c25eacf7c86628805a78ecd8fa" translate="yes" xml:space="preserve">
          <source>End Of Proof</source>
          <target state="translated">Конец доказательства</target>
        </trans-unit>
        <trans-unit id="ad9d937f40f9885915fd0bc9430bfd7d6e63f0d4" translate="yes" xml:space="preserve">
          <source>End With Leftwards Arrow Above</source>
          <target state="translated">Завершите с левой стрелкой выше</target>
        </trans-unit>
        <trans-unit id="348ce364668910edabfd008dfd0d3a94254a6fef" translate="yes" xml:space="preserve">
          <source>End, &lt;code&gt;^E&lt;/code&gt;</source>
          <target state="translated">Конец, &lt;code&gt;^E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0891cb9306e1015f2471b30de2c6d9cc3c5bab0c" translate="yes" xml:space="preserve">
          <source>Ensuring that all arguments support broadcast</source>
          <target state="translated">Обеспечение того,чтобы все аргументы поддерживали трансляцию</target>
        </trans-unit>
        <trans-unit id="a74398c918fa81c3c891469eb00e56ab1bce6a94" translate="yes" xml:space="preserve">
          <source>Enter help or shell mode (when at start of a line)</source>
          <target state="translated">Войти в режим справки или оболочки (когда в начале строки)</target>
        </trans-unit>
        <trans-unit id="e641b987ac9e8ea3ec201a6a67556391d2e16178" translate="yes" xml:space="preserve">
          <source>Enum constant for &lt;a href=&quot;#Libdl.dlopen&quot;&gt;&lt;code&gt;dlopen&lt;/code&gt;&lt;/a&gt;. See your platform man page for details, if applicable.</source>
          <target state="translated">Константа &lt;a href=&quot;#Libdl.dlopen&quot;&gt; &lt;code&gt;dlopen&lt;/code&gt; &lt;/a&gt; для dlopen . См. Подробности на странице руководства вашей платформы, если применимо.</target>
        </trans-unit>
        <trans-unit id="3d4759b02e49d42abcfd8c6da270947288cfdfb3" translate="yes" xml:space="preserve">
          <source>Enums.@enum</source>
          <target state="translated">Enums.@enum</target>
        </trans-unit>
        <trans-unit id="9848c4523e6e3aa918b1c25741d4c5549ef8d0ad" translate="yes" xml:space="preserve">
          <source>Enums.Enum</source>
          <target state="translated">Enums.Enum</target>
        </trans-unit>
        <trans-unit id="cc756bbce5c6a1daad1db7d15c8a2dcefb92b0e6" translate="yes" xml:space="preserve">
          <source>EnvDict</source>
          <target state="translated">EnvDict</target>
        </trans-unit>
        <trans-unit id="7f4a2c89d81b1eddb2e5160fabf3758acbd3a82d" translate="yes" xml:space="preserve">
          <source>Envelope</source>
          <target state="translated">Envelope</target>
        </trans-unit>
        <trans-unit id="6762c5bdd1e043549bb3b44e75155fdf9be1b7a5" translate="yes" xml:space="preserve">
          <source>Envelope With Downwards Arrow Above</source>
          <target state="translated">Конверт со стрелкой сверху вниз</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">Переменные среды</target>
        </trans-unit>
        <trans-unit id="941617a2c1b6b1aec2faae0db722ab34dd080e87" translate="yes" xml:space="preserve">
          <source>Environment stacks</source>
          <target state="translated">Экологические стеки</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">Переменные среды</target>
        </trans-unit>
        <trans-unit id="89641f9fa6e1bc519a9a2c77cb0174bd0af98e58" translate="yes" xml:space="preserve">
          <source>Environment variables :</source>
          <target state="translated">Переменные среды :</target>
        </trans-unit>
        <trans-unit id="19f829a38150f040480818f9393c99b2f11589f5" translate="yes" xml:space="preserve">
          <source>Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI terminal escape sequences&lt;/a&gt;. Julia provides a high-level interface with much of the same functionality; see the section on &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;The Julia REPL&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ee4c027fd890e4de416f6f3ab9a71f9c9e72e8" translate="yes" xml:space="preserve">
          <source>Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI terminal escape sequences&lt;/a&gt;. Julia provides a high-level interface with much of the same functionality; see the section on &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;.</source>
          <target state="translated">Переменные среды, определяющие формат вывода REPL на терминале. Как правило, эти переменные должны быть установлены как &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;escape-последовательности терминала ANSI&lt;/a&gt; . Julia предоставляет высокоуровневый интерфейс с большей частью той же функциональности; см. раздел, посвященный &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;REPL Юлии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="3adc5cf208fce048a876da30f12ee121f6e24ef5" translate="yes" xml:space="preserve">
          <source>Equal And Parallel To</source>
          <target state="translated">Равный и параллельный</target>
        </trans-unit>
        <trans-unit id="9014b90f8a5c287f9f7cca7cf1a09f7419d2e0a4" translate="yes" xml:space="preserve">
          <source>Equal To By Definition</source>
          <target state="translated">Равны по определению</target>
        </trans-unit>
        <trans-unit id="527d2270efb77ab589aa3d2bc8b1899c1c160dcc" translate="yes" xml:space="preserve">
          <source>Equal To Or Greater-Than / Equal To Or Greater Than</source>
          <target state="translated">Равно или больше,чем та,или больше.</target>
        </trans-unit>
        <trans-unit id="6043f4fef98b74458e43463764bf902e73e8ff02" translate="yes" xml:space="preserve">
          <source>Equal To Or Less-Than / Equal To Or Less Than</source>
          <target state="translated">Равно или меньше,или меньше,чем</target>
        </trans-unit>
        <trans-unit id="f6b115d144ac2f3557f089ae7d83d11f870e6ef8" translate="yes" xml:space="preserve">
          <source>Equal To Or Precedes</source>
          <target state="translated">Равный или предшествующий</target>
        </trans-unit>
        <trans-unit id="3e050032f44766762506ff80de8be9a1911a3683" translate="yes" xml:space="preserve">
          <source>Equal To Or Succeeds</source>
          <target state="translated">Равенство или успех</target>
        </trans-unit>
        <trans-unit id="15cfd415b36fe06b7025888786ae38085fcb3dbe" translate="yes" xml:space="preserve">
          <source>Equality and Comparison Operators</source>
          <target state="translated">Равенство и сравнение Операторы</target>
        </trans-unit>
        <trans-unit id="d8dae2f241fe4b5c985e7ee897c6b9676b9479ac" translate="yes" xml:space="preserve">
          <source>Equals Colon / Equal Colon</source>
          <target state="translated">Равноценный полковник/Равноценный полковник</target>
        </trans-unit>
        <trans-unit id="f93dc9419a85602368082c386c9a828a21bf6a6a" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Leftwards Arrow</source>
          <target state="translated">Знак равенства Стрелка над левой стрелкой</target>
        </trans-unit>
        <trans-unit id="ec3132ed55f4f598ba853ce4e35988f1d955c3eb" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Plus Sign</source>
          <target state="translated">Равняется знаку выше плюс</target>
        </trans-unit>
        <trans-unit id="77fb2dbe6663a45556f7650f2f6c1c73a590ed1c" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Tilde Operator</source>
          <target state="translated">Равнозначный сигнал над оператором тильды</target>
        </trans-unit>
        <trans-unit id="62609b0cf8c4d06d3037a7bf8e6a793f1d27492d" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel</source>
          <target state="translated">Равнозначный сигнал и наклонная параллель</target>
        </trans-unit>
        <trans-unit id="23b4d26cbdac9571083cacc41611600ec79ff967" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel With Tilde Above</source>
          <target state="translated">Равнозначный сигнал и наклон параллельно с тильдой выше</target>
        </trans-unit>
        <trans-unit id="392e4a8368a67b37c46109802dbf3b2bbe627e02" translate="yes" xml:space="preserve">
          <source>Equals Sign With Bumpy Above</source>
          <target state="translated">Равный сигнал с ухабистой поверхностью</target>
        </trans-unit>
        <trans-unit id="f2b106f710b9bbc7d6d2a380faea7b8fd23ed23a" translate="yes" xml:space="preserve">
          <source>Equals Sign With Dot Below</source>
          <target state="translated">Равный сигнал с точкой внизу</target>
        </trans-unit>
        <trans-unit id="292a343448e994eeed1ffd3fdb4c2c8eb86b5555" translate="yes" xml:space="preserve">
          <source>Equals Sign With Two Dots Above And Two Dots Below</source>
          <target state="translated">Равный сигнал с двумя точками выше и двумя точками ниже</target>
        </trans-unit>
        <trans-unit id="5e945a1cf2921ae612b33494ebe19cfd549e10ac" translate="yes" xml:space="preserve">
          <source>Equals With Asterisk</source>
          <target state="translated">Равны со звездочкой</target>
        </trans-unit>
        <trans-unit id="f3f7928443c385bebfa509e6448cd7d63a9cc4a2" translate="yes" xml:space="preserve">
          <source>Equiangular To</source>
          <target state="translated">Прямоугольный К</target>
        </trans-unit>
        <trans-unit id="0dae504b4d888ad200cb544ee05069b242235880" translate="yes" xml:space="preserve">
          <source>Equivalent To</source>
          <target state="translated">Эквивалентному</target>
        </trans-unit>
        <trans-unit id="209bb1206181d9c196e80f6965debb3ab3399f46" translate="yes" xml:space="preserve">
          <source>Equivalent With Four Dots Above</source>
          <target state="translated">Эквивалент с четырьмя точками выше</target>
        </trans-unit>
        <trans-unit id="bdeb0fcd2d5eaaa85eb93b2bbb4eae42f75d7875" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</source>
          <target state="translated">Эквивалентно &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a444cba5b25b06d85c75d2cdc5490f28108cce13" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawn expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;fetch(@spawn expr)&lt;/code&gt; . Смотрите &lt;code&gt;fetch&lt;/code&gt; и &lt;a href=&quot;#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04a15056af777844fc12e01881e2375b1a9bb29c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawnat :any expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3145567457b210ea2803bee24b9156158b97cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt; . Смотрите &lt;code&gt;fetch&lt;/code&gt; и &lt;a href=&quot;#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce9a67772da7b41e7c54b6a2b9da8ba6fbcc2a7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git branch&lt;/code&gt;. Create a new branch from the current HEAD.</source>
          <target state="translated">Эквивалентен &lt;code&gt;git branch&lt;/code&gt; . Создайте новую ветку из текущего HEAD.</target>
        </trans-unit>
        <trans-unit id="8ad57947a691137150d754570a8ec38ac67d31bf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d743c43b1f86bc4c8cac6b46919f9f746db86863" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt;. Checkout the git commit &lt;code&gt;commit&lt;/code&gt; (a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) in &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, force the checkout and discard any current changes. Note that this detaches the current HEAD.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt; . &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; фиксацию &lt;code&gt;commit&lt;/code&gt; git ( GitHash в строковой форме) в &lt;code&gt;repo&lt;/code&gt; . Если &lt;code&gt;force&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , принудительно выполнить проверку и отменить любые текущие изменения. Обратите внимание, что это отключает текущую HEAD.</target>
        </trans-unit>
        <trans-unit id="901e29752c2ee8a70b5ed5fe68c348abc419a1fa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bad74bb24ad9c1d3be87108ffc378bb2da2cc9f9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d427754f80d9c8df017cbc0092318835b0e696" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f8f3cd0f685b341a1ae14b9341b4e36c903d172" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="332ee7d1accb14409369b51e9d27080d4e0d14ed" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0083711cca7b02373661eae132e8a9c8507549ec" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eabda327026b4f99bb6d32a8fbcdc496382a0b31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6790132b2a9497e212bac7d4cf8fd0dd3edd5e55" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652b9155620394c1b1868072030e6b42f726640f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26a71f2870da7113263fbb72943176e45aaa35d2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git update-index&lt;/code&gt;. Return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;repo&lt;/code&gt; needs updating.</source>
          <target state="translated">Эквивалентно &lt;code&gt;git update-index&lt;/code&gt; . Верните &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;repo&lt;/code&gt; нужно обновить.</target>
        </trans-unit>
        <trans-unit id="f6ae3107848d44951e6909ca431ab304a4e9d539" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).ctime&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;stat(file).ctime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a4ce7135ab64a453fd910fc4aa56e36ba1ee2e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mode&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;stat(file).mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a1382d7c1945d0f98e93198d22d79e261cf0056" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mtime&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;stat(file).mtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe4fd466e331817e41386a75031f2b796ddfe458" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).size&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;stat(file).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e823580a07913d38604c722d16a5560458f01a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is in position &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; где &lt;code&gt;i&lt;/code&gt; находится в позиции &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f31ba230aca25c1b698d1cc7150cef0b7b302c5" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно вызову &lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9eaa630d94bb27275e18bb3b960a961c0a1f0f4b" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;char&lt;/code&gt; c-type.</source>
          <target state="translated">Эквивалентен типу &lt;code&gt;char&lt;/code&gt; c-type.</target>
        </trans-unit>
        <trans-unit id="118bc4f07f9064de09c7d27e3dc69b842c07d3cb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;double&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен родному &lt;code&gt;double&lt;/code&gt; c-типу ( &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bdf6e4eb22892b98b092275da9c573a01025062d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;float&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалент нативному типу &lt;code&gt;float&lt;/code&gt; c ( &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="699b0aa6e72445454df17960d3daa3c9e6cc0497" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;intmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалент &lt;code&gt;intmax_t&lt;/code&gt; c-типу intmax_t ( &lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb40c99637fa47e326a9d7aab30c227079ce80bd" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type (&lt;code&gt;Int&lt;/code&gt;).</source>
          <target state="translated">Эквивалент нативному &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type ( &lt;code&gt;Int&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="864b89ace5975f766b1aac60a330727b39bce821" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен собственному &lt;code&gt;signed int&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="42f2a96aef8ef6b3b801a9ca2e3e8f2afcb4b1e9" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен собственному &lt;code&gt;signed long long&lt;/code&gt; c-типу ( &lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a5cd170ceee5df72650f75fb3558c1e0d584a0dc" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long&lt;/code&gt; c-type.</source>
          <target state="translated">Эквивалентен родному &lt;code&gt;signed long&lt;/code&gt; типу c.</target>
        </trans-unit>
        <trans-unit id="8bc320fb0e8a7512a786d769855e2e089a153ce2" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен родному &lt;code&gt;signed short&lt;/code&gt; c-типу ( &lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e69f65df3ca222b477f6e9993f20448b4bdae0f" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;size_t&lt;/code&gt; c-type (&lt;code&gt;UInt&lt;/code&gt;).</source>
          <target state="translated">Эквивалентен собственному c-типу &lt;code&gt;size_t&lt;/code&gt; ( &lt;code&gt;UInt&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="264d1040fe211b837b556b11ff091efb6a3f53bb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ssize_t&lt;/code&gt; c-type.</source>
          <target state="translated">Эквивалент нативному &lt;code&gt;ssize_t&lt;/code&gt; c-type.</target>
        </trans-unit>
        <trans-unit id="dbd9e2c996a261d76f3ff53391f8e38719fe9e6e" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;uintmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалент нативному &lt;code&gt;uintmax_t&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c8ce8fa159766da046ddd33786548e72dee4d9d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned char&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен собственному типу &lt;code&gt;unsigned char&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="344ab3cdb03d54ba12a0e16e58a7476236a61e4d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен собственному &lt;code&gt;unsigned int&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="55d9ab0846117166f39d8e403505f1471a82f976" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен собственному &lt;code&gt;unsigned long long&lt;/code&gt; c-типу ( &lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b3c06e09eab11aa3d1730ea23df9a5045171b15" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long&lt;/code&gt; c-type.</source>
          <target state="translated">Эквивалентен родному &lt;code&gt;unsigned long&lt;/code&gt; c-типу.</target>
        </trans-unit>
        <trans-unit id="016e279d1d48e1d87938958891ce84c0cfdfcbbb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалент нативному &lt;code&gt;unsigned short&lt;/code&gt; c-типу ( &lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c9bbcb68fcb17f0cce9547b0872debb3c579553" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;wchar_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалент нативному &lt;code&gt;wchar_t&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="698b31ff8b5d1a102369509499209b09eacc9225" translate="yes" xml:space="preserve">
          <source>Errors can also be handled by retrying failed computations. Keyword arguments &lt;code&gt;retry_delays&lt;/code&gt; and &lt;code&gt;retry_check&lt;/code&gt; are passed through to &lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt;&lt;code&gt;retry&lt;/code&gt;&lt;/a&gt; as keyword arguments &lt;code&gt;delays&lt;/code&gt; and &lt;code&gt;check&lt;/code&gt; respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</source>
          <target state="translated">Ошибки также можно исправить, повторив неудачные вычисления. Аргументы &lt;code&gt;retry_delays&lt;/code&gt; слова retry_delays и &lt;code&gt;retry_check&lt;/code&gt; передаются для &lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt; &lt;code&gt;retry&lt;/code&gt; &lt;/a&gt; попытки, поскольку аргументы ключевого слова &lt;code&gt;delays&lt;/code&gt; и &lt;code&gt;check&lt;/code&gt; соответственно. Если указано пакетирование, и весь пакет не удается, все элементы в пакете повторяются.</target>
        </trans-unit>
        <trans-unit id="e1d7a4876d3316d08fbc2b13153db110692b9665" translate="yes" xml:space="preserve">
          <source>Escaped backslash (&lt;code&gt;\\&lt;/code&gt;)</source>
          <target state="translated">Экранированная обратная косая черта ( &lt;code&gt;\\&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cc1c125b60f307138cb9e72beb52b2e7792689de" translate="yes" xml:space="preserve">
          <source>Escaped double-quote (&lt;code&gt;\&quot;&lt;/code&gt;)</source>
          <target state="translated">Экранированные двойные кавычки ( &lt;code&gt;\&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="06580f39a051b4e6ef99253897a370dadc16359c" translate="yes" xml:space="preserve">
          <source>Essentials</source>
          <target state="translated">Essentials</target>
        </trans-unit>
        <trans-unit id="e8510e15707f994fff8e2c28fa38378116dc350d" translate="yes" xml:space="preserve">
          <source>Estimates</source>
          <target state="translated">Estimates</target>
        </trans-unit>
        <trans-unit id="b9ba339b04699a110d3fe7f5b9f39b67a033e6ff" translate="yes" xml:space="preserve">
          <source>Estimates the error in the solution to &lt;code&gt;A * X = B&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt;, or the equivalent equations a right-handed &lt;code&gt;side = R&lt;/code&gt;&lt;code&gt;X * A&lt;/code&gt; after computing &lt;code&gt;X&lt;/code&gt; using &lt;code&gt;trtrs!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is upper triangular. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is lower triangular. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;Ferr&lt;/code&gt; and &lt;code&gt;Berr&lt;/code&gt; are optional inputs. &lt;code&gt;Ferr&lt;/code&gt; is the forward error and &lt;code&gt;Berr&lt;/code&gt; is the backward error, each component-wise.</source>
          <target state="translated">Оценивает ошибку в решении &lt;code&gt;A * X = B&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(A) * X = B&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; ) for &lt;code&gt;side = L&lt;/code&gt; , или эквивалентные уравнения: правая &lt;code&gt;side = R&lt;/code&gt; &lt;code&gt;X * A&lt;/code&gt; после вычисления &lt;code&gt;X&lt;/code&gt; с помощью &lt;code&gt;trtrs!&lt;/code&gt; , Если &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; - верхний треугольник. Если &lt;code&gt;uplo = L&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; - нижний треугольник. Если &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; имеет неединичные диагональные элементы. Если &lt;code&gt;diag = U&lt;/code&gt; , все диагональные элементы &lt;code&gt;A&lt;/code&gt; - одно. &lt;code&gt;Ferr&lt;/code&gt; и &lt;code&gt;Berr&lt;/code&gt; - необязательные входы. &lt;code&gt;Ferr&lt;/code&gt; - это прямая ошибка, а &lt;code&gt;Berr&lt;/code&gt; - обратная ошибка, по каждому компоненту.</target>
        </trans-unit>
        <trans-unit id="f36e35f5e8b00caa694f59163398facd608ea93b" translate="yes" xml:space="preserve">
          <source>Euler Constant / Eulers</source>
          <target state="translated">Эйлер Констант/Эйлеры</target>
        </trans-unit>
        <trans-unit id="2e207df50d2607a1fe4fc27fe314291135737c83" translate="yes" xml:space="preserve">
          <source>Euler's constant.</source>
          <target state="translated">постоянная Эйлера.</target>
        </trans-unit>
        <trans-unit id="44623d7804a9c26efcde5e7649c3cb20b91a39c3" translate="yes" xml:space="preserve">
          <source>Euro Sign</source>
          <target state="translated">знак Евро</target>
        </trans-unit>
        <trans-unit id="57a3202bd3e441520bd7d609cab598bcb00faf56" translate="yes" xml:space="preserve">
          <source>European Castle</source>
          <target state="translated">Европейский замок</target>
        </trans-unit>
        <trans-unit id="c85713b44c54b59d5e3730564793b844ff3a2225" translate="yes" xml:space="preserve">
          <source>European Post Office</source>
          <target state="translated">Европейское почтовое отделение</target>
        </trans-unit>
        <trans-unit id="70431e2cf67367675e48b7000db056935aff96a4" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Оценить &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07ce5a176f4ebcfe9263b70e6399c95e665e2889" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; and display the result</source>
          <target state="translated">Вычислить &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; и отобразить результат</target>
        </trans-unit>
        <trans-unit id="25162b98d6071e304907ff82a3a467fb9271d77e" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the given module and return the result.</source>
          <target state="translated">Оцените выражение в данном модуле и верните результат.</target>
        </trans-unit>
        <trans-unit id="8f829ca8274917256304e4a58cd74009eea2d9d8" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the global scope of the containing module. Every &lt;code&gt;Module&lt;/code&gt; (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;eval&lt;/code&gt;, which evaluates expressions in that module.</source>
          <target state="translated">Вычислить выражение в глобальной области действия содержащего модуля. Каждый &lt;code&gt;Module&lt;/code&gt; (кроме определенных с помощью &lt;code&gt;baremodule&lt;/code&gt; ) имеет собственное определение &lt;code&gt;eval&lt;/code&gt; с одним аргументом , которое оценивает выражения в этом модуле.</target>
        </trans-unit>
        <trans-unit id="2601dc536c9d898fbb26df788d4c9e5325bd9791" translate="yes" xml:space="preserve">
          <source>Evaluate an expression with values interpolated into it using &lt;code&gt;eval&lt;/code&gt;. If two arguments are provided, the first is the module to evaluate in.</source>
          <target state="translated">Оцените выражение со значениями, вставленными в него, используя &lt;code&gt;eval&lt;/code&gt; . Если предоставлены два аргумента, первый - это модуль, в котором выполняется оценка.</target>
        </trans-unit>
        <trans-unit id="0e1822550830e88855261b7ab222f92611690733" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of module &lt;code&gt;m&lt;/code&gt;. Every module (except those defined with &lt;a href=&quot;#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">Оцените содержимое входного исходного файла в глобальной области видимости модуля &lt;code&gt;m&lt;/code&gt; . Каждый модуль ( за исключением тех , которые определены с &lt;a href=&quot;#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt; ) имеет свое собственное определение 1 аргументами &lt;code&gt;include&lt;/code&gt; , который оценивает файл в этом модуле. Возвращает результат последнего вычисленного выражения входного файла. Во время включения локальный путь включения задается для каталога, содержащего файл. Вложенные вызовы &lt;code&gt;include&lt;/code&gt; будут искать относительно этого пути. Эта функция обычно используется для интерактивной загрузки исходного кода или для объединения файлов в пакеты, которые разбиты на несколько исходных файлов.</target>
        </trans-unit>
        <trans-unit id="b612928c09f072c08e5798d5159ed31466947d90" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of module &lt;code&gt;m&lt;/code&gt;. Every module (except those defined with &lt;a href=&quot;#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt;) has its own definition of &lt;code&gt;include&lt;/code&gt; omitting the &lt;code&gt;m&lt;/code&gt; argument, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d4172b689085063db7676aaaf218e8295b9200" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">Оцените содержимое входного исходного файла в глобальной области содержащего модуля. Каждый модуль ( за исключением тех , которые определены с &lt;code&gt;baremodule&lt;/code&gt; ) имеет свое собственное определение 1 аргументами &lt;code&gt;include&lt;/code&gt; , который оценивает файл в этом модуле. Возвращает результат последнего вычисленного выражения входного файла. Во время включения локальный путь включения задается для каталога, содержащего файл. Вложенные вызовы &lt;code&gt;include&lt;/code&gt; будут искать относительно этого пути. Эта функция обычно используется для интерактивной загрузки исходного кода или для объединения файлов в пакеты, которые разбиты на несколько исходных файлов.</target>
        </trans-unit>
        <trans-unit id="d9f1c29d4ad5838bc52b4059149cf23bc056eedf" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf5bd09edaddcf11f7e48b14ce64a359652894a" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k c[k] z^{k-1}$ for the coefficients &lt;code&gt;c[1]&lt;/code&gt;, &lt;code&gt;c[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;z&lt;/code&gt;. This macro expands to efficient inline code that uses either Horner's method or, for complex &lt;code&gt;z&lt;/code&gt;, a more efficient Goertzel-like algorithm.</source>
          <target state="translated">Вычислите полином $ \ sum_k c [k] z ^ {k-1} $ для коэффициентов &lt;code&gt;c[1]&lt;/code&gt; , &lt;code&gt;c[2]&lt;/code&gt; , ...; то есть коэффициенты даны в порядке возрастания степени &lt;code&gt;z&lt;/code&gt; . Этот макрос расширяется до эффективного встроенного кода, который использует либо метод Хорнера, либо, для сложных &lt;code&gt;z&lt;/code&gt; , более эффективный алгоритм, подобный Гертцеля.</target>
        </trans-unit>
        <trans-unit id="17bdebb1637db1ca1fe9844da888b02d8d7bfdc0" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k x^{k-1} p[k]$ for the coefficients &lt;code&gt;p[1]&lt;/code&gt;, &lt;code&gt;p[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;x&lt;/code&gt;. Loops are unrolled at compile time if the number of coefficients is statically known, i.e. when &lt;code&gt;p&lt;/code&gt; is a &lt;code&gt;Tuple&lt;/code&gt;. This function generates efficient code using Horner's method if &lt;code&gt;x&lt;/code&gt; is real, or using a Goertzel-like &lt;sup&gt;&lt;a href=&quot;#footnote-DK62&quot; id=&quot;citeref-DK62&quot;&gt;[DK62]&lt;/a&gt;&lt;/sup&gt; algorithm if &lt;code&gt;x&lt;/code&gt; is complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c283394a3475c9f10b4259ae3690af8f5faa1d" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k z^{k-1} c[k]$ for the coefficients &lt;code&gt;c[1]&lt;/code&gt;, &lt;code&gt;c[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;z&lt;/code&gt;. This macro expands to efficient inline code that uses either Horner's method or, for complex &lt;code&gt;z&lt;/code&gt;, a more efficient Goertzel-like algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf82123eb8f03dbfcdf15d386b828c44539c7f3" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt;&lt;code&gt;code_llvm&lt;/code&gt;&lt;/a&gt; on the resulting expression. Set the optional keyword arguments &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;dump_module&lt;/code&gt;, &lt;code&gt;debuginfo&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt; by putting them and their value before the function call, like this:</source>
          <target state="translated">Оценивает аргументы вызова функции или макроса, определяет их типы и вызывает &lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt; &lt;code&gt;code_llvm&lt;/code&gt; &lt;/a&gt; для полученного выражения. Установите необязательные аргументы ключевого слова &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;dump_module&lt;/code&gt; , &lt;code&gt;debuginfo&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , поместив их и их значение перед вызовом функции, например:</target>
        </trans-unit>
        <trans-unit id="0574281a0958da4e1fedb99a3969efb400d9fd77" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">Оценивает аргументы вызова функции или макроса, определяет их типы и вызывает &lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt; для полученного выражения.</target>
        </trans-unit>
        <trans-unit id="088bbc9cbb660de44f799b6c6a191524f6690255" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">Оценивает аргументы вызова функции или макроса, определяет их типы и вызывает &lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt; для полученного выражения.</target>
        </trans-unit>
        <trans-unit id="86161509c0da7e0e06a0044e2d468e8408652cab" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt;&lt;code&gt;code_lowered&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">Оценивает аргументы вызова функции или макроса, определяет их типы и вызывает &lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt; &lt;code&gt;code_lowered&lt;/code&gt; &lt;/a&gt; для полученного выражения.</target>
        </trans-unit>
        <trans-unit id="d170313f77b7bcf562ce6e89794d222a66dc883d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt;&lt;code&gt;code_typed&lt;/code&gt;&lt;/a&gt; on the resulting expression. Use the optional argument &lt;code&gt;optimize&lt;/code&gt; with</source>
          <target state="translated">Оценивает аргументы вызова функции или макроса, определяет их типы и вызывает &lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt; &lt;code&gt;code_typed&lt;/code&gt; &lt;/a&gt; для полученного выражения. Используйте необязательный аргумент &lt;code&gt;optimize&lt;/code&gt; с</target>
        </trans-unit>
        <trans-unit id="84c0397d7e38cfd74be0824e7f63562d46240019" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;edit&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">Оценивает аргументы для вызова функции или макроса, определяет их типы и вызывает функцию &lt;code&gt;edit&lt;/code&gt; для полученного выражения.</target>
        </trans-unit>
        <trans-unit id="fca23945bcd8a8eb5e9f3ee416d4703a5d82433d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;less&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">Оценивает аргументы функции или вызова макроса, определяет их типы и вызывает функцию &lt;code&gt;less&lt;/code&gt; для полученного выражения.</target>
        </trans-unit>
        <trans-unit id="2278317a19c030d07ee978a6edb3e56c37e01040" translate="yes" xml:space="preserve">
          <source>Evaluating expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbabc83f5b048a0e83e97e9b394f27da706b3e88" translate="yes" xml:space="preserve">
          <source>Evaluation Scope of Default Values</source>
          <target state="translated">Оценка Масштаб значений по умолчанию</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="01624c7776323f5a2680a97bd186745ab3cf1f28" translate="yes" xml:space="preserve">
          <source>Event processing is controlled by overriding functions associated with &lt;code&gt;AbstractLogger&lt;/code&gt;:</source>
          <target state="translated">Обработка событий контролируется переопределяющими функциями, связанными с &lt;code&gt;AbstractLogger&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="e8a98dc3ac17ae3d77b1ddc48b9496c80b2623e7" translate="yes" xml:space="preserve">
          <source>Evergreen Tree</source>
          <target state="translated">вечнозелёное дерево</target>
        </trans-unit>
        <trans-unit id="5d19898d878c5e7ae6a6206e54d456e97f3d4151" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;../modules/index#modules&quot;&gt;module&lt;/a&gt; has its own &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; function that evaluates expressions in its global scope. Expressions passed to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; are not limited to returning values &amp;ndash; they can also have side-effects that alter the state of the enclosing module's environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d21058e9a447b8fa599cb386e31bf0f68fa38e3" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;../modules/index#modules-1&quot;&gt;module&lt;/a&gt; has its own &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; function that evaluates expressions in its global scope. Expressions passed to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; are not limited to returning values &amp;ndash; they can also have side-effects that alter the state of the enclosing module's environment:</source>
          <target state="translated">Каждый &lt;a href=&quot;../modules/index#modules-1&quot;&gt;модуль&lt;/a&gt; имеет свою собственную функцию &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; ,&lt;/a&gt; которая оценивает выражения в своей глобальной области видимости. Выражения, передаваемые в &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; , не ограничиваются возвращаемыми значениями - они также могут иметь побочные эффекты, которые изменяют состояние окружения включающего модуля:</target>
        </trans-unit>
        <trans-unit id="ff9db205866ccce1546fa3a3f0dcf16499413e68" translate="yes" xml:space="preserve">
          <source>Every Julia program starts life as a string:</source>
          <target state="translated">Каждая программа Джулии начинает жизнь как строка:</target>
        </trans-unit>
        <trans-unit id="554f49a29b61819b844be413863c737b1ffe0f6b" translate="yes" xml:space="preserve">
          <source>Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a &lt;code&gt;=&lt;/code&gt; immediately after the operator. For example, writing &lt;code&gt;x += 3&lt;/code&gt; is equivalent to writing &lt;code&gt;x = x + 3&lt;/code&gt;:</source>
          <target state="translated">Каждый двоичный арифметический и побитовый оператор также имеет обновленную версию, которая присваивает результат операции обратно своему левому операнду. Обновляемая версия бинарного оператора формируется путем помещения &lt;code&gt;=&lt;/code&gt; сразу после оператора. Например, запись &lt;code&gt;x += 3&lt;/code&gt; эквивалентна записи &lt;code&gt;x = x + 3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="74d163370c2dd6c3a91981ad81aefa6f4ddbb3ff" translate="yes" xml:space="preserve">
          <source>Every concrete value in the system is an instance of some &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">Каждое конкретное значение в системе является экземпляром некоторого &lt;code&gt;DataType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6ede3443e8f7e99e3d1681b81b7bd2c9c393a0" translate="yes" xml:space="preserve">
          <source>Every worker is also notified of other workers in the cluster.</source>
          <target state="translated">Каждый работник также уведомляется о других работниках кластера.</target>
        </trans-unit>
        <trans-unit id="3da573171e36ece7f0a3ae53192e2857a7114b29" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex double&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*16&lt;/code&gt; in Fortran).</source>
          <target state="translated">Точно соответствует &lt;code&gt;complex double&lt;/code&gt; типу double в C (или &lt;code&gt;COMPLEX*16&lt;/code&gt; в Фортране).</target>
        </trans-unit>
        <trans-unit id="12b877c370c66bac293ce599efbe5b9cfed8d671" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex float&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">Точно соответствует &lt;code&gt;complex float&lt;/code&gt; типу float в C (или &lt;code&gt;COMPLEX*8&lt;/code&gt; в Фортране).</target>
        </trans-unit>
        <trans-unit id="9f324ad0c495e9b10cd207dd5c4138beb2a008e4" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;double&lt;/code&gt; type in C (or &lt;code&gt;REAL*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">Точно соответствует типу &lt;code&gt;double&lt;/code&gt; в C (или &lt;code&gt;REAL*8&lt;/code&gt; в Fortran).</target>
        </trans-unit>
        <trans-unit id="3f6752421aa22fb1eeb8d2fd5badfc564def668c" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;float&lt;/code&gt; type in C (or &lt;code&gt;REAL*4&lt;/code&gt; in Fortran).</source>
          <target state="translated">Точно соответствует типу &lt;code&gt;float&lt;/code&gt; в C (или &lt;code&gt;REAL*4&lt;/code&gt; в Fortran).</target>
        </trans-unit>
        <trans-unit id="6cffeb7c4b2c762c65b636222df4fb94787880c0" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;signed&lt;/code&gt; type annotation in C (or any &lt;code&gt;INTEGER&lt;/code&gt; type in Fortran). Any Julia type that is not a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; is assumed to be unsigned.</source>
          <target state="translated">Точно соответствует аннотации &lt;code&gt;signed&lt;/code&gt; типа в C (или любому типу &lt;code&gt;INTEGER&lt;/code&gt; в Fortran). Любой тип Julia, не являющийся подтипом &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; , считается беззнаковым.</target>
        </trans-unit>
        <trans-unit id="0d1330aca84c1389777df28581b8c82cd98c2394" translate="yes" xml:space="preserve">
          <source>Examining &lt;code&gt;hello.txt&lt;/code&gt; again will show its contents have been changed.</source>
          <target state="translated">Изучение &lt;code&gt;hello.txt&lt;/code&gt; снова покажет его содержимое было изменено.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="1e20cb09b4bf0570e117bfae2c451577f63f7028" translate="yes" xml:space="preserve">
          <source>Example using an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="373a52dcd1b4d765302f9139879ce9f9a0fb8c90" translate="yes" xml:space="preserve">
          <source>Example: On errors, retry &lt;code&gt;f&lt;/code&gt; on an element a maximum of 3 times without any delay between retries.</source>
          <target state="translated">Пример: при ошибках повторите попытку &lt;code&gt;f&lt;/code&gt; для элемента не более 3 раз без задержки между попытками.</target>
        </trans-unit>
        <trans-unit id="e833cacc44d10e154db82262037462cf8beef7f2" translate="yes" xml:space="preserve">
          <source>Example: Retry &lt;code&gt;f&lt;/code&gt; only if the exception is not of type &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt;, with exponentially increasing delays up to 3 times. Return a &lt;code&gt;NaN&lt;/code&gt; in place for all &lt;code&gt;InexactError&lt;/code&gt; occurrences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a35fb66c95d0cf88768455058261ed6959091e5" translate="yes" xml:space="preserve">
          <source>Example: Retry &lt;code&gt;f&lt;/code&gt; only if the exception is not of type &lt;code&gt;InexactError&lt;/code&gt;, with exponentially increasing delays up to 3 times. Return a &lt;code&gt;NaN&lt;/code&gt; in place for all &lt;code&gt;InexactError&lt;/code&gt; occurrences.</source>
          <target state="translated">Пример: повторите попытку &lt;code&gt;f&lt;/code&gt; , только если исключение не относится к типу &lt;code&gt;InexactError&lt;/code&gt; , с экспоненциально увеличивающимися задержками до 3 раз. Возвращает &lt;code&gt;NaN&lt;/code&gt; для всех вхождений &lt;code&gt;InexactError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="b9efd4419a008bc5f5f67da74017e3ce7f66e0fb" translate="yes" xml:space="preserve">
          <source>Examples of operations involving I/O include reading/writing to files, accessing web services, executing external programs, etc. In all these cases, overall execution time can be improved if other tasks can be run while a file is being read, or while waiting for an external service/program to complete.</source>
          <target state="translated">Примеры операций,связанных с вводом/выводом,включают в себя чтение/запись в файлы,доступ к веб-службам,выполнение внешних программ и т.д.Во всех этих случаях общее время выполнения может быть улучшено,если другие задачи могут быть выполнены во время чтения файла или во время ожидания завершения работы внешней службы/программы.</target>
        </trans-unit>
        <trans-unit id="9f82b594b309c2e2430648d834395134902abf67" translate="yes" xml:space="preserve">
          <source>Examples should, whenever possible, be written as &lt;em&gt;doctests&lt;/em&gt;. A &lt;em&gt;doctest&lt;/em&gt; is a fenced code block (see &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks&quot;&gt;Code blocks&lt;/a&gt;) starting with &lt;code&gt;```jldoctest&lt;/code&gt; and contains any number of &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompts together with inputs and expected outputs that mimic the Julia REPL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca7a5cb7aef9e6990554e02b239447ff53ee134" translate="yes" xml:space="preserve">
          <source>Examples should, whenever possible, be written as &lt;em&gt;doctests&lt;/em&gt;. A &lt;em&gt;doctest&lt;/em&gt; is a fenced code block (see &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;Code blocks&lt;/a&gt;) starting with &lt;code&gt;```jldoctest&lt;/code&gt; and contains any number of &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompts together with inputs and expected outputs that mimic the Julia REPL.</source>
          <target state="translated">Примеры следует, по возможности, записывать в виде &lt;em&gt;тестов&lt;/em&gt; . &lt;em&gt;Doctest&lt;/em&gt; является огорожена кодовым блоком (см &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;блоков коды&lt;/a&gt; ) , начиная с &lt;code&gt;```jldoctest&lt;/code&gt; и содержит любое количество &lt;code&gt;julia&amp;gt;&lt;/code&gt; подсказку вместе с входами и выходами , которые ожидаемыми имитируют Жулиа Repl.</target>
        </trans-unit>
        <trans-unit id="2056efb231cce98ac0668dedf4d2bf625aba4a55" translate="yes" xml:space="preserve">
          <source>Examples that are untestable should be written within fenced code blocks starting with &lt;code&gt;```julia&lt;/code&gt; so that they are highlighted correctly in the generated documentation.</source>
          <target state="translated">Примеры, которые нельзя тестировать, следует записывать внутри изолированных блоков кода, начинающихся с &lt;code&gt;```julia&lt;/code&gt; чтобы они правильно выделялись в сгенерированной документации.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">Обработка исключений</target>
        </trans-unit>
        <trans-unit id="bf77702e21f59d94d4eb46c5b52d82853eea421c" translate="yes" xml:space="preserve">
          <source>Exception handling in Julia is done using &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;, instead of &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;except&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. In contrast to Python, it is not recommended to use exception handling as part of the normal workflow in Julia due to performance reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93cbc45254a123c56a8eaff87f67380fa6af7a8" translate="yes" xml:space="preserve">
          <source>Exception stacks and &lt;code&gt;catch_stack&lt;/code&gt;</source>
          <target state="translated">Стеки исключений и &lt;code&gt;catch_stack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d404b3b66335698d08bc7e83b3b1da3bf0caaf78" translate="yes" xml:space="preserve">
          <source>Exception stacks requires at least Julia 1.1.</source>
          <target state="translated">Исключительные стеки требуют,по крайней мере,Джулии 1.1.</target>
        </trans-unit>
        <trans-unit id="a7f19469182a37332b5dea18474c06d9a6cffcd0" translate="yes" xml:space="preserve">
          <source>Exception thrown when a &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; value is encountered in a situation where it is not supported. The error message, in the &lt;code&gt;msg&lt;/code&gt; field may provide more specific details.</source>
          <target state="translated">Исключение возникает при обнаружении &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения в ситуации, когда оно не поддерживается. Сообщение об ошибке в поле &lt;code&gt;msg&lt;/code&gt; может содержать более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="2886bf315699a79be72431b11e875ca8880a85db" translate="yes" xml:space="preserve">
          <source>Exception thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal) position and cannot proceed. This may &lt;em&gt;not&lt;/em&gt; mean that the matrix is singular: it may be fruitful to switch to a diffent factorization such as pivoted LU that can re-order variables to eliminate spurious zero pivots. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the zero pivot(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a497fe30a5347da8aff63c8337366f7a84f4058" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the singular value(s).</source>
          <target state="translated">Исключение возникает, когда входная матрица имеет одно или несколько собственных значений с нулевым знаком и не является обратимой. Линейное решение, включающее такую ​​матрицу, не может быть вычислено. &lt;code&gt;info&lt;/code&gt; о поле указывает местоположение (одного из) особую ценность (ы).</target>
        </trans-unit>
        <trans-unit id="2023c26839abcfb0ae82bfd1150e32fbc284d2ca" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix was not &lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;positive definite&lt;/a&gt;. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.</source>
          <target state="translated">Возникло исключение, когда входная матрица не была &lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;положительно определенной&lt;/a&gt; . Некоторые функции линейной алгебры и факторизации применимы только к положительно определенным матрицам. &lt;code&gt;info&lt;/code&gt; о поле указывает местоположение (одного из) собственное значение (ы) , который (которые) меньше / равно 0.</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="82857d1e87d55237f9f3e372603e440bfa06f318" translate="yes" xml:space="preserve">
          <source>Exceptions can be created explicitly with &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt;. For example, a function defined only for nonnegative numbers could be written to &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if the argument is negative:</source>
          <target state="translated">Исключения можно создавать явно с помощью &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; . Например, функция определена только для неотрицательных чисел может быть записано в &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; , если аргумент отрицателен:</target>
        </trans-unit>
        <trans-unit id="e4ba2f79f23d1d745b18049a3459429b5707c9cf" translate="yes" xml:space="preserve">
          <source>Exceptions on remote computations are captured and rethrown locally. A &lt;code&gt;RemoteException&lt;/code&gt; wraps the &lt;code&gt;pid&lt;/code&gt; of the worker and a captured exception. A &lt;code&gt;CapturedException&lt;/code&gt; captures the remote exception and a serializable form of the call stack when the exception was raised.</source>
          <target state="translated">Исключения при удаленных вычислениях фиксируются и повторно генерируются локально. &lt;code&gt;RemoteException&lt;/code&gt; оборачивает &lt;code&gt;pid&lt;/code&gt; работника и захваченного исключения. &lt;code&gt;CapturedException&lt;/code&gt; захватывает удаленное исключение и сериализуемую форму стеки вызовов , когда исключение было поднято.</target>
        </trans-unit>
        <trans-unit id="47a6e6d3c2e9b02e1dbab62db882a7f9616c024c" translate="yes" xml:space="preserve">
          <source>Exceptions that occur while generating the log event are captured and logged by default. This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system. This behavior can be customized per logger type by extending &lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt;&lt;code&gt;Logging.catch_exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Исключения, возникающие при создании события журнала, фиксируются и регистрируются по умолчанию. Это предотвращает сбой приложения отдельными неработающими событиями, что полезно при включении редко используемых событий отладки в производственной системе. Это поведение можно настроить для каждого типа регистратора, расширив &lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt; &lt;code&gt;Logging.catch_exceptions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20d32bee5048387540915f82b1cf8f99bd32d983" translate="yes" xml:space="preserve">
          <source>Exceptions that occur while generating the log event are captured and logged by default. This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system. This behavior can be customized per logger type by extending &lt;a href=&quot;#Logging.catch_exceptions&quot;&gt;&lt;code&gt;Logging.catch_exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249bab0d837de1c736ed6cf322c1023e34887589" translate="yes" xml:space="preserve">
          <source>Excessive use will likely lead to poor performance.</source>
          <target state="translated">Чрезмерное использование,скорее всего,приведет к снижению производительности.</target>
        </trans-unit>
        <trans-unit id="f389ff868b8af6a6f2f6d30e8b679e098d301b92" translate="yes" xml:space="preserve">
          <source>Exchange the current position with the mark</source>
          <target state="translated">Обменять текущую позицию на метку</target>
        </trans-unit>
        <trans-unit id="c80276d7c0f717bb4d551e808f6db2511c2186fe" translate="yes" xml:space="preserve">
          <source>Exclamation Question Mark</source>
          <target state="translated">восклицательный знак вопроса</target>
        </trans-unit>
        <trans-unit id="dac1fed7304cfae795fbd37d78d8443ee698fee8" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;f&lt;/code&gt; in an environment that is temporarily modified (not replaced as in &lt;code&gt;setenv&lt;/code&gt;) by zero or more &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; arguments &lt;code&gt;kv&lt;/code&gt;. &lt;code&gt;withenv&lt;/code&gt; is generally used via the &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; syntax. A value of &lt;code&gt;nothing&lt;/code&gt; can be used to temporarily unset an environment variable (if it is set). When &lt;code&gt;withenv&lt;/code&gt; returns, the original environment has been restored.</source>
          <target state="translated">Выполните &lt;code&gt;f&lt;/code&gt; в среде, которая временно изменена (не заменена, как в &lt;code&gt;setenv&lt;/code&gt; ) нулевым или более аргументом &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; &lt;code&gt;kv&lt;/code&gt; . &lt;code&gt;withenv&lt;/code&gt; обычно используется с &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; . Значение &amp;laquo; &lt;code&gt;nothing&lt;/code&gt; можно использовать для временного отключения переменной среды (если она установлена). Когда &lt;code&gt;withenv&lt;/code&gt; возвращается, исходная среда была восстановлена.</target>
        </trans-unit>
        <trans-unit id="303c63e1f5cb3dac07df60b3ba1c0270b3b39672" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;function&lt;/code&gt;, directing all log messages to &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">Выполнить &lt;code&gt;function&lt;/code&gt; , направляя все сообщения журнала в &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bad793892b867876bd2fc3271d9d2236468940a7" translate="yes" xml:space="preserve">
          <source>Execute Permission</source>
          <target state="translated">получить разрешение</target>
        </trans-unit>
        <trans-unit id="ccf93fd6554ca73378cd7ef4e9dc68bcbb434afc" translate="yes" xml:space="preserve">
          <source>Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined &amp;ndash; be careful when doing this, as it may change numerical results.</source>
          <target state="translated">Выполнить преобразованную версию выражения, которая вызывает функции, которые могут нарушать строгую семантику IEEE. Это обеспечивает максимально быструю операцию, но результаты не определены - будьте осторожны при этом, так как это может изменить числовые результаты.</target>
        </trans-unit>
        <trans-unit id="5e27a1a745ad8902705c2e6ab83a0903098f9f06" translate="yes" xml:space="preserve">
          <source>Execute an expression under &lt;code&gt;Main&lt;/code&gt; on all &lt;code&gt;procs&lt;/code&gt;. Errors on any of the processes are collected into a &lt;a href=&quot;../../base/base/index#Base.CompositeException&quot;&gt;&lt;code&gt;CompositeException&lt;/code&gt;&lt;/a&gt; and thrown. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9df83ba80f7ea05232757e37fd45c85f102a7b" translate="yes" xml:space="preserve">
          <source>Execute an expression under &lt;code&gt;Main&lt;/code&gt; on all &lt;code&gt;procs&lt;/code&gt;. Errors on any of the processes are collected into a &lt;code&gt;CompositeException&lt;/code&gt; and thrown. For example:</source>
          <target state="translated">Выполнить выражение в разделе &lt;code&gt;Main&lt;/code&gt; для всех &lt;code&gt;procs&lt;/code&gt; . Ошибки любого из процессов собираются в &lt;code&gt;CompositeException&lt;/code&gt; и генерируются. Например:</target>
        </trans-unit>
        <trans-unit id="ef0298149bb24a28fd471679846d07a4d0087cc3" translate="yes" xml:space="preserve">
          <source>Executes &lt;code&gt;f&lt;/code&gt; on worker &lt;code&gt;id&lt;/code&gt; asynchronously. Unlike &lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall&lt;/code&gt;&lt;/a&gt;, it does not store the result of computation, nor is there a way to wait for its completion.</source>
          <target state="translated">Асинхронно выполняет &lt;code&gt;f&lt;/code&gt; для &lt;code&gt;id&lt;/code&gt; рабочего стола. В отличие от &lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall&lt;/code&gt; &lt;/a&gt; , он не сохраняет результат вычисления и не может дождаться его завершения.</target>
        </trans-unit>
        <trans-unit id="acb80322579157531d28a7bec37d10ea4056bc6f" translate="yes" xml:space="preserve">
          <source>Executing the above snippet results in &lt;code&gt;Main.A&lt;/code&gt; on worker 2 having a different value from &lt;code&gt;Main.A&lt;/code&gt; on worker 3, while the value of &lt;code&gt;Main.A&lt;/code&gt; on node 1 is set to &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">Выполнение указанных выше результатов фрагмента кода в &lt;code&gt;Main.A&lt;/code&gt; на работнике 2 , имеющего различное значение от &lt;code&gt;Main.A&lt;/code&gt; на работнике 3, в то время как значение &lt;code&gt;Main.A&lt;/code&gt; на узле 1 установлено в &lt;code&gt;nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="911180ac9cebe24cefdcdd1680b9c49387acd612" translate="yes" xml:space="preserve">
          <source>Exit (when buffer is empty)</source>
          <target state="translated">Выход (когда буфер пуст)</target>
        </trans-unit>
        <trans-unit id="d477eb857db4070fa5362225484e2e2cc1160414" translate="yes" xml:space="preserve">
          <source>Exit hooks are allowed to call &lt;code&gt;exit(n)&lt;/code&gt;, in which case Julia will exit with exit code &lt;code&gt;n&lt;/code&gt; (instead of the original exit code). If more than one exit hook calls &lt;code&gt;exit(n)&lt;/code&gt;, then Julia will exit with the exit code corresponding to the last called exit hook that calls &lt;code&gt;exit(n)&lt;/code&gt;. (Because exit hooks are called in LIFO order, &quot;last called&quot; is equivalent to &quot;first registered&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fb80361f00a1ef919b8a402eb0fa8767e88aa3" translate="yes" xml:space="preserve">
          <source>Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Разверните до строки с абсолютным путем к каталогу файла, содержащего макровызов. Вернуть текущий рабочий каталог при запуске из REPL или при оценке с помощью &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f7e4fd43efc93c7c61b01d066abbb6ecd0ad58" translate="yes" xml:space="preserve">
          <source>Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;. Return &lt;code&gt;nothing&lt;/code&gt; if the macro was missing parser source information. Alternatively see &lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt;&lt;code&gt;PROGRAM_FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Разверните до строки с путем к файлу, содержащему макровызов, или пустой строкой, если оценивается с помощью &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; . &lt;code&gt;nothing&lt;/code&gt; возвращает, если в макросе отсутствовала информация об источнике синтаксического анализатора. В качестве альтернативы см. &lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt; &lt;code&gt;PROGRAM_FILE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f8c8a91207271c3979e8b044e269e773310cb43" translate="yes" xml:space="preserve">
          <source>Expand to the line number of the location of the macrocall. Return &lt;code&gt;0&lt;/code&gt; if the line number could not be determined.</source>
          <target state="translated">Разверните до номера строки местоположения макровызова. Верните &lt;code&gt;0&lt;/code&gt; , если номер строки определить не удалось.</target>
        </trans-unit>
        <trans-unit id="c980fcdbd3756987bdd9be9bd2691a2d11e6223d" translate="yes" xml:space="preserve">
          <source>Expecting the filesystem to be unchanged between compile-time and runtime e.g. &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;source_path()&lt;/code&gt; to find resources at runtime, or the BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won't need to be found at runtime.</source>
          <target state="translated">Ожидается, что файловая система останется неизменной между временем компиляции и временем выполнения, например, &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;source_path()&lt;/code&gt; для поиска ресурсов во время выполнения или макрос BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; . Иногда это неизбежно. Однако, когда это возможно, рекомендуется копировать ресурсы в модуль во время компиляции, чтобы их не нужно было находить во время выполнения.</target>
        </trans-unit>
        <trans-unit id="ef01e9964e65833fa4da94fa27761fbd0428c0b5" translate="yes" xml:space="preserve">
          <source>Experimental multithreading support.</source>
          <target state="translated">Экспериментальная поддержка многопоточности.</target>
        </trans-unit>
        <trans-unit id="d1e10c5f2ecca7a990bcf252a20b9966c63ad49c" translate="yes" xml:space="preserve">
          <source>Explicitly finds &lt;code&gt;Q&lt;/code&gt;, the orthogonal/unitary matrix from &lt;code&gt;gehrd!&lt;/code&gt;. &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;tau&lt;/code&gt; must correspond to the input/output to &lt;code&gt;gehrd!&lt;/code&gt;.</source>
          <target state="translated">Явно находит &lt;code&gt;Q&lt;/code&gt; , ортогональную / унитарную матрицу из &lt;code&gt;gehrd!&lt;/code&gt; , &lt;code&gt;ilo&lt;/code&gt; , &lt;code&gt;ihi&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;tau&lt;/code&gt; должны соответствовать вводу / выводу в &lt;code&gt;gehrd!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d89ba743e7b20b3225440e90c3ccf3bf8748afa9" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;LQ&lt;/code&gt; factorization after calling &lt;code&gt;gelqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gelqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">Явное находит матрицу &lt;code&gt;Q&lt;/code&gt; в виде &lt;code&gt;LQ&lt;/code&gt; факторизации после вызова &lt;code&gt;gelqf!&lt;/code&gt; на &lt;code&gt;A&lt;/code&gt; . Использует вывод &lt;code&gt;gelqf!&lt;/code&gt; , Перезаписывается &lt;code&gt;Q&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="842467dd8285c3ac06d28f0f33b4e3294049f962" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QL&lt;/code&gt; factorization after calling &lt;code&gt;geqlf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqlf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">Явное находит матрицу &lt;code&gt;Q&lt;/code&gt; в виде &lt;code&gt;QL&lt;/code&gt; факторизации после вызова &lt;code&gt;geqlf!&lt;/code&gt; на &lt;code&gt;A&lt;/code&gt; . Использует вывод &lt;code&gt;geqlf!&lt;/code&gt; , Перезаписывается &lt;code&gt;Q&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ece9405b82e399d70d34379e646461b54cd5e7c" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QR&lt;/code&gt; factorization after calling &lt;code&gt;geqrf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqrf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">Явное находит матрицу &lt;code&gt;Q&lt;/code&gt; в виде &lt;code&gt;QR&lt;/code&gt; - факторизации после вызова &lt;code&gt;geqrf!&lt;/code&gt; на &lt;code&gt;A&lt;/code&gt; . Использует вывод &lt;code&gt;geqrf!&lt;/code&gt; , Перезаписывается &lt;code&gt;Q&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54b7a9812258e65fe016e3ff6743203ffc052ea2" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;RQ&lt;/code&gt; factorization after calling &lt;code&gt;gerqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gerqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">Явное находит матрицу &lt;code&gt;Q&lt;/code&gt; в виде &lt;code&gt;RQ&lt;/code&gt; факторизации после вызова &lt;code&gt;gerqf!&lt;/code&gt; на &lt;code&gt;A&lt;/code&gt; . Использует вывод &lt;code&gt;gerqf!&lt;/code&gt; , Перезаписывается &lt;code&gt;Q&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50220615494147fbec7eb0d31ca7ba3a82c81db3" translate="yes" xml:space="preserve">
          <source>Explicitly passing &lt;code&gt;task&lt;/code&gt; will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.</source>
          <target state="translated">Явно передаваемая &lt;code&gt;task&lt;/code&gt; вернет текущий стек исключений для произвольной задачи. Это полезно для проверки задач, которые не удалось выполнить из-за неперехваченных исключений.</target>
        </trans-unit>
        <trans-unit id="90b58b7713ee5ebddd55f78493a86426624ddf35" translate="yes" xml:space="preserve">
          <source>ExponentialBackOff</source>
          <target state="translated">ExponentialBackOff</target>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="23bf8b64f7777c5abac718af8c1d4675c08d1bd7" translate="yes" xml:space="preserve">
          <source>Exponentiation operator. If &lt;code&gt;x&lt;/code&gt; is a matrix, computes matrix exponentiation.</source>
          <target state="translated">Оператор возведения в степень. Если &lt;code&gt;x&lt;/code&gt; - матрица, вычисляет возведение в степень матрицы.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="2ffaab085f397ec888c88af14ff5370679b8c9cd" translate="yes" xml:space="preserve">
          <source>Expressionless Face</source>
          <target state="translated">Лицо без выражения</target>
        </trans-unit>
        <trans-unit id="88cbc8428bc0cead64822d528b5aeb2ed594f6d0" translate="yes" xml:space="preserve">
          <source>Expressions and evaluation</source>
          <target state="translated">Выражения и оценка</target>
        </trans-unit>
        <trans-unit id="395de5a745d120d755d181c48640612c62257526" translate="yes" xml:space="preserve">
          <source>Expressions executed remotely via &lt;code&gt;@spawn&lt;/code&gt;, or closures specified for remote execution using &lt;code&gt;remotecall&lt;/code&gt; may refer to global variables. Global bindings under module &lt;code&gt;Main&lt;/code&gt; are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</source>
          <target state="translated">Выражения, выполняемые удаленно через &lt;code&gt;@spawn&lt;/code&gt; , или замыкания, указанные для удаленного выполнения с помощью &lt;code&gt;remotecall&lt;/code&gt; , могут ссылаться на глобальные переменные. Глобальные привязки в модуле &lt;code&gt;Main&lt;/code&gt; обрабатываются немного иначе, чем глобальные привязки в других модулях. Рассмотрим следующий фрагмент кода:</target>
        </trans-unit>
        <trans-unit id="c021e85f0971c261cc893329ddbecca6139c6c2b" translate="yes" xml:space="preserve">
          <source>Expressions executed remotely via &lt;code&gt;@spawnat&lt;/code&gt;, or closures specified for remote execution using &lt;code&gt;remotecall&lt;/code&gt; may refer to global variables. Global bindings under module &lt;code&gt;Main&lt;/code&gt; are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdaffe5a439039b7bf8f6bd820ea137bfdd1da7" translate="yes" xml:space="preserve">
          <source>Expressions may also be constructed directly in &lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;prefix notation&lt;/a&gt;:</source>
          <target state="translated">Выражения также могут быть построены непосредственно в &lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;префиксной записи&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="499636f8c38809ad543e77eff829b775812e07ab" translate="yes" xml:space="preserve">
          <source>Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are symbols, &lt;code&gt;*(b,c)&lt;/code&gt; is a subexpression, and &lt;code&gt;1&lt;/code&gt; is a literal 64-bit signed integer.</source>
          <target state="translated">Выражения, предоставляемые анализатором, обычно имеют только символы, другие выражения и литеральные значения в качестве аргументов, тогда как выражения, созданные кодом Julia, могут иметь произвольные значения времени выполнения без буквальных форм в качестве аргументов. В этом конкретном примере &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; - символы, &lt;code&gt;*(b,c)&lt;/code&gt; - подвыражение, а &lt;code&gt;1&lt;/code&gt; - буквальное 64-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="7f0edd94f804e2ef96353f1dd584892a96db61b3" translate="yes" xml:space="preserve">
          <source>Expressions starting with &lt;code&gt;0x&lt;/code&gt; are always hexadecimal literals.</source>
          <target state="translated">Выражения, начинающиеся с &lt;code&gt;0x&lt;/code&gt; , всегда являются шестнадцатеричными литералами.</target>
        </trans-unit>
        <trans-unit id="14b0df907ddf13aab95716adce355b18503f9692" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; are always floating-point literals.</source>
          <target state="translated">Выражения, начинающиеся с числового литерала, за которым следует &lt;code&gt;e&lt;/code&gt; или &lt;code&gt;E&lt;/code&gt; , всегда являются литералами с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="168d5e3cbe916c23713fe630f1348b13aac9d055" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;f&lt;/code&gt; are always 32-bit floating-point literals.</source>
          <target state="translated">Выражения, начинающиеся с числового литерала, за которым следует &lt;code&gt;f&lt;/code&gt; , всегда являются 32-битными литералами с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="3716e13409c4d9335f64fad9810901c98f3f9853" translate="yes" xml:space="preserve">
          <source>Extended documentation for mathematical symbols &amp;amp; functions is &lt;a href=&quot;../math/index#math-ops&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94855ece22db4469edf3ed1b0b895b74c83b0b49" translate="yes" xml:space="preserve">
          <source>Extended documentation for mathematical symbols &amp;amp; functions is &lt;a href=&quot;../math/index#math-ops-1&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Расширенная документация по математическим символам и функциям находится &lt;a href=&quot;../math/index#math-ops-1&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9923a9977a4965d0e75c0d0897087a1b8aae8273" translate="yes" xml:space="preserve">
          <source>Extending broadcast with custom implementations</source>
          <target state="translated">Расширение вещания с помощью пользовательских реализаций</target>
        </trans-unit>
        <trans-unit id="e37b3da56d0eb7ab09f9dced1733e35bd0cf8f0a" translate="yes" xml:space="preserve">
          <source>Extending in-place broadcasting</source>
          <target state="translated">Расширение местного вещания</target>
        </trans-unit>
        <trans-unit id="dda79d09f22a8d0b6a55357e8dd3c1f09491aeff" translate="yes" xml:space="preserve">
          <source>External Profiling</source>
          <target state="translated">Внешнее профилирование</target>
        </trans-unit>
        <trans-unit id="dcc209bf958342fc6704aa1a6650f41110ebb0ea" translate="yes" xml:space="preserve">
          <source>External applications</source>
          <target state="translated">Внешние приложения</target>
        </trans-unit>
        <trans-unit id="ddfa24e5756c773c710e95d9df553e39fcc67e85" translate="yes" xml:space="preserve">
          <source>External libraries, such as those called via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, pose a problem for Julia's task-based I/O mechanism. If a C library performs a blocking operation, that prevents the Julia scheduler from executing any other tasks until the call returns. (Exceptions are calls into custom C code that call back into Julia, which may then yield, or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt;, the C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72388f5a580b9a206f5fadf477e9c6409b4ba887" translate="yes" xml:space="preserve">
          <source>Extra keyword arguments can be collected using &lt;code&gt;...&lt;/code&gt;, as in varargs functions:</source>
          <target state="translated">Дополнительные аргументы ключевого слова могут быть собраны с помощью &lt;code&gt;...&lt;/code&gt; , как в функциях varargs:</target>
        </trans-unit>
        <trans-unit id="c4546f951699a79deff827a563b0a9a224961ffb" translate="yes" xml:space="preserve">
          <source>Extract a field from a composite &lt;code&gt;value&lt;/code&gt; by name or position. See also &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c542a0937e5c368280ab873c2a76a31ca26a4f2" translate="yes" xml:space="preserve">
          <source>Extract a named field from a &lt;code&gt;value&lt;/code&gt; of composite type. See also &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Извлечь именованное поле из &lt;code&gt;value&lt;/code&gt; составного типа. См. Также &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c60b2d6e5ed4bb81c4f042b61a85bf3046814ef9" translate="yes" xml:space="preserve">
          <source>Extract the &lt;code&gt;significand(s)&lt;/code&gt; (a.k.a. mantissa), in binary representation, of a floating-point number. If &lt;code&gt;x&lt;/code&gt; is a non-zero finite number, then the result will be a number of the same type on the interval $[1,2)$. Otherwise &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">Извлечение &lt;code&gt;significand(s)&lt;/code&gt; (он же мантисса), в двоичном представлении, из числа с плавающей точкой. Если &lt;code&gt;x&lt;/code&gt; - ненулевое конечное число, то результатом будет число того же типа на интервале $ [1,2) $. В противном случае возвращается &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd9a47407646b7eb349264a1847a577117c4b4b" translate="yes" xml:space="preserve">
          <source>Extracting the type parameter from a super-type</source>
          <target state="translated">Извлечение параметра типа из супер-типа</target>
        </trans-unit>
        <trans-unit id="1fbfe5e749872a05dc1c33c2c7e3ca998b7be846" translate="yes" xml:space="preserve">
          <source>Extracting useful information</source>
          <target state="translated">Извлечение полезной информации</target>
        </trans-unit>
        <trans-unit id="a98fa15cfef5c8e370cf565d569aef6f02c37e94" translate="yes" xml:space="preserve">
          <source>Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:</source>
          <target state="translated">Извлечение подстроки с использованием индексации диапазона также ожидает корректные индексы байтов или выбрасывает ошибку:</target>
        </trans-unit>
        <trans-unit id="479ced4730cae81bdb549a4c55a6c538ce811e6e" translate="yes" xml:space="preserve">
          <source>Extraterrestrial Alien</source>
          <target state="translated">инопланетянин</target>
        </trans-unit>
        <trans-unit id="794b03ba50df5bea4d6fe059ce926e6abf4b67b1" translate="yes" xml:space="preserve">
          <source>Eyeglasses</source>
          <target state="translated">Eyeglasses</target>
        </trans-unit>
        <trans-unit id="62be7f51429e4e104e01fe3131805c3195ede1d0" translate="yes" xml:space="preserve">
          <source>Eyes</source>
          <target state="translated">Eyes</target>
        </trans-unit>
        <trans-unit id="935b5308312476832a58c20321b71ffe59146c81" translate="yes" xml:space="preserve">
          <source>Face Massage</source>
          <target state="translated">Массаж лица</target>
        </trans-unit>
        <trans-unit id="6d9f49198cfb94a88e7e31f25250998eb9d2d1e4" translate="yes" xml:space="preserve">
          <source>Face Savouring Delicious Food</source>
          <target state="translated">Лицо Сохранение вкусной еды</target>
        </trans-unit>
        <trans-unit id="28d752ff1cbe0e0d9da042fc2eb4d864b23a6a83" translate="yes" xml:space="preserve">
          <source>Face Screaming In Fear</source>
          <target state="translated">Крики лица в страхе</target>
        </trans-unit>
        <trans-unit id="b9e9beed389ea0d867f47293f82e2186403a9ed4" translate="yes" xml:space="preserve">
          <source>Face Throwing A Kiss</source>
          <target state="translated">Поцелуй в лицо</target>
        </trans-unit>
        <trans-unit id="bbcbf04ff477b2051e7e4f303a290165f6e17c1c" translate="yes" xml:space="preserve">
          <source>Face With Cold Sweat</source>
          <target state="translated">Лицо с холодным потом</target>
        </trans-unit>
        <trans-unit id="31e3b7279424674f21abf98db495235d209a6f78" translate="yes" xml:space="preserve">
          <source>Face With Look Of Triumph</source>
          <target state="translated">Лицо с видом триумфа</target>
        </trans-unit>
        <trans-unit id="d977220829cb5c54e44951e580b7af5a8be682f2" translate="yes" xml:space="preserve">
          <source>Face With Medical Mask</source>
          <target state="translated">Лицо с медицинской маской</target>
        </trans-unit>
        <trans-unit id="ed92f3d2a6422f2069bba1ed8548d4fce7291c38" translate="yes" xml:space="preserve">
          <source>Face With No Good Gesture</source>
          <target state="translated">Лицо без хорошего жеста</target>
        </trans-unit>
        <trans-unit id="506a6677d48e694c03b7beb019db5a830b3143a9" translate="yes" xml:space="preserve">
          <source>Face With Ok Gesture</source>
          <target state="translated">Лицо с хорошим жестом</target>
        </trans-unit>
        <trans-unit id="28e351cf809c3e1056a0ccbe38a572fea7f91813" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth</source>
          <target state="translated">Лицо с открытым ртом</target>
        </trans-unit>
        <trans-unit id="ede5660328e307c9c221b7e2a4cda4e1f338198d" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth And Cold Sweat</source>
          <target state="translated">Лицо с открытым ртом и холодным потом.</target>
        </trans-unit>
        <trans-unit id="2ba0e50eb9d9ecd8226c1f88f65005c12090219b" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue</source>
          <target state="translated">Лицо с застрявшим языком</target>
        </trans-unit>
        <trans-unit id="0ac1bde49f3cb47f6fb14b275d6c4062eb336a94" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Tightly-Closed Eyes</source>
          <target state="translated">Лицо с застрявшим языком и плотно закрытыми глазами.</target>
        </trans-unit>
        <trans-unit id="f4cf7e61567246c7cc07e1da723a4bb7e03afad8" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Winking Eye</source>
          <target state="translated">Лицо с застрявшим языком и подмигивающим глазом...</target>
        </trans-unit>
        <trans-unit id="a06e070daf131855d1c38e6f755e23cf18f7fde6" translate="yes" xml:space="preserve">
          <source>Face With Tears Of Joy</source>
          <target state="translated">Лицо со слезами радости</target>
        </trans-unit>
        <trans-unit id="712efae47f8a280e2a18330da009234488ca3fe5" translate="yes" xml:space="preserve">
          <source>Face Without Mouth</source>
          <target state="translated">Лицо без рта</target>
        </trans-unit>
        <trans-unit id="afc193c2d83a82dc7805b7f571fe51bc57700902" translate="yes" xml:space="preserve">
          <source>Factorial of &lt;code&gt;n&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if &lt;code&gt;n&lt;/code&gt; is not small, but you can use &lt;code&gt;factorial(big(n))&lt;/code&gt; to compute the result exactly in arbitrary precision.</source>
          <target state="translated">Факториал &lt;code&gt;n&lt;/code&gt; . Если &lt;code&gt;n&lt;/code&gt; есть &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , факториал вычисляется как целое число (повышен до по меньшей мере , 64 бит). Обратите внимание, что это может привести к переполнению, если &lt;code&gt;n&lt;/code&gt; не мало, но вы можете использовать &lt;code&gt;factorial(big(n))&lt;/code&gt; для точного вычисления результата с произвольной точностью.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="63654e405afb574cef72ea67524c3b8dfe3ad9f8" translate="yes" xml:space="preserve">
          <source>Fallen Leaf</source>
          <target state="translated">Опавший лист</target>
        </trans-unit>
        <trans-unit id="b9484d668f5b5826c667e198c17cfe45233a7bb4" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing North East Arrow</source>
          <target state="translated">Падение диагонального пересечения Северо-Восточная стрелка</target>
        </trans-unit>
        <trans-unit id="393d595d0d4e1a1bb3815008194b595d879c69cb" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing Rising Diagonal</source>
          <target state="translated">Падение диагонального креста диагональю восхода</target>
        </trans-unit>
        <trans-unit id="4efb6cb7c018f0c686d4e9d68b615950223b4dd1" translate="yes" xml:space="preserve">
          <source>Family</source>
          <target state="translated">Family</target>
        </trans-unit>
        <trans-unit id="f4b462a59695a129404bc83da0ca619fa6bc84c1" translate="yes" xml:space="preserve">
          <source>FastMath.@fastmath</source>
          <target state="translated">FastMath.@fastmath</target>
        </trans-unit>
        <trans-unit id="5e56c9df8931a964370d4185aaacd5e1646ab9bf" translate="yes" xml:space="preserve">
          <source>Fastforward merge changes into current HEAD. This is only possible if the commit referred to by &lt;code&gt;ann&lt;/code&gt; is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).</source>
          <target state="translated">Быстрое слияние изменений в текущую HEAD. Это возможно только в том случае, если коммит, на который ссылается &lt;code&gt;ann&lt;/code&gt; , является потомком текущего HEAD (например, при извлечении изменений из удаленной ветви, которая находится просто перед вершиной локальной ветки).</target>
        </trans-unit>
        <trans-unit id="2cb40f791e4167e1561e4d7cf136b54833a93f9c" translate="yes" xml:space="preserve">
          <source>Father Christmas</source>
          <target state="translated">Дед Мороз</target>
        </trans-unit>
        <trans-unit id="9f64754b8681b16b5355b0c86ea9df6b53108695" translate="yes" xml:space="preserve">
          <source>Fax Machine</source>
          <target state="translated">факс-машина</target>
        </trans-unit>
        <trans-unit id="2e7c6c500cc9c35c302564a53fea2d0265ede623" translate="yes" xml:space="preserve">
          <source>Fearful Face</source>
          <target state="translated">Страшное лицо</target>
        </trans-unit>
        <trans-unit id="e8205fe2da2e8213474f5eefce3af1eb9e900095" translate="yes" xml:space="preserve">
          <source>Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; will add to the appropriate project and manifest files, selected via &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt;, so that a future call to &lt;code&gt;import X&lt;/code&gt; will load &lt;code&gt;X&lt;/code&gt; without further thought.</source>
          <target state="translated">Объединенное управление пакетами и точная воспроизводимость программного обеспечения - сложные, но достойные цели в системе пакетов. В совокупности эти цели приводят к более сложному механизму загрузки пакетов, чем у большинства динамических языков, но также обеспечивают масштабируемость и воспроизводимость, которые чаще связаны со статическими языками. Как правило, пользователи Julia должны иметь возможность использовать встроенный диспетчер пакетов для управления своими проектами без необходимости точного понимания этих взаимодействий. Вызов &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; добавит к соответствующим файлам проекта и манифеста, выбранным с помощью &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt; , так что будущий вызов для &lt;code&gt;import X&lt;/code&gt; загрузит &lt;code&gt;X&lt;/code&gt; без дополнительных размышлений.</target>
        </trans-unit>
        <trans-unit id="47786ddc55ac4be098cd5e14320506e7fb87ccf0" translate="yes" xml:space="preserve">
          <source>Federation of packages</source>
          <target state="translated">Федерация пакетов</target>
        </trans-unit>
        <trans-unit id="39d4db59ebfbfc4ac31928560a37f5b11dfbe6ef" translate="yes" xml:space="preserve">
          <source>Female Sign</source>
          <target state="translated">Женский знак</target>
        </trans-unit>
        <trans-unit id="5ade35b896f1964ffd73b5188c1b0487a813086e" translate="yes" xml:space="preserve">
          <source>Feminine Ordinal Indicator</source>
          <target state="translated">Индикатор женского пола</target>
        </trans-unit>
        <trans-unit id="d710ff00c62629aec846cd362ec81d6ef45db696" translate="yes" xml:space="preserve">
          <source>Ferris Wheel</source>
          <target state="translated">колесо обозрения</target>
        </trans-unit>
        <trans-unit id="df0dbf9f1e3f08dc6fd97eee350731fe6d045e40" translate="yes" xml:space="preserve">
          <source>Fetch from the specified &lt;code&gt;rmt&lt;/code&gt; remote git repository, using &lt;code&gt;refspecs&lt;/code&gt; to determine which remote branch(es) to fetch. The keyword arguments are:</source>
          <target state="translated">&lt;code&gt;rmt&lt;/code&gt; из указанного удаленного репозитория git rmt , используя &lt;code&gt;refspecs&lt;/code&gt; чтобы определить, какие удаленные ветки следует извлечь. Аргументы ключевого слова:</target>
        </trans-unit>
        <trans-unit id="cb2823e177eb0088e61a0c4192de87c90606b3f2" translate="yes" xml:space="preserve">
          <source>Fetch value(s) from a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;rr&lt;/code&gt;, removing the value(s) in the process.</source>
          <target state="translated">Получить значение (я) из &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; &lt;code&gt;rr&lt;/code&gt; , удалив значение (я) в процессе.</target>
        </trans-unit>
        <trans-unit id="f75758f2a5b3122c0452e7b217407d3ca4c90027" translate="yes" xml:space="preserve">
          <source>Fetches updates from an upstream of the repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">Fetches обновления от верхнего течения хранилища &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab81972fb7d8656b3c745c5f3e56930d139a6985" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; can be set by the cluster manager when &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; is called. The value of this field is passed in all &lt;code&gt;connect&lt;/code&gt; callbacks. Typically, it carries information on &lt;em&gt;how to connect&lt;/em&gt; to a worker. For example, the TCP/IP socket transport uses this field to specify the &lt;code&gt;(host, port)&lt;/code&gt; tuple at which to connect to a worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e0dc3617ed6df7db01aef23ac96c5f906e0e79" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; can be set by the cluster manager when &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; is called. The value of this field is passed in in all &lt;code&gt;connect&lt;/code&gt; callbacks. Typically, it carries information on &lt;em&gt;how to connect&lt;/em&gt; to a worker. For example, the TCP/IP socket transport uses this field to specify the &lt;code&gt;(host, port)&lt;/code&gt; tuple at which to connect to a worker.</source>
          <target state="translated">Поле &lt;code&gt;connect_at::Any&lt;/code&gt; в &lt;code&gt;WorkerConfig&lt;/code&gt; может быть установлено менеджером кластера при вызове &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; . Значение этого поля передается во всех обратных вызовах &lt;code&gt;connect&lt;/code&gt; . Обычно в нем содержится информация о &lt;em&gt;том, как подключиться&lt;/em&gt; к работнику. Например, транспортный сокет TCP / IP использует это поле для указания кортежа &lt;code&gt;(host, port)&lt;/code&gt; по которому следует подключиться к работнику.</target>
        </trans-unit>
        <trans-unit id="a021a8bc64f3d535386a42159616c145f16e2e9f" translate="yes" xml:space="preserve">
          <source>Fields can have type restrictions, which may be parameterized:</source>
          <target state="translated">Поля могут иметь ограничения по типу,которые могут быть параметризованы:</target>
        </trans-unit>
        <trans-unit id="85e54bf45d80186bc0d6353b5c2465d78bd8c6a3" translate="yes" xml:space="preserve">
          <source>Fields for output from functions can also be completed:</source>
          <target state="translated">Поля для вывода функций также могут быть заполнены:</target>
        </trans-unit>
        <trans-unit id="9c69000bd588bc2ad85aa2ab7ce5f54b4fa4c471" translate="yes" xml:space="preserve">
          <source>Fields with no type annotation default to &lt;code&gt;Any&lt;/code&gt;, and can accordingly hold any type of value.</source>
          <target state="translated">Поля без аннотации типа по умолчанию имеют значение &lt;code&gt;Any&lt;/code&gt; и могут соответственно содержать любой тип значения.</target>
        </trans-unit>
        <trans-unit id="844953f92852d1b54e7d635339a7d17db22cf318" translate="yes" xml:space="preserve">
          <source>File Events</source>
          <target state="translated">События в файле</target>
        </trans-unit>
        <trans-unit id="f78e390524cd3565f0dc8b46bd2ea361def72e8d" translate="yes" xml:space="preserve">
          <source>File Folder</source>
          <target state="translated">Папка файлов</target>
        </trans-unit>
        <trans-unit id="1b8c4bf7746a674619789c0353c0a64bca75a908" translate="yes" xml:space="preserve">
          <source>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</source>
          <target state="translated">Расширение файла для динамических библиотек (например,dll,dylib,и т.д.)на текущей платформе.</target>
        </trans-unit>
        <trans-unit id="2a5ce0551b3bc16a4d13e2e3a13e5586cafae52b" translate="yes" xml:space="preserve">
          <source>File locations</source>
          <target state="translated">Места хранения файлов</target>
        </trans-unit>
        <trans-unit id="2c420d28b90db2dee25055b2d7bd4981ad9a1524" translate="yes" xml:space="preserve">
          <source>File/function names are sometimes truncated (with &lt;code&gt;...&lt;/code&gt;), and indentation is truncated with a &lt;code&gt;+n&lt;/code&gt; at the beginning, where &lt;code&gt;n&lt;/code&gt; is the number of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea is to save to a file using a wide &lt;code&gt;displaysize&lt;/code&gt; in an &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Имена файлов / функций иногда усекаются (с помощью &lt;code&gt;...&lt;/code&gt; ), а отступы усекаются с помощью &lt;code&gt;+n&lt;/code&gt; в начале, где &lt;code&gt;n&lt;/code&gt; - количество дополнительных пробелов, которые были бы вставлены, если бы там было место. Если вам нужен полный профиль глубоко вложенного кода, часто хорошей идеей является сохранение в файл, используя широкий &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; &lt;code&gt;displaysize&lt;/code&gt; в IOContext :</target>
        </trans-unit>
        <trans-unit id="f8d8d763bd5d522952215bd9a9fc1f2faf928be9" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_fd()</source>
          <target state="translated">FileWatching.poll_fd()</target>
        </trans-unit>
        <trans-unit id="9a0031862648613baa256a2b1e25c479a5254826" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_file()</source>
          <target state="translated">FileWatching.poll_file()</target>
        </trans-unit>
        <trans-unit id="747de65fe94e8175642ef8c7cef685465b1b4bb5" translate="yes" xml:space="preserve">
          <source>FileWatching.unwatch_folder()</source>
          <target state="translated">FileWatching.unwatch_folder()</target>
        </trans-unit>
        <trans-unit id="d92f14cfa1ec3fdb1aad5fa8235becab8031e345" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_file()</source>
          <target state="translated">FileWatching.watch_file()</target>
        </trans-unit>
        <trans-unit id="c0d5eb4225c04b069f17ff8146680ce4c975f229" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_folder()</source>
          <target state="translated">FileWatching.watch_folder()</target>
        </trans-unit>
        <trans-unit id="0b5acc23bb7f272c55693528aa9ca461dacf6e0b" translate="yes" xml:space="preserve">
          <source>Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file:</source>
          <target state="translated">Имена файлов и файлов в основном не связаны с модулями;модули ассоциируются только с выражениями модулей.Можно иметь несколько файлов на модуль и несколько модулей на файл:</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="66d37ac694679d2aaba78e1325d8da6c3e6b2dc1" translate="yes" xml:space="preserve">
          <source>Filesystem.cd()</source>
          <target state="translated">Filesystem.cd()</target>
        </trans-unit>
        <trans-unit id="4b83b49056e1fe9e1c6931b13ab708ea3d3dc5b1" translate="yes" xml:space="preserve">
          <source>Filesystem.cp()</source>
          <target state="translated">Filesystem.cp()</target>
        </trans-unit>
        <trans-unit id="a4dead2a6ad53fe70d8e528eef3724fac180b679" translate="yes" xml:space="preserve">
          <source>Filesystem.mv()</source>
          <target state="translated">Filesystem.mv()</target>
        </trans-unit>
        <trans-unit id="cf83f1b98e2416e6a59699657d24bd33d10365f7" translate="yes" xml:space="preserve">
          <source>Filesystem.rm()</source>
          <target state="translated">Filesystem.rm()</target>
        </trans-unit>
        <trans-unit id="e8602ecc6cdda92120a80db2b2896945fc2bc02d" translate="yes" xml:space="preserve">
          <source>Fill array &lt;code&gt;A&lt;/code&gt; with the value &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill!(A, Foo())&lt;/code&gt; will return &lt;code&gt;A&lt;/code&gt; filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">Заполните массив &lt;code&gt;A&lt;/code&gt; значением &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; - ссылка на объект, все элементы будут ссылаться на один и тот же объект. &lt;code&gt;fill!(A, Foo())&lt;/code&gt; вернет &lt;code&gt;A&lt;/code&gt; , заполненный результатом однократной оценки &lt;code&gt;Foo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15f90b730a9bb3cbbb4e0be4003f4356fc9b9036" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Заполните массив &lt;code&gt;A&lt;/code&gt; нормально распределенными (среднее значение 0, стандартное отклонение 1) случайными числами. Также см. Функцию &lt;a href=&quot;#Base.rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae93e848c3d30d15d2b5012ea3af3f0ab55b5ca" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with random numbers following the exponential distribution (with scale 1).</source>
          <target state="translated">Заполните массив &lt;code&gt;A&lt;/code&gt; случайными числами в соответствии с экспоненциальным распределением (с масштабом 1).</target>
        </trans-unit>
        <trans-unit id="0e5d88ef3637a2479a8b258a074f4fa06d769918" translate="yes" xml:space="preserve">
          <source>Fills an array of the digits of &lt;code&gt;n&lt;/code&gt; in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.</source>
          <target state="translated">Заполняет массив цифр &lt;code&gt;n&lt;/code&gt; в заданной базе. Более значащие цифры имеют более высокие индексы. Если длина массива недостаточна, младшие разряды заполняются до длины массива. Если длина массива слишком велика, лишняя часть заполняется нулями.</target>
        </trans-unit>
        <trans-unit id="6631e6cc1655ad1b4e5dff0d7262c17fe69da03f" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;where&lt;/code&gt; is parsed as an infix operator for writing parametric method and type definitions. Also &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are parsed as infix operators. Creation of a variable named &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;isa&lt;/code&gt; is allowed though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396759f79c6ca8385ec1d2296022926c7edb5dd8" translate="yes" xml:space="preserve">
          <source>Finally, distributed computing runs multiple processes with separate memory spaces, potentially on different machines. This functionality is provided by the &lt;code&gt;Distributed&lt;/code&gt; standard library as well as external packages like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22655b3e2d52ed1fe3abbc273a301c575c9c7fae" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;DummyModule.jl&lt;/code&gt; is not a standalone file but a package, then &lt;code&gt;using DummyModule&lt;/code&gt; will &lt;em&gt;load&lt;/em&gt;&lt;code&gt;DummyModule.jl&lt;/code&gt; on all processes, but only bring it into scope on the process where &lt;code&gt;using&lt;/code&gt; was called.</source>
          <target state="translated">Наконец, если &lt;code&gt;DummyModule.jl&lt;/code&gt; не является автономным файлом , но пакет, а затем с &lt;code&gt;using DummyModule&lt;/code&gt; будет &lt;em&gt;загружать &lt;/em&gt; &lt;code&gt;DummyModule.jl&lt;/code&gt; на все процессы, но только привести его в рамки на процесс , в котором с &lt;code&gt;using&lt;/code&gt; называется.</target>
        </trans-unit>
        <trans-unit id="f1c7a00722ed8c5c04db876017518449fd3a13b0" translate="yes" xml:space="preserve">
          <source>Finally, let's take a look at some more complex examples where this rule comes into play. Define a function &lt;code&gt;f(x)&lt;/code&gt;, which initially has one method:</source>
          <target state="translated">Наконец, давайте рассмотрим несколько более сложных примеров, в которых применяется это правило. Определите функцию &lt;code&gt;f(x)&lt;/code&gt; , которая изначально имеет один метод:</target>
        </trans-unit>
        <trans-unit id="e8ab1a15d94e7105e3fcab5c9d28790890e0a56b" translate="yes" xml:space="preserve">
          <source>Finally, the &quot;exclusive or&quot; logical operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; always propagates &lt;code&gt;missing&lt;/code&gt; values, since both operands always have an effect on the result. Also note that the negation operator &lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;missing&lt;/code&gt; when the operand is &lt;code&gt;missing&lt;/code&gt; just like other unary operators.</source>
          <target state="translated">Наконец, логический оператор &amp;laquo;исключающее ИЛИ&amp;raquo; &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; всегда передает &lt;code&gt;missing&lt;/code&gt; значения, поскольку оба операнда всегда влияют на результат. Также обратите внимание, что оператор отрицания &lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; возвращает значение &lt;code&gt;missing&lt;/code&gt; , если операнд &lt;code&gt;missing&lt;/code&gt; как и другие унарные операторы.</target>
        </trans-unit>
        <trans-unit id="f1606584dd02e5f78a49dbb79dadabcf6a1374a4" translate="yes" xml:space="preserve">
          <source>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is &lt;em&gt;pre-allocated&lt;/em&gt;, so that repeated calls do not allocate new arrays over and over again for the results (see &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;). A convenient syntax for this is &lt;code&gt;X .= ...&lt;/code&gt;, which is equivalent to &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; except that, as above, the &lt;code&gt;broadcast!&lt;/code&gt; loop is fused with any nested &quot;dot&quot; calls. For example, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt;, overwriting &lt;code&gt;X&lt;/code&gt; with &lt;code&gt;sin.(Y)&lt;/code&gt; in-place. If the left-hand side is an array-indexing expression, e.g. &lt;code&gt;X[begin+1:end] .= sin.(Y)&lt;/code&gt;, then it translates to &lt;code&gt;broadcast!&lt;/code&gt; on a &lt;code&gt;view&lt;/code&gt;, e.g. &lt;code&gt;broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y)&lt;/code&gt;, so that the left-hand side is updated in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767751161f0cdd1157de7a8f8d7964c9db4474ed" translate="yes" xml:space="preserve">
          <source>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is &lt;em&gt;pre-allocated&lt;/em&gt;, so that repeated calls do not allocate new arrays over and over again for the results (see &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;). A convenient syntax for this is &lt;code&gt;X .= ...&lt;/code&gt;, which is equivalent to &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; except that, as above, the &lt;code&gt;broadcast!&lt;/code&gt; loop is fused with any nested &quot;dot&quot; calls. For example, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt;, overwriting &lt;code&gt;X&lt;/code&gt; with &lt;code&gt;sin.(Y)&lt;/code&gt; in-place. If the left-hand side is an array-indexing expression, e.g. &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt;, then it translates to &lt;code&gt;broadcast!&lt;/code&gt; on a &lt;code&gt;view&lt;/code&gt;, e.g. &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt;, so that the left-hand side is updated in-place.</source>
          <target state="translated">Наконец, максимальная эффективность обычно достигается, когда выходной массив векторизованной операции &lt;em&gt;предварительно выделяется&lt;/em&gt; , так что повторные вызовы не выделяют новые массивы снова и снова для результатов (см. &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;Предварительное выделение выходных данных&lt;/a&gt; ). Удобный синтаксис для этого - &lt;code&gt;X .= ...&lt;/code&gt; , что эквивалентно &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; за исключением того, что, как и выше, &lt;code&gt;broadcast!&lt;/code&gt; цикл объединяется с любыми вложенными вызовами &amp;laquo;точки&amp;raquo;. Например, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; эквивалентно &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt; , заменяющей &lt;code&gt;X&lt;/code&gt; на &lt;code&gt;sin.(Y)&lt;/code&gt; на месте. Если левая часть представляет собой выражение индексации массива, например &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt; , то переводится в &lt;code&gt;broadcast!&lt;/code&gt; в &lt;code&gt;view&lt;/code&gt; , например, &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt; , так что левая часть обновляется на месте.</target>
        </trans-unit>
        <trans-unit id="c12ff37c90964a19ee534ead21bebd3e9eed8809" translate="yes" xml:space="preserve">
          <source>Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:</source>
          <target state="translated">Наконец,мы завершаем текущее тематическое исследование рационального типа номера Юлии,в котором относительно сложно использовать механизм продвижения по службе со следующими правилами продвижения по службе:</target>
        </trans-unit>
        <trans-unit id="30b68f7e7af1c04cf4dd6e837e4591351c43581a" translate="yes" xml:space="preserve">
          <source>Finally, you can use &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to actually generate a call to the library function. Arguments to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">Наконец, вы можете использовать &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; для фактического вызова библиотечной функции. Аргументы против &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; следующие:</target>
        </trans-unit>
        <trans-unit id="b7d84c29ce4854abb76c4c28bbdd03fd9c5aa451" translate="yes" xml:space="preserve">
          <source>Finally, you can use &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to actually generate a call to the library function. The arguments to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feefe85d510994646d16a16714a8d3ae19ac8a26" translate="yes" xml:space="preserve">
          <source>Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;guidelines for contributing&lt;/a&gt;.</source>
          <target state="translated">Наконец, вы также можете подумать о создании Julia из исходников для себя. Этот вариант в основном предназначен для тех, кто хорошо разбирается в командной строке или хочет учиться. Если это относится к вам, возможно, вам будет интересно прочитать наши &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;правила участия&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3fe342dc0e6c8372fd117cdbcdeaa485ff1b80" translate="yes" xml:space="preserve">
          <source>Finally,&lt;code&gt;where&lt;/code&gt; is parsed as an infix operator for writing parametric method and type definitions. Also &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are parsed as infix operators. Creation of a variable named &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;isa&lt;/code&gt; is allowed though.</source>
          <target state="translated">Наконец, &lt;code&gt;where&lt;/code&gt; анализируется как инфиксный оператор для написания параметрических определений методов и типов. Также &lt;code&gt;in&lt;/code&gt; и &lt;code&gt;isa&lt;/code&gt; анализируются как инфиксные операторы. Однако создание переменной с именем &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; или &lt;code&gt;isa&lt;/code&gt; разрешено.</target>
        </trans-unit>
        <trans-unit id="c9b51ec67d633a0669dda1015ca213cfa3baaf80" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;y::T&lt;/code&gt; such that &lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; (mod n), where n is the number of integers representable in &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; is an integer in &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; can represent any integer (e.g. &lt;code&gt;T == BigInt&lt;/code&gt;), then this operation corresponds to a conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Найдите &lt;code&gt;y::T&lt;/code&gt; такое, что &lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; (mod n), где n - количество целых чисел, представимых в &lt;code&gt;T&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; - целое число в &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; может представлять любое целое число (например , &lt;code&gt;T == BigInt&lt;/code&gt; ), то эта операция соответствует преобразования в &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6150b2996e7de5708d81911408a8ec428d36e07" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;y&lt;/code&gt; in the range &lt;code&gt;r&lt;/code&gt; such that $x &amp;equiv; y (mod n)$, where &lt;code&gt;n = length(r)&lt;/code&gt;, i.e. &lt;code&gt;y = mod(x - first(r), n) + first(r)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f647c9d8a07df297d4680ab0a11627650c460ccd" translate="yes" xml:space="preserve">
          <source>Find a merge base (a common ancestor) between the commits &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt;. &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt; may both be in string form. Return the &lt;code&gt;GitHash&lt;/code&gt; of the merge base.</source>
          <target state="translated">Найти совмещенные базы (общий предок) между фиксациями &lt;code&gt;one&lt;/code&gt; и &lt;code&gt;two&lt;/code&gt; . &lt;code&gt;one&lt;/code&gt; и &lt;code&gt;two&lt;/code&gt; могут быть в строковой форме. Верните &lt;code&gt;GitHash&lt;/code&gt; базы слияния.</target>
        </trans-unit>
        <trans-unit id="1825fce8a92f2ce1845fd36082521f2d3a4e162f" translate="yes" xml:space="preserve">
          <source>Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Найдите первое вхождение &lt;code&gt;pattern&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; . Эквивалентен &lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80ded0d1fb8ec161dcae3181a5658542cce2200b" translate="yes" xml:space="preserve">
          <source>Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21d600b94cf0b778ba467005900538f19345af8" translate="yes" xml:space="preserve">
          <source>Find the index of the element of &lt;code&gt;dx&lt;/code&gt; with the maximum absolute value. &lt;code&gt;n&lt;/code&gt; is the length of &lt;code&gt;dx&lt;/code&gt;, and &lt;code&gt;incx&lt;/code&gt; is the stride. If &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;incx&lt;/code&gt; are not provided, they assume default values of &lt;code&gt;n=length(dx)&lt;/code&gt; and &lt;code&gt;incx=stride1(dx)&lt;/code&gt;.</source>
          <target state="translated">Найдите индекс элемента &lt;code&gt;dx&lt;/code&gt; с максимальным абсолютным значением. &lt;code&gt;n&lt;/code&gt; - длина &lt;code&gt;dx&lt;/code&gt; , &lt;code&gt;incx&lt;/code&gt; - шаг. Если &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;incx&lt;/code&gt; не указаны, они принимают значения по умолчанию &lt;code&gt;n=length(dx)&lt;/code&gt; и &lt;code&gt;incx=stride1(dx)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eaf75b6910de284edca0478751e60e1ad92a9d8" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Найдите последнее вхождение &lt;code&gt;pattern&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; . Эквивалентен &lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67e62ddbda9380872652837135cdba3485044ca2" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80338a6fd8042cc9a4548c075df3fb6d4dd0cdc" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of character &lt;code&gt;ch&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552c8ae53a2283ce454807a34e7013b314ceea60" translate="yes" xml:space="preserve">
          <source>Find the maximum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">Найдите максимум &lt;code&gt;A&lt;/code&gt; и соответствующий линейный индекс по размерам синглетов &lt;code&gt;rval&lt;/code&gt; и &lt;code&gt;rind&lt;/code&gt; и сохраните результаты в &lt;code&gt;rval&lt;/code&gt; и &lt;code&gt;rind&lt;/code&gt; . &lt;code&gt;NaN&lt;/code&gt; считается большим, чем все другие значения.</target>
        </trans-unit>
        <trans-unit id="9aa328c598b9330ac1b7a72be0fe532e46cd4d55" translate="yes" xml:space="preserve">
          <source>Find the minimum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">Найдите минимум &lt;code&gt;A&lt;/code&gt; и соответствующий линейный индекс по размерам синглетов &lt;code&gt;rval&lt;/code&gt; и &lt;code&gt;rind&lt;/code&gt; и сохраните результаты в &lt;code&gt;rval&lt;/code&gt; и &lt;code&gt;rind&lt;/code&gt; . &lt;code&gt;NaN&lt;/code&gt; считается меньшим, чем все другие значения.</target>
        </trans-unit>
        <trans-unit id="d865db872da82af36f837e5f310f73145bef3112" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">Найти следующий индекс после или в том числе и &lt;code&gt;i&lt;/code&gt; из &lt;code&gt;true&lt;/code&gt; элемента &lt;code&gt;A&lt;/code&gt; , или &lt;code&gt;nothing&lt;/code&gt; , если не найдено.</target>
        </trans-unit>
        <trans-unit id="3bed36c27812d4cd102ecb3fe1568c0bed863342" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">Найдите следующий индекс после или включая &lt;code&gt;i&lt;/code&gt; элемента &lt;code&gt;A&lt;/code&gt; , для которого &lt;code&gt;predicate&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;nothing&lt;/code&gt; если не найден.</target>
        </trans-unit>
        <trans-unit id="7a1d8f46d937916c8787067db2b2714283d812a5" translate="yes" xml:space="preserve">
          <source>Find the next occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;. &lt;code&gt;pattern&lt;/code&gt; can be either a string, or a regular expression, in which case &lt;code&gt;string&lt;/code&gt; must be of type &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Найдите следующее вхождение &lt;code&gt;pattern&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; начиная с позиции &lt;code&gt;start&lt;/code&gt; . &lt;code&gt;pattern&lt;/code&gt; может быть либо строкой, либо регулярным выражением, и в этом случае &lt;code&gt;string&lt;/code&gt; должна иметь тип &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ea577e1df683b2cdf0866079e5dca95cc8a70df" translate="yes" xml:space="preserve">
          <source>Find the next occurrence of character &lt;code&gt;ch&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acd53075bd7738ba5874f9d2945af016adac780" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">Найти предыдущий индекс до или в том числе и &lt;code&gt;i&lt;/code&gt; из &lt;code&gt;true&lt;/code&gt; элемента &lt;code&gt;A&lt;/code&gt; , или &lt;code&gt;nothing&lt;/code&gt; , если не найдено.</target>
        </trans-unit>
        <trans-unit id="ac4b726fe8ef16af102227f0592ab9d5019209eb" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">Найдите предыдущий индекс до или включая &lt;code&gt;i&lt;/code&gt; элемента &lt;code&gt;A&lt;/code&gt; , для которого &lt;code&gt;predicate&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;nothing&lt;/code&gt; если не найден.</target>
        </trans-unit>
        <trans-unit id="7099f261e64c52f512558cba2d47b4f0bc49c077" translate="yes" xml:space="preserve">
          <source>Find the previous occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">Найдите предыдущее вхождение &lt;code&gt;pattern&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; начиная с позиции &lt;code&gt;start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eee018a6003d420d94f270f4deb2bf0aff001cc" translate="yes" xml:space="preserve">
          <source>Find the root module of a given module. This is the first module in the chain of parent modules of &lt;code&gt;m&lt;/code&gt; which is either a registered root module or which is its own parent module.</source>
          <target state="translated">Найдите корневой модуль данного модуля. Это первый модуль в цепочке родительских модулей &lt;code&gt;m&lt;/code&gt; , который является либо зарегистрированным корневым модулем, либо собственным родительским модулем.</target>
        </trans-unit>
        <trans-unit id="48db6f6163bbca28ad1cb048ef296ccaadb4bcda" translate="yes" xml:space="preserve">
          <source>Finding the length of time between two &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is straightforward given their underlying representation as &lt;code&gt;UTInstant{Day}&lt;/code&gt; and &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt;, respectively. The difference between &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is returned in the number of &lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt;&lt;code&gt;Day&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in the number of &lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt;&lt;code&gt;Millisecond&lt;/code&gt;&lt;/a&gt;. Similarly, comparing &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; is a simple matter of comparing the underlying machine instants (which in turn compares the internal &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values).</source>
          <target state="translated">Найти промежуток времени между двумя &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; несложно, учитывая их базовое представление как &lt;code&gt;UTInstant{Day}&lt;/code&gt; и &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt; соответственно. Разница между &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; возвращается в количестве &lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt; &lt;code&gt;Day&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt; &lt;code&gt;Millisecond&lt;/code&gt; &lt;/a&gt; . Точно так же сравнение &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; - это простой вопрос сравнения базовых машинных моментов (который, в свою очередь, сравнивает внутренние значения &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2069d729b3672a99ea2f38ff359c481d7de66468" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;LU&lt;/code&gt; factorization of a tridiagonal matrix with &lt;code&gt;dl&lt;/code&gt; on the subdiagonal, &lt;code&gt;d&lt;/code&gt; on the diagonal, and &lt;code&gt;du&lt;/code&gt; on the superdiagonal.</source>
          <target state="translated">Finds the &lt;code&gt;LU&lt;/code&gt; factorization of a tridiagonal matrix with &lt;code&gt;dl&lt;/code&gt; on the subdiagonal, &lt;code&gt;d&lt;/code&gt; on the diagonal, and &lt;code&gt;du&lt;/code&gt; on the superdiagonal.</target>
        </trans-unit>
        <trans-unit id="f84cbc64cd18b52fd324e199af11a5fabde58655" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt; with matrix balancing. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. If &lt;code&gt;balanc = N&lt;/code&gt;, no balancing is performed. If &lt;code&gt;balanc = P&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted but not scaled. If &lt;code&gt;balanc = S&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is scaled but not permuted. If &lt;code&gt;balanc = B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted and scaled. If &lt;code&gt;sense = N&lt;/code&gt;, no reciprocal condition numbers are computed. If &lt;code&gt;sense = E&lt;/code&gt;, reciprocal condition numbers are computed for the eigenvalues only. If &lt;code&gt;sense = V&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors only. If &lt;code&gt;sense = B&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If &lt;code&gt;sense = E,B&lt;/code&gt;, the right and left eigenvectors must be computed.</source>
          <target state="translated">Находит собственную систему матрицы &lt;code&gt;A&lt;/code&gt; с балансировкой матриц. Если &lt;code&gt;jobvl = N&lt;/code&gt; , левые собственные векторы матрицы &lt;code&gt;A&lt;/code&gt; не вычисляются. Если &lt;code&gt;jobvr = N&lt;/code&gt; , правые собственные векторы &lt;code&gt;A&lt;/code&gt; не вычисляются. Если &lt;code&gt;jobvl = V&lt;/code&gt; или &lt;code&gt;jobvr = V&lt;/code&gt; , вычисляются соответствующие собственные векторы. Если &lt;code&gt;balanc = N&lt;/code&gt; , балансировка не выполняется. Если &lt;code&gt;balanc = P&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; переставляется, но не масштабируется. Если &lt;code&gt;balanc = S&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; масштабируется, но не переставляется. Если &lt;code&gt;balanc = B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; переставляется и масштабируется. Если &lt;code&gt;sense = N&lt;/code&gt; , обратные числа условий не вычисляются. Если &lt;code&gt;sense = E&lt;/code&gt; , обратные числа условия вычисляются только для собственных значений. Если &lt;code&gt;sense = V&lt;/code&gt; , обратные числа обусловленности вычисляются только для правых собственных векторов. Если &lt;code&gt;sense = B&lt;/code&gt; , числа взаимной обусловленности вычисляются для правых собственных векторов и собственных векторов. Если &lt;code&gt;sense = E,B&lt;/code&gt; , необходимо вычислить правый и левый собственные векторы.</target>
        </trans-unit>
        <trans-unit id="d0023ab74a3d6a6fa55c15cb99a0305228d939c9" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. Returns the eigenvalues in &lt;code&gt;W&lt;/code&gt;, the right eigenvectors in &lt;code&gt;VR&lt;/code&gt;, and the left eigenvectors in &lt;code&gt;VL&lt;/code&gt;.</source>
          <target state="translated">Находит eigensystem из &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;jobvl = N&lt;/code&gt; , левые собственные векторы матрицы &lt;code&gt;A&lt;/code&gt; не вычисляются. Если &lt;code&gt;jobvr = N&lt;/code&gt; , правые собственные векторы &lt;code&gt;A&lt;/code&gt; не вычисляются. Если &lt;code&gt;jobvl = V&lt;/code&gt; или &lt;code&gt;jobvr = V&lt;/code&gt; , вычисляются соответствующие собственные векторы. Возвращает собственные значения в &lt;code&gt;W&lt;/code&gt; , правые собственные векторы в &lt;code&gt;VR&lt;/code&gt; и левые собственные векторы в &lt;code&gt;VL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c756f96984dbd050044ac948d5f71380b56742" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of an upper triangular matrix &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;side = R&lt;/code&gt;, the right eigenvectors are computed. If &lt;code&gt;side = L&lt;/code&gt;, the left eigenvectors are computed. If &lt;code&gt;side = B&lt;/code&gt;, both sets are computed. If &lt;code&gt;howmny = A&lt;/code&gt;, all eigenvectors are found. If &lt;code&gt;howmny = B&lt;/code&gt;, all eigenvectors are found and backtransformed using &lt;code&gt;VL&lt;/code&gt; and &lt;code&gt;VR&lt;/code&gt;. If &lt;code&gt;howmny = S&lt;/code&gt;, only the eigenvectors corresponding to the values in &lt;code&gt;select&lt;/code&gt; are computed.</source>
          <target state="translated">Находит eigensystem из верхней треугольной матрицы &lt;code&gt;T&lt;/code&gt; . Если &lt;code&gt;side = R&lt;/code&gt; , вычисляются правые собственные векторы. Если &lt;code&gt;side = L&lt;/code&gt; , вычисляются левые собственные векторы. Если &lt;code&gt;side = B&lt;/code&gt; , вычисляются оба набора. Если &lt;code&gt;howmny = A&lt;/code&gt; , все собственные векторы найдены. Если &lt;code&gt;howmny = B&lt;/code&gt; , все собственные векторы будут найдены и преобразованы с помощью &lt;code&gt;VL&lt;/code&gt; и &lt;code&gt;VR&lt;/code&gt; . Если &lt;code&gt;howmny = S&lt;/code&gt; , вычисляются только собственные векторы, соответствующие значениям в &lt;code&gt;select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0322800c8fc7bfd25f123e3f433827d776d8a68b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used.</source>
          <target state="translated">Находит собственные значения ( &lt;code&gt;jobz = N&lt;/code&gt; ) или собственные значения и собственные векторы ( &lt;code&gt;jobz = V&lt;/code&gt; ) симметричной матрицу &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;uplo = U&lt;/code&gt; , верхний треугольник &lt;code&gt;A&lt;/code&gt; используется. Если &lt;code&gt;uplo = L&lt;/code&gt; , нижний треугольник &lt;code&gt;A&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="d4975ecab6a2216e2ae41b865699cde79f331c8b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. &lt;code&gt;abstol&lt;/code&gt; can be set as a tolerance for convergence.</source>
          <target state="translated">Находит собственные значения ( &lt;code&gt;jobz = N&lt;/code&gt; ) или собственные значения и собственные векторы ( &lt;code&gt;jobz = V&lt;/code&gt; ) симметричной матрицу &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;uplo = U&lt;/code&gt; , верхний треугольник &lt;code&gt;A&lt;/code&gt; используется. Если &lt;code&gt;uplo = L&lt;/code&gt; , нижний треугольник &lt;code&gt;A&lt;/code&gt; используется. Если &lt;code&gt;range = A&lt;/code&gt; , все собственные значения найдены. Если &lt;code&gt;range = V&lt;/code&gt; , находятся собственные значения в полуоткрытом интервале &lt;code&gt;(vl, vu]&lt;/code&gt; . Если &lt;code&gt;range = I&lt;/code&gt; , обнаруживаются собственные значения с индексами между &lt;code&gt;il&lt;/code&gt; и &lt;code&gt;iu&lt;/code&gt; . &lt;code&gt;abstol&lt;/code&gt; может быть установлен как допуск для сходимости.</target>
        </trans-unit>
        <trans-unit id="61beb0a5e34ea39a8997c5ca322120812554427f" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigendecomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed.</source>
          <target state="translated">Находит обобщенную eigendecomposition из &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; . Если &lt;code&gt;jobvl = N&lt;/code&gt; , левые собственные векторы не вычисляются. Если &lt;code&gt;jobvr = N&lt;/code&gt; , правильные собственные векторы не вычисляются. Если &lt;code&gt;jobvl = V&lt;/code&gt; или &lt;code&gt;jobvr = V&lt;/code&gt; , вычисляются соответствующие собственные векторы.</target>
        </trans-unit>
        <trans-unit id="c264a1b0e814f3cbf1d8360c3568e4b5d9e1b127" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt; and symmetric positive-definite matrix &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;itype = 1&lt;/code&gt;, the problem to solve is &lt;code&gt;A * x = lambda * B * x&lt;/code&gt;. If &lt;code&gt;itype = 2&lt;/code&gt;, the problem to solve is &lt;code&gt;A * B * x = lambda * x&lt;/code&gt;. If &lt;code&gt;itype = 3&lt;/code&gt;, the problem to solve is &lt;code&gt;B * A * x = lambda * x&lt;/code&gt;.</source>
          <target state="translated">Находит обобщенные собственные значения ( &lt;code&gt;jobz = N&lt;/code&gt; ) или собственных значений и собственных векторов ( &lt;code&gt;jobz = V&lt;/code&gt; ) симметричной матрицы &lt;code&gt;A&lt;/code&gt; и симметричной положительно определенной матрицы &lt;code&gt;B&lt;/code&gt; . Если &lt;code&gt;uplo = U&lt;/code&gt; , верхние треугольники &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; используются. Если &lt;code&gt;uplo = L&lt;/code&gt; , нижние треугольники &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; используются. Если &lt;code&gt;itype = 1&lt;/code&gt; , необходимо решить задачу &lt;code&gt;A * x = lambda * B * x&lt;/code&gt; . Если &lt;code&gt;itype = 2&lt;/code&gt; , необходимо решить задачу &lt;code&gt;A * B * x = lambda * x&lt;/code&gt; . Если &lt;code&gt;itype = 3&lt;/code&gt; , проблема, которую нужно решить, &lt;code&gt;B * A * x = lambda * x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32def567c6d9738ac90487f8efbe1b9b389479aa" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt; or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</source>
          <target state="translated">Находит разложение обобщенного сингулярного значения &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; и &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; . &lt;code&gt;D1&lt;/code&gt; имеет &lt;code&gt;alpha&lt;/code&gt; по диагонали, а &lt;code&gt;D2&lt;/code&gt; имеет &lt;code&gt;beta&lt;/code&gt; по диагонали. Если &lt;code&gt;jobu = U&lt;/code&gt; , вычисляется ортогональная / унитарная матрица &lt;code&gt;U&lt;/code&gt; . Если &lt;code&gt;jobv = V&lt;/code&gt; вычисляется ортогональная / унитарная матрица &lt;code&gt;V&lt;/code&gt; . Если &lt;code&gt;jobq = Q&lt;/code&gt; , вычисляется ортогональная / унитарная матрица &lt;code&gt;Q&lt;/code&gt; . Если &lt;code&gt;jobu&lt;/code&gt; , &lt;code&gt;jobv&lt;/code&gt; или &lt;code&gt;jobq&lt;/code&gt; равно &lt;code&gt;N&lt;/code&gt; , эта матрица не вычисляется. Эта функция доступна только в версиях LAPACK до 3.6.0.</target>
        </trans-unit>
        <trans-unit id="210e81d5d1ad1ff32c30a0939ad6da82758f3395" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt;, or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function requires LAPACK 3.6.0.</source>
          <target state="translated">Находит разложение обобщенного сингулярного значения &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; и &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; . &lt;code&gt;D1&lt;/code&gt; имеет &lt;code&gt;alpha&lt;/code&gt; по диагонали, а &lt;code&gt;D2&lt;/code&gt; имеет &lt;code&gt;beta&lt;/code&gt; по диагонали. Если &lt;code&gt;jobu = U&lt;/code&gt; , вычисляется ортогональная / унитарная матрица &lt;code&gt;U&lt;/code&gt; .Если &lt;code&gt;jobv = V&lt;/code&gt; вычисляется ортогональная / унитарная матрица &lt;code&gt;V&lt;/code&gt; .Если &lt;code&gt;jobq = Q&lt;/code&gt; , вычисляется ортогональная / унитарная матрица &lt;code&gt;Q&lt;/code&gt; .Если &lt;code&gt;jobu&lt;/code&gt; , &lt;code&gt;jobv&lt;/code&gt; или &lt;code&gt;jobq&lt;/code&gt; равно &lt;code&gt;N&lt;/code&gt; , эта матрица не вычисляется. Для этой функции требуется LAPACK 3.6.0.</target>
        </trans-unit>
        <trans-unit id="a39c044a480fd441ceb8f283f49fa1d53cc5f0a7" translate="yes" xml:space="preserve">
          <source>Finds the inverse of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;A&lt;/code&gt; is overwritten with its inverse.</source>
          <target state="translated">Находки обратная (верхний , если &lt;code&gt;uplo = U&lt;/code&gt; , ниже , если &lt;code&gt;uplo = L&lt;/code&gt; ) треугольная матрица . Если &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; имеет неединичные диагональные элементы. Если &lt;code&gt;diag = U&lt;/code&gt; , все диагональные элементы &lt;code&gt;A&lt;/code&gt; равны одному. &lt;code&gt;A&lt;/code&gt; заменяется обратным. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a5d68361868fdd15faef2d4f1871095495175a9" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. If &lt;code&gt;norm = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;norm = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm.</source>
          <target state="translated">Находит обратное условие количество (верхний , если &lt;code&gt;uplo = U&lt;/code&gt; , ниже , если &lt;code&gt;uplo = L&lt;/code&gt; ) треугольная матрица . Если &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; имеет неединичные диагональные элементы. Если &lt;code&gt;diag = U&lt;/code&gt; , все диагональные элементы &lt;code&gt;A&lt;/code&gt; равны одному. Если &lt;code&gt;norm = I&lt;/code&gt; , число обусловленности находится в норме бесконечности. Если &lt;code&gt;norm = O&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; , число обусловленности находится в одной норме. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c78886357b0729c06906090f44a5cf8b7b256de8" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;normtype = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;normtype = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm. &lt;code&gt;A&lt;/code&gt; must be the result of &lt;code&gt;getrf!&lt;/code&gt; and &lt;code&gt;anorm&lt;/code&gt; is the norm of &lt;code&gt;A&lt;/code&gt; in the relevant norm.</source>
          <target state="translated">Находит обоюдное число обусловленности матрицы &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;normtype = I&lt;/code&gt; , число обусловленности находится в норме бесконечности. Если &lt;code&gt;normtype = O&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; , число обусловленности находится в одной норме. Должно быть результатом &lt;code&gt;getrf!&lt;/code&gt; а &lt;code&gt;anorm&lt;/code&gt; - это норма &lt;code&gt;A&lt;/code&gt; в соответствующей норме. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c19c48ac3ae5442f994d8fe0a9d01dd34ef53de" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;, using a divide and conquer approach. If &lt;code&gt;job = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; and the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; or rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;job = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately.</source>
          <target state="translated">Находит разложение &lt;code&gt;A&lt;/code&gt; по сингулярным числам , &lt;code&gt;A = U * S * V'&lt;/code&gt; , используя подход &amp;laquo;разделяй и властвуй&amp;raquo;. Если &lt;code&gt;job = A&lt;/code&gt; , вычисляются все столбцы &lt;code&gt;U&lt;/code&gt; и строки &lt;code&gt;V'&lt;/code&gt; . Если &lt;code&gt;job = N&lt;/code&gt; , столбцы &lt;code&gt;U&lt;/code&gt; или строки &lt;code&gt;V'&lt;/code&gt; не вычисляются. Если &lt;code&gt;job = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; заменяется столбцами (thin) &lt;code&gt;U&lt;/code&gt; и строками (thin) &lt;code&gt;V'&lt;/code&gt; . Если &lt;code&gt;job = S&lt;/code&gt; , столбцы (thin) &lt;code&gt;U&lt;/code&gt; и строки (thin) &lt;code&gt;V'&lt;/code&gt; вычисляются и возвращаются отдельно.</target>
        </trans-unit>
        <trans-unit id="a0b3e8d21586ca0fb1724dcb3c78acc9787461cc" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;. If &lt;code&gt;jobu = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = A&lt;/code&gt; all the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = N&lt;/code&gt; no rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt;. If &lt;code&gt;jobvt = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;jobu = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; are computed and returned separately. If &lt;code&gt;jobvt = S&lt;/code&gt; the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately. &lt;code&gt;jobu&lt;/code&gt; and &lt;code&gt;jobvt&lt;/code&gt; can't both be &lt;code&gt;O&lt;/code&gt;.</source>
          <target state="translated">Находит сингулярное разложение &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = U * S * V'&lt;/code&gt; . Если &lt;code&gt;jobu = A&lt;/code&gt; , вычисляются все столбцы &lt;code&gt;U&lt;/code&gt; . Если &lt;code&gt;jobvt = A&lt;/code&gt; все строки &lt;code&gt;V'&lt;/code&gt; . Если &lt;code&gt;jobu = N&lt;/code&gt; , столбцы &lt;code&gt;U&lt;/code&gt; не вычисляются. Если &lt;code&gt;jobvt = N&lt;/code&gt; никакие строки &lt;code&gt;V'&lt;/code&gt; не вычисляются. Если &lt;code&gt;jobu = O&lt;/code&gt; , перезаписываются столбцами (тонкие) &lt;code&gt;U&lt;/code&gt; . Если &lt;code&gt;jobvt = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; заменяется строками (thin) &lt;code&gt;V'&lt;/code&gt; . Если &lt;code&gt;jobu = S&lt;/code&gt; , столбцы (thin) &lt;code&gt;A&lt;/code&gt; &lt;code&gt;U&lt;/code&gt; вычисляются и возвращаются отдельно. Если &lt;code&gt;jobvt = S&lt;/code&gt; строки (тонкого) &lt;code&gt;V'&lt;/code&gt; вычисляются и возвращаются отдельно. &lt;code&gt;jobu&lt;/code&gt; и &lt;code&gt;jobvt&lt;/code&gt; не могут быть оба &lt;code&gt;O&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfbc35df929a38fee1ee63d2aef508a3752ae6f0" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for Hermitian matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">Находит решение &lt;code&gt;A * X = B&lt;/code&gt; для эрмитовой матрицы &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;uplo = U&lt;/code&gt; , сохраняется верхняя половина &lt;code&gt;A&lt;/code&gt; .Если &lt;code&gt;uplo = L&lt;/code&gt; , сохраняется нижняя половина. &lt;code&gt;B&lt;/code&gt; перезаписывается решением &lt;code&gt;X&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; заменяется факторизацией Банча-Кауфмана. &lt;code&gt;ipiv&lt;/code&gt; содержит сводную информацию о факторизации.</target>
        </trans-unit>
        <trans-unit id="3f1c2e1c20cfe582666286913369ada94f51d8cf" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">Находит решение &lt;code&gt;A * X = B&lt;/code&gt; для симметричной матрицы &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;uplo = U&lt;/code&gt; , сохраняется верхняя половина &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;uplo = L&lt;/code&gt; , сохраняется нижняя половина. &lt;code&gt;B&lt;/code&gt; перезаписывается решением &lt;code&gt;X&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; заменяется факторизацией Банча-Кауфмана. &lt;code&gt;ipiv&lt;/code&gt; содержит сводную информацию о факторизации.</target>
        </trans-unit>
        <trans-unit id="05c0a676aeb2122358cb2d2b62a8dc34d0ff96bb" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by &lt;code&gt;potrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Находит решение &lt;code&gt;A * X = B&lt;/code&gt; где &lt;code&gt;A&lt;/code&gt; - симметричная или эрмитова положительно определенная матрица, чье разложение Холецкого было вычислено с помощью &lt;code&gt;potrf!&lt;/code&gt; , Если &lt;code&gt;uplo = U&lt;/code&gt; было вычислено верхнее разложение Холецкого &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;uplo = L&lt;/code&gt; было вычислено нижнее разложение Холецкого &lt;code&gt;A&lt;/code&gt; . &lt;code&gt;B&lt;/code&gt; перезаписывается с решением &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e99b5edae4a2dc1678284239ea67a37fe1921376" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. &lt;code&gt;A&lt;/code&gt; is overwritten by its Cholesky decomposition. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Находит решение &lt;code&gt;A * X = B&lt;/code&gt; где &lt;code&gt;A&lt;/code&gt; - симметричная или эрмитова положительно определенная матрица. Если &lt;code&gt;uplo = U&lt;/code&gt; вычисляется верхнее разложение Холецкого &lt;code&gt;A&lt;/code&gt; .Если &lt;code&gt;uplo = L&lt;/code&gt; вычисляется нижнее разложение Холецкого матрицы &lt;code&gt;A&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; перезаписывается его разложением Холецкого. &lt;code&gt;B&lt;/code&gt; перезаписывается с решением &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7e713430f9bcb8fd60110d1ddaba473fe37beb" translate="yes" xml:space="preserve">
          <source>Finished with an uncaught exception</source>
          <target state="translated">Завершено с неуловимым исключением</target>
        </trans-unit>
        <trans-unit id="d4f94f922955d9b99f89834068cd98fd1aba023b" translate="yes" xml:space="preserve">
          <source>Finite Part Integral</source>
          <target state="translated">Конечная цельная деталь</target>
        </trans-unit>
        <trans-unit id="e5b076c42526fba51c6923d8682dc75c64aa4bcd" translate="yes" xml:space="preserve">
          <source>Finite difference operator on a vector or a multidimensional array &lt;code&gt;A&lt;/code&gt;. In the latter case the dimension to operate on needs to be specified with the &lt;code&gt;dims&lt;/code&gt; keyword argument.</source>
          <target state="translated">Разностный оператор в векторе или многомерный массив &lt;code&gt;A&lt;/code&gt; . В последнем случае необходимо указать размерность, с которой нужно работать, с помощью аргумента ключевого слова &lt;code&gt;dims&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4557ec58940c5eada2fe857ddb8888c78004d3" translate="yes" xml:space="preserve">
          <source>Finite numbers are ordered in the usual manner.</source>
          <target state="translated">Конечные числа заказываются обычным способом.</target>
        </trans-unit>
        <trans-unit id="78baebfcb4b52665d7e8a9c7826c47b0fa2439f6" translate="yes" xml:space="preserve">
          <source>Fire</source>
          <target state="translated">Fire</target>
        </trans-unit>
        <trans-unit id="ccb3bd276e9391502d5858c0ee82ed61db7ec7a7" translate="yes" xml:space="preserve">
          <source>Fire Engine</source>
          <target state="translated">Пожарная машина</target>
        </trans-unit>
        <trans-unit id="c38b663a951f35db127c178e977a734a5f954d31" translate="yes" xml:space="preserve">
          <source>Firework Sparkler</source>
          <target state="translated">Фейерверк Искра</target>
        </trans-unit>
        <trans-unit id="4f8ff80cb6112a8df5a0ae17110f841b4709fc4a" translate="yes" xml:space="preserve">
          <source>Fireworks</source>
          <target state="translated">Fireworks</target>
        </trans-unit>
        <trans-unit id="0b7bdf63087ea834463f7869ee05ee0f78b2039d" translate="yes" xml:space="preserve">
          <source>First Quarter Moon</source>
          <target state="translated">первый квартал Луны</target>
        </trans-unit>
        <trans-unit id="8d23a610d2c1a9be816138d8135fd6968e488141" translate="yes" xml:space="preserve">
          <source>First Quarter Moon Symbol</source>
          <target state="translated">Символ Луны первого квартала</target>
        </trans-unit>
        <trans-unit id="74fa6c1e17a3a3252deb8af7194e87d8d33fbc11" translate="yes" xml:space="preserve">
          <source>First Quarter Moon With Face</source>
          <target state="translated">Первый квартал Луна с лицом</target>
        </trans-unit>
        <trans-unit id="f1738c1a48a67517ee40f4407fe85d205603ee0a" translate="yes" xml:space="preserve">
          <source>First, a review of some relevant Julia type terminology:</source>
          <target state="translated">Во-первых,обзор терминологии,относящейся к типу Джулии:</target>
        </trans-unit>
        <trans-unit id="429810985fd6146395c751081851ef1372d21c2f" translate="yes" xml:space="preserve">
          <source>First, let's review some relevant Julia type terminology:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cea893d2a53ebb1e9b3f78ee61f550c12f76b89" translate="yes" xml:space="preserve">
          <source>First, triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining strings within code that is indented. For example:</source>
          <target state="translated">Во-первых,строки в тройных кавычках также выделяются на уровень наименее выделенной строки.Это полезно для определения строк внутри кода,которые имеют отступы.Например:</target>
        </trans-unit>
        <trans-unit id="f0d11adabc82edc0523feb5883cbbd9e9d59c1cd" translate="yes" xml:space="preserve">
          <source>First, with &lt;code&gt;ntasks&lt;/code&gt; undefined, each element is processed in a different task.</source>
          <target state="translated">Во-первых, если &lt;code&gt;ntasks&lt;/code&gt; не определен, каждый элемент обрабатывается в отдельной задаче.</target>
        </trans-unit>
        <trans-unit id="3030e8ec7633ec1a524bb246aee7dbda6fb3e4bc" translate="yes" xml:space="preserve">
          <source>Fish</source>
          <target state="translated">Fish</target>
        </trans-unit>
        <trans-unit id="08ef4d73924ae1ff99ef9760dad3a8b35cdbc717" translate="yes" xml:space="preserve">
          <source>Fish Cake With Swirl Design</source>
          <target state="translated">Рыбный торт с вихревым дизайном</target>
        </trans-unit>
        <trans-unit id="6af9685850189240cc327402ef6a117b0925f447" translate="yes" xml:space="preserve">
          <source>Fisheye</source>
          <target state="translated">Fisheye</target>
        </trans-unit>
        <trans-unit id="217458563b479c9b5e1aa24b33b36b9c5286dff5" translate="yes" xml:space="preserve">
          <source>Fishing Pole And Fish</source>
          <target state="translated">Рыбацкий полюс и рыба</target>
        </trans-unit>
        <trans-unit id="ec1091759eb5098c1ce15fb7122c53128cb7e317" translate="yes" xml:space="preserve">
          <source>Fisted Hand Sign</source>
          <target state="translated">Висячий ручной знак</target>
        </trans-unit>
        <trans-unit id="46a9bd02c1e56f8667dcc006e6e80c33bdfb6b09" translate="yes" xml:space="preserve">
          <source>Five-argument &lt;code&gt;mul!&lt;/code&gt; requires at least Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4d04bcaeb407d6978ec547023834d74dc08028" translate="yes" xml:space="preserve">
          <source>Fix deprecation warnings</source>
          <target state="translated">Исправить предупреждения о депрессии</target>
        </trans-unit>
        <trans-unit id="f057e4dd9329dfaa6b558f5251558c8bd7042ccf" translate="yes" xml:space="preserve">
          <source>Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; would correspond to a date string like &lt;code&gt;&quot;20140716&quot;&lt;/code&gt;. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; from one period character to the next.</source>
          <target state="translated">Слоты фиксированной ширины указываются путем повторения символа точки количество раз, соответствующее ширине, без разделителя между символами. Таким образом, &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; будет соответствовать строке даты, такой как &lt;code&gt;&quot;20140716&quot;&lt;/code&gt; . Синтаксический анализатор отличает слот фиксированной ширины отсутствием разделителя, отмечая переход &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; от одного символа точки к другому.</target>
        </trans-unit>
        <trans-unit id="5695ea14bfec9e6b7d86faa5e86d6e6aa911f902" translate="yes" xml:space="preserve">
          <source>Flag In Hole</source>
          <target state="translated">Флаг в дыре</target>
        </trans-unit>
        <trans-unit id="58270b038657eb33ab9c272d4b0b663caf6f505b" translate="yes" xml:space="preserve">
          <source>Flatness</source>
          <target state="translated">Flatness</target>
        </trans-unit>
        <trans-unit id="157a69122ac7ee154e0f87d80f294a117ce27465" translate="yes" xml:space="preserve">
          <source>Flexed Biceps</source>
          <target state="translated">Флекс Бицепс</target>
        </trans-unit>
        <trans-unit id="ee9ce77c4431cac02ee809f2bf8b3362c097e451" translate="yes" xml:space="preserve">
          <source>Flip the bits of &lt;code&gt;val&lt;/code&gt; indexed by &lt;code&gt;flag&lt;/code&gt;, so that if a bit is &lt;code&gt;0&lt;/code&gt; it will be &lt;code&gt;1&lt;/code&gt; after the toggle, and vice-versa.</source>
          <target state="translated">Переверните биты &lt;code&gt;val&lt;/code&gt; , проиндексированные &lt;code&gt;flag&lt;/code&gt; , так что, если бит равен &lt;code&gt;0&lt;/code&gt; , он будет равен &lt;code&gt;1&lt;/code&gt; после переключения, и наоборот.</target>
        </trans-unit>
        <trans-unit id="444518fe06999c30d999423013ab4f1c5d158646" translate="yes" xml:space="preserve">
          <source>Floating-Point Numbers</source>
          <target state="translated">Числа с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="50eee28c25d79612d8553be7d7bd2846378f99a9" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:</source>
          <target state="translated">Арифметика с плавающей точкой влечет за собой множество тонкостей,которые могут быть удивительными для пользователей,незнакомых с низкоуровневыми деталями реализации.Однако,эти тонкости подробно описаны в большинстве книг по научным вычислениям,а также в следующих ссылках:</target>
        </trans-unit>
        <trans-unit id="fa83ec82b434276bb3bfc0811f157d35a5e75cfc" translate="yes" xml:space="preserve">
          <source>Floating-point numbers have &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;two zeros&lt;/a&gt;, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the &lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt;&lt;code&gt;bitstring&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">У чисел с плавающей запятой есть &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;два нуля&lt;/a&gt; , положительный ноль и отрицательный ноль. Они равны друг другу, но имеют разные двоичные представления, как можно увидеть с помощью функции &lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt; &lt;code&gt;bitstring&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3fba63653b996ccaa92264b381e4cee8797797a5" translate="yes" xml:space="preserve">
          <source>Floating-point operations on reduction variables can be reordered, possibly causing different results than without &lt;code&gt;@simd&lt;/code&gt;.</source>
          <target state="translated">Операции с плавающей запятой над &lt;code&gt;@simd&lt;/code&gt; переменными можно переупорядочить, что может привести к другим результатам, чем без @simd .</target>
        </trans-unit>
        <trans-unit id="5043ab32eb0ec94e147a66ceca999e1ecfae56b6" translate="yes" xml:space="preserve">
          <source>Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.</source>
          <target state="translated">Значения с плавающей запятой продвигаются к самому большому из типов аргументов с плавающей запятой.Целочисленные значения увеличиваются либо до наибольшего из натуральных размеров машинного слова,либо до наибольшего из целочисленных типов аргументов.Смеси целых чисел и значений с плавающей запятой переходят к типу с плавающей запятой,достаточно большому,чтобы вместить все значения.Целые числа,смешанные с нормированными значениями,переводятся в нормированные значения.Смешанные с плавающей точкой нормированные значения повышаются до размеров с плавающей точкой.Смешанные с вещественными значениями сложные значения переходят в соответствующий вид комплексных значений.</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">Плавающая запятая ноль</target>
        </trans-unit>
        <trans-unit id="d43047ffbb02b9960d1076b1d1bb9cdef48764e1" translate="yes" xml:space="preserve">
          <source>Flooring division, returning a value consistent with &lt;code&gt;mod1(x,y)&lt;/code&gt;</source>
          <target state="translated">Деление полов, возвращающее значение, соответствующее &lt;code&gt;mod1(x,y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cb23ae2c189b13f5f90d739cf453c252387dc2d" translate="yes" xml:space="preserve">
          <source>Floppy Disk</source>
          <target state="translated">Дискета</target>
        </trans-unit>
        <trans-unit id="00d43012b0d3d0a7fff1c3e0edf1cbd87e191788" translate="yes" xml:space="preserve">
          <source>Flower Playing Cards</source>
          <target state="translated">Игровые карточки с цветами</target>
        </trans-unit>
        <trans-unit id="3b70164ceac5ab45d8a49385e479599c3b2028ee" translate="yes" xml:space="preserve">
          <source>Flushed Face</source>
          <target state="translated">Покрасневшее лицо</target>
        </trans-unit>
        <trans-unit id="c095ff38e8ffaf6ceac6c9df64aa62e9da573536" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; streams (which may have been written to by external C code).</source>
          <target state="translated">Сбрасывает потоки C &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; (которые могли быть записаны внешним кодом C).</target>
        </trans-unit>
        <trans-unit id="88957d8137dbc8ecadcade0adeacd0f2a5ab4356" translate="yes" xml:space="preserve">
          <source>Foggy</source>
          <target state="translated">Foggy</target>
        </trans-unit>
        <trans-unit id="6e5da7739741403346eb36590ee15c92d6501bc4" translate="yes" xml:space="preserve">
          <source>Following the outer constructor definitions, we defined a number of methods for the &lt;code&gt;⊘&lt;/code&gt; operator, which provides a syntax for writing rationals (e.g. &lt;code&gt;1 ⊘ 2&lt;/code&gt;). Julia's &lt;code&gt;Rational&lt;/code&gt; type uses the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator for this purpose. Before these definitions, &lt;code&gt;⊘&lt;/code&gt; is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers&quot;&gt;Rational Numbers&lt;/a&gt; &amp;ndash; its entire behavior is defined in these few lines. The first and most basic definition just makes &lt;code&gt;a ⊘ b&lt;/code&gt; construct a &lt;code&gt;OurRational&lt;/code&gt; by applying the &lt;code&gt;OurRational&lt;/code&gt; constructor to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; when they are integers. When one of the operands of &lt;code&gt;⊘&lt;/code&gt; is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying &lt;code&gt;⊘&lt;/code&gt; to complex integral values creates an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; &amp;ndash; a complex number whose real and imaginary parts are rationals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c789741f990351befd624144e4fbf31c533b3a78" translate="yes" xml:space="preserve">
          <source>Following the outer constructor definitions, we defined a number of methods for the &lt;code&gt;⊘&lt;/code&gt; operator, which provides a syntax for writing rationals (e.g. &lt;code&gt;1 ⊘ 2&lt;/code&gt;). Julia's &lt;code&gt;Rational&lt;/code&gt; type uses the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator for this purpose. Before these definitions, &lt;code&gt;⊘&lt;/code&gt; is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers&lt;/a&gt; &amp;ndash; its entire behavior is defined in these few lines. The first and most basic definition just makes &lt;code&gt;a ⊘ b&lt;/code&gt; construct a &lt;code&gt;OurRational&lt;/code&gt; by applying the &lt;code&gt;OurRational&lt;/code&gt; constructor to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; when they are integers. When one of the operands of &lt;code&gt;⊘&lt;/code&gt; is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying &lt;code&gt;⊘&lt;/code&gt; to complex integral values creates an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; &amp;ndash; a complex number whose real and imaginary parts are rationals:</source>
          <target state="translated">Следуя определениям внешнего конструктора, мы определили ряд методов для оператора &lt;code&gt;⊘&lt;/code&gt; , который обеспечивает синтаксис для записи рациональных чисел (например, &lt;code&gt;1 ⊘ 2&lt;/code&gt; ). Тип &lt;code&gt;Rational&lt;/code&gt; Джулии использует для этой цели оператор &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt; . До этих определений &lt;code&gt;⊘&lt;/code&gt; - это полностью неопределенный оператор, имеющий только синтаксис и не имеющий значения. После этого он ведет себя так же, как описано в &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers&lt;/a&gt; - все его поведение определяется в этих нескольких строках. Первое и самое простое определение просто заставляет &lt;code&gt;a ⊘ b&lt;/code&gt; построить &lt;code&gt;OurRational&lt;/code&gt; , применяя конструктор &lt;code&gt;OurRational&lt;/code&gt; к &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .когда они целые числа. Когда один из операндов &lt;code&gt;⊘&lt;/code&gt; уже рациональное число, мы строим новое рациональные для полученного соотношения немного по- разному; это поведение фактически идентично делению рационального числа на целое. Наконец, применение &lt;code&gt;⊘&lt;/code&gt; к комплексным целым значениям создает экземпляр &lt;code&gt;Complex{OurRational}&lt;/code&gt; - комплексного числа, действительная и мнимая части которого являются рациональными:</target>
        </trans-unit>
        <trans-unit id="1e77a8685e1b18b030132d7235106a58bff9d77d" translate="yes" xml:space="preserve">
          <source>Footnote references</source>
          <target state="translated">Ссылки в сносках</target>
        </trans-unit>
        <trans-unit id="9d738544b84d3e6ca69948f1d45fc336d259c385" translate="yes" xml:space="preserve">
          <source>Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the &lt;code&gt;:&lt;/code&gt; character that is appended to the footnote label.</source>
          <target state="translated">Текст сноски определяется с использованием следующего синтаксиса, который аналогичен синтаксису ссылки на сноску, за исключением символа &lt;code&gt;:&lt;/code&gt; , который добавляется к метке сноски.</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="6f17ee469db4ec0c0c7e81b41c2cbcf9f902b3cc" translate="yes" xml:space="preserve">
          <source>Footprints</source>
          <target state="translated">Footprints</target>
        </trans-unit>
        <trans-unit id="ae9f4e9dfa0443b0ceae859867c4f509f5a9474e" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects this can be done either directly or by use of a convenience macro:</source>
          <target state="translated">Для объектов &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; это можно сделать либо напрямую, либо с помощью вспомогательного макроса:</target>
        </trans-unit>
        <trans-unit id="b1492f65d2da61bde614e2df1030321603972a60" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;. For &lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt;.</source>
          <target state="translated">Для целочисленных типов &lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; знака это эквивалентно &lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; . Для &lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; числа типов, это равносильно тому , &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a40737843ce84d120d446cac7c60f6d3a180523" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types that support arbitrary dimensionality, &lt;code&gt;N&lt;/code&gt; can be set to &lt;code&gt;Any&lt;/code&gt;:</source>
          <target state="translated">Для типов &lt;code&gt;AbstractArray&lt;/code&gt; , поддерживающих произвольную размерность, &lt;code&gt;N&lt;/code&gt; может быть установлено значение &lt;code&gt;Any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78cc0c00798ab494e86cd193ffb9a72a0848fb41" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types, defining a &lt;code&gt;BroadcastStyle&lt;/code&gt; supersedes the fallback choice, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt;&lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;DefaultArrayStyle&lt;/code&gt; and the abstract supertype, &lt;code&gt;AbstractArrayStyle&lt;/code&gt;, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.</source>
          <target state="translated">Для типов &lt;code&gt;AbstractArray&lt;/code&gt; определение &lt;code&gt;BroadcastStyle&lt;/code&gt; заменяет альтернативный вариант &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt; &lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;DefaultArrayStyle&lt;/code&gt; и абстрактный супертип &lt;code&gt;AbstractArrayStyle&lt;/code&gt; сохраняют размерность как параметр типа для поддержки специализированных типов массивов, которые имеют фиксированные требования к размерности.</target>
        </trans-unit>
        <trans-unit id="0c614db39e8f0ca718810e31731f59d181271482" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArrays&lt;/code&gt; that only support a certain dimensionality, create a subtype of &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; (see below).</source>
          <target state="translated">Для &lt;code&gt;AbstractArrays&lt;/code&gt; , которые поддерживают только определенную размерность, создайте подтип &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="36e4edbd82274075aaa50a1a6642d0776aa14705" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MySimpleContainer&lt;/code&gt;, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.</source>
          <target state="translated">Для &lt;code&gt;MySimpleContainer&lt;/code&gt; объект полностью определяется своим типом и параметрами, поэтому компилятор может генерировать оптимизированные функции. В большинстве случаев этого, вероятно, будет достаточно.</target>
        </trans-unit>
        <trans-unit id="08c5ae2629f26fdb821a26a0f5b3306f51f209f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;SymTridiagonal&lt;/code&gt; block matrices, the elements of &lt;code&gt;dv&lt;/code&gt; are symmetrized. The argument &lt;code&gt;ev&lt;/code&gt; is interpreted as the superdiagonal. Blocks from the subdiagonal are (materialized) transpose of the corresponding superdiagonal blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066f4790c89fa96385b602165d512d492e66ecc6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;wchar_t*&lt;/code&gt; arguments, the Julia type should be &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt; (if the C routine expects a NUL-terminated string) or &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the &lt;code&gt;Cwstring&lt;/code&gt; type will cause an error to be thrown if the string itself contains NUL characters).</source>
          <target state="translated">Для аргументов &lt;code&gt;wchar_t*&lt;/code&gt; тип Julia должен быть &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt; (если процедура C ожидает строку с завершающим NUL) или &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; противном случае. Также обратите внимание, что строковые данные UTF-8 в Julia имеют внутреннее завершение NUL, поэтому их можно передать функциям C, ожидающим данных с завершающим NUL, без создания копии (но использование типа &lt;code&gt;Cwstring&lt;/code&gt; вызовет ошибку, если сама строка содержит символы NUL).</target>
        </trans-unit>
        <trans-unit id="757bf33c899d624608fa2ee3a0b47130199f6860" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;wchar_t*&lt;/code&gt; arguments, the Julia type should be &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt; (if the C routine expects a NUL-terminated string), or &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the &lt;code&gt;Cwstring&lt;/code&gt; type will cause an error to be thrown if the string itself contains NUL characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d4350a3633a902604161c6b5b29254014e76bb" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;every&lt;/em&gt; binary operation like &lt;code&gt;^&lt;/code&gt;, there is a corresponding &quot;dot&quot; operation &lt;code&gt;.^&lt;/code&gt; that is &lt;em&gt;automatically&lt;/em&gt; defined to perform &lt;code&gt;^&lt;/code&gt; element-by-element on arrays. For example, &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; is not defined, since there is no standard mathematical meaning to &quot;cubing&quot; a (non-square) array, but &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; is defined as computing the elementwise (or &quot;vectorized&quot;) result &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt;. Similarly for unary operators like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&amp;radic;&lt;/code&gt;, there is a corresponding &lt;code&gt;.&amp;radic;&lt;/code&gt; that applies the operator elementwise.</source>
          <target state="translated">Для &lt;em&gt;каждой&lt;/em&gt; двоичной операции, такой как &lt;code&gt;^&lt;/code&gt; , существует соответствующая операция &quot;точка&quot; &lt;code&gt;.^&lt;/code&gt; , Которая &lt;em&gt;автоматически&lt;/em&gt; определяется для выполнения &lt;code&gt;^&lt;/code&gt; элемент за элементом в массивах. Например, &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; не определено, поскольку нет стандартного математического смысла для &amp;laquo;кубирования&amp;raquo; (неквадратного) массива, но &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; определяется как вычисление поэлементный (или &quot;векторизованный&quot;) результат &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt; . Аналогично для унарных операторов вроде &lt;code&gt;!&lt;/code&gt; или &lt;code&gt;&amp;radic;&lt;/code&gt; , существует соответствующий &lt;code&gt;.&amp;radic;&lt;/code&gt; , который применяет оператор поэлементно.</target>
        </trans-unit>
        <trans-unit id="33b12b0497bd71670a617ce62626d84d142b3953" translate="yes" xml:space="preserve">
          <source>For Adjoint/Transpose-wrapped vectors, return the operator $q$-norm of &lt;code&gt;A&lt;/code&gt;, which is equivalent to the &lt;code&gt;p&lt;/code&gt;-norm with value &lt;code&gt;p = q/(q-1)&lt;/code&gt;. They coincide at &lt;code&gt;p = q = 2&lt;/code&gt;. Use &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; to compute the &lt;code&gt;p&lt;/code&gt; norm of &lt;code&gt;A&lt;/code&gt; as a vector.</source>
          <target state="translated">Для векторов с добавлением / транспонированием верните оператор $ q $ -норму для &lt;code&gt;A&lt;/code&gt; , которая эквивалентна &lt;code&gt;p&lt;/code&gt; -норме со значением &lt;code&gt;p = q/(q-1)&lt;/code&gt; . Они совпадают при &lt;code&gt;p = q = 2&lt;/code&gt; . Используйте &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; ,&lt;/a&gt; чтобы вычислить &lt;code&gt;p&lt;/code&gt; - норму &lt;code&gt;A&lt;/code&gt; как вектора.</target>
        </trans-unit>
        <trans-unit id="7cce7fbd5f6d7a391c27939f48d9689b1cad7e94" translate="yes" xml:space="preserve">
          <source>For All</source>
          <target state="translated">Для всех</target>
        </trans-unit>
        <trans-unit id="34ab36290f41b0fe509819193b0860af6e374811" translate="yes" xml:space="preserve">
          <source>For Fortran functions taking variable length strings of type &lt;code&gt;character(len=*)&lt;/code&gt; the string lengths are provided as &lt;em&gt;hidden arguments&lt;/em&gt;. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using &lt;code&gt;Csize_t&lt;/code&gt; as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others &lt;em&gt;optionally&lt;/em&gt; permit placing hidden arguments directly after the character argument (Intel, PGI). For example, Fortran subroutines of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4c87ed1d5890c7a24dd4de829654130f87033e" translate="yes" xml:space="preserve">
          <source>For Fortran functions taking variable length strings of type &lt;code&gt;character(len=*)&lt;/code&gt; the string lengths are provided as &lt;em&gt;hidden arguments&lt;/em&gt;. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using &lt;code&gt;Csize_t&lt;/code&gt; as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others &lt;em&gt;optionally&lt;/em&gt; permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the form</source>
          <target state="translated">Для функций Fortran, принимающих строки переменной длины типа &lt;code&gt;character(len=*)&lt;/code&gt; длины строк указываются как &lt;em&gt;скрытые аргументы&lt;/em&gt; . Тип и положение этих аргументов в списке зависят от компилятора, при этом поставщики компиляторов обычно по умолчанию используют &lt;code&gt;Csize_t&lt;/code&gt; в качестве типа и добавляют скрытые аргументы в конец списка аргументов. Хотя это поведение исправлено для некоторых компиляторов (GNU), другие по &lt;em&gt;желанию&lt;/em&gt; позволяют размещать скрытые аргументы непосредственно после символьного аргумента (Intel, PGI). Например, подпрограммы Fortran вида</target>
        </trans-unit>
        <trans-unit id="d553b36129c90b85dcd46c9add276340b10d3409" translate="yes" xml:space="preserve">
          <source>For Loops and Comprehensions</source>
          <target state="translated">Для Петлей и Пониманий</target>
        </trans-unit>
        <trans-unit id="717c84af107ffef8e4706cbbe50e715cf976c386" translate="yes" xml:space="preserve">
          <source>For Windows users, Julia's shell mode does not expose windows shell commands. Hence, this will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f78eccb3fe706727ad782465619222ec9fd8a5" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;String&lt;/code&gt;, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an &lt;code&gt;a::Array&lt;/code&gt; of some other bitstype, you can do &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt;, but note that the result may be endian-dependent.</source>
          <target state="translated">Для &lt;code&gt;String&lt;/code&gt; обратите внимание, что результат зависит от кодировки UTF-8 (другая контрольная сумма будет получена из другой кодировки Unicode). Чтобы получить контрольную сумму &lt;code&gt;a::Array&lt;/code&gt; для некоторого другого битового типа, вы можете выполнить &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt; , но обратите внимание, что результат может зависеть от порядка байтов.</target>
        </trans-unit>
        <trans-unit id="fdbd68155fa3d6b046d9d04578affc99d85e662a" translate="yes" xml:space="preserve">
          <source>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook's &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;article&lt;/a&gt; on the subject as well as his &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;introduction&lt;/a&gt; to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</source>
          <target state="translated">Краткое, но наглядное представление о том, как представлены числа с плавающей запятой, можно найти в &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;статье&lt;/a&gt; Джона Д. Кука по этому вопросу, а также в его &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;введении&lt;/a&gt; к некоторым вопросам, возникающим из-за того, как поведение этого представления отличается от идеализированной абстракции действительных чисел.</target>
        </trans-unit>
        <trans-unit id="26d026061b818471461b6e11cb1c3175bde48284" translate="yes" xml:space="preserve">
          <source>For a complete example, let's say you have created a type, &lt;code&gt;ArrayAndChar&lt;/code&gt;, that stores an array and a single character:</source>
          <target state="translated">В качестве полного примера предположим, что вы создали тип &lt;code&gt;ArrayAndChar&lt;/code&gt; , который хранит массив и один символ:</target>
        </trans-unit>
        <trans-unit id="125644f126fbc4277c5149f11a90f626bb48ac54" translate="yes" xml:space="preserve">
          <source>For a complete list of &lt;em&gt;every&lt;/em&gt; Julia operator's precedence, see the top of this file: &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt;&lt;code&gt;src/julia-parser.scm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Полный список приоритетов &lt;em&gt;каждого&lt;/em&gt; оператора Julia см. В верхней части этого файла: &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt; &lt;code&gt;src/julia-parser.scm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f4d0c1cef2d73378f1ab6ea21dcd2e3aa81e9b0" translate="yes" xml:space="preserve">
          <source>For a given period, return the value associated with that period. For example, &lt;code&gt;value(Millisecond(10))&lt;/code&gt; returns 10 as an integer.</source>
          <target state="translated">Для заданного периода вернуть значение, связанное с этим периодом. Например, &lt;code&gt;value(Millisecond(10))&lt;/code&gt; возвращает 10 как целое число.</target>
        </trans-unit>
        <trans-unit id="f1ded20e8e0575e0300cc2adc5a53b33da3694f1" translate="yes" xml:space="preserve">
          <source>For a more general way to make all such calls work sensibly, see &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general &lt;code&gt;Point&lt;/code&gt; constructor work as one would expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ab5fbb77be1d46e4a2df54b426186afb121ac6" translate="yes" xml:space="preserve">
          <source>For a more general way to make all such calls work sensibly, see &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general &lt;code&gt;Point&lt;/code&gt; constructor work as one would expect:</source>
          <target state="translated">Более общий способ заставить все такие звонки работать разумно, см. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Преобразование и продвижение&lt;/a&gt; . Рискуя испортить ожидание, мы можем показать здесь, что все, что нужно, - это следующее определение внешнего метода, чтобы все вызовы общего конструктора &lt;code&gt;Point&lt;/code&gt; работали так, как и следовало ожидать:</target>
        </trans-unit>
        <trans-unit id="ed852a3125d50800bb13a676272e7f42d0c371f3" translate="yes" xml:space="preserve">
          <source>For a more specific example, a generic square-matrix multiply pseudo-code might look like:</source>
          <target state="translated">Для более конкретного примера может показаться,что общий квадратно-матричный псевдокод может выглядеть как псевдокод:</target>
        </trans-unit>
        <trans-unit id="8b96550022e1c9fcddbfb08ee86d23ebf98de982" translate="yes" xml:space="preserve">
          <source>For a scalar input, &lt;code&gt;eigvals&lt;/code&gt; will return a scalar.</source>
          <target state="translated">Для скалярного ввода &lt;code&gt;eigvals&lt;/code&gt; вернет скаляр.</target>
        </trans-unit>
        <trans-unit id="6e10df5562967eabafd887233bdf313820cd17e4" translate="yes" xml:space="preserve">
          <source>For addition details see the LibGit2 guide on &lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;authenticating against a server&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения см. В руководстве LibGit2 по &lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;аутентификации на сервере&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f08193acb8e4821221019bdf43b59fe564f1010" translate="yes" xml:space="preserve">
          <source>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; and &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt;.</source>
          <target state="translated">Для получения дополнительной (алгоритмической) информации и версий этих методов, в которых отсутствует проверка аргументов, см. (Неэкспортированные) родительские методы &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; и &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="42ec6c27994a098a5b5c8be91c0dfca1418b0092" translate="yes" xml:space="preserve">
          <source>For additional documentation and an expert driver, see &lt;code&gt;SparseArrays.sparse!&lt;/code&gt;.</source>
          <target state="translated">Для получения дополнительной документации и опытного драйвера см. &lt;code&gt;SparseArrays.sparse!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="2966c479e2a97d05120d634abb3c3b4fa57bcb14" translate="yes" xml:space="preserve">
          <source>For all practical purposes, such objects behave identically to those of &lt;code&gt;MyStillAmbiguousType&lt;/code&gt;.</source>
          <target state="translated">Для всех практических целей такие объекты ведут себя идентично объектам &lt;code&gt;MyStillAmbiguousType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2586b120b44665025a1f73d79469ce79bd89f3e9" translate="yes" xml:space="preserve">
          <source>For allowed arguments, see &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Допустимые аргументы см. В &lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1cb1d8b0a6fd3f459dd21aee4330db5fb020cbc" translate="yes" xml:space="preserve">
          <source>For an M-by-N matrix &lt;code&gt;A&lt;/code&gt; and P-by-N matrix &lt;code&gt;B&lt;/code&gt;,</source>
          <target state="translated">Для матрицы &lt;code&gt;A&lt;/code&gt; размером M на N и матрицы &lt;code&gt;B&lt;/code&gt; размера P на N ,</target>
        </trans-unit>
        <trans-unit id="c4a55d03c0f3c7fb4fb277a66cb30932f6ca5fde" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the maximum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">Для ввода массива вернуть индексы максимальных элементов по заданным размерам. &lt;code&gt;NaN&lt;/code&gt; считается большим, чем все другие значения.</target>
        </trans-unit>
        <trans-unit id="f86a7fc66f2b2ba3bac55fe34c24f68f4fabc8c5" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the minimum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">Для ввода массива верните индексы минимальных элементов по заданным размерам. &lt;code&gt;NaN&lt;/code&gt; считается меньшим, чем все другие значения.</target>
        </trans-unit>
        <trans-unit id="29ced7bd7c80c9a4577211e81fdcb7b16c085cf0" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the maximum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">Для ввода массива возвращает значение и индекс максимума по заданным измерениям. &lt;code&gt;NaN&lt;/code&gt; считается большим, чем все другие значения.</target>
        </trans-unit>
        <trans-unit id="049c1d61ced18d9f201600808d1def1f22e2bc2b" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the minimum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">Для ввода массива возвращает значение и индекс минимума по заданным измерениям. &lt;code&gt;NaN&lt;/code&gt; считается меньшим, чем все другие значения.</target>
        </trans-unit>
        <trans-unit id="af04ee9a31664b38b875e97d7dedcb572df90336" translate="yes" xml:space="preserve">
          <source>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg's paper &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;.</source>
          <target state="translated">Превосходное и подробное обсуждение чисел с плавающей запятой и проблем числовой точности, возникающих при вычислениях с ними, можно найти в статье Дэвида Голдберга &amp;laquo; &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;Что должен знать каждый компьютерный ученый об арифметике с плавающей запятой&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b2edf4da8334ec709f88df3d9c11c7bf6cf6a32" translate="yes" xml:space="preserve">
          <source>For an in-place version and algorithmic information, see &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для получения информации о версии на месте и алгоритмической информации см. &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="231340498dbc5d7093c855f539374b7859ea6f87" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.</source>
          <target state="translated">Для итератора или коллекции,в которой есть ключи и значения (например,массивы и словари),верните итератор над ключами.</target>
        </trans-unit>
        <trans-unit id="9cf1660ad8de659f871c4cde9fc066e87eb4f30f" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</source>
          <target state="translated">Для итератора или коллекции с ключами и значениями верните итератор поверх значений.Эта функция просто возвращает свой аргумент по умолчанию,так как элементы общего итератора обычно считаются его &quot;значениями&quot;.</target>
        </trans-unit>
        <trans-unit id="f5a23131be87d6b23ab4381b2afccc7a7294e103" translate="yes" xml:space="preserve">
          <source>For an ordered container &lt;code&gt;collection&lt;/code&gt;, add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a50cf1c996d77537f503b2b0ab2ae143d3ab0c" translate="yes" xml:space="preserve">
          <source>For an out-of-place version, see &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;. For algorithmic information, see &lt;code&gt;fkeep!&lt;/code&gt;.</source>
          <target state="translated">Для &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt; версии см. Dropzeros . Для получения информации об алгоритмах см. &lt;code&gt;fkeep!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d9698467f9f9a26107005e5cc7d8c52ec73e6fba" translate="yes" xml:space="preserve">
          <source>For an overview of why functions like &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt;&lt;code&gt;hypot&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt;&lt;code&gt;expm1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; are necessary and useful, see John D. Cook's excellent pair of blog posts on the subject: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt;, and &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о том, почему такие функции , как &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt; &lt;code&gt;hypot&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt; &lt;code&gt;expm1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; необходимы и полезны, см отличную пару Джона Д. Кук сообщений в блоге на эту тему: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, ERFC&lt;/a&gt; и &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d80c08b4c206c014a1c8f4dd0759aa7c625fa2a" translate="yes" xml:space="preserve">
          <source>For any iterable container &lt;code&gt;A&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;norm&lt;/code&gt; is defined), compute the &lt;code&gt;p&lt;/code&gt;-norm (defaulting to &lt;code&gt;p=2&lt;/code&gt;) as if &lt;code&gt;A&lt;/code&gt; were a vector of the corresponding length.</source>
          <target state="translated">Для любого итеративного контейнера &lt;code&gt;A&lt;/code&gt; (включая массивы любой размерности) чисел (или любого типа элемента, для которого определена &lt;code&gt;norm&lt;/code&gt; ) вычислить &lt;code&gt;p&lt;/code&gt; - норму (по умолчанию &lt;code&gt;p=2&lt;/code&gt; ), как если бы &lt;code&gt;A&lt;/code&gt; был вектором соответствующей длины.</target>
        </trans-unit>
        <trans-unit id="a3a03065c6c3f77db333198b92d9783df8912cc7" translate="yes" xml:space="preserve">
          <source>For any iterable containers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;dot&lt;/code&gt; is defined), compute the dot product (or inner product or scalar product), i.e. the sum of &lt;code&gt;dot(x[i],y[i])&lt;/code&gt;, as if they were vectors.</source>
          <target state="translated">Для любых повторяемых контейнеров &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; (включая массивы любого измерения) чисел (или любого типа элемента, для которого определена &lt;code&gt;dot&lt;/code&gt; ), вычислите скалярное произведение (или внутреннее произведение или скалярное произведение), то есть сумму &lt;code&gt;dot(x[i],y[i])&lt;/code&gt; , как если бы они были векторами.</target>
        </trans-unit>
        <trans-unit id="9861c33db5cb32a638bd7ed95113f331a3454eb4" translate="yes" xml:space="preserve">
          <source>For any keywords that are not specified, the current settings from &lt;code&gt;cmd&lt;/code&gt; are used. Normally, to create a &lt;code&gt;Cmd&lt;/code&gt; object in the first place, one uses backticks, e.g.</source>
          <target state="translated">Для любых неуказанных ключевых слов используются текущие настройки из &lt;code&gt;cmd&lt;/code&gt; . Обычно для создания объекта &lt;code&gt;Cmd&lt;/code&gt; в первую очередь используются обратные кавычки, например</target>
        </trans-unit>
        <trans-unit id="85d14ad6a0f26364153773489f0db13bfaafa53f" translate="yes" xml:space="preserve">
          <source>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to &lt;code&gt;length(A)&lt;/code&gt;. However, for &lt;code&gt;AbstractVector&lt;/code&gt;s linear indices are &lt;code&gt;axes(A, 1)&lt;/code&gt;, and therefore do not start at 1 for vectors with unconventional indexing.</source>
          <target state="translated">Для массивов с обычной индексацией (индексы начинаются с 1) или любого многомерного массива линейные индексы находятся в диапазоне от 1 до &lt;code&gt;length(A)&lt;/code&gt; . Однако для &lt;code&gt;AbstractVector&lt;/code&gt; линейные индексы являются &lt;code&gt;axes(A, 1)&lt;/code&gt; , и поэтому не начинаются с 1 для векторов с нетрадиционной индексацией.</target>
        </trans-unit>
        <trans-unit id="81f6c2e801b1d9455cd3aa8ac3e88e840497dca8" translate="yes" xml:space="preserve">
          <source>For arrays, returns a string of size and type info, e.g. &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt;.</source>
          <target state="translated">Для массивов возвращает строку информации о размере и типе, например, &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06562c8550b5e93a013f75fd29118d4c0694a02a" translate="yes" xml:space="preserve">
          <source>For arrays, this function requires at least Julia 1.2.</source>
          <target state="translated">Для массивов эта функция требует,по крайней мере,Джулии 1.2.</target>
        </trans-unit>
        <trans-unit id="d3e36f74f84aea73dce8e8117a1733e018408eb9" translate="yes" xml:space="preserve">
          <source>For bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.</source>
          <target state="translated">Для битовых типов это означает,что битовый паттерн значения после установки никогда не изменится,и это значение является идентификатором битового типа.</target>
        </trans-unit>
        <trans-unit id="7aee08c8ffda1f859a18b6cbf5bd4f3be6da6c3e" translate="yes" xml:space="preserve">
          <source>For cartesian to linear index conversion, see &lt;a href=&quot;#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для преобразования декартовых индексов в линейные см. &lt;a href=&quot;#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b30defdf847f67d42803fa30f31344e75b07b3" translate="yes" xml:space="preserve">
          <source>For code points less than &lt;code&gt;\u80&lt;/code&gt;, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding &lt;code&gt;\x&lt;/code&gt; escape, so the distinction can safely be ignored. For the escapes &lt;code&gt;\x80&lt;/code&gt; through &lt;code&gt;\xff&lt;/code&gt; as compared to &lt;code&gt;\u80&lt;/code&gt; through &lt;code&gt;\uff&lt;/code&gt;, however, there is a major difference: the former escapes all encode single bytes, which &amp;ndash; unless followed by very specific continuation bytes &amp;ndash; do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</source>
          <target state="translated">Для кодовых точек меньше &lt;code&gt;\u80&lt;/code&gt; бывает, что кодировка UTF-8 каждой кодовой точки - это всего лишь один байт, созданный соответствующим экранированием &lt;code&gt;\x&lt;/code&gt; , поэтому различие можно безопасно игнорировать. Однако для экранирований от &lt;code&gt;\x80&lt;/code&gt; до &lt;code&gt;\xff&lt;/code&gt; по сравнению с &lt;code&gt;\u80&lt;/code&gt; до &lt;code&gt;\uff&lt;/code&gt; есть существенное различие: в первом экранируются все одиночные байты, которые, если за ними не следуют очень специфические байты продолжения, не образуют действительный UTF-8. data, тогда как последние экранируют все кодовые точки Unicode с двухбайтовой кодировкой.</target>
        </trans-unit>
        <trans-unit id="7990f7d8e420dec5f948426ee0deb5045c50fdaa" translate="yes" xml:space="preserve">
          <source>For composite types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value's content may itself be modified.</source>
          <target state="translated">Для составных типов это означает,что идентичность значений его полей никогда не изменится.Когда поля являются битовыми типами,это означает,что их биты никогда не изменятся,для полей,значения которых являются мутируемыми типами,как массивы,это означает,что поля всегда будут ссылаться на одно и то же мутируемое значение,даже если содержание этого мутируемого значения само по себе может быть изменено.</target>
        </trans-unit>
        <trans-unit id="03316709b23be1fe05fb3b1026fde6353f45ac08" translate="yes" xml:space="preserve">
          <source>For consistency across Julia, the call site should always pass a &lt;code&gt;Val&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; rather than using a &lt;em&gt;type&lt;/em&gt;, i.e., use &lt;code&gt;foo(Val(:bar))&lt;/code&gt; rather than &lt;code&gt;foo(Val{:bar})&lt;/code&gt;.</source>
          <target state="translated">Для единообразия в Julia сайт вызова всегда должен передавать &lt;em&gt;экземпляр &lt;/em&gt; &lt;code&gt;Val&lt;/code&gt; , а не использовать &lt;em&gt;тип&lt;/em&gt; , то есть использовать &lt;code&gt;foo(Val(:bar))&lt;/code&gt; вместо &lt;code&gt;foo(Val{:bar})&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d9ce2fe390265769939ee6ced6c2028220d4701" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Для удобства &lt;code&gt;p&lt;/code&gt; может быть типом вместо значения: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; - это сокращение для &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89f749ab9e4eefe9228d7474faa98982038d612a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Для удобства &lt;code&gt;p&lt;/code&gt; может быть типом вместо значения: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; - это ярлык для &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba5445c2e02b549b16ba3decf8b6cd4aeb77578a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Для удобства &lt;code&gt;p&lt;/code&gt; может быть типом вместо значения: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; - это сокращение для &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="628a74984a13bf54fa3097a1ff489c44e499c284" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Для удобства &lt;code&gt;precision&lt;/code&gt; может быть типом, а не значением: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; - это сокращение для &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f856c7ece595cf56ae5fb16a5157cda0b0b39e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Для удобства &lt;code&gt;precision&lt;/code&gt; может быть типом, а не значением: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; - это ярлык для &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="752ad3a1bbf71154ca789079220fccfae5f42c78" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Для удобства &lt;code&gt;precision&lt;/code&gt; может быть типом, а не значением: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; - это сокращение для &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f72febf4d9dbc862197cbb1a8b226080ce81a9b0" translate="yes" xml:space="preserve">
          <source>For custom matrix and vector types, it is recommended to implement 5-argument &lt;code&gt;mul!&lt;/code&gt; rather than implementing 3-argument &lt;code&gt;mul!&lt;/code&gt; directly if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337e0be4946ed3262678abe0f2e935f04104f98b" translate="yes" xml:space="preserve">
          <source>For direct C++ interfacing, see the &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; package. For tools to create C++ bindings, see the &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; package.</source>
          <target state="translated">Для прямого взаимодействия с C ++ см. Пакет &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; . Инструменты для создания привязок C ++ см. &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;В&lt;/a&gt; пакете CxxWrap .</target>
        </trans-unit>
        <trans-unit id="1e618742c8a5d9129a1258dfbf5438a2e4a87773" translate="yes" xml:space="preserve">
          <source>For each pair &lt;code&gt;old=&amp;gt;new&lt;/code&gt; in &lt;code&gt;old_new&lt;/code&gt;, replace all occurrences of &lt;code&gt;old&lt;/code&gt; in collection &lt;code&gt;A&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt;. Equality is determined using &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;count&lt;/code&gt; is specified, then replace at most &lt;code&gt;count&lt;/code&gt; occurrences in total. See also &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для каждой пары &lt;code&gt;old=&amp;gt;new&lt;/code&gt; в &lt;code&gt;old_new&lt;/code&gt; замените все вхождения &lt;code&gt;old&lt;/code&gt; в коллекции &lt;code&gt;A&lt;/code&gt; на &lt;code&gt;new&lt;/code&gt; . Равенство определяется с помощью &lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;count&lt;/code&gt; задан, то замените в большинстве &lt;code&gt;count&lt;/code&gt; вхождений в общей сложности. См. Также &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd384e9075d866940b3029eb6057da7ada0b04b" translate="yes" xml:space="preserve">
          <source>For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.</source>
          <target state="translated">Для удобства понимания в примерах,приведенных в этой главе,показаны полные структуры данных для корней,графиков и путей.Однако,код загрузки пакетов Джулии не создает их явно.Вместо этого,он лениво вычисляет только столько структур,сколько необходимо для загрузки данного пакета.</target>
        </trans-unit>
        <trans-unit id="04e18da25adbbde93578f1eb2fa5f41635ed03eb" translate="yes" xml:space="preserve">
          <source>For empty collections, providing &lt;code&gt;init&lt;/code&gt; will be necessary, except for some special cases (e.g. when &lt;code&gt;op&lt;/code&gt; is one of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) when Julia can determine the neutral element of &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">Для пустых коллекций предоставление &lt;code&gt;init&lt;/code&gt; будет необходимо, за исключением некоторых особых случаев (например, когда &lt;code&gt;op&lt;/code&gt; является одним из &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ), когда Джулия может определить нейтральный элемент &lt;code&gt;op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7a1238b1ac319ac9db6a4c619c8de57eb47bad" translate="yes" xml:space="preserve">
          <source>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;collected writings&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;William Kahan&lt;/a&gt;, commonly known as the &quot;Father of Floating-Point&quot;. Of particular interest may be &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;An Interview with the Old Man of Floating-Point&lt;/a&gt;.</source>
          <target state="translated">Для еще более обширной документации , истории, обоснование, а также вопросы с числами с плавающей точкой, а также обсуждение многих других тем , в численных вычислений, см &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;собраны труды&lt;/a&gt; по &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;Кэхэн&lt;/a&gt; , широко известный как &amp;laquo;Отец с плавающей Точка&amp;raquo;. Особый интерес может представлять &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;&amp;laquo;Интервью со Стариком Плавающей точки&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b77b25aae44912586606895a221d1e45b8c25f37" translate="yes" xml:space="preserve">
          <source>For every incoming logical connection with a worker, &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the &lt;code&gt;IO&lt;/code&gt; objects.</source>
          <target state="translated">Для каждого входящего логического соединения с &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; . Это запускает новую задачу, которая обрабатывает чтение и запись сообщений от / к работнику, представленному объектами &lt;code&gt;IO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b85b3e1a00e44270cd850d12b0754ab94e579430" translate="yes" xml:space="preserve">
          <source>For every worker launched, the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method must add a &lt;code&gt;WorkerConfig&lt;/code&gt; object (with appropriate fields initialized) to &lt;code&gt;launched&lt;/code&gt;</source>
          <target state="translated">Для каждого запущенного &lt;code&gt;WorkerConfig&lt;/code&gt; метод &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; должен добавить объект WorkerConfig (с соответствующими инициализированными полями) в &lt;code&gt;launched&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c1669fdd5a30442a1d111e532e0e0ca62fed47" translate="yes" xml:space="preserve">
          <source>For example in order to fix &lt;code&gt;findfirst&lt;/code&gt; example above one needs to have a separate copy of &lt;code&gt;rx&lt;/code&gt; variable for each thread:</source>
          <target state="translated">Например, чтобы исправить &lt;code&gt;findfirst&lt;/code&gt; выше пример findfirst, необходимо иметь отдельную копию переменной &lt;code&gt;rx&lt;/code&gt; для каждого потока:</target>
        </trans-unit>
        <trans-unit id="08186eb20e073535d04d3ee1bc374db09694e868" translate="yes" xml:space="preserve">
          <source>For example in the following docstring a variable &lt;code&gt;a&lt;/code&gt; is defined and the expected result, as printed in a Julia REPL, appears afterwards:</source>
          <target state="translated">Например, в следующей строке документации определяется переменная &lt;code&gt;a&lt;/code&gt; , и ожидаемый результат, напечатанный в Julia REPL, появляется после:</target>
        </trans-unit>
        <trans-unit id="b50ac335cd803909aabb34c2ac8aa635fe70764b" translate="yes" xml:space="preserve">
          <source>For example you should write</source>
          <target state="translated">Например,вы должны написать</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="d30d6b6735d4ff4914afad9079e3d2da944acfc0" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; will evaluate &lt;code&gt;Sys.iswindows()&lt;/code&gt; and insert either &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt; into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a &lt;code&gt;ccall&lt;/code&gt; to a non-existent function. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; and &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; are also valid syntax.</source>
          <target state="translated">Например, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; вычислит &lt;code&gt;Sys.iswindows()&lt;/code&gt; и вставит в выражение либо &lt;code&gt;foo&lt;/code&gt; , либо &lt;code&gt;bar&lt;/code&gt; . Это полезно в тех случаях, когда конструкция будет недействительной на других платформах, например, &lt;code&gt;ccall&lt;/code&gt; несуществующей функции. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; и &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; также являются допустимым синтаксисом.</target>
        </trans-unit>
        <trans-unit id="ebd8456aa0b38dfe42ed79277e4c1654dd3d60d1" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10 on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; вернет ссылку на канал типа &lt;code&gt;Int&lt;/code&gt; и размера 10 в &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96ff3ffca8d84a68fdc5320415ea0dc59a9a8872" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10. The channel exists on worker &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; вернет ссылку на канал типа &lt;code&gt;Int&lt;/code&gt; и размера 10. Канал существует на рабочем &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4891a83f30d6618f43c5e0d97b64d34ca2b73c56" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; returns an uninitialized &lt;code&gt;Array{Int,2}&lt;/code&gt; since ranges are neither mutable nor support 2 dimensions:</source>
          <target state="translated">Например, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; возвращает неинициализированный &lt;code&gt;Array{Int,2}&lt;/code&gt; поскольку диапазоны не изменяемы и не поддерживают 2 измерения:</target>
        </trans-unit>
        <trans-unit id="9440a60be9ec094e973482fb911a180f54e935ef" translate="yes" xml:space="preserve">
          <source>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package &lt;code&gt;ClusterManagers.jl&lt;/code&gt;.</source>
          <target state="translated">Например, кластеры Beowulf поддерживаются с помощью настраиваемого диспетчера кластеров, реализованного в пакете &lt;code&gt;ClusterManagers.jl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c68e3216a6f7acab7967abd7cf08e2c4de403780" translate="yes" xml:space="preserve">
          <source>For example, NFKC corresponds to the options &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt;.</source>
          <target state="translated">Например, NFKC соответствует параметрам &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4599895ae8d119fa4cbac0f0c56af45c7eba0c70" translate="yes" xml:space="preserve">
          <source>For example, a Linux installation with a Julia executable located at &lt;code&gt;/bin/julia&lt;/code&gt;, a &lt;code&gt;DATAROOTDIR&lt;/code&gt; of &lt;code&gt;../share&lt;/code&gt;, and a &lt;code&gt;SYSCONFDIR&lt;/code&gt; of &lt;code&gt;../etc&lt;/code&gt; will have &lt;code&gt;JULIA_BINDIR&lt;/code&gt; set to &lt;code&gt;/bin&lt;/code&gt;, a source-file search path of</source>
          <target state="translated">Например, установка Linux с Джулией исполняемым находится в &lt;code&gt;/bin/julia&lt;/code&gt; , в &lt;code&gt;DATAROOTDIR&lt;/code&gt; из &lt;code&gt;../share&lt;/code&gt; и &lt;code&gt;SYSCONFDIR&lt;/code&gt; из &lt;code&gt;../etc&lt;/code&gt; будет иметь &lt;code&gt;JULIA_BINDIR&lt;/code&gt; набор в &lt;code&gt;/bin&lt;/code&gt; , поиск исходного файла путь</target>
        </trans-unit>
        <trans-unit id="cb227b31f00d820f5d9d05405c8ad07604ce912a" translate="yes" xml:space="preserve">
          <source>For example, a recursive factorial routine could be defined like this:</source>
          <target state="translated">Например,можно определить рекурсивный факториал:</target>
        </trans-unit>
        <trans-unit id="a3ee27750c0b683e5c90895147928cfd59e22a42" translate="yes" xml:space="preserve">
          <source>For example, consider a function &lt;code&gt;plot&lt;/code&gt; that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</source>
          <target state="translated">Например, рассмотрим &lt;code&gt;plot&lt;/code&gt; функции, который строит линию. Эта функция может иметь множество опций для управления стилем линии, шириной, цветом и так далее. Если он принимает аргументы ключевого слова, возможный вызов может выглядеть как &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; , где мы решили указать только ширину линии. Обратите внимание, что это служит двум целям. Вызов легче читать, поскольку мы можем обозначить аргумент его значением. Также становится возможным передавать любое подмножество большого количества аргументов в любом порядке.</target>
        </trans-unit>
        <trans-unit id="02796f85acf393569f8f018e6f896c1698a7ba0c" translate="yes" xml:space="preserve">
          <source>For example, consider the following definitions of a function &lt;code&gt;addone&lt;/code&gt; that returns one plus its argument:</source>
          <target state="translated">Например, рассмотрим следующие определения функции &lt;code&gt;addone&lt;/code&gt; , которая возвращает единицу плюс ее аргумент:</target>
        </trans-unit>
        <trans-unit id="8379ff1b045b6b8381b0fc1dcbd698daf2ddf0cf" translate="yes" xml:space="preserve">
          <source>For example, here is how we can guarantee that an opened file is closed:</source>
          <target state="translated">Например,вот как мы можем гарантировать,что открытый файл будет закрыт:</target>
        </trans-unit>
        <trans-unit id="4559e10e5bdf85aaaa91ac7c4619e47af5636653" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;x&lt;/code&gt; is an array and &lt;code&gt;v = @view x[1:10]&lt;/code&gt;, then &lt;code&gt;v&lt;/code&gt; acts like a 10-element array, but its data is actually accessing the first 10 elements of &lt;code&gt;x&lt;/code&gt;. Writing to a view, e.g. &lt;code&gt;v[3] = 2&lt;/code&gt;, writes directly to the underlying array &lt;code&gt;x&lt;/code&gt; (in this case modifying &lt;code&gt;x[3]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49582067d66dec7b465ad077603d8140735bdbe0" translate="yes" xml:space="preserve">
          <source>For example, if you define a &lt;code&gt;MyImage&lt;/code&gt; type and know how to write it to a PNG file, you could define a function &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; to allow your images to be displayed on any PNG-capable &lt;code&gt;AbstractDisplay&lt;/code&gt; (such as IJulia). As usual, be sure to &lt;code&gt;import Base.show&lt;/code&gt; in order to add new methods to the built-in Julia function &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">Например, если вы определяете тип &lt;code&gt;MyImage&lt;/code&gt; и знаете, как записать его в файл PNG, вы можете определить функцию &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; чтобы позволить вашему изображения для отображения на любом &lt;code&gt;AbstractDisplay&lt;/code&gt; дисплее с поддержкой PNG (таком как IJulia). Как обычно, обязательно &lt;code&gt;import Base.show&lt;/code&gt; , чтобы добавить новые методы во встроенную функцию Julia &lt;code&gt;show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2da1e2276f1c5c558883dab8cb5596d1bc2a1628" translate="yes" xml:space="preserve">
          <source>For example, say we define a type that stores a vector along with an accurate representation of its sum:</source>
          <target state="translated">Допустим,мы определяем тип,который хранит вектор вместе с точным представлением его суммы:</target>
        </trans-unit>
        <trans-unit id="e2cfd2a7e3ca6e4481d092c3fbc0442d5a4ab757" translate="yes" xml:space="preserve">
          <source>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</source>
          <target state="translated">Например,предположим,что хочется объявить тип,содержащий пару вещественных чисел,при условии ограничения,что первое число не больше второго.Можно объявить так:</target>
        </trans-unit>
        <trans-unit id="79225a639e81658b4de8b5567b3dea63ac5abb4f" translate="yes" xml:space="preserve">
          <source>For example, suppose we want to check our new function &lt;code&gt;foo(x)&lt;/code&gt; works as expected:</source>
          <target state="translated">Например, предположим, что мы хотим проверить, что наша новая функция &lt;code&gt;foo(x)&lt;/code&gt; работает должным образом:</target>
        </trans-unit>
        <trans-unit id="7eda6e477d1dd1d46e2cafc4f54477c6b2bb0e6a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; functions can be composed like this:</source>
          <target state="translated">Например, функции &lt;code&gt;sqrt&lt;/code&gt; и &lt;code&gt;+&lt;/code&gt; могут быть составлены следующим образом:</target>
        </trans-unit>
        <trans-unit id="5ae23a1c15837ee5f1ee5c9f54f1ec5adaf7300a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; function throws a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if applied to a negative real value:</source>
          <target state="translated">Например, функция &lt;code&gt;sqrt&lt;/code&gt; выдает &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; если применяется к отрицательному действительному значению:</target>
        </trans-unit>
        <trans-unit id="41fbcb24e42e9f837587084b7759fc106d92d27c" translate="yes" xml:space="preserve">
          <source>For example, the following code</source>
          <target state="translated">Например,следующий код</target>
        </trans-unit>
        <trans-unit id="df53f88b87089b5c188eb151fc2371ed97e5a8bd" translate="yes" xml:space="preserve">
          <source>For example, the following code will not work as intended:</source>
          <target state="translated">Например,следующий код будет работать не так,как предполагалось:</target>
        </trans-unit>
        <trans-unit id="dd2a7ac9bf39edcb33138e7083aee6d2163bed39" translate="yes" xml:space="preserve">
          <source>For example, the following definition supports the negation of ranges:</source>
          <target state="translated">Например,следующее определение поддерживает отрицание диапазонов:</target>
        </trans-unit>
        <trans-unit id="ebd9e6f4328ccf3da34436709427cc4b4eaab0c0" translate="yes" xml:space="preserve">
          <source>For example, the following regex has all three flags turned on:</source>
          <target state="translated">Например,в следующем регексе включены все три флага:</target>
        </trans-unit>
        <trans-unit id="f984e5cb891417962d09962040b3dc32bb1ac27e" translate="yes" xml:space="preserve">
          <source>For example, the following would cause the &lt;code&gt;for&lt;/code&gt; loop to wait for more data:</source>
          <target state="translated">Например, следующее приведет к тому, что цикл &lt;code&gt;for&lt;/code&gt; будет ждать дополнительных данных:</target>
        </trans-unit>
        <trans-unit id="eecf63c1cc24adb010e598c33c14402e51c960fb" translate="yes" xml:space="preserve">
          <source>For example, the tuple &lt;code&gt;(a=3.1, b=&quot;hello&quot;)&lt;/code&gt; has a type &lt;code&gt;NamedTuple{(:a, :b),Tuple{Float64,String}}&lt;/code&gt;, which can also be declared via &lt;code&gt;@NamedTuple&lt;/code&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ca40c2a3ba9787690378fb5f2aab689eee1052" translate="yes" xml:space="preserve">
          <source>For example, to read a simple byte array, we could do:</source>
          <target state="translated">Например,для чтения простого массива байт можно сделать:</target>
        </trans-unit>
        <trans-unit id="8878c21d4c3068d1cd94e841b14239269912a492" translate="yes" xml:space="preserve">
          <source>For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:</source>
          <target state="translated">Например,попытка диспетчеризации по элементипу массива часто приводит к неоднозначным ситуациям.Вместо этого,обычно код будет посылать сначала по типу контейнера,а затем возвращаться к более специфическому методу,основанному на el типе.В большинстве случаев алгоритмы удобно поддаются такому иерархическому подходу,в то время как в других случаях эта строгость должна быть устранена вручную.Такое диспетчерское разветвление можно наблюдать,например,в логике суммирования двух матриц:</target>
        </trans-unit>
        <trans-unit id="b2c13e0b4d2254aa0c6b075c4f699f03e1e4085d" translate="yes" xml:space="preserve">
          <source>For example, two vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of the same length can be written as two columns of tab-delimited text to &lt;code&gt;f&lt;/code&gt; by either &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; or by &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">Например, два вектора &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; одинаковой длины могут быть записаны как два столбца текста с разделителями табуляции в &lt;code&gt;f&lt;/code&gt; либо с помощью &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; либо с помощью &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b7a39286391fad09a5ff705ae3bda829227952" translate="yes" xml:space="preserve">
          <source>For example, when reading all of the output from a command, call &lt;code&gt;read(out, String)&lt;/code&gt;, not &lt;code&gt;wait(process)&lt;/code&gt;, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for a reader to be connected.</source>
          <target state="translated">Например, при чтении всего вывода команды вызовите &lt;code&gt;read(out, String)&lt;/code&gt; , а не &lt;code&gt;wait(process)&lt;/code&gt; , поскольку первый будет активно потреблять все данные, записанные процессом, тогда как последний попытается сохранить данные в буферах ядра в ожидании подключения считывателя.</target>
        </trans-unit>
        <trans-unit id="5029745bd6486130a24ba078811879e64132c558" translate="yes" xml:space="preserve">
          <source>For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</source>
          <target state="translated">Например,можно определить тип,который хранит коэффициенты многочлена,но ведет себя как функция,оценивающая многочлен:</target>
        </trans-unit>
        <trans-unit id="67f058df3da112643c2b0a1dfa02199be4e0057b" translate="yes" xml:space="preserve">
          <source>For example, you might look up the function via &lt;code&gt;dlsym&lt;/code&gt;, then cache it in a shared reference for that session. For example:</source>
          <target state="translated">Например, вы можете найти функцию через &lt;code&gt;dlsym&lt;/code&gt; , а затем кэшировать ее в общей ссылке для этого сеанса. Например:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="77957bacdf57512b4372bd5a4e3fd7ed75c7e36e" translate="yes" xml:space="preserve">
          <source>For expert drivers and additional information, see &lt;code&gt;permute!&lt;/code&gt;.</source>
          <target state="translated">Для опытных водителей и дополнительной информации см. &lt;code&gt;permute!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="023517bc66d9d3e180b498d61c21e401d08d2db9" translate="yes" xml:space="preserve">
          <source>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by &lt;code&gt;include&lt;/code&gt; or added explicitly by &lt;code&gt;include_dependency&lt;/code&gt; is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in &lt;code&gt;require&lt;/code&gt; matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</source>
          <target state="translated">Для файловых зависимостей изменение определяется путем проверки того, является ли время модификации (mtime) каждого файла, загруженного с помощью &lt;code&gt;include&lt;/code&gt; или явно добавленного с помощью &lt;code&gt;include_dependency&lt;/code&gt; , неизменным или равно времени модификации, усеченному до ближайшей секунды (для размещения систем, которые не могут копировать mtime с точностью до секунды). Также учитывается, соответствует ли путь к файлу, выбранному логикой поиска в &lt;code&gt;require&lt;/code&gt; , пути, по которому был создан файл предварительной компиляции. Он также принимает во внимание набор зависимостей, уже загруженных в текущий процесс, и не будет перекомпилировать эти модули, даже если их файлы изменятся или исчезнут, чтобы избежать несовместимости между работающей системой и кешем предварительной компиляции.</target>
        </trans-unit>
        <trans-unit id="66dd55e20f602bb211d9c7813d2f9f0ed6928fe9" translate="yes" xml:space="preserve">
          <source>For fixed-size integer types less than 128 bits, &lt;code&gt;widen&lt;/code&gt; will return a type with twice the number of bits.</source>
          <target state="translated">Для целочисленных типов фиксированного размера менее 128 бит &lt;code&gt;widen&lt;/code&gt; вернет тип с удвоенным количеством бит.</target>
        </trans-unit>
        <trans-unit id="b4ff71b16e3ea299f0633e174809e0487289b907" translate="yes" xml:space="preserve">
          <source>For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517d5d95b2398e36f4828f9d104f02ccf187deee" translate="yes" xml:space="preserve">
          <source>For functions &lt;code&gt;f(x)&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; defines a new function constant &lt;code&gt;f&lt;/code&gt;, or adds a new method to &lt;code&gt;f&lt;/code&gt; if &lt;code&gt;f&lt;/code&gt; is already defined; this usage is equivalent to &lt;code&gt;function f(x); x; end&lt;/code&gt;.</source>
          <target state="translated">Для функций &lt;code&gt;f(x)&lt;/code&gt; , &lt;code&gt;f(x) = x&lt;/code&gt; определяет новую функциональную константу &lt;code&gt;f&lt;/code&gt; или добавляет новый метод к &lt;code&gt;f&lt;/code&gt; , если &lt;code&gt;f&lt;/code&gt; уже определен; это использование эквивалентно &lt;code&gt;function f(x); x; end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="225c4a50cda420749e1622d47819d81476ffb811" translate="yes" xml:space="preserve">
          <source>For functions that do not need to return a value (functions used only for some side effects), the Julia convention is to return the value &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6abe0e3a65b8ed9f51c340da311967dd300c9c" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw add&lt;/code&gt; instruction.</source>
          <target state="translated">Дополнительные сведения см. В инструкции LLVM &lt;code&gt;atomicrmw add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0322dcf17161d23047710cc59f3f8e235c18a53" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw and&lt;/code&gt; instruction.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;code&gt;atomicrmw and&lt;/code&gt; инструкцию LLVM .</target>
        </trans-unit>
        <trans-unit id="e5b561d9fc0067e467e9e9fcee46e3023283cf28" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw max&lt;/code&gt; instruction.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;code&gt;atomicrmw max&lt;/code&gt; LLVM .</target>
        </trans-unit>
        <trans-unit id="eab5683b8c3c9bc6117f8a69b4da87aa9632a8fb" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw min&lt;/code&gt; instruction.</source>
          <target state="translated">Дополнительные сведения см. В инструкции LLVM &lt;code&gt;atomicrmw min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b7e08b7890af600321c511f13a806cd3559bcfa" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw nand&lt;/code&gt; instruction.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;code&gt;atomicrmw nand&lt;/code&gt; LLVM .</target>
        </trans-unit>
        <trans-unit id="7b8dd1c376a179e2ba56074f5563e776f17ef9ec" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw or&lt;/code&gt; instruction.</source>
          <target state="translated">Для получения дополнительных сведений см. &lt;code&gt;atomicrmw or&lt;/code&gt; инструкцию LLVM .</target>
        </trans-unit>
        <trans-unit id="48c1004b7dffe90355657654366824768f35001b" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw sub&lt;/code&gt; instruction.</source>
          <target state="translated">Дополнительные сведения см. В &lt;code&gt;atomicrmw sub&lt;/code&gt; инструкции atomicrmw LLVM .</target>
        </trans-unit>
        <trans-unit id="192e95dde72a6e68d2db267b6ee138cf37555d73" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xchg&lt;/code&gt; instruction.</source>
          <target state="translated">Дополнительные сведения см. В инструкции LLVM &lt;code&gt;atomicrmw xchg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e4b67df501ae8428fb22d5e33af878bfbea1ef9" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xor&lt;/code&gt; instruction.</source>
          <target state="translated">Дополнительные сведения см. В инструкции LLVM &lt;code&gt;atomicrmw xor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ee314d2ce6ee192109b08f74bbfd48cbb0e5cbc" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;cmpxchg&lt;/code&gt; instruction.</source>
          <target state="translated">Для получения дополнительных сведений см. Инструкцию &lt;code&gt;cmpxchg&lt;/code&gt; LLVM .</target>
        </trans-unit>
        <trans-unit id="a7755edb4519e4536a6271c13a954434e48a3388" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;fence&lt;/code&gt; instruction.</source>
          <target state="translated">Дополнительные сведения см. В инструкции по &lt;code&gt;fence&lt;/code&gt; LLVM .</target>
        </trans-unit>
        <trans-unit id="25a5b4ba8ce7a92e22ffc818fd949e445709bd1e" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592e1ef0cc917b2ef533393d9872f216dc5c373c" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="translated">Для дальнейшего обсуждения того, как эти неконечные значения с плавающей запятой упорядочены относительно друг друга и других чисел с плавающей запятой, см. &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Числовые сравнения&lt;/a&gt; . По &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;стандарту IEEE 754&lt;/a&gt; эти значения с плавающей запятой являются результатами определенных арифметических операций:</target>
        </trans-unit>
        <trans-unit id="f6a5e306e2388b19948e17b05f28ec9cf0f8d86c" translate="yes" xml:space="preserve">
          <source>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The &lt;code&gt;permute&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt;, and &lt;code&gt;sortby&lt;/code&gt; keywords are the same as for &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для обычных несимметричных матриц можно указать, как матрица сбалансирована перед вычислением собственного значения. В &lt;code&gt;permute&lt;/code&gt; , &lt;code&gt;scale&lt;/code&gt; и &lt;code&gt;sortby&lt;/code&gt; ключевых слов такого же , как для &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="2a3464000c64f9602c239ac8ef54cb51f0375c94" translate="yes" xml:space="preserve">
          <source>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option &lt;code&gt;permute=true&lt;/code&gt; permutes the matrix to become closer to upper triangular, and &lt;code&gt;scale=true&lt;/code&gt; scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is &lt;code&gt;true&lt;/code&gt; for both options.</source>
          <target state="translated">Для обычных несимметричных матриц можно указать, как матрица сбалансирована до вычисления собственного вектора. Параметр &lt;code&gt;permute=true&lt;/code&gt; переставляет матрицу, чтобы она стала ближе к верхнему треугольнику, а &lt;code&gt;scale=true&lt;/code&gt; масштабирует матрицу по ее диагональным элементам, чтобы сделать строки и столбцы более равными по норме. Значение по умолчанию &lt;code&gt;true&lt;/code&gt; для обоих вариантов.</target>
        </trans-unit>
        <trans-unit id="97272f75bb7bf420f1c0e8253e48bdca2d0549a3" translate="yes" xml:space="preserve">
          <source>For general square matrices, &lt;code&gt;A = A*B&lt;/code&gt; cannot be implemented without temporary storage: &lt;code&gt;A[1,1]&lt;/code&gt; gets computed and stored on the left hand side before you're done using it on the right hand side.</source>
          <target state="translated">Для обычных квадратных матриц &lt;code&gt;A = A*B&lt;/code&gt; не может быть реализовано без временного хранилища: &lt;code&gt;A[1,1]&lt;/code&gt; вычисляется и сохраняется в левой части, прежде чем вы закончите использовать его в правой части.</target>
        </trans-unit>
        <trans-unit id="935a8c2e4f251a5770a2bb608ecff08833dd9c32" translate="yes" xml:space="preserve">
          <source>For global variables, only the bindings are captured in a closure, not the data. &lt;code&gt;let&lt;/code&gt; blocks can be used to capture global data.</source>
          <target state="translated">Для глобальных переменных в замыкании фиксируются только привязки, но не данные. Блоки &lt;code&gt;let&lt;/code&gt; могут использоваться для сбора глобальных данных.</target>
        </trans-unit>
        <trans-unit id="e5b2b73939c9dca143b01d277fa950512fdcf9e4" translate="yes" xml:space="preserve">
          <source>For implementing primitive operations, such as addition, we use the &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt; function to compute the desired output type. (As before, we saw this at work in the &lt;code&gt;promote&lt;/code&gt; call in the call to &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">Для реализации примитивных операций, таких как сложение, мы используем функцию &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; для вычисления желаемого типа вывода. (Как и раньше, мы видели это в &lt;code&gt;promote&lt;/code&gt; при обращении к &lt;code&gt;+&lt;/code&gt; при обращении к + ).</target>
        </trans-unit>
        <trans-unit id="9bbc05f37cbd2b5498a3ab3a593a156112a8c55d" translate="yes" xml:space="preserve">
          <source>For instance, consider this C routine that uses AVX intrinsics:</source>
          <target state="translated">Например,рассмотрим эту рутину C,использующую встроенные средства AVX:</target>
        </trans-unit>
        <trans-unit id="58f3adf26ef93227d12186ad90763f386c1243e3" translate="yes" xml:space="preserve">
          <source>For inverting dense ill-conditioned matrices in a least-squares sense, &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; is recommended.</source>
          <target state="translated">Для инвертирования плотных плохо обусловленных матриц методом наименьших квадратов &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="034287249fc47e9292b9e290930968170dd861cb" translate="yes" xml:space="preserve">
          <source>For long docstrings, consider splitting the documentation with an &lt;code&gt;# Extended help&lt;/code&gt; header. The typical help-mode will show only the material above the header; you can access the full help by adding a '?' at the beginning of the expression (i.e., &quot;??foo&quot; rather than &quot;?foo&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3476b291492f6f31f8c69709d348f023db79ecb7" translate="yes" xml:space="preserve">
          <source>For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for &lt;em&gt;dynamic scheduling&lt;/em&gt;. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.</source>
          <target state="translated">Для многих проблем не нужно думать о задачах напрямую. Однако их можно использовать для ожидания нескольких событий одновременно, что обеспечивает &lt;em&gt;динамическое планирование&lt;/em&gt; . При динамическом планировании программа решает, что вычислять или где вычислять, в зависимости от того, когда завершатся другие задания. Это необходимо для непредсказуемых или несбалансированных рабочих нагрузок, когда мы хотим назначить больше работы процессам, только когда они завершат свои текущие задачи.</target>
        </trans-unit>
        <trans-unit id="7f0ae2a2524af9d24fc01426df34e4e2c47f07b3" translate="yes" xml:space="preserve">
          <source>For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Recursive data structures&lt;/a&gt;, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.</source>
          <target state="translated">Для многих типов формирование новых объектов путем связывания значений их полей - это все, что когда-либо требовалось для создания экземпляров. Однако в некоторых случаях при создании составных объектов требуется больше функциональных возможностей. Иногда инварианты необходимо принудительно применять либо путем проверки аргументов, либо путем их преобразования. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Рекурсивные структуры данных&lt;/a&gt; , особенно те, которые могут быть самореферентными, часто не могут быть созданы чисто, если сначала они не будут созданы в неполном состоянии, а затем программно изменены, чтобы сделать их единым целым, как отдельный шаг от создания объекта. Иногда просто удобно иметь возможность создавать объекты с меньшим количеством параметров или с другими типами параметров, чем у них есть поля. Система Джулии для построения объектов учитывает все эти и многие другие случаи.</target>
        </trans-unit>
        <trans-unit id="c3ab9fc4f4873966145fee9c6ac1a9124f310742" translate="yes" xml:space="preserve">
          <source>For matrices &lt;code&gt;M&lt;/code&gt; with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is the largest singular value of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Для матрицы &lt;code&gt;M&lt;/code&gt; с плавающей точкой элементов, то удобно , чтобы вычислить Псевдообращение инвертирования только особых значений больше , чем &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; , где &lt;code&gt;&amp;sigma;₁&lt;/code&gt; является самым большим сингулярным значением &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac6da235d612ded03083200d47fe1ab7d98c9b79" translate="yes" xml:space="preserve">
          <source>For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:</source>
          <target state="translated">Для более сложных функций на матрицах может потребоваться вычислить ожидаемый тип возврата для более сложной последовательности операций.Часто это выполняется следующими шагами:</target>
        </trans-unit>
        <trans-unit id="4017330d0c6b8db2f9072cd10c06aafbef3ef320" translate="yes" xml:space="preserve">
          <source>For more details on how to pass callbacks to C libraries, see this &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о том, как передавать обратные вызовы библиотекам C, см. В этом &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;сообщении в блоге&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40c80b687e747654f0a96421e3edca10bc4facd7" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/distributed-computing/index#code-availability&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e7422368e9880e43d73e7cf711179bdaf3a6a3" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о загрузке кода см. В разделах руководства по &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;модулям&lt;/a&gt; и &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;параллельным вычислениям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b74d22bb6d8c3dae54e22351d507e76018a8637" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f5736599d7832ed10460cda99264a6faea4e6" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о стилистических соглашениях см. В &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Руководстве&lt;/a&gt; по стилю .</target>
        </trans-unit>
        <trans-unit id="29a5a734cc9600ff863c3e949c6ca0cd3d61e836" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM Language Reference&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;Справочник по языку LLVM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d81fc78cdce363d7f10d30a8aad51f62ffcf7c5d" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM Language Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94367c7326944c925932ccd75ddf09b0dc2a2ca" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;, &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;, &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;, &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;#footnote-issue8859&quot;&gt;[Issue8859]&lt;/a&gt; , &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt; , &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt; , &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1043bbca3d9cff9872a90536395e252c63759842" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;sup&gt;&lt;a href=&quot;#footnote-issue8859&quot; id=&quot;citeref-issue8859&quot;&gt;[issue8859]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-B96&quot; id=&quot;citeref-B96&quot;&gt;[B96]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-S84&quot; id=&quot;citeref-S84&quot;&gt;[S84]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-KY88&quot; id=&quot;citeref-KY88&quot;&gt;[KY88]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c9da6d7f9a8088ccb6c5228fbbc41a8fd90ece" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="translated">Для более серьезного тестирования рассмотрим пакет &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; , который, помимо прочего, многократно оценивает функцию, чтобы уменьшить шум.</target>
        </trans-unit>
        <trans-unit id="7fb3b51ac0a69c0826f2ccf53c628c34678a1b75" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;code&gt;@btime&lt;/code&gt; macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88557b99f2da7edd1312dcf73383bf3fd839d0cf" translate="yes" xml:space="preserve">
          <source>For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</source>
          <target state="translated">Для большинства пользовательских типов лучше требовать от программистов явного предоставления ожидаемых типов для построения функций,но иногда,особенно для числовых задач,удобно делать продвижение автоматически.</target>
        </trans-unit>
        <trans-unit id="ceb4f91d41747de4680e86cde1985bd3bfc38e4e" translate="yes" xml:space="preserve">
          <source>For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">Для нескольких аргументов коллекции примените &lt;code&gt;f&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="ea75a21c84d373ef04e66eb8c0a6a1bc5cc64258" translate="yes" xml:space="preserve">
          <source>For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by Julia. We can divide them in three main categories :</source>
          <target state="translated">Новичкам в многопоточном и параллельном вычислении может быть полезно сначала оценить различные уровни параллелизма,предлагаемые Джулией.Их можно разделить на три основные категории:</target>
        </trans-unit>
        <trans-unit id="ac8a874fecbfe223b7adee365914ddd8f5f53622" translate="yes" xml:space="preserve">
          <source>For non-numeric values, and for fewer or more than two arguments, the function &lt;code&gt;f&lt;/code&gt; remains undefined, and applying it will still result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Для нечисловых значений и для меньшего или большего количества аргументов функция &lt;code&gt;f&lt;/code&gt; остается неопределенной, и ее применение все равно приведет к &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c60cf4f6c963a7be1f2993b69f713f92f6b5f1c8" translate="yes" xml:space="preserve">
          <source>For number types, &lt;code&gt;adjoint&lt;/code&gt; returns the complex conjugate, and therefore it is equivalent to the identity function for real numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235d743e9d754b970eea4778b2f329bcad575d20" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$.</source>
          <target state="translated">Для чисел возвращаем $\left(|x|^p \right)^{1/p}$.</target>
        </trans-unit>
        <trans-unit id="00b6eae180d5b268722ff406a9cc534055692e79" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$. This is equivalent to &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для чисел верните $ \ left (| x | ^ p \ right) ^ {1 / p} $. Это эквивалентно &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f585a8f761ded66238973d0a20da01f3603d93" translate="yes" xml:space="preserve">
          <source>For one argument, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (1, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi/2, \pi/2]$.</source>
          <target state="translated">Для одного аргумента это угол в радианах между положительной осью &lt;em&gt;x&lt;/em&gt; и точкой (1, &lt;em&gt;y&lt;/em&gt; ), возвращающий значение в интервале $ [- \ pi / 2, \ pi / 2] $.</target>
        </trans-unit>
        <trans-unit id="cbe3a2c9ed0456d9a3ed109f08314c90a9a6e71e" translate="yes" xml:space="preserve">
          <source>For other types, &lt;code&gt;isequal&lt;/code&gt; defaults to calling &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, so if you want to define equality for your own types then you only need to add a &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; method. If you define your own equality function, you should probably define a corresponding &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; method to ensure that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">Для других типов &lt;code&gt;isequal&lt;/code&gt; по умолчанию вызывает &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; , поэтому, если вы хотите определить равенство для своих собственных типов, вам нужно только добавить метод &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; . Если вы определяете свою собственную функцию равенства, вам, вероятно, следует определить соответствующий метод &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; чтобы гарантировать, что &lt;code&gt;isequal(x,y)&lt;/code&gt; подразумевает &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b291b40e0be0bd452d639b38ca79aedde9913f1" translate="yes" xml:space="preserve">
          <source>For outputting hours with 12-hour clock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2f4b9050307c80e2b4e5b109845a6af03029a8" translate="yes" xml:space="preserve">
          <source>For real or complex floating-point values, if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is not specified, &lt;code&gt;rtol&lt;/code&gt; defaults to the square root of &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the type of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is supplied, &lt;code&gt;rtol&lt;/code&gt; defaults to zero.</source>
          <target state="translated">Для вещественных или комплексных значений с плавающей запятой, если &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; не указан, &lt;code&gt;rtol&lt;/code&gt; по умолчанию принимает квадратный корень из &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; типа &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; , в зависимости от того, что больше (наименее точное). Это соответствует требованию равенства примерно половины значащих цифр. В противном случае, например, для целочисленных аргументов или если &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; , &lt;code&gt;rtol&lt;/code&gt; по умолчанию равен нулю.</target>
        </trans-unit>
        <trans-unit id="9a1f18a5fd677ec7a031d2172a281c2590c59640" translate="yes" xml:space="preserve">
          <source>For real vectors &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt;, the Kronecker product is related to the outer product by &lt;code&gt;kron(v,w) == vec(w * transpose(v))&lt;/code&gt; or &lt;code&gt;w * transpose(v) == reshape(kron(v,w), (length(w), length(v)))&lt;/code&gt;. Note how the ordering of &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; differs on the left and right of these expressions (due to column-major storage). For complex vectors, the outer product &lt;code&gt;w * v'&lt;/code&gt; also differs by conjugation of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58b65ff0e6e435abbaf14887e067d0c31d3520b" translate="yes" xml:space="preserve">
          <source>For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.</source>
          <target state="translated">По причинам длительности результаты здесь не показаны,но вы можете попробовать это самостоятельно.Так как в первом случае тип указан полностью,то компилятору не нужно генерировать код для разрешения типа во время выполнения.Это приводит к более короткому и быстрому коду.</target>
        </trans-unit>
        <trans-unit id="6fc874bd7cd4d5b9abffad50a8cc5e9ee8fcd173" translate="yes" xml:space="preserve">
          <source>For rectangular &lt;code&gt;A&lt;/code&gt; the result is the minimum-norm least squares solution computed by a pivoted QR factorization of &lt;code&gt;A&lt;/code&gt; and a rank estimate of &lt;code&gt;A&lt;/code&gt; based on the R factor.</source>
          <target state="translated">Для прямоугольного &lt;code&gt;A&lt;/code&gt; результатом является решение методом наименьших квадратов с минимальной нормой, вычисленное с помощью развернутой QR-факторизации &lt;code&gt;A&lt;/code&gt; и оценки ранга &lt;code&gt;A&lt;/code&gt; на основе фактора R.</target>
        </trans-unit>
        <trans-unit id="96f59651f15b7587bcada98bfc3f714cf7b14bc2" translate="yes" xml:space="preserve">
          <source>For similar reasons, automated translation to Julia would also typically generate unreadable, slow, non-idiomatic code that would not be a good starting point for a native Julia port from another language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912d3fe9f2697c548ca0705aab244457023707b1" translate="yes" xml:space="preserve">
          <source>For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function's purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an &lt;code&gt;# Arguments&lt;/code&gt; header, with one &lt;code&gt;-&lt;/code&gt; bullet for each argument. The list should mention the types and default values (if any) of the arguments:</source>
          <target state="translated">Для простых функций часто проще указать роль аргументов непосредственно в описании назначения функции. Список аргументов будет только повторять информацию, уже предоставленную в другом месте. Однако предоставление списка аргументов может быть хорошей идеей для сложных функций с множеством аргументов (в частности, аргументов ключевого слова). В этом случае, вставьте его после общего описания функции, под &lt;code&gt;# Arguments&lt;/code&gt; заголовка, с одним &lt;code&gt;-&lt;/code&gt; пуля для каждого аргумента. В списке должны быть указаны типы и значения по умолчанию (если есть) аргументов:</target>
        </trans-unit>
        <trans-unit id="1ea7196a777e8e9b741754a756a982ecdc4df126" translate="yes" xml:space="preserve">
          <source>For simple index types, it defers to the unexported &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; to process each index &lt;code&gt;i&lt;/code&gt;. While this internal function is not intended to be called directly, &lt;code&gt;Base.to_index&lt;/code&gt; may be extended by custom array or index types to provide custom indexing behaviors.</source>
          <target state="translated">Для простых типов индексов он обращается к &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; для обработки каждого индекса &lt;code&gt;i&lt;/code&gt; . Хотя эта внутренняя функция не предназначена для прямого &lt;code&gt;Base.to_index&lt;/code&gt; , Base.to_index может быть расширен за счет настраиваемых типов массивов или индексов для обеспечения настраиваемого поведения при индексировании.</target>
        </trans-unit>
        <trans-unit id="53b19a276cd1b474618ba84687e1e90b947ee82e" translate="yes" xml:space="preserve">
          <source>For situations where a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; exists only sometimes, the &lt;code&gt;Union{T, Nothing}&lt;/code&gt; type can be used for function arguments, object fields and array element types as the equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; in other languages. If the value itself can be &lt;code&gt;nothing&lt;/code&gt; (notably, when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;), the &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; type is more appropriate since &lt;code&gt;x == nothing&lt;/code&gt; then indicates the absence of a value, and &lt;code&gt;x == Some(nothing)&lt;/code&gt; indicates the presence of a value equal to &lt;code&gt;nothing&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt;&lt;code&gt;something&lt;/code&gt;&lt;/a&gt; function allows unwrapping &lt;code&gt;Some&lt;/code&gt; objects and using a default value instead of &lt;code&gt;nothing&lt;/code&gt; arguments. Note that the compiler is able to generate efficient code when working with &lt;code&gt;Union{T, Nothing}&lt;/code&gt; arguments or fields.</source>
          <target state="translated">В ситуациях, когда значение &lt;code&gt;x&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; существует только иногда, тип &lt;code&gt;Union{T, Nothing}&lt;/code&gt; может использоваться для аргументов функции, полей объекта и типов элементов массива как эквивалент &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; , &lt;code&gt;Option&lt;/code&gt; или &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt; на других языках. Если само значение не может быть &lt;code&gt;nothing&lt;/code&gt; (особенно, когда &lt;code&gt;T&lt;/code&gt; равно &lt;code&gt;Any&lt;/code&gt; ), тип &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; более уместен, поскольку &lt;code&gt;x == nothing&lt;/code&gt; указывает на отсутствие значения, а &lt;code&gt;x == Some(nothing)&lt;/code&gt; указывает на наличие значения , равного &lt;code&gt;nothing&lt;/code&gt; . Что- &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt; &lt;code&gt;something&lt;/code&gt; &lt;/a&gt;Функция позволяет развернуть &lt;code&gt;Some&lt;/code&gt; объекты и использовать значение по умолчанию вместо аргументов &amp;laquo; &lt;code&gt;nothing&lt;/code&gt; . Обратите внимание, что компилятор может генерировать эффективный код при работе с аргументами или полями &lt;code&gt;Union{T, Nothing}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a7de4a7810165537aadc6250e15a8a55f9a88d" translate="yes" xml:space="preserve">
          <source>For some types which &quot;wrap&quot; other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example &lt;code&gt;Some(x)&lt;/code&gt; wraps &lt;code&gt;x&lt;/code&gt; to indicate that a value is present (in a context where the result might be a &lt;code&gt;Some&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt;). However, &lt;code&gt;x&lt;/code&gt; itself might be the object &lt;code&gt;Some(y)&lt;/code&gt;, in which case the result is &lt;code&gt;Some(Some(y))&lt;/code&gt;, with two levels of wrapping. &lt;code&gt;convert(Some, x)&lt;/code&gt;, on the other hand, would just return &lt;code&gt;x&lt;/code&gt; since it is already a &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="translated">Для некоторых типов, которые &amp;laquo;обертывают&amp;raquo; другие значения, конструктор может заключить свой аргумент в новый объект, даже если он уже имеет запрошенный тип. Например, &lt;code&gt;Some(x)&lt;/code&gt; оборачивает &lt;code&gt;x&lt;/code&gt; , чтобы указать, что значение присутствует (в контексте, где результатом может быть &lt;code&gt;Some&lt;/code&gt; или &lt;code&gt;nothing&lt;/code&gt; ). Однако сам &lt;code&gt;x&lt;/code&gt; может быть объектом &lt;code&gt;Some(y)&lt;/code&gt; , и в этом случае результатом будет &lt;code&gt;Some(Some(y))&lt;/code&gt; с двумя уровнями переноса. &lt;code&gt;convert(Some, x)&lt;/code&gt; , с другой стороны, просто вернет &lt;code&gt;x&lt;/code&gt; , поскольку это уже &lt;code&gt;Some&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47046f98397f6383243a7899dc2654cd12e6fb38" translate="yes" xml:space="preserve">
          <source>For some types, the machinery to &quot;fuse&quot; operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; as if it had been written &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt;, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing &lt;code&gt;Broadcasted&lt;/code&gt; objects, Julia lowers the fused expression &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; to &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt;. Now, by default, &lt;code&gt;broadcasted&lt;/code&gt; just calls the &lt;code&gt;Broadcasted&lt;/code&gt; constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.</source>
          <target state="translated">Для некоторых типов механизм &amp;laquo;слияния&amp;raquo; операций на вложенных уровнях широковещательной передачи недоступен или может быть выполнен более эффективно постепенно. В таких случаях вам может потребоваться или вы захотите оценить &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; как если бы это было написано &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt; , где внутренняя операция оценивается перед выполнением внешняя операция. Такая нетерпеливая операция напрямую поддерживается небольшим косвенным обращением; вместо того, чтобы напрямую создавать объекты &lt;code&gt;Broadcasted&lt;/code&gt; , Джулия понижает объединенное выражение &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; до &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt; . Теперь, по умолчанию &lt;code&gt;broadcasted&lt;/code&gt; только называет , &lt;code&gt;Broadcasted&lt;/code&gt; конструктор для создания ленивого представления дерева слитных выражений, но вы можете переопределить его для определенной комбинации функции и аргументов.</target>
        </trans-unit>
        <trans-unit id="08e1dce6d1b843106b2d04dbdc79c4bf75d54149" translate="yes" xml:space="preserve">
          <source>For specializing broadcast on custom types, see</source>
          <target state="translated">Для специализации трансляции на пользовательских типах см.</target>
        </trans-unit>
        <trans-unit id="1b18cc26dc44ec9e519a2a7660046d4495db6e20" translate="yes" xml:space="preserve">
          <source>For specific exception types, &lt;code&gt;handler&lt;/code&gt; is required to accept additional arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063287ad264bebc20a42dfa1890ff52805f2bb2c" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected) or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="translated">Для строковых аргументов ( &lt;code&gt;char*&lt;/code&gt; ) тип Julia должен быть &lt;code&gt;Cstring&lt;/code&gt; (если ожидаются данные с завершающим NUL) или либо &lt;code&gt;Ptr{Cchar}&lt;/code&gt; либо &lt;code&gt;Ptr{UInt8}&lt;/code&gt; противном случае (эти два типа указателей имеют одинаковый эффект), как описано выше, а не &lt;code&gt;String&lt;/code&gt; . Точно так же для аргументов массива ( &lt;code&gt;T[]&lt;/code&gt; или &lt;code&gt;T*&lt;/code&gt; ) тип Julia снова должен быть &lt;code&gt;Ptr{T}&lt;/code&gt; , а не &lt;code&gt;Vector{T}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ae9d821284a94b5ce78c69057ff544650721831" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected), or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3d0b51e2ef5e244357843af21db4dc2c7dfc01" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt;) is chosen.</source>
          <target state="translated">Для симметричного или эрмитового &lt;code&gt;A&lt;/code&gt; используется &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; разложение ( собственное разложение ), в противном случае выбирается алгоритм масштабирования и возведения в квадрат (см. &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9203451fb420c19124d347a28e5e21e46e2168a9" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;sup&gt;&lt;a href=&quot;#footnote-H05&quot; id=&quot;citeref-H05&quot;&gt;[H05]&lt;/a&gt;&lt;/sup&gt;) is chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4a6da96174312b12bb84f60f8bf72388ffeca" translate="yes" xml:space="preserve">
          <source>For text I/O, use the &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):</source>
          <target state="translated">Для текстового ввода-вывода используйте методы &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;show&lt;/code&gt; , в зависимости от ваших потребностей (см. Документацию по этим двум методам для подробного обсуждения разницы между ними):</target>
        </trans-unit>
        <trans-unit id="205743ce47116c17ca0d1d16d7b760bea8f341c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;Squares&lt;/code&gt; iterable above, we can easily compute the &lt;code&gt;i&lt;/code&gt;th element of the sequence by squaring it. We can expose this as an indexing expression &lt;code&gt;S[i]&lt;/code&gt;. To opt into this behavior, &lt;code&gt;Squares&lt;/code&gt; simply needs to define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Для итераций &lt;code&gt;Squares&lt;/code&gt; , описанных выше, мы можем легко вычислить &lt;code&gt;i&lt;/code&gt; - й элемент последовательности, возведя его в квадрат. Мы можем представить это как выражение индексации &lt;code&gt;S[i]&lt;/code&gt; . Чтобы выбрать такое поведение, &lt;code&gt;Squares&lt;/code&gt; просто нужно определить &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b61259c05b4f470d8af9ec6b5659050e33e9f420" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return the total number of that day of the week in &lt;code&gt;dt&lt;/code&gt;'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; in the adjuster function.</source>
          <target state="translated">Для дня недели &lt;code&gt;dt&lt;/code&gt; возвращает общее количество дней недели в месяце &lt;code&gt;dt&lt;/code&gt; . Возвращает 4 или 5. Используется во временных выражениях для указания последнего дня недели в месяце путем включения &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; в функцию настройки .</target>
        </trans-unit>
        <trans-unit id="fe652373fcfd70aa4cf5d9a9c42f569d7f7beb45" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return which number it is in &lt;code&gt;dt&lt;/code&gt;'s month. So if the day of the week of &lt;code&gt;dt&lt;/code&gt; is Monday, then &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; In the range 1:5.</source>
          <target state="translated">Для дня недели &lt;code&gt;dt&lt;/code&gt; верните номер в месяце &lt;code&gt;dt&lt;/code&gt; . Итак, если день недели &lt;code&gt;dt&lt;/code&gt; - понедельник, то &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; В диапазоне 1: 5.</target>
        </trans-unit>
        <trans-unit id="652922b94585bcd03eb665e42d71bab0709ffc65" translate="yes" xml:space="preserve">
          <source>For the default constructor, exactly one argument must be supplied for each field:</source>
          <target state="translated">Для конструктора по умолчанию для каждого поля должен быть задан ровно один аргумент:</target>
        </trans-unit>
        <trans-unit id="56d79b9ca82aa7547916a2539b58ed4630995e94" translate="yes" xml:space="preserve">
          <source>For the remaining keyword arguments, see the documentation of &lt;a href=&quot;#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Остальные аргументы ключевых слов см. В документации по &lt;a href=&quot;#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="b23a97c3c42b32c810ec362860430dab0f399881" translate="yes" xml:space="preserve">
          <source>For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;||&lt;/code&gt; do not allow for &lt;code&gt;missing&lt;/code&gt; values in situations where the value of the operand determines whether the next operand is evaluated or not. For example</source>
          <target state="translated">По той же причине, в отличие от логических операторов, представленных выше, сокращающие логические операторы &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;||&lt;/code&gt; не допускайте &lt;code&gt;missing&lt;/code&gt; значений в ситуациях, когда значение операнда определяет, оценивается ли следующий операнд или нет. Например</target>
        </trans-unit>
        <trans-unit id="f6f2cb638bdf85d316fe3667be12ad3cf8fd1cb2" translate="yes" xml:space="preserve">
          <source>For the very common pattern usage pattern of</source>
          <target state="translated">Для очень распространенного шаблона использования</target>
        </trans-unit>
        <trans-unit id="abe66bccf2edc923b8619fe03afd5d016c3843ac" translate="yes" xml:space="preserve">
          <source>For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives.</source>
          <target state="translated">По этим причинам рекомендуется попробовать использовать встроенный профилировщик выборки,прежде чем рассматривать какие-либо альтернативы.</target>
        </trans-unit>
        <trans-unit id="61eee68fc84c521e01e74ee4b3cb32a8a20b7707" translate="yes" xml:space="preserve">
          <source>For translating a C argument list to Julia:</source>
          <target state="translated">За перевод списка аргументов на C Джулии:</target>
        </trans-unit>
        <trans-unit id="0c8fe98556d87eebbe139565ad2035f5a8376ab0" translate="yes" xml:space="preserve">
          <source>For translating a C return type to Julia:</source>
          <target state="translated">Для перевода обратного шрифта C на Джулию:</target>
        </trans-unit>
        <trans-unit id="f089947163c1743d34e858e0290c83835145a36d" translate="yes" xml:space="preserve">
          <source>For two arguments, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi, \pi]$. This corresponds to a standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Для двух аргументов это угол в радианах между положительной осью &lt;em&gt;x&lt;/em&gt; и точкой ( &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; ), возвращающий значение в интервале $ [- \ pi, \ pi] $. Это соответствует стандартной функции &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8784f2a51d06748e116c26d584683c6da35029e2" translate="yes" xml:space="preserve">
          <source>For unbuffered channels returns &lt;code&gt;true&lt;/code&gt; if there are tasks waiting on a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для небуферизованных каналов возвращает &lt;code&gt;true&lt;/code&gt; , если есть задачи, ожидающие &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="dcf07feef0790c851bc6f0a6f8cbac38791a64b9" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">Для небуферизованных каналов блокируется до записи &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;выполняется другая задача.</target>
        </trans-unit>
        <trans-unit id="84b0a200921412bb65f21b5bb7c59da76c4bbed1" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">Для небуферизованных каналов блокируется до &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt;выполняется другая задача.</target>
        </trans-unit>
        <trans-unit id="a1f4f3e026d72a7731be56290972632b9296433b" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;code&gt;take!&lt;/code&gt; is performed by a different task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d88c03e115fa0e1f0ae726ca69a5946e7b8f3d" translate="yes" xml:space="preserve">
          <source>For variable &lt;code&gt;a&lt;/code&gt; and expression &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a = b&lt;/code&gt; makes &lt;code&gt;a&lt;/code&gt; refer to the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Для переменных &lt;code&gt;a&lt;/code&gt; и выражения &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a = b&lt;/code&gt; делает относится к значению &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a2988c23bad5d1f4419c0c3331b505d6761bfd4" translate="yes" xml:space="preserve">
          <source>For when a capture doesn't match, instead of a substring, &lt;code&gt;m.captures&lt;/code&gt; contains &lt;code&gt;nothing&lt;/code&gt; in that position, and &lt;code&gt;m.offsets&lt;/code&gt; has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</source>
          <target state="translated">Когда захват не совпадает, вместо подстроки &lt;code&gt;m.captures&lt;/code&gt; &lt;code&gt;nothing&lt;/code&gt; содержит в этой позиции, а &lt;code&gt;m.offsets&lt;/code&gt; имеет нулевое смещение (напомним, что индексы в Julia начинаются с 1, поэтому нулевое смещение в строке недействительным). Вот пара несколько надуманных примеров:</target>
        </trans-unit>
        <trans-unit id="cdc4b17a13e956b864dfd62e85ad672e28429820" translate="yes" xml:space="preserve">
          <source>Force a GC run</source>
          <target state="translated">Запустить GC</target>
        </trans-unit>
        <trans-unit id="5eb175b9460612a847c5831f8d611666f7e129b1" translate="yes" xml:space="preserve">
          <source>Forces</source>
          <target state="translated">Forces</target>
        </trans-unit>
        <trans-unit id="08bb485a70c09a4b008d8b79ee39bee0f080480a" translate="yes" xml:space="preserve">
          <source>Forces synchronization between the in-memory version of a memory-mapped &lt;code&gt;Array&lt;/code&gt; or &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; and the on-disk version.</source>
          <target state="translated">Принудительная синхронизация между версией отображаемого в память &lt;code&gt;Array&lt;/code&gt; или &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; в памяти и версией на диске.</target>
        </trans-unit>
        <trans-unit id="a4b44623e8c8994cfd237bbb5a20500862bde2d9" translate="yes" xml:space="preserve">
          <source>Fork And Knife</source>
          <target state="translated">Вилка и нож</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="050d7641601e8d3bdebb15e95cb05f81983e6de8" translate="yes" xml:space="preserve">
          <source>Format the &lt;code&gt;tok&lt;/code&gt; token from &lt;code&gt;dt&lt;/code&gt; and write it to &lt;code&gt;io&lt;/code&gt;. The formatting can be based on &lt;code&gt;locale&lt;/code&gt;.</source>
          <target state="translated">Форматирование &lt;code&gt;tok&lt;/code&gt; маркер из &lt;code&gt;dt&lt;/code&gt; и записать его &lt;code&gt;io&lt;/code&gt; . Форматирование может зависеть от &lt;code&gt;locale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b95515ff3376dd3ae2f977e999ab2880dd7abaa5" translate="yes" xml:space="preserve">
          <source>Fortran Wrapper Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5449b0de438e10172cfa72d13dabc8ee40d61810" translate="yes" xml:space="preserve">
          <source>Fortran compilers &lt;em&gt;may&lt;/em&gt; also add other hidden arguments for pointers, assumed-shape (&lt;code&gt;:&lt;/code&gt;) and assumed-size (&lt;code&gt;*&lt;/code&gt;) arrays. Such behaviour can be avoided by using &lt;code&gt;ISO_C_BINDING&lt;/code&gt; and including &lt;code&gt;bind(c)&lt;/code&gt; in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only &lt;code&gt;character(len=1)&lt;/code&gt; will be permitted to pass strings).</source>
          <target state="translated">Компиляторы Фортрана &lt;em&gt;могут&lt;/em&gt; также добавлять другие скрытые аргументы для указателей, массивов предполагаемой формы ( &lt;code&gt;:&lt;/code&gt; ) и предполагаемого размера ( &lt;code&gt;*&lt;/code&gt; ). Такого поведения можно избежать, используя &lt;code&gt;ISO_C_BINDING&lt;/code&gt; и включив &lt;code&gt;bind(c)&lt;/code&gt; в определение подпрограммы, что настоятельно рекомендуется для интероперабельного кода. В этом случае не будет скрытых аргументов за счет некоторых особенностей языка (например, только &lt;code&gt;character(len=1)&lt;/code&gt; будет разрешен для передачи строк).</target>
        </trans-unit>
        <trans-unit id="a0484116def6ba2539f3b9f9921bd8b4ba22a4aa" translate="yes" xml:space="preserve">
          <source>Fortran name</source>
          <target state="translated">Имя Фортран</target>
        </trans-unit>
        <trans-unit id="16c35d1374b93a7d00d34b68d3e6ad6a2c21c760" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="translated">К счастью, многие полезные параллельные вычисления не требуют перемещения данных. Типичным примером является моделирование методом Монте-Карло, где несколько процессов могут одновременно обрабатывать независимые испытания моделирования. Мы можем использовать &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; ,&lt;/a&gt; чтобы подбрасывать монеты в двух процессах. Сначала напишите в &lt;code&gt;count_heads.jl&lt;/code&gt; следующую функцию :</target>
        </trans-unit>
        <trans-unit id="c88633f59ce30b4843943132dd5c7b1eb583498a" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd1ed1b5512a22fba4de952e82beaad9990da5b" translate="yes" xml:space="preserve">
          <source>Forward delete one character (when buffer has text)</source>
          <target state="translated">Форвардное удаление одного символа (когда в буфере есть текст)</target>
        </trans-unit>
        <trans-unit id="d2bd5de8c2484ca6755e34f338af3268021c0a12" translate="yes" xml:space="preserve">
          <source>Forward delete the next word</source>
          <target state="translated">Вперед удалить следующее слово</target>
        </trans-unit>
        <trans-unit id="a187c3285151f39c70caaf5e477c6e87663d3ef4" translate="yes" xml:space="preserve">
          <source>Fountain</source>
          <target state="translated">Fountain</target>
        </trans-unit>
        <trans-unit id="4ab98d03a72763b8222b6d8722ded7966bf98d76" translate="yes" xml:space="preserve">
          <source>Four Leaf Clover</source>
          <target state="translated">Клевер четырёх листьев</target>
        </trans-unit>
        <trans-unit id="2b13f83d35f7fc73ce97c8b26bfe724907153aae" translate="yes" xml:space="preserve">
          <source>Four-Per-Em Space</source>
          <target state="translated">Четырехэтажное пространство</target>
        </trans-unit>
        <trans-unit id="73c09759c4507af6948adebc3787e93351d4acda" translate="yes" xml:space="preserve">
          <source>Fourth Root</source>
          <target state="translated">Четвёртый корень</target>
        </trans-unit>
        <trans-unit id="c54d686ebd31bf6296f3ac8e3de5cdba7b0fe495" translate="yes" xml:space="preserve">
          <source>Fraction Numerator One</source>
          <target state="translated">Числитель дроби Один</target>
        </trans-unit>
        <trans-unit id="9f62f41c6fc2c6a6ef7e8630ebef06bc253ed2e9" translate="yes" xml:space="preserve">
          <source>Fractions</source>
          <target state="translated">Fractions</target>
        </trans-unit>
        <trans-unit id="1a4eb1bfc4ceb4284f084ca37c8edbaed934f05c" translate="yes" xml:space="preserve">
          <source>Free and open source (&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT licensed&lt;/a&gt;)</source>
          <target state="translated">Бесплатный и открытый исходный код (под &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;лицензией MIT&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d150e0aaee05d4d7cee80412f889a1b8c7404089" translate="yes" xml:space="preserve">
          <source>French Fries</source>
          <target state="translated">картошка фри</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">Часто задаваемые вопросы</target>
        </trans-unit>
        <trans-unit id="2e42fd5fd57e2eddb93e306ecceb863efd070156" translate="yes" xml:space="preserve">
          <source>Fried Shrimp</source>
          <target state="translated">жареные креветки</target>
        </trans-unit>
        <trans-unit id="d25d30098e10e7246e59352c44263a5bb1531117" translate="yes" xml:space="preserve">
          <source>Frog Face</source>
          <target state="translated">Лягушачья Лицо</target>
        </trans-unit>
        <trans-unit id="ec026c33022b335b80bd8f0e64407b39229b2c88" translate="yes" xml:space="preserve">
          <source>From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how &lt;code&gt;foo&lt;/code&gt; behaves:</source>
          <target state="translated">С точки зрения вызывающего абонента это идентично обычной функции; Фактически, вам не нужно знать, вызываете ли вы обычную или сгенерированную функцию. Посмотрим, как себя ведет &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ca77e2b5e973595e2f2f608f9805266ed582b1b8" translate="yes" xml:space="preserve">
          <source>From these definitions, one obtains the following behavior:</source>
          <target state="translated">Из этих определений получается следующее поведение:</target>
        </trans-unit>
        <trans-unit id="b422184537e8dbfbffe465f2c662481e754378a9" translate="yes" xml:space="preserve">
          <source>Front-Facing Baby Chick</source>
          <target state="translated">Лицом к лицу детская цыпочка</target>
        </trans-unit>
        <trans-unit id="6d0c809a561642fe04a663534c34c6a988c1f63d" translate="yes" xml:space="preserve">
          <source>Frown</source>
          <target state="translated">Frown</target>
        </trans-unit>
        <trans-unit id="fb52dd543cda4930bef0a7aed25ec2307f4f2ed5" translate="yes" xml:space="preserve">
          <source>Frowning Face With Open Mouth</source>
          <target state="translated">Хмурое лицо с открытым ртом</target>
        </trans-unit>
        <trans-unit id="3b8ae9bdd856b92028c18db46fbc39d04889c711" translate="yes" xml:space="preserve">
          <source>Fuel Pump</source>
          <target state="translated">Насос топлива</target>
        </trans-unit>
        <trans-unit id="1dc013b6064daee6213fd09ae3d5ea49df1bdb94" translate="yes" xml:space="preserve">
          <source>Full Block</source>
          <target state="translated">Полный блок</target>
        </trans-unit>
        <trans-unit id="91e2750218473c3715d4640558a3e864dd2b4c5e" translate="yes" xml:space="preserve">
          <source>Full Moon Symbol</source>
          <target state="translated">Полнолуние Символ</target>
        </trans-unit>
        <trans-unit id="32a64f880ba20480782d9f08062e23749801ebec" translate="yes" xml:space="preserve">
          <source>Full Moon With Face</source>
          <target state="translated">Полнолуние с лицом</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">Полное внешнее присоединение</target>
        </trans-unit>
        <trans-unit id="f1096aa4780f9ea80d71f2a7366569059e04d8fc" translate="yes" xml:space="preserve">
          <source>Full day of week name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bc6576bb78484d08a918ba3eadfec40cb28a6b" translate="yes" xml:space="preserve">
          <source>Full month name according to the &lt;code&gt;locale&lt;/code&gt; keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db63acc70bb8aace65207096c8aa56a922c0d72f" translate="yes" xml:space="preserve">
          <source>Fully implemented by:</source>
          <target state="translated">Полностью реализованный:</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="95054001cf3f6f293128fbac88deaae7d22cc115" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;abmult&lt;/code&gt; returns a function &lt;code&gt;f&lt;/code&gt; that multiplies its argument by the absolute value of &lt;code&gt;r&lt;/code&gt;. The inner function assigned to &lt;code&gt;f&lt;/code&gt; is called a &quot;closure&quot;. Inner functions are also used by the language for &lt;code&gt;do&lt;/code&gt;-blocks and for generator expressions.</source>
          <target state="translated">Функция &lt;code&gt;abmult&lt;/code&gt; возвращает функцию &lt;code&gt;f&lt;/code&gt; , которая умножает свой аргумент на абсолютное значение &lt;code&gt;r&lt;/code&gt; . Внутренняя функция, присвоенная &lt;code&gt;f&lt;/code&gt; , называется &amp;laquo;закрытием&amp;raquo;. Внутренние функции также используются языком для &lt;code&gt;do&lt;/code&gt; -blocks и для выражений генератора.</target>
        </trans-unit>
        <trans-unit id="902d94a2b6ad89fe3137e81fa9679244c8f73579" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;exit_on_sigint&lt;/code&gt; requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7697b6877e6664e26745e5f66999b4cfefbd165c" translate="yes" xml:space="preserve">
          <source>Function body starting with &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</source>
          <target state="translated">Тело функции начинается с &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa0b7e8266dfec8d33dbc09471974455072b6005" translate="yes" xml:space="preserve">
          <source>Function chaining (sometimes called &quot;piping&quot; or &quot;using a pipe&quot; to send data to a subsequent function) is when you apply a function to the previous function's output:</source>
          <target state="translated">Функциональная цепочка (иногда называемая &quot;трубопроводом&quot; или &quot;использованием трубы&quot; для передачи данных в последующую функцию)-это когда вы применяете функцию к выходу предыдущей функции:</target>
        </trans-unit>
        <trans-unit id="de91ebb3667f8cc24a066c6edb9a49fb5801d827" translate="yes" xml:space="preserve">
          <source>Function composition also works in prefix form: &lt;code&gt;∘(f, g)&lt;/code&gt; is the same as &lt;code&gt;f ∘ g&lt;/code&gt;. The prefix form supports composition of multiple functions: &lt;code&gt;∘(f, g, h) = f ∘ g ∘ h&lt;/code&gt; and splatting &lt;code&gt;∘(fs...)&lt;/code&gt; for composing an iterable collection of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28a100a083f8e25a3bc12e6db11fea904564f3f" translate="yes" xml:space="preserve">
          <source>Function composition and piping</source>
          <target state="translated">Функциональный состав и трубопровод</target>
        </trans-unit>
        <trans-unit id="faa5a28142e8b8d79608d822a7ee2fc012117fa0" translate="yes" xml:space="preserve">
          <source>Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (&lt;code&gt;∘&lt;/code&gt;) to compose the functions, so &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; is the same as &lt;code&gt;f(g(args...))&lt;/code&gt;.</source>
          <target state="translated">Композиция функций - это когда вы объединяете функции вместе и применяете полученную композицию к аргументам. Вы используете оператор композиции функций ( &lt;code&gt;∘&lt;/code&gt; ), чтобы составлять функции, поэтому &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; совпадает с &lt;code&gt;f(g(args...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2060410180dd6737f9e6d318390fd5317d7bae" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8cbdb67375da79abe2b0143f8eebcc7cb99416" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="translated">Параметры функции также могут использоваться для ограничения количества аргументов, которые могут быть &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;переданы функции&lt;/a&gt; &quot;varargs&quot; (функции Varargs ). Обозначение &lt;code&gt;Vararg{T,N}&lt;/code&gt; используется для обозначения такого ограничения. Например:</target>
        </trans-unit>
        <trans-unit id="c748f42ec833ed8f7d97105f385770153e5f3a88" translate="yes" xml:space="preserve">
          <source>Function sets &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs and &lt;code&gt;mirror&lt;/code&gt; flag for remote reference.</source>
          <target state="translated">Наборы функций &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs и флаг &lt;code&gt;mirror&lt;/code&gt; для удаленной ссылки.</target>
        </trans-unit>
        <trans-unit id="ea4be7f77276f932f73d95ac11b41c01bca27493" translate="yes" xml:space="preserve">
          <source>Function-like objects</source>
          <target state="translated">Функциональноподобные объекты</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="eddb44c7165ef5eabc1df07ca23331299f12c1fa" translate="yes" xml:space="preserve">
          <source>Functionality for base-64 encoded strings and IO.</source>
          <target state="translated">Функциональность для строк в кодировке base-64 и IO.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="53a4e15f59ddb4061325c79602aaccdf7b922b54" translate="yes" xml:space="preserve">
          <source>Functions &amp;amp; Methods</source>
          <target state="translated">Функции и методы</target>
        </trans-unit>
        <trans-unit id="c13326dfc431675363c3f3a461ddb4d2e5748e9f" translate="yes" xml:space="preserve">
          <source>Functions &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/a&gt;, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</source>
          <target state="translated">Функции &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/a&gt; и другие доступны в качестве программных средств добавления, удаления и запроса процессов в кластере.</target>
        </trans-unit>
        <trans-unit id="0ff075e5c1729ce32f2f5738fecab65d263b0838" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; also follow the rules of three-valued logic, returning &lt;code&gt;missing&lt;/code&gt; when the result cannot be determined</source>
          <target state="translated">Функции &lt;code&gt;any&lt;/code&gt; и &lt;code&gt;all&lt;/code&gt; же следовать правилам трехзначной логики, возвращая &lt;code&gt;missing&lt;/code&gt; , если результат не может быть определен</target>
        </trans-unit>
        <trans-unit id="a7372df3a40ed071a29722d4bc6498e66d76a5da" translate="yes" xml:space="preserve">
          <source>Functions and Methods</source>
          <target state="translated">Функции и методы</target>
        </trans-unit>
        <trans-unit id="547df569a8b37a13ed96cad6ad095bccba6ee3ff" translate="yes" xml:space="preserve">
          <source>Functions and variables share the same namespace (&amp;ldquo;Lisp-1&amp;rdquo;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb375b3fcf2e8e9d0dbcd433eb2746123db60e5" translate="yes" xml:space="preserve">
          <source>Functions are defined with the &lt;code&gt;function&lt;/code&gt; keyword:</source>
          <target state="translated">Функции определяются с помощью ключевого слова &lt;code&gt;function&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55e8c66bfd9e6c0e9dfa04cb544f8bb30a80231b" translate="yes" xml:space="preserve">
          <source>Functions in Julia are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;first-class objects&lt;/a&gt;: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</source>
          <target state="translated">Функции в Julia являются &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;объектами первого класса&lt;/a&gt; : их можно назначать переменным и вызывать с использованием стандартного синтаксиса вызова функций из переменной, которой они были назначены. Их можно использовать как аргументы и возвращать как значения. Они также могут быть созданы анонимно, без указания имени, с использованием любого из этих синтаксисов:</target>
        </trans-unit>
        <trans-unit id="c04e52a6c310e2a4baade48d1f42fd88819eec1a" translate="yes" xml:space="preserve">
          <source>Functions in Julia can be combined by composing or piping (chaining) them together.</source>
          <target state="translated">Функции в Юлии могут быть объединены с помощью композиции или связывания их (цепочки).</target>
        </trans-unit>
        <trans-unit id="ceeb1ec49508dede84853cbb0f013b3decdfa56c" translate="yes" xml:space="preserve">
          <source>Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by &lt;code&gt;function bar end&lt;/code&gt;). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:</source>
          <target state="translated">Функции в Julia могут иметь несколько реализаций, известных как методы. Хотя для универсальных функций рекомендуется использовать одну цель, Джулия позволяет документировать методы индивидуально, если это необходимо. В общем, следует документировать только самый общий метод или даже саму функцию (т.е. объект, созданный без каких-либо методов &lt;code&gt;function bar end&lt;/code&gt; ). Конкретные методы следует документировать, только если их поведение отличается от более общих. В любом случае они не должны повторять информацию, представленную в другом месте. Например:</target>
        </trans-unit>
        <trans-unit id="0369fd43ccf1e9549a7a746fe6b93020919f4a10" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820b3bd7ddec6937c4e242be1bbe2ab057c0ac78" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="translated">Функции в Julia возвращают значения из своего последнего выражения или ключевого слова &lt;code&gt;return&lt;/code&gt; вместо перечисления имен возвращаемых переменных в определении функции (подробности см. &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;В&lt;/a&gt; разделе &amp;laquo;Ключевое слово возврата&amp;raquo; ).</target>
        </trans-unit>
        <trans-unit id="a59fb02f015778c14d39ec5b1bcf732d30a76ac1" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression(s) or the &lt;code&gt;return&lt;/code&gt; keyword. Multiple values can be returned from functions and assigned as tuples, e.g. &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; or &lt;code&gt;a, b = myfunction()&lt;/code&gt;, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">Функции в Julia возвращают значения из своего последнего выражения (я) или ключевого слова &lt;code&gt;return&lt;/code&gt; . Несколько значений могут быть возвращены из функций и назначены как кортежи, например &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; или &lt;code&gt;a, b = myfunction()&lt;/code&gt; , вместо того, чтобы передавать указатели на значения, как это было бы в C / C ++ ( т.е. &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a55840c344c2be9d92831007662fa28bbfaafd80" translate="yes" xml:space="preserve">
          <source>Functions like &lt;code&gt;strange_twos&lt;/code&gt; occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</source>
          <target state="translated">Такие функции, как &lt;code&gt;strange_twos&lt;/code&gt; возникают при работе с данными неопределенного типа, например с данными, загруженными из входного файла, который может содержать целые числа, числа с плавающей запятой, строки или что-то еще.</target>
        </trans-unit>
        <trans-unit id="7b33eb7808d1f3eaa212ba1f622374dd77c823c6" translate="yes" xml:space="preserve">
          <source>Functions on &lt;code&gt;Expr&lt;/code&gt;essions</source>
          <target state="translated">Функции по &lt;code&gt;Expr&lt;/code&gt; essions</target>
        </trans-unit>
        <trans-unit id="8b8603c397ef929230aa5c590ebf0c5ec135d545" translate="yes" xml:space="preserve">
          <source>Functions pertaining to probability distributions are provided by the &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions package&lt;/a&gt;.</source>
          <target state="translated">Функции, относящиеся к распределению вероятностей, предоставляются &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;пакетом Distributions&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f329adf9adf1ecc64a0f0d4d6a3d48dd49e69578" translate="yes" xml:space="preserve">
          <source>Functions that do not propagate &lt;code&gt;missing&lt;/code&gt; values can be made to do so by wrapping them in the &lt;code&gt;passmissing&lt;/code&gt; function provided by the &lt;a href=&quot;https://github.com/JuliaData/Missings.jl&quot;&gt;Missings.jl&lt;/a&gt; package. For example, &lt;code&gt;f(x)&lt;/code&gt; becomes &lt;code&gt;passmissing(f)(x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07740f0b9c92a3b6637549532f0dfc491685de70" translate="yes" xml:space="preserve">
          <source>Functions that write to their arguments have names that end in &lt;code&gt;!&lt;/code&gt;. These are sometimes called &quot;mutating&quot; or &quot;in-place&quot; functions because they are intended to produce changes in their arguments after the function is called, not just return a value.</source>
          <target state="translated">Функции, которые пишут в свои аргументы, имеют имена, оканчивающиеся на &lt;code&gt;!&lt;/code&gt; , Иногда их называют &amp;laquo;изменяющими&amp;raquo; или &amp;laquo;на месте&amp;raquo; функциями, потому что они предназначены для изменения своих аргументов после вызова функции, а не просто для возврата значения.</target>
        </trans-unit>
        <trans-unit id="9cba6354edf31323e29d861220b894beb53b62d4" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments are defined using a semicolon in the signature:</source>
          <target state="translated">Функции с аргументами ключевых слов определяются с помощью точки с запятой в сигнатуре:</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">Дальнейшее чтение</target>
        </trans-unit>
        <trans-unit id="d740b078ded802ba0e2eac07618b79e4bfdcbb51" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0132f20ae5d3a74b84246e40987da84635bfd3d0" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="translated">Кроме того, &quot;пунктирные&quot; операторы обновления, такие как &lt;code&gt;a .+= b&lt;/code&gt; (или &lt;code&gt;@. a += b&lt;/code&gt; ), анализируются как &lt;code&gt;a .= a .+ b&lt;/code&gt; , где &lt;code&gt;.=&lt;/code&gt; - это объединенная операция присваивания на &lt;em&gt;месте&lt;/em&gt; (см. &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;Документацию по синтаксису точек.&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d0dab03985e67ddbff313bf737b40f319ace224" translate="yes" xml:space="preserve">
          <source>Furthermore, the iterable object splatted into a function call need not be a tuple:</source>
          <target state="translated">Более того,итерабельный объект,разбитый на вызов функции,не обязательно должен быть кортежом:</target>
        </trans-unit>
        <trans-unit id="047ca54032a1756c098d3bc1a941a0ed8e583df8" translate="yes" xml:space="preserve">
          <source>Future</source>
          <target state="translated">Future</target>
        </trans-unit>
        <trans-unit id="0e833ac5a09d0da4e04120e7544830f8a65151fd" translate="yes" xml:space="preserve">
          <source>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi:10.1137/0905030&lt;/a&gt;</source>
          <target state="translated">GW Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5 (2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;DOI: 10,1137 / 0905030&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="153d4c166a2f860e5ac33c697533af00d178259a" translate="yes" xml:space="preserve">
          <source>GC.@preserve</source>
          <target state="translated">GC.@preserve</target>
        </trans-unit>
        <trans-unit id="3897445415fe5ec5c17d947d2f396ecb73cfab7e" translate="yes" xml:space="preserve">
          <source>GC.enable()</source>
          <target state="translated">GC.enable()</target>
        </trans-unit>
        <trans-unit id="f7f51a07b89aa04e176b4dce9ba6e667279a4cac" translate="yes" xml:space="preserve">
          <source>GC.gc()</source>
          <target state="translated">GC.gc()</target>
        </trans-unit>
        <trans-unit id="dd04fdce0b5db2163f133667347720589a61611d" translate="yes" xml:space="preserve">
          <source>GMP.BigInt</source>
          <target state="translated">GMP.BigInt</target>
        </trans-unit>
        <trans-unit id="ec181f943ce9eb84bc41a51f14f715a4b73d4e15" translate="yes" xml:space="preserve">
          <source>GMP.BigInt()</source>
          <target state="translated">GMP.BigInt()</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="f3b1d13cf7d8da8c19344c722b6886a02e91434d" translate="yes" xml:space="preserve">
          <source>Game Die</source>
          <target state="translated">Игра Умри</target>
        </trans-unit>
        <trans-unit id="23e043a9ee4de0e7b0c73093401aa0bca44ab49b" translate="yes" xml:space="preserve">
          <source>Garbage Collection Safety</source>
          <target state="translated">Безопасность при уборке мусора</target>
        </trans-unit>
        <trans-unit id="d6d5b4be825ce665265510009390d4b69a148c2b" translate="yes" xml:space="preserve">
          <source>Garbage-collection handle for the return value from &lt;code&gt;@cfunction&lt;/code&gt; when the first argument is annotated with '$'. Like all &lt;code&gt;cfunction&lt;/code&gt; handles, it should be passed to &lt;code&gt;ccall&lt;/code&gt; as a &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, and will be converted automatically at the call site to the appropriate type.</source>
          <target state="translated">&lt;code&gt;@cfunction&lt;/code&gt; мусора для возвращаемого значения из @cfunction, когда первый аргумент помечен знаком &amp;laquo;$&amp;raquo;. Как и все дескрипторы &lt;code&gt;cfunction&lt;/code&gt; , он должен передаваться в &lt;code&gt;ccall&lt;/code&gt; как Ptr &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; , и он будет автоматически преобразован на сайте вызова в соответствующий тип.</target>
        </trans-unit>
        <trans-unit id="dbb8c00bae5bbda144f1736a9cba2314230cbae3" translate="yes" xml:space="preserve">
          <source>Gem Stone</source>
          <target state="translated">Драгоценный камень</target>
        </trans-unit>
        <trans-unit id="ddba2c9277cd909b2d4fac91a3cc754a462c7a90" translate="yes" xml:space="preserve">
          <source>Gemini</source>
          <target state="translated">Gemini</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="9203a7a738516ae214b4ae47d8b7fd816429f200" translate="yes" xml:space="preserve">
          <source>General Collections</source>
          <target state="translated">Общие коллекции</target>
        </trans-unit>
        <trans-unit id="b87cf666cc00e115fb18674c6deb84af8b517c7f" translate="yes" xml:space="preserve">
          <source>General I/O</source>
          <target state="translated">Общий ввод/вывод</target>
        </trans-unit>
        <trans-unit id="4979599c738b7850931480557307563f3cf52a2f" translate="yes" xml:space="preserve">
          <source>General Number Functions and Constants</source>
          <target state="translated">Общее число Функции и постоянные</target>
        </trans-unit>
        <trans-unit id="6b7059d9b81b1f245d958405a414e29373725e72" translate="yes" xml:space="preserve">
          <source>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">Общее экранирование традиционных escape-последовательностей C и Unicode. Первая форма возвращает экранированную строку, вторая выводит результат в &lt;code&gt;io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e9dfb96c25a921933f55dcf7822775fb8e071eb" translate="yes" xml:space="preserve">
          <source>General exceptions can be raised using the functions:</source>
          <target state="translated">Общие исключения могут быть подняты с помощью функций:</target>
        </trans-unit>
        <trans-unit id="aa8e53d9ebff9d0979fd39b344364382458a81b6" translate="yes" xml:space="preserve">
          <source>General non-square</source>
          <target state="translated">Общий неквадрат</target>
        </trans-unit>
        <trans-unit id="07891976324532c807b79ec56fda0fc0b9da6708" translate="yes" xml:space="preserve">
          <source>General square</source>
          <target state="translated">Общая площадь</target>
        </trans-unit>
        <trans-unit id="1d3f6af2e9c4d5b2ed46f9e07478d485ceb20715" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">Общее отключение традиционных escape-последовательностей C и Unicode. Первая форма возвращает экранированную строку, вторая выводит результат в &lt;code&gt;io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8d4a5e7b244f7677a49086fc90992db4311d8da" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;. The argument &lt;code&gt;keep&lt;/code&gt; specifies a collection of characters which (along with backlashes) are to be kept as they are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0285ea21d10ed4a7913ad2a66cb346f95bc9d78" translate="yes" xml:space="preserve">
          <source>Generalized SVD</source>
          <target state="translated">Обобщенное СВД</target>
        </trans-unit>
        <trans-unit id="57f4b7233f83ddd1853b6b2d05e4bb762f7fd0b4" translate="yes" xml:space="preserve">
          <source>Generalized Schur decomposition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d85331d4948d0ae34d7f8f8e070efd57ba16e64" translate="yes" xml:space="preserve">
          <source>Generalized linear models are provided by the &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM package&lt;/a&gt;.</source>
          <target state="translated">Обобщенные линейные модели предоставляются &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;пакетом GLM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74e66c6cbf540d5ae8fbca755495f0306efa1594" translate="yes" xml:space="preserve">
          <source>Generalized spectral decomposition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad14a691ce38a290bae999d447b8c703f49ef6b" translate="yes" xml:space="preserve">
          <source>Generally, new types should implement &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt; instead of this function, and rely on the fallback definition &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">Как правило, новые типы должны реализовывать &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt; вместо этой функции и полагаться на определение запасного варианта &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f33a08ad09d1f8b477ee12ea78ff5b8bbea276a6" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;BitArray&lt;/code&gt; of random boolean values.</source>
          <target state="translated">Сгенерируйте &lt;code&gt;BitArray&lt;/code&gt; случайных логических значений.</target>
        </trans-unit>
        <trans-unit id="fd53bfe967151037d3aab623a3c39dc68a9e6a07" translate="yes" xml:space="preserve">
          <source>Generate a C-callable function pointer from the Julia function &lt;code&gt;callable&lt;/code&gt; for the given type signature. To pass the return value to a &lt;code&gt;ccall&lt;/code&gt;, use the argument type &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; in the signature.</source>
          <target state="translated">Генерация C-вызываемая функция указателя из функции Julia &lt;code&gt;callable&lt;/code&gt; для данного типа подписи. Чтобы передать возвращаемое значение в &lt;code&gt;ccall&lt;/code&gt; , используйте в подписи тип аргумента &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464b58935d4b4855a4eca20151ebbc5055b2f194" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution of variance 1 (corresponding to real and imaginary part having independent normal distribution with mean zero and variance &lt;code&gt;1/2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e2ff826d751563b9e50313fe308bc12b868933" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.</source>
          <target state="translated">Сгенерируйте нормально распределенное случайное число типа &lt;code&gt;T&lt;/code&gt; со средним 0 и стандартным отклонением 1. При желании сгенерируйте массив нормально распределенных случайных чисел. &lt;code&gt;Base&lt;/code&gt; модуль в настоящее время обеспечивает реализацию для типов &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (по умолчанию), а также их &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; аналоги. Когда аргумент типа является сложным, значения берутся из циркулярно-симметричного комплексного нормального распределения.</target>
        </trans-unit>
        <trans-unit id="d735a31a4d0a7d19a36da47899d779f788bda4b7" translate="yes" xml:space="preserve">
          <source>Generate a random number of type &lt;code&gt;T&lt;/code&gt; according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default).</source>
          <target state="translated">Сгенерируйте случайное число типа &lt;code&gt;T&lt;/code&gt; в соответствии с экспоненциальным распределением с масштабом 1. При желании сгенерируйте массив таких случайных чисел. Модуль &lt;code&gt;Base&lt;/code&gt; в настоящее время предоставляет реализацию для типов &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="a537f03cb21656031e0fd8ad6fc35f3473173ca5" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed due to the very remote posibility of two simultaneous calls to &lt;code&gt;tempname&lt;/code&gt; generating the same file name. The name is guaranteed to differ from all files already existing at the time of the call to &lt;code&gt;tempname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd80a1d3f890e93d6b1dc16c37a28152669461b" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.</source>
          <target state="translated">Сгенерируйте временный путь к файлу.Эта функция возвращает только путь,файл не создается.Скорее всего,путь будет уникальным,но это не может быть гарантировано.</target>
        </trans-unit>
        <trans-unit id="3e42af03cf7e4fa9b19d5375dcdec38dc109c9bc" translate="yes" xml:space="preserve">
          <source>Generated functions</source>
          <target state="translated">Генерируемые функции</target>
        </trans-unit>
        <trans-unit id="cba590af8f8ae8e32e66535964125d2756a08bf3" translate="yes" xml:space="preserve">
          <source>Generated functions are only permitted to call functions that were defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function. (Failure to follow this may result in getting &lt;code&gt;MethodErrors&lt;/code&gt; referring to functions from a future world-age.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40080cfd55d586fc4f5401be4bb1834fea88976c" translate="yes" xml:space="preserve">
          <source>Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile &quot;generic&quot; versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.</source>
          <target state="translated">Сгенерированные функции могут достигать высокой эффективности во время выполнения,но сопряжены с затратами времени на компиляцию:для каждой комбинации конкретных типов аргументов должно быть сгенерировано новое тело функции.Обычно Юлия способна компилировать &quot;общие&quot; версии функций,которые будут работать с любыми аргументами,но с генерируемыми функциями это невозможно.Это означает,что программы,интенсивно использующие генерируемые функции,могут быть не в состоянии скомпилировать их статически.</target>
        </trans-unit>
        <trans-unit id="503406d41ab4e8215a281c0d73cf5e1840925953" translate="yes" xml:space="preserve">
          <source>Generated functions must not &lt;em&gt;mutate&lt;/em&gt; or &lt;em&gt;observe&lt;/em&gt; any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt;&lt;code&gt;hasmethod&lt;/code&gt;&lt;/a&gt;). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.</source>
          <target state="translated">Сгенерированные функции не должны &lt;em&gt;изменяться&lt;/em&gt; или &lt;em&gt;наблюдать&lt;/em&gt; какое-либо непостоянное глобальное состояние (включая, например, ввод-вывод, блокировки, нелокальные словари или использование &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt; &lt;code&gt;hasmethod&lt;/code&gt; &lt;/a&gt; ). Это означает, что они могут читать только глобальные константы и не могут иметь никаких побочных эффектов. Другими словами, они должны быть полностью чистыми. Из-за ограничений реализации это также означает, что в настоящее время они не могут определить замыкание или генератор.</target>
        </trans-unit>
        <trans-unit id="3ef0ab87b9316844c35d99faef219c9c7322d80c" translate="yes" xml:space="preserve">
          <source>Generated values can be filtered using the &lt;code&gt;if&lt;/code&gt; keyword:</source>
          <target state="translated">Сгенерированные значения можно фильтровать с помощью ключевого слова &lt;code&gt;if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="43a3b60a1f43668fa7df03ea6999eb9005534d03" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;rowval&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Создает копию &lt;code&gt;A&lt;/code&gt; и удаляет хранятся числовые нули из этой копии, при необходимости обрезки лишнего пространства от результата в &lt;code&gt;rowval&lt;/code&gt; и &lt;code&gt;nzval&lt;/code&gt; массивов , когда &lt;code&gt;trim&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eae6d1575ffa43a8d9796f9233f972a39752f20b" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8200a561dd1fd6d9a2571a09a8c0833fd591d2" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;nzind&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Создает копию &lt;code&gt;x&lt;/code&gt; и удаляет числовые нули из этой копии, при необходимости обрезки лишнего пространства от результата в &lt;code&gt;nzind&lt;/code&gt; и &lt;code&gt;nzval&lt;/code&gt; массивов , когда &lt;code&gt;trim&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45dac0453bb6ba7f95de954c9e7abbe105892f30" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d35e347a9e9f11c97762e02cb3817fdf6492b95" translate="yes" xml:space="preserve">
          <source>Generates a gensym symbol for a variable. For example, &lt;code&gt;@gensym x y&lt;/code&gt; is transformed into &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt;.</source>
          <target state="translated">Создает генетический символ для переменной. Например, &lt;code&gt;@gensym x y&lt;/code&gt; преобразуется в &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82624d1ced08378811cc12e5b9bb3247c76bde71" translate="yes" xml:space="preserve">
          <source>Generates a symbol which will not conflict with other variable names.</source>
          <target state="translated">Генерирует символ,который не будет конфликтовать с именами других переменных.</target>
        </trans-unit>
        <trans-unit id="6493dacd8d9340030628eff5048e31c32e36106f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.</source>
          <target state="translated">Генерирует универсальный уникальный идентификатор (UUID)версии 1 (по времени),как указано в RFC 4122.Обратите внимание,что идентификатор узла генерируется случайным образом (не идентифицирует хост)в соответствии с разделом 4.5 RFC.</target>
        </trans-unit>
        <trans-unit id="5c0ffbf6fa6cd08065c3fd1e20d39e7262ac9916" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">Генерирует универсальный уникальный идентификатор (UUID)версии 4 (случайный или псевдослучайный),как указано в RFC 4122.</target>
        </trans-unit>
        <trans-unit id="6864e40d6120ff94e92379a41401cda33ec26eb1" translate="yes" xml:space="preserve">
          <source>Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">Генерирует универсальный уникальный идентификатор (UUID)версии 5 (пространство имен и домен),как указано в RFC 4122.</target>
        </trans-unit>
        <trans-unit id="070600dec2910fb2959b8379d05bbc160f7ec7de" translate="yes" xml:space="preserve">
          <source>Generating random values for some distributions may involve various trade-offs. &lt;em&gt;Pre-computed&lt;/em&gt; values, such as an &lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;alias table&lt;/a&gt; for discrete distributions, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rejection_sampling&quot;&gt;&amp;ldquo;squeezing&amp;rdquo; functions&lt;/a&gt; for univariate distributions, can speed up sampling considerably. How much information should be pre-computed can depend on the number of values we plan to draw from a distribution. Also, some random number generators can have certain properties that various algorithms may want to exploit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ad5eda3014502203f1f1c9f4f8ad8b0addc8bb" translate="yes" xml:space="preserve">
          <source>Generating random values of custom types</source>
          <target state="translated">Генерация случайных значений пользовательских типов</target>
        </trans-unit>
        <trans-unit id="ea6d79a7c35cdb9d37f8d907393ca6d0663b71e9" translate="yes" xml:space="preserve">
          <source>Generating values for an &lt;code&gt;AbstractFloat&lt;/code&gt; type</source>
          <target state="translated">Генерация значений для типа &lt;code&gt;AbstractFloat&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79059f17dfecc212b29a403a6fe768eae1bb1610" translate="yes" xml:space="preserve">
          <source>Generating values from a collection</source>
          <target state="translated">Генерирование ценностей из коллекции</target>
        </trans-unit>
        <trans-unit id="5f32399dda528ab0f4979390ae10b103edb83e67" translate="yes" xml:space="preserve">
          <source>Generating values from a type</source>
          <target state="translated">Генерация значений по типу</target>
        </trans-unit>
        <trans-unit id="217dffa188c85186f3dde4d07c906c09c058f848" translate="yes" xml:space="preserve">
          <source>Generator Expressions</source>
          <target state="translated">Выражения генератора</target>
        </trans-unit>
        <trans-unit id="111436dce43eef86f4f13a06226e540548b10b69" translate="yes" xml:space="preserve">
          <source>Generators (creation and seeding)</source>
          <target state="translated">Генераторы (создание и посев)</target>
        </trans-unit>
        <trans-unit id="23abb36aa0bc1408666d7f17a0f4dc7b6c92131a" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab25cfdc66be945181ae90276749fb192703ddc0" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">Генераторы реализуются через внутренние функции. Так же, как внутренние функции, используемые где-либо в языке, переменные из охватывающей области могут быть &amp;laquo;захвачены&amp;raquo; во внутренней функции. Например, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; захватывает три переменные &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; из окружающей области. Захваченные переменные могут создавать проблемы с производительностью; см. &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;советы по производительности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83082f46072d254fd933bf6e78414552f2b12960" translate="yes" xml:space="preserve">
          <source>Generic Functions</source>
          <target state="translated">Общие функции</target>
        </trans-unit>
        <trans-unit id="2654c4b9018fcc37437c59923d4ac1eabf19c850" translate="yes" xml:space="preserve">
          <source>Generic equality operator. Falls back to &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, &lt;code&gt;==&lt;/code&gt; is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</source>
          <target state="translated">Универсальный оператор равенства. Возвращается к &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; . Должен быть реализован для всех типов с понятием равенства на основе абстрактного значения, которое представляет экземпляр. Например, все числовые типы сравниваются по числовому значению без учета типа. Строки сравниваются как последовательности символов без учета кодировки. Для коллекций &lt;code&gt;==&lt;/code&gt; обычно вызывается рекурсивно для всего содержимого, хотя другие свойства (например, форма массивов) также могут быть приняты во внимание.</target>
        </trans-unit>
        <trans-unit id="a247769c311d71434e7dbab7ffa2c58b32221569" translate="yes" xml:space="preserve">
          <source>Generic error type. The error message, in the &lt;code&gt;.msg&lt;/code&gt; field, may provide more specific details.</source>
          <target state="translated">Общий тип ошибки. Сообщение об ошибке в поле &lt;code&gt;.msg&lt;/code&gt; может содержать более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="0a2cbe8ef5a6182effacad0728af04d3466e9419" translate="yes" xml:space="preserve">
          <source>Generically sized uniform scaling operator defined as a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В общем размере оператор равномерного масштабирования определяются как скалярный раз оператора, &lt;code&gt;&amp;lambda;*I&lt;/code&gt; . Смотрите также &lt;a href=&quot;#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7021447d5c6f5d07882ea34fcf74ffd494b65a7" translate="yes" xml:space="preserve">
          <source>Geometric Proportion</source>
          <target state="translated">Геометрическая пропорция</target>
        </trans-unit>
        <trans-unit id="e505f741dc44890868c87aa48f3d8916c6fb0128" translate="yes" xml:space="preserve">
          <source>Geometrically Equal To</source>
          <target state="translated">Геометрически равный</target>
        </trans-unit>
        <trans-unit id="f64b845181c47fc7995221a47eaadce47af6bcc8" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To</source>
          <target state="translated">Геометрически эквивалентно</target>
        </trans-unit>
        <trans-unit id="30404c5812bd3cd0bc1e26c11cfbb33861e4d141" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Геометрически эквивалентный+комбинированный наложение с длинным солевым покрытием/непериодическое наложение с длинным косым черенком</target>
        </trans-unit>
        <trans-unit id="ea2ac5cf7c4e856204e6a41aeaaa0b3dd4ef2ab5" translate="yes" xml:space="preserve">
          <source>Get Julia's process ID.</source>
          <target state="translated">Достань удостоверение личности Джулии.</target>
        </trans-unit>
        <trans-unit id="76117157c574ac5727a236f6277b1450a47c5f21" translate="yes" xml:space="preserve">
          <source>Get a backtrace object for the current program point.</source>
          <target state="translated">Получить объект обратной связи для текущей точки программы.</target>
        </trans-unit>
        <trans-unit id="6245e1b22dd874707de430f7178865b9a33deacf" translate="yes" xml:space="preserve">
          <source>Get a hash value for &lt;code&gt;x&lt;/code&gt; based on object identity. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; if &lt;code&gt;x === y&lt;/code&gt;.</source>
          <target state="translated">Получите хеш-значение для &lt;code&gt;x&lt;/code&gt; на основе идентичности объекта. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; если &lt;code&gt;x === y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="594cb8bf35cce2c570e740ff46837e8b661e81ff" translate="yes" xml:space="preserve">
          <source>Get a list of all reference names in the &lt;code&gt;repo&lt;/code&gt; repository.</source>
          <target state="translated">Получить список всех референтных имен в &lt;code&gt;repo&lt;/code&gt; хранилище.</target>
        </trans-unit>
        <trans-unit id="edea7d0cabb9a933daebe03151b03bacc57f2132" translate="yes" xml:space="preserve">
          <source>Get a list of all tags in the git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">Получить список всех тегов в мерзавца хранилище &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c83b8077da01523efd9ec95df9552f34eef56509" translate="yes" xml:space="preserve">
          <source>Get a module's enclosing &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Main&lt;/code&gt; is its own parent.</source>
          <target state="translated">Получите модуль, вмещающий &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Main&lt;/code&gt; - это собственный родитель.</target>
        </trans-unit>
        <trans-unit id="91aa8a1066c0cf259f10453272965a98317015dc" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Получите строку, состоящую из первых &lt;code&gt;n&lt;/code&gt; символов &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a14f2cfc2cb6c1c852e03fd6e4a706f0a47df06c" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the last &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Получите строку, состоящую из последних &lt;code&gt;n&lt;/code&gt; символов &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3372d98da97932978011accfa92cc350dd85fc43" translate="yes" xml:space="preserve">
          <source>Get a tuple or a vector of the properties (&lt;code&gt;x.property&lt;/code&gt;) of an object &lt;code&gt;x&lt;/code&gt;. This is typically the same as &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames(typeof(x))&lt;/code&gt;&lt;/a&gt;, but types that overload &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; should generally overload &lt;code&gt;propertynames&lt;/code&gt; as well to get the properties of an instance of the type.</source>
          <target state="translated">Получить кортеж или вектор свойств ( &lt;code&gt;x.property&lt;/code&gt; ) объекта &lt;code&gt;x&lt;/code&gt; . Обычно это то же самое, что и &lt;a href=&quot;#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames(typeof(x))&lt;/code&gt; &lt;/a&gt; , но типы, которые перегружают &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; ,&lt;/a&gt; обычно должны также перегружать имена &lt;code&gt;propertynames&lt;/code&gt; чтобы получить свойства экземпляра типа.</target>
        </trans-unit>
        <trans-unit id="42f453edc0370fb274422ead5407c2776b31db1f" translate="yes" xml:space="preserve">
          <source>Get a tuple with the names of the fields of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">Получите кортеж с именами полей &lt;code&gt;DataType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d530106390fd810b016b6212bad35ad44f20a8f4" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.</source>
          <target state="translated">Получить IP-адрес локальной машины указанного типа.Сбрасывает,если адреса указанного типа недоступны.</target>
        </trans-unit>
        <trans-unit id="7cad9add4d27400ccccd1e83a0b5fe65f627675d" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.</source>
          <target state="translated">Получите IP-адрес локальной машины,предпочитая IPv4,а не IPv6.Сбрасывает,если адреса недоступны.</target>
        </trans-unit>
        <trans-unit id="d1b1f967961007a8e3404abb4f0fb2c9b3d00448" translate="yes" xml:space="preserve">
          <source>Get an array of the names exported by a &lt;code&gt;Module&lt;/code&gt;, excluding deprecated names. If &lt;code&gt;all&lt;/code&gt; is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If &lt;code&gt;imported&lt;/code&gt; is true, then names explicitly imported from other modules are also included.</source>
          <target state="translated">Получите массив имен, экспортированных &lt;code&gt;Module&lt;/code&gt; , за исключением устаревших имен. Если &lt;code&gt;all&lt;/code&gt; верно, то список также включает неэкспортируемые имена, определенные в модуле, устаревшие имена и имена, созданные компилятором. Если &lt;code&gt;imported&lt;/code&gt; имеет значение true, то также включаются имена, явно импортированные из других модулей.</target>
        </trans-unit>
        <trans-unit id="171cab21a362e3fe558e803f2cb2a0d2a8e62a11" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Module&lt;/code&gt; of the toplevel eval, which is the &lt;code&gt;Module&lt;/code&gt; code is currently being read from.</source>
          <target state="translated">Получите &lt;code&gt;Module&lt;/code&gt; eval верхнего уровня, из которого в настоящее время считывается код &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7881586bad23ccbb959e0086fba3cebe29d398b8" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;fetch&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to fetch from.</source>
          <target state="translated">Получить refspecs &lt;em&gt;выборки&lt;/em&gt; для указанного &lt;code&gt;rmt&lt;/code&gt; . Эти refspecs содержат информацию о том, из каких ветвей следует выполнять выборку.</target>
        </trans-unit>
        <trans-unit id="f2abefd55e48cb868afd9b2bbc8365ad10b4fa4f" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;push&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to push to.</source>
          <target state="translated">Получите спецификации &lt;em&gt;push&lt;/em&gt; для указанного &lt;code&gt;rmt&lt;/code&gt; . Эти refspecs содержат информацию о том, в какую ветку (-а) нажать.</target>
        </trans-unit>
        <trans-unit id="0ec8068370cc3ffbb8329c71ce1fa5a1af831971" translate="yes" xml:space="preserve">
          <source>Get the ID number of the current thread of execution. The master thread has ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Получить идентификационный номер текущего потока выполнения. Главный поток имеет ID &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="899b97d6f0cff7934c3aa84ef79f50d77403aeb3" translate="yes" xml:space="preserve">
          <source>Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.</source>
          <target state="translated">Получите IP-адрес и порт удаленной конечной точки,к которой подключен данный разъем.Действительно только для подключенных TCP сокетов.</target>
        </trans-unit>
        <trans-unit id="b30337efd6e1ddf333502df0ba154f1bbe883302" translate="yes" xml:space="preserve">
          <source>Get the IP address and port that the given socket is bound to.</source>
          <target state="translated">Получите IP-адрес и порт,к которому привязан данный сокет.</target>
        </trans-unit>
        <trans-unit id="ae34bdec6f00934e072471fe83b1ec1bb0253d9e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine of the specified type.</source>
          <target state="translated">Получить IP-адреса локальной машины указанного типа.</target>
        </trans-unit>
        <trans-unit id="5f0191f319b101f536ac6e663f42d85f39f5dc3e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e3f3bd81b00cd5fdff2163bfb439bea6bf2f6a" translate="yes" xml:space="preserve">
          <source>Get the IPv4 addresses of the local machine.</source>
          <target state="translated">Получить IPv4-адреса локальной машины.</target>
        </trans-unit>
        <trans-unit id="fc0c58665e06f4bcac50a3a051a380e40687f694" translate="yes" xml:space="preserve">
          <source>Get the additive identity element for the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt; can also specify the type itself).</source>
          <target state="translated">Получите дополнительный элемент идентичности для типа &lt;code&gt;x&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; также может указывать сам тип).</target>
        </trans-unit>
        <trans-unit id="13d05d3446c1b045371ca3c580a406fe6efa3a85" translate="yes" xml:space="preserve">
          <source>Get the backtrace of the current exception, for use within &lt;code&gt;catch&lt;/code&gt; blocks.</source>
          <target state="translated">Получить трассировку текущего исключения для использования в блоках &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0b515694c2e31069f75a4341701ebdddc0dbcfa" translate="yes" xml:space="preserve">
          <source>Get the child process ID, if it still exists.</source>
          <target state="translated">Достань удостоверение личности ребенка,если оно все еще существует.</target>
        </trans-unit>
        <trans-unit id="b7046c13174456af8138867bb2456e8e9106c14f" translate="yes" xml:space="preserve">
          <source>Get the concrete type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Получите конкретный тип &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47ebb15e57ce473b474a7f913ff4aa9d19236677" translate="yes" xml:space="preserve">
          <source>Get the current floating point rounding mode for type &lt;code&gt;T&lt;/code&gt;, controlling the rounding of basic arithmetic functions (&lt;a href=&quot;../math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;a href=&quot;../math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sqrt&lt;/code&gt;) and type conversion.</source>
          <target state="translated">Получите текущий режим округления с плавающей запятой для типа &lt;code&gt;T&lt;/code&gt; , управляя округлением основных арифметических функций ( &lt;a href=&quot;../math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;a href=&quot;../math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;sqrt&lt;/code&gt; ) и преобразованием типов.</target>
        </trans-unit>
        <trans-unit id="054e0f64d6af85ef39cd5689d518feb6140528b2" translate="yes" xml:space="preserve">
          <source>Get the current position of a stream.</source>
          <target state="translated">Получить текущее положение потока.</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">Получить текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="b150736a9f570c696c7e152a5f442d80d1bfe707" translate="yes" xml:space="preserve">
          <source>Get the currently running &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Получить текущую запущенную &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="307991aa1f7f375be076c27a6b5e16a8e43f1f24" translate="yes" xml:space="preserve">
          <source>Get the directory part of a path. Trailing characters ('/' or '\') in the path are counted as part of the path.</source>
          <target state="translated">Получите часть пути к каталогу.Символы трейлинга ('/' или '\')в пути считаются частью пути.</target>
        </trans-unit>
        <trans-unit id="15803f5611fdfd7a4570ea4b6299230e231b89c3" translate="yes" xml:space="preserve">
          <source>Get the exponent of a normalized floating-point number.</source>
          <target state="translated">Получите показатель нормализованного числа с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="428d1e51e8fd8658370395752d8d28b03956207a" translate="yes" xml:space="preserve">
          <source>Get the fetch URL of a remote git repository.</source>
          <target state="translated">Получить URL получения удалённого git-репозитория.</target>
        </trans-unit>
        <trans-unit id="6395adf311f39b7041b3bc31800f3ac3ac69f04a" translate="yes" xml:space="preserve">
          <source>Get the file name part of a path.</source>
          <target state="translated">Получить имя файла часть пути.</target>
        </trans-unit>
        <trans-unit id="45d031a98e3d7988439346e5f12753ad44f6564c" translate="yes" xml:space="preserve">
          <source>Get the first element of an iterable collection. Return the start point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">Получите первый элемент повторяющейся коллекции. Вернуть начальную точку &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; ,&lt;/a&gt; даже если она пуста.</target>
        </trans-unit>
        <trans-unit id="e2a67c4001b5073d3effff6ee96ac8c41fc3f469" translate="yes" xml:space="preserve">
          <source>Get the full path of the library &lt;code&gt;libname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803a6a556ee1107f53d846bba76956752d4f95be" translate="yes" xml:space="preserve">
          <source>Get the fully-qualified name of a module as a tuple of symbols. For example,</source>
          <target state="translated">Получить полное имя модуля в виде кортежа символов.Например,</target>
        </trans-unit>
        <trans-unit id="9fe2dd6fafde9402b9bebe656d7e76ff3412ff6a" translate="yes" xml:space="preserve">
          <source>Get the git object to which &lt;code&gt;te&lt;/code&gt; refers and return it as its actual type (the type &lt;a href=&quot;#LibGit2.entrytype&quot;&gt;&lt;code&gt;entrytype&lt;/code&gt;&lt;/a&gt; would show), for instance a &lt;code&gt;GitBlob&lt;/code&gt; or &lt;code&gt;GitTag&lt;/code&gt;.</source>
          <target state="translated">Получите объект git, на который ссылается &lt;code&gt;te&lt;/code&gt; , и верните его как фактический тип ( будет отображаться тип &lt;a href=&quot;#LibGit2.entrytype&quot;&gt; &lt;code&gt;entrytype&lt;/code&gt; &lt;/a&gt; ), например &lt;code&gt;GitBlob&lt;/code&gt; или &lt;code&gt;GitTag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="353f9fc88dc058135091370ad6a5d9c59fcfda6e" translate="yes" xml:space="preserve">
          <source>Get the id of the current process.</source>
          <target state="translated">Получите идентификатор текущего процесса.</target>
        </trans-unit>
        <trans-unit id="4e1a5fc780c8cf7e7bc238f6885dd2ba9bd5e31b" translate="yes" xml:space="preserve">
          <source>Get the key type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Получите ключевой тип словарного типа. Ведет себя аналогично &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7db9e0d4b309f243e7497e360f841540e11cc1fa" translate="yes" xml:space="preserve">
          <source>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling &lt;a href=&quot;#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to get the last index. Return the end point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">Получить последний элемент упорядоченной коллекции, если он может быть вычислен за время O (1). Это достигается путем вызова &lt;a href=&quot;#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt; для получения последнего индекса. Вернуть конечную точку &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; ,&lt;/a&gt; даже если она пуста.</target>
        </trans-unit>
        <trans-unit id="acd04aae132c80a71e1f513a908b2702371aa23c" translate="yes" xml:space="preserve">
          <source>Get the local machine's host name.</source>
          <target state="translated">Получите имя хоста локальной машины.</target>
        </trans-unit>
        <trans-unit id="7880b6703d5b76a9fbb2e0506acfbba24be95f11" translate="yes" xml:space="preserve">
          <source>Get the memory address of a Julia object as a &lt;code&gt;Ptr&lt;/code&gt;. The existence of the resulting &lt;code&gt;Ptr&lt;/code&gt; will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the &lt;code&gt;Ptr&lt;/code&gt; will be used.</source>
          <target state="translated">Получите адрес памяти объекта Julia как &lt;code&gt;Ptr&lt;/code&gt; . Существование результирующего &lt;code&gt;Ptr&lt;/code&gt; не защитит объект от сборки мусора, поэтому вы должны убедиться, что объект остается ссылкой на все время, пока будет использоваться &lt;code&gt;Ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563766b2618b2d015ed0e9c3d29a5e7becea72bb" translate="yes" xml:space="preserve">
          <source>Get the name of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt; (without its parent module) as a symbol.</source>
          <target state="translated">Получить имя (потенциально &lt;code&gt;UnionAll&lt;/code&gt; -wrapped) &lt;code&gt;DataType&lt;/code&gt; (без родительского модуля) в качестве символа.</target>
        </trans-unit>
        <trans-unit id="52de91388eb956065955884b6eac39cce6e61088" translate="yes" xml:space="preserve">
          <source>Get the name of a &lt;code&gt;Module&lt;/code&gt; as a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Получите имя &lt;code&gt;Module&lt;/code&gt; как &lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8a8ebbac78211cc23fd2af9d0c3c21bb5d703fa" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol, or &lt;code&gt;:anonymous&lt;/code&gt;.</source>
          <target state="translated">Получите имя универсальной &lt;code&gt;Function&lt;/code&gt; в виде символа или &lt;code&gt;:anonymous&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64e061910a8b5067e4b872f11bbe2bcd37fe4b98" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of &lt;code&gt;Function&lt;/code&gt;, it is the name of the function's type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5308e8edde6c7f90f89dc8b80d1be8f9e4aed1b" translate="yes" xml:space="preserve">
          <source>Get the name of a remote repository, for instance &lt;code&gt;&quot;origin&quot;&lt;/code&gt;. If the remote is anonymous (see &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt;&lt;code&gt;GitRemoteAnon&lt;/code&gt;&lt;/a&gt;) the name will be an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Получите имя удаленного репозитория, например &lt;code&gt;&quot;origin&quot;&lt;/code&gt; . Если пульт анонимный (см. &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt; &lt;code&gt;GitRemoteAnon&lt;/code&gt; &lt;/a&gt; ), имя будет пустой строкой &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9cf8794c830b5b5477bd4dd5127e438a0a336f9" translate="yes" xml:space="preserve">
          <source>Get the name of field &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">Получите имя поля &lt;code&gt;i&lt;/code&gt; типа &lt;code&gt;DataType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f05b4e05331b196f379ecdeee8aa391e63dd1631" translate="yes" xml:space="preserve">
          <source>Get the native address of an array or string, optionally at a given location &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Получить собственный адрес массива или строки, необязательно по заданному &lt;code&gt;index&lt;/code&gt; местоположения .</target>
        </trans-unit>
        <trans-unit id="67e6a2296c5e9b9545d8ce6e5fe670e01fcb2193" translate="yes" xml:space="preserve">
          <source>Get the number of available processes.</source>
          <target state="translated">Получить количество доступных процессов.</target>
        </trans-unit>
        <trans-unit id="6c54bfd12378fd187e6fdf88c8f9a891fd352b8a" translate="yes" xml:space="preserve">
          <source>Get the number of available worker processes. This is one less than &lt;a href=&quot;#Distributed.nprocs&quot;&gt;&lt;code&gt;nprocs()&lt;/code&gt;&lt;/a&gt;. Equal to &lt;code&gt;nprocs()&lt;/code&gt; if &lt;code&gt;nprocs() == 1&lt;/code&gt;.</source>
          <target state="translated">Получите количество доступных рабочих процессов. Это на единицу меньше, чем &lt;a href=&quot;#Distributed.nprocs&quot;&gt; &lt;code&gt;nprocs()&lt;/code&gt; &lt;/a&gt; . Равно &lt;code&gt;nprocs()&lt;/code&gt; если &lt;code&gt;nprocs() == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d316efb69571072b7b698b64013b0df989b23e2" translate="yes" xml:space="preserve">
          <source>Get the number of fields in the given object.</source>
          <target state="translated">Получить количество полей в данном объекте.</target>
        </trans-unit>
        <trans-unit id="a93c91e8128e4c3c8ef281740f30c00304272fd2" translate="yes" xml:space="preserve">
          <source>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</source>
          <target state="translated">Получить количество полей,которое будет иметь экземпляр данного типа.Бросается ошибка,если тип слишком абстрактен,чтобы определить это.</target>
        </trans-unit>
        <trans-unit id="8783ebd0cc15f38c2e971a316cd9c7666dbba9ce" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;a href=&quot;#Base.Threads.threadid&quot;&gt;&lt;code&gt;threadid()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3677eab3b97fd3c65939b3bc5a15f59d44d4af9" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;code&gt;threadid()&lt;/code&gt;.</source>
          <target state="translated">Получите количество потоков, доступных процессу Julia. Это исчерпывающая верхняя граница &lt;code&gt;threadid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b55f78480b3149c80bfc50e1a7d85e6fa50c73b" translate="yes" xml:space="preserve">
          <source>Get the permissions of the owner of the file as a bitfield of</source>
          <target state="translated">Получить права владельца файла в виде битового поля</target>
        </trans-unit>
        <trans-unit id="c5f291709146a9a504c67d3dc2b280d4f865a715" translate="yes" xml:space="preserve">
          <source>Get the precision (in bits) currently used for &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; arithmetic.</source>
          <target state="translated">Получите точность (в битах), используемую в настоящее время для арифметики &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ec48750990030ca792131bcde102c3d937ba66e" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</source>
          <target state="translated">Получить точность числа с плавающей точкой,определяемого эффективным количеством битов в мантиссе.</target>
        </trans-unit>
        <trans-unit id="c82750d28bc29a3941ba9c542817da0f2854ea45" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the significand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a1d9961dcbce8522f507a9d605791c91380396" translate="yes" xml:space="preserve">
          <source>Get the process title. On some systems, will always return an empty string.</source>
          <target state="translated">Получите название процесса.На некоторых системах всегда возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="8d97afd1ec5aab5d2f47ff664bcaf7b5f14afb9a" translate="yes" xml:space="preserve">
          <source>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of &lt;code&gt;(exception,backtrace)&lt;/code&gt; pairs, or a Vector of exceptions if &lt;code&gt;include_bt&lt;/code&gt; is false.</source>
          <target state="translated">Получить стек обрабатываемых в настоящее время исключений. Для вложенных блоков catch может быть несколько текущих исключений, и в этом случае последнее выброшенное исключение будет последним в стеке. Стек возвращается как вектор пар &lt;code&gt;(exception,backtrace)&lt;/code&gt; или вектор исключений, если &lt;code&gt;include_bt&lt;/code&gt; имеет значение false.</target>
        </trans-unit>
        <trans-unit id="857485ff0b5ba0b2460dd06bb700b67ed684fb9b" translate="yes" xml:space="preserve">
          <source>Get the stage number of &lt;code&gt;ie&lt;/code&gt;. The stage number &lt;code&gt;0&lt;/code&gt; represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an &lt;code&gt;IndexEntry&lt;/code&gt; describe which side(s) of the conflict the current state of the file belongs to. Stage &lt;code&gt;0&lt;/code&gt; is the state before the attempted merge, stage &lt;code&gt;1&lt;/code&gt; is the changes which have been made locally, stages &lt;code&gt;2&lt;/code&gt; and larger are for changes from other branches (for instance, in the case of a multi-branch &quot;octopus&quot; merge, stages &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;4&lt;/code&gt; might be used).</source>
          <target state="translated">Получить сценическое число &lt;code&gt;ie&lt;/code&gt; . Номер этапа &lt;code&gt;0&lt;/code&gt; представляет текущее состояние рабочего дерева, но в случае конфликта слияния можно использовать другие числа. В таком случае различные номера &lt;code&gt;IndexEntry&lt;/code&gt; в IndexEntry описывают, к какой стороне (сторонам) конфликта принадлежит текущее состояние файла. Этап &lt;code&gt;0&lt;/code&gt; - это состояние до попытки слияния, этап &lt;code&gt;1&lt;/code&gt; - это изменения, которые были сделаны локально, этапы &lt;code&gt;2&lt;/code&gt; и выше предназначены для изменений из других ветвей (например, в случае слияния &amp;laquo;осьминога&amp;raquo; с несколькими ветвями, этапы &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; и &lt;code&gt;4&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="129f24b071e084dab9af722a0959ecf2337e059d" translate="yes" xml:space="preserve">
          <source>Get the step size of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Получите размер шага объекта &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8858aa789b8a95e917ca5b8edf3cb4cfb4672953" translate="yes" xml:space="preserve">
          <source>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</source>
          <target state="translated">Получить системное время в секундах от эпохи,с довольно высоким (обычно микросекундным)разрешением.</target>
        </trans-unit>
        <trans-unit id="95239b12c16c016f41ece1f43f66824450caaa42" translate="yes" xml:space="preserve">
          <source>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</source>
          <target state="translated">Получить время в наносекундах.Время,соответствующее 0,не определено,и обертывается каждые 5,8 лет.</target>
        </trans-unit>
        <trans-unit id="860a244a52c686caf400b1420fb67fb1c70889f7" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24f1d764ec96114bfff224327fcd8d0d0abdd31" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in kilobytes.</source>
          <target state="translated">Получить полную свободную память в оперативной памяти в килобайтах.</target>
        </trans-unit>
        <trans-unit id="2891099c5c8dc8b6402c7d53caeef5e0b9cc1707" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e4ce0e0a7ea7ef86f926adb946a71d925d5beb" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in kilobytes.</source>
          <target state="translated">Получить суммарную память в оперативной памяти (включая используемую в настоящее время)в килобайтах.</target>
        </trans-unit>
        <trans-unit id="e98e2a89d68b00f3fd77d6a63a6d2c70dc724cf3" translate="yes" xml:space="preserve">
          <source>Get the value of the C library's &lt;code&gt;errno&lt;/code&gt;. If an argument is specified, it is used to set the value of &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">Получить значение библиотеки C в &lt;code&gt;errno&lt;/code&gt; . Если аргумент указан, он используется для установки значения &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2268d21fbee620aaff052e88aa0c0825d399931" translate="yes" xml:space="preserve">
          <source>Get the value type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Получить тип значения типа словаря. Ведет себя аналогично &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8ca9fec9f5e29ac3cbc1f3abc652c135b52ec1" translate="yes" xml:space="preserve">
          <source>Get the vector of processes mapping the shared array.</source>
          <target state="translated">Получить вектор процессов,отображающих общий массив.</target>
        </trans-unit>
        <trans-unit id="db2afe93edd474fc522d8c7d75cb7a001e5b61fe" translate="yes" xml:space="preserve">
          <source>Gets all of the IP addresses of the &lt;code&gt;host&lt;/code&gt;. Uses the operating system's underlying &lt;code&gt;getaddrinfo&lt;/code&gt; implementation, which may do a DNS lookup.</source>
          <target state="translated">Получает все IP-адреса &lt;code&gt;host&lt;/code&gt; . Использует базовую реализацию &lt;code&gt;getaddrinfo&lt;/code&gt; операционной системы , которая может выполнять поиск в DNS.</target>
        </trans-unit>
        <trans-unit id="a284592991f22190fd532a8317fc543ce797cfe4" translate="yes" xml:space="preserve">
          <source>Gets the first IP address of the &lt;code&gt;host&lt;/code&gt; of the specified &lt;code&gt;IPAddr&lt;/code&gt; type. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.</source>
          <target state="translated">Получает первый IP-адрес &lt;code&gt;host&lt;/code&gt; указанного типа &lt;code&gt;IPAddr&lt;/code&gt; . Использует базовую реализацию getaddrinfo операционной системы, которая может выполнять поиск в DNS.</target>
        </trans-unit>
        <trans-unit id="846899bbba33d15c0dd1bf73665c2578909867ff" translate="yes" xml:space="preserve">
          <source>Gets the path of the temporary directory. On Windows, &lt;code&gt;tempdir()&lt;/code&gt; uses the first environment variable found in the ordered list &lt;code&gt;TMP&lt;/code&gt;, &lt;code&gt;TEMP&lt;/code&gt;, &lt;code&gt;USERPROFILE&lt;/code&gt;. On all other operating systems, &lt;code&gt;tempdir()&lt;/code&gt; uses the first environment variable found in the ordered list &lt;code&gt;TMPDIR&lt;/code&gt;, &lt;code&gt;TMP&lt;/code&gt;, &lt;code&gt;TEMP&lt;/code&gt;, and &lt;code&gt;TEMPDIR&lt;/code&gt;. If none of these are found, the path &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3acf6ca590093170d5ddc3c9107d6f1324074" translate="yes" xml:space="preserve">
          <source>Getting Around</source>
          <target state="translated">Обход</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="04ccf152a8a13833ef0a70fb0a973a671f0ea746" translate="yes" xml:space="preserve">
          <source>Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a &lt;code&gt;QuoteNode&lt;/code&gt; or other similar &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;. Some examples of this include &lt;code&gt;@task body&lt;/code&gt; which simply returns &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt;, and &lt;code&gt;@eval expr&lt;/code&gt;, which simply returns &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt;.</source>
          <target state="translated">Соблюдение правил гигиены может оказаться непростой задачей. Прежде чем использовать макрос, вы можете подумать, достаточно ли закрытия функции. Еще одна полезная стратегия - отложить как можно больше работы на время выполнения. Например, многие макросы просто &lt;code&gt;QuoteNode&lt;/code&gt; свои аргументы в QuoteNode или другое подобное &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; . Некоторые примеры этого включают &lt;code&gt;@task body&lt;/code&gt; , которое просто возвращает &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt; , и &lt;code&gt;@eval expr&lt;/code&gt; , которое просто возвращает &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf44c9857b696454c5ef1ca708da5e3ee8a0b24a" translate="yes" xml:space="preserve">
          <source>Ghost</source>
          <target state="translated">Ghost</target>
        </trans-unit>
        <trans-unit id="4a4c89342a61073746cb0be5c482a4f233f70856" translate="yes" xml:space="preserve">
          <source>Gimel Symbol / Third Transfinite Cardinal</source>
          <target state="translated">Символ Гимеля/Третий кардинал с переводом денежных знаков</target>
        </trans-unit>
        <trans-unit id="29fb58174b748291968c938f5144e432d7a05bc1" translate="yes" xml:space="preserve">
          <source>Girl</source>
          <target state="translated">Girl</target>
        </trans-unit>
        <trans-unit id="d1acb2e33d2070c77075991c4c8d8d1a063d6fb4" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that it should not inline a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585f3a3c7ecf6be9b08fcb5c41bd3f7b4064386b" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that this function is worth inlining.</source>
          <target state="translated">Дайте подсказку компилятору,что эта функция заслуживает внимания.</target>
        </trans-unit>
        <trans-unit id="f9f77d5a362582fb87b0f06e19b1b57c8b1806c3" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a character.</source>
          <target state="translated">Дайте количество столбцов,необходимых для печати символа.</target>
        </trans-unit>
        <trans-unit id="d66cd5d2057c5b56255474647800cbbea7c7ec15" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a string.</source>
          <target state="translated">Дайте количество столбцов,необходимое для печати строки.</target>
        </trans-unit>
        <trans-unit id="a34ffde7989d779a84306150562bbcc334bb927c" translate="yes" xml:space="preserve">
          <source>Given a 2-argument function &lt;code&gt;f&lt;/code&gt; and an iterator &lt;code&gt;itr&lt;/code&gt;, return a new iterator that successively applies &lt;code&gt;f&lt;/code&gt; to the previous value and the next element of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990b49394e3cec090496333dd6dda71ca867283b" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;-like function &lt;code&gt;writefunc&lt;/code&gt;, which takes an I/O stream as its first argument, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; calls &lt;code&gt;writefunc&lt;/code&gt; to write &lt;code&gt;args...&lt;/code&gt; to a base64-encoded string, and returns the string. &lt;code&gt;base64encode(args...)&lt;/code&gt; is equivalent to &lt;code&gt;base64encode(write, args...)&lt;/code&gt;: it converts its arguments into bytes using the standard &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; functions and returns the base64-encoded string.</source>
          <target state="translated">Учитывая &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; -like функции &lt;code&gt;writefunc&lt;/code&gt; , который принимает потоки ввода / вывода в качестве первого аргумента, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; называет &lt;code&gt;writefunc&lt;/code&gt; писать &lt;code&gt;args...&lt;/code&gt; в строку base64 кодировке, и возвращает строку. &lt;code&gt;base64encode(args...)&lt;/code&gt; эквивалентен &lt;code&gt;base64encode(write, args...)&lt;/code&gt; : он преобразует свои аргументы в байты с помощью стандартных функций &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; и возвращает строку в кодировке base64.</target>
        </trans-unit>
        <trans-unit id="f3d33bb8ba673cca2a309308e1c04181d32a390f" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;Ptr{T}&lt;/code&gt;, the contents of type &lt;code&gt;T&lt;/code&gt; can generally be copied from the referenced memory into a Julia object using &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt;. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;[]&lt;/code&gt; access syntax).</source>
          <target state="translated">Учитывая &lt;code&gt;Ptr{T}&lt;/code&gt; , содержимое типа &lt;code&gt;T&lt;/code&gt; обычно можно скопировать из указанной памяти в объект Julia с помощью &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt; . Аргумент index является необязательным (по умолчанию - 1) и следует соглашению Julia об индексировании на основе 1. Эта функция намеренно аналогична поведению &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; (например, синтаксис доступа &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9276b00b5b100003171aa4d1b53dddc58e924e43" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">Учитывая тип коллекции &lt;code&gt;S&lt;/code&gt; , в настоящее время предполагается, что если определен &lt;code&gt;rand(::S)&lt;/code&gt; будет создан объект типа &lt;code&gt;eltype(S)&lt;/code&gt; . Чтобы определить случайную генерацию из объектов типа &lt;code&gt;S&lt;/code&gt; , можно определить следующий метод: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; . Здесь &lt;code&gt;sp&lt;/code&gt; просто обертывает объект типа &lt;code&gt;S&lt;/code&gt; , доступ к которому можно получить через &lt;code&gt;sp[]&lt;/code&gt; . Продолжая пример &lt;code&gt;Die&lt;/code&gt; , мы хотим теперь определить &lt;code&gt;rand(d::Die)&lt;/code&gt; для создания &lt;code&gt;Int&lt;/code&gt; , соответствующего одной из сторон &lt;code&gt;d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="700a876db14031cb467cacd249ca9851d58258cb" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f1730c953eabcee66d16110ac2417f817ee88b" translate="yes" xml:space="preserve">
          <source>Given a dictionary &lt;code&gt;D&lt;/code&gt;, the syntax &lt;code&gt;D[x]&lt;/code&gt; returns the value of key &lt;code&gt;x&lt;/code&gt; (if it exists) or throws an error, and &lt;code&gt;D[x] = y&lt;/code&gt; stores the key-value pair &lt;code&gt;x =&amp;gt; y&lt;/code&gt; in &lt;code&gt;D&lt;/code&gt; (replacing any existing value for the key &lt;code&gt;x&lt;/code&gt;). Multiple arguments to &lt;code&gt;D[...]&lt;/code&gt; are converted to tuples; for example, the syntax &lt;code&gt;D[x,y]&lt;/code&gt; is equivalent to &lt;code&gt;D[(x,y)]&lt;/code&gt;, i.e. it refers to the value keyed by the tuple &lt;code&gt;(x,y)&lt;/code&gt;.</source>
          <target state="translated">Учитывая словарь &lt;code&gt;D&lt;/code&gt; , синтаксис &lt;code&gt;D[x]&lt;/code&gt; возвращает значение ключа &lt;code&gt;x&lt;/code&gt; (если он существует) или выдает ошибку, а &lt;code&gt;D[x] = y&lt;/code&gt; сохраняет пару ключ-значение &lt;code&gt;x =&amp;gt; y&lt;/code&gt; в &lt;code&gt;D&lt;/code&gt; (заменяя любые существующие значение для ключа &lt;code&gt;x&lt;/code&gt; ). Несколько аргументов &lt;code&gt;D[...]&lt;/code&gt; преобразуются в кортежи; например, синтаксис &lt;code&gt;D[x,y]&lt;/code&gt; эквивалентен &lt;code&gt;D[(x,y)]&lt;/code&gt; , т. е. он относится к значению, содержащему ключ кортежа &lt;code&gt;(x,y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0b3c9a8cb5b6bf41774ca0094396ad324bf5391" translate="yes" xml:space="preserve">
          <source>Given a library &lt;code&gt;handle&lt;/code&gt; from &lt;code&gt;dlopen&lt;/code&gt;, return the full path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aeb65e7ccb967c9455ef2f486079851e21e2b6b" translate="yes" xml:space="preserve">
          <source>Given a pointer to an execution context (usually generated by a call to &lt;code&gt;backtrace&lt;/code&gt;), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.</source>
          <target state="translated">Получив указатель на контекст выполнения (обычно генерируемый вызовом &lt;code&gt;backtrace&lt;/code&gt; ), ищет информацию о контексте кадра стека. Возвращает массив информации о фрейме для всех функций, встроенных в этот момент, начиная с самой внутренней функции.</target>
        </trans-unit>
        <trans-unit id="fcada796f1c4aca1cfb31ae96c64d212e649ecf0" translate="yes" xml:space="preserve">
          <source>Given a predicate function &lt;code&gt;flt&lt;/code&gt; and an iterable object &lt;code&gt;itr&lt;/code&gt;, return an iterable object which upon iteration yields the elements &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;itr&lt;/code&gt; that satisfy &lt;code&gt;flt(x)&lt;/code&gt;. The order of the original iterator is preserved.</source>
          <target state="translated">Принимая во внимание предикат функции &lt;code&gt;flt&lt;/code&gt; и итератора объект &lt;code&gt;itr&lt;/code&gt; , возвращает объект итератора , который при итерации дает элементы &lt;code&gt;x&lt;/code&gt; из &lt;code&gt;itr&lt;/code&gt; , которые удовлетворяют условию &lt;code&gt;flt(x)&lt;/code&gt; . Порядок исходного итератора сохраняется.</target>
        </trans-unit>
        <trans-unit id="c16f746a1658b9d1859c84c436dc50bdb9fe0a85" translate="yes" xml:space="preserve">
          <source>Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace &lt;code&gt;data&lt;/code&gt; obtained from &lt;a href=&quot;#Profile.retrieve&quot;&gt;&lt;code&gt;retrieve&lt;/code&gt;&lt;/a&gt;; otherwise, the current internal profile buffer is used.</source>
          <target state="translated">Учитывая предыдущий прогон профилирования, определите, кто вызвал конкретную функцию. Указание имени файла (и, возможно, диапазона номеров строк, в которых определяется функция) позволяет устранить неоднозначность перегруженного метода. Возвращаемое значение - это вектор, содержащий счетчик количества вызовов и информацию о линии о вызывающем абоненте. При желании можно предоставить &lt;code&gt;data&lt;/code&gt; обратной трассировки, полученные при &lt;a href=&quot;#Profile.retrieve&quot;&gt; &lt;code&gt;retrieve&lt;/code&gt; &lt;/a&gt; ; в противном случае используется текущий внутренний буфер профиля.</target>
        </trans-unit>
        <trans-unit id="67104b7201b61b9623c8478911e24c6cfc8b97bc" translate="yes" xml:space="preserve">
          <source>Given a single iterable argument, constructs a &lt;a href=&quot;#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt; whose key-value pairs are taken from 2-tuples &lt;code&gt;(key,value)&lt;/code&gt; generated by the argument.</source>
          <target state="translated">Для одного итеративного аргумента создает &lt;a href=&quot;#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; , пары ключ-значение которого берутся из двух кортежей &lt;code&gt;(key,value)&lt;/code&gt; сгенерированных аргументом.</target>
        </trans-unit>
        <trans-unit id="a19217b165ec900e8bae935104c81bb7e032d599" translate="yes" xml:space="preserve">
          <source>Given a starting value, construct a range either by length or from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt;, optionally with a given step (defaults to 1, a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;). One of &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; is required. If &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; are all specified, they must agree.</source>
          <target state="translated">Учитывая начальное значение, построить диапазон либо по длине или от &lt;code&gt;start&lt;/code&gt; до &lt;code&gt;stop&lt;/code&gt; , при необходимости с заданным шагом ( по умолчанию 1, а &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; ). Требуется одна &lt;code&gt;length&lt;/code&gt; или &lt;code&gt;stop&lt;/code&gt; . Если указаны &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; и &lt;code&gt;step&lt;/code&gt; , они должны быть согласованы.</target>
        </trans-unit>
        <trans-unit id="e6bf5e1364f77d196c7b9a51bb62bde8f133bcde" translate="yes" xml:space="preserve">
          <source>Given a string or array &lt;code&gt;s&lt;/code&gt; of ASCII codes for a sequence of hexadecimal digits, returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of bytes corresponding to the binary representation: each successive pair of hexadecimal digits in &lt;code&gt;s&lt;/code&gt; gives the value of one byte in the return vector.</source>
          <target state="translated">Учитывая строку или массив &lt;code&gt;s&lt;/code&gt; кодов ASCII для последовательности шестнадцатеричных цифр, возвращает &lt;code&gt;Vector{UInt8}&lt;/code&gt; байтов, соответствующий двоичному представлению: каждая последующая пара шестнадцатеричных цифр в &lt;code&gt;s&lt;/code&gt; дает значение одного байта в векторе возврата.</target>
        </trans-unit>
        <trans-unit id="b539dd0aaced1e1e9c21b2db4d99090ee705b0d2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. &lt;code&gt;SamplerType&lt;/code&gt; is the &lt;em&gt;default sampler for types&lt;/em&gt;. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; method should be defined, and should return values what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6a85425c1e72a27deafaba610d488a3457e0f2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (this should return what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return).</source>
          <target state="translated">С учетом типа &lt;code&gt;T&lt;/code&gt; , это в настоящее время предполагается , что если &lt;code&gt;rand(T)&lt;/code&gt; определяется, объект типа &lt;code&gt;T&lt;/code&gt; будет выпускаться. Чтобы определить случайную генерацию значений типа &lt;code&gt;T&lt;/code&gt; , можно определить следующий метод: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (это должно вернуть то, что &lt;code&gt;rand(rng, T)&lt;/code&gt; как ожидается, будет возвращать rand (rng, T) ).</target>
        </trans-unit>
        <trans-unit id="60e4af8cc8de60ffb69850d252bdcd98ee3d2bfa" translate="yes" xml:space="preserve">
          <source>Given an AbstractArray &lt;code&gt;A&lt;/code&gt;, create a view &lt;code&gt;B&lt;/code&gt; such that the dimensions appear to be permuted. Similar to &lt;code&gt;permutedims&lt;/code&gt;, except that no copying occurs (&lt;code&gt;B&lt;/code&gt; shares storage with &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">Учитывая AbstractArray &lt;code&gt;A&lt;/code&gt; , создайте представление &lt;code&gt;B&lt;/code&gt; так, чтобы измерения казались переставленными. Подобно &lt;code&gt;permutedims&lt;/code&gt; , за исключением того, что копирование не происходит ( &lt;code&gt;B&lt;/code&gt; разделяет хранилище с &lt;code&gt;A&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2273302d369651afdbde86cc33fa4cfcb401046e" translate="yes" xml:space="preserve">
          <source>Given an expression object, one can cause Julia to evaluate (execute) it at global scope using &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Учитывая объект выражения, можно заставить Джулию оценить (выполнить) его в глобальной области с помощью &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b05155f37fd5b5acf7427c2b96abcb47e059d8f8" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse(v)&lt;/code&gt;&lt;/a&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc48e1bcaa064479ac3ce6a9aad0b807686849" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;reverse(v)&lt;/code&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="translated">Дан индекс &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;reverse(v)&lt;/code&gt; , верните соответствующий индекс в &lt;code&gt;v&lt;/code&gt; , чтобы &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt; . (Это может быть нетривиально в случаях, когда &lt;code&gt;v&lt;/code&gt; содержит символы, отличные от ASCII.)</target>
        </trans-unit>
        <trans-unit id="214692258e5d3f03bf0e19a0c7bce6fe690232a0" translate="yes" xml:space="preserve">
          <source>Given an iterator &lt;code&gt;itr&lt;/code&gt;, then &lt;code&gt;reverse(itr)&lt;/code&gt; is an iterator over the same collection but in the reverse order.</source>
          <target state="translated">Если &lt;code&gt;itr&lt;/code&gt; итератор itr , то &lt;code&gt;reverse(itr)&lt;/code&gt; является итератором для той же коллекции, но в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="089e5e83e8607aed09695c30f3dd1c60f5798574" translate="yes" xml:space="preserve">
          <source>Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.</source>
          <target state="translated">Получив итератор,который дает итераторы,верните итератор,который дает элементы этих итераторов.По-другому говоря,элементы итератора аргумента сводятся воедино.</target>
        </trans-unit>
        <trans-unit id="3c9b417cfac83aea8a69f80d6bc8cf9a41f8a58a" translate="yes" xml:space="preserve">
          <source>Given such a declaration, for each choice of &lt;code&gt;T&lt;/code&gt;, we have &lt;code&gt;Point{T}&lt;/code&gt; as a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt;:</source>
          <target state="translated">Учитывая такое объявление, для каждого выбора &lt;code&gt;T&lt;/code&gt; у нас есть &lt;code&gt;Point{T}&lt;/code&gt; как подтип &lt;code&gt;Pointy{T}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d716647091cd161029df5d10c16015ae51186d66" translate="yes" xml:space="preserve">
          <source>Given the git configuration file containing:</source>
          <target state="translated">Учитывая содержимое конфигурационного файла git'а:</target>
        </trans-unit>
        <trans-unit id="915ac53cd4c78783b139cec5dd22b4b42ed2b99a" translate="yes" xml:space="preserve">
          <source>Given the statement &lt;code&gt;using Foo&lt;/code&gt;, the system consults an internal table of top-level modules to look for one named &lt;code&gt;Foo&lt;/code&gt;. If the module does not exist, the system attempts to &lt;code&gt;require(:Foo)&lt;/code&gt;, which typically results in loading code from an installed package.</source>
          <target state="translated">Учитывая оператор, &lt;code&gt;using Foo&lt;/code&gt; , система обращается к внутренней таблице модулей верхнего уровня, чтобы найти модуль с именем &lt;code&gt;Foo&lt;/code&gt; . Если модуль не существует, система пытается &lt;code&gt;require(:Foo)&lt;/code&gt; , что обычно приводит к загрузке кода из установленного пакета.</target>
        </trans-unit>
        <trans-unit id="06fe662af1da02e3f2ea7cf7081d137d14c1ea88" translate="yes" xml:space="preserve">
          <source>Given the type of an iterator, return one of the following values:</source>
          <target state="translated">Учитывая тип итератора,верните одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="712fa051470c666b0b3c1cf4e1eb3b5cdf800a89" translate="yes" xml:space="preserve">
          <source>Given this dependency &lt;code&gt;graph&lt;/code&gt;, when Julia sees &lt;code&gt;import Priv&lt;/code&gt; in the &lt;code&gt;Pub&lt;/code&gt; package&amp;mdash;which has UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt;&amp;mdash;it looks up:</source>
          <target state="translated">Учитывая этот &lt;code&gt;graph&lt;/code&gt; зависимостей , когда Джулия видит &lt;code&gt;import Priv&lt;/code&gt; в пакете &lt;code&gt;Pub&lt;/code&gt; , который имеет UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt; ,он ищет:</target>
        </trans-unit>
        <trans-unit id="617b3c70bd8eb4654d1000dde442b1913a3d57c6" translate="yes" xml:space="preserve">
          <source>Given this roots map, in &lt;code&gt;App&lt;/code&gt;'s code the statement &lt;code&gt;import Priv&lt;/code&gt; will cause Julia to look up &lt;code&gt;roots[:Priv]&lt;/code&gt;, which yields &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;, the UUID of the &lt;code&gt;Priv&lt;/code&gt; package that is to be loaded in that context. This UUID identifies which &lt;code&gt;Priv&lt;/code&gt; package to load and use when the main application evaluates &lt;code&gt;import Priv&lt;/code&gt;.</source>
          <target state="translated">Учитывая эти корни на карту, в &lt;code&gt;App&lt;/code&gt; коды &amp;laquo;s заявление &lt;code&gt;import Priv&lt;/code&gt; заставит Джулию искать &lt;code&gt;roots[:Priv]&lt;/code&gt; , что дает &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; , то UUID из &lt;code&gt;Priv&lt;/code&gt; пакета , который должен быть загружен в в этом контексте. Этот UUID определяет, какой пакет &lt;code&gt;Priv&lt;/code&gt; загружать и использовать, когда основное приложение оценивает &lt;code&gt;import Priv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b509e583621052cb07bc486839dfdb1f16ed86dc" translate="yes" xml:space="preserve">
          <source>Global Scope</source>
          <target state="translated">Глобальный масштаб</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">Глобальные переменные</target>
        </trans-unit>
        <trans-unit id="40501a9e5007169fb629c5387c4f8fb6e999c42d" translate="yes" xml:space="preserve">
          <source>Global constants are declared as constants on remote nodes too.</source>
          <target state="translated">Глобальные константы объявляются константами и на удаленных узлах.</target>
        </trans-unit>
        <trans-unit id="389f13ca82ff7a2453bc65e6b170fb5bce0e7be4" translate="yes" xml:space="preserve">
          <source>Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</source>
          <target state="translated">Глобальные счетчики (например,для попыток уникальной идентификации объектов).Рассмотрим следующий фрагмент кода:</target>
        </trans-unit>
        <trans-unit id="9f22cff33a2ca414f07ad83aad20cf6de8acaeaf" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard error stream.</source>
          <target state="translated">Глобальная переменная,относящаяся к стандартному потоку ошибок.</target>
        </trans-unit>
        <trans-unit id="9aa21a682323865a22d83920da0f441d6c030675" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard input stream.</source>
          <target state="translated">Глобальная переменная,относящаяся к стандартному входному потоку.</target>
        </trans-unit>
        <trans-unit id="51d6faf5f0e0e6c01ea9efaf0aad4dbd11c26673" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard out stream.</source>
          <target state="translated">Глобальная переменная,относящаяся к стандартному внешнему потоку.</target>
        </trans-unit>
        <trans-unit id="70ae8e14e7d7a8122e7468fd602556f9b4388301" translate="yes" xml:space="preserve">
          <source>Global variables</source>
          <target state="translated">Глобальные переменные</target>
        </trans-unit>
        <trans-unit id="7d6e1e2bd4cbe556d039d09149551410bf54cb41" translate="yes" xml:space="preserve">
          <source>Global variables exported by native libraries can be accessed by name using the &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; function. The arguments to &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; are a symbol specification identical to that used by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, and a type describing the value stored in the variable:</source>
          <target state="translated">Доступ к глобальным переменным, экспортируемым собственными библиотеками, можно получить по имени с &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; функции cglobal . Аргументы для &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; - это спецификация символа, идентичная той, что используется &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , и тип, описывающий значение, хранящееся в переменной:</target>
        </trans-unit>
        <trans-unit id="d02d943210f33ec6146b40f17e3a1be495a87492" translate="yes" xml:space="preserve">
          <source>Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:</source>
          <target state="translated">Глобусы пересылаются в адрес получателя только в контексте удаленного вызова,а затем только в том случае,если его значение изменилось.Также,кластер не синхронизирует глобальные привязки между узлами.Например:</target>
        </trans-unit>
        <trans-unit id="fb02a2aa39a487184ec2e48cce6d9541aa570f94" translate="yes" xml:space="preserve">
          <source>Globals under modules other than &lt;code&gt;Main&lt;/code&gt; are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under &lt;code&gt;Main&lt;/code&gt;) may cause an &lt;code&gt;UndefVarError&lt;/code&gt; to be thrown later.</source>
          <target state="translated">Глобальные объекты в модулях, отличных от &lt;code&gt;Main&lt;/code&gt; , не сериализуются по значению для удаленного узла. Присылается только справка. Функции, которые создают глобальные привязки (кроме &lt;code&gt;Main&lt;/code&gt; ), могут позже вызвать &lt;code&gt;UndefVarError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd336be94f1ee162a48e523127d9e5b06609fb8" translate="yes" xml:space="preserve">
          <source>Globe With Meridians</source>
          <target state="translated">Глобус с меридианами</target>
        </trans-unit>
        <trans-unit id="bf6d33bf807dc90549a0d0bac64e3cc4b4bb46ed" translate="yes" xml:space="preserve">
          <source>Glowing Star</source>
          <target state="translated">Светящаяся звезда</target>
        </trans-unit>
        <trans-unit id="0e3f5fc25846b7ffc7fbf7ea4a19522f60c6c683" translate="yes" xml:space="preserve">
          <source>Goat</source>
          <target state="translated">Goat</target>
        </trans-unit>
        <trans-unit id="e10a82a4acb4738d8b41ab1910aa292204041524" translate="yes" xml:space="preserve">
          <source>Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization. We call our custom sampler &lt;code&gt;SamplerDie&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
