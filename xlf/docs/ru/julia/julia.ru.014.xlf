<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="5ab646baedc9dd22f188651743d4f15248da82d7" translate="yes" xml:space="preserve">
          <source>Surface Integral</source>
          <target state="translated">Интеграл поверхности</target>
        </trans-unit>
        <trans-unit id="17daa74b4ef9134312485788d9f1641a90336c0f" translate="yes" xml:space="preserve">
          <source>Surfer</source>
          <target state="translated">Surfer</target>
        </trans-unit>
        <trans-unit id="c8c7bd468d1aa59989cc45f0885429f1cf6ed2c3" translate="yes" xml:space="preserve">
          <source>Surround text that should be displayed as mathematics using $\LaTeX$ syntax with double backticks, &lt;code&gt;``&lt;/code&gt; .</source>
          <target state="translated">Окружающий текст, который должен отображаться как математика с использованием синтаксиса $ \ LaTeX $, с двойными обратными кавычками, &lt;code&gt;``&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92a7b6e5715227886b18e3f8f91b9c36dfc5369e" translate="yes" xml:space="preserve">
          <source>Surround text that should be displayed exactly as written with single backticks, &lt;code&gt;`&lt;/code&gt; .</source>
          <target state="translated">Окружающий текст, который должен отображаться точно так, как написано, с одинарными обратными кавычками, &lt;code&gt;`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83bffe5f5bc6bf97e1966b45cd2db4c1bcc58652" translate="yes" xml:space="preserve">
          <source>Surround words with one asterisk, &lt;code&gt;*&lt;/code&gt;, to display the enclosed text in italics.</source>
          <target state="translated">Окружите слова одной звездочкой &lt;code&gt;*&lt;/code&gt; , чтобы текст, заключенный в них, был выделен курсивом.</target>
        </trans-unit>
        <trans-unit id="3a1145c55802eb89506200bd2ff9a16655c333b8" translate="yes" xml:space="preserve">
          <source>Surround words with two asterisks, &lt;code&gt;**&lt;/code&gt;, to display the enclosed text in boldface.</source>
          <target state="translated">Окружите слова двумя звездочками &lt;code&gt;**&lt;/code&gt; , чтобы текст, заключенный в них, был выделен жирным шрифтом.</target>
        </trans-unit>
        <trans-unit id="25e2d663550b8401fc89f3e8e446533086519e41" translate="yes" xml:space="preserve">
          <source>Sushi</source>
          <target state="translated">Sushi</target>
        </trans-unit>
        <trans-unit id="4b69a79697ed3f157a8f14b72eb302695d487ae6" translate="yes" xml:space="preserve">
          <source>Suspends execution for &lt;code&gt;s&lt;/code&gt; seconds. This function does not yield to Julia's scheduler and therefore blocks the Julia thread that it is running on for the duration of the sleep time.</source>
          <target state="translated">Приостанавливает выполнение на &lt;code&gt;s&lt;/code&gt; секунд. Эта функция не уступает планировщику Джулии и поэтому блокирует поток Джулии, в котором он работает, на время ожидания.</target>
        </trans-unit>
        <trans-unit id="973888c30a491df5bbae163d9bc214c808d088f6" translate="yes" xml:space="preserve">
          <source>Suspension Railway</source>
          <target state="translated">Подвесная железная дорога</target>
        </trans-unit>
        <trans-unit id="71d18f43d49f2f47456648385efbfe0cb4d0c149" translate="yes" xml:space="preserve">
          <source>Swimmer</source>
          <target state="translated">Swimmer</target>
        </trans-unit>
        <trans-unit id="3e44c920427e845df4958295eb8c3045b55fcfd5" translate="yes" xml:space="preserve">
          <source>Switch</source>
          <target state="translated">Switch</target>
        </trans-unit>
        <trans-unit id="a4abe2e6561ee4e0b3b06b8ee33d70d04583aff2" translate="yes" xml:space="preserve">
          <source>Switch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, &lt;code&gt;arg&lt;/code&gt; is returned from the task's last call to &lt;code&gt;yieldto&lt;/code&gt;. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.</source>
          <target state="translated">Перейти к данной задаче. При первом переключении на задачу функция задачи вызывается без аргументов. При последующих переключениях &lt;code&gt;arg&lt;/code&gt; возвращается из последнего вызова &lt;code&gt;yieldto&lt;/code&gt; . Это низкоуровневый вызов, который только переключает задачи, никоим образом не учитывая состояния или планирование. Его использование не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="8347671d999d16381b5c0feb325df8120cc6f75d" translate="yes" xml:space="preserve">
          <source>Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.</source>
          <target state="translated">Переключитесь на планировщик,чтобы разрешить выполнение другой запланированной задачи.Задача,которая вызывает эту функцию,все еще может быть запущена,и будет перезапущена немедленно,если нет других запущенных задач.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="1b2b779caa2c156291622711d5449bc4e0c50caf" translate="yes" xml:space="preserve">
          <source>Symbols do not belong to any package, and do not contain any values &lt;em&gt;per se&lt;/em&gt;. &lt;code&gt;M.var&lt;/code&gt; evaluates the symbol &lt;code&gt;var&lt;/code&gt; in the module &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac5aec6d1effd8a82fbef4c4c88712086df0e89" translate="yes" xml:space="preserve">
          <source>Symmetric matrix</source>
          <target state="translated">Симметричная матрица</target>
        </trans-unit>
        <trans-unit id="3f0921e5bff6794f52edd645b52ae45f6f732f4a" translate="yes" xml:space="preserve">
          <source>Symmetric real tridiagonal</source>
          <target state="translated">Симметричная реальная трехдиагональная</target>
        </trans-unit>
        <trans-unit id="ca10a61f0da269816a5c9d408bb8aa1f417f179d" translate="yes" xml:space="preserve">
          <source>Symmetric tridiagonal matrix</source>
          <target state="translated">Симметричная трехдиагональная матрица</target>
        </trans-unit>
        <trans-unit id="cbcf7ae51d210c4ce6c53f74b6ecb4c2b26819b4" translate="yes" xml:space="preserve">
          <source>Synchronization</source>
          <target state="translated">Synchronization</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="df02dad62c7357a982f0b8b91e3712d365096846" translate="yes" xml:space="preserve">
          <source>Syntax / Keyword</source>
          <target state="translated">Синтаксис/Ключевое слово</target>
        </trans-unit>
        <trans-unit id="dd6effb9dc1e87cae1ff2fb15208ededa0c5b6cc" translate="yes" xml:space="preserve">
          <source>Syntax Conflicts</source>
          <target state="translated">Синтаксические конфликты</target>
        </trans-unit>
        <trans-unit id="3655179938bda8b64c156fa5a6ab6ed93c568007" translate="yes" xml:space="preserve">
          <source>Syntax Guide</source>
          <target state="translated">Руководство по синтаксису</target>
        </trans-unit>
        <trans-unit id="49b8645cb3d5d028f81e3ff546436dea1e75203f" translate="yes" xml:space="preserve">
          <source>Syringe</source>
          <target state="translated">Syringe</target>
        </trans-unit>
        <trans-unit id="eea5f6535cf1464538bf913c29432e06b44c8a00" translate="yes" xml:space="preserve">
          <source>Sys</source>
          <target state="translated">Sys</target>
        </trans-unit>
        <trans-unit id="5b15446e1a2df96945de25b580d31fd7781e5677" translate="yes" xml:space="preserve">
          <source>Sys.ARCH</source>
          <target state="translated">Sys.ARCH</target>
        </trans-unit>
        <trans-unit id="ea549709c8d36e5b671637c93ae8042e833fb6c7" translate="yes" xml:space="preserve">
          <source>Sys.BINDIR</source>
          <target state="translated">Sys.BINDIR</target>
        </trans-unit>
        <trans-unit id="cbd1d907a3f81eed0265ef8833d42ad375912b5f" translate="yes" xml:space="preserve">
          <source>Sys.CPU_THREADS</source>
          <target state="translated">Sys.CPU_THREADS</target>
        </trans-unit>
        <trans-unit id="15b4b8619f588da9848eb54f4bf8375e81de8ba4" translate="yes" xml:space="preserve">
          <source>Sys.KERNEL</source>
          <target state="translated">Sys.KERNEL</target>
        </trans-unit>
        <trans-unit id="ddf91742e9bfe2e15760cc0904b02e0241b87da2" translate="yes" xml:space="preserve">
          <source>Sys.MACHINE</source>
          <target state="translated">Sys.MACHINE</target>
        </trans-unit>
        <trans-unit id="796735660de3fec9cc6a7ccbfddbef088428a267" translate="yes" xml:space="preserve">
          <source>Sys.WORD_SIZE</source>
          <target state="translated">Sys.WORD_SIZE</target>
        </trans-unit>
        <trans-unit id="375901ce98140a171ed6632260dde67cf6259438" translate="yes" xml:space="preserve">
          <source>Sys.free_memory()</source>
          <target state="translated">Sys.free_memory()</target>
        </trans-unit>
        <trans-unit id="7fa56fc341a0cdcf2e078d2b91be8fdea785a838" translate="yes" xml:space="preserve">
          <source>Sys.get_process_title()</source>
          <target state="translated">Sys.get_process_title()</target>
        </trans-unit>
        <trans-unit id="39dc0ce5e6f1d0c9e651677c3e12e7f1757cbcba" translate="yes" xml:space="preserve">
          <source>Sys.isapple()</source>
          <target state="translated">Sys.isapple()</target>
        </trans-unit>
        <trans-unit id="03119912a2c03ee07527224e883b39a922bdadc4" translate="yes" xml:space="preserve">
          <source>Sys.isbsd()</source>
          <target state="translated">Sys.isbsd()</target>
        </trans-unit>
        <trans-unit id="22a24965517e80c9d1727c9f7fc5d84adf3ce605" translate="yes" xml:space="preserve">
          <source>Sys.isdragonfly()</source>
          <target state="translated">Sys.isdragonfly()</target>
        </trans-unit>
        <trans-unit id="27a4af1930d284707ac8426c9dfb34043828ecd1" translate="yes" xml:space="preserve">
          <source>Sys.isfreebsd()</source>
          <target state="translated">Sys.isfreebsd()</target>
        </trans-unit>
        <trans-unit id="a2965d91481a0bbc8f3ee0bd36632e37c4e173eb" translate="yes" xml:space="preserve">
          <source>Sys.islinux()</source>
          <target state="translated">Sys.islinux()</target>
        </trans-unit>
        <trans-unit id="a0e775e7d914f8aac6d1a328e138a3a3c3c2a11d" translate="yes" xml:space="preserve">
          <source>Sys.isnetbsd()</source>
          <target state="translated">Sys.isnetbsd()</target>
        </trans-unit>
        <trans-unit id="a4cd0ca152f09ceeda470eb8f4454f9c05f7de4e" translate="yes" xml:space="preserve">
          <source>Sys.isopenbsd()</source>
          <target state="translated">Sys.isopenbsd()</target>
        </trans-unit>
        <trans-unit id="44d1250110223056dac1d302e658cb39d616dc4b" translate="yes" xml:space="preserve">
          <source>Sys.isunix()</source>
          <target state="translated">Sys.isunix()</target>
        </trans-unit>
        <trans-unit id="1d8055070eda84bf6013fc0792786c9e9266c1f4" translate="yes" xml:space="preserve">
          <source>Sys.iswindows()</source>
          <target state="translated">Sys.iswindows()</target>
        </trans-unit>
        <trans-unit id="029e67926c34e0658c17d66ac464b0e6d925adb6" translate="yes" xml:space="preserve">
          <source>Sys.set_process_title()</source>
          <target state="translated">Sys.set_process_title()</target>
        </trans-unit>
        <trans-unit id="c06dd39312f9e01848f09c4e56f06f3a5d14a622" translate="yes" xml:space="preserve">
          <source>Sys.total_memory()</source>
          <target state="translated">Sys.total_memory()</target>
        </trans-unit>
        <trans-unit id="235f7cf2ef4a9196211511f0a01512f001e55ff9" translate="yes" xml:space="preserve">
          <source>Sys.windows_version()</source>
          <target state="translated">Sys.windows_version()</target>
        </trans-unit>
        <trans-unit id="bc0792d8dc81e8aa30b987246a5ce97c40cd6833" translate="yes" xml:space="preserve">
          <source>System</source>
          <target state="translated">System</target>
        </trans-unit>
        <trans-unit id="47e68638ef3b94e3c34563e1179f97e827fb9bec" translate="yes" xml:space="preserve">
          <source>SystemError</source>
          <target state="translated">SystemError</target>
        </trans-unit>
        <trans-unit id="14398aaa3709921f04833f4eb9d880847302976e" translate="yes" xml:space="preserve">
          <source>T-Shirt</source>
          <target state="translated">T-Shirt</target>
        </trans-unit>
        <trans-unit id="5e3f230d5d2963950b06367aa593d1b64588e341" translate="yes" xml:space="preserve">
          <source>TR</source>
          <target state="translated">TR</target>
        </trans-unit>
        <trans-unit id="eb8b89e8c468a2f2b0bf3f62ac7419a0270f3b4b" translate="yes" xml:space="preserve">
          <source>Tab completion</source>
          <target state="translated">заполнение вкладки</target>
        </trans-unit>
        <trans-unit id="62b315a7c84a121cc5728c13d37733f905c0d329" translate="yes" xml:space="preserve">
          <source>Tab completion can also help completing fields:</source>
          <target state="translated">Заполнение полей также может помочь в заполнении полей:</target>
        </trans-unit>
        <trans-unit id="96d8de29ef10f4e4538a1cb749404c8f188732bc" translate="yes" xml:space="preserve">
          <source>Tab completion can help with investigation of the available methods matching the input arguments:</source>
          <target state="translated">Заполнение вкладки может помочь в исследовании доступных методов,соответствующих входным аргументам:</target>
        </trans-unit>
        <trans-unit id="ec37058ab8c801341a2164838991c7b36baf606c" translate="yes" xml:space="preserve">
          <source>Tab completion sequence(s)</source>
          <target state="translated">Последовательность заполнения вкладки</target>
        </trans-unit>
        <trans-unit id="193daf137ed8b89de36d47c3df5fd8f66c0e1d14" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="translated">Tables</target>
        </trans-unit>
        <trans-unit id="f6142c5e7f7b37b008f0934abccaace0a6f434f0" translate="yes" xml:space="preserve">
          <source>Take a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call &lt;code&gt;open(Libc.dup(fd))&lt;/code&gt; to avoid the ownership capture of the original handle.</source>
          <target state="translated">Возьмите необработанный файловый дескриптор, оберните его в тип ввода-вывода, поддерживающий Julia, и станьте владельцем дескриптора fd. Вызовите &lt;code&gt;open(Libc.dup(fd))&lt;/code&gt; чтобы избежать захвата права собственности на исходный дескриптор.</target>
        </trans-unit>
        <trans-unit id="028c707e8657f2ad234b365e0bd3fd169e21c888" translate="yes" xml:space="preserve">
          <source>Take a snapshot of the current state of the repository &lt;code&gt;repo&lt;/code&gt;, storing the current HEAD, index, and any uncommitted work. The output &lt;code&gt;State&lt;/code&gt; can be used later during a call to &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt; to return the repository to the snapshotted state.</source>
          <target state="translated">Сделать снимок текущего состояния хранилища &lt;code&gt;repo&lt;/code&gt; , сохранением текущего HEAD, индекс, и любую неизрасходованную работу. Выход &lt;code&gt;State&lt;/code&gt; может использоваться позже во время разговора , чтобы &lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; &lt;/a&gt; , чтобы вернуть хранилище в snapshotted состоянии.</target>
        </trans-unit>
        <trans-unit id="417b76383d90f18e7280ea7c153cd0ec7f4143f1" translate="yes" xml:space="preserve">
          <source>Take the expression &lt;code&gt;x&lt;/code&gt; and return an equivalent expression with all macros removed (expanded) for executing in module &lt;code&gt;m&lt;/code&gt;. The &lt;code&gt;recursive&lt;/code&gt; keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:</source>
          <target state="translated">Возьмите выражение &lt;code&gt;x&lt;/code&gt; и верните эквивалентное выражение со всеми удаленными (расширенными) макросами для выполнения в модуле &lt;code&gt;m&lt;/code&gt; . В &lt;code&gt;recursive&lt;/code&gt; ключевое слово определяет , будут ли более глубокие уровни вложенности макрокоманд также расширены. Это продемонстрировано в примере ниже:</target>
        </trans-unit>
        <trans-unit id="d28f2931bbad698b16249ed36b449a3b14fb39b6" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;Date&lt;/code&gt; and return the number of days since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возьмите заданную &lt;code&gt;Date&lt;/code&gt; и верните количество дней с момента округления ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c44da3302da9152e79b3157eb63204c185052ad" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;DateTime&lt;/code&gt; and return the number of Julian calendar days since the julian epoch &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; as a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возьмите данное &lt;code&gt;DateTime&lt;/code&gt; и верните количество дней в юлианском календаре с юлианской эпохи &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ce37312d945672925e211e70623bf1d7a6b2f2" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;DateTime&lt;/code&gt; and return the number of milliseconds since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возьмите заданный &lt;code&gt;DateTime&lt;/code&gt; и верните количество миллисекунд с момента округления ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b90d8b1442620b2460ac29cdc4af299f9431cbe7" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;DateTime&lt;/code&gt; and return the number of seconds since the unix epoch &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; as a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возьмите данное &lt;code&gt;DateTime&lt;/code&gt; и верните количество секунд с эпохи unix &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52e8457357f9105fd0f6a09d1e22e555734202d0" translate="yes" xml:space="preserve">
          <source>Take the inverse of &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;y&lt;/code&gt; such that $x y = 1 \pmod m$, with $div(x,y) = 0$. This is undefined for $m = 0$, or if $gcd(x,m) \neq 1$.</source>
          <target state="translated">Возьмем обратный к &lt;code&gt;x&lt;/code&gt; по модулю &lt;code&gt;m&lt;/code&gt; : &lt;code&gt;y&lt;/code&gt; такой, что $ xy = 1 \ pmod m $, где $ div (x, y) = 0 $. Не определено для $ m = 0 $ или $ gcd (x, m) \ neq 1 $.</target>
        </trans-unit>
        <trans-unit id="ac65d0f278e58fa9f0d56cc7d33997e42273d3be" translate="yes" xml:space="preserve">
          <source>Take the number of Julian calendar days since epoch &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; and return the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Возьмите количество дней по юлианскому календарю с эпохи &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; и верните соответствующее &lt;code&gt;DateTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651f47947b58a46afe82a3eb965d1ee5bbbb30a9" translate="yes" xml:space="preserve">
          <source>Take the number of Rata Die days since epoch &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; and return the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Возьмите количество дней Rata Die с эпохи &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; и верните соответствующее &lt;code&gt;DateTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4192143b648e1063359b65a375c87d5eaac8a3f" translate="yes" xml:space="preserve">
          <source>Take the number of days since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) and return the corresponding &lt;code&gt;Date&lt;/code&gt;.</source>
          <target state="translated">Возьмите количество дней с эпохи округления ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) и верните соответствующую &lt;code&gt;Date&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ff629efbee246780761d817ac2092dd33354876" translate="yes" xml:space="preserve">
          <source>Take the number of milliseconds since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) and return the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Возьмите количество миллисекунд с момента округления ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) и верните соответствующий &lt;code&gt;DateTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdec858b0f40b88512aa7f1bc4fef283de2775ca" translate="yes" xml:space="preserve">
          <source>Take the number of seconds since unix epoch &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; and convert to the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Возьмите количество секунд с эпохи unix &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; и преобразуйте его в соответствующее &lt;code&gt;DateTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df4eac27878e48240f59f94254ce1aad5866d1eb" translate="yes" xml:space="preserve">
          <source>Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for &quot;vectorized&quot; (element-wise) functions, the convenient syntax &lt;code&gt;x .= f.(y)&lt;/code&gt; can be used for in-place operations with fused loops and no temporary arrays (see the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax for vectorizing functions&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cf08645b24660e17958eeaca8edbd4e94b3d71" translate="yes" xml:space="preserve">
          <source>Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for &quot;vectorized&quot; (element-wise) functions, the convenient syntax &lt;code&gt;x .= f.(y)&lt;/code&gt; can be used for in-place operations with fused loops and no temporary arrays (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax for vectorizing functions&lt;/a&gt;).</source>
          <target state="translated">В крайнем случае, предварительное распределение может сделать ваш код более уродливым, поэтому могут потребоваться измерения производительности и некоторое суждение. Однако для &amp;laquo;векторизованных&amp;raquo; (поэлементных) функций удобный синтаксис &lt;code&gt;x .= f.(y)&lt;/code&gt; может использоваться для операций на месте с объединенными циклами и без временных массивов (см. &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;Точечный синтаксис для функций векторизации&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="068e523ef955dcbff5853a974467b5a1dfd337be" translate="yes" xml:space="preserve">
          <source>Taken together, &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; uniquely identify a reference across all workers.</source>
          <target state="translated">Взятые вместе, &lt;code&gt;whence&lt;/code&gt; и &lt;code&gt;id&lt;/code&gt; однозначно определяют ссылку для всех рабочих процессов.</target>
        </trans-unit>
        <trans-unit id="de9377a78118014a32619a7a3fae9e2c93076858" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;StackTrace&lt;/code&gt; (a vector of &lt;code&gt;StackFrames&lt;/code&gt;) and a function name (a &lt;code&gt;Symbol&lt;/code&gt;) and removes the &lt;code&gt;StackFrame&lt;/code&gt; specified by the function name from the &lt;code&gt;StackTrace&lt;/code&gt; (also removing all frames above the specified function). Primarily used to remove &lt;code&gt;StackTraces&lt;/code&gt; functions from the &lt;code&gt;StackTrace&lt;/code&gt; prior to returning it.</source>
          <target state="translated">Принимает &lt;code&gt;StackTrace&lt;/code&gt; (вектор &lt;code&gt;StackFrames&lt;/code&gt; ) и имя функции ( &lt;code&gt;Symbol&lt;/code&gt; ), а также удаляет &lt;code&gt;StackFrame&lt;/code&gt; , указанный именем функции, из &lt;code&gt;StackTrace&lt;/code&gt; (также удаляя все кадры выше указанной функции). В основном используется для удаления функций &lt;code&gt;StackTraces&lt;/code&gt; из &lt;code&gt;StackTrace&lt;/code&gt; перед их возвратом.</target>
        </trans-unit>
        <trans-unit id="d364a68aa146d3f3bf91f5e5cefd025c8e63eb18" translate="yes" xml:space="preserve">
          <source>Takes one or two &lt;code&gt;BroadcastStyle&lt;/code&gt;s and combines them using &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt; to determine a common &lt;code&gt;BroadcastStyle&lt;/code&gt;.</source>
          <target state="translated">Принимает один или два &lt;code&gt;BroadcastStyle&lt;/code&gt; и объединяет их с помощью &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; для определения общего &lt;code&gt;BroadcastStyle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f5b4f7c8c50f94fb9b9fa5a4c40c9fc953fc239" translate="yes" xml:space="preserve">
          <source>Takes the expression &lt;code&gt;x&lt;/code&gt; and returns an equivalent expression in lowered form for executing in module &lt;code&gt;m&lt;/code&gt;. See also &lt;a href=&quot;#Base.code_lowered&quot;&gt;&lt;code&gt;code_lowered&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Принимает выражение &lt;code&gt;x&lt;/code&gt; и возвращает эквивалентное выражение в уменьшенной форме для выполнения в модуле &lt;code&gt;m&lt;/code&gt; . См. Также &lt;a href=&quot;#Base.code_lowered&quot;&gt; &lt;code&gt;code_lowered&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0f75dfe8be08da7413ff205308db3988d48c238" translate="yes" xml:space="preserve">
          <source>Taking any locks: C code you call out to may use locks internally, (for example, it is not problematic to call &lt;code&gt;malloc&lt;/code&gt;, even though most implementations require locks internally) but don't attempt to hold or acquire any while executing Julia code.</source>
          <target state="translated">Принятие любых блокировок: код C, который вы вызываете, может использовать внутренние блокировки (например, вызвать &lt;code&gt;malloc&lt;/code&gt; не проблематично , хотя большинство реализаций требуют внутренних блокировок), но не пытайтесь удерживать или получать их во время выполнения кода Julia.</target>
        </trans-unit>
        <trans-unit id="0c204d1420d355840b7090b04468d71687143fa6" translate="yes" xml:space="preserve">
          <source>Tanabata Tree</source>
          <target state="translated">дерево Танабата</target>
        </trans-unit>
        <trans-unit id="540da3c8235d6a0dd4fb058287e70d93a6ac769f" translate="yes" xml:space="preserve">
          <source>Tangerine</source>
          <target state="translated">Tangerine</target>
        </trans-unit>
        <trans-unit id="01b941006f02b16df67545cd411e591988012b12" translate="yes" xml:space="preserve">
          <source>Task operations are built on a low-level primitive called &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;yieldto(task, value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e55dab266b437d3555af520a2b5749154eb13c2" translate="yes" xml:space="preserve">
          <source>Task states</source>
          <target state="translated">Целевые состояния</target>
        </trans-unit>
        <trans-unit id="090ec5f560fc50377fcd95e5cda128e91b276e98" translate="yes" xml:space="preserve">
          <source>Tasks</source>
          <target state="translated">Tasks</target>
        </trans-unit>
        <trans-unit id="0b35cd483f5048f80cbf6983b2b06a9cd32bcd14" translate="yes" xml:space="preserve">
          <source>Tasks (aka Coroutines)</source>
          <target state="translated">Задачи (он же &quot;Корутины&quot;)</target>
        </trans-unit>
        <trans-unit id="df3ca43deba3d5d7f0127736b100d3e238341ae0" translate="yes" xml:space="preserve">
          <source>Tasks and events</source>
          <target state="translated">Задачи и события</target>
        </trans-unit>
        <trans-unit id="8eab10a59a1438147c2e463f755d257993fd8a07" translate="yes" xml:space="preserve">
          <source>Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. This feature is sometimes called by other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations.</source>
          <target state="translated">Задачи-это функция управления потоком,которая позволяет приостанавливать и возобновлять вычисления гибким образом.Эта функция иногда называется другими именами,такими как симметричные корусели,легкие потоки,совместная многозадачность или одноразовые продолжения.</target>
        </trans-unit>
        <trans-unit id="3cc270b1ec293008662eb882aad48af33750fd03" translate="yes" xml:space="preserve">
          <source>Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. We mention them here only for completeness; for a full discussion see &lt;a href=&quot;../asynchronous-programming/index#man-asynchronous&quot;&gt;Asynchronous Programming&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb3658baf2d7e7d43b5b8f372fd5ca23bdc053a" translate="yes" xml:space="preserve">
          <source>Tasks have a &lt;code&gt;state&lt;/code&gt; field that describes their execution status. A &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;&lt;code&gt;state&lt;/code&gt; is one of the following symbols:</source>
          <target state="translated">У задач есть поле &lt;code&gt;state&lt;/code&gt; которое описывает статус их выполнения. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; &lt;code&gt;state&lt;/code&gt; является одним из следующих символов:</target>
        </trans-unit>
        <trans-unit id="c5e606e056ade44a820632a75114e5367860a0b9" translate="yes" xml:space="preserve">
          <source>Taurus</source>
          <target state="translated">Taurus</target>
        </trans-unit>
        <trans-unit id="82e2b91027511aadd8b52aa9401729c10793ba39" translate="yes" xml:space="preserve">
          <source>Taxi</source>
          <target state="translated">Taxi</target>
        </trans-unit>
        <trans-unit id="0a57f37badaa7ec48014346cc98c84cac7d2ade4" translate="yes" xml:space="preserve">
          <source>Teacup Without Handle</source>
          <target state="translated">Учительница без ручки</target>
        </trans-unit>
        <trans-unit id="8e757d58b37dccc7e4c0b2a497f65a5ed9d48db3" translate="yes" xml:space="preserve">
          <source>Tear-Off Calendar</source>
          <target state="translated">Слезоточивый календарь</target>
        </trans-unit>
        <trans-unit id="b36b5c8399292bab447511d6002f7a7d4e7be9ba" translate="yes" xml:space="preserve">
          <source>Technically, the &lt;code&gt;MIME&quot;mime&quot;&lt;/code&gt; macro defines a singleton type for the given &lt;code&gt;mime&lt;/code&gt; string, which allows us to exploit Julia's dispatch mechanisms in determining how to display objects of any given type.</source>
          <target state="translated">Технически макрос &lt;code&gt;MIME&quot;mime&quot;&lt;/code&gt; определяет одноэлементный тип для данной строки &lt;code&gt;mime&lt;/code&gt; , что позволяет нам использовать механизмы диспетчеризации Джулии для определения того, как отображать объекты любого заданного типа.</target>
        </trans-unit>
        <trans-unit id="e8591fccea0433d35b0f909dc027997ba9cf40af" translate="yes" xml:space="preserve">
          <source>Telephone Receiver</source>
          <target state="translated">Телефонный приемник</target>
        </trans-unit>
        <trans-unit id="6fdcfe42f30940ceb992fdf61a9d918ee098d622" translate="yes" xml:space="preserve">
          <source>Telephone Recorder</source>
          <target state="translated">Телефонный диктофон</target>
        </trans-unit>
        <trans-unit id="e5b83a241ff8a2dcd5e8a0e8480a8c3a13d035b9" translate="yes" xml:space="preserve">
          <source>Telescope</source>
          <target state="translated">Telescope</target>
        </trans-unit>
        <trans-unit id="a77b1903c8e3b2f68e74c12f0e476b3e4533624b" translate="yes" xml:space="preserve">
          <source>Television</source>
          <target state="translated">Television</target>
        </trans-unit>
        <trans-unit id="3024b128d3cb0369c884d0466a1f023cd5ca5d2d" translate="yes" xml:space="preserve">
          <source>Tells the compiler to apply the polyhedral optimizer Polly to a function.</source>
          <target state="translated">Говорит компилятору применить к функции полиэдрический оптимизатор Polly.</target>
        </trans-unit>
        <trans-unit id="82c8638d126af0aea69ce9d89f262926c474dc0b" translate="yes" xml:space="preserve">
          <source>Tells the compiler to inline a function while retaining the caller's inbounds context.</source>
          <target state="translated">Сказывает компилятору включить функцию,сохраняя при этом входящий контекст вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="f664957d0ea8b87df32ae92b4fd24aa1a46ea0d6" translate="yes" xml:space="preserve">
          <source>Temporarily change the current working directory to &lt;code&gt;dir&lt;/code&gt;, apply function &lt;code&gt;f&lt;/code&gt; and finally return to the original directory.</source>
          <target state="translated">Временно измените текущий рабочий каталог на &lt;code&gt;dir&lt;/code&gt; , примените функцию &lt;code&gt;f&lt;/code&gt; и, наконец, вернитесь в исходный каталог.</target>
        </trans-unit>
        <trans-unit id="5368df43ad530996bb634ca556da7a94b51b1f83" translate="yes" xml:space="preserve">
          <source>Temporarily protect the given objects from being garbage collected, even if they would otherwise be unreferenced.</source>
          <target state="translated">Временно защищайте данные предметы от сбора мусора,даже если в противном случае они не будут иметь ссылок.</target>
        </trans-unit>
        <trans-unit id="7aa6cf11b9fd650712f5d0d45e4ebbfbd3c41157" translate="yes" xml:space="preserve">
          <source>Tennis Racquet And Ball</source>
          <target state="translated">Теннисная ракетка и мяч</target>
        </trans-unit>
        <trans-unit id="eae12d19e86e1dd6bdd687f86d4bf2b6b0796fe8" translate="yes" xml:space="preserve">
          <source>Tent</source>
          <target state="translated">Tent</target>
        </trans-unit>
        <trans-unit id="e78f2b53804e241d64d7b89461c2a0d69af83b51" translate="yes" xml:space="preserve">
          <source>TerminalMenus</source>
          <target state="translated">TerminalMenus</target>
        </trans-unit>
        <trans-unit id="13fa61ab6513a29d350b01bb431ceafe6fa30f37" translate="yes" xml:space="preserve">
          <source>TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal.</source>
          <target state="translated">TerminalMenus является субмодулем Julia REPL и позволяет создавать небольшие,низкопрофильные интерактивные меню в терминале.</target>
        </trans-unit>
        <trans-unit id="2139b2bddeeaa577530e84c69430b174701f95a8" translate="yes" xml:space="preserve">
          <source>Test sets can also be nested:</source>
          <target state="translated">Тестовые наборы также могут быть вложены:</target>
        </trans-unit>
        <trans-unit id="905795e622786e111cc0f710b821ee73ef40ef36" translate="yes" xml:space="preserve">
          <source>Test that a factorization of a matrix succeeded.</source>
          <target state="translated">Проверьте,что факторизация матрицы прошла успешно.</target>
        </trans-unit>
        <trans-unit id="b044b22b39c04d0d12ff81df1380d3e1a16e02ee" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;A&lt;/code&gt; is lower triangular starting from the &lt;code&gt;k&lt;/code&gt;th superdiagonal.</source>
          <target state="translated">Проверьте, является ли &lt;code&gt;A&lt;/code&gt; нижним треугольником, начиная с &lt;code&gt;k&lt;/code&gt; - й наддиагонали.</target>
        </trans-unit>
        <trans-unit id="e4cf2b6626c76618b63816a9d2821ac9a2e3d9dd" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;A&lt;/code&gt; is upper triangular starting from the &lt;code&gt;k&lt;/code&gt;th superdiagonal.</source>
          <target state="translated">Проверьте, является ли &lt;code&gt;A&lt;/code&gt; верхним треугольником, начиная с &lt;code&gt;k&lt;/code&gt; - й наддиагонали.</target>
        </trans-unit>
        <trans-unit id="98fd1b482df7fb574b54488f598a98d5212dc3a9" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;n&lt;/code&gt; is a power of two.</source>
          <target state="translated">Проверьте, является ли &lt;code&gt;n&lt;/code&gt; степенью двойки.</target>
        </trans-unit>
        <trans-unit id="27c9d85a5238374f74460ae2f5d8d739f24f5e58" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;y&lt;/code&gt;, according to a fixed total order. &lt;code&gt;isless&lt;/code&gt; is not defined on all pairs of values &lt;code&gt;(x, y)&lt;/code&gt;. However, if it is defined, it is expected to satisfy the following:</source>
          <target state="translated">Проверьте, меньше ли &lt;code&gt;x&lt;/code&gt; , чем &lt;code&gt;y&lt;/code&gt; , в соответствии с фиксированным общим порядком. &lt;code&gt;isless&lt;/code&gt; не определен для всех пар значений &lt;code&gt;(x, y)&lt;/code&gt; . Однако, если он определен, ожидается, что он будет удовлетворять следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="4e089adb509ccd09b24baf13faa8a1eebdb92d73" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;x&lt;/code&gt; is numerically equal to some integer.</source>
          <target state="translated">Проверить, равно ли &lt;code&gt;x&lt;/code&gt; численно некоторому целому числу.</target>
        </trans-unit>
        <trans-unit id="129659df829e85df63605534482b69287911ce83" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;x&lt;/code&gt; or all its elements are numerically equal to some real number including infinities and NaNs. &lt;code&gt;isreal(x)&lt;/code&gt; is true if &lt;code&gt;isequal(x, real(x))&lt;/code&gt; is true.</source>
          <target state="translated">Проверьте, равны ли &lt;code&gt;x&lt;/code&gt; или все его элементы численно некоторому действительному числу, включая бесконечности и NaN. &lt;code&gt;isreal(x)&lt;/code&gt; истинно, если &lt;code&gt;isequal(x, real(x))&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="600f2a45d487a92b3e1acfc026b5358d6258b900" translate="yes" xml:space="preserve">
          <source>Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</source>
          <target state="translated">Проверьте,принадлежит ли символ к набору символов ASCII,или это верно для всех элементов строки.</target>
        </trans-unit>
        <trans-unit id="ff3201c5d4b7bfd8db4e7a4f29a3f69497556eca" translate="yes" xml:space="preserve">
          <source>Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with 'L'.</source>
          <target state="translated">Проверьте,является ли символ буквой.Символ классифицируется как буква,если он принадлежит к общей категории Unicode Letter,т.е.символ,код категории которого начинается с 'L'.</target>
        </trans-unit>
        <trans-unit id="b813a818e8d7c67e7e9a9f0231fbac7c47fefadd" translate="yes" xml:space="preserve">
          <source>Test whether a character is a valid hexadecimal digit. Note that this does not include &lt;code&gt;x&lt;/code&gt; (as in the standard &lt;code&gt;0x&lt;/code&gt; prefix).</source>
          <target state="translated">Проверьте, является ли символ допустимой шестнадцатеричной цифрой. Обратите внимание, что это не включает &lt;code&gt;x&lt;/code&gt; (как в стандартном префиксе &lt;code&gt;0x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e0cacc8325a8d7f460c1842e48e751e6577dc0aa" translate="yes" xml:space="preserve">
          <source>Test whether a floating point number is not a number (NaN).</source>
          <target state="translated">Проверьте,не является ли число с плавающей точкой (NaN)числом.</target>
        </trans-unit>
        <trans-unit id="d7419a87e49114034dc9b13f27d841429ec6cc7c" translate="yes" xml:space="preserve">
          <source>Test whether a floating point number is subnormal.</source>
          <target state="translated">Проверьте,является ли число с плавающей точкой субнормальным.</target>
        </trans-unit>
        <trans-unit id="2ab2650250d6d0753ef232f30dc775ab55d17e25" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is Hermitian.</source>
          <target state="translated">Проверьте,является ли матрица гермитской.</target>
        </trans-unit>
        <trans-unit id="82b9f1f281541be3d753c0180e9a9b9c68a4213c" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is diagonal.</source>
          <target state="translated">Проверьте,диагональ ли матрицы.</target>
        </trans-unit>
        <trans-unit id="d10ee2b732be6df553fcdf2c02967046d343062a" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of &lt;code&gt;A&lt;/code&gt;, overwriting &lt;code&gt;A&lt;/code&gt; in the process. See also &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Проверьте, является ли матрица положительно определенной (и эрмитовой), пытаясь выполнить факторизацию Холецкого &lt;code&gt;A&lt;/code&gt; , перезаписывая &lt;code&gt;A&lt;/code&gt; в процессе. См. Также &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="348072f52243282048adc6be8377b4069538c3e2" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of &lt;code&gt;A&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.isposdef!&quot;&gt;&lt;code&gt;isposdef!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Тест является ли положительно определенной (и эрмитов), пытаясь выполнить Чолески разложения матрицы &lt;code&gt;A&lt;/code&gt; . См. Также &lt;a href=&quot;#LinearAlgebra.isposdef!&quot;&gt; &lt;code&gt;isposdef!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07adbca0475dd6e20bdd50fc2143d233a16e3c32" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is symmetric.</source>
          <target state="translated">Проверьте,симметрична ли матрица.</target>
        </trans-unit>
        <trans-unit id="3599ca56d6716dfc1dda935750874c488e247ef1" translate="yes" xml:space="preserve">
          <source>Test whether a number is finite.</source>
          <target state="translated">Проверьте,является ли число конечным.</target>
        </trans-unit>
        <trans-unit id="73368aa2af01f69082a351e93d003d22094d90ad" translate="yes" xml:space="preserve">
          <source>Test whether a number is infinite.</source>
          <target state="translated">Проверьте,является ли число бесконечным.</target>
        </trans-unit>
        <trans-unit id="d75260ba4af82ac9b6c50155871969bea358f4b9" translate="yes" xml:space="preserve">
          <source>Test whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite number (&quot;not a number&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d5538dd4fb443f30fc719de96fea5e3c4be074" translate="yes" xml:space="preserve">
          <source>Test whether a vector is in sorted order. The &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt; and &lt;code&gt;rev&lt;/code&gt; keywords modify what order is considered to be sorted just as they do for &lt;a href=&quot;#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Проверьте, отсортирован ли вектор. &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;by&lt;/code&gt; и &lt;code&gt;rev&lt;/code&gt; ключевых слова Modify , что заказ считаются быть отсортированы так же , как они делают для своего &lt;a href=&quot;#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="042172a78d48aeda17bafb91d25140f851ffb91a" translate="yes" xml:space="preserve">
          <source>Test whether all elements of a boolean collection are &lt;code&gt;true&lt;/code&gt;, returning &lt;code&gt;false&lt;/code&gt; as soon as the first &lt;code&gt;false&lt;/code&gt; value in &lt;code&gt;itr&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">Проверяет, все ли элементы логической коллекции &lt;code&gt;true&lt;/code&gt; , возвращая &lt;code&gt;false&lt;/code&gt; как только встречается первое &lt;code&gt;false&lt;/code&gt; значение в &lt;code&gt;itr&lt;/code&gt; (короткое замыкание).</target>
        </trans-unit>
        <trans-unit id="07c60c5c1f0ceba07eb9c4e3e6adeed9269c406c" translate="yes" xml:space="preserve">
          <source>Test whether all values in &lt;code&gt;A&lt;/code&gt; along the singleton dimensions of &lt;code&gt;r&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Тестовые ли все значения в &lt;code&gt;A&lt;/code&gt; вдоль одноэлементных размеров &lt;code&gt;r&lt;/code&gt; являются &lt;code&gt;true&lt;/code&gt; , и записывать результаты в &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3d64b16b12423728af4949449874717f8930e1" translate="yes" xml:space="preserve">
          <source>Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return &lt;code&gt;false&lt;/code&gt;. Therefore it is always safe to read one byte after seeing &lt;code&gt;eof&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;eof&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; as long as buffered data is still available, even if the remote end of a connection is closed.</source>
          <target state="translated">Проверьте, находится ли поток ввода-вывода в конце файла. Если поток еще не исчерпан, эта функция заблокируется, чтобы дождаться дополнительных данных, если это необходимо, а затем вернет &lt;code&gt;false&lt;/code&gt; . Следовательно, всегда безопасно прочитать один байт после того, как &lt;code&gt;eof&lt;/code&gt; вернет &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;eof&lt;/code&gt; вернет &lt;code&gt;false&lt;/code&gt; , пока буферизованные данные все еще доступны, даже если удаленный конец соединения закрыт.</target>
        </trans-unit>
        <trans-unit id="a9e4f6b06e3064db079558e13017dc87dfe1fa0e" translate="yes" xml:space="preserve">
          <source>Test whether any elements of a boolean collection are &lt;code&gt;true&lt;/code&gt;, returning &lt;code&gt;true&lt;/code&gt; as soon as the first &lt;code&gt;true&lt;/code&gt; value in &lt;code&gt;itr&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; являются ли какие-либо элементы логической коллекции &lt;code&gt;true&lt;/code&gt; , возвращая &lt;code&gt;true&lt;/code&gt; как только встречается первое &lt;code&gt;true&lt;/code&gt; значение в itr (короткое замыкание).</target>
        </trans-unit>
        <trans-unit id="e348af6e654acbf2a94a256de0eb0dbfdadfb336" translate="yes" xml:space="preserve">
          <source>Test whether any values in &lt;code&gt;A&lt;/code&gt; along the singleton dimensions of &lt;code&gt;r&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Тестовые ли какое - либо значение в &lt;code&gt;A&lt;/code&gt; вдоль одноэлементных размеров &lt;code&gt;r&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , и записывать результаты в &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd46b89139e604585bd7adc7fd76ca1664e06ca" translate="yes" xml:space="preserve">
          <source>Test whether evaluating &lt;code&gt;expr&lt;/code&gt; results in &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; output that contains the &lt;code&gt;msg&lt;/code&gt; string or matches the &lt;code&gt;msg&lt;/code&gt; regular expression. If &lt;code&gt;msg&lt;/code&gt; is a boolean function, tests whether &lt;code&gt;msg(output)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;msg&lt;/code&gt; is a tuple or array, checks that the error output contains/matches each item in &lt;code&gt;msg&lt;/code&gt;. Returns the result of evaluating &lt;code&gt;expr&lt;/code&gt;.</source>
          <target state="translated">Проверьте, приводит ли оценка &lt;code&gt;expr&lt;/code&gt; к выходным данным &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; , содержащим строку &lt;code&gt;msg&lt;/code&gt; , или соответствует регулярному выражению &lt;code&gt;msg&lt;/code&gt; . Если &lt;code&gt;msg&lt;/code&gt; - логическая функция, проверяет, возвращает ли &lt;code&gt;msg(output)&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; . Если &lt;code&gt;msg&lt;/code&gt; является кортежем или массивом, проверяет, что вывод ошибки содержит / соответствует каждому элементу в &lt;code&gt;msg&lt;/code&gt; . Возвращает результат вычисления &lt;code&gt;expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c503325cf6d409b8a3c8deb8bb14aeb0c9c653" translate="yes" xml:space="preserve">
          <source>Test whether evaluating &lt;code&gt;expr&lt;/code&gt; results in empty &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; output (no warnings or other messages). Returns the result of evaluating &lt;code&gt;expr&lt;/code&gt;.</source>
          <target state="translated">Проверьте, приводит ли вычисление &lt;code&gt;expr&lt;/code&gt; к пустому выводу &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; (без предупреждений или других сообщений). Возвращает результат вычисления &lt;code&gt;expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb141979c927fd73f20cd08901b19019dd16fdc" translate="yes" xml:space="preserve">
          <source>Test whether string &lt;code&gt;a&lt;/code&gt; comes before string &lt;code&gt;b&lt;/code&gt; in alphabetical order (technically, in lexicographical order by Unicode code points).</source>
          <target state="translated">Проверьте, стоит ли строка &lt;code&gt;a&lt;/code&gt; перед строкой &lt;code&gt;b&lt;/code&gt; в алфавитном порядке (технически, в лексикографическом порядке по кодовым точкам Unicode).</target>
        </trans-unit>
        <trans-unit id="af1d2d0bea1baef660017807a8fc1e76d51825f5" translate="yes" xml:space="preserve">
          <source>Test whether the bits of &lt;code&gt;val&lt;/code&gt; indexed by &lt;code&gt;flag&lt;/code&gt; are set (&lt;code&gt;1&lt;/code&gt;) or unset (&lt;code&gt;0&lt;/code&gt;).</source>
          <target state="translated">Проверьте, установлены ли биты &lt;code&gt;val&lt;/code&gt; , проиндексированные с помощью &lt;code&gt;flag&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) или не установлены ( &lt;code&gt;0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="03c61a2f3d90dc00f68f5e2ed78c218e3afa629e" translate="yes" xml:space="preserve">
          <source>Test whether the given array has a value associated with index &lt;code&gt;i&lt;/code&gt;. Return &lt;code&gt;false&lt;/code&gt; if the index is out of bounds, or has an undefined reference.</source>
          <target state="translated">Проверить, имеет ли данный массив значение, связанное с индексом &lt;code&gt;i&lt;/code&gt; . Вернуть &lt;code&gt;false&lt;/code&gt; , если индекс выходит за границы или имеет неопределенную ссылку.</target>
        </trans-unit>
        <trans-unit id="beda63ee049bff8ccbc0434c5189adc1f6390d8f" translate="yes" xml:space="preserve">
          <source>Test whether two strings are equal character by character (technically, Unicode code point by code point).</source>
          <target state="translated">Тестирование того,равны ли две строки по символам (технически,точка за точкой кода Юникода).</target>
        </trans-unit>
        <trans-unit id="49bf5d839411dd44ef27726c0fd5d3673c683947" translate="yes" xml:space="preserve">
          <source>Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, different synchronization approaches should be considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf06dc89873a4ef4739014da9b0503ac82ea142" translate="yes" xml:space="preserve">
          <source>Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, perhaps a lock is the wrong way to synchronize.</source>
          <target state="translated">Пробные и испытательные спиннинговые замки быстрее всего работают с 30-ю соперничающими нитями.Если у вас больше соперников,возможно,блокировка-это неправильный способ синхронизации.</target>
        </trans-unit>
        <trans-unit id="2d37dbc036f72363555168a219582cc080650c2c" translate="yes" xml:space="preserve">
          <source>Test.@inferred</source>
          <target state="translated">Test.@inferred</target>
        </trans-unit>
        <trans-unit id="67c3de69a1559a69f4d736c324dbd0345e8ce841" translate="yes" xml:space="preserve">
          <source>Test.@test</source>
          <target state="translated">Test.@test</target>
        </trans-unit>
        <trans-unit id="bd238279fd968d439f9885d950b9239d42041d37" translate="yes" xml:space="preserve">
          <source>Test.@test_broken</source>
          <target state="translated">Test.@test_broken</target>
        </trans-unit>
        <trans-unit id="77f427edbc1109c9ae775e8fe246045b182ad14f" translate="yes" xml:space="preserve">
          <source>Test.@test_deprecated</source>
          <target state="translated">Test.@test_deprecated</target>
        </trans-unit>
        <trans-unit id="5f31db08afdef0dd5283f2187bca919c2925c8f7" translate="yes" xml:space="preserve">
          <source>Test.@test_logs</source>
          <target state="translated">Test.@test_logs</target>
        </trans-unit>
        <trans-unit id="de547b50f8053308f0a2ee21b90aaae3dcceb9ad" translate="yes" xml:space="preserve">
          <source>Test.@test_nowarn</source>
          <target state="translated">Test.@test_nowarn</target>
        </trans-unit>
        <trans-unit id="615ef519b12005068f8a41a5b369ca5e1c35c1df" translate="yes" xml:space="preserve">
          <source>Test.@test_skip</source>
          <target state="translated">Test.@test_skip</target>
        </trans-unit>
        <trans-unit id="95afc1bc6b103ad5f46190e8654549af904b5ca5" translate="yes" xml:space="preserve">
          <source>Test.@test_throws</source>
          <target state="translated">Test.@test_throws</target>
        </trans-unit>
        <trans-unit id="9d03989391caa1d6637c00c4e3593a97718e2d0c" translate="yes" xml:space="preserve">
          <source>Test.@test_warn</source>
          <target state="translated">Test.@test_warn</target>
        </trans-unit>
        <trans-unit id="9c32cdd553427e36cbe90d4bd95ba370b53cfa1f" translate="yes" xml:space="preserve">
          <source>Test.@testset</source>
          <target state="translated">Test.@testset</target>
        </trans-unit>
        <trans-unit id="066c25bc74518d73302b5533ce6478389885f805" translate="yes" xml:space="preserve">
          <source>Test.finish()</source>
          <target state="translated">Test.finish()</target>
        </trans-unit>
        <trans-unit id="631cdc0a519d0e288b565285a0850351da1807ff" translate="yes" xml:space="preserve">
          <source>Test.get_testset()</source>
          <target state="translated">Test.get_testset()</target>
        </trans-unit>
        <trans-unit id="faa7d1071b0518cdce8349dea77288299aaf1de4" translate="yes" xml:space="preserve">
          <source>Test.get_testset_depth()</source>
          <target state="translated">Test.get_testset_depth()</target>
        </trans-unit>
        <trans-unit id="c13bc73ec3123a7311ed203c0f38cc895a803bbc" translate="yes" xml:space="preserve">
          <source>Test.record()</source>
          <target state="translated">Test.record()</target>
        </trans-unit>
        <trans-unit id="cfa7ab2b3a16142765d21a4e0e0bb623e5059861" translate="yes" xml:space="preserve">
          <source>Testing Base Julia</source>
          <target state="translated">Испытательная база Джулия</target>
        </trans-unit>
        <trans-unit id="4987ea8354d4ae570352dab5aa6d2a2a221c5e60" translate="yes" xml:space="preserve">
          <source>Testing log events</source>
          <target state="translated">События журнала тестирования</target>
        </trans-unit>
        <trans-unit id="9f285f003655f9f610bc2da7f8c3424ca3aeec50" translate="yes" xml:space="preserve">
          <source>Tests if</source>
          <target state="translated">Проверяет,если</target>
        </trans-unit>
        <trans-unit id="f004ea40cf1865fa970c6555dac7feb5082b5754" translate="yes" xml:space="preserve">
          <source>Tests if an IP address is a link-local address. Link-local addresses are not guaranteed to be unique beyond their network segment, therefore routers do not forward them. Link-local addresses are from the address blocks &lt;code&gt;169.254.0.0/16&lt;/code&gt; or &lt;code&gt;fe80::/10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14917cac8a358ec6de88c1ed38efe9ab513ca635" translate="yes" xml:space="preserve">
          <source>Tests that the call expression &lt;code&gt;f(x)&lt;/code&gt; returns a value of the same type inferred by the compiler. It is useful to check for type stability.</source>
          <target state="translated">Проверяет, что выражение вызова &lt;code&gt;f(x)&lt;/code&gt; возвращает значение того же типа, выведенного компилятором. Полезно проверить стабильность типа.</target>
        </trans-unit>
        <trans-unit id="f51e24e7a72028a134722e0d08788caab74f1323" translate="yes" xml:space="preserve">
          <source>Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Returns a &lt;code&gt;Pass&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, a &lt;code&gt;Fail&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it is &lt;code&gt;false&lt;/code&gt;, and an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it could not be evaluated.</source>
          <target state="translated">Тесты , что выражение &lt;code&gt;ex&lt;/code&gt; оценивает в &lt;code&gt;true&lt;/code&gt; . Возвращает &lt;code&gt;Pass&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; , если это произойдет, &lt;code&gt;Fail&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; , если оно &lt;code&gt;false&lt;/code&gt; , и &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; , если он не может быть оценен.</target>
        </trans-unit>
        <trans-unit id="17b9894fca3ff1649ca921b070f540e392fa37b8" translate="yes" xml:space="preserve">
          <source>Tests that the expression &lt;code&gt;expr&lt;/code&gt; throws &lt;code&gt;exception&lt;/code&gt;. The exception may specify either a type, or a value (which will be tested for equality by comparing fields). Note that &lt;code&gt;@test_throws&lt;/code&gt; does not support a trailing keyword form.</source>
          <target state="translated">Проверяет, что выражение &lt;code&gt;expr&lt;/code&gt; вызывает &lt;code&gt;exception&lt;/code&gt; . Исключение может указывать либо тип, либо значение (которое будет проверяться на равенство путем сравнения полей). Обратите внимание, что &lt;code&gt;@test_throws&lt;/code&gt; не поддерживает форму завершающего ключевого слова.</target>
        </trans-unit>
        <trans-unit id="ae181d6002e3e7b8e7869d12db427e89bc76200b" translate="yes" xml:space="preserve">
          <source>Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with 'P'.</source>
          <target state="translated">Тестирует принадлежность символа к пунктуации общей категории Юникода,т.е.символа,код категории которого начинается с 'P'.</target>
        </trans-unit>
        <trans-unit id="2a7a2ddabfc89454537a4dc9c09df6337da0be84" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.</source>
          <target state="translated">Проверяет,является ли персонаж управляющим.Контрольные символы являются непечатаемыми символами подмножества Latin-1 Unicode.</target>
        </trans-unit>
        <trans-unit id="c61df5952425542bbe698c6186d9e662be2fad8c" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a decimal digit (0-9).</source>
          <target state="translated">Проверяет,является ли символ десятичной цифрой (0-9).</target>
        </trans-unit>
        <trans-unit id="0ac236a3ea7a0e9ead5326f9e44c423dc78ebc26" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</source>
          <target state="translated">Тестирует,является ли символ строчной буквой.Символ классифицируется как строчная,если он принадлежит к Unicode категории Ll,Letter:Нижний регистр.</target>
        </trans-unit>
        <trans-unit id="91cdaf6d3cfe470a11194162162137ec98b73f57" translate="yes" xml:space="preserve">
          <source>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</source>
          <target state="translated">Тестирует,является ли символ заглавной буквой.Символ классифицируется как заглавная,если он принадлежит к Unicode категории Lu,Letter:Прописной или Lt,Letter:Заглавная буква.</target>
        </trans-unit>
        <trans-unit id="45909810023531a635329b57dc9f15acb810e806" translate="yes" xml:space="preserve">
          <source>Tests whether a character is any whitespace character. Includes ASCII characters '\t', '\n', '\v', '\f', '\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.</source>
          <target state="translated">Тестирует,является ли символ каким-либо пробелом.Включает символы ASCII '\t','\n','\v','\f','\r' и ' ',латинский-1 символ U+0085,а также символы категории Zs в стандарте Юникод.</target>
        </trans-unit>
        <trans-unit id="b0a4dc18e63052a8e4b050ac6060b42fea1cafaa" translate="yes" xml:space="preserve">
          <source>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.</source>
          <target state="translated">Проверяет,является ли символ числовым.Символ классифицируется как цифровой,если он принадлежит к общей категории Unicode Number,т.е.символ,код категории которого начинается с 'N'.</target>
        </trans-unit>
        <trans-unit id="982f0addad2d0da939982a5caca6283ccb1d7eb4" translate="yes" xml:space="preserve">
          <source>Tests whether a character is printable, including spaces, but not a control character.</source>
          <target state="translated">Проверяет,является ли символ печатаемым,включая пробелы,но не управляющий символ.</target>
        </trans-unit>
        <trans-unit id="e49525a9628b3bad0a6106685a8ac5eeac97a7e1" translate="yes" xml:space="preserve">
          <source>Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.</source>
          <target state="translated">Тестирует,определена ли глобальная переменная или поле объекта.Аргументами могут быть модуль и символ или составной объект и имя поля (как символ)или индекс.</target>
        </trans-unit>
        <trans-unit id="b292cfab7944ffbf6199920c5349913e95d9eeb7" translate="yes" xml:space="preserve">
          <source>Tests whether variable &lt;code&gt;s&lt;/code&gt; is defined in the current scope.</source>
          <target state="translated">Проверяет, определена ли переменная &lt;code&gt;s&lt;/code&gt; в текущей области.</target>
        </trans-unit>
        <trans-unit id="109f7c2f219315f947611c43c343d61302c960d4" translate="yes" xml:space="preserve">
          <source>Text I/O</source>
          <target state="translated">Текстовый ввод/вывод</target>
        </trans-unit>
        <trans-unit id="ea824a563aca9df06f453afa8aed6e59740fd02e" translate="yes" xml:space="preserve">
          <source>Text from external sources, such as quotations from books or websites, can be quoted using &lt;code&gt;&amp;gt;&lt;/code&gt; characters prepended to each line of the quote as follows.</source>
          <target state="translated">Текст из внешних источников, например цитаты из книг или веб-сайтов, можно цитировать, используя символы &lt;code&gt;&amp;gt;&lt;/code&gt; , добавленные к каждой строке цитаты следующим образом.</target>
        </trans-unit>
        <trans-unit id="fbe2b75f7fbda9be349dabaf963a9b88611d5493" translate="yes" xml:space="preserve">
          <source>That is really all there is to using promotions. The rest is just a matter of clever application, the most typical &quot;clever&quot; application being the definition of catch-all methods for numeric operations like the arithmetic operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;. Here are some of the catch-all method definitions given in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Это действительно все, что нужно для использования рекламных акций. Остальное - просто умное приложение, наиболее типичным &amp;laquo;умным&amp;raquo; приложением является определение универсальных методов для числовых операций, таких как арифметические операторы &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;/&lt;/code&gt; . Вот некоторые из определений универсальных методов, приведенных в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a55180ee0e35250f4a5e86928557c4ebfc2a5b49" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;fdot(x)&lt;/code&gt; is ten times faster and allocates 1/6 the memory of &lt;code&gt;f(x)&lt;/code&gt;, because each &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operation in &lt;code&gt;f(x)&lt;/code&gt; allocates a new temporary array and executes in a separate loop. (Of course, if you just do &lt;code&gt;f.(x)&lt;/code&gt; then it is as fast as &lt;code&gt;fdot(x)&lt;/code&gt; in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)</source>
          <target state="translated">То есть, &lt;code&gt;fdot(x)&lt;/code&gt; в десять раз быстрее и выделяет 1/6 памяти &lt;code&gt;f(x)&lt;/code&gt; , потому что каждая операция &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;+&lt;/code&gt; в &lt;code&gt;f(x)&lt;/code&gt; выделяет новый временный массив и выполняется в отдельном цикле. (Конечно, если вы просто выполните &lt;code&gt;f.(x)&lt;/code&gt; то в этом примере это будет так же быстро, как &lt;code&gt;fdot(x)&lt;/code&gt; , но во многих контекстах удобнее просто добавить несколько точек в свои выражения, чем определять отдельную функцию для каждую векторизованную операцию.)</target>
        </trans-unit>
        <trans-unit id="96ae6d125bf587e76e862ea35e250d9a1dd1ac01" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;maxintfloat&lt;/code&gt; returns the smallest positive integer-valued floating-point number &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;n+1&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exactly representable in the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">То есть, &lt;code&gt;maxintfloat&lt;/code&gt; возвращает наименьшее целое положительное число многозначных число с плавающей точкой &lt;code&gt;n&lt;/code&gt; такое , что &lt;code&gt;n+1&lt;/code&gt; является &lt;em&gt;не&lt;/em&gt; совсем представима в типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5135aa1a424ac6b5ea53a127625ebc585292c35c" translate="yes" xml:space="preserve">
          <source>That is, in the first call, the expression &lt;code&gt;:(1 == 1.0)&lt;/code&gt; is spliced into the test condition slot, while the value of &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the &lt;code&gt;@assert&lt;/code&gt; macro call occurs. Then at execution time, if the test expression evaluates to true, then &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the &lt;em&gt;value&lt;/em&gt; of the condition is available and it would be impossible to display the expression that computed it in the error message.</source>
          <target state="translated">То есть при первом вызове выражение &lt;code&gt;:(1 == 1.0)&lt;/code&gt; вставляется в слот условия проверки, а значение &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; вставляется в слот сообщения утверждения. &lt;code&gt;@assert&lt;/code&gt; таким образом выражение целиком помещается в синтаксическое дерево, где происходит вызов макроса @assert . Затем во время выполнения, если тестовое выражение оценивается как истинное, тогда &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; не возвращается, тогда как, если тест ложный, возникает ошибка, указывающая на утвержденное выражение, которое было ложным. Обратите внимание, что было бы невозможно записать это как функцию, поскольку доступно только &lt;em&gt;значение&lt;/em&gt; условия, и было бы невозможно отобразить выражение, которое его вычислило, в сообщении об ошибке.</target>
        </trans-unit>
        <trans-unit id="a5c2c27899b95213132fa8a21acc33667eaa425d" translate="yes" xml:space="preserve">
          <source>That is, write:</source>
          <target state="translated">То есть,пиши:</target>
        </trans-unit>
        <trans-unit id="d78e12b42ebbdc9ccff0d1ee38bf8bf79ad2272d" translate="yes" xml:space="preserve">
          <source>That may seem confusing, given that the hour (12) is not divisible by 10. The reason that &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; was chosen is that it is 17,676,660 hours after &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;, and 17,676,660 is divisible by 10.</source>
          <target state="translated">Это может показаться запутанным, учитывая, что час (12) не делится на 10. Причина, по которой был выбран вариант &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; , состоит в том, что это 17 676 660 часов после &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; , и 17 676 660 делится на 10.</target>
        </trans-unit>
        <trans-unit id="8eac926841ffd7462f202ab5376273deeb8cd2ba" translate="yes" xml:space="preserve">
          <source>That's all. This macro says that the literal contents of the string literal &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; should be passed to the &lt;code&gt;@r_str&lt;/code&gt; macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; is equivalent to placing the following object directly into the syntax tree:</source>
          <target state="translated">Вот и все. Этот макрос говорит, что буквальное содержимое строкового литерала &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; Должно быть передано в макрос &lt;code&gt;@r_str&lt;/code&gt; , а результат этого расширения должен быть помещен в синтаксическое дерево, где строковый литерал происходит. Другими словами, выражение &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; Эквивалентно помещению следующего объекта непосредственно в дерево синтаксиса:</target>
        </trans-unit>
        <trans-unit id="ececc5f47222691560cc9e3bee59dad9b3d640dc" translate="yes" xml:space="preserve">
          <source>The &quot;splat&quot; operator, &lt;code&gt;...&lt;/code&gt;, represents a sequence of arguments. &lt;code&gt;...&lt;/code&gt; can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. &lt;code&gt;...&lt;/code&gt; can also be used to apply a function to a sequence of arguments.</source>
          <target state="translated">Оператор &quot;splat&quot; &lt;code&gt;...&lt;/code&gt; представляет последовательность аргументов. &lt;code&gt;...&lt;/code&gt; может использоваться в определениях функций, чтобы указать, что функция принимает произвольное количество аргументов. &lt;code&gt;...&lt;/code&gt; также можно использовать для применения функции к последовательности аргументов.</target>
        </trans-unit>
        <trans-unit id="6e87b92b09ff210cf587ecb8ad71387d805a3837" translate="yes" xml:space="preserve">
          <source>The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value &lt;code&gt;0x04030201&lt;/code&gt;. Big-endian machines will contain the value &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">32-битная метка порядка байтов указывает собственный порядок байтов хост-машины. Машины с &lt;code&gt;0x04030201&lt;/code&gt; байтов будут содержать значение 0x04030201 . Машины с &lt;code&gt;0x01020304&lt;/code&gt; байтов будут содержать значение 0x01020304 .</target>
        </trans-unit>
        <trans-unit id="bc0d418f0a58caa5e7b5119be0993120b5604ac3" translate="yes" xml:space="preserve">
          <source>The 32-bit floating-point literal expression &lt;code&gt;1.5f22&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1.5&lt;/code&gt; multiplied by the variable &lt;code&gt;f22&lt;/code&gt;.</source>
          <target state="translated">32-битное буквальное выражение с плавающей запятой &lt;code&gt;1.5f22&lt;/code&gt; можно интерпретировать как числовой литерал &lt;code&gt;1.5&lt;/code&gt; , умноженный на переменную &lt;code&gt;f22&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0554b963c33c05a019079c25e9e8af324781e9db" translate="yes" xml:space="preserve">
          <source>The 5 allocations seen are from running the &lt;code&gt;@time&lt;/code&gt; macro itself in global scope. If we instead run the timing in a function, we can see that indeed no allocations are performed:</source>
          <target state="translated">5 замеченных распределений связаны с запуском самого макроса &lt;code&gt;@time&lt;/code&gt; в глобальной области видимости. Если вместо этого мы запустим тайминг в функции, мы увидим, что на самом деле никакие выделения не выполняются:</target>
        </trans-unit>
        <trans-unit id="f454420e121c88ed4ff052968b927a4892010960" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.@NamedTuple&quot;&gt;&lt;code&gt;@NamedTuple&lt;/code&gt;&lt;/a&gt; macro can be used for conveniently declaring &lt;code&gt;NamedTuple&lt;/code&gt; types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dea49356c38a6636e3d8df6877285b62b149f3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt;&lt;code&gt;Logging.shouldlog&lt;/code&gt;&lt;/a&gt; function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically. Most usefully, &lt;code&gt;shouldlog&lt;/code&gt; is passed an event &lt;code&gt;id&lt;/code&gt; which can be used to discard events early based on a cached predicate.</source>
          <target state="translated">Функция &lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt; &lt;code&gt;Logging.shouldlog&lt;/code&gt; &lt;/a&gt; вызывается с текущим регистратором, принимая некоторую минимальную информацию (уровень, модуль, группа, идентификатор), которая может быть вычислена статически. Наиболее полезно, что в &lt;code&gt;shouldlog&lt;/code&gt; передается &lt;code&gt;id&lt;/code&gt; события, который можно использовать для раннего отбрасывания событий на основе кэшированного предиката.</target>
        </trans-unit>
        <trans-unit id="9817feb15ee575eea4a8ff720d63067615a333e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types implements arbitrary-precision floating point and integer arithmetic, respectively. For &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://www.mpfr.org/&quot;&gt;GNU MPFR library&lt;/a&gt; is used, and for &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; is used.</source>
          <target state="translated">В &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; типы орудий произвольной точности с плавающей точкой и целочисленной арифметики, соответственно. Для &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://www.mpfr.org/&quot;&gt; библиотека GNU MPFR&lt;/a&gt; используется и для &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://gmplib.org&quot;&gt; GNU Multiple Precision Арифметика Library (GMP)&lt;/a&gt; используется.</target>
        </trans-unit>
        <trans-unit id="ad3f2b7adf33af93573e441a9559f7a7900079c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; functions ultimately call &lt;code&gt;show&lt;/code&gt; in order to write an object &lt;code&gt;x&lt;/code&gt; as a given &lt;code&gt;mime&lt;/code&gt; type to a given I/O stream &lt;code&gt;io&lt;/code&gt; (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type &lt;code&gt;T&lt;/code&gt;, it is only necessary to define a new &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;T&lt;/code&gt;, via: &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt;, where &lt;code&gt;mime&lt;/code&gt; is a MIME-type string and the function body calls &lt;a href=&quot;#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; (or similar) to write that representation of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;io&lt;/code&gt;. (Note that the &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; notation only supports literal strings; to construct &lt;code&gt;MIME&lt;/code&gt; types in a more flexible manner use &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt;.)</source>
          <target state="translated">Функции &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; конечном итоге вызывают &lt;code&gt;show&lt;/code&gt; , чтобы записать объект &lt;code&gt;x&lt;/code&gt; как заданный тип &lt;code&gt;mime&lt;/code&gt; в заданный поток ввода-вывода &lt;code&gt;io&lt;/code&gt; (обычно буфер памяти), если это возможно. Чтобы обеспечить богатое мультимедийное представление определяемого пользователем типа &lt;code&gt;T&lt;/code&gt; , необходимо только определить новый метод &lt;code&gt;show&lt;/code&gt; для &lt;code&gt;T&lt;/code&gt; через: &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt; , где &lt;code&gt;mime&lt;/code&gt; - это строка типа MIME, а тело функции вызывает &lt;a href=&quot;#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; (или подобное), чтобы записать это представление &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;io&lt;/code&gt; . (Обратите внимание, что &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; нотация поддерживает только буквальные строки; для более гибкого создания типов &lt;code&gt;MIME&lt;/code&gt; используйте &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="5436a7d5a656260665ad063d5ab1e6eff72c987d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt;&lt;code&gt;r&lt;/code&gt; controls the direction of the rounding; the default is &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that &lt;code&gt;round&lt;/code&gt; may give incorrect results if the global rounding mode is changed (see &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">В &lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt; &lt;code&gt;r&lt;/code&gt; управляет направлением закругления; значение по умолчанию - &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt; , которое округляется до ближайшего целого числа, причем связи (дробные значения 0,5) округляются до ближайшего четного целого числа. Обратите внимание, что &lt;code&gt;round&lt;/code&gt; может дать неверные результаты при изменении глобального режима округления (см. &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="36e18d121f5a838cc6709524d85e5f444560cd8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Dates.dayname&quot;&gt;&lt;code&gt;dayname&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthname&quot;&gt;&lt;code&gt;monthname&lt;/code&gt;&lt;/a&gt; methods can also take an optional &lt;code&gt;locale&lt;/code&gt; keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely &lt;a href=&quot;#Dates.dayabbr&quot;&gt;&lt;code&gt;dayabbr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthabbr&quot;&gt;&lt;code&gt;monthabbr&lt;/code&gt;&lt;/a&gt;. First the mapping is loaded into the &lt;code&gt;LOCALES&lt;/code&gt; variable:</source>
          <target state="translated">В &lt;a href=&quot;#Dates.dayname&quot;&gt; &lt;code&gt;dayname&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.monthname&quot;&gt; &lt;code&gt;monthname&lt;/code&gt; &lt;/a&gt; метода может также принимать необязательный &lt;code&gt;locale&lt;/code&gt; ключевое слово , которое может быть использовано , чтобы вернуть название дня или месяц года для других языков / языков. Существуют также версии этих функций, возвращающих сокращенные имена, а именно &lt;a href=&quot;#Dates.dayabbr&quot;&gt; &lt;code&gt;dayabbr&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.monthabbr&quot;&gt; &lt;code&gt;monthabbr&lt;/code&gt; &lt;/a&gt; . Сначала отображение загружается в переменную &lt;code&gt;LOCALES&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b0ea31c9b36eaba5425ec694eab3ed041d8c9eef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Logging.Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; module provides a way to record the history and progress of a computation as a log of events. Events are created by inserting a logging statement into the source code, for example:</source>
          <target state="translated">Модуль &lt;a href=&quot;#Logging.Logging&quot;&gt; &lt;code&gt;Logging&lt;/code&gt; &lt;/a&gt; предоставляет способ записывать историю и ход вычислений в виде журнала событий. События создаются путем вставки оператора регистрации в исходный код, например:</target>
        </trans-unit>
        <trans-unit id="3c601dd00846e1bc1e44a6ddd894b45f7d42da42" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Logging.shouldlog&quot;&gt;&lt;code&gt;Logging.shouldlog&lt;/code&gt;&lt;/a&gt; function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically. Most usefully, &lt;code&gt;shouldlog&lt;/code&gt; is passed an event &lt;code&gt;id&lt;/code&gt; which can be used to discard events early based on a cached predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb88735d7a5a0928051c7ed6f644aff1c31082e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Rounding-functions&quot;&gt;Rounding functions&lt;/a&gt; take a type &lt;code&gt;T&lt;/code&gt; as an optional argument. For example, &lt;code&gt;round(Int,x)&lt;/code&gt; is a shorthand for &lt;code&gt;Int(round(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0d2cdace4e12d15a4692bf023ef78f32612455" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Rounding-functions-1&quot;&gt;Rounding functions&lt;/a&gt; take a type &lt;code&gt;T&lt;/code&gt; as an optional argument. For example, &lt;code&gt;round(Int,x)&lt;/code&gt; is a shorthand for &lt;code&gt;Int(round(x))&lt;/code&gt;.</source>
          <target state="translated">Функции &lt;a href=&quot;#Rounding-functions-1&quot;&gt;округления&lt;/a&gt; принимают тип &lt;code&gt;T&lt;/code&gt; в качестве необязательного аргумента. Например, &lt;code&gt;round(Int,x)&lt;/code&gt; - это сокращение от &lt;code&gt;Int(round(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb87235a3e582308fdae141ff9f8e2932202086" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector &lt;code&gt;I&lt;/code&gt; of row indices, a vector &lt;code&gt;J&lt;/code&gt; of column indices, and a vector &lt;code&gt;V&lt;/code&gt; of stored values (this is also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO (coordinate) format&lt;/a&gt;). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; then constructs a sparse matrix such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The equivalent sparse vector constructor is &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt;, which takes the (row) index vector &lt;code&gt;I&lt;/code&gt; and the vector &lt;code&gt;V&lt;/code&gt; with the stored values and constructs a sparse vector &lt;code&gt;R&lt;/code&gt; such that &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; часто является удобным способом создания разреженных массивов. Например, чтобы построить разреженную матрицу, мы можем ввести вектор &lt;code&gt;I&lt;/code&gt; индексов строк, вектор &lt;code&gt;J&lt;/code&gt; индексов столбцов и вектор &lt;code&gt;V&lt;/code&gt; сохраненных значений (это также известно как &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;формат COO (координата)&lt;/a&gt; ). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; затем строит разреженную матрицу, такую ​​что &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; . Эквивалентным конструктором разреженных векторов является &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt; , который берет индексный вектор (строку) &lt;code&gt;I&lt;/code&gt; и вектор &lt;code&gt;V&lt;/code&gt; с сохраненными значениями и создает разреженный вектор &lt;code&gt;R&lt;/code&gt; такой, что &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b105317bea9286064ba65c3dd65ad287bf9e16f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.@NamedTuple&quot;&gt;&lt;code&gt;@NamedTuple&lt;/code&gt;&lt;/a&gt; macro provides a more convenient &lt;code&gt;struct&lt;/code&gt;-like syntax for declaring &lt;code&gt;NamedTuple&lt;/code&gt; types via &lt;code&gt;key::Type&lt;/code&gt; declarations, where an omitted &lt;code&gt;::Type&lt;/code&gt; corresponds to &lt;code&gt;::Any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce4dd4aa2504c940aa48ceeab07c53ca96b6449" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; can be a block:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt; макрос переписывает этот вызов , чтобы быть точно эквивалентными выше длинных версий. Для более длинных блоков сгенерированного кода аргумент выражения, передаваемый &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; ,&lt;/a&gt; может быть блоком:</target>
        </trans-unit>
        <trans-unit id="38ef0a3b168bd74d25880aec3b78cf19271d94b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt; macro makes use of &lt;code&gt;@__doc__&lt;/code&gt; to allow for documenting &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;s. Examining its definition should serve as an example of how to use &lt;code&gt;@__doc__&lt;/code&gt; correctly.</source>
          <target state="translated">В &lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; &lt;/a&gt; макрос использует &lt;code&gt;@__doc__&lt;/code&gt; , чтобы обеспечить документирование &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; s. Изучение его определения должно служить примером того, как правильно использовать &lt;code&gt;@__doc__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acfadefe2bb6121d5e848cbd0b9afe7e8768d52d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function is used to produce an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; that interrupts the normal flow of control.</source>
          <target state="translated">Функция &lt;a href=&quot;../../base/base/index#Base.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; используется для создания &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; которое прерывает нормальный поток управления.</target>
        </trans-unit>
        <trans-unit id="fd385b6cfaa8837c37589622c3c706028ad36f1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt; operator is another exception: &lt;code&gt;missing&lt;/code&gt; is considered as greater than any other value. This operator is used by &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, which therefore places &lt;code&gt;missing&lt;/code&gt; values after all other values.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt; оператор является еще одним исключением: &lt;code&gt;missing&lt;/code&gt; , считается больше , чем любое другое значение. Этот оператор используется при &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; , поэтому &lt;code&gt;missing&lt;/code&gt; значения помещаются после всех остальных значений.</target>
        </trans-unit>
        <trans-unit id="4d17e67e8157d57768d314d2878bcbffb2b8fe95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions also apply to floating-point types:</source>
          <target state="translated">Функции &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; также применимы к типам с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="ebd60a4f944bf87ca60e53bffccdaf6c4d569a54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; function confirms that the &quot;two&quot; constructed instances of &lt;code&gt;NoFields&lt;/code&gt; are actually one and the same. Singleton types are described in further detail &lt;a href=&quot;#man-singleton-types&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de73ba08a71f852e7d2733fa6dfed62a7f72340d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; function confirms that the &quot;two&quot; constructed instances of &lt;code&gt;NoFields&lt;/code&gt; are actually one and the same. Singleton types are described in further detail &lt;a href=&quot;#man-singleton-types-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; подтверждает, что &amp;laquo;два&amp;raquo; сконструированных экземпляра &lt;code&gt;NoFields&lt;/code&gt; на самом деле являются одним и тем же. Типы Singleton более подробно описаны &lt;a href=&quot;#man-singleton-types-1&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d77ec66ab2077f795aecb0927e53656b9c9cc945" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:</source>
          <target state="translated">Конструктор &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; принимает любое количество аргументов и создает новый символ, объединяя их строковые представления вместе:</target>
        </trans-unit>
        <trans-unit id="414514dfacecedf70ecbd06d5fef52f6a37552e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt; function tests if an object is of a given type and returns true or false:</source>
          <target state="translated">Функция &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa&lt;/code&gt; &lt;/a&gt; проверяет, принадлежит ли объект заданному типу, и возвращает истину или ложь:</target>
        </trans-unit>
        <trans-unit id="bf1b3d1c04844d76b7ef3cb166b81958a1f65c08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; функции</target>
        </trans-unit>
        <trans-unit id="b96dfc29471c7f4e7faf38271fb34f184e922afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</source>
          <target state="translated">Функция &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;/a&gt; , уже используемая в руководстве в примерах, возвращает тип своего аргумента. Поскольку, как отмечалось выше, типы являются объектами, у них также есть типы, и мы можем спросить, каковы их типы:</target>
        </trans-unit>
        <trans-unit id="0d827a86b6df88cc411d1f3d30cdcddabf2bc33a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; keyword supports the same syntax as &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt;, but only operates on a single name at a time. It does not add modules to be searched the way &lt;code&gt;using&lt;/code&gt; does. &lt;code&gt;import&lt;/code&gt; also differs from &lt;code&gt;using&lt;/code&gt; in that functions imported using &lt;code&gt;import&lt;/code&gt; can be extended with new methods.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; ключевых слов поддерживает тот же синтаксис, &lt;a href=&quot;../../base/base/index#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; , но действует только на одно имя в то время. Это не добавляет модули для поиска пути с &lt;code&gt;using&lt;/code&gt; делает. &lt;code&gt;import&lt;/code&gt; также отличается от &lt;code&gt;using&lt;/code&gt; тем, что функции, импортированные с помощью &lt;code&gt;import&lt;/code&gt; , могут быть расширены новыми методами.</target>
        </trans-unit>
        <trans-unit id="fb6064acb840b23c310e96e72bfc362b78efc865" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; keyword supports the same syntax as &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt;. It does not add modules to be searched the way &lt;code&gt;using&lt;/code&gt; does. &lt;code&gt;import&lt;/code&gt; also differs from &lt;code&gt;using&lt;/code&gt; in that functions imported using &lt;code&gt;import&lt;/code&gt; can be extended with new methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec874bb7238b430b76f31f6a2f70602d5cd36c3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt; type is essentially a synonym for &lt;code&gt;Ptr{UInt8}&lt;/code&gt;, except the conversion to &lt;code&gt;Cstring&lt;/code&gt; throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator). If you are passing a &lt;code&gt;char*&lt;/code&gt; to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use &lt;code&gt;Ptr{UInt8}&lt;/code&gt; as the argument type. &lt;code&gt;Cstring&lt;/code&gt; can also be used as the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</source>
          <target state="translated">Тип &lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; ,&lt;/a&gt; по сути, является синонимом &lt;code&gt;Ptr{UInt8}&lt;/code&gt; , за исключением того, что преобразование в &lt;code&gt;Cstring&lt;/code&gt; вызывает ошибку, если строка Julia содержит какие-либо встроенные символы NUL (что приведет к молчаливому усечению строки, если процедура C рассматривает NUL как терминатор) , Если вы передаете &lt;code&gt;char*&lt;/code&gt; в процедуру C, которая не предполагает завершения NUL (например, потому что вы передаете явную длину строки), или если вы точно знаете, что ваша строка Julia не содержит NUL и хотите пропустить проверку, вы может использовать &lt;code&gt;Ptr{UInt8}&lt;/code&gt; в качестве типа аргумента. &lt;code&gt;Cstring&lt;/code&gt; также может использоваться как &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; возвращаемый тип, но в этом случае он, очевидно, не вводит никаких дополнительных проверок и предназначен только для улучшения читаемости вызова.</target>
        </trans-unit>
        <trans-unit id="2ca3ede71d20c319ef4b7f43097716ec7d74586d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;&lt;code&gt;irange&lt;/code&gt; specifies indices of the sorted eigenvalues to search for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe5df294c64ae2bc17b6c645704bd7bc62ca16b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;Base.filter&lt;/code&gt;&lt;/a&gt; method can be used to obtain all valid dates/moments in a specified range:</source>
          <target state="translated">Метод &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;Base.filter&lt;/code&gt; &lt;/a&gt; можно использовать для получения всех действительных дат / моментов в указанном диапазоне:</target>
        </trans-unit>
        <trans-unit id="32116ae8c0495cf49f4c9c66e837a3e4255f5c44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt; function provides indented and annotated display of &lt;code&gt;Expr&lt;/code&gt; objects:</source>
          <target state="translated">Функция &lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt; &lt;code&gt;dump&lt;/code&gt; &lt;/a&gt; обеспечивает отображение объектов &lt;code&gt;Expr&lt;/code&gt; с отступами и аннотациями :</target>
        </trans-unit>
        <trans-unit id="63e3ea8e88f5b981ca22a0c9f75818db8e88281d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt;&lt;code&gt;@threadcall&lt;/code&gt;&lt;/a&gt; macro addresses scenarios where we do not want a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to block the main Julia event loop. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt;. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that &lt;code&gt;@threadcall&lt;/code&gt; does not return till the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.</source>
          <target state="translated">В &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt; &lt;code&gt;@threadcall&lt;/code&gt; &lt;/a&gt; макро адрес сценариев , в которых мы не хотим &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; блокировать основной цикл событий Юлия. Он планирует выполнение функции C в отдельном потоке. Для этого используется пул потоков с размером по умолчанию 4. Размер пула потоков управляется переменной среды &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; . В ожидании свободного потока и во время выполнения функции, когда поток становится доступным, запрашивающая задача (в основном цикле событий Julia) уступает место другим задачам. Обратите внимание, что &lt;code&gt;@threadcall&lt;/code&gt; не возвращается, пока выполнение не будет завершено. Поэтому с точки зрения пользователя это блокирующий вызов, как и другие API-интерфейсы Julia.</target>
        </trans-unit>
        <trans-unit id="c1836413cdf1d297fe2f1a01545184ccffbd9cb1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt;&lt;code&gt;@threadcall&lt;/code&gt;&lt;/a&gt; macro provides a way to avoid stalling execution in such a scenario. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt;. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that &lt;code&gt;@threadcall&lt;/code&gt; does not return until the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9980cd05996241c9e77ece29af3cb2e812c97a73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; type is a direct child type of &lt;code&gt;Any&lt;/code&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is its child. In turn, &lt;code&gt;Real&lt;/code&gt; has two children (it has more, but only two are shown here; we'll get to the others later): &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt;, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, &lt;code&gt;AbstractFloat&lt;/code&gt; is a proper subtype of &lt;code&gt;Real&lt;/code&gt;, including only floating-point representations of real numbers. Integers are further subdivided into &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; varieties.</source>
          <target state="translated">Тип &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; является прямым дочерним типом &lt;code&gt;Any&lt;/code&gt; , а &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; - его дочерним типом . В свою очередь, у &lt;code&gt;Real&lt;/code&gt; есть два дочерних элемента (их больше, но здесь показаны только два; мы вернемся к другим позже): &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt; , разделяющие мир на представления целых чисел и представления действительных чисел. Представления действительных чисел, конечно же, включают типы с плавающей запятой, но также включают и другие типы, такие как рациональные числа. Следовательно, &lt;code&gt;AbstractFloat&lt;/code&gt; - это правильный подтип &lt;code&gt;Real&lt;/code&gt; , включающий только представления вещественных чисел с плавающей запятой. Целые числа далее подразделяются на &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; сорта.</target>
        </trans-unit>
        <trans-unit id="baf410f301db00bfb07a3204858e468ec6990386" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; function blocks the calling task until some other task finishes. So for example if you type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61c350b843f41f66bd6a94fb06646bf09f7c269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; function MUST exit as soon as all the requested workers have been launched.</source>
          <target state="translated">Метод &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; вызывается асинхронно в отдельной задаче. Завершение этой задачи означает, что все запрошенные рабочие процессы были запущены. Следовательно, функция &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; ДОЛЖНА завершиться, как только все запрошенные рабочие процессы будут запущены.</target>
        </trans-unit>
        <trans-unit id="e5928b30867a053dbff6206d1bc20c56f14e738b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method takes the following arguments:</source>
          <target state="translated">Метод &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; принимает следующие аргументы:</target>
        </trans-unit>
        <trans-unit id="f3209cd500cde4d2208651c2f2fd51b7059c49bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;literal numeric coefficient notation&lt;/a&gt; does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b33ac485b0a3f8ebfda5064c9e3efc2a8bcfdcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;literal numeric coefficient notation&lt;/a&gt; does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:</source>
          <target state="translated">&lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;Буквальное числовой коэффициент обозначение&lt;/a&gt; не работает при построении комплексного числа от переменных. Вместо этого умножение должно быть явно записано:</target>
        </trans-unit>
        <trans-unit id="caedc4f0f18d64cfcc829cf6a132a779a017790d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../strings/index#man-concatenation&quot;&gt;main argument&lt;/a&gt; against &lt;code&gt;+&lt;/code&gt; is that string concatenation is not commutative, while &lt;code&gt;+&lt;/code&gt; is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and &lt;code&gt;*&lt;/code&gt; may be unfamiliar for some users, it communicates certain algebraic properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275af0000e44bc521cd56c3026533fc5cd78a5de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;main argument&lt;/a&gt; against &lt;code&gt;+&lt;/code&gt; is that string concatenation is not commutative, while &lt;code&gt;+&lt;/code&gt; is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and &lt;code&gt;*&lt;/code&gt; may be unfamiliar for some users, it communicates certain algebraic properties.</source>
          <target state="translated">&lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;Основной аргумент&lt;/a&gt; против &lt;code&gt;+&lt;/code&gt; является то , что конкатенация не является коммутативной, в то время как &lt;code&gt;+&lt;/code&gt; , как правило , используются в качестве коммутативным оператора. Хотя сообщество Julia признает, что в других языках используются другие операторы и &lt;code&gt;*&lt;/code&gt; могут быть незнакомы для некоторых пользователей, оно передает определенные алгебраические свойства.</target>
        </trans-unit>
        <trans-unit id="c14035985c996abe00f4042cc746b4176aab2201" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames package&lt;/a&gt; provides data frames.</source>
          <target state="translated">Пакет &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames&lt;/a&gt; предоставляет фреймы данных.</target>
        </trans-unit>
        <trans-unit id="1d1ea15f36c87296348b2ee87ead9f02bdc36c83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JunoLab/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; package can help you find common performance problems in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ebf2c6b9c4eb22391edbc55310df1678b26195" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; package can help you find common performance problems in your code.</source>
          <target state="translated">Пакет &lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; может помочь вам найти общие проблемы с производительностью в вашем коде.</target>
        </trans-unit>
        <trans-unit id="09270743df4b19bd666f57937fe0296a7b3d369a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (here assumed to be accessible through &lt;code&gt;:libgsl&lt;/code&gt;) defines an opaque pointer, &lt;code&gt;gsl_permutation *&lt;/code&gt;, as the return type of the C function &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;. As user code never has to look inside the &lt;code&gt;gsl_permutation&lt;/code&gt; struct, the corresponding Julia wrapper simply needs a new type declaration, &lt;code&gt;gsl_permutation&lt;/code&gt;, that has no internal fields and whose sole purpose is to be placed in the type parameter of a &lt;code&gt;Ptr&lt;/code&gt; type. The return type of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is declared as &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, since the memory allocated and pointed to by &lt;code&gt;output_ptr&lt;/code&gt; is controlled by C (and not Julia).</source>
          <target state="translated">&lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (здесь предполагается , должны быть доступны через &lt;code&gt;:libgsl&lt;/code&gt; ) определяет непрозрачный указатель, &lt;code&gt;gsl_permutation *&lt;/code&gt; , как тип возвращаемого значения функции C &lt;code&gt;gsl_permutation_alloc&lt;/code&gt; . Поскольку пользовательский код никогда не должен заглядывать внутрь структуры &lt;code&gt;gsl_permutation&lt;/code&gt; , соответствующей оболочке Julia просто требуется объявление нового типа, &lt;code&gt;gsl_permutation&lt;/code&gt; , у которого нет внутренних полей и единственная цель которого - быть помещена в параметр типа типа &lt;code&gt;Ptr&lt;/code&gt; . Тип возвращаемого значения &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; объявлен как &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; , поскольку память выделена и указана &lt;code&gt;output_ptr&lt;/code&gt; контролируется C (а не Джулией).</target>
        </trans-unit>
        <trans-unit id="a5024e48ba7e7691b4d6acf8617bee0fb07d889c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (here assumed to be accessible through &lt;code&gt;:libgsl&lt;/code&gt;) defines an opaque pointer, &lt;code&gt;gsl_permutation *&lt;/code&gt;, as the return type of the C function &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;. As user code never has to look inside the &lt;code&gt;gsl_permutation&lt;/code&gt; struct, the corresponding Julia wrapper simply needs a new type declaration, &lt;code&gt;gsl_permutation&lt;/code&gt;, that has no internal fields and whose sole purpose is to be placed in the type parameter of a &lt;code&gt;Ptr&lt;/code&gt; type. The return type of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is declared as &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, since the memory allocated and pointed to by &lt;code&gt;output_ptr&lt;/code&gt; is controlled by C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add9fe6066c4b3711f11f5e626b62cf52c5e5aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; characters are still parsed as string interpolation or start of an escape sequence in docstrings too. The &lt;code&gt;raw&quot;&quot;&lt;/code&gt; string macro together with the &lt;code&gt;@doc&lt;/code&gt; macro can be used to avoid having to escape them. This is handy when the docstrings include LaTeX or Julia source code examples containing interpolation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ea3eda7ce888d73eff517a4ef953491525adf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; syntax is deprecated, use the &lt;code&gt;Ref{T}&lt;/code&gt; argument type instead.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; Синтаксис нежелателен, используйте &lt;code&gt;Ref{T}&lt;/code&gt; , тип аргументов вместо этого.</target>
        </trans-unit>
        <trans-unit id="ff8eac00092307ddc7d1e59e50812b91cc8012ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;:&lt;/code&gt; operator in general means &quot;is a subtype of&quot;, and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns &lt;code&gt;true&lt;/code&gt; when its left operand is a subtype of its right operand:</source>
          <target state="translated">Оператор &lt;code&gt;&amp;lt;:&lt;/code&gt; в целом означает &amp;laquo;является подтипом&amp;raquo; и, используемый в подобных объявлениях, объявляет правый тип как непосредственный супертип вновь объявленного типа. Его также можно использовать в выражениях как оператор подтипа, который возвращает &lt;code&gt;true&lt;/code&gt; если его левый операнд является подтипом его правого операнда:</target>
        </trans-unit>
        <trans-unit id="1d1649fbe8e01a8ee7d8ead051328750570da1e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, return type, and input types must be literal constants (i.e., they can't be variables, but see &lt;a href=&quot;#Non-constant-Function-Specifications&quot;&gt;Non-constant Function Specifications&lt;/a&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462f03c3cade5b2449ca60ca2d04cc3130736218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; разделитель может быть использован для разделения аргументов командной строки , предназначенных для файла сценария из аргументов , предназначенных для Юли:</target>
        </trans-unit>
        <trans-unit id="b62e329ad97e7f8cc85f80ec7eb642548e51e86b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument requires at least Julia 1.5. In older versions you must use the environment variable instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715fb1cbad5e27d977534841ecb00d2691680981" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;2x + y&lt;/code&gt; definition is only used in the first case, while the &lt;code&gt;2x - y&lt;/code&gt; definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. &lt;sup&gt;&lt;a href=&quot;#footnote-Clarke61&quot; id=&quot;citeref-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396147a6b9dfacff46d28874aadee188884bc052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;2x + y&lt;/code&gt; definition is only used in the first case, while the &lt;code&gt;2x - y&lt;/code&gt; definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</source>
          <target state="translated">Определение &lt;code&gt;2x + y&lt;/code&gt; используется только в первом случае, а определение &lt;code&gt;2x - y&lt;/code&gt; используется в остальных. Никакое автоматическое приведение или преобразование аргументов функции никогда не выполняется: все преобразования в Julia не являются магическими и полностью явными. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Однако &amp;laquo;Преобразование и продвижение&amp;raquo;&lt;/a&gt; показывает, насколько умное применение достаточно продвинутой технологии может быть неотличимо от магии. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="702c47148e007cd263dc6deb6727c14f26afb82e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:</source>
          <target state="translated">Оператор &lt;code&gt;::&lt;/code&gt; может использоваться для присоединения аннотаций типов к выражениям и переменным в программах. Для этого есть две основные причины:</target>
        </trans-unit>
        <trans-unit id="a4ee1c478f2612aec54bd174690fa6ea35ddb91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;/code&gt; character has two syntactic purposes in Julia. The first form creates a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;interned string&lt;/a&gt; used as one building-block of expressions:</source>
          <target state="translated">У символа &lt;code&gt;:&lt;/code&gt; две синтаксические цели в Julia. Первая форма создает &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;интернированную строку,&lt;/a&gt; используемую в качестве одного строительного блока выражений:</target>
        </trans-unit>
        <trans-unit id="353d9f2d22e6c55c71578ee1d9f5c97d21c6a0cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:any&lt;/code&gt; argument is available as of Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c311a5c224de0110d74a449183e9149c5a0fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@assert&lt;/code&gt; macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.</source>
          <target state="translated">&lt;code&gt;@assert&lt;/code&gt; макрос делает большое использование сплайсинга в цитируемые выражения для упрощения манипуляции выражений внутри тела макроса.</target>
        </trans-unit>
        <trans-unit id="801ed9019f04c0f8f529dacee5be7631d5e276fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@boundscheck&lt;/code&gt; annotation allows you, as a library writer, to opt-in to allowing &lt;em&gt;other code&lt;/em&gt; to remove your bounds checks with &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;. As noted there, the caller must verify&amp;mdash;using information they can access&amp;mdash;that their accesses are valid before using &lt;code&gt;@inbounds&lt;/code&gt;. For indexing into your &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; subclasses, for example, this involves checking the indices against its &lt;a href=&quot;../arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;code&gt;@boundscheck&lt;/code&gt; annotations should only be added to a &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; implementation after you are certain its behavior is correct.</source>
          <target state="translated">&lt;code&gt;@boundscheck&lt;/code&gt; аннотации позволяют, как библиотека писатель, чтобы отказаться в позволяя &lt;em&gt;другой код&lt;/em&gt; , чтобы удалить вашу ограничивающую проверку с &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; . Как отмечено там, вызывающий должен проверить - используя информацию, к которой он имеет доступ, - что их доступ действителен, прежде чем использовать &lt;code&gt;@inbounds&lt;/code&gt; . Например, для индексации в ваши подклассы &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; это включает проверку индексов по его &lt;a href=&quot;../arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; . Следовательно, аннотации &lt;code&gt;@boundscheck&lt;/code&gt; следует добавлять только в &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; реализация после того, как вы убедитесь, что его поведение правильное.</target>
        </trans-unit>
        <trans-unit id="ec599750f5ec83c5af3c5362e9301d9cdbbe1ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; macro associates its first argument with its second in a per-module dictionary called &lt;code&gt;META&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d04719fe4369bb879f4c27763dea9901ff5736f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; macro associates its first argument with its second in a per-module dictionary called &lt;code&gt;META&lt;/code&gt;. By default, documentation is expected to be written in Markdown, and the &lt;code&gt;doc&quot;&quot;&lt;/code&gt; string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; макрос связывает свой первый аргумент со своим вторым в словаре для каждого модуля под названием &lt;code&gt;META&lt;/code&gt; . По умолчанию ожидается, что документация будет написана в Markdown, а строковый макрос &lt;code&gt;doc&quot;&quot;&lt;/code&gt; просто создает объект, представляющий содержимое Markdown. В будущем он, вероятно, будет делать более сложные вещи, например, разрешать относительные пути к изображениям или ссылкам.</target>
        </trans-unit>
        <trans-unit id="3901521653150d23278fa27f787a9dbcf11d8111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@simd&lt;/code&gt; does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; to also assert that:</source>
          <target state="translated">&lt;code&gt;@simd&lt;/code&gt; не утверждает , по умолчанию , что цикл полностью свободен от зависимостей памяти петель переносимых, что предположение , что может быть легко нарушено в родовом коде. Если вы пишете не общий код, вы можете использовать &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; чтобы также утверждать, что:</target>
        </trans-unit>
        <trans-unit id="22755b36a58e8494f0fc686a468ea1d881c82d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; form is equivalent to writing &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; which can be useful when the expression is a call using infix syntax such as approximate comparisons:</source>
          <target state="translated">Форма &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; эквивалентна записи &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; которая может быть полезна, когда выражение является вызовом с использованием инфиксного синтаксиса. например, приблизительные сравнения:</target>
        </trans-unit>
        <trans-unit id="16c63b805f73cc977b60037a10997e30bb4b9947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">Форма &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; работает как макрос &lt;code&gt;@test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abdc5ad65294f55eba9140a8f0b4f4933db8d022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">Форма &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; работает как макрос &lt;code&gt;@test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d32bc610a43028740032f0894a8d5b65d4647e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@testset&lt;/code&gt; macro can be used to group tests into &lt;em&gt;sets&lt;/em&gt;. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a &lt;code&gt;TestSetException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@testset&lt;/code&gt; макрос может использоваться для групповых тестов в &lt;em&gt;наборы&lt;/em&gt; . Будут запущены все тесты в наборе тестов, и в конце набора тестов будет напечатана сводка. Если какой-либо из тестов &lt;code&gt;TestSetException&lt;/code&gt; неудачно или не мог быть оценен из-за ошибки, набор тестов затем выдаст TestSetException .</target>
        </trans-unit>
        <trans-unit id="6e1109eb4b0b82fe1adad014b7f4cf1b1315fb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threadcall&lt;/code&gt; macro is called in the same way as &lt;a href=&quot;../c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main &lt;code&gt;julia&lt;/code&gt; thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; environment variable and restarting the &lt;code&gt;julia&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;@threadcall&lt;/code&gt; макрос вызывается таким же образом , как &lt;a href=&quot;../c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; но делает работу в другом потоке. Это полезно, когда вы хотите вызвать блокирующую функцию C без блокировки основного потока &lt;code&gt;julia&lt;/code&gt; . Параллелизм ограничен размером пула потоков libuv, который по умолчанию составляет 4 потока, но его можно увеличить, установив &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; среды UV_THREADPOOL_SIZE и перезапустив процесс &lt;code&gt;julia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be390301ffbdbbfe0c2a21aa488c727a5bb08d3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threads&lt;/code&gt; Macro</source>
          <target state="translated">В &lt;code&gt;@threads&lt;/code&gt; Macro</target>
        </trans-unit>
        <trans-unit id="3926862dd6a57d44f61884e7fbb13c9a98fc27be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@views&lt;/code&gt; macro only affects &lt;code&gt;array[...]&lt;/code&gt; expressions that appear explicitly in the given &lt;code&gt;expression&lt;/code&gt;, not array slicing that occurs in functions called by that code.</source>
          <target state="translated">&lt;code&gt;@views&lt;/code&gt; макрос влияет только &lt;code&gt;array[...]&lt;/code&gt; выражения , которые появляются явно в данном &lt;code&gt;expression&lt;/code&gt; , не массив нарезку , что происходит в функциях , вызываемых этим кодом.</target>
        </trans-unit>
        <trans-unit id="744985bd7018fe47b7df392a0c9d1bf69ee2f566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractArray&lt;/code&gt; type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; type should generally implement at least &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size(A)&lt;/code&gt;&lt;/a&gt; (returning an &lt;code&gt;Int&lt;/code&gt; tuple), &lt;code&gt;getindex(A,i)&lt;/code&gt; and &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt;&lt;/a&gt;; mutable arrays should also implement &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;. It is recommended that these operations have nearly constant time complexity, or technically &amp;Otilde;(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt;&lt;/a&gt; method, which is used to allocate a similar array for &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; and other out-of-place operations. No matter how an &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; is represented internally, &lt;code&gt;T&lt;/code&gt; is the type of object returned by &lt;em&gt;integer&lt;/em&gt; indexing (&lt;code&gt;A[1, ..., 1]&lt;/code&gt;, when &lt;code&gt;A&lt;/code&gt; is not empty) and &lt;code&gt;N&lt;/code&gt; should be the length of the tuple returned by &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. For more details on defining custom &lt;code&gt;AbstractArray&lt;/code&gt; implementations, see the &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;array interface guide in the interfaces chapter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1624bacdb2ea72aa9e204c460f79dbfffe8ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractArray&lt;/code&gt; type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; type should generally implement at least &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size(A)&lt;/code&gt;&lt;/a&gt; (returning an &lt;code&gt;Int&lt;/code&gt; tuple), &lt;code&gt;getindex(A,i)&lt;/code&gt; and &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt;&lt;/a&gt;; mutable arrays should also implement &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;. It is recommended that these operations have nearly constant time complexity, or technically &amp;Otilde;(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt;&lt;/a&gt; method, which is used to allocate a similar array for &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; and other out-of-place operations. No matter how an &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; is represented internally, &lt;code&gt;T&lt;/code&gt; is the type of object returned by &lt;em&gt;integer&lt;/em&gt; indexing (&lt;code&gt;A[1, ..., 1]&lt;/code&gt;, when &lt;code&gt;A&lt;/code&gt; is not empty) and &lt;code&gt;N&lt;/code&gt; should be the length of the tuple returned by &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. For more details on defining custom &lt;code&gt;AbstractArray&lt;/code&gt; implementations, see the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;array interface guide in the interfaces chapter&lt;/a&gt;.</source>
          <target state="translated">Тип &lt;code&gt;AbstractArray&lt;/code&gt; включает в себя все, что неопределенно похоже на массив, и его реализации могут сильно отличаться от обычных массивов. Например, элементы могут быть вычислены по запросу, а не сохранены. Однако любой конкретный тип &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; обычно должен реализовывать по крайней мере &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size(A)&lt;/code&gt; &lt;/a&gt; (возвращающий кортеж &lt;code&gt;Int&lt;/code&gt; ), &lt;code&gt;getindex(A,i)&lt;/code&gt; и &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt; &lt;/a&gt; ; изменяемые массивы также должны реализовывать &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; , Рекомендуется, чтобы эти операции имели почти постоянную временную сложность или технически (1) сложность, поскольку в противном случае некоторые функции массива могут быть неожиданно медленными. Бетонные типы также обычно должны обеспечивать&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt; &lt;/a&gt; метод (A, T = eltype (A), dims = size (A)) , который используется для выделения аналогичного массива для&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; и других неуместных операций. Независимо от того, как &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; представлен внутри, &lt;code&gt;T&lt;/code&gt; - это тип объекта, возвращаемый&lt;em&gt; целочисленной&lt;/em&gt; индексацией ( &lt;code&gt;A[1, ..., 1]&lt;/code&gt; , когда &lt;code&gt;A&lt;/code&gt; не пусто), а &lt;code&gt;N&lt;/code&gt; должно быть длиной кортеж возвращается по&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения об определении пользовательскихреализаций &lt;code&gt;AbstractArray&lt;/code&gt; см. В&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt; руководстве по интерфейсу массива в главе,&lt;/a&gt; посвященной интерфейсам .</target>
        </trans-unit>
        <trans-unit id="a1a42131bfca003806ea94dc4875800e91fc9149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractChar&lt;/code&gt; type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the &lt;a href=&quot;#Base.codepoint&quot;&gt;&lt;code&gt;codepoint&lt;/code&gt;&lt;/a&gt; function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;, for example. New &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; types should define a &lt;code&gt;codepoint(::T)&lt;/code&gt; method and a &lt;code&gt;T(::UInt32)&lt;/code&gt; constructor, at minimum.</source>
          <target state="translated">Тип &lt;code&gt;AbstractChar&lt;/code&gt; - это супертип всех реализаций символов в Julia. Символ представляет собой кодовую точку Unicode и может быть преобразован в целое число с помощью функции &lt;a href=&quot;#Base.codepoint&quot;&gt; &lt;code&gt;codepoint&lt;/code&gt; &lt;/a&gt; , чтобы получить числовое значение кодовой точки, или составлен из того же целого числа. Эти числовые значения определяют, как символы сравниваются, например, с &lt;code&gt;&amp;lt;&lt;/code&gt; и &lt;code&gt;==&lt;/code&gt; . Новые типы &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; должны определять как минимум метод &lt;code&gt;codepoint(::T)&lt;/code&gt; и конструктор &lt;code&gt;T(::UInt32)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c7306a482beca890d3fe61802010a334de7540c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConfigEntry&lt;/code&gt; would look like the following:</source>
          <target state="translated">&lt;code&gt;ConfigEntry&lt;/code&gt; будет выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="ba9c45997f3e5b0258d17d45edce07e2353ce6d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module approach tries to follow the simple principle of trying to change as little as possible when doing &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; arithmetic. This approach is also often known as &lt;em&gt;calendrical&lt;/em&gt; arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will say &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;March 3&lt;/a&gt; (assumes 31 days). PHP says &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;March 2&lt;/a&gt; (assumes 30 days). The fact is, there is no right answer. In the &lt;code&gt;Dates&lt;/code&gt; module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.</source>
          <target state="translated">В &lt;code&gt;Dates&lt;/code&gt; модульного подход пытается следовать простому принципу пытается изменить как можно меньше при выполнении &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; арифметики. Этот подход также часто называют &lt;em&gt;календарной&lt;/em&gt; арифметикой или тем, что вы, вероятно, догадались бы, если бы кто-то спросил вас о том же вычислении в разговоре. К чему весь этот шум? Возьмем классический пример: прибавьте 1 месяц к 31 января 2014 года. Каков ответ? Javascript скажет &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;3 марта&lt;/a&gt; (предполагается, что 31 день). PHP говорит &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;2 марта&lt;/a&gt; (предполагается, что 30 дней). Дело в том, что нет правильного ответа. В модуле &amp;laquo; &lt;code&gt;Dates&lt;/code&gt; &amp;raquo; отображается результат 28 февраля. Как он это выясняет? Мне нравится думать о классической азартной игре 7-7-7 в казино.</target>
        </trans-unit>
        <trans-unit id="f3b7289c36cdd40212d2c06b1045bb17b9239ebc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides the &lt;em&gt;adjuster&lt;/em&gt; API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and return or &lt;em&gt;adjust to&lt;/em&gt; the first or last of the desired period relative to the input.</source>
          <target state="translated">Модуль &lt;code&gt;Dates&lt;/code&gt; предоставляет API-интерфейс &lt;em&gt;настройки&lt;/em&gt; через несколько удобных методов, которые помогают просто и лаконично выразить временные правила. Первая группа методов настройки имеет дело с первой и последней неделями, месяцами, кварталами и годами. Каждый из них принимает один &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; в&lt;/a&gt; качестве входных данных и возвращает или &lt;em&gt;настраивает&lt;/em&gt; первый или последний желаемый период относительно входа.</target>
        </trans-unit>
        <trans-unit id="822dabd74f61866145ac5d6c2a28ae2c68643b5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides two types for working with dates: &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, representing day and millisecond precision, respectively; both are subtypes of the abstract &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with. For example, since the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.</source>
          <target state="translated">Модуль &lt;code&gt;Dates&lt;/code&gt; предоставляет два типа для работы с датами: &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; , представляющие точность дня и миллисекунды соответственно; оба являются подтипами абстрактного &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; . Мотивация для различных типов проста: некоторые операции намного проще, как с точки зрения кода, так и с точки зрения мышления, когда нет необходимости иметь дело со сложностями большей точности. Например, поскольку тип &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; разрешается только с точностью до одной даты (т. Е. Без часов, минут или секунд), обычные соображения для часовых поясов, летнего времени и дополнительных секунд не нужны и их следует избегать.</target>
        </trans-unit>
        <trans-unit id="47e6ad22d3652de8f0079c299b50b93cf7e90cb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Docs&lt;/code&gt; module provides the &lt;code&gt;@doc&lt;/code&gt; macro which can be used to set and retrieve documentation metadata for Julia objects.</source>
          <target state="translated">Модуль &lt;code&gt;Docs&lt;/code&gt; предоставляет макрос &lt;code&gt;@doc&lt;/code&gt; , который можно использовать для установки и получения метаданных документации для объектов Julia.</target>
        </trans-unit>
        <trans-unit id="6709d2ae00bff6f93afe9f0a943f4102d4f4b039" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Future&lt;/code&gt; module implements future behavior of already existing functions, which will replace the current version in a future release of Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21bb014706065802683533ccfbc183fd2f75ab09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GitHash&lt;/code&gt; of the target object of &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GitHash&lt;/code&gt; целевого объекта &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3fa0171d91b22777ce2dc8384f8c21045a536e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JL_GC_POP&lt;/code&gt; call releases the references established by the previous &lt;code&gt;JL_GC_PUSH&lt;/code&gt;. Note that &lt;code&gt;JL_GC_PUSH&lt;/code&gt; stores references on the C stack, so it must be exactly paired with a &lt;code&gt;JL_GC_POP&lt;/code&gt; before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; was invoked.</source>
          <target state="translated">&lt;code&gt;JL_GC_POP&lt;/code&gt; вызов освобождает ссылки , установленные предыдущим &lt;code&gt;JL_GC_PUSH&lt;/code&gt; . Обратите внимание, что &lt;code&gt;JL_GC_PUSH&lt;/code&gt; хранит ссылки в стеке C, поэтому он должен быть точно соединен с &lt;code&gt;JL_GC_POP&lt;/code&gt; перед выходом из области видимости. То есть до того, как функция вернется или поток управления в противном случае покинет блок, в котором был вызван &lt;code&gt;JL_GC_PUSH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b348f9eede2ca6e62ca6337bddb047633174b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt;&lt;code&gt;DEPOT_PATH&lt;/code&gt;&lt;/a&gt; variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files.</source>
          <target state="translated">&lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; переменной среды используются для заполнения глобальной Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt; &lt;code&gt;DEPOT_PATH&lt;/code&gt; &lt;/a&gt; переменного, которая управляет , где менеджер пакетов, а также механизмы загрузки коды Джулии, искать пакет реестры, установленные пакеты, названные среды, клонов репо, кэшировать скомпилированный пакет изображения и конфигурации файлы.</target>
        </trans-unit>
        <trans-unit id="cec94ad32872cc8ab93d55723729ae88908f0085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt;&lt;code&gt;DEPOT_PATH&lt;/code&gt;&lt;/a&gt; variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, configuration files, and the default location of the REPL's history file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b53844bde8803b551065f9d379c45987bf2bcfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; variable, which determines which packages can be loaded via &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;using&lt;/code&gt; (see &lt;a href=&quot;../code-loading/index#Code-Loading&quot;&gt;Code Loading&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69afeb6e2b2ee8e42ee83f53cc80115effd30019" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; variable, which determines which packages can be loaded via &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;using&lt;/code&gt; (see &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; переменной среды используются для заполнения глобальной Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;/a&gt; переменного, которая определяет , какие пакеты могут быть загружены с помощью &lt;code&gt;import&lt;/code&gt; и &lt;code&gt;using&lt;/code&gt; (см &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Загрузки коды&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="34bade2917d4a413edb80c43d8efdb3c090b4bcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profile&lt;/code&gt; module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify &quot;bottlenecks&quot; as targets for optimization.</source>
          <target state="translated">Модуль &lt;code&gt;Profile&lt;/code&gt; предоставляет инструменты, помогающие разработчикам повысить производительность своего кода. При использовании он измеряет выполняемый код и производит вывод, который помогает понять, сколько времени тратится на отдельные строки. Чаще всего используется для определения &amp;laquo;узких мест&amp;raquo; в качестве целей оптимизации.</target>
        </trans-unit>
        <trans-unit id="dee6516fb82f5277170e1ea0a8d04d1ed4092fd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pub&lt;/code&gt; package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.</source>
          <target state="translated">Пакет &lt;code&gt;Pub&lt;/code&gt; находится в хранилище пользователя, где живут пакеты, установленные пользователем. Они доступны только пользователю, который их установил.</target>
        </trans-unit>
        <trans-unit id="351bc5d2c88b2e50ba19e5df5f7c41cf0b55e7ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Random&lt;/code&gt; module defines a customizable framework for obtaining random values that can address these issues. Each invocation of &lt;code&gt;rand&lt;/code&gt; generates a &lt;em&gt;sampler&lt;/em&gt; which can be customized with the above trade-offs in mind, by adding methods to &lt;code&gt;Sampler&lt;/code&gt;, which in turn can dispatch on the random number generator, the object that characterizes the distribution, and a suggestion for the number of repetitions. Currently, for the latter, &lt;code&gt;Val{1}&lt;/code&gt; (for a single sample) and &lt;code&gt;Val{Inf}&lt;/code&gt; (for an arbitrary number) are used, with &lt;code&gt;Random.Repetition&lt;/code&gt; an alias for both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c1397c7dbb153add27fc9553cd4c77cee5bc54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Regex()&lt;/code&gt; constructor may be used to create a valid regex string programmatically. This permits using the contents of string variables and other string operations when constructing the regex string. Any of the regex codes above can be used within the single string argument to &lt;code&gt;Regex()&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">Конструктор &lt;code&gt;Regex()&lt;/code&gt; может использоваться для программного создания допустимой строки регулярного выражения. Это позволяет использовать содержимое строковых переменных и другие строковые операции при построении строки регулярного выражения. Любой из приведенных выше кодов регулярных выражений можно использовать в однострочном аргументе &lt;code&gt;Regex()&lt;/code&gt; . Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="db31bac9b865cc662808ada884b07e698cf41290" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SamplerSimple&lt;/code&gt; type is sufficient for most use cases with precomputed data. However, in order to demonstrate how to use custom sampler types, here we implement something similar to &lt;code&gt;SamplerSimple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ca6d3bf4c447b201b63ae9bba284f7ce5a10d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StackTraces&lt;/code&gt; module provides simple stack traces that are both human readable and easy to use programmatically.</source>
          <target state="translated">Модуль &lt;code&gt;StackTraces&lt;/code&gt; предоставляет простые трассировки стека, которые удобны для чтения и просты в использовании программными средствами.</target>
        </trans-unit>
        <trans-unit id="c7aa3a52368467c889b31b4e2156567453a420c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Test&lt;/code&gt; module provides simple &lt;em&gt;unit testing&lt;/em&gt; functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.</source>
          <target state="translated">Модуль &lt;code&gt;Test&lt;/code&gt; обеспечивает простую функциональность &lt;em&gt;модульного тестирования&lt;/em&gt; . Модульное тестирование - это способ проверить правильность кода, убедившись, что результаты соответствуют вашим ожиданиям. Это может быть полезно для обеспечения того, чтобы ваш код продолжал работать после внесения изменений, и может использоваться при разработке как способ определения поведения, которое ваш код должен иметь после завершения.</target>
        </trans-unit>
        <trans-unit id="3a54216422a2392050b1e4b2adcb38fe041e32d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTInstant&lt;/code&gt; represents a machine timeline based on UT time (1 day = one revolution of the earth). The &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;Period&lt;/code&gt; parameter that indicates the resolution or precision of the instant.</source>
          <target state="translated">&lt;code&gt;UTInstant&lt;/code&gt; представляет собой временную шкалу , основанную на машины UT времени (1 день = один оборот земли). &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;Period&lt;/code&gt; параметр , который указывает на разрешение или точность момент.</target>
        </trans-unit>
        <trans-unit id="f172eb4712d1e651ca4443a247edaddae0c02ffc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnitRange&lt;/code&gt;&lt;code&gt;irange&lt;/code&gt; specifies indices of the sorted eigenvalues to search for.</source>
          <target state="translated">В &lt;code&gt;UnitRange&lt;/code&gt; &lt;code&gt;irange&lt;/code&gt; Определяет индексы отсортированных собственные для поиска.</target>
        </trans-unit>
        <trans-unit id="ec153c629332b5ec9f45e8c540e2078292ed5e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; character should be escaped appropriately if the text is embedded in a Julia source code, for example, &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt;, since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the &lt;code&gt;raw&lt;/code&gt; string macro together with the &lt;code&gt;@doc&lt;/code&gt; macro:</source>
          <target state="translated">Символ &lt;code&gt;\&lt;/code&gt; следует экранировать соответствующим образом, если текст встроен в исходный код Julia, например, &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt; , поскольку он интерпретируется как строковый литерал. В качестве альтернативы, чтобы избежать экранирования, можно использовать макрос &lt;code&gt;raw&lt;/code&gt; строки вместе с &lt;code&gt;@doc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="81508e7a2286289f4f9b4e988f086408435f8b86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.</source>
          <target state="translated">Операция &lt;code&gt;\&lt;/code&gt; здесь выполняет линейное решение. Оператор левого деления довольно мощный, и его легко написать компактный, читаемый код, достаточно гибкий, чтобы решать все виды систем линейных уравнений.</target>
        </trans-unit>
        <trans-unit id="70fe69b8656c0c45fea00d261b4a1573767bfc08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abstract type&lt;/code&gt; keyword introduces a new abstract type, whose name is given by &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt;. This name can be optionally followed by &lt;code&gt;&amp;lt;:&lt;/code&gt; and an already-existing type, indicating that the newly declared abstract type is a subtype of this &quot;parent&quot; type.</source>
          <target state="translated">&lt;code&gt;abstract type&lt;/code&gt; ключевое слово вводит новый абстрактный тип, имя которого задается &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt; . За этим именем при желании может следовать &lt;code&gt;&amp;lt;:&lt;/code&gt; и уже существующий тип, указывая, что вновь объявленный абстрактный тип является подтипом этого &amp;laquo;родительского&amp;raquo; типа.</target>
        </trans-unit>
        <trans-unit id="39c37e363f5430e97a4dfa887fff2d0a51efccac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alg&lt;/code&gt; keyword argument requires Julia 1.3 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9421706ce1251dd1a3a86cb4c9ef2ac4b3c269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allowed_types&lt;/code&gt; contains a bitmask of &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; values specifying which authentication methods should be attempted.</source>
          <target state="translated">Параметр &lt;code&gt;allowed_types&lt;/code&gt; содержит битовую маску значений &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; , определяющую, какие методы аутентификации следует попробовать.</target>
        </trans-unit>
        <trans-unit id="8b06ca131e63337ccd916fd14f532e8185770099" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; keyword arguments requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;rtol&lt;/code&gt; is available as a positional argument, but this will be deprecated in Julia 2.0.</source>
          <target state="translated">Для аргументов ключевого слова &lt;code&gt;atol&lt;/code&gt; и &lt;code&gt;rtol&lt;/code&gt; требуется как минимум версия Julia 1.1. В Julia 1.0 &lt;code&gt;rtol&lt;/code&gt; доступен как позиционный аргумент, но в Julia 2.0 он устарел.</target>
        </trans-unit>
        <trans-unit id="8c5e3a41d3bdc968b371bacefc8b137db06a4e1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; argument is a pointer to an array of length &lt;code&gt;nmemb&lt;/code&gt;, with elements of &lt;code&gt;size&lt;/code&gt; bytes each. &lt;code&gt;compare&lt;/code&gt; is a callback function which takes pointers to two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and returns an integer less/greater than zero if &lt;code&gt;a&lt;/code&gt; should appear before/after &lt;code&gt;b&lt;/code&gt; (or zero if any order is permitted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8f8106813dc53840cdd36136d9eb3701004f27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; argument is a pointer to an array of length &lt;code&gt;nmemb&lt;/code&gt;, with elements of &lt;code&gt;size&lt;/code&gt; bytes each. &lt;code&gt;compare&lt;/code&gt; is a callback function which takes pointers to two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and returns an integer less/greater than zero if &lt;code&gt;a&lt;/code&gt; should appear before/after &lt;code&gt;b&lt;/code&gt; (or zero if any order is permitted). Now, suppose that we have a 1d array &lt;code&gt;A&lt;/code&gt; of values in Julia that we want to sort using the &lt;code&gt;qsort&lt;/code&gt; function (rather than Julia's built-in &lt;code&gt;sort&lt;/code&gt; function). Before we worry about calling &lt;code&gt;qsort&lt;/code&gt; and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define &lt;code&gt;&amp;lt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; аргумент является указателем на массив длиной &lt;code&gt;nmemb&lt;/code&gt; , с элементами &lt;code&gt;size&lt;/code&gt; байт каждый. &lt;code&gt;compare&lt;/code&gt; - это функция обратного вызова, которая принимает указатели на два элемента &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; и возвращает целое число меньше / больше нуля, если &lt;code&gt;a&lt;/code&gt; должно появиться до / после &lt;code&gt;b&lt;/code&gt; (или ноль, если разрешен любой порядок). Теперь предположим, что у нас есть 1d-массив &lt;code&gt;A&lt;/code&gt; значений в Julia, который мы хотим отсортировать с помощью функции &lt;code&gt;qsort&lt;/code&gt; (а не встроенной функции &lt;code&gt;sort&lt;/code&gt; Julia ). Прежде чем беспокоиться о вызове &lt;code&gt;qsort&lt;/code&gt; и передавая аргументы, нам нужно написать функцию сравнения, которая работает для некоторых произвольных объектов (которые определяют &lt;code&gt;&amp;lt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="2208a0a1e673c387c0482cabd9f5481f4d468aa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;baseline&lt;/code&gt; is the tree to be used for comparison to the working directory and index; defaults to HEAD.</source>
          <target state="translated">&lt;code&gt;baseline&lt;/code&gt; это дерево можно использовать для сравнения с рабочим каталогом и индексом; по умолчанию HEAD.</target>
        </trans-unit>
        <trans-unit id="2423af315b07d14dbe0beca5286d61ecc80d3806" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blocksize&lt;/code&gt; keyword argument requires Julia 1.4 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b441ac8e59d2fd60c5cee59a3c67db4265556f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chnl&lt;/code&gt; object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed &lt;code&gt;Channel&lt;/code&gt; objects.</source>
          <target state="translated">Объект &lt;code&gt;chnl&lt;/code&gt; может быть явно закрыт независимо от завершения задачи. Завершение задач не влияет на уже закрытые объекты &lt;code&gt;Channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90a04897ae4361417810ae9870dce7c36f780876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; option controls whether the process attempts to delete the returned path automatically when the process exits. Note that the &lt;code&gt;tempname&lt;/code&gt; function does not create any file or directory at the returned location, so there is nothing to cleanup unless you create a file or directory there. If you do and &lt;code&gt;clean&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; it will be deleted upon process termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa868ba15d4c70e293eebe72c9574ee9fe6fe35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a &lt;code&gt;const&lt;/code&gt; declaration solves this performance problem.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; декларация должна быть использована только в глобальном масштабе на глобал. Компилятору сложно оптимизировать код, включающий глобальные переменные, поскольку их значения (или даже их типы) могут измениться практически в любое время. Если глобальная переменная не изменится, добавление объявления &lt;code&gt;const&lt;/code&gt; решает эту проблему производительности.</target>
        </trans-unit>
        <trans-unit id="5822b594c5a7a77089ae64b02006c257e39cc153" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contains&lt;/code&gt; function requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b4a67ce4add4334b6cfa9f5f2082d426131b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert&lt;/code&gt; function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:</source>
          <target state="translated">Функция &lt;code&gt;convert&lt;/code&gt; обычно принимает два аргумента: первый - это объект типа, а второй - значение, которое нужно преобразовать в этот тип. Возвращаемое значение - это значение, преобразованное в экземпляр данного типа. Самый простой способ понять эту функцию - увидеть ее в действии:</target>
        </trans-unit>
        <trans-unit id="e7cb3fc07af13ab851df995a0b91fc4d68f51c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current&lt;/code&gt; status object may be a &lt;code&gt;StatStruct&lt;/code&gt;, an &lt;code&gt;EOFError&lt;/code&gt; (indicating the timeout elapsed), or some other &lt;code&gt;Exception&lt;/code&gt; subtype (if the &lt;code&gt;stat&lt;/code&gt; operation failed - for example, if the path does not exist).</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt; объекта состояния может быть &lt;code&gt;StatStruct&lt;/code&gt; , &lt;code&gt;EOFError&lt;/code&gt; ( с указанием тайм - аут истек), или какой -либо другой &lt;code&gt;Exception&lt;/code&gt; подтипа (если &lt;code&gt;stat&lt;/code&gt; операция не удалась - например, если путь не существует).</target>
        </trans-unit>
        <trans-unit id="940a17c26916de1b6351b6066b3e6217426d4df2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dest&lt;/code&gt; array must be distinct from the &lt;code&gt;src&lt;/code&gt; array (they cannot alias each other).</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; массив должен быть отличным от &lt;code&gt;src&lt;/code&gt; массива (они не могут псевдоним друг друга).</target>
        </trans-unit>
        <trans-unit id="611e9863b6fe56ca0563d7d25daad5883ed6f0ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dir&lt;/code&gt; keyword argument can be used to specify a working directory for the command.</source>
          <target state="translated">&lt;code&gt;dir&lt;/code&gt; аргумент можно использовать ключевое слово , чтобы указать рабочий каталог для команды.</target>
        </trans-unit>
        <trans-unit id="a4bff47d996768873bcc39999935a98007b3cec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do x&lt;/code&gt; syntax creates an anonymous function with argument &lt;code&gt;x&lt;/code&gt; and passes it as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Similarly, &lt;code&gt;do a,b&lt;/code&gt; would create a two-argument anonymous function, and a plain &lt;code&gt;do&lt;/code&gt; would declare that what follows is an anonymous function of the form &lt;code&gt;() -&amp;gt; ...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;do x&lt;/code&gt; синтаксис создает анонимную функцию с аргументом &lt;code&gt;x&lt;/code&gt; и передает его в качестве первого аргумента &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; . Точно так же, &lt;code&gt;do a,b&lt;/code&gt; бы создать два-аргумент анонимные функции и простой &lt;code&gt;do&lt;/code&gt; бы заявить, что далее следует анонимная функция вида &lt;code&gt;() -&amp;gt; ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38f76b197c154b053fc67ebe8a0b86d9c54ffd48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used. The condition expressions in the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; construct are evaluated until the first one evaluates to &lt;code&gt;true&lt;/code&gt;, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.</source>
          <target state="translated">В &lt;code&gt;elseif&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; блоки не являются обязательными, а также многие &lt;code&gt;elseif&lt;/code&gt; блоков , как желательно могут быть использованы. Выражения условия в конструкции &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; оцениваются до тех пор, пока первое из них не станет &lt;code&gt;true&lt;/code&gt; , после чего оценивается связанный блок, и никакие другие выражения условий или блоки не оцениваются.</target>
        </trans-unit>
        <trans-unit id="dabea74759059aade9a04e98141814de885b1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; where the logging macro occurs in the source code.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; и &lt;code&gt;line&lt;/code&gt; , где происходит регистрация макроса в исходном коде.</target>
        </trans-unit>
        <trans-unit id="40928cdd855b3408cd94e2ea60dca71441758515" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; argument is a function that determines how to open a file with the given editor. It should take three arguments, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baef46876dcf6509194a8000268158d1d7c2494a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above &lt;code&gt;while&lt;/code&gt; loop does is so common, it can be expressed more concisely with a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Цикл &lt;code&gt;for&lt;/code&gt; упрощает написание распространенных идиом повторяющихся вычислений. Так как отсчет вверх и вниз , как выше в &lt;code&gt;while&lt;/code&gt; петля делает это настолько часто, это может быть выражено более сжато с &lt;code&gt;for&lt;/code&gt; цикла:</target>
        </trans-unit>
        <trans-unit id="ee6a3346a6698b43646ee623779b34ee8b0963c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grow&lt;/code&gt; keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is &amp;lt; requested array size). Write privileges are required to grow the file.</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; ключевых слов аргумент определяет , должен ли файл на диске выращиваться для размещения требуемого размера массива (если общий размер файла &amp;lt;запрошенный размер массива). Для увеличения файла требуются права записи.</target>
        </trans-unit>
        <trans-unit id="944e976cee83757342402d268820319c708e7f02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello&lt;/code&gt; is the output of the &lt;code&gt;echo&lt;/code&gt; command, sent to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;. The run method itself returns &lt;code&gt;nothing&lt;/code&gt;, and throws an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; if the external command fails to run successfully.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; является выходом &lt;code&gt;echo&lt;/code&gt; команды, посланной на &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; . Сам метод run &lt;code&gt;nothing&lt;/code&gt; возвращает и выдает &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; если внешняя команда не выполняется успешно.</target>
        </trans-unit>
        <trans-unit id="3728644266a88dfcc97848c625f08a3fe62768b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ipv6only&lt;/code&gt; parameter disables dual stack mode. If &lt;code&gt;ipv6only=true&lt;/code&gt;, only an IPv6 stack is created.</source>
          <target state="translated">Параметр &lt;code&gt;ipv6only&lt;/code&gt; отключает режим двойного стека. Если &lt;code&gt;ipv6only=true&lt;/code&gt; , создается только стек IPv6.</target>
        </trans-unit>
        <trans-unit id="9a83013fd8954052be45bbcebac7dcd162b9bddd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;join&lt;/code&gt; and &lt;code&gt;sort&lt;/code&gt; keyword arguments require at least Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9131ac4a45cc03434a2d1d252e0b9eb47948d016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt;th diagonal of a matrix, as a vector.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; - й диагонали матрицы, в качестве вектора.</target>
        </trans-unit>
        <trans-unit id="586747034b4744d9048e093e3d358be130046659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; block creates a new variable &lt;code&gt;r&lt;/code&gt; whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance. In the mean time, some user-contributed packages like &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures&lt;/a&gt; automate the insertion of &lt;code&gt;let&lt;/code&gt; statements as in &lt;code&gt;abmult3&lt;/code&gt;.</source>
          <target state="translated">Блок &lt;code&gt;let&lt;/code&gt; создает новую переменную &lt;code&gt;r&lt;/code&gt; , областью действия которой является только внутренняя функция. Второй метод восстанавливает полную языковую производительность при наличии захваченных переменных. Обратите внимание, что это быстро развивающийся аспект компилятора, и вполне вероятно, что в будущих выпусках не потребуется такая степень аннотации программиста для достижения производительности. &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;Между&lt;/a&gt; тем , некоторые пользовательские пакеты, такие как FastClosures, автоматизируют вставку операторов &lt;code&gt;let&lt;/code&gt; , как в &lt;code&gt;abmult3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="404db33b1806403679f9afdc7e45d8ad145e7ae6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords can also be applied to destructuring assignments, e.g. &lt;code&gt;local x, y = 1, 2&lt;/code&gt;. In this case the keyword affects all listed variables.</source>
          <target state="translated">В &lt;code&gt;local&lt;/code&gt; и &lt;code&gt;global&lt;/code&gt; ключевых словах также может быть применены к деструктурирующим заданий, например , &lt;code&gt;local x, y = 1, 2&lt;/code&gt; . В этом случае ключевое слово влияет на все перечисленные переменные.</target>
        </trans-unit>
        <trans-unit id="e6f28358dd1bfb5022d94e86f119a98a067084c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock&lt;/code&gt; argument is available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90d836f6ddde99c9e10f3c6026b387d7de48843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock&lt;/code&gt; keyword argument controls whether operations will be locked for safe multi-threaded access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d442e907c59ccc9e130f30539a3ad937b37db4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loopback&lt;/code&gt; keyword argument dictates whether loopback addresses (e.g. &lt;code&gt;ip&quot;127.0.0.1&quot;&lt;/code&gt;, &lt;code&gt;ip&quot;::1&quot;&lt;/code&gt;) are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e455fac98bba78f84dcce75d6fd177f25053bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loopback&lt;/code&gt; keyword argument dictates whether loopback addresses are included.</source>
          <target state="translated">В &lt;code&gt;loopback&lt;/code&gt; аргумент диктат ключевых слов, включены ли петлевой адреса.</target>
        </trans-unit>
        <trans-unit id="43f03591f994b72dda2b585d5125cc1a285cbfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; in which the logging macro was expanded.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; , в котором был расширен лесозаготовительной макрос.</target>
        </trans-unit>
        <trans-unit id="4522c3b2f49470689410e3676d64813c5ddeff60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt;-norm is defined as</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; -норм определяются как</target>
        </trans-unit>
        <trans-unit id="e0a5498fb62d227e0dfc45c4ea76fe12397ce61d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt; arguments were added in 1.4. Prior to Julia 1.4 the path &lt;code&gt;tempname&lt;/code&gt; would never be cleaned up at process termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302ea1391975a513d95c23abf51eb7e6812df7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument is a string, regular expression, or an array of strings and regular expressions. For the &lt;code&gt;fn&lt;/code&gt; to be called, one of the patterns must match the value of &lt;code&gt;EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;JULIA_EDITOR&lt;/code&gt;. For strings, the string must equal the &lt;a href=&quot;../../base/file/index#Base.Filesystem.basename&quot;&gt;&lt;code&gt;basename&lt;/code&gt;&lt;/a&gt; of the first word of the editor command, with its extension, if any, removed. E.g. &quot;vi&quot; doesn't match &quot;vim -g&quot; but matches &quot;/usr/bin/vi -m&quot;; it also matches &lt;code&gt;vi.exe&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; is a regex it is matched against all of the editor command as a shell-escaped string. An array pattern matches if any of its items match. If multiple editors match, the one added most recently is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b88a0b1c328d1e6bd27b342609d1fb54652c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote&lt;/code&gt; function converts all its arguments to a common type &amp;ndash; in this case &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition, the &lt;code&gt;Point&lt;/code&gt; constructor promotes its arguments the same way that numeric operators like &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; do, and works for all kinds of real numbers:</source>
          <target state="translated">Функция &lt;code&gt;promote&lt;/code&gt; преобразует все свои аргументы в общий тип - в данном случае &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . С помощью этого определения метода конструктор &lt;code&gt;Point&lt;/code&gt; продвигает свои аргументы так же, как числовые операторы, такие как &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , и работает для всех видов действительных чисел:</target>
        </trans-unit>
        <trans-unit id="8297e1ed549bbae968b6d4d9056ddd08eaa6ab7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote_rule&lt;/code&gt; function is used as a building block to define a second function called &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which, given any number of type objects, returns the common type to which those values, as arguments to &lt;code&gt;promote&lt;/code&gt; should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use &lt;code&gt;promote_type&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;promote_rule&lt;/code&gt; используется в качестве строительного блока для определения второй функции с именем &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; , которая при любом количестве объектов типа возвращает общий тип, которому эти значения должны быть продвинуты в качестве аргументов для &lt;code&gt;promote&lt;/code&gt; . Таким образом, если кто-то хочет знать, в отсутствие фактических значений, к какому типу будет продвигаться коллекция значений определенных типов, можно использовать &lt;code&gt;promote_type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b692555ebed7ff435cd42db277bcbc90f0f6b5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r&quot;...&quot;&lt;/code&gt; literal is constructed without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). Here is an example showing the difference from standard string literals:</source>
          <target state="translated">&lt;code&gt;r&quot;...&quot;&lt;/code&gt; буквальный строятся без интерполяции и неэкранированного (за исключением кавычки &lt;code&gt;&quot;&lt;/code&gt; , которые по- прежнему должны быть экранированы) Ниже приведен пример , показывающее отличие от стандартных строковых литералов.:</target>
        </trans-unit>
        <trans-unit id="2a6072b422e59a959f8b81bd76474b677710288a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; ключевых слов</target>
        </trans-unit>
        <trans-unit id="fbd3a71fad13cb9858c23c4a3ef4f996112c52ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_type_numeric&lt;/code&gt; function behaves much like the &lt;code&gt;same_type&lt;/code&gt; function defined above, but is only defined for pairs of numbers.</source>
          <target state="translated">Функция &lt;code&gt;same_type_numeric&lt;/code&gt; во многом похожа на функцию &lt;code&gt;same_type&lt;/code&gt; , определенную выше, но определена только для пар чисел.</target>
        </trans-unit>
        <trans-unit id="82ca08e2caba29401264be1575cf38e6bdfde40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schedule&lt;/code&gt; argument can be used to request a particular scheduling policy. The only currently supported value is &lt;code&gt;:static&lt;/code&gt;, which creates one task per thread and divides the iterations equally among them. Specifying &lt;code&gt;:static&lt;/code&gt; is an error if used from inside another &lt;code&gt;@threads&lt;/code&gt; loop or from a thread other than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0faccd874b145bf90dea0ffa9ea23d2d84a128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schedule&lt;/code&gt; argument is available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fab5a03f87c103ae23a4670919e1023dea2f659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; keyword argument specifies whether the resulting &lt;code&gt;Array&lt;/code&gt; and changes made to it will be visible to other processes mapping the same file.</source>
          <target state="translated">В &lt;code&gt;shared&lt;/code&gt; ключевых слов аргумент определяет , является ли полученный &lt;code&gt;Array&lt;/code&gt; и изменения , внесенные в него будут видны другим процессам , отображающих один и тот же файл.</target>
        </trans-unit>
        <trans-unit id="0931d123977915d4a1d899bba2683bbb5d1cf496" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shred&lt;/code&gt; keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to &lt;code&gt;false&lt;/code&gt; during testing.</source>
          <target state="translated">&lt;code&gt;shred&lt;/code&gt; управление ключевым слов , должна ли быть уничтожена секретной информация в поле полезной нагрузки учетных данных. Должно быть установлено значение &lt;code&gt;false&lt;/code&gt; только во время тестирования.</target>
        </trans-unit>
        <trans-unit id="4faa585381b0ef3fd8f6f635485b6d01da652249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn=&lt;/code&gt; parameter was added in Julia 1.3. This constructor was added in Julia 1.3. In earlier versions of Julia, Channel used keyword arguments to set &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, but those constructors are deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd95653810075abbd2a6979c3286487161ebaa1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; object may be anything, and should be chosen appropriately for each iterable type. See the &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration&quot;&gt;manual section on the iteration interface&lt;/a&gt; for more details about defining a custom iterable type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe58d87c8dd555b134b1d599492862c038b6d10f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; object may be anything, and should be chosen appropriately for each iterable type. See the &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;manual section on the iteration interface&lt;/a&gt; for more details about defining a custom iterable type.</source>
          <target state="translated">Объект &lt;code&gt;state&lt;/code&gt; может быть любым, и его следует выбирать соответствующим образом для каждого итеративного типа. См. &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;Раздел руководства по интерфейсу итерации&lt;/a&gt; для получения дополнительных сведений об определении настраиваемого итеративного типа.</target>
        </trans-unit>
        <trans-unit id="197a5a1cfcc6bf414db454749ace6bc6b46270e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transcode&lt;/code&gt; function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</source>
          <target state="translated">Функция &lt;code&gt;transcode&lt;/code&gt; выполняется успешно, пока входные данные могут быть разумно представлены в целевой кодировке; он всегда успешно выполняет преобразование между кодировками UTF-XX, даже для недопустимых данных Unicode.</target>
        </trans-unit>
        <trans-unit id="25bce1e285bcf1b8934e0d8620acac52150b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; заявление</target>
        </trans-unit>
        <trans-unit id="c2c1155010a79df372e519698f4e8f431ee252c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement allows for &lt;code&gt;Exception&lt;/code&gt;s to be tested for, and for the graceful handling of things that may ordinarily break your application. For example, in the below code the function for square root would normally throw an exception. By placing a &lt;code&gt;try/catch&lt;/code&gt; block around it we can mitigate that here. You may choose how you wish to handle this exception, whether logging it, return a placeholder value or as in the case below where we just printed out a statement. One thing to think about when deciding how to handle unexpected situations is that using a &lt;code&gt;try/catch&lt;/code&gt; block is much slower than using conditional branching to handle those situations. Below there are more examples of handling exceptions with a &lt;code&gt;try/catch&lt;/code&gt; block:</source>
          <target state="translated">Оператор &lt;code&gt;try/catch&lt;/code&gt; позволяет проверять &lt;code&gt;Exception&lt;/code&gt; и изящную обработку вещей, которые обычно могут нарушить работу вашего приложения. Например, в приведенном ниже коде функция извлечения квадратного корня обычно вызывает исключение. Поместив вокруг него блок &lt;code&gt;try/catch&lt;/code&gt; , мы можем смягчить это здесь. Вы можете выбрать, как вы хотите обрабатывать это исключение: регистрировать ли его в журнале, возвращать значение-заполнитель или как в случае ниже, когда мы только что распечатали оператор. При принятии решения о том, как справиться с неожиданными ситуациями, следует подумать о том, что использование блока &lt;code&gt;try/catch&lt;/code&gt; намного медленнее, чем использование условного ветвления для обработки этих ситуаций. Ниже приведены другие примеры обработки исключений с помощью &lt;code&gt;try/catch&lt;/code&gt; . блок:</target>
        </trans-unit>
        <trans-unit id="8de2b2884ad5c0d59519c41370d411d31e17c8aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; префикс на этой функции указывает на то, что ни одна проверка не выполняется на указатель &lt;code&gt;p&lt;/code&gt; для того , чтобы действительно. Неправильное использование может привести к повреждению или сбою вашей программы так же, как и в C.</target>
        </trans-unit>
        <trans-unit id="1ad1cf514621d9bd7509c63edb01e709a946f374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; префикс на этой функции указывает на то, что ни одна проверка не выполняется на указатель &lt;code&gt;p&lt;/code&gt; для того , чтобы действительно. Неправильное использование может привести к сбою в работе вашей программы или возврату мусорных ответов так же, как и в C.</target>
        </trans-unit>
        <trans-unit id="ffd2fc5d018bc4147802a9ab69acc1302211d9d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointers &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; префикс на этой функции указывает на то, что ни одна проверка не выполняется на указатели &lt;code&gt;dest&lt;/code&gt; и &lt;code&gt;src&lt;/code&gt; , чтобы гарантировать , что они являются действительными. Неправильное использование может привести к повреждению или сбою вашей программы так же, как и в C.</target>
        </trans-unit>
        <trans-unit id="c545e57ea20b7dee78b3ead6faf2e0dd60dec4ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; префикс на этой функции указывает на то, что ни одна проверка не выполняется , чтобы гарантировать , что N является Inbounds на любом массиве. Неправильное использование может привести к повреждению или сбою вашей программы так же, как и в C.</target>
        </trans-unit>
        <trans-unit id="f4d657f988d9e3352165918f5b958ddc6e9310c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that using the result of this function after the &lt;code&gt;x&lt;/code&gt; argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; префикс на этой функции указует , что использование результата этой функции после &lt;code&gt;x&lt;/code&gt; аргумента этой функции больше не доступно для программы может привести к непредсказуемому поведению, включая коррупцию программы или ошибку сегментацию, позднее в любое время.</target>
        </trans-unit>
        <trans-unit id="1f00bb06127cf74d0a7a977235b45b41a807deea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;userdata&lt;/code&gt; field is used to store information for each worker by external managers.</source>
          <target state="translated">Поле &lt;code&gt;userdata&lt;/code&gt; используется для хранения информации о каждом работнике внешними менеджерами.</target>
        </trans-unit>
        <trans-unit id="ea1c59c30ca45a88d468b07114183bcee1a4d149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword creates a type that is an iterated union of other types, over all values of some variable. For example &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; includes all &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt;s where the element type is some kind of &lt;code&gt;Real&lt;/code&gt; number.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; ключевое слово создает тип , который итерированное объединение других типов, по всем значениям некоторых переменные. Например , &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; включает в себя весь &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; ы , где тип элемента является своим родом &lt;code&gt;Real&lt;/code&gt; числа.</target>
        </trans-unit>
        <trans-unit id="e2963a52dada4be3a4b826619d947c135b0ff9a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:</source>
          <target state="translated">Само ключевое слово &lt;code&gt;where&lt;/code&gt; может быть вложено в более сложное объявление. Например, рассмотрим два типа, созданные следующими объявлениями:</target>
        </trans-unit>
        <trans-unit id="998cd2a7738c69cc615469e2df80e3038aa7e4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop evaluates the condition expression (&lt;code&gt;i &amp;lt;= 5&lt;/code&gt; in this case), and as long it remains &lt;code&gt;true&lt;/code&gt;, keeps also evaluating the body of the &lt;code&gt;while&lt;/code&gt; loop. If the condition expression is &lt;code&gt;false&lt;/code&gt; when the &lt;code&gt;while&lt;/code&gt; loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; цикл вычисляет выражение условия ( &lt;code&gt;i &amp;lt;= 5&lt;/code&gt; , в данном случае), и до тех пор он остается &lt;code&gt;true&lt;/code&gt; , сохраняет также оценивает тело в &lt;code&gt;while&lt;/code&gt; цикла. Если выражение условия &lt;code&gt;false&lt;/code&gt; , когда во &lt;code&gt;while&lt;/code&gt; цикла первого достигнут, тело никогда не оценивало.</target>
        </trans-unit>
        <trans-unit id="c9eac2e060f4090d788f5a1733519b89ab4b4ae0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;binomial coefficient&lt;/em&gt;$\binom{n}{k}$, being the coefficient of the $k$th term in the polynomial expansion of $(1+x)^n$.</source>
          <target state="translated">&lt;em&gt;Биномиального коэффициента&lt;/em&gt; $ \ БИНОМ {п} {к} $, будучи коэффициент $ K $ -й член в разложении полинома $ (1 + х) ^ п $.</target>
        </trans-unit>
        <trans-unit id="5f58dd4e346415c12b8a2bde13968a9b1deff1c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;log level&lt;/em&gt; is a broad category for the message that is used for early filtering. There are several standard levels of type &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;; user-defined levels are also possible.</source>
          <target state="translated">Уровень &lt;em&gt;журнала&lt;/em&gt; - это широкая категория для сообщения, которое используется для ранней фильтрации. Есть несколько стандартных уровней типа &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt; &lt;code&gt;LogLevel&lt;/code&gt; &lt;/a&gt; ; также возможны уровни, определяемые пользователем.</target>
        </trans-unit>
        <trans-unit id="3159599b94059581dc5ff890d9483fac4c0d5266" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;log level&lt;/em&gt; is a broad category for the message that is used for early filtering. There are several standard levels of type &lt;a href=&quot;#Logging.LogLevel&quot;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;; user-defined levels are also possible. Each is distinct in purpose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620317702e34b9f6f3d4d6b07a30259367383fd0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message&lt;/em&gt; is an object describing the event. By convention &lt;code&gt;AbstractString&lt;/code&gt;s passed as messages are assumed to be in markdown format. Other types will be displayed using &lt;code&gt;print(io, obj)&lt;/code&gt; or &lt;code&gt;string(obj)&lt;/code&gt; for text-based output and possibly &lt;code&gt;show(io,mime,obj)&lt;/code&gt; for other multimedia displays used in the installed logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fe1c7ad22ee14f0705951a3acf51f247460513" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message&lt;/em&gt; is an object describing the event. By convention &lt;code&gt;AbstractString&lt;/code&gt;s passed as messages are assumed to be in markdown format. Other types will be displayed using &lt;code&gt;show(io,mime,obj)&lt;/code&gt; according to the display capabilities of the installed logger.</source>
          <target state="translated">&lt;em&gt;Сообщение&lt;/em&gt; является объектом , описывающим событие. По соглашению, &lt;code&gt;AbstractString&lt;/code&gt; , передаваемые как сообщения, считаются имеющими формат уценки. Другие типы будут отображаться с использованием &lt;code&gt;show(io,mime,obj)&lt;/code&gt; соответствии с возможностями отображения установленного регистратора.</target>
        </trans-unit>
        <trans-unit id="ff35386d12b40dc9ba6f11aed8e1486efcf6f63b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primary environment&lt;/em&gt;&amp;mdash;i.e. the first environment in a stack&amp;mdash;is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.</source>
          <target state="translated">&lt;em&gt;Основная среда&lt;/em&gt; -ie первой среды в стеке-добросовестно встроена в слоистой среде. Полный граф зависимостей первой среды в стеке гарантированно будет включен в составную среду без изменений, включая те же версии всех зависимостей.</target>
        </trans-unit>
        <trans-unit id="f56a5c0b72490015a89e1c362931e81a9ffdc753" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called &lt;code&gt;x&lt;/code&gt; without the two &lt;code&gt;x&lt;/code&gt;'s referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail.</source>
          <target state="translated">Область &lt;em&gt;действия&lt;/em&gt; переменной - это область кода, в которой переменная видна. Область видимости переменных помогает избежать конфликтов именования переменных. Концепция интуитивно понятна: обе функции могут иметь аргументы, называемые &lt;code&gt;x&lt;/code&gt; , при этом два &lt;code&gt;x&lt;/code&gt; не относятся к одному и тому же. Точно так же есть много других случаев, когда разные блоки кода могут использовать одно и то же имя, не ссылаясь на одно и то же. Правила, когда одно и то же имя переменной относится или не относится к одному и тому же объекту, называются правилами области действия; в этом разделе они подробно описаны.</target>
        </trans-unit>
        <trans-unit id="e823801b39157cff5d7794c3183a7d1989add808" translate="yes" xml:space="preserve">
          <source>The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the &lt;code&gt;Random&lt;/code&gt; module. For example, it's typically sufficient to implement one &lt;code&gt;rand&lt;/code&gt; method in order to have all other usual methods work automatically.</source>
          <target state="translated">API для 1) достаточно функциональный, но относительно недавний, поэтому, возможно, ему придется развиваться в последующих выпусках модуля &lt;code&gt;Random&lt;/code&gt; . Например, обычно достаточно реализовать один метод &lt;code&gt;rand&lt;/code&gt; , чтобы все остальные обычные методы работали автоматически.</target>
        </trans-unit>
        <trans-unit id="8ab319b5b160e68efa740a64380d05f1be87039a" translate="yes" xml:space="preserve">
          <source>The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.</source>
          <target state="translated">API для 2)все еще является рудиментарным и может потребовать от реализатора больше работы,чем необходимо для поддержки обычных типов генерируемых значений.</target>
        </trans-unit>
        <trans-unit id="c48202b29b3f0136388eb79e46b027ab787228ea" translate="yes" xml:space="preserve">
          <source>The API for atomic operations has not yet been finalized and is likely to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9630cea145272914a5264c86a31f652e4069fa" translate="yes" xml:space="preserve">
          <source>The API is not clearly defined yet, but as a rule of thumb:</source>
          <target state="translated">API пока не имеет четкого определения,но,как правило,является эмпирическим:</target>
        </trans-unit>
        <trans-unit id="a2cac855dd1e1320bc002428689d4b74c6a1a9ec" translate="yes" xml:space="preserve">
          <source>The ASCII string &quot;DATA&quot; corresponds to the bytes 68, 65, 84, 65. &lt;code&gt;\xff&lt;/code&gt; produces the single byte 255. The Unicode escape &lt;code&gt;\u2200&lt;/code&gt; is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:</source>
          <target state="translated">Строка ASCII &amp;laquo;DATA&amp;raquo; соответствует байтам 68, 65, 84, 65. &lt;code&gt;\xff&lt;/code&gt; производит единственный байт 255. &lt;code&gt;\u2200&lt;/code&gt; Юникода \ u2200 кодируется в UTF-8 как три байта 226, 136, 128. Обратите внимание, что результирующий массив байтов не соответствует допустимой строке UTF-8:</target>
        </trans-unit>
        <trans-unit id="39a538bac8d2eeb537bfbc18fea41895f84fba1e" translate="yes" xml:space="preserve">
          <source>The C &lt;code&gt;getenv&lt;/code&gt; function indicates an error by returning &lt;code&gt;NULL&lt;/code&gt;, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:</source>
          <target state="translated">Функция C &lt;code&gt;getenv&lt;/code&gt; указывает на ошибку, возвращая &lt;code&gt;NULL&lt;/code&gt; , но другие стандартные функции C указывают на ошибки различными способами, в том числе путем возврата -1, 0, 1 и других специальных значений. Эта оболочка выдает исключение, явно указывающее на проблему, если вызывающий пытается получить несуществующую переменную среды:</target>
        </trans-unit>
        <trans-unit id="bb0be6121167f43ded0796e444ece3ab2ece1c9f" translate="yes" xml:space="preserve">
          <source>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array &lt;code&gt;result_array&lt;/code&gt;. This variable can only be used with corresponding input type declaration &lt;code&gt;Ref{Cdouble}&lt;/code&gt;, since its memory is allocated and managed by Julia, not C. The implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt;&lt;/a&gt; unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</source>
          <target state="translated">Обернутая функция C возвращает целочисленный код ошибки; результаты фактического вычисления функции Бесселя J заполняют массив Julia &lt;code&gt;result_array&lt;/code&gt; . Эта переменная может использоваться только с соответствующим объявлением типа ввода &lt;code&gt;Ref{Cdouble}&lt;/code&gt; , поскольку ее память выделяется и управляется Джулией, а не C. &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt; &lt;/a&gt; вызов Base.cconvert (Ref {Cdouble}, result_array) распаковывает указатель Julia на Структура данных массива Julia в форме, понятной C.</target>
        </trans-unit>
        <trans-unit id="07b891ed69432f32d091d715fe2a8f62e3c9dfac" translate="yes" xml:space="preserve">
          <source>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array &lt;code&gt;result_array&lt;/code&gt;. This variable is declared as a &lt;code&gt;Ref{Cdouble}&lt;/code&gt;, since its memory is allocated and managed by Julia. The implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt;&lt;/a&gt; unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e369993cdb5fa6e70590fdbba6d637a46744b422" translate="yes" xml:space="preserve">
          <source>The C null pointer constant, sometimes used when calling external code.</source>
          <target state="translated">Константа нулевого указателя C,иногда используемая при вызове внешнего кода.</target>
        </trans-unit>
        <trans-unit id="1266dcff3400e720f05ea76935c60007b496fe2d" translate="yes" xml:space="preserve">
          <source>The Darwin kernel descends from BSD, which means that &lt;code&gt;Sys.isbsd()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; on macOS systems. To exclude macOS from a predicate, use &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt;.</source>
          <target state="translated">Дарвин Kernel нисходит из BSD, а это значит , что &lt;code&gt;Sys.isbsd()&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; в системах MacOS. Чтобы исключить macOS из предиката, используйте &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d062d595ac22ed3de2b1695d4234bbdd4c8970f" translate="yes" xml:space="preserve">
          <source>The Examples folder &lt;code&gt;clustermanager/simple&lt;/code&gt; is an example that shows a simple implementation using UNIX domain sockets for cluster setup.</source>
          <target state="translated">Папка примеров &lt;code&gt;clustermanager/simple&lt;/code&gt; - это пример, демонстрирующий простую реализацию с использованием сокетов домена UNIX для настройки кластера.</target>
        </trans-unit>
        <trans-unit id="47538569b998ba670f072a1e4a838d9065a41d8f" translate="yes" xml:space="preserve">
          <source>The GC can be allowed to deallocate a variable by removing the reference to it from &lt;code&gt;refs&lt;/code&gt; using the function &lt;code&gt;delete!&lt;/code&gt;, provided that no other reference to the variable is kept anywhere:</source>
          <target state="translated">GC может быть разрешено освободить переменную, удалив ссылку на нее из &lt;code&gt;refs&lt;/code&gt; с помощью функции &lt;code&gt;delete!&lt;/code&gt; при условии, что никакая другая ссылка на переменную нигде не хранится:</target>
        </trans-unit>
        <trans-unit id="9114ec3ce1d9b68ea428c28233e88219f98a90cb" translate="yes" xml:space="preserve">
          <source>The GC can only run when Julia objects are allocated. Calls like &lt;code&gt;jl_box_float64&lt;/code&gt; perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between &lt;code&gt;jl_...&lt;/code&gt; calls. But in order to make sure that values can survive &lt;code&gt;jl_...&lt;/code&gt; calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; macros:</source>
          <target state="translated">Сборщик мусора может работать только при выделении объектов Julia. Вызовы вроде &lt;code&gt;jl_box_float64&lt;/code&gt; выполняют выделение, и выделение может также произойти в любой момент выполнения кода Julia. Однако, как правило, безопасно использовать указатели между вызовами &lt;code&gt;jl_...&lt;/code&gt; Но чтобы убедиться, что значения могут пережить вызовы &lt;code&gt;jl_...&lt;/code&gt; , мы должны сообщить Джулии, что у нас есть ссылка на значение Джулии. Это можно сделать с &lt;code&gt;JL_GC_PUSH&lt;/code&gt; макроса JL_GC_PUSH :</target>
        </trans-unit>
        <trans-unit id="b9622f1df591a3459173814aa7b8701ce73b0cc6" translate="yes" xml:space="preserve">
          <source>The GC can only run when Julia objects are allocated. Calls like &lt;code&gt;jl_box_float64&lt;/code&gt; perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between &lt;code&gt;jl_...&lt;/code&gt; calls. But in order to make sure that values can survive &lt;code&gt;jl_...&lt;/code&gt; calls, we have to tell Julia that we still hold a reference to Julia &lt;a href=&quot;https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf&quot;&gt;root&lt;/a&gt; values, a process called &quot;GC rooting&quot;. Rooting a value will ensure that the garbage collector does not accidentally identify this value as unused and free the memory backing that value. This can be done using the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26097947d8e62d93e95f7bb8a753aa81198a0d" translate="yes" xml:space="preserve">
          <source>The Julia REPL</source>
          <target state="translated">Джулия РЭПЛ</target>
        </trans-unit>
        <trans-unit id="933a15ce4387b92a310db748193668c12bc6df9b" translate="yes" xml:space="preserve">
          <source>The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (&lt;code&gt;^D&lt;/code&gt; to exit, &lt;code&gt;^R&lt;/code&gt; and &lt;code&gt;^S&lt;/code&gt; for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so), or pressing Esc and then the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966cbe6fa0ef45947b54d91f086e0f21369273f7" translate="yes" xml:space="preserve">
          <source>The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (&lt;code&gt;^D&lt;/code&gt; to exit, &lt;code&gt;^R&lt;/code&gt; and &lt;code&gt;^S&lt;/code&gt; for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).</source>
          <target state="translated">Julia REPL отлично использует привязки клавиш. Несколько привязок управляющих клавиш уже были представлены выше ( &lt;code&gt;^D&lt;/code&gt; для выхода, &lt;code&gt;^R&lt;/code&gt; и &lt;code&gt;^S&lt;/code&gt; для поиска), но их гораздо больше. В дополнение к управляющей клавише есть также привязки мета-клавиш. Они больше различаются в зависимости от платформы, но большинство терминалов по умолчанию используют alt- или option, удерживаемые при нажатой клавише для отправки мета-ключа (или могут быть настроены для этого).</target>
        </trans-unit>
        <trans-unit id="78a8d27e5d46846612931d336af5427fb48eaefb" translate="yes" xml:space="preserve">
          <source>The Julia internal variable &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt;&lt;code&gt;Sys.WORD_SIZE&lt;/code&gt;&lt;/a&gt; indicates whether the target system is 32-bit or 64-bit:</source>
          <target state="translated">Внутренняя переменная Julia &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt; &lt;code&gt;Sys.WORD_SIZE&lt;/code&gt; &lt;/a&gt; указывает, является ли целевая система 32-битной или 64-битной:</target>
        </trans-unit>
        <trans-unit id="1693b1af11374cde64dabe11066916f7ee8e88c7" translate="yes" xml:space="preserve">
          <source>The Julia process running the driver script in the example above has an &lt;code&gt;id&lt;/code&gt; equal to 1, just like a process providing an interactive prompt.</source>
          <target state="translated">Процесс Julia, запускающий сценарий драйвера в приведенном выше примере, имеет &lt;code&gt;id&lt;/code&gt; равный 1, как и процесс, предоставляющий интерактивную подсказку.</target>
        </trans-unit>
        <trans-unit id="aa8416476707db541c2333530ff960a4433eec90" translate="yes" xml:space="preserve">
          <source>The Julian mode</source>
          <target state="translated">Юлианский режим</target>
        </trans-unit>
        <trans-unit id="6db1584071cd3b6081826f70375b838eede7d0f5" translate="yes" xml:space="preserve">
          <source>The LQ decomposition is the QR decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;, and it is useful in order to compute the minimum-norm solution &lt;code&gt;lq(A) \ b&lt;/code&gt; to an underdetermined system of equations (&lt;code&gt;A&lt;/code&gt; has more columns than rows, but has full row rank).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c675577bb25cbb84233bfad40ea840727c87ba" translate="yes" xml:space="preserve">
          <source>The LQ decomposition is the QR decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;.</source>
          <target state="translated">LQ-разложение - это QR-разложение &lt;code&gt;transpose(A)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b05b84454661b0ad77fcf176c57484bf1c0a4367" translate="yes" xml:space="preserve">
          <source>The LibGit2 module provides bindings to &lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2&lt;/a&gt;, a portable C library that implements core functionality for the &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; version control system. These bindings are currently used to power Julia's package manager. It is expected that this module will eventually be moved into a separate package.</source>
          <target state="translated">Модуль LibGit2 обеспечивает &lt;a href=&quot;https://libgit2.org/&quot;&gt;привязку&lt;/a&gt; к libgit2 , переносимой библиотеке C, которая реализует основные функции системы контроля версий &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; . Эти привязки в настоящее время используются для управления пакетным менеджером Джулии. Ожидается, что со временем этот модуль будет вынесен в отдельный пакет.</target>
        </trans-unit>
        <trans-unit id="9bf2cc298d975bbd37b6f7fd047fb42694bf8a90" translate="yes" xml:space="preserve">
          <source>The MethodInstance containing the execution context (if it could be found).</source>
          <target state="translated">МетодInstance,содержащий контекст выполнения (если его можно найти).</target>
        </trans-unit>
        <trans-unit id="09f175ba6c5dae9885fb192f636fd6ea181b8da1" translate="yes" xml:space="preserve">
          <source>The MultiSelectMenu allows users to select many choices from a list.</source>
          <target state="translated">MultiSelectMenu позволяет пользователям выбирать множество вариантов из списка.</target>
        </trans-unit>
        <trans-unit id="e79dc73e951d809603b22dcb8e0be503a1e70e20" translate="yes" xml:space="preserve">
          <source>The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression into multiple shell words, and so that uses of Perl variables like &lt;code&gt;$|&lt;/code&gt; (yes, that's the name of a variable in Perl), don't cause interpolation. In other instances, you may want to use double quotes so that interpolation &lt;em&gt;does&lt;/em&gt; occur:</source>
          <target state="translated">Выражение Perl должно быть заключено в одинарные кавычки по двум причинам: чтобы пробелы не разбивали выражение на несколько слов оболочки и чтобы использовать такие переменные Perl, как &lt;code&gt;$|&lt;/code&gt; (да, это имя переменной в Perl), не вызывать интерполяцию. В других случаях вы можете использовать двойные кавычки, чтобы интерполяция &lt;em&gt;действительно&lt;/em&gt; происходила:</target>
        </trans-unit>
        <trans-unit id="8c980de45243fb6623e03d7762f46ca10e22fb57" translate="yes" xml:space="preserve">
          <source>The REPL approximates being in the body of a function by deciding whether assignment inside the loop assigns to a global or creates new local based on whether a global variable by that name is defined or not. If a global by the name exists, then the assignment updates it. If no global exists, then the assignment creates a new local variable. In this example we see both cases in action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac56e6a222fd8496371258c1e3e6d866939f3927" translate="yes" xml:space="preserve">
          <source>The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt;. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.</source>
          <target state="translated">REPL имеет четыре основных режима работы. Первая и самая распространенная - это подсказка по юлианскому календарю. Это режим работы по умолчанию; каждая новая строка изначально начинается с &lt;code&gt;julia&amp;gt;&lt;/code&gt; . Здесь вы можете ввести выражения Julia. Нажатие return или enter после того, как было введено полное выражение, оценит ввод и покажет результат последнего выражения.</target>
        </trans-unit>
        <trans-unit id="7b885d623b0799b11114ac06066f9470abd82025" translate="yes" xml:space="preserve">
          <source>The RadioMenu allows the user to select one option from the list. The &lt;code&gt;request&lt;/code&gt; function displays the interactive menu and returns the index of the selected choice. If a user presses 'q' or &lt;code&gt;ctrl-c&lt;/code&gt;, &lt;code&gt;request&lt;/code&gt; will return a &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">RadioMenu позволяет пользователю выбрать один вариант из списка. Функция &lt;code&gt;request&lt;/code&gt; отображает интерактивное меню и возвращает индекс выбранного варианта. Если пользователь нажимает &amp;laquo;q&amp;raquo; или &lt;code&gt;ctrl-c&lt;/code&gt; , &lt;code&gt;request&lt;/code&gt; вернет &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc95763180c94c043c7cbd64909fa3879451e300" translate="yes" xml:space="preserve">
          <source>The Stable version of Julia is the latest released version of Julia, this is the version most people will want to run. It has the latest features, including improved performance. The Stable version of Julia is versioned according to &lt;a href=&quot;https://semver.org/&quot;&gt;SemVer&lt;/a&gt; as v1.x.y. A new minor release of Julia corresponding to a new Stable version is made approximately every 4-5 months after a few weeks of testing as a release candidate. Unlike the LTS version the a Stable version will not normally recieve bugfixes after another Stable version of Julia has been released. However, upgrading to the next Stable release will always be possible as each release of Julia v1.x will continue to run code written for earlier versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e9b2d3e677af4a8fc2eebaa65445429cdf1c63" translate="yes" xml:space="preserve">
          <source>The Statistics module contains basic statistics functionality.</source>
          <target state="translated">Модуль &quot;Статистика&quot; содержит функционал базовой статистики.</target>
        </trans-unit>
        <trans-unit id="a6cb2cfa7ad804a669566fbac23d8bb1a6bb5c00" translate="yes" xml:space="preserve">
          <source>The Statistics standard library module contains basic statistics functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d7e2a5c0d018541c4ea58100e6545824bf9830" translate="yes" xml:space="preserve">
          <source>The ability to define function behavior across many combinations of argument types via &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;</source>
          <target state="translated">Возможность определять поведение функции для множества комбинаций типов аргументов посредством &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;множественной отправки&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cbecc736377010eae111d725b15330296dbcf5e" translate="yes" xml:space="preserve">
          <source>The above cross referencing is &lt;em&gt;not&lt;/em&gt; a Markdown feature, and relies on &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt;, which is used to build base Julia's documentation.</source>
          <target state="translated">Вышеупомянутая перекрестная ссылка &lt;em&gt;не&lt;/em&gt; является функцией Markdown и основана на &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt; , который используется для создания базовой документации Джулии.</target>
        </trans-unit>
        <trans-unit id="96d64d7232abba83a2151348646c44806eda095b" translate="yes" xml:space="preserve">
          <source>The above mentioned functions can then be used to perform the queries:</source>
          <target state="translated">Вышеперечисленные функции могут быть использованы для выполнения запросов:</target>
        </trans-unit>
        <trans-unit id="b1864a2a8cdc1de40a1915df6dd632015d943dc9" translate="yes" xml:space="preserve">
          <source>The above results are all &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. Literal &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; values can be entered by writing an &lt;code&gt;f&lt;/code&gt; in place of &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">Все приведенные выше результаты являются значениями &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . Литеральные значения &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; можно ввести, написав &lt;code&gt;f&lt;/code&gt; вместо &lt;code&gt;e&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8361f38beb9f62ba5d41300ac34886cea61348b7" translate="yes" xml:space="preserve">
          <source>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</source>
          <target state="translated">Вышеуказанные синтаксические улучшения значительно снижают визуальный шум,возникающий при написании общих математических формул.Обратите внимание,что между числовым буквенным коэффициентом и идентификатором или выражением в скобках,которое он умножает,не может быть пробела.</target>
        </trans-unit>
        <trans-unit id="60fe34a8f000c3fae237bc0700dfba4695829533" translate="yes" xml:space="preserve">
          <source>The above would transfer &lt;code&gt;foo&lt;/code&gt; only once to each worker.</source>
          <target state="translated">Вышеупомянутое передаст &lt;code&gt;foo&lt;/code&gt; каждому рабочему только один раз.</target>
        </trans-unit>
        <trans-unit id="b269bbaa9bb906bbb27460a932677dba11288dd6" translate="yes" xml:space="preserve">
          <source>The absolute path &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; of the REPL's history file. If &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; is not set, then &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; defaults to</source>
          <target state="translated">Абсолютный путь &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; файла истории REPL. Если &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; не установлен, то &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; умолчанию</target>
        </trans-unit>
        <trans-unit id="3648e183f2c998051f65ea547854578d5a18dead" translate="yes" xml:space="preserve">
          <source>The absolute path of the directory containing the Julia executable, which sets the global variable &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt;&lt;code&gt;Sys.BINDIR&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; is not set, then Julia determines the value &lt;code&gt;Sys.BINDIR&lt;/code&gt; at run-time.</source>
          <target state="translated">Абсолютный путь к каталогу, содержащему исполняемый файл Julia, который устанавливает глобальную переменную &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt; &lt;code&gt;Sys.BINDIR&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; не установлен, тогда Джулия определяет значение &lt;code&gt;Sys.BINDIR&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="8927a0d24697e123dd4df5a3afe112eef67df6d2" translate="yes" xml:space="preserve">
          <source>The absolute path of the shell with which Julia should execute external commands (via &lt;code&gt;Base.repl_cmd()&lt;/code&gt;). Defaults to the environment variable &lt;code&gt;$SHELL&lt;/code&gt;, and falls back to &lt;code&gt;/bin/sh&lt;/code&gt; if &lt;code&gt;$SHELL&lt;/code&gt; is unset.</source>
          <target state="translated">Абсолютный путь оболочки, с которой Джулия должна выполнять внешние команды (через &lt;code&gt;Base.repl_cmd()&lt;/code&gt; ). По умолчанию используется переменная окружения &lt;code&gt;$SHELL&lt;/code&gt; и возвращается к &lt;code&gt;/bin/sh&lt;/code&gt; , если &lt;code&gt;$SHELL&lt;/code&gt; не задано.</target>
        </trans-unit>
        <trans-unit id="5eb992db79bc340c73f7d0c78a81caf2c5fb6b5d" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc93eeda62c80f4972fdd152957671d0189f643" translate="yes" xml:space="preserve">
          <source>The abstract supertype of all enumerated types defined with &lt;a href=&quot;#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Абстрактный супертип всех перечислимых типов, определенных с помощью &lt;a href=&quot;#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="001842608bb84d463cf1f0db5f50ad22ca07a767" translate="yes" xml:space="preserve">
          <source>The actual argument values to be passed to the function, if any; each is a separate parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580f4961193cdce395b23ec3d5fef77701e0ce25" translate="yes" xml:space="preserve">
          <source>The actual body of the function is a single &lt;code&gt;leaq&lt;/code&gt; instruction, which computes the integer multiply and add at once. This is even more beneficial when &lt;code&gt;f&lt;/code&gt; gets inlined into another function:</source>
          <target state="translated">Фактическое тело функции - это &lt;code&gt;leaq&lt;/code&gt; инструкция leaq , которая вычисляет целое число, умножение и сложение сразу. Это даже более полезно, когда &lt;code&gt;f&lt;/code&gt; встраивается в другую функцию:</target>
        </trans-unit>
        <trans-unit id="630238b36b114a948ff90dc6c02413e6edb7bf0d" translate="yes" xml:space="preserve">
          <source>The actual definition of &lt;code&gt;@assert&lt;/code&gt; in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (&lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt;), this is specified with an ellipses following the last argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18e2a05bc75f9cb445304a890f63b9983ea2e1c" translate="yes" xml:space="preserve">
          <source>The actual definition of &lt;code&gt;@assert&lt;/code&gt; in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;), this is specified with an ellipses following the last argument:</source>
          <target state="translated">Фактическое определение &lt;code&gt;@assert&lt;/code&gt; в Julia Base более сложное. Это позволяет пользователю дополнительно указать собственное сообщение об ошибке вместо того, чтобы просто печатать неудачное выражение. Как и в функциях с переменным количеством аргументов ( &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;функции Varargs&lt;/a&gt; ), это указывается с помощью многоточия после последнего аргумента:</target>
        </trans-unit>
        <trans-unit id="3249b07e810b7bf455aef815d32c41a4e16eda1a" translate="yes" xml:space="preserve">
          <source>The addition of a &lt;code&gt;Date&lt;/code&gt; with a &lt;code&gt;Time&lt;/code&gt; produces a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;Time&lt;/code&gt; are used along with the year, month, and day of the &lt;code&gt;Date&lt;/code&gt; to create the new &lt;code&gt;DateTime&lt;/code&gt;. Non-zero microseconds or nanoseconds in the &lt;code&gt;Time&lt;/code&gt; type will result in an &lt;code&gt;InexactError&lt;/code&gt; being thrown.</source>
          <target state="translated">Добавление &lt;code&gt;Date&lt;/code&gt; к &lt;code&gt;Time&lt;/code&gt; дает &lt;code&gt;DateTime&lt;/code&gt; . Час, минута, секунда, и миллисекунды части &lt;code&gt;Time&lt;/code&gt; используются наряду с год, месяц и день &lt;code&gt;Date&lt;/code&gt; создания нового &lt;code&gt;DateTime&lt;/code&gt; . Ненулевые микросекунды или наносекунды в типе &lt;code&gt;Time&lt;/code&gt; приведут к &lt;code&gt;InexactError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3453c8422824806e0089fba52c363bf6cdb622f4" translate="yes" xml:space="preserve">
          <source>The adjoint operator &lt;code&gt;'&lt;/code&gt; in Julia returns an adjoint of a vector (a lazy representation of row vector), whereas the transpose operator &lt;code&gt;.T&lt;/code&gt; over a vector in Python returns the original vector (non-op).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0f2aeb81b016f9f8ad15cc7fa177089d4b107f" translate="yes" xml:space="preserve">
          <source>The advantage is that your testing code is now contained in a module and does not use the global scope in &lt;code&gt;Main&lt;/code&gt; for definitions, which is a bit more tidy.</source>
          <target state="translated">Преимущество заключается в том, что ваш тестовый код теперь содержится в модуле и не использует глобальную область видимости в &lt;code&gt;Main&lt;/code&gt; для определений, что немного более аккуратно.</target>
        </trans-unit>
        <trans-unit id="f20a70b4f6a41daccbadde162c2965a4719810ba" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Алгоритм возвращает оценку стандартного отклонения генеративного распределения в предположении, что каждая запись &lt;code&gt;itr&lt;/code&gt; является IID, полученной из этого генеративного распределения. Для массивов это вычисление эквивалентно вычислению &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt; . Если &lt;code&gt;corrected&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , то сумма масштабируется с &lt;code&gt;n-1&lt;/code&gt; , тогда как сумма масштабируется с &lt;code&gt;n&lt;/code&gt; , если &lt;code&gt;corrected&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; с &lt;code&gt;n&lt;/code&gt; числа элементов в &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5d718f1e39513cb56beb2116bcad02f80b82c53" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;true&lt;code&gt;, then the sum is scaled with&lt;/code&gt;n-1&lt;code&gt;, whereas the sum is scaled with&lt;/code&gt;n&lt;code&gt;if&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;false&lt;code&gt;with&lt;/code&gt;n&lt;code&gt;the number of elements in&lt;/code&gt;itr`.</source>
          <target state="translated">Алгоритм возвращает оценку дисперсии генеративного распределения в предположении, что каждая запись &lt;code&gt;itr&lt;/code&gt; является IID, полученной из этого генеративного распределения. Для массивов это вычисление эквивалентно вычислению &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt; исправить &lt;code&gt;is&lt;/code&gt; верно &lt;code&gt;, then the sum is scaled with&lt;/code&gt; п-1 &lt;code&gt;, whereas the sum is scaled with&lt;/code&gt; п , &lt;code&gt;if&lt;/code&gt; исправлены &lt;code&gt;is&lt;/code&gt; ложным &lt;code&gt;with&lt;/code&gt; п &lt;code&gt;the number of elements in&lt;/code&gt; itr`.</target>
        </trans-unit>
        <trans-unit id="57033835ec26e53b58132bc74e3f700bdc54d641" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01293a961a773cd4d130208dbabeea56d0a5c61c" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Алгоритм возвращает оценку дисперсии генеративного распределения в предположении, что каждая запись &lt;code&gt;itr&lt;/code&gt; является IID, полученной из этого генеративного распределения. Для массивов это вычисление эквивалентно вычислению &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt; . Если &lt;code&gt;corrected&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , то сумма масштабируется с &lt;code&gt;n-1&lt;/code&gt; , тогда как сумма масштабируется с &lt;code&gt;n&lt;/code&gt; , если &lt;code&gt;corrected&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; с &lt;code&gt;n&lt;/code&gt; числа элементов в &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa6e80fec84c6187fde0dd2ae7b8f5dc4c529c00" translate="yes" xml:space="preserve">
          <source>The alternative form &lt;code&gt;rethrow(e)&lt;/code&gt; allows you to associate an alternative exception object &lt;code&gt;e&lt;/code&gt; with the current backtrace. However this misrepresents the program state at the time of the error so you're encouraged to instead throw a new exception using &lt;code&gt;throw(e)&lt;/code&gt;. In Julia 1.1 and above, using &lt;code&gt;throw(e)&lt;/code&gt; will preserve the root cause exception on the stack, as described in &lt;a href=&quot;#Base.catch_stack&quot;&gt;&lt;code&gt;catch_stack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac2877c35123766a145f522e7dfc5430f0ca77c" translate="yes" xml:space="preserve">
          <source>The analogue of extracting (or &quot;dereferencing&quot;) all elements of a cell array, e.g. in &lt;code&gt;vertcat(A{:})&lt;/code&gt; in MATLAB, is written using the splat operator in Julia, e.g. as &lt;code&gt;vcat(A...)&lt;/code&gt;.</source>
          <target state="translated">Аналог извлечения (или &amp;laquo;разыменования&amp;raquo;) всех элементов массива ячеек, например, в &lt;code&gt;vertcat(A{:})&lt;/code&gt; в MATLAB, записывается с использованием оператора splat в Julia, например, как &lt;code&gt;vcat(A...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3f2e21d1a797762aaea13aa49c6c7d374ab6e23" translate="yes" xml:space="preserve">
          <source>The annotation &lt;code&gt;@fastmath&lt;/code&gt; re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression &lt;code&gt;1 / (2*dx)&lt;/code&gt; in the function &lt;code&gt;deriv&lt;/code&gt; is hoisted out of the loop (i.e. calculated outside the loop), as if one had written &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt;. In the loop, the expression &lt;code&gt;... / (2*dx)&lt;/code&gt; then becomes &lt;code&gt;... * idx&lt;/code&gt;, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Аннотация &lt;code&gt;@fastmath&lt;/code&gt; переупорядочивает выражения с плавающей запятой, например, изменяя порядок вычисления или предполагая, что определенные особые случаи (inf, nan) не могут возникнуть. В этом случае (и на этом конкретном компьютере) основное отличие состоит в том, что выражение &lt;code&gt;1 / (2*dx)&lt;/code&gt; в функции производное &lt;code&gt;deriv&lt;/code&gt; из цикла (т.е. вычисляется вне цикла), как если бы было написано &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt; . В этом цикле выражение &lt;code&gt;... / (2*dx)&lt;/code&gt; становится &lt;code&gt;... * idx&lt;/code&gt; , который гораздо быстрее оценить. Конечно, как фактическая оптимизация, применяемая компилятором, так и результирующее ускорение во многом зависят от оборудования. Вы можете проверить изменение сгенерированного кода, используя функцию Юлии &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91407676de179a11323fecebc90b0b28f6220397" translate="yes" xml:space="preserve">
          <source>The application also depends on the &lt;code&gt;Pub&lt;/code&gt; package, which in turn depends on the public &lt;code&gt;Priv&lt;/code&gt; and the same &lt;code&gt;Zebra&lt;/code&gt; package that the private &lt;code&gt;Priv&lt;/code&gt; package depends on.</source>
          <target state="translated">Приложение также зависит от &lt;code&gt;Pub&lt;/code&gt; пакета, который , в свою очередь , зависит от общественности &lt;code&gt;Priv&lt;/code&gt; и того же &lt;code&gt;Zebra&lt;/code&gt; пакета, частный &lt;code&gt;Priv&lt;/code&gt; пакет зависит.</target>
        </trans-unit>
        <trans-unit id="d108508038e64416f7594e79cff0ba0d5c60ed1c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;A&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;ldiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;code&gt;A&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; должен быть матрицей. Скорее, вместо матриц это должен быть объект факторизации (например, произведенный &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; ). Причина этого в том, что факторизация сама по себе является дорогостоящей и обычно выделяет память (хотя это также может быть выполнено на месте, например, &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; &lt;/a&gt; ), А также критические для производительности ситуации, требующие &lt;code&gt;ldiv!&lt;/code&gt; как правило , требует также мелкозернистого контроля над факторизацией &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba5f6815e327ac58578c3c74637303b6ebdc780" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;B&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;rdiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;code&gt;B&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; должен быть матрицей. Скорее, вместо матриц это должен быть объект факторизации (например, произведенный &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; ). Причина этого в том, что сама факторизация является дорогостоящей и обычно выделяет память (хотя ее также можно выполнить на месте, например, &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; &lt;/a&gt; ), А также в критических для производительности ситуациях, требующих &lt;code&gt;rdiv!&lt;/code&gt; как правило , требует также мелкозернистого контроля над факторизацией &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6947ba42284e98465ca0fe899c7260684fa80d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__module__&lt;/code&gt; provides information (in the form of a &lt;code&gt;Module&lt;/code&gt; object) about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.</source>
          <target state="translated">Аргумент &lt;code&gt;__module__&lt;/code&gt; предоставляет информацию (в форме объекта &lt;code&gt;Module&lt;/code&gt; ) о контексте расширения вызова макроса. Это позволяет макросам искать контекстную информацию, такую ​​как существующие привязки, или вставлять значение в качестве дополнительного аргумента в вызов функции времени выполнения, выполняющий самоотражение в текущем модуле.</target>
        </trans-unit>
        <trans-unit id="118cff9af4b8de3b0527244748b6b6cdd9ccdeb6" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__source__&lt;/code&gt; provides information (in the form of a &lt;code&gt;LineNumberNode&lt;/code&gt; object) about the parser location of the &lt;code&gt;@&lt;/code&gt; sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt;&lt;code&gt;@__LINE__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt;&lt;code&gt;@__DIR__&lt;/code&gt;&lt;/a&gt; macros.</source>
          <target state="translated">Аргумент &lt;code&gt;__source__&lt;/code&gt; предоставляет информацию (в форме объекта &lt;code&gt;LineNumberNode&lt;/code&gt; ) о местоположении синтаксического анализатора знака &lt;code&gt;@&lt;/code&gt; из вызова макроса. Это позволяет макросам включать лучшую диагностическую информацию об ошибках и обычно используется, например, при &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt; &lt;code&gt;@__LINE__&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; , макросах парсера строк и документах, а также для реализации макросов @__LINE__ , @__FILE__ и &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt; &lt;code&gt;@__DIR__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28332afec21b48c8f9eedddb529063711d48dde4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;val&lt;/code&gt; to a function or constructor is outside the valid domain.</source>
          <target state="translated">Аргумент &lt;code&gt;val&lt;/code&gt; функции или конструктора находится за пределами допустимого домена.</target>
        </trans-unit>
        <trans-unit id="c5eb1e5a4cdcda6110ebd89f0ecb14ceede7e9cb" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;left&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">Аргумент находится в &lt;em&gt;левой&lt;/em&gt; части матрично-матричной операции.</target>
        </trans-unit>
        <trans-unit id="7b59a99385d1b11a2ad5b866d4ec7b5957c8ab4c" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;right&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">Аргумент идет в &lt;em&gt;правой&lt;/em&gt; части матрично-матричной операции.</target>
        </trans-unit>
        <trans-unit id="1401afc18591a21d5a01e530b4ce757f985dd757" translate="yes" xml:space="preserve">
          <source>The arguments may be integer and rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="884d75c174d0479198ef02863fa90299587b8335" translate="yes" xml:space="preserve">
          <source>The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)</source>
          <target state="translated">Данные массива должны быть представлены в двоичном формате (например,ASCII-формат,такой как CSV,не поддерживается).</target>
        </trans-unit>
        <trans-unit id="b10872dab02eb4daf575beb40c2f7b4e9635a0b7" translate="yes" xml:space="preserve">
          <source>The asserted condition did not evaluate to &lt;code&gt;true&lt;/code&gt;. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">Утвержденное условие не соответствует &lt;code&gt;true&lt;/code&gt; . Необязательный аргумент &lt;code&gt;msg&lt;/code&gt; - это описательная строка ошибки.</target>
        </trans-unit>
        <trans-unit id="9ef046749eb00971a20635012815c9aa3fe8e4de" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt; since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage. Here is an example where the behavior of &lt;code&gt;let&lt;/code&gt; is needed:</source>
          <target state="translated">Присваивания оцениваются по порядку, каждая правая часть оценивается в области видимости до того, как будет введена новая переменная в левой части. Поэтому имеет смысл написать что-то вроде &lt;code&gt;let x = x&lt;/code&gt; поскольку две переменные &lt;code&gt;x&lt;/code&gt; различны и имеют отдельное хранилище. Вот пример, в котором необходимо поведение &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="332e2ebabecf595b9a10dedb9752fafc32737dcf" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt;, since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage.</source>
          <target state="translated">Присваивания оцениваются по порядку, каждая правая часть оценивается в области видимости до того, как будет введена новая переменная в левой части. Поэтому имеет смысл написать что-то вроде &lt;code&gt;let x = x&lt;/code&gt; , поскольку две переменные &lt;code&gt;x&lt;/code&gt; различны и имеют отдельное хранилище.</target>
        </trans-unit>
        <trans-unit id="cb5c5acb0ed1217a3a242c8796f09db063ffe31c" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like &lt;code&gt;-&lt;/code&gt; because it is undefined whether &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; should be evaluated as &lt;code&gt;(1-2)-3&lt;/code&gt; or &lt;code&gt;1-(2-3)&lt;/code&gt;. Use &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity.</source>
          <target state="translated">Ассоциативность сокращения зависит от реализации. Это означает, что вы не можете использовать неассоциативные операции, такие как &lt;code&gt;-&lt;/code&gt; , потому что не определено, должно ли &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; оцениваться как &lt;code&gt;(1-2)-3&lt;/code&gt; или &lt;code&gt;1-(2-3)&lt;/code&gt; , &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt; этого используйте foldl или &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; &lt;/a&gt; для гарантированной левой или правой ассоциативности.</target>
        </trans-unit>
        <trans-unit id="8e83411f941380eef1e4e97a62a5d00092492f0f" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of &lt;code&gt;f&lt;/code&gt; for elements that appear multiple times in &lt;code&gt;itr&lt;/code&gt;. Use &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity and invocation of &lt;code&gt;f&lt;/code&gt; for every value.</source>
          <target state="translated">Ассоциативность сокращения зависит от реализации. Кроме того, некоторые реализации могут повторно использовать возвращаемое значение &lt;code&gt;f&lt;/code&gt; для элементов, которые появляются в &lt;code&gt;itr&lt;/code&gt; несколько раз . &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldl&lt;/code&gt; &lt;/a&gt; этого используйте mapfoldl или &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldr&lt;/code&gt; &lt;/a&gt; для гарантированной левой или правой ассоциативности и вызова &lt;code&gt;f&lt;/code&gt; для каждого значения.</target>
        </trans-unit>
        <trans-unit id="fa2ffdac4b6b173468c64bdf00df48adef8f3782" translate="yes" xml:space="preserve">
          <source>The available color keys can be seen by typing &lt;code&gt;Base.text_colors&lt;/code&gt; in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.</source>
          <target state="translated">Доступные цветовые ключи можно увидеть, набрав &lt;code&gt;Base.text_colors&lt;/code&gt; в режиме справки REPL. Кроме того, целые числа от 0 до 255 могут использоваться в качестве цветовых ключей для терминалов с поддержкой 256 цветов.</target>
        </trans-unit>
        <trans-unit id="d6514960ce535f34b9eb969fcb1b4f9c39742102" translate="yes" xml:space="preserve">
          <source>The base Julia installation has in-built support for two types of clusters:</source>
          <target state="translated">Базовая установка Julia имеет встроенную поддержку двух типов кластеров:</target>
        </trans-unit>
        <trans-unit id="562f643f12db492fbdb1e985351909d826402fa4" translate="yes" xml:space="preserve">
          <source>The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).</source>
          <target state="translated">Базовое время выполнения Julia обеспечивает только текстовое отображение,но более богатое отображение может быть включено при загрузке внешних модулей или при использовании графических сред Julia (таких как ноутбук IJulia на базе IPython).</target>
        </trans-unit>
        <trans-unit id="002dc05c0d427615b628a5faca800a873b359de7" translate="yes" xml:space="preserve">
          <source>The base array type in Julia is the abstract type &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray{T,N}&lt;/code&gt;&lt;/a&gt;. It is parameterized by the number of dimensions &lt;code&gt;N&lt;/code&gt; and the element type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt;&lt;code&gt;AbstractVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt;&lt;code&gt;AbstractMatrix&lt;/code&gt;&lt;/a&gt; are aliases for the 1-d and 2-d cases. Operations on &lt;code&gt;AbstractArray&lt;/code&gt; objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</source>
          <target state="translated">Базовым типом массива в Julia является абстрактный тип &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; &lt;/a&gt; . Это параметризуется число измерений &lt;code&gt;N&lt;/code&gt; и типа элемента &lt;code&gt;T&lt;/code&gt; . &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt; &lt;code&gt;AbstractVector&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt; &lt;code&gt;AbstractMatrix&lt;/code&gt; &lt;/a&gt; - это псевдонимы для 1-го и 2-го случаев. Операции с объектами &lt;code&gt;AbstractArray&lt;/code&gt; определяются с помощью операторов и функций более высокого уровня независимо от базового хранилища. Эти операции обычно работают правильно как резерв для любой конкретной реализации массива.</target>
        </trans-unit>
        <trans-unit id="b29d93a344c231f0373e8777552dd842d0c0ae6b" translate="yes" xml:space="preserve">
          <source>The base library of Julia. &lt;code&gt;Base&lt;/code&gt; is a module that contains basic functionality (the contents of &lt;code&gt;base/&lt;/code&gt;). All modules implicitly contain &lt;code&gt;using Base&lt;/code&gt;, since this is needed in the vast majority of cases.</source>
          <target state="translated">Базовая библиотека Юлии. &lt;code&gt;Base&lt;/code&gt; - это модуль, который содержит базовую функциональность (содержимое &lt;code&gt;base/&lt;/code&gt; ). Все модули неявно содержат &lt;code&gt;using Base&lt;/code&gt; , поскольку это необходимо в подавляющем большинстве случаев.</target>
        </trans-unit>
        <trans-unit id="f9d1c85fa2408916e8a238b5528b77d6327d21e9" translate="yes" xml:space="preserve">
          <source>The basic function for waiting for an event is &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. Several objects implement &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;; for example, given a &lt;code&gt;Process&lt;/code&gt; object, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; will wait for it to exit. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is often implicit; for example, a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; can happen inside a call to &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; to wait for data to be available.</source>
          <target state="translated">Основная функция ожидания события - &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . Несколько объектов реализуют &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; ; например, для объекта &lt;code&gt;Process&lt;/code&gt; функция &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; будет ждать его выхода. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; часто подразумевается; например, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; может произойти внутри вызова на &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; чтобы дождаться доступности данных.</target>
        </trans-unit>
        <trans-unit id="14cf1a6587ccfeb2916e3241169682e31c9f7659" translate="yes" xml:space="preserve">
          <source>The basic issue is that there is &lt;em&gt;nothing special about Julia's compiler&lt;/em&gt;: we use a commonplace compiler (LLVM) with no &amp;ldquo;secret sauce&amp;rdquo; that other language developers don't know about. Indeed, Julia's compiler is in many ways much simpler than those of other dynamic languages (e.g. PyPy or LuaJIT). Julia's performance advantage derives almost entirely from its front-end: its language semantics allow a &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;well-written Julia program&lt;/a&gt; to &lt;em&gt;give more opportunities to the compiler&lt;/em&gt; to generate efficient code and memory layouts. If you tried to compile Matlab or Python code to Julia, our compiler would be limited by the semantics of Matlab or Python to producing code no better than that of existing compilers for those languages (and probably worse). The key role of semantics is also why several existing Python compilers (like Numba and Pythran) only attempt to optimize a small subset of the language (e.g. operations on Numpy arrays and scalars), and for this subset they are already doing at least as well as we could for the same semantics. The people working on those projects are incredibly smart and have accomplished amazing things, but retrofitting a compiler onto a language that was designed to be interpreted is a very difficult problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38afa5a3f5d12c0c2e4c45c469ff70f9f6584c66" translate="yes" xml:space="preserve">
          <source>The basic syntax is simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called &lt;em&gt;docstrings&lt;/em&gt;). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:</source>
          <target state="translated">Базовый синтаксис прост: любая строка, появляющаяся на верхнем уровне прямо перед объектом (функцией, макросом, типом или экземпляром), будет интерпретироваться как документирующая его (они называются &lt;em&gt;строками документации&lt;/em&gt; ). Обратите внимание, что между строкой документации и документированным объектом не должно быть пустых строк или комментариев. Вот простой пример:</target>
        </trans-unit>
        <trans-unit id="33dcf1261b96e1096c0d88cf03a127c00532ab23" translate="yes" xml:space="preserve">
          <source>The basic syntax is simple: any string appearing at the toplevel right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called &lt;em&gt;docstrings&lt;/em&gt;). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6788f6ee76ef14250b1c48634160dc28850751" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;missing&lt;/code&gt; values follows one basic rule: &lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard operators and functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means an operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="translated">Поведение &lt;code&gt;missing&lt;/code&gt; значений следует одному основному правилу: &lt;code&gt;missing&lt;/code&gt; значения автоматически &lt;em&gt;распространяются&lt;/em&gt; при передаче в стандартные операторы и функции, в частности математические функции. Неуверенность в значении одного из операндов вызывает неуверенность в результате. На практике это означает, что операция с &lt;code&gt;missing&lt;/code&gt; значением обычно возвращает &lt;code&gt;missing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7e648e6d6c87b02acc6c1db84cf592e9a9a93a8" translate="yes" xml:space="preserve">
          <source>The behavior of the logical &quot;and&quot; operator &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; is similar to that of the &lt;code&gt;|&lt;/code&gt; operator, with the difference that missingness does not propagate when one of the operands is &lt;code&gt;false&lt;/code&gt;. For example, when that is the case of the first operand</source>
          <target state="translated">Поведение логического оператора &amp;laquo;И&amp;raquo; &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; аналогично поведению оператора &lt;code&gt;|&lt;/code&gt; оператор, с той разницей, что отсутствие не распространяется, если один из операндов &lt;code&gt;false&lt;/code&gt; . Например, в случае первого операнда</target>
        </trans-unit>
        <trans-unit id="ab054bf408727eebc7e261fecbdce6bbcf7910b4" translate="yes" xml:space="preserve">
          <source>The best approach is to avoid defining &lt;em&gt;either&lt;/em&gt; of these methods: instead, rely on a generic method &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; and make sure this method is implemented with generic calls (like &lt;code&gt;similar&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) that do the right thing for each container type and element type &lt;em&gt;separately&lt;/em&gt;. This is just a more complex variant of the advice to &lt;a href=&quot;#man-methods-orthogonalize&quot;&gt;orthogonalize&lt;/a&gt; your methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b67ccc64e36fcf07f7c05aa43c8c2a633077f18" translate="yes" xml:space="preserve">
          <source>The best approach is to avoid defining &lt;em&gt;either&lt;/em&gt; of these methods: instead, rely on a generic method &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; and make sure this method is implemented with generic calls (like &lt;code&gt;similar&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) that do the right thing for each container type and element type &lt;em&gt;separately&lt;/em&gt;. This is just a more complex variant of the advice to &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;orthogonalize&lt;/a&gt; your methods.</source>
          <target state="translated">Наилучший подход - избегать определения &lt;em&gt;любого&lt;/em&gt; из этих методов: вместо этого полагайтесь на общий метод &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; и убедитесь, что этот метод реализован с помощью общих вызовов (например, &lt;code&gt;similar&lt;/code&gt; и &lt;code&gt;-&lt;/code&gt; ), которые делают правильные вещи для каждый тип контейнера и тип элемента &lt;em&gt;отдельно&lt;/em&gt; . Это просто более сложный вариант совета по &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;ортогонализации&lt;/a&gt; ваших методов.</target>
        </trans-unit>
        <trans-unit id="24e50b0f52b6b5a46a65d54e76552fe8b8d70561" translate="yes" xml:space="preserve">
          <source>The best way to ensure this is to acquire a lock around any access to data that can be observed from multiple threads. For example, in most cases you should use the following code pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d958f10307af7b028b81ab80b4d640f64af23b08" translate="yes" xml:space="preserve">
          <source>The better design would be to define your call hierarchy like this:</source>
          <target state="translated">Лучше всего было бы определить вашу иерархию вызовов таким образом:</target>
        </trans-unit>
        <trans-unit id="3983e66c166493bdb9b9e27ea74aedeb9d2d8cf1" translate="yes" xml:space="preserve">
          <source>The biggest advantage of &lt;code&gt;advection_shared!&lt;/code&gt; is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.</source>
          <target state="translated">Самое большое преимущество &lt;code&gt;advection_shared!&lt;/code&gt; заключается в том, что он минимизирует трафик между рабочими, позволяя каждому выполнять вычисления в течение длительного времени на назначенной части.</target>
        </trans-unit>
        <trans-unit id="194659e7083e920d17f0c59327a653e32e8cfe4a" translate="yes" xml:space="preserve">
          <source>The binary operator &lt;code&gt;&amp;asymp;&lt;/code&gt; is equivalent to &lt;code&gt;isapprox&lt;/code&gt; with the default arguments, and &lt;code&gt;x ≉ y&lt;/code&gt; is equivalent to &lt;code&gt;!isapprox(x,y)&lt;/code&gt;.</source>
          <target state="translated">Бинарный оператор &lt;code&gt;&amp;asymp;&lt;/code&gt; эквивалентен &lt;code&gt;isapprox&lt;/code&gt; с аргументами по умолчанию, а &lt;code&gt;x ≉ y&lt;/code&gt; эквивалентен &lt;code&gt;!isapprox(x,y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba294c6e25bcc46b7feed1d1a73c0b3e0ef49e3" translate="yes" xml:space="preserve">
          <source>The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:</source>
          <target state="translated">На пустых линиях на самом деле есть пробелы.К счастью,приведенная выше неловкая идиома не нужна для итерации через символы в строке,так как вы можете просто использовать строку как итерабельный объект,никакой обработки исключений не требуется:</target>
        </trans-unit>
        <trans-unit id="de9db3cae53c5214143033ee37e23b9bcca06442" translate="yes" xml:space="preserve">
          <source>The block size for QR decomposition can be specified by keyword argument &lt;code&gt;blocksize :: Integer&lt;/code&gt; when &lt;code&gt;pivot == Val(false)&lt;/code&gt; and &lt;code&gt;A isa StridedMatrix{&amp;lt;:BlasFloat}&lt;/code&gt;. It is ignored when &lt;code&gt;blocksize &amp;gt; minimum(size(A))&lt;/code&gt;. See &lt;a href=&quot;#LinearAlgebra.QRCompactWY&quot;&gt;&lt;code&gt;QRCompactWY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586252847b0a965d3d0a5b40259b311ee19d7146" translate="yes" xml:space="preserve">
          <source>The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by &lt;code&gt;similar&lt;/code&gt;, using the Broadcasted object as its first argument.</source>
          <target state="translated">Стиль широковещания вычисляется для каждой операции широковещания, чтобы учесть диспетчеризацию и специализацию. Фактическое выделение результирующего массива обрабатывается &lt;code&gt;similar&lt;/code&gt; , с использованием объекта Broadcasted в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="5232abbd2579e189a3c4536c48fbc58adcc52edd" translate="yes" xml:space="preserve">
          <source>The built-in concrete type used for strings (and string literals) in Julia is &lt;code&gt;String&lt;/code&gt;. This supports the full range of &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; characters via the &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; encoding. (A &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert to/from other Unicode encodings.)</source>
          <target state="translated">Встроенный конкретный тип, используемый для строк (и строковых литералов) в Julia, - это &lt;code&gt;String&lt;/code&gt; . Это поддерживает полный диапазон &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;символов Юникода&lt;/a&gt; в &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;кодировке UTF-8&lt;/a&gt; . (Для преобразования в / из других кодировок Unicode предусмотрена функция &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="dc25d16dd1aba7b0c5bea6b12ba6118124030ae4" translate="yes" xml:space="preserve">
          <source>The byte offset of field &lt;code&gt;i&lt;/code&gt; of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</source>
          <target state="translated">Смещение в байтах поля &lt;code&gt;i&lt;/code&gt; типа относительно начала данных. Например, мы могли бы использовать его следующим образом для обобщения информации о структуре:</target>
        </trans-unit>
        <trans-unit id="2947adec00e452cbe7215d4a9d5ddd5347c0e1b7" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;time&lt;/code&gt; is delayed by wrapping it in a 0-argument anonymous function that is called only when the requested key is absent from &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df22a65b46868ee938e0477154f053724ad2e34c" translate="yes" xml:space="preserve">
          <source>The callback you pass to C should only execute a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;:uv_async_send&lt;/code&gt;, passing &lt;code&gt;cond.handle&lt;/code&gt; as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</source>
          <target state="translated">Обратный вызов, который вы передаете C, должен выполнять &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; только&lt;/a&gt; для &lt;code&gt;:uv_async_send&lt;/code&gt; , передавая &lt;code&gt;cond.handle&lt;/code&gt; в качестве аргумента, стараясь избегать любых выделений или других взаимодействий со средой выполнения Julia.</target>
        </trans-unit>
        <trans-unit id="1914d99c521314d189e5cd08206a81317617d28f" translate="yes" xml:space="preserve">
          <source>The caller must be holding the &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; that owns &lt;code&gt;c&lt;/code&gt; before calling this method. The calling task will be blocked until some other task wakes it, usually by calling &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e65b00ae78a0300e89eb33901bc2c6dff08184" translate="yes" xml:space="preserve">
          <source>The caller must be holding the &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; that owns &lt;code&gt;c&lt;/code&gt; before calling this method. The calling task will be blocked until some other task wakes it, usually by calling &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</source>
          <target state="translated">Перед вызовом этого метода вызывающая сторона должна удерживать &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; которой принадлежит &lt;code&gt;c&lt;/code&gt; . Вызывающая задача будет заблокирована до тех пор, пока ее не разбудит какая-то другая задача, обычно путем вызова &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; `для того же объекта Condition. При блокировке блокировка будет снята атомарно (даже если она была заблокирована рекурсивно) и будет восстановлена ​​перед возвратом.</target>
        </trans-unit>
        <trans-unit id="b9769cfc324c619140bf4882f569b4d5be45feda" translate="yes" xml:space="preserve">
          <source>The case of &lt;code&gt;rand&lt;/code&gt; is a bit more complex as we have to ensure that each thread uses non-overlapping pseudorandom number sequences. This can be simply ensured by using &lt;code&gt;Future.randjump&lt;/code&gt; function:</source>
          <target state="translated">Случай с &lt;code&gt;rand&lt;/code&gt; немного сложнее, так как мы должны гарантировать, что каждый поток использует неперекрывающиеся псевдослучайные числовые последовательности. Это можно просто обеспечить, используя функцию &lt;code&gt;Future.randjump&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5555fa452d0454119cd31b5aa3d13eec12b96796" translate="yes" xml:space="preserve">
          <source>The channels example from above can be modified for interprocess communication, as shown below.</source>
          <target state="translated">Пример каналов сверху может быть изменен для межпроцессного взаимодействия,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="89b722bb0d4e7814b2f6957c408ca31cc4584902" translate="yes" xml:space="preserve">
          <source>The choice of which method to execute when a function is applied is called &lt;em&gt;dispatch&lt;/em&gt;. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in &lt;code&gt;x + y&lt;/code&gt; belong to &lt;code&gt;x&lt;/code&gt; any more than it does to &lt;code&gt;y&lt;/code&gt;? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</source>
          <target state="translated">Выбор метода для выполнения при применении функции называется &lt;em&gt;диспетчеризацией&lt;/em&gt; . Джулия позволяет процессу диспетчеризации выбирать, какой из методов функции вызывать, в зависимости от количества заданных аргументов и типов всех аргументов функции. Это отличается от традиционных объектно-ориентированных языков, где отправка происходит на основе только первого аргумента, который часто имеет особый синтаксис аргумента и иногда подразумевается, а не явно записывается как аргумент. &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; Использование всех аргументов функции для выбора метода, который следует вызвать, а не только первого, называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;многократной отправкой.&lt;/a&gt;, Множественная отправка особенно полезна для математического кода, где нет смысла искусственно считать, что операции &amp;laquo;принадлежат&amp;raquo; одному аргументу больше, чем любому из других: принадлежит ли операция сложения в &lt;code&gt;x + y&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; больше, чем к &lt;code&gt;y&lt;/code&gt; ? Реализация математического оператора обычно зависит от типов всех его аргументов. Однако даже за пределами математических операций множественная диспетчеризация оказывается мощной и удобной парадигмой для структурирования и организации программ.</target>
        </trans-unit>
        <trans-unit id="13ecd81245d046d8f7c6febb538d3020c7b75542" translate="yes" xml:space="preserve">
          <source>The choice of which method to execute when a function is applied is called &lt;em&gt;dispatch&lt;/em&gt;. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in &lt;code&gt;x + y&lt;/code&gt; belong to &lt;code&gt;x&lt;/code&gt; any more than it does to &lt;code&gt;y&lt;/code&gt;? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810842d6186800c0a575092bdf409289f500ddec" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;x-&amp;gt;x&lt;/code&gt; carries a reference to &lt;code&gt;Foo&lt;/code&gt;, and since &lt;code&gt;Foo&lt;/code&gt; is unavailable on node 2, an &lt;code&gt;UndefVarError&lt;/code&gt; is thrown.</source>
          <target state="translated">Замыкание &lt;code&gt;x-&amp;gt;x&lt;/code&gt; содержит ссылку на &lt;code&gt;Foo&lt;/code&gt; , и поскольку &lt;code&gt;Foo&lt;/code&gt; недоступен на узле 2, &lt;code&gt;UndefVarError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd31f7bc6251a511018cdc2ef8ff1b65e61abb04" translate="yes" xml:space="preserve">
          <source>The cluster manager captures the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; of each worker and makes it available to the master process.</source>
          <target state="translated">Диспетчер кластера захватывает стандартный &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; каждого рабочего и делает его доступным для главного процесса.</target>
        </trans-unit>
        <trans-unit id="232fd0535972887717b19fb5bb8c4cfab94a62e6" translate="yes" xml:space="preserve">
          <source>The code above is equivalent to calling &lt;code&gt;get&lt;/code&gt; with an anonymous function containing the code enclosed between &lt;code&gt;do&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c5bc198a3439c620845fc2e6da1bcc9a273974" translate="yes" xml:space="preserve">
          <source>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fPIC&lt;/code&gt; options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)</source>
          <target state="translated">Вызываемый код должен быть доступен как общая библиотека. Большинство библиотек C и Fortran уже скомпилированы как разделяемые библиотеки, но если вы сами компилируете код с помощью GCC (или Clang), вам нужно будет использовать &lt;code&gt;-shared&lt;/code&gt; и &lt;code&gt;-fPIC&lt;/code&gt; параметры. Машинные инструкции, сгенерированные JIT Джулии, такие же, как и собственный вызов C, поэтому результирующие накладные расходы такие же, как при вызове библиотечной функции из кода C. (Вызовы небиблиотечных функций как в C, так и в Julia могут быть встроены и, таким образом, могут иметь даже меньше накладных расходов, чем вызовы функций совместно используемых библиотек. Когда и библиотеки, и исполняемые файлы генерируются LLVM, можно выполнять оптимизацию всей программы, которая может даже оптимизировать через эту границу, но Джулия еще не поддерживает это. Однако в будущем это может сделать это, что приведет к еще большему увеличению производительности.)</target>
        </trans-unit>
        <trans-unit id="34cdd974b77024d3560260c4b5ac606cb2155811" translate="yes" xml:space="preserve">
          <source>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fPIC&lt;/code&gt; options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f830d6caf7ed0451c6b75d05afceaf2e516b19" translate="yes" xml:space="preserve">
          <source>The collection must not be empty.</source>
          <target state="translated">Коллекция не должна быть пустой.</target>
        </trans-unit>
        <trans-unit id="b1b1444de74c16e81499ba99fc21db058cdbcd70" translate="yes" xml:space="preserve">
          <source>The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, which is to be placed inside your home directory:</source>
          <target state="translated">Цвета, используемые Джулией и REPL, также могут быть изменены. Чтобы изменить цвет приглашения Julia, вы можете добавить что-то вроде следующего в ваш файл &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; , который будет помещен в ваш домашний каталог:</target>
        </trans-unit>
        <trans-unit id="6ae3351e931cdaf68574bd5908ad25710f928fca" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">Предполагается, что столбцы разделены одним или несколькими пробелами. В качестве разделителя конца строки принимается &lt;code&gt;\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b166229d69582696f7886d8f6669f9f89c33f90c" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">Предполагается, что столбцы разделены одним или несколькими пробелами. В качестве разделителя конца строки принимается &lt;code&gt;\n&lt;/code&gt; . Если все данные числовые, результатом будет числовой массив. Если некоторые элементы не могут быть проанализированы как числа, возвращается неоднородный массив чисел и строк.</target>
        </trans-unit>
        <trans-unit id="c128fcb09c50ebb22346ed7e858f0e921632da46" translate="yes" xml:space="preserve">
          <source>The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:</source>
          <target state="translated">Сочетание высокоуровневого языка программирования,первоклассной абстракции команд и автоматической настройки труб между процессами является мощным средством.Чтобы дать некоторое представление о сложных трубопроводах,которые можно легко создать,вот несколько более сложных примеров,с извинениями за чрезмерное использование однолинейных Perl:</target>
        </trans-unit>
        <trans-unit id="6a7191f54d1d0a0057ae059656a933d9b6a26e58" translate="yes" xml:space="preserve">
          <source>The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as &lt;code&gt;julia&lt;/code&gt;'s immediate child process, using &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; calls.</source>
          <target state="translated">Команда никогда не запускается с оболочкой. Вместо этого Джулия анализирует синтаксис команды напрямую, соответствующим образом интерполируя переменные и разделяя слова, как это сделала бы оболочка, соблюдая синтаксис кавычек оболочки. Команда запускается как непосредственный дочерний процесс &lt;code&gt;julia&lt;/code&gt; с использованием вызовов &lt;code&gt;fork&lt;/code&gt; и &lt;code&gt;exec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a0dcc8c9826601bed0e074d703f3ff7a640f8d1" translate="yes" xml:space="preserve">
          <source>The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; or &lt;code&gt;eachindex(x)&lt;/code&gt; instead (see also &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt;).</source>
          <target state="translated">Распространенная идиома использования 1: n для индексации в AbstractArray небезопасна, если массив использует нетрадиционное индексирование, и может вызвать ошибку сегментации, если проверка границ отключена. &lt;code&gt;LinearIndices(x)&lt;/code&gt; используйте LinearIndices (x) или &lt;code&gt;eachindex(x)&lt;/code&gt; (см. Также &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;массивы смещения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0bf4109d6939a09708619e91409334de90fe3c1c" translate="yes" xml:space="preserve">
          <source>The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; or &lt;code&gt;eachindex(x)&lt;/code&gt; instead (see also &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;Arrays with custom indices&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0451ae3f3f75dd1173ec1688aaf529347960c71" translate="yes" xml:space="preserve">
          <source>The commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;). This means it will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">Обычно используемый тип &lt;code&gt;Int&lt;/code&gt; соответствует машинному целочисленному типу ( &lt;code&gt;Int32&lt;/code&gt; или &lt;code&gt;Int64&lt;/code&gt; ). Это означает, что он переполнится, так что &lt;code&gt;2^64 == 0&lt;/code&gt; . Если вам нужны большие значения, используйте другой подходящий тип, например &lt;code&gt;Int128&lt;/code&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; или тип с плавающей запятой, например &lt;code&gt;Float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="282c5d6af8a85d4583f2090ba3bf0607d51cccb2" translate="yes" xml:space="preserve">
          <source>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of &lt;code&gt;Union&lt;/code&gt; types with a small number of types &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;, by generating specialized code in separate branches for each possible type.</source>
          <target state="translated">Компиляторы для многих языков имеют конструкцию внутреннего объединения для рассуждений о типах; Юля просто выставляет программисту. Компилятор Julia может генерировать эффективный код при наличии типов &lt;code&gt;Union&lt;/code&gt; с небольшим количеством типов &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; , генерируя специализированный код в отдельных ветвях для каждого возможного типа.</target>
        </trans-unit>
        <trans-unit id="1be479cb36a150784847fcc775f7e727a4aeb4b9" translate="yes" xml:space="preserve">
          <source>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of &lt;code&gt;Union&lt;/code&gt; types with a small number of types &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;, by generating specialized code in separate branches for each possible type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9aee61fefed95ed11583fb480004204213f80db" translate="yes" xml:space="preserve">
          <source>The complete list is in the parser code: https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d307808f74aeaa37d8dbbea9a15606c901a4cae0" translate="yes" xml:space="preserve">
          <source>The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.</source>
          <target state="translated">Заполнение полей для вывода из функций использует типовой вывод,и он может предложить поля только в том случае,если функция является устойчивой к типу.</target>
        </trans-unit>
        <trans-unit id="d3138fe1fc8f7174a34adb1898449525528a913c" translate="yes" xml:space="preserve">
          <source>The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.</source>
          <target state="translated">Завершение работы методов использует вывод типа и,следовательно,может проверить,совпадают ли аргументы,даже если они выводятся из функций.Функция должна быть стабильной по типу,чтобы она могла удалить несовпадающие методы.</target>
        </trans-unit>
        <trans-unit id="6f83f5850ac6b62e295ec56f0e83533e7801ad37" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; is linear in the length of &lt;code&gt;s&lt;/code&gt;, unless an optimized method with constant complexity is available, which is the case for &lt;code&gt;Dict&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;BitSet&lt;/code&gt;. For more than a few calls, use &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; instead, or either &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; or &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; as appropriate.</source>
          <target state="translated">Сложность &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; линейна по длине &lt;code&gt;s&lt;/code&gt; , если не доступен оптимизированный метод с постоянной сложностью, как в случае с &lt;code&gt;Dict&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; и &lt;code&gt;BitSet&lt;/code&gt; . Для более чем нескольких вызовов используйте вместо этого &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; или, при необходимости, &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; или &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="311dcfe3310c4c1e71b8fdd71e07a972ef0dc132" translate="yes" xml:space="preserve">
          <source>The components of tuples can optionally be named, in which case a &lt;em&gt;named tuple&lt;/em&gt; is constructed:</source>
          <target state="translated">Компоненты кортежей могут быть при желании названы, и в этом случае создается &lt;em&gt;именованный кортеж&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="3e9339bf8ddc8517e7daf0c8e7c807dbe19f1e27" translate="yes" xml:space="preserve">
          <source>The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.</source>
          <target state="translated">Сжатое хранилище разреженных колонок позволяет легко и быстро получить доступ к элементам в колонке разреженной матрицы,в то время как доступ к разреженной матрице по строкам значительно медленнее.Такие операции,как вставка ранее незакрепленных записей по одному в структуру CSC,как правило,выполняются медленно.Это происходит потому,что все элементы разреженной матрицы,находящиеся за пределами точки вставки,должны быть перемещены на одно место.</target>
        </trans-unit>
        <trans-unit id="8b1889cfa906d5de7f417dbba5d8a75294042a14" translate="yes" xml:space="preserve">
          <source>The concatenation functions are used so often that they have special syntax:</source>
          <target state="translated">Функции конкатенирования используются настолько часто,что имеют специальный синтаксис:</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">Константа Пи.</target>
        </trans-unit>
        <trans-unit id="cdd946b3bbe64931ddb3bd5e7f32f9d59fbf8fe0" translate="yes" xml:space="preserve">
          <source>The constant ℯ.</source>
          <target state="translated">Константа ℯ.</target>
        </trans-unit>
        <trans-unit id="9cefd93a0c7128d9cee7f50ca451b5a8198bc929" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; allows us to construct references to channels holding more than one value of a specific type. &lt;code&gt;f&lt;/code&gt; is a function executed on &lt;code&gt;pid&lt;/code&gt; and it must return an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">Конструктор &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; позволяет нам создавать ссылки на каналы, содержащие более одного значения определенного типа. &lt;code&gt;f&lt;/code&gt; - это функция, выполняемая на &lt;code&gt;pid&lt;/code&gt; , и она должна возвращать &lt;code&gt;AbstractChannel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76232e9ec80692ffa1332b97fa1e6fc3973cc15d" translate="yes" xml:space="preserve">
          <source>The constructor for a shared array is of the form:</source>
          <target state="translated">Конструктор для разделяемого массива имеет форму:</target>
        </trans-unit>
        <trans-unit id="821d6810ac6b95dcd6b7cb3ce13745f711f223d5" translate="yes" xml:space="preserve">
          <source>The constructs introducing scope blocks are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f297e05974522f0c6701c3e5abf5ccf2ee32ab" translate="yes" xml:space="preserve">
          <source>The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;item two&lt;/code&gt;.</source>
          <target state="translated">Содержимое каждого элемента в списке должно совпадать с первой строкой элемента. В приведенном выше примере изолированный блок кода должен иметь отступ в четыре пробела для выравнивания с &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;item two&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a711e2ee96d05b52332ef79c64c2aa17ad5865e1" translate="yes" xml:space="preserve">
          <source>The cookie may be passed to the workers at startup via argument &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt;. If argument &lt;code&gt;--worker&lt;/code&gt; is specified without the cookie, the worker tries to read the cookie from its standard input (&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;stdin&lt;/code&gt; is closed immediately after the cookie is retrieved.</source>
          <target state="translated">Куки могут быть переданы рабочим при запуске через аргумент &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt; . Если аргумент &lt;code&gt;--worker&lt;/code&gt; указан без cookie, воркер пытается прочитать cookie со стандартного ввода ( &lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; ). Стандартный &lt;code&gt;stdin&lt;/code&gt; закрывается сразу после получения файла cookie.</target>
        </trans-unit>
        <trans-unit id="964f5d9426cfdc6c758d47e988ded861b6315851" translate="yes" xml:space="preserve">
          <source>The core language imposes very little; Julia Base and the standard library are written in Julia itself, including primitive operations like integer arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870af6ba603446abce307b3e8bfd11194f33f900" translate="yes" xml:space="preserve">
          <source>The core language imposes very little; Julia Base and the standard library is written in Julia itself, including primitive operations like integer arithmetic</source>
          <target state="translated">Основной язык накладывает очень мало;База Julia и стандартная библиотека написаны на самом языке Julia,включая примитивные операции,такие как целочисленная арифметика</target>
        </trans-unit>
        <trans-unit id="3bc4ff368fbfc76c3ff3eaa70599d7710f608522" translate="yes" xml:space="preserve">
          <source>The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling &lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt;&lt;code&gt;Logging.min_enabled_level&lt;/code&gt;&lt;/a&gt;. This behavior can be overridden via environment variables (more on this later).</source>
          <target state="translated">Просматривается текущее состояние регистратора, и уровень сообщений проверяется на соответствие минимальному уровню кэширования регистратора, который определяется путем вызова &lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt; &lt;code&gt;Logging.min_enabled_level&lt;/code&gt; &lt;/a&gt; . Это поведение можно переопределить с помощью переменных среды (подробнее об этом позже).</target>
        </trans-unit>
        <trans-unit id="0146df473ce231b1bd3f1a030488e3df426f1fa7" translate="yes" xml:space="preserve">
          <source>The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling &lt;a href=&quot;#Logging.min_enabled_level&quot;&gt;&lt;code&gt;Logging.min_enabled_level&lt;/code&gt;&lt;/a&gt;. This behavior can be overridden via environment variables (more on this later).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7f546fa478be5baf73e1d9a88ce7b4f22fd7b5" translate="yes" xml:space="preserve">
          <source>The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too.</source>
          <target state="translated">Текущая версия Julia мультиплексирует все задачи в одном потоке ОС.Таким образом,в то время как задачи,связанные с операциями ввода/вывода,выигрывают от параллельного выполнения,вычислительные связанные задачи эффективно выполняются последовательно в одном потоке ОС.Будущие версии Julia могут поддерживать планирование задач в нескольких потоках,и в этом случае вычисление связанных задач также выиграет от параллельного выполнения.</target>
        </trans-unit>
        <trans-unit id="76aeeb5da0056ec0aaaca0d1c584f7796e1043fc" translate="yes" xml:space="preserve">
          <source>The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</source>
          <target state="translated">Опасности злоупотребления многократной отправкой (так же известные как,больше по типам со значениями по параметрам)</target>
        </trans-unit>
        <trans-unit id="61e6dec9a93ab50439a3df7d4ed79515ae264595" translate="yes" xml:space="preserve">
          <source>The day of month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">День месяца &lt;code&gt;Date&lt;/code&gt; или &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="299252ee9be4ede7afdc82ba83cfa67ed6efb411" translate="yes" xml:space="preserve">
          <source>The declared types of all fields in a composite DataType &lt;code&gt;T&lt;/code&gt; as a tuple.</source>
          <target state="translated">Объявленные типы всех полей в составном DataType &lt;code&gt;T&lt;/code&gt; в виде кортежа.</target>
        </trans-unit>
        <trans-unit id="2ef7bb84da109de096d6179f580e39fcc330d135" translate="yes" xml:space="preserve">
          <source>The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and lines containing only spaces or tabs (the line containing the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is always included). Then for all lines, excluding the text following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, the common starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence), e.g.:</source>
          <target state="translated">Уровень детентирования определяется как самая длинная общая начальная последовательность пробелов или табуляции во всех строках, за исключением строки, следующей за открывающим &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; и строк, содержащих только пробелы или табуляции ( всегда включается строка, содержащая закрывающий &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ). Затем для всех строк, за исключением текста, следующего за открытием &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; , общая начальная последовательность удаляется (включая строки, содержащие только пробелы и табуляции, если они начинаются с этой последовательности), например:</target>
        </trans-unit>
        <trans-unit id="2356f962c8d3ff60eecc6a182ea052ea39664b67" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">По умолчанию &lt;code&gt;pid&lt;/code&gt; - это текущий процесс.</target>
        </trans-unit>
        <trans-unit id="60227207bf9b873d43f880cb82175cc1c4120101" translate="yes" xml:space="preserve">
          <source>The default MIME type is &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt;. There is a fallback definition for &lt;code&gt;text/plain&lt;/code&gt; output that calls &lt;code&gt;show&lt;/code&gt; with 2 arguments, so it is not always necessary to add a method for that case. If a type benefits from custom human-readable output though, &lt;code&gt;show(::IO, ::MIME&quot;text/plain&quot;, ::T)&lt;/code&gt; should be defined. For example, the &lt;code&gt;Day&lt;/code&gt; type uses &lt;code&gt;1 day&lt;/code&gt; as the output for the &lt;code&gt;text/plain&lt;/code&gt; MIME type, and &lt;code&gt;Day(1)&lt;/code&gt; as the output of 2-argument &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fb2cffe54cc4ab8a1dd2c832ae7310589c0943" translate="yes" xml:space="preserve">
          <source>The default MIME type is &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt;. There is a fallback definition for &lt;code&gt;text/plain&lt;/code&gt; output that calls &lt;code&gt;show&lt;/code&gt; with 2 arguments. Therefore, this case should be handled by defining a 2-argument &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; method.</source>
          <target state="translated">Тип MIME по умолчанию - &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt; . Существует резервное определение для &lt;code&gt;text/plain&lt;/code&gt; вывода, которое вызывает &lt;code&gt;show&lt;/code&gt; с двумя аргументами. Следовательно, этот случай должен быть обработан путем определения метода &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; с двумя аргументами .</target>
        </trans-unit>
        <trans-unit id="e57baa92c6f6a7e34ff4590072c999e03c2e6a26" translate="yes" xml:space="preserve">
          <source>The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously &quot;untyped&quot; code. Adding annotations serves three primary purposes: to take advantage of Julia's powerful multiple-dispatch mechanism, to improve human readability, and to catch programmer errors.</source>
          <target state="translated">Поведение по умолчанию в Julia,когда опускаются типы,заключается в том,чтобы позволить значениям быть любого типа.Таким образом,можно написать много полезных функций Julia,никогда явно не используя типы.Однако,когда требуется дополнительная выразительность,легко постепенно ввести явные аннотации типов в ранее &quot;не типизированный&quot; код.Добавление аннотаций служит трем основным целям:воспользоваться мощным механизмом многодисковой рассылки Julia,улучшить читабельность и отловить ошибки программиста.</target>
        </trans-unit>
        <trans-unit id="d1df4775c1a0c6149628da164ef2c2add2aea3bd" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove leading whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; пробелы и разделители: подробности см. В isspace .</target>
        </trans-unit>
        <trans-unit id="1c11c76e6a974f0248876da7137e97c01ffa7caf" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove trailing whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">По умолчанию удаляются завершающие пробелы и разделители: подробности см. В &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b48a4ab8a2d4ed833b136d5a3a24148da74e18" translate="yes" xml:space="preserve">
          <source>The default constructor &lt;code&gt;Channel()&lt;/code&gt; and default &lt;code&gt;size=0&lt;/code&gt; were added in Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855bff164720a2c745d8e506987fbf1482013980" translate="yes" xml:space="preserve">
          <source>The default implementation (which uses TCP/IP sockets) is implemented as &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt;.</source>
          <target state="translated">Реализация по умолчанию (которая использует сокеты TCP / IP) реализована как &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7fa17aefadd075c2be825658630ae2cf9c235" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;isequal&lt;/code&gt; calls &lt;code&gt;==&lt;/code&gt;, so a type that does not involve floating-point values generally only needs to define &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;isequal&lt;/code&gt; по умолчанию вызывает &lt;code&gt;==&lt;/code&gt; , поэтому для типа, не использующего значения с плавающей запятой, обычно требуется только определить &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48bcbdbff411080a8ce1e0c1f60de9f518c30398" translate="yes" xml:space="preserve">
          <source>The default implementations of the above (on a &lt;code&gt;AbstractWorkerPool&lt;/code&gt;) require fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40594727e32e7ffa62fc7c197ea4f5e0449e9039" translate="yes" xml:space="preserve">
          <source>The default implementations of the above (on a &lt;code&gt;AbstractWorkerPool&lt;/code&gt;) require fields channel::Channel{Int} workers::Set{Int} where &lt;code&gt;channel&lt;/code&gt; contains free worker pids and &lt;code&gt;workers&lt;/code&gt; is the set of all workers associated with this pool.</source>
          <target state="translated">Реализации по умолчанию выше (на &lt;code&gt;AbstractWorkerPool&lt;/code&gt; ) требуют поля канал :: Channel {Int} рабочих :: Set {Int} , где &lt;code&gt;channel&lt;/code&gt; содержит свободные рабочий ИДП и &lt;code&gt;workers&lt;/code&gt; это совокупность всех работников , связанных с этим бассейном.</target>
        </trans-unit>
        <trans-unit id="90d0098a5b9857be430bc6bdbd24d7771a71aa03" translate="yes" xml:space="preserve">
          <source>The default is &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию используется &lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="939929b76e159e18d5e7761850ea7b359afa492d" translate="yes" xml:space="preserve">
          <source>The default mode used is always &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</source>
          <target state="translated">По умолчанию всегда используется режим &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt; , который округляется до ближайшего представимого значения, а связи округляются в сторону ближайшего значения с даже младшим значащим битом.</target>
        </trans-unit>
        <trans-unit id="bb41fa3202534d6677ac2f342e3bce0fdc60f379" translate="yes" xml:space="preserve">
          <source>The default precision (in number of bits of the significand) and rounding mode of &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; operations can be changed globally by calling &lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt;&lt;code&gt;setprecision&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;setrounding&lt;/code&gt;, and all further calculations will take these changes in account. Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a &lt;code&gt;do&lt;/code&gt; block:</source>
          <target state="translated">Точность по умолчанию (в количестве бит значимости) и режим округления для операций &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; можно изменить глобально, вызвав &lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt; &lt;code&gt;setprecision&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;setrounding&lt;/code&gt; , и все дальнейшие вычисления будут учитывать эти изменения. В качестве альтернативы точность или округление можно изменить только в рамках выполнения определенного блока кода, используя те же функции с блоком &lt;code&gt;do&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf260c790afbd5fd76456a214c3da2bfee6f596b" translate="yes" xml:space="preserve">
          <source>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</source>
          <target state="translated">Режим округления по умолчанию.Округление до ближайшего целого,при этом связи (дробные значения 0.5)округляются до ближайшего четного числа.</target>
        </trans-unit>
        <trans-unit id="cd46d911f48a459503193b1169b7d8853a54b000" translate="yes" xml:space="preserve">
          <source>The default schedule (used when no &lt;code&gt;schedule&lt;/code&gt; argument is present) is subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d023ed2ec488f600d82c5f04099bb7053c6343" translate="yes" xml:space="preserve">
          <source>The default sorting algorithms are chosen on the basis that they are fast and stable, or &lt;em&gt;appear&lt;/em&gt; to be so. For numeric types indeed, &lt;code&gt;QuickSort&lt;/code&gt; is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred algorithm, e.g. &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt;.</source>
          <target state="translated">Алгоритмы сортировки по умолчанию выбираются на том основании, что они быстрые и стабильные или &lt;em&gt;кажутся&lt;/em&gt; таковыми. Действительно, для числовых типов выбирается &lt;code&gt;QuickSort&lt;/code&gt; , поскольку в этом случае он быстрее и неотличим от стабильной сортировки (если только массив каким-либо образом не записывает свои мутации). За свойство стабильности можно пренебречь, поэтому, если оно вам не нужно, вы можете явно указать предпочтительный алгоритм, например &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e4b294c96581c70e29314614e72dd9c556dd867" translate="yes" xml:space="preserve">
          <source>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</source>
          <target state="translated">Тип по умолчанию для целочисленного литерала зависит от того,имеет ли целевая система 32-битную или 64-битную архитектуру:</target>
        </trans-unit>
        <trans-unit id="0025d7cf20de7d8585d610cdb20c478776196150" translate="yes" xml:space="preserve">
          <source>The default value (for iterators that do not define this function) is &lt;code&gt;HasLength()&lt;/code&gt;. This means that most iterators are assumed to implement &lt;a href=&quot;#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Значение по умолчанию (для итераторов, которые не определяют эту функцию) - &lt;code&gt;HasLength()&lt;/code&gt; . Это означает, что предполагается, что большинство итераторов реализуют &lt;a href=&quot;#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed1fec164addf150bd6fc4ed074c8bde6086195e" translate="yes" xml:space="preserve">
          <source>The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.</source>
          <target state="translated">По умолчанию,когда ключевые слова не передаются,файлы открываются только для чтения.Возвращает поток для доступа к открытому файлу.</target>
        </trans-unit>
        <trans-unit id="46ad04b79597833ac2971450ca4faf1a5ac755c0" translate="yes" xml:space="preserve">
          <source>The definitive guide to floating point arithmetic is the &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;IEEE 754-2008 Standard&lt;/a&gt;; however, it is not available for free online.</source>
          <target state="translated">Окончательное руководство по арифметике с плавающей запятой - это &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;стандарт IEEE 754-2008&lt;/a&gt; ; однако он не доступен бесплатно в Интернете.</target>
        </trans-unit>
        <trans-unit id="c7a1e185817162d29c3ca02c640a39cf90726456" translate="yes" xml:space="preserve">
          <source>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</source>
          <target state="translated">Строка описания принимает интерполяцию из индексов цикла.Если описание не предоставляется,оно строится на основе переменных.</target>
        </trans-unit>
        <trans-unit id="b9783bd3f57cabbb7dcb6efff07a6fb2ce7cf2be" translate="yes" xml:space="preserve">
          <source>The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. &lt;code&gt;(x, y)&lt;/code&gt;) instead of just a symbol, then an assignment &lt;code&gt;(x, y) = argument&lt;/code&gt; will be inserted for you:</source>
          <target state="translated">Функция деструктуризации также может использоваться в аргументе функции. Если имя аргумента функции записано как кортеж (например, &lt;code&gt;(x, y)&lt;/code&gt; ), а не просто символ, тогда для вас будет вставлен &lt;code&gt;(x, y) = argument&lt;/code&gt; присваивания (x, y) = :</target>
        </trans-unit>
        <trans-unit id="dca7fd4aaff137c3b5ad312f731763865f2c4777" translate="yes" xml:space="preserve">
          <source>The diagonal of the matrix &lt;code&gt;X&lt;/code&gt; is assumed to be all ones.</source>
          <target state="translated">Диагональ матрицы &lt;code&gt;X&lt;/code&gt; предполагается равной единице.</target>
        </trans-unit>
        <trans-unit id="65475d5b108ff8d6ff4d0b451b5957edd3247c0c" translate="yes" xml:space="preserve">
          <source>The diagonal values of the matrix &lt;code&gt;X&lt;/code&gt; will be read.</source>
          <target state="translated">Будут считаны значения диагонали матрицы &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35294cd283107f3ea2ad299c610959761013b001" translate="yes" xml:space="preserve">
          <source>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator &lt;code&gt;p&lt;/code&gt;-norm of a &lt;code&gt;1 &amp;times; n&lt;/code&gt; matrix.</source>
          <target state="translated">Разница в норме между векторным пространством и двойственным ему возникает, чтобы сохранить связь между двойственностью и скалярным произведением, и результат согласуется с оператором &lt;code&gt;p&lt;/code&gt; -нормой матрицы &lt;code&gt;1 &amp;times; n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe30caaca3ec896d42d37e2680c6fbcc22f3fc58" translate="yes" xml:space="preserve">
          <source>The difference seems trivial, but in fact is quite significant due to the behavior of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</source>
          <target state="translated">Разница кажется тривиальной, но на самом деле довольно существенная из-за поведения &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; . В первом методе случайная матрица создается локально, затем отправляется другому процессу, где она возводится в квадрат. Во втором методе случайная матрица строится и возводится в квадрат для другого процесса. Следовательно, второй метод отправляет гораздо меньше данных, чем первый.</target>
        </trans-unit>
        <trans-unit id="eb05e878344722c287b20da3054e1a3329545a60" translate="yes" xml:space="preserve">
          <source>The difference seems trivial, but in fact is quite significant due to the behavior of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515d7afeaf87e8c8538070fa94ff623cdced8f10" translate="yes" xml:space="preserve">
          <source>The different prompt modes</source>
          <target state="translated">Различные режимы запроса</target>
        </trans-unit>
        <trans-unit id="cf7712c8e857525e49eb6c6feac8d5fe578af7a4" translate="yes" xml:space="preserve">
          <source>The discussion in the preceding paragraph referred to the &quot;parser&quot;, that is, the phase of compilation that takes place when the module containing &lt;code&gt;abmult&lt;/code&gt; is first loaded, as opposed to the later phase when it is first invoked. The parser does not &quot;know&quot; that &lt;code&gt;Int&lt;/code&gt; is a fixed type, or that the statement &lt;code&gt;r = -r&lt;/code&gt; transforms an &lt;code&gt;Int&lt;/code&gt; to another &lt;code&gt;Int&lt;/code&gt;. The magic of type inference takes place in the later phase of compilation.</source>
          <target state="translated">Обсуждение в предыдущем абзаце относилось к &amp;laquo;синтаксическому анализатору&amp;raquo;, то есть к фазе компиляции, которая имеет место при первой загрузке модуля, содержащего &lt;code&gt;abmult&lt;/code&gt; , в отличие от более поздней фазы, когда он впервые вызывается. Синтаксический анализатор не &amp;laquo;знает&amp;raquo;, что &lt;code&gt;Int&lt;/code&gt; является фиксированным типом или что инструкция &lt;code&gt;r = -r&lt;/code&gt; преобразует &lt;code&gt;Int&lt;/code&gt; в другой &lt;code&gt;Int&lt;/code&gt; . Магия вывода типов происходит на более поздней стадии компиляции.</target>
        </trans-unit>
        <trans-unit id="228846c17a2f8eda9af9e04280c4e7e004d8ecbb" translate="yes" xml:space="preserve">
          <source>The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.</source>
          <target state="translated">Обсуждение продвижения на основе признаков обеспечивает переход к следующему шаблону проектирования:вычисление типа выходного элемента для матричной операции.</target>
        </trans-unit>
        <trans-unit id="c9eeea461d08f16f6e9e3e76a2854c7413f10de0" translate="yes" xml:space="preserve">
          <source>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, &lt;code&gt;eps(1.0)&lt;/code&gt; is the same as &lt;code&gt;eps(Float64)&lt;/code&gt; since &lt;code&gt;1.0&lt;/code&gt; is a 64-bit floating-point value.</source>
          <target state="translated">Расстояние между двумя соседними представляемыми числами с плавающей запятой не является постоянным, но меньше для меньших значений и больше для больших значений. Другими словами, представимые числа с плавающей запятой являются наиболее плотными в строке действительных чисел около нуля и становятся более разреженными по мере удаления от нуля. По определению &lt;code&gt;eps(1.0)&lt;/code&gt; это то же самое, что &lt;code&gt;eps(Float64)&lt;/code&gt; поскольку &lt;code&gt;1.0&lt;/code&gt; - это 64-битное значение с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="17711720acdfc250d4da5bdf1c59e4156516b762" translate="yes" xml:space="preserve">
          <source>The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in local versus global scopes for variable assignments. Consider the modification of the last example by moving &lt;code&gt;bar&lt;/code&gt; to the global scope:</source>
          <target state="translated">Различие между наследованием глобальной области видимости и вложенной локальной областью видимости может привести к некоторым незначительным различиям между функциями, определенными в локальной и глобальной областях для назначения переменных. Рассмотрим модификацию последнего примера, переместив &lt;code&gt;bar&lt;/code&gt; в глобальную область видимости:</target>
        </trans-unit>
        <trans-unit id="bcbd86bd1c455f650a19858504ec03684521d39b" translate="yes" xml:space="preserve">
          <source>The documentation is also available in PDF format: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt;.</source>
          <target state="translated">Документация также доступна в формате PDF: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adc54fa69d8c5b645a51e5f0c26507e3e5712011" translate="yes" xml:space="preserve">
          <source>The documentation is also available in PDF format: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.5.3.pdf&quot;&gt;julia-1.5.3.pdf&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c976d9d02fc2e4f087f2db86ac987d2cebacc0" translate="yes" xml:space="preserve">
          <source>The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-eval-print loop or &quot;REPL&quot;) by double-clicking the Julia executable or running &lt;code&gt;julia&lt;/code&gt; from the command line:</source>
          <target state="translated">Самый простой способ изучить и поэкспериментировать с Julia - запустить интерактивный сеанс (также известный как цикл чтения-оценки-печати или REPL), дважды щелкнув исполняемый файл Julia или запустив &lt;code&gt;julia&lt;/code&gt; из командной строки:</target>
        </trans-unit>
        <trans-unit id="2182ffaca8a0c2d19e2f394d632b220a4bda55b5" translate="yes" xml:space="preserve">
          <source>The easiest way to understand this behavior is to see an example. In the previous example, the &lt;code&gt;println&lt;/code&gt; call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let's try a two-way version first:</source>
          <target state="translated">Самый простой способ понять это поведение - посмотреть на примере. В предыдущем примере вызов &lt;code&gt;println&lt;/code&gt; используется всеми тремя ветвями: единственный реальный выбор - это буквальная строка для печати. Это можно было бы записать более кратко, используя тернарный оператор. Для ясности давайте сначала попробуем двустороннюю версию:</target>
        </trans-unit>
        <trans-unit id="56dd1399973b5466f5b438f54aa5084eb3d4b3fd" translate="yes" xml:space="preserve">
          <source>The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">Редактор можно изменить, установив &lt;code&gt;JULIA_EDITOR&lt;/code&gt; , &lt;code&gt;VISUAL&lt;/code&gt; или &lt;code&gt;EDITOR&lt;/code&gt; в качестве переменной среды.</target>
        </trans-unit>
        <trans-unit id="8d60f89821e0be17d3c10fd641e166470b0fae98" translate="yes" xml:space="preserve">
          <source>The editor returned by &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; and used in, e.g., &lt;code&gt;InteractiveUtils.edit&lt;/code&gt;, referring to the command of the preferred editor, for instance &lt;code&gt;vim&lt;/code&gt;.</source>
          <target state="translated">Редактор, возвращаемый &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; и используемый, например, в &lt;code&gt;InteractiveUtils.edit&lt;/code&gt; , ссылаясь на команду предпочтительного редактора, например &lt;code&gt;vim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f31493a5d545803d2bc443ac0f38b3d641d141b" translate="yes" xml:space="preserve">
          <source>The efficiency gained by being able to store &lt;code&gt;Point{Float64}&lt;/code&gt; objects with immediate values is magnified enormously in the case of arrays: an &lt;code&gt;Array{Float64}&lt;/code&gt; can be stored as a contiguous memory block of 64-bit floating-point values, whereas an &lt;code&gt;Array{Real}&lt;/code&gt; must be an array of pointers to individually allocated &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; objects &amp;ndash; which may well be &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;boxed&lt;/a&gt; 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the &lt;code&gt;Real&lt;/code&gt; abstract type.</source>
          <target state="translated">Эффективность, полученная за счет возможности хранить объекты &lt;code&gt;Point{Float64}&lt;/code&gt; с немедленными значениями, значительно возрастает в случае массивов: &lt;code&gt;Array{Float64}&lt;/code&gt; может храниться как непрерывный блок памяти из 64-битных значений с плавающей запятой, тогда как &lt;code&gt;Array{Real}&lt;/code&gt; должен быть массивом указателей на индивидуально выделенные объекты &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; - которые вполне могут быть &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;упакованными в коробку&lt;/a&gt; 64-битными значениями с плавающей запятой, но также могут быть произвольно большими сложными объектами, которые объявляются реализациями абстрактного типа &lt;code&gt;Real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77656128da3c3e27758883f72427b834f3cb4b6e" translate="yes" xml:space="preserve">
          <source>The eigenvalues are returned in &lt;code&gt;W&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">Собственные возвращаются в &lt;code&gt;W&lt;/code&gt; и собственных векторов в &lt;code&gt;Z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="709d89b2d19663c267d1c6a4862d61316a231e84" translate="yes" xml:space="preserve">
          <source>The element type of the result is chosen using promotion (see &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;) based on the element type of &lt;code&gt;A&lt;/code&gt; and on the types of the &lt;code&gt;new&lt;/code&gt; values in pairs. If &lt;code&gt;count&lt;/code&gt; is omitted and the element type of &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Union&lt;/code&gt;, the element type of the result will not include singleton types which are replaced with values of a different type: for example, &lt;code&gt;Union{T,Missing}&lt;/code&gt; will become &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;missing&lt;/code&gt; is replaced.</source>
          <target state="translated">Тип элемента результата выбирается с помощью продвижения (см. &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; ) на основе типа элемента &lt;code&gt;A&lt;/code&gt; и типов &lt;code&gt;new&lt;/code&gt; значений в парах. Если &lt;code&gt;count&lt;/code&gt; опущен и типа элемента &lt;code&gt;A&lt;/code&gt; является &lt;code&gt;Union&lt;/code&gt; , типа элемента результата не будет включать одноэлементные типы , которые заменяются значениями другого типа, например, &lt;code&gt;Union{T,Missing}&lt;/code&gt; будет &lt;code&gt;T&lt;/code&gt; , если &lt;code&gt;missing&lt;/code&gt; является заменены.</target>
        </trans-unit>
        <trans-unit id="14b4f332ac46b505bad4228677357909dd03b266" translate="yes" xml:space="preserve">
          <source>The element type of the tuple must be an instance of &lt;code&gt;VecElement{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a primitive type that is 1, 2, 4 or 8 bytes.</source>
          <target state="translated">Тип элемента кортежа должен быть экземпляром &lt;code&gt;VecElement{T}&lt;/code&gt; где &lt;code&gt;T&lt;/code&gt; - это примитивный тип размером 1, 2, 4 или 8 байтов.</target>
        </trans-unit>
        <trans-unit id="c9296fda074d952d1c87394f1441913d330aa413" translate="yes" xml:space="preserve">
          <source>The empty (or &quot;bottom&quot;) type, written as &lt;code&gt;Union{}&lt;/code&gt; (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.</source>
          <target state="translated">Пустой (или &amp;laquo;нижний&amp;raquo;) тип, записанный как &lt;code&gt;Union{}&lt;/code&gt; (пустой тип объединения), является типом без значений и подтипов (кроме самого себя). Обычно вам не нужно использовать этот тип.</target>
        </trans-unit>
        <trans-unit id="3534ea1366da3151258e1f770bb393a26a8c9156" translate="yes" xml:space="preserve">
          <source>The empty tuple (&lt;code&gt;()&lt;/code&gt;) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.</source>
          <target state="translated">Пустой кортеж ( &lt;code&gt;()&lt;/code&gt; ) - еще одна форма небытия. Но на самом деле его не следует рассматривать как ничто иное, как набор нулевых значений.</target>
        </trans-unit>
        <trans-unit id="f2bd3a290bc2b2f98102d89ff212080bf2528200" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">В качестве разделителя конца строки принимается &lt;code&gt;\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13d242b1b1e933d4ec26a29014e675d01b5c3b93" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">В качестве разделителя конца строки принимается &lt;code&gt;\n&lt;/code&gt; . Если все данные числовые, результатом будет числовой массив. Если некоторые элементы не могут быть проанализированы как числа, возвращается неоднородный массив чисел и строк.</target>
        </trans-unit>
        <trans-unit id="646c7a5bc743f5d4a67f86e4404a7cfd381dff26" translate="yes" xml:space="preserve">
          <source>The endianness of the written value depends on the endianness of the host system. Convert to/from a fixed endianness when writing/reading (e.g. using &lt;a href=&quot;#Base.htol&quot;&gt;&lt;code&gt;htol&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.ltoh&quot;&gt;&lt;code&gt;ltoh&lt;/code&gt;&lt;/a&gt;) to get results that are consistent across platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c21a922512e76aea89910e75ca40814c713417b" translate="yes" xml:space="preserve">
          <source>The entries of &lt;code&gt;F.D1&lt;/code&gt; and &lt;code&gt;F.D2&lt;/code&gt; are related, as explained in the LAPACK documentation for the &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;generalized SVD&lt;/a&gt; and the &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt; routine which is called underneath (in LAPACK 3.6.0 and newer).</source>
          <target state="translated">Записи &lt;code&gt;F.D1&lt;/code&gt; и &lt;code&gt;F.D2&lt;/code&gt; связаны, как объяснено в документации LAPACK для &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;обобщенного SVD&lt;/a&gt; и подпрограммы &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3,&lt;/a&gt; которая вызывается ниже (в LAPACK 3.6.0 и новее).</target>
        </trans-unit>
        <trans-unit id="3ee9b3b4fb75bbbf3de3deed96398c0ab2d5522c" translate="yes" xml:space="preserve">
          <source>The environment variables that Julia uses generally start with &lt;code&gt;JULIA&lt;/code&gt;. If &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt;&lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt;&lt;/a&gt; is called with the keyword &lt;code&gt;verbose=true&lt;/code&gt;, then the output will list any defined environment variables relevant for Julia, including those which include &lt;code&gt;JULIA&lt;/code&gt; in their names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6e8a6592578860941072596b3389f0e39bd834" translate="yes" xml:space="preserve">
          <source>The environment variables that Julia uses generally start with &lt;code&gt;JULIA&lt;/code&gt;. If &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt;&lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt;&lt;/a&gt; is called with the keyword &lt;code&gt;verbose=true&lt;/code&gt;, then the output will list defined environment variables relevant for Julia, including those for which &lt;code&gt;JULIA&lt;/code&gt; appears in the name.</source>
          <target state="translated">Переменные среды, которые использует Джулия, обычно начинаются с &lt;code&gt;JULIA&lt;/code&gt; . Если &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt; &lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt; &lt;/a&gt; вызывается с ключевым словом &lt;code&gt;verbose=true&lt;/code&gt; , то вывод будет перечислять определенные переменные среды, относящиеся к Julia, включая те, для которых &lt;code&gt;JULIA&lt;/code&gt; фигурирует в имени.</target>
        </trans-unit>
        <trans-unit id="2e01139cb5620c6fbb793874bc029ba48692801b" translate="yes" xml:space="preserve">
          <source>The equivalent of an &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML tag can be achieved using three hyphens (&lt;code&gt;---&lt;/code&gt;). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ebc4dca8e995a281e980c9657b899d8cf0df29e" translate="yes" xml:space="preserve">
          <source>The equivalent of an &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML tag can be written using the following syntax:</source>
          <target state="translated">Эквивалент HTML-тега &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; можно записать с использованием следующего синтаксиса:</target>
        </trans-unit>
        <trans-unit id="74efd542b7345e98fdaed051a7a6183a8d020db5" translate="yes" xml:space="preserve">
          <source>The example generated function &lt;code&gt;foo&lt;/code&gt; above did not do anything a normal function &lt;code&gt;foo(x) = x * x&lt;/code&gt; could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:</source>
          <target state="translated">Пример сгенерированной функции &lt;code&gt;foo&lt;/code&gt; выше не сделал ничего, что не могла сделать обычная функция &lt;code&gt;foo(x) = x * x&lt;/code&gt; (кроме печати типа при первом вызове и увеличения накладных расходов). Однако сила сгенерированной функции заключается в ее способности вычислять различные цитируемые выражения в зависимости от переданных ей типов:</target>
        </trans-unit>
        <trans-unit id="4cb49bdc57a779962ff666ac722912890cdcf08f" translate="yes" xml:space="preserve">
          <source>The example in the previous section glossed over the implementation details of &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt;, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of &lt;code&gt;map&lt;/code&gt;, one important question is what order to use to traverse the data. When &lt;code&gt;AbstractArray&lt;/code&gt; subtypes implement the &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;Base.IndexStyle&lt;/code&gt;&lt;/a&gt; trait, other functions such as &lt;code&gt;map&lt;/code&gt; can dispatch on this information to pick the best algorithm (see &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;Abstract Array Interface&lt;/a&gt;). This means that each subtype does not need to implement a custom version of &lt;code&gt;map&lt;/code&gt;, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of &lt;code&gt;map&lt;/code&gt; illustrating the trait-based dispatch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e119c6a2d56d3760f8ebb0ae8619e173f79b4b25" translate="yes" xml:space="preserve">
          <source>The example in the previous section glossed over the implementation details of &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt;, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of &lt;code&gt;map&lt;/code&gt;, one important question is what order to use to traverse the data. When &lt;code&gt;AbstractArray&lt;/code&gt; subtypes implement the &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;Base.IndexStyle&lt;/code&gt;&lt;/a&gt; trait, other functions such as &lt;code&gt;map&lt;/code&gt; can dispatch on this information to pick the best algorithm (see &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Abstract Array Interface&lt;/a&gt;). This means that each subtype does not need to implement a custom version of &lt;code&gt;map&lt;/code&gt;, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of &lt;code&gt;map&lt;/code&gt; illustrating the trait-based dispatch:</source>
          <target state="translated">В примере, приведенном в предыдущем разделе, не были затронуты детали реализации &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt; , которые оба оперируют этими чертами. При итерации по матрице, например, при реализации &lt;code&gt;map&lt;/code&gt; , один важный вопрос - какой порядок использовать для обхода данных. Когда подтипы &lt;code&gt;AbstractArray&lt;/code&gt; реализуют черту &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;Base.IndexStyle&lt;/code&gt; &lt;/a&gt; , другие функции, такие как &lt;code&gt;map&lt;/code&gt; , могут отправлять эту информацию, чтобы выбрать лучший алгоритм (см. &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Интерфейс абстрактного массива&lt;/a&gt; ). Это означает, что каждому подтипу не требуется реализовывать собственную версию &lt;code&gt;map&lt;/code&gt; , поскольку общие определения + классы характеристик позволят системе выбрать самую быструю версию. Вот игрушечная реализация &lt;code&gt;map&lt;/code&gt; иллюстрирующая отправку на основе признаков:</target>
        </trans-unit>
        <trans-unit id="c4e7ac687a3c1938fcc96d92a705ce561c8d3bfd" translate="yes" xml:space="preserve">
          <source>The exception is that quotation marks still must be escaped, e.g. &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt;. To make it possible to express all strings, backslashes then also must be escaped, but only when appearing right before a quote character:</source>
          <target state="translated">Исключением является то, что кавычки по-прежнему должны быть экранированы, например, &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; эквивалентен &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; . Чтобы можно было выразить все строки, обратные косые черты также должны быть экранированы, но только если они появляются прямо перед символом кавычек:</target>
        </trans-unit>
        <trans-unit id="806a2c6eb838f5063922dc987163b721668d0145" translate="yes" xml:space="preserve">
          <source>The exception stack is stored on the &lt;code&gt;Task&lt;/code&gt; where the exceptions occurred. When a task fails with uncaught exceptions, &lt;code&gt;catch_stack(task)&lt;/code&gt; may be used to inspect the exception stack for that task.</source>
          <target state="translated">Стек исключений хранится в &lt;code&gt;Task&lt;/code&gt; которой возникли исключения. Когда задача завершается неудачно с неперехваченными исключениями, &lt;code&gt;catch_stack(task)&lt;/code&gt; может использоваться для проверки стека исключений для этой задачи.</target>
        </trans-unit>
        <trans-unit id="8f5394bfbaefac45354c9007a6d28e58fb286a9b" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928c8d0396de54cd800b9aede32ea561fba936f5" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="translated">Исключением из этого правила являются наименьшие и наибольшие конечные значения (например, &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; и &lt;code&gt;prevfloat(Inf)&lt;/code&gt; для &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ), которые округляются до меньшего из значений.</target>
        </trans-unit>
        <trans-unit id="116c955b734ab2654b5573c4e02330a021559f49" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def91518b0989f4a83def2144fe01cdce215a440" translate="yes" xml:space="preserve">
          <source>The executable itself is one of</source>
          <target state="translated">Сам исполняемый файл является одним из</target>
        </trans-unit>
        <trans-unit id="0db1c4486699e7de0f4ce2a483205ec8ce5f38db" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt;, before the &lt;code&gt;?&lt;/code&gt;, is a condition expression, and the ternary operation evaluates the expression &lt;code&gt;b&lt;/code&gt;, before the &lt;code&gt;:&lt;/code&gt;, if the condition &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or the expression &lt;code&gt;c&lt;/code&gt;, after the &lt;code&gt;:&lt;/code&gt;, if it is &lt;code&gt;false&lt;/code&gt;. Note that the spaces around &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; are mandatory: an expression like &lt;code&gt;a?b:c&lt;/code&gt; is not a valid ternary expression (but a newline is acceptable after both the &lt;code&gt;?&lt;/code&gt; and the &lt;code&gt;:&lt;/code&gt;).</source>
          <target state="translated">Выражение &lt;code&gt;a&lt;/code&gt; перед &lt;code&gt;?&lt;/code&gt; , Это выражение условия, и тернарная операция вычисляет выражение &lt;code&gt;b&lt;/code&gt; , до того , как &lt;code&gt;:&lt;/code&gt; , если условие является &lt;code&gt;true&lt;/code&gt; или выражение &lt;code&gt;c&lt;/code&gt; , после того , как &lt;code&gt;:&lt;/code&gt; , если оно &lt;code&gt;false&lt;/code&gt; . Обратите внимание, что пробелы вокруг &lt;code&gt;?&lt;/code&gt; и &lt;code&gt;:&lt;/code&gt; являются обязательными: выражение , как &lt;code&gt;a?b:c&lt;/code&gt; не является допустимым выражение тройного (но новая строка является приемлемой после того, как &lt;code&gt;?&lt;/code&gt; и &lt;code&gt;:&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="465bf593bbe53b12eb7783b96c9712a167cf8578" translate="yes" xml:space="preserve">
          <source>The expression passed to the &lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function could not be interpreted as a valid Julia expression.</source>
          <target state="translated">Выражение, переданное в функцию &lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; не могло быть интерпретировано как допустимое выражение Julia.</target>
        </trans-unit>
        <trans-unit id="a177c1288ef44211cc6e949df284aa83f006f7fc" translate="yes" xml:space="preserve">
          <source>The extension given by the constant &lt;code&gt;dlext&lt;/code&gt; (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt;, or &lt;code&gt;.dylib&lt;/code&gt;) can be omitted from the &lt;code&gt;libfile&lt;/code&gt; string, as it is automatically appended if needed. If &lt;code&gt;libfile&lt;/code&gt; is not an absolute path name, then the paths in the array &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; are searched for &lt;code&gt;libfile&lt;/code&gt;, followed by the system load path.</source>
          <target state="translated">Расширение, задаваемое константой &lt;code&gt;dlext&lt;/code&gt; ( &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.dll&lt;/code&gt; или &lt;code&gt;.dylib&lt;/code&gt; ), можно не указывать в строке &lt;code&gt;libfile&lt;/code&gt; , поскольку оно автоматически добавляется при необходимости. Если имя &lt;code&gt;libfile&lt;/code&gt; не является абсолютным путем, то пути в массиве &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; ищутся для &lt;code&gt;libfile&lt;/code&gt; , за которым следует путь загрузки системы.</target>
        </trans-unit>
        <trans-unit id="36c16e65be4afc2c66cb3288c6300982f05c7ad1" translate="yes" xml:space="preserve">
          <source>The fact that the type of &lt;code&gt;m.a&lt;/code&gt; is known from &lt;code&gt;m&lt;/code&gt;'s type&amp;mdash;coupled with the fact that its type cannot change mid-function&amp;mdash;allows the compiler to generate highly-optimized code for objects like &lt;code&gt;m&lt;/code&gt; but not for objects like &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Тот факт, что тип &lt;code&gt;m.a&lt;/code&gt; известен из типа &lt;code&gt;m&lt;/code&gt; - в сочетании с тем фактом, что его тип не может изменять среднюю функцию - позволяет компилятору генерировать высокооптимизированный код для таких объектов, как &lt;code&gt;m&lt;/code&gt; , но не для таких объектов, как &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c52690600fcbcb99da1f62c4bac2b9e5d6f697" translate="yes" xml:space="preserve">
          <source>The fallback definition is</source>
          <target state="translated">Определение отступления</target>
        </trans-unit>
        <trans-unit id="ee6beb39d94f4bf27bb085bd2200c292b19c5e9a" translate="yes" xml:space="preserve">
          <source>The fields represent:</source>
          <target state="translated">Поля представляют собой:</target>
        </trans-unit>
        <trans-unit id="c9020dd8336689ac7fec628824c2784dbf9a80fb" translate="yes" xml:space="preserve">
          <source>The file is passed via the stream argument, either as an open &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; or filename string. When you initialize the stream, use &lt;code&gt;&quot;r&quot;&lt;/code&gt; for a &quot;read-only&quot; array, and &lt;code&gt;&quot;w+&quot;&lt;/code&gt; to create a new array used to write values to disk.</source>
          <target state="translated">Файл передается через аргумент потока либо в виде открытого &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; , либо в виде строки имени файла. Когда вы инициализируете поток, используйте &lt;code&gt;&quot;r&quot;&lt;/code&gt; для массива &amp;laquo;только для чтения&amp;raquo; и &lt;code&gt;&quot;w+&quot;&lt;/code&gt; для создания нового массива, используемого для записи значений на диск.</target>
        </trans-unit>
        <trans-unit id="689e05efadfddad191a25330c014009d3e84b447" translate="yes" xml:space="preserve">
          <source>The file-system preferred block size for the file</source>
          <target state="translated">Предпочтительный размер блока файловой системы для файла</target>
        </trans-unit>
        <trans-unit id="c3038fc2cf1255c7ec1e11b0a18b74e94018430a" translate="yes" xml:space="preserve">
          <source>The final call to &lt;code&gt;qsort&lt;/code&gt; looks like this:</source>
          <target state="translated">Последний вызов &lt;code&gt;qsort&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="7d988c680830d3c098bed962d30d54cd701b74ad" translate="yes" xml:space="preserve">
          <source>The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</source>
          <target state="translated">Последняя проблема,которая до сих пор не решена,-это строительство объектов повышенной комфортности или,в более общем плане,рекурсивных структур данных.Поскольку фундаментальная трудность может быть не сразу очевидна,давайте кратко объясним ее.Рассмотрим следующее рекурсивное заявление типа:</target>
        </trans-unit>
        <trans-unit id="2c490723b997dd55f5ce00727bf52c98838be748" translate="yes" xml:space="preserve">
          <source>The first &quot;important&quot; line in this output is this one:</source>
          <target state="translated">Первая &quot;важная&quot; строка в этом выходе-эта:</target>
        </trans-unit>
        <trans-unit id="355a754edd3ac1108f8aa47f09609e4797573a28" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;old&lt;/code&gt; is the signature of the deprecated method, the second one &lt;code&gt;new&lt;/code&gt; is the call which replaces it. &lt;code&gt;@deprecate&lt;/code&gt; exports &lt;code&gt;old&lt;/code&gt; unless the optional third argument is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Первый аргумент &lt;code&gt;old&lt;/code&gt; - это подпись устаревшего метода, второй &lt;code&gt;new&lt;/code&gt; - это вызов, который его заменяет. &lt;code&gt;@deprecate&lt;/code&gt; экспортирует &lt;code&gt;old&lt;/code&gt; если третий необязательный аргумент не равен &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca4a6f093dfc816b748358bcada908fd4397bf69" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; can be marked with a &lt;code&gt;$&lt;/code&gt;, in which case the return value will instead be a &lt;code&gt;struct CFunction&lt;/code&gt; which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt;&lt;code&gt;finalizer&lt;/code&gt;&lt;/a&gt; when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.</source>
          <target state="translated">Первый аргумент &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; может быть отмечен знаком &lt;code&gt;$&lt;/code&gt; , и в этом случае возвращаемое значение будет вместо этого &lt;code&gt;struct CFunction&lt;/code&gt; , которая закрывает аргумент. Вы должны убедиться, что этот возвращаемый объект остается в живых до тех пор, пока все его использования не будут выполнены. Содержимое и код указателя cfunction будут удалены с помощью &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt; &lt;code&gt;finalizer&lt;/code&gt; &lt;/a&gt; когда эта ссылка будет отброшена и atexit. Обычно в этом нет необходимости, поскольку эта функция отсутствует в C, но может быть полезна для работы с плохо спроектированными API, которые не предоставляют отдельный параметр среды закрытия.</target>
        </trans-unit>
        <trans-unit id="693dd527818a9b4cb2e07e46d1435896bbc1c434" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can also be an expression evaluated at run time. In this case, the expression must evaluate to a &lt;code&gt;Ptr&lt;/code&gt;, which will be used as the address of the native function to call. This behavior occurs when the first &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</source>
          <target state="translated">Первым аргументом &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; также может быть выражение, вычисляемое во время выполнения. В этом случае выражение должно оцениваться как &lt;code&gt;Ptr&lt;/code&gt; , который будет использоваться как адрес собственной функции для вызова. Это происходит, когда первый аргумент &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; содержит ссылки на неконстантные , такие как локальные переменные, аргументы функций или неконстантные глобальные переменные.</target>
        </trans-unit>
        <trans-unit id="145bbc0abe5deab0a11d30eff56416193fa999ea" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;remotecall&lt;/code&gt; is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but &lt;code&gt;remotecall&lt;/code&gt; is considered a low-level interface providing finer control. The second argument to &lt;code&gt;remotecall&lt;/code&gt; is the &lt;code&gt;id&lt;/code&gt; of the process that will do the work, and the remaining arguments will be passed to the function being called.</source>
          <target state="translated">Первым аргументом &lt;code&gt;remotecall&lt;/code&gt; является вызываемая функция. Большинство параллельных программ в Julia не ссылаются на конкретные процессы или количество доступных процессов, но &lt;code&gt;remotecall&lt;/code&gt; считается интерфейсом низкого уровня, обеспечивающим более точное управление. Второй аргумент &lt;code&gt;remotecall&lt;/code&gt; - это &lt;code&gt;id&lt;/code&gt; процесса, который будет выполнять работу, а остальные аргументы будут переданы вызываемой функции.</target>
        </trans-unit>
        <trans-unit id="25e1aab2d5890f1ec3fee29d387628c8119eeb0c" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;show&lt;/code&gt; can be an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; specifying output format properties. See &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Первым &lt;code&gt;show&lt;/code&gt; аргументом может быть &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; ,&lt;/a&gt; определяющий свойства формата вывода. Подробнее см. &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52b90970f0dc891c8696d7672a072123d726419a" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; is executed when &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; is called. The resulting expression contains &lt;em&gt;only&lt;/em&gt; the second &lt;code&gt;println&lt;/code&gt;:</source>
          <target state="translated">Первый вызов &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt; выполняется при &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt; . Результирующее выражение содержит &lt;em&gt;только&lt;/em&gt; второй &lt;code&gt;println&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8464368be55c0ee0f473e53693ff139c3f5a4a18" translate="yes" xml:space="preserve">
          <source>The first case works, because the last character &lt;code&gt;y&lt;/code&gt; and the space are one-byte characters, whereas &lt;code&gt;end-2&lt;/code&gt; indexes into the middle of the &lt;code&gt;&amp;exist;&lt;/code&gt; multibyte representation. The correct way for this case is using &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; or, if you're using that value to index into &lt;code&gt;s&lt;/code&gt; you can write &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; expands to &lt;code&gt;lastindex(s)&lt;/code&gt;.</source>
          <target state="translated">Первый случай работает, потому что последний символ &lt;code&gt;y&lt;/code&gt; и пробел являются однобайтовыми символами, тогда как &lt;code&gt;end-2&lt;/code&gt; указывает на середину многобайтового представления &lt;code&gt;&amp;exist;&lt;/code&gt; . Правильный способ для этого случая - использовать &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; или, если вы используете это значение для индексации в &lt;code&gt;s&lt;/code&gt; , вы можете написать &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; а &lt;code&gt;end&lt;/code&gt; расширяется до &lt;code&gt;lastindex(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae7754ed7d4e8921dc21019e00cb20a90b09dbc" translate="yes" xml:space="preserve">
          <source>The first construct is used when you need the value, but not index, of each element. In the second construct, &lt;code&gt;i&lt;/code&gt; will be an &lt;code&gt;Int&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an array type with fast linear indexing; otherwise, it will be a &lt;code&gt;CartesianIndex&lt;/code&gt;:</source>
          <target state="translated">Первая конструкция используется, когда вам нужно значение, но не индекс каждого элемента. Во второй конструкции &lt;code&gt;i&lt;/code&gt; будет &lt;code&gt;Int&lt;/code&gt; , если &lt;code&gt;A&lt;/code&gt; является типом массива с быстрой линейной индексацией; в противном случае это будет &lt;code&gt;CartesianIndex&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a131f32e4f6815b22742934540634fef42489da" translate="yes" xml:space="preserve">
          <source>The first entry is the &quot;user depot&quot; and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</source>
          <target state="translated">Первая запись является &quot;депо пользователя&quot; и должна быть доступна для записи и принадлежать текущему пользователю.Депо пользователя-это место,где:клонируются реестры,устанавливаются новые версии пакетов,создаются и обновляются именованные среды,клонируются репозитории пакетов,сохраняются только что скомпилированные файлы образов пакетов,записываются лог-файлы,по умолчанию проверяются пакеты разработки,сохраняются глобальные конфигурационные данные.Последующие записи в пути депо обрабатываются как доступные только для чтения и подходящие для установленных и управляемых системными администраторами реестров,пакетов и пр.</target>
        </trans-unit>
        <trans-unit id="006a5d47461c1a2f566eaae2f91fca6d12ba4594" translate="yes" xml:space="preserve">
          <source>The first five control flow mechanisms are standard to high-level programming languages. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.</source>
          <target state="translated">Первые пять механизмов потока управления являются стандартными для языков программирования высокого уровня. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; не такие уж стандартные: они обеспечивают нелокальный поток управления, что позволяет переключаться между временно приостановленными вычислениями. Это мощная конструкция: и обработка исключений, и совместная многозадачность реализованы в Julia с помощью задач. Повседневное программирование не требует прямого использования задач, но некоторые проблемы могут быть решены гораздо легче с помощью задач.</target>
        </trans-unit>
        <trans-unit id="bc720da072f28a4dbfd483b203295a21a9e3bf91" translate="yes" xml:space="preserve">
          <source>The first index</source>
          <target state="translated">Первый показатель</target>
        </trans-unit>
        <trans-unit id="2eaf288e228785826b1d737a1c9027a7797306cf" translate="yes" xml:space="preserve">
          <source>The first index, used in &lt;code&gt;X[begin]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb11ec038c2596553227120950a5afbedeee7655" translate="yes" xml:space="preserve">
          <source>The first line &amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash; declares that &lt;code&gt;OurRational&lt;/code&gt; takes one type parameter of an integer type, and is itself a real type. The field declarations &lt;code&gt;num::T&lt;/code&gt; and &lt;code&gt;den::T&lt;/code&gt; indicate that the data held in a &lt;code&gt;OurRational{T}&lt;/code&gt; object are a pair of integers of type &lt;code&gt;T&lt;/code&gt;, one representing the rational value's numerator and the other representing its denominator.</source>
          <target state="translated">Первая строка - &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; - объявляет, что &lt;code&gt;OurRational&lt;/code&gt; принимает один параметр типа целочисленного типа и сам является реальным типом. Объявления полей &lt;code&gt;num::T&lt;/code&gt; и &lt;code&gt;den::T&lt;/code&gt; указывают, что данные, содержащиеся в &lt;code&gt;OurRational{T}&lt;/code&gt; представляют собой пару целых чисел типа &lt;code&gt;T&lt;/code&gt; , одно из которых представляет числитель рационального значения, а другое - его знаменатель.</target>
        </trans-unit>
        <trans-unit id="427adf0e5c19944f265b6711e004071ffee6d958" translate="yes" xml:space="preserve">
          <source>The first line shows that 80 backtraces were taken at line 73 of &lt;code&gt;event.jl&lt;/code&gt;, but it's not that this line was &quot;expensive&quot; on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to &lt;code&gt;eval_user_input&lt;/code&gt;, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.</source>
          <target state="translated">Первая строка показывает , что 80 Цепочки вызовов были взяты на линии 73 &lt;code&gt;event.jl&lt;/code&gt; , но это не значит, что эта линия была &amp;laquo;дорогой&amp;raquo; сама по себе: третьей линии показывает , что все 80 из этих цепочек вызовов фактически запускаются внутри своего вызова &lt;code&gt;eval_user_input&lt;/code&gt; , и так далее. Чтобы узнать, какие операции на самом деле требуют времени, нам нужно глубже изучить цепочку вызовов.</target>
        </trans-unit>
        <trans-unit id="37442d0cb92e69637999d8ebca28303617dca96e" translate="yes" xml:space="preserve">
          <source>The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:</source>
          <target state="translated">Первый метод применяется во всех случаях,когда оба аргумента относятся к одному конкретному типу,независимо от того,какой это тип,в то время как второй метод действует как ловушка,охватывая все остальные случаи.Таким образом,в целом,это определяет булевую функцию,которая проверяет,являются ли два ее аргумента одними и теми же типами:</target>
        </trans-unit>
        <trans-unit id="babb1cbcd790c4e72ac9f6036b92d0c0da3483a5" translate="yes" xml:space="preserve">
          <source>The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.</source>
          <target state="translated">Первое правило гласит,что продвижение рационального числа с любым другим целым типом способствует продвижению рационального типа,тип числителя/знаменателя которого является результатом продвижения его числителя/знаменателя с другим целым типом.Второе правило применяет одну и ту же логику к двум различным типам рациональных чисел,в результате чего продвижение их соответствующих типов числителя/знаменателя становится рациональным.Третье и последнее правило диктует,что продвижение рационального числа с плавающей точкой приводит к такому же типу,что и продвижение типа числитель/знаменатель с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="5020af03736f636ddf8f18f7a30cb8b1c77d29b4" translate="yes" xml:space="preserve">
          <source>The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling &lt;code&gt;jl_init&lt;/code&gt;, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use &lt;code&gt;jl_init_with_image&lt;/code&gt; instead.</source>
          <target state="translated">Первое, что нужно сделать перед вызовом любой другой функции Julia C, - это инициализировать Julia. Это делается путем вызова &lt;code&gt;jl_init&lt;/code&gt; , который пытается автоматически определить место установки Джулии. Если вам нужно указать настраиваемое расположение или указать, какой образ системы загружать, используйте вместо этого &lt;code&gt;jl_init_with_image&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b9f2f10b840e10d0a053fb01cc746ce6f7be51" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the above argument declarations are equivalent to &lt;code&gt;x::Any&lt;/code&gt; and &lt;code&gt;y::Any&lt;/code&gt;. When this function is invoked, say as &lt;code&gt;myplus(2,5)&lt;/code&gt;, the dispatcher chooses the most specific method named &lt;code&gt;myplus&lt;/code&gt; that matches the given arguments. (See &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; for more information on multiple dispatch.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823f93752a3686f8e2124abf1332680955d50534" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the above argument declarations are equivalent to &lt;code&gt;x::Any&lt;/code&gt; and &lt;code&gt;y::Any&lt;/code&gt;. When this function is invoked, say as &lt;code&gt;myplus(2,5)&lt;/code&gt;, the dispatcher chooses the most specific method named &lt;code&gt;myplus&lt;/code&gt; that matches the given arguments. (See &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on multiple dispatch.)</source>
          <target state="translated">Прежде всего следует отметить, что приведенные выше объявления аргументов эквивалентны &lt;code&gt;x::Any&lt;/code&gt; и &lt;code&gt;y::Any&lt;/code&gt; . Когда эта функция вызывается, например, &lt;code&gt;myplus(2,5)&lt;/code&gt; , диспетчер выбирает наиболее &lt;code&gt;myplus&lt;/code&gt; метод с именем myplus, который соответствует заданным аргументам. (Дополнительные сведения о множественной отправке см. В разделе &quot; &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Методы&quot;&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a6f07b43794fd555596c18f4ead21c7719a2dcd3" translate="yes" xml:space="preserve">
          <source>The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:</source>
          <target state="translated">Первая версия кода формирует строку,затем записывает ее в файл,а вторая версия записывает значения непосредственно в файл.Также обратите внимание,что в некоторых случаях строковая интерполяция может быть сложнее прочитать.Рассмотрим:</target>
        </trans-unit>
        <trans-unit id="7b79b92115c47e04b621f66bea7584e8b8cc8d6b" translate="yes" xml:space="preserve">
          <source>The floating-point literal expression &lt;code&gt;1e10&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1&lt;/code&gt; multiplied by the variable &lt;code&gt;e10&lt;/code&gt;, and similarly with the equivalent &lt;code&gt;E&lt;/code&gt; form.</source>
          <target state="translated">Выражение &lt;code&gt;1e10&lt;/code&gt; литерала с плавающей запятой можно интерпретировать как числовой литерал &lt;code&gt;1&lt;/code&gt; , умноженный на переменную &lt;code&gt;e10&lt;/code&gt; , и аналогично с эквивалентной формой &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbff4b9b06b08e6ec4a779cfee60c358c056ae65" translate="yes" xml:space="preserve">
          <source>The floored quotient and modulus after division. A convenience wrapper for &lt;code&gt;divrem(x, y, RoundDown)&lt;/code&gt;. Equivalent to &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f774bd2a3cc1859a12b8ce9ea22d04daec926b" translate="yes" xml:space="preserve">
          <source>The floored quotient and modulus after division. Equivalent to &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt;.</source>
          <target state="translated">Частное и модуль упругости после деления. Эквивалентно &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc58e18ac764f385326b970e654dea814c444fa3" translate="yes" xml:space="preserve">
          <source>The folder &lt;code&gt;clustermanager/0mq&lt;/code&gt; in the &lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;Examples repository&lt;/a&gt; contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all &lt;em&gt;logically&lt;/em&gt; connected to each other&amp;ndash;any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.</source>
          <target state="translated">Папка &lt;code&gt;clustermanager/0mq&lt;/code&gt; в &lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;репозитории примеров&lt;/a&gt; содержит пример использования ZeroMQ для соединения рабочих Julia в звездообразной топологии с брокером 0MQ посередине. Примечание. Все процессы Julia по-прежнему &lt;em&gt;логически&lt;/em&gt; связаны друг с другом - любой рабочий может напрямую отправлять сообщения любому другому работнику, не зная, что 0MQ используется в качестве транспортного уровня.</target>
        </trans-unit>
        <trans-unit id="a25bab23609fe72a03f9f2d28cbc6e4cfaac93b5" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;arithmetic operators&lt;/a&gt; are supported on all primitive numeric types:</source>
          <target state="translated">Следующие &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;арифметические операторы&lt;/a&gt; поддерживаются для всех примитивных числовых типов:</target>
        </trans-unit>
        <trans-unit id="b432537d382d58fcb2012895b80fa177f57617f4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;bitwise operators&lt;/a&gt; are supported on all primitive integer types:</source>
          <target state="translated">Следующие &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;побитовые операторы&lt;/a&gt; поддерживаются для всех примитивных целочисленных типов:</target>
        </trans-unit>
        <trans-unit id="bc2ce27e5cd51f5b5da2d26eef20e592177e82dd" translate="yes" xml:space="preserve">
          <source>The following Julia code calls &lt;code&gt;dist&lt;/code&gt; using &lt;code&gt;ccall&lt;/code&gt;:</source>
          <target state="translated">Следующий код Julia вызывает &lt;code&gt;dist&lt;/code&gt; с помощью &lt;code&gt;ccall&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="82ab1c7eae6116d2e86f4fd6447f19f5008f2767" translate="yes" xml:space="preserve">
          <source>The following are Julia's primitive numeric types:</source>
          <target state="translated">Ниже приведены примитивные числовые типы Джулии:</target>
        </trans-unit>
        <trans-unit id="68261312da3f6e4277114d21e46489769870f01a" translate="yes" xml:space="preserve">
          <source>The following arguments, if any, are the actual argument values passed to the function.</source>
          <target state="translated">Следующими аргументами,если таковые имеются,являются фактические значения аргументов,переданные в функцию.</target>
        </trans-unit>
        <trans-unit id="33f4f41b4dfa9a0ce6359f8eda915a3bfda673bd" translate="yes" xml:space="preserve">
          <source>The following defines the usage of terminal-based &lt;code&gt;emacs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345825a433cae3afd4ca7643a01203ee8503ec4c" translate="yes" xml:space="preserve">
          <source>The following elements can be written either at the &quot;toplevel&quot; of a document or within another &quot;toplevel&quot; element.</source>
          <target state="translated">Следующие элементы могут быть написаны как на &quot;верхнем уровне&quot; документа,так и внутри другого элемента &quot;верхнего уровня&quot;.</target>
        </trans-unit>
        <trans-unit id="5790b1d96d0b783ee001251802dd3d3773c38e07" translate="yes" xml:space="preserve">
          <source>The following escape sequences are recognised:</source>
          <target state="translated">Распознаются следующие последовательности эвакуации:</target>
        </trans-unit>
        <trans-unit id="b2e62d45eb7d1c7cb2ac8b8faa743869642b4084" translate="yes" xml:space="preserve">
          <source>The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :</source>
          <target state="translated">В следующем примере вычисляется средневзвешенное значение текущего элемента и его левого и правого соседа по сетке 1-d.:</target>
        </trans-unit>
        <trans-unit id="07c71a4306d82cac91450f4de662495a1563cd2f" translate="yes" xml:space="preserve">
          <source>The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.</source>
          <target state="translated">Следующий пример рассчитывает QR-разложение небольшого участка большого массива,не создавая временных рамок,и вызывая соответствующую функцию LAPACK с правильными ведущими размерными размерами и параметрами шага.</target>
        </trans-unit>
        <trans-unit id="01c45a39447b88a2e0d45df263308e82a86e4712" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:</source>
          <target state="translated">Следующий пример демонстрирует основные особенности модулей.Он не предназначен для запуска,но показан в иллюстративных целях:</target>
        </trans-unit>
        <trans-unit id="f3dad0aa9d2fe2847f41cefe7b11a1e7d6233556" translate="yes" xml:space="preserve">
          <source>The following example utilizes ccall to call a function in a common Fortran library (libBLAS) to computes a dot product. Notice that the argument mapping is a bit different here than above, as we need to map from Julia to Fortran. On every argument type, we specify &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt;. This mangling convention may be specific to your fortran compiler and operating system, and is likely undocumented. However, wrapping each in a &lt;code&gt;Ref&lt;/code&gt; (or &lt;code&gt;Ptr&lt;/code&gt;, where equivalent) is a frequent requirement of Fortran compiler implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec34fbe859ef32bab5a71865f07de40a61bead9c" translate="yes" xml:space="preserve">
          <source>The following examples highlight execution in different tasks by returning the &lt;code&gt;objectid&lt;/code&gt; of the tasks in which the mapping function is executed.</source>
          <target state="translated">В следующих примерах подчеркивается выполнение в различных задачах, возвращая &lt;code&gt;objectid&lt;/code&gt; задач, в которых выполняется функция сопоставления.</target>
        </trans-unit>
        <trans-unit id="874609aa4f87e9365e65a6b29283f60a85fb17ac" translate="yes" xml:space="preserve">
          <source>The following examples may help you interpret expressions marked as containing non-leaf types:</source>
          <target state="translated">Следующие примеры могут помочь в интерпретации выражений,помеченных как содержащие нелистовые типы:</target>
        </trans-unit>
        <trans-unit id="cbdf8c8b616fe2394336d97bc9a1e9b4526f4626" translate="yes" xml:space="preserve">
          <source>The following examples show the different forms.</source>
          <target state="translated">Следующие примеры показывают различные формы.</target>
        </trans-unit>
        <trans-unit id="e0233afcec03abf55b61a44d6697627a2028159d" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;BunchKaufman&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt;&lt;code&gt;issymmetric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt;&lt;code&gt;ishermitian&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для объектов &lt;code&gt;BunchKaufman&lt;/code&gt; доступны следующие функции : &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt; &lt;code&gt;issymmetric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt; &lt;code&gt;ishermitian&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="624545d56fb5f27fa75152ac7cc2635666c3e206" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;Eigen&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для объектов &lt;code&gt;Eigen&lt;/code&gt; доступны следующие функции : &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1aea27103439af78084bb11124346f279815f32" translate="yes" xml:space="preserve">
          <source>The following functions are available for the &lt;code&gt;QR&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;\&lt;/code&gt;. When &lt;code&gt;A&lt;/code&gt; is rectangular, &lt;code&gt;\&lt;/code&gt; will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When &lt;code&gt;A&lt;/code&gt; is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.</source>
          <target state="translated">Для объектов &lt;code&gt;QR&lt;/code&gt; доступны следующие функции : &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;\&lt;/code&gt; . Когда &lt;code&gt;A&lt;/code&gt; имеет прямоугольную форму, &lt;code&gt;\&lt;/code&gt; вернет решение методом наименьших квадратов, а если решение не уникально, то будет возвращено решение с наименьшей нормой. Когда &lt;code&gt;A&lt;/code&gt; не является полным рангом, для получения решения с минимальной нормой требуется факторизация с поворотом (столбца).</target>
        </trans-unit>
        <trans-unit id="aabc44011e588107ac199e54e743b25f507c9ed0" translate="yes" xml:space="preserve">
          <source>The following functions are not exported:</source>
          <target state="translated">Следующие функции не экспортируются:</target>
        </trans-unit>
        <trans-unit id="688d351a0c5736fa7ecff6e47939996801847a5a" translate="yes" xml:space="preserve">
          <source>The following language constructs call &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">Следующие языковые конструкции вызывают &lt;code&gt;convert&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6c5e57131238ccfda9b38e0c3969a02ae25bed8d" translate="yes" xml:space="preserve">
          <source>The following methods and types in &lt;code&gt;Base.StackTraces&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt;.</source>
          <target state="translated">Следующие методы и типы в &lt;code&gt;Base.StackTraces&lt;/code&gt; не экспортируются и должны вызываться, например, как &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="427d5751feb1ea6470872d5f773b472a734eb30c" translate="yes" xml:space="preserve">
          <source>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</source>
          <target state="translated">Следующие методы описываются как &quot;небезопасные&quot;,потому что плохой указатель или объявление типа может привести к внезапному завершению работы Юлии.</target>
        </trans-unit>
        <trans-unit id="b0ebcfaf65e09f2421f1536d1962299cfa2d23fa" translate="yes" xml:space="preserve">
          <source>The following operators are supported for arrays:</source>
          <target state="translated">Для массивов поддерживаются следующие операторы:</target>
        </trans-unit>
        <trans-unit id="61cb6687852400c8b9d8a7c3529a66703d4cce18" translate="yes" xml:space="preserve">
          <source>The following properties are in common use:</source>
          <target state="translated">В общем пользовании находятся следующие свойства:</target>
        </trans-unit>
        <trans-unit id="d1b72ce471ac18a5159131679678a4b35625017b" translate="yes" xml:space="preserve">
          <source>The following rules and examples pertain to local scopes. A newly introduced variable in a local scope cannot be referenced by a parent scope. For example, here the $z$ is not introduced into the top-level scope:</source>
          <target state="translated">Следующие правила и примеры относятся к локальным областям применения.На вновь введенную переменную в локальной области видимости нельзя ссылаться с помощью родительской области видимости.Например,здесь $z$ не вводится в область видимости верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="b337c7ef95094018464c8f26d41814785e93faec" translate="yes" xml:space="preserve">
          <source>The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.</source>
          <target state="translated">В следующих разделах объясняются некоторые аспекты идиоматического стиля кодирования Юлии.Ни одно из этих правил не является абсолютным;это только предложения,чтобы помочь вам ознакомиться с языком и помочь вам выбрать один из альтернативных дизайнов.</target>
        </trans-unit>
        <trans-unit id="599c61734f3be9adb8efdea5a3e2879b8d0d65f5" translate="yes" xml:space="preserve">
          <source>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix &lt;code&gt;S&lt;/code&gt;, or that the resulting sparse matrix has density &lt;code&gt;d&lt;/code&gt;, i.e. each matrix element has a probability &lt;code&gt;d&lt;/code&gt; of being non-zero.</source>
          <target state="translated">В следующей таблице показано соответствие между встроенными методами для разреженных матриц и их соответствующими методами для типов плотных матриц. В общем, методы, которые генерируют разреженные матрицы, отличаются от своих плотных аналогов тем, что результирующая матрица следует тому же шаблону разреженности, что и данная разреженная матрица &lt;code&gt;S&lt;/code&gt; , или что результирующая разреженная матрица имеет плотность &lt;code&gt;d&lt;/code&gt; , то есть каждый элемент матрицы имеет вероятность &lt;code&gt;d&lt;/code&gt; быть ненулевая.</target>
        </trans-unit>
        <trans-unit id="2850e916b8328a8067cb56753c2fae6f207d9a41" translate="yes" xml:space="preserve">
          <source>The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments). You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing &lt;code&gt;?&lt;/code&gt; and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).</source>
          <target state="translated">В следующей таблице перечислены символы Unicode, которые можно вводить с помощью завершения табуляции в сокращениях, подобных LaTeX, в Julia REPL (и в различных других средах редактирования). Вы также можете получить информацию о том, как ввести символ, введя его в справку REPL, т.е. набрав &lt;code&gt;?&lt;/code&gt; а затем ввод символа в REPL (например, путем копирования и вставки из того места, где вы видели символ).</target>
        </trans-unit>
        <trans-unit id="84caf0f2b4e520eb1362c7d90034a53ce384352e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the &lt;a href=&quot;#Standard-Functions-1&quot;&gt;Standard Functions&lt;/a&gt; section of the Linear Algebra documentation.</source>
          <target state="translated">В следующей таблице приведены типы факторизации матриц, реализованные в Julia. Подробности связанных с ними методов можно найти в разделе &amp;laquo; &lt;a href=&quot;#Standard-Functions-1&quot;&gt;Стандартные функции&lt;/a&gt; &amp;raquo; документации по линейной алгебре.</target>
        </trans-unit>
        <trans-unit id="57acff1f14a6f50eb70fb52e043df3e1854283f1" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the &lt;a href=&quot;#Standard-functions&quot;&gt;Standard functions&lt;/a&gt; section of the Linear Algebra documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e3ae439be1705d14dc31df2b803cc4528033bf" translate="yes" xml:space="preserve">
          <source>The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.</source>
          <target state="translated">В следующих таблицах приведены типы специальных матриц,которые были реализованы в Юлии,а также доступны ли для них в LAPACK крючки к различным оптимизированным методам.</target>
        </trans-unit>
        <trans-unit id="58787cfe45db809926391f964f8c2fe50eb9c66e" translate="yes" xml:space="preserve">
          <source>The following two-word sequences are reserved: &lt;code&gt;abstract type&lt;/code&gt;, &lt;code&gt;mutable struct&lt;/code&gt;, &lt;code&gt;primitive type&lt;/code&gt;. However, you can create variables with names: &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;mutable&lt;/code&gt;, &lt;code&gt;primitive&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Зарезервированы следующие последовательности из двух слов: &lt;code&gt;abstract type&lt;/code&gt; , &lt;code&gt;mutable struct&lt;/code&gt; , &lt;code&gt;primitive type&lt;/code&gt; . Однако вы можете создавать переменные с именами: &lt;code&gt;abstract&lt;/code&gt; , &lt;code&gt;mutable&lt;/code&gt; , &lt;code&gt;primitive&lt;/code&gt; и &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c16965f50c24120006902ac240b6d5249b8840ca" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.answer_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that output should have at the terminal.</source>
          <target state="translated">Форматирование &lt;code&gt;Base.answer_color()&lt;/code&gt; (по умолчанию: нормальное, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ), которое вывод должен иметь на терминале.</target>
        </trans-unit>
        <trans-unit id="2a94f6ed982371cc454e13d3c41d22bd28f7000c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.error_color()&lt;/code&gt; (default: light red, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt;) that errors should have at the terminal.</source>
          <target state="translated">Форматирование &lt;code&gt;Base.error_color()&lt;/code&gt; (по умолчанию: светло-красный, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt; ), которое ошибки должны иметь на терминале.</target>
        </trans-unit>
        <trans-unit id="5bedb24b2b2a4f0d544b13331782037e6b751d7c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.info_color()&lt;/code&gt; (default: cyan, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt;) that info should have at the terminal.</source>
          <target state="translated">Форматирование &lt;code&gt;Base.info_color()&lt;/code&gt; (по умолчанию: голубой, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt; ), которое информация должна иметь на терминале.</target>
        </trans-unit>
        <trans-unit id="9abdd1879aac44fbed37a23e8cd8c9521c6a3a7b" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.input_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that input should have at the terminal.</source>
          <target state="translated">Форматирование &lt;code&gt;Base.input_color()&lt;/code&gt; (по умолчанию: нормальное, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ), которое ввод должен иметь на терминале.</target>
        </trans-unit>
        <trans-unit id="5c3246893833440c6ee277a6f4469b2f678db3a7" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that function calls should have during a stack trace at the terminal.</source>
          <target state="translated">Форматирование &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (по умолчанию: полужирный, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ), которое должны иметь вызовы функций во время трассировки стека на терминале.</target>
        </trans-unit>
        <trans-unit id="276edac3df59db618aba660c48a61b72521725f5" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that line info should have during a stack trace at the terminal.</source>
          <target state="translated">Форматирование &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (по умолчанию: полужирный, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ), которую информация о строке должна иметь во время трассировки стека на терминале.</target>
        </trans-unit>
        <trans-unit id="5a3d58af274070ed561a7473fe7be9c81a95ede6" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.warn_color()&lt;/code&gt; (default: yellow, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt;) that warnings should have at the terminal.</source>
          <target state="translated">Форматирование &lt;code&gt;Base.warn_color()&lt;/code&gt; (по умолчанию: желтый, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt; ), которое должно отображаться в предупреждениях на терминале.</target>
        </trans-unit>
        <trans-unit id="e430bf906d90ec3cbe26e6641c11eeda24fe35ca" translate="yes" xml:space="preserve">
          <source>The former is a single character value of type &lt;code&gt;Char&lt;/code&gt;, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.</source>
          <target state="translated">Первое - это односимвольное значение типа &lt;code&gt;Char&lt;/code&gt; , а второе - строковое значение, которое содержит только один символ. В Юлии это совсем разные вещи.</target>
        </trans-unit>
        <trans-unit id="d152dae5600534a9646e1a87a36f09f36dd3ded5" translate="yes" xml:space="preserve">
          <source>The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and the second due to the &lt;code&gt;fetch&lt;/code&gt; (or even a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;fetch&lt;/code&gt;/&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is also being executed serially resulting in an overall poorer performance.</source>
          <target state="translated">Первый приводит к одному сетевому &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; а второй - к двум сетевым вызовам - первый из-за @spawnat, а второй из-за &lt;code&gt;fetch&lt;/code&gt; (или даже &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; ). &lt;code&gt;fetch&lt;/code&gt; / &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; также выполняются последовательно приводит к общему ухудшению производительности.</target>
        </trans-unit>
        <trans-unit id="d93e33c90f8c053ee253be6b3d20b4b263f781d7" translate="yes" xml:space="preserve">
          <source>The fully expanded value of &lt;code&gt;LOAD_PATH&lt;/code&gt; that is searched for projects and packages can be seen by calling the &lt;code&gt;Base.load_path()&lt;/code&gt; function.</source>
          <target state="translated">Полностью развернутое значение &lt;code&gt;LOAD_PATH&lt;/code&gt; , которое ищется для проектов и пакетов, можно увидеть, вызвав &lt;code&gt;Base.load_path()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53cd7e3be35b834ce5e0e038f9eb6daebb41c365" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;count_heads&lt;/code&gt; simply adds together &lt;code&gt;n&lt;/code&gt; random bits. Here is how we can perform some trials on two machines, and add together the results:</source>
          <target state="translated">Функция &lt;code&gt;count_heads&lt;/code&gt; просто складывает &lt;code&gt;n&lt;/code&gt; случайных битов. Вот как мы можем провести несколько испытаний на двух машинах и сложить результаты:</target>
        </trans-unit>
        <trans-unit id="1a7009ac781780ee28678319854f5347c9495c13" translate="yes" xml:space="preserve">
          <source>The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.</source>
          <target state="translated">Вызов функции превысил размер стека вызовов.Обычно это происходит,когда вызов повторяется бесконечно.</target>
        </trans-unit>
        <trans-unit id="da6b2e5a2ff44122d7db169754c14ee6b172e967" translate="yes" xml:space="preserve">
          <source>The function in which &lt;code&gt;@boundscheck&lt;/code&gt; is written must be inlined into its caller in order for &lt;code&gt;@inbounds&lt;/code&gt; to have effect.</source>
          <target state="translated">Функция, в которой написана &lt;code&gt;@boundscheck&lt;/code&gt; , должна быть встроена в вызывающую &lt;code&gt;@inbounds&lt;/code&gt; чтобы @inbounds имел эффект.</target>
        </trans-unit>
        <trans-unit id="39d7cf55fabb709098be0379cf1a36954e7ad2fc" translate="yes" xml:space="preserve">
          <source>The function parameter &lt;code&gt;f&lt;/code&gt; should have following signature:</source>
          <target state="translated">Параметр функции &lt;code&gt;f&lt;/code&gt; должен иметь следующую сигнатуру:</target>
        </trans-unit>
        <trans-unit id="c1a0f9cdfffaafbbc345f4ef6dcd681fce922423" translate="yes" xml:space="preserve">
          <source>The function reads the cookie from stdin if required, and listens on a free port (or if specified, the port in the &lt;code&gt;--bind-to&lt;/code&gt; command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.</source>
          <target state="translated">Функция считывает cookie из стандартного ввода, если требуется, и прослушивает свободный порт (или, если он указан, порт в параметре командной строки &lt;code&gt;--bind-to&lt;/code&gt; ) и планирует задачи для обработки входящих TCP-соединений и запросов. Он также (необязательно) закрывает stdin и перенаправляет stderr на stdout.</target>
        </trans-unit>
        <trans-unit id="9bbfa1f4c4ac027f7439aa3d2df2d4291e74275a" translate="yes" xml:space="preserve">
          <source>The function's return type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b716ab0d4ac152e4a4f9c6b1390eb5136f17d5d2" translate="yes" xml:space="preserve">
          <source>The garbage collector does not guarantee any order of finalization. That is, if &lt;code&gt;a&lt;/code&gt; contained a reference to &lt;code&gt;b&lt;/code&gt; and both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are due for garbage collection, there is no guarantee that &lt;code&gt;b&lt;/code&gt; would be finalized after &lt;code&gt;a&lt;/code&gt;. If proper finalization of &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt; being valid, it must be handled in other ways.</source>
          <target state="translated">Сборщик мусора не гарантирует какой-либо порядок завершения. То есть, если &lt;code&gt;a&lt;/code&gt; содержит ссылку на &lt;code&gt;b&lt;/code&gt; и оба &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; подлежат сборке мусора, нет гарантии, что &lt;code&gt;b&lt;/code&gt; будет завершен после &lt;code&gt;a&lt;/code&gt; . Если правильное завершение &lt;code&gt;a&lt;/code&gt; зависит от того, является ли &lt;code&gt;b&lt;/code&gt; действительным, с этим нужно работать другими способами.</target>
        </trans-unit>
        <trans-unit id="2c5ffa9d8537b10e07bd1e1cd0016a03d6887376" translate="yes" xml:space="preserve">
          <source>The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the &lt;code&gt;jl_gc_wb&lt;/code&gt; (write barrier) function like so:</source>
          <target state="translated">Сборщик мусора работает в предположении, что он знает каждый объект старого поколения, указывающий на объект молодого поколения. Каждый раз, когда указатель обновляется, нарушая это предположение, он должен сигнализироваться &lt;code&gt;jl_gc_wb&lt;/code&gt; с помощью функции jl_gc_wb (барьер записи) следующим образом:</target>
        </trans-unit>
        <trans-unit id="7f907da64c464f65fc72aafc195dfebc2e4f4da6" translate="yes" xml:space="preserve">
          <source>The general syntax for assigning values in an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">Общий синтаксис для присвоения значений в n-мерном массиве &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f7fec22031b950929a2be2bf28c88a4e32319b3" translate="yes" xml:space="preserve">
          <source>The general syntax for indexing into an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">Общий синтаксис для индексации в n-мерный массив &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="03b4ccfaa881cd16fd244ada75dc950f11a8dd7c" translate="yes" xml:space="preserve">
          <source>The general syntaxes for declaring a primitive type are:</source>
          <target state="translated">Общими синтаксисами для объявления примитивного типа являются:</target>
        </trans-unit>
        <trans-unit id="f539d98e5f467e838a2ad828b788e7266b1e5a86" translate="yes" xml:space="preserve">
          <source>The generalized SVD is used in applications such as when one wants to compare how much belongs to &lt;code&gt;A&lt;/code&gt; vs. how much belongs to &lt;code&gt;B&lt;/code&gt;, as in human vs yeast genome, or signal vs noise, or between clusters vs within clusters. (See Edelman and Wang for discussion: https://arxiv.org/abs/1901.00485)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8b49d87c21864e9239600316a0864509f86bdd" translate="yes" xml:space="preserve">
          <source>The generalized eigenvalues are returned in &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt;. The left Schur vectors are returned in &lt;code&gt;vsl&lt;/code&gt; and the right Schur vectors are returned in &lt;code&gt;vsr&lt;/code&gt;.</source>
          <target state="translated">Обобщенные собственные значения возвращаются в &lt;code&gt;alpha&lt;/code&gt; и &lt;code&gt;beta&lt;/code&gt; . Левые векторы Шура возвращаются в &lt;code&gt;vsl&lt;/code&gt; , а правые векторы Шура возвращаются в &lt;code&gt;vsr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b85eadd92e8e39874d6e912a6cbd8941d0875a4" translate="yes" xml:space="preserve">
          <source>The global constant &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt; is bound to the complex number &lt;em&gt;i&lt;/em&gt;, representing the principal square root of -1. (Using mathematicians' &lt;code&gt;i&lt;/code&gt; or engineers' &lt;code&gt;j&lt;/code&gt; for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;juxtaposed with identifiers as coefficients&lt;/a&gt;, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0ec4e7835e3ddd782c0a7070e015136b4b04a9" translate="yes" xml:space="preserve">
          <source>The global constant &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt; is bound to the complex number &lt;em&gt;i&lt;/em&gt;, representing the principal square root of -1. (Using mathematicians' &lt;code&gt;i&lt;/code&gt; or engineers' &lt;code&gt;j&lt;/code&gt; for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;juxtaposed with identifiers as coefficients&lt;/a&gt;, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</source>
          <target state="translated">Глобальная константа &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt; связана с комплексным числом &lt;em&gt;i&lt;/em&gt; , представляющим главный квадратный корень из -1. (Использование математиков &lt;code&gt;i&lt;/code&gt; или инженеров &lt;code&gt;j&lt;/code&gt; для этой глобальной константы было отклонено, поскольку они являются такими популярными именами индексных переменных.) Поскольку Julia позволяет &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;сопоставить&lt;/a&gt; числовые литералы с идентификаторами в качестве коэффициентов , этой привязки достаточно для обеспечения удобного синтаксиса для комплексных чисел, подобных к традиционным математическим обозначениям:</target>
        </trans-unit>
        <trans-unit id="ef1d21913b7da2cd50221a9ea53be6e2ac79e4fa" translate="yes" xml:space="preserve">
          <source>The global logger may be set with &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt;&lt;code&gt;global_logger&lt;/code&gt;&lt;/a&gt;, and task-local loggers controlled using &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt;&lt;code&gt;with_logger&lt;/code&gt;&lt;/a&gt;. Newly spawned tasks inherit the logger of the parent task.</source>
          <target state="translated">Глобальный регистратор может быть установлен с помощью &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt; &lt;code&gt;global_logger&lt;/code&gt; &lt;/a&gt; , а локальные регистраторы задач управляются с помощью &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt; &lt;code&gt;with_logger&lt;/code&gt; &lt;/a&gt; . Недавно созданные задачи наследуют регистратор родительской задачи.</target>
        </trans-unit>
        <trans-unit id="fec591827136cb7a3fdc941604debe52d6ebea89" translate="yes" xml:space="preserve">
          <source>The global logger may be set with &lt;a href=&quot;#Logging.global_logger&quot;&gt;&lt;code&gt;global_logger&lt;/code&gt;&lt;/a&gt;, and task-local loggers controlled using &lt;a href=&quot;#Logging.with_logger&quot;&gt;&lt;code&gt;with_logger&lt;/code&gt;&lt;/a&gt;. Newly spawned tasks inherit the logger of the parent task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f673e90f9a09b859b5b51800816fab3de4b761" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; determines a relative path from &lt;code&gt;Sys.BINDIR&lt;/code&gt; to the data directory associated with Julia. Then the path</source>
          <target state="translated">Глобальная переменная &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; определяет относительный путь от &lt;code&gt;Sys.BINDIR&lt;/code&gt; к каталогу данных, связанному с Julia. Тогда путь</target>
        </trans-unit>
        <trans-unit id="e3bc80be4d521baacc06dd9873b328760a93de88" translate="yes" xml:space="preserve">
          <source>The golden ratio.</source>
          <target state="translated">Золотое сечение.</target>
        </trans-unit>
        <trans-unit id="354c17f25309f78f252b602097180cb50161163d" translate="yes" xml:space="preserve">
          <source>The group id of the file owner</source>
          <target state="translated">Идентификатор группы владельца файла</target>
        </trans-unit>
        <trans-unit id="9e739954ff8de8447d1ab16a3adde7a80c985194" translate="yes" xml:space="preserve">
          <source>The hexadecimal integer literal expression &lt;code&gt;0xff&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;0&lt;/code&gt; multiplied by the variable &lt;code&gt;xff&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатеричное целочисленное буквальное выражение &lt;code&gt;0xff&lt;/code&gt; можно интерпретировать как числовой литерал &lt;code&gt;0&lt;/code&gt; , умноженный на переменную &lt;code&gt;xff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49109aa658d7c92b2a2e148756ac4fc9b1efb6c1" translate="yes" xml:space="preserve">
          <source>The highest finite value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Высокое конечное значение представимо по заданной с плавающей точкой ТипДанных &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c54bd6057f9e745e71a4f119d94151d139d45e8" translate="yes" xml:space="preserve">
          <source>The highest value representable by the given (real) numeric &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">Наибольшее значение, представленное заданным (реальным) числовым &lt;code&gt;DataType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d03859ad784bc750f8658c68023988ea70e276c" translate="yes" xml:space="preserve">
          <source>The host machine must have the requisite SIMD registers. For example, the code above will not work on hosts without AVX support.</source>
          <target state="translated">На хост-машине должны быть необходимые SIMD-регистры.Например,приведенный выше код не будет работать на хостах без поддержки AVX.</target>
        </trans-unit>
        <trans-unit id="69486992100b48c68c6ad0bb1508ce13148c9067" translate="yes" xml:space="preserve">
          <source>The hour of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Час &lt;code&gt;Time&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ae14cb6dca4ab146e83e6f66251f24254e3bb17" translate="yes" xml:space="preserve">
          <source>The hour of day of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Час дня &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1bfeaaafc9c1b963fac8395380b6b23cf36c72" translate="yes" xml:space="preserve">
          <source>The hour part of a DateTime as a &lt;code&gt;Hour&lt;/code&gt;.</source>
          <target state="translated">Часовая часть DateTime как &lt;code&gt;Hour&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3215c43ad10d3da4db391c4e4892aec7413196da" translate="yes" xml:space="preserve">
          <source>The identity function. Returns its argument.</source>
          <target state="translated">Функция идентификации.Возвращает свой аргумент.</target>
        </trans-unit>
        <trans-unit id="c738dd3a82cae47bce1402d7e9ed9b1a08ec88db" translate="yes" xml:space="preserve">
          <source>The imaginary unit &lt;code&gt;sqrt(-1)&lt;/code&gt; is represented in Julia as &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;j&lt;/code&gt; as in MATLAB.</source>
          <target state="translated">Мнимая единица &lt;code&gt;sqrt(-1)&lt;/code&gt; представлена ​​в Julia как &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt; , а не &lt;code&gt;i&lt;/code&gt; или &lt;code&gt;j&lt;/code&gt; , как в MATLAB.</target>
        </trans-unit>
        <trans-unit id="30bb48cc6e4e4350066fc756423b5585bb034986" translate="yes" xml:space="preserve">
          <source>The imaginary unit &lt;code&gt;sqrt(-1)&lt;/code&gt; is represented in Julia as &lt;code&gt;im&lt;/code&gt;, not &lt;code&gt;j&lt;/code&gt; as in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7823efd88570f05c6cdcdeba7b9c6d877d28d4c3" translate="yes" xml:space="preserve">
          <source>The imaginary unit.</source>
          <target state="translated">Воображаемая единица.</target>
        </trans-unit>
        <trans-unit id="d2f3b37cc4a76dd392140d18be234dc4fa787173" translate="yes" xml:space="preserve">
          <source>The implementation of this behavior is a &quot;world age counter&quot;. This monotonically increasing value tracks each method definition operation. This allows describing &quot;the set of method definitions visible to a given runtime environment&quot; as a single number, or &quot;world age&quot;. It also allows comparing the methods available in two worlds just by comparing their ordinal value. In the example above, we see that the &quot;current world&quot; (in which the method &lt;code&gt;newfun&lt;/code&gt; exists), is one greater than the task-local &quot;runtime world&quot; that was fixed when the execution of &lt;code&gt;tryeval&lt;/code&gt; started.</source>
          <target state="translated">Реализация этого поведения - &amp;laquo;мировой счетчик возраста&amp;raquo;. Это монотонно увеличивающееся значение отслеживает каждую операцию определения метода. Это позволяет описать &amp;laquo;набор определений методов, видимых данной среде выполнения&amp;raquo; как одно число или &amp;laquo;мировую эпоху&amp;raquo;. Это также позволяет сравнивать методы, доступные в двух мирах, просто сравнивая их порядковые значения. В приведенном выше примере мы видим, что &amp;laquo;текущий мир&amp;raquo; (в котором существует метод &lt;code&gt;newfun&lt;/code&gt; ) на единицу больше, чем локальный для задачи &amp;laquo;мир времени выполнения&amp;raquo;, который был исправлен при &lt;code&gt;tryeval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b253e7f28529381ae2517e2dd4df05c0e78e871f" translate="yes" xml:space="preserve">
          <source>The incremental precompiled module file are created and used automatically when using &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;using&lt;/code&gt; to load a module. This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt;&lt;code&gt;Base.compilecache(modulename)&lt;/code&gt;&lt;/a&gt;. The resulting cache files will be stored in &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt;. Subsequently, the module is automatically recompiled upon &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt;&lt;code&gt;include_dependency(path)&lt;/code&gt;&lt;/a&gt; in the module file(s).</source>
          <target state="translated">Инкрементный файл предварительно скомпилированного модуля создается и используется автоматически при использовании &lt;code&gt;import&lt;/code&gt; или &lt;code&gt;using&lt;/code&gt; для загрузки модуля. Это приведет к его автоматической компиляции при первом импорте. Кроме того, вы можете вручную вызвать &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt; &lt;code&gt;Base.compilecache(modulename)&lt;/code&gt; &lt;/a&gt; . Полученные файлы кеша будут сохранены в &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt; . Впоследствии модуль автоматически перекомпилируется при &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; при изменении любой из его зависимостей; зависимости - это модули, которые он импортирует, сборка Julia, файлы, которые она включает, или явные зависимости, объявленные с помощью &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt; &lt;code&gt;include_dependency(path)&lt;/code&gt; &lt;/a&gt; в файле (файлах) модуля.</target>
        </trans-unit>
        <trans-unit id="13dd8189d32c7c1290b037751919f6e30e7f64f8" translate="yes" xml:space="preserve">
          <source>The individual components of the decomposition &lt;code&gt;F&lt;/code&gt; can be retrieved via property accessors:</source>
          <target state="translated">Отдельные компоненты разложения &lt;code&gt;F&lt;/code&gt; можно получить с помощью средств доступа к свойствам:</target>
        </trans-unit>
        <trans-unit id="41c086468dc0b6a3a361a760590aea5addc822ff" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F::LDLt&lt;/code&gt; can be accessed via &lt;code&gt;getproperty&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d9b54de6a322e63bc3f875f6d62e056cb73285" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F::LU&lt;/code&gt; can be accessed via &lt;a href=&quot;../../base/base/index#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8bb274f2ee9cfc9c33d3c699116094ae0bac43" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F&lt;/code&gt; can be accessed via &lt;a href=&quot;../../base/base/index#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0913135fd9f357f77350a326cce1c8ed6fa49d" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F&lt;/code&gt; can be accessed via &lt;code&gt;getproperty&lt;/code&gt;:</source>
          <target state="translated">К отдельным компонентам факторизации &lt;code&gt;F&lt;/code&gt; можно получить доступ через &lt;code&gt;getproperty&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6e01ca13a398bafdf18f4d4f60195a783a431cf" translate="yes" xml:space="preserve">
          <source>The infix form is exactly equivalent to the function application form &amp;ndash; in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;*&lt;/code&gt; just like you would with other function values:</source>
          <target state="translated">Инфиксная форма в точности эквивалентна форме приложения функции - на самом деле первая анализируется для внутреннего вызова функции. Это также означает, что вы можете назначать и передавать операторы, такие как &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;*&lt;/code&gt; , точно так же, как и с другими значениями функций:</target>
        </trans-unit>
        <trans-unit id="ab93d805a4e1efd3cacbdba9a517e0dc2379a9e4" translate="yes" xml:space="preserve">
          <source>The infix operation &lt;code&gt;a ⊻ b&lt;/code&gt; is a synonym for &lt;code&gt;xor(a,b)&lt;/code&gt;, and &lt;code&gt;⊻&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\xor&lt;/code&gt; or &lt;code&gt;\veebar&lt;/code&gt; in the Julia REPL.</source>
          <target state="translated">Инфиксная операция &lt;code&gt;a ⊻ b&lt;/code&gt; является синонимом для &lt;code&gt;xor(a,b)&lt;/code&gt; , а &lt;code&gt;⊻&lt;/code&gt; может быть набрана с помощью дополнения табуляции &lt;code&gt;\xor&lt;/code&gt; или &lt;code&gt;\veebar&lt;/code&gt; в Julia REPL.</target>
        </trans-unit>
        <trans-unit id="e1b31695e555eb78c96b1ce43ed5d4b769be43f4" translate="yes" xml:space="preserve">
          <source>The initial Julia process, also called the &lt;code&gt;master&lt;/code&gt;, is special and has an &lt;code&gt;id&lt;/code&gt; of 1.</source>
          <target state="translated">Первоначальный процесс Julia, также называемый &lt;code&gt;master&lt;/code&gt; , является особенным и имеет &lt;code&gt;id&lt;/code&gt; 1.</target>
        </trans-unit>
        <trans-unit id="46aabc78dd4e507670425bdb3bf204611d3ffb13" translate="yes" xml:space="preserve">
          <source>The inode number of the file</source>
          <target state="translated">Идентификационный номер файла</target>
        </trans-unit>
        <trans-unit id="204c42952f2670f515bfe08f06a0ba3dd55c909a" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;n&lt;/code&gt; is passed by value, and so the function's input signature is simply declared as &lt;code&gt;(Csize_t,)&lt;/code&gt; without any &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt; necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt;, since Fortran variables are passed by pointers.) Furthermore, &lt;code&gt;n&lt;/code&gt; can be any type that is convertible to a &lt;code&gt;Csize_t&lt;/code&gt; integer; the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; implicitly calls &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вход &lt;code&gt;n&lt;/code&gt; передается по значению, и поэтому входная сигнатура функции просто объявляется как &lt;code&gt;(Csize_t,)&lt;/code&gt; без каких-либо &lt;code&gt;Ref&lt;/code&gt; или &lt;code&gt;Ptr&lt;/code&gt; . (Если вместо этого &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt; функцию Fortran, соответствующая входная сигнатура функции должна быть (Ref {Csize_t},) , поскольку переменные Fortran передаются указателями.) Кроме того, &lt;code&gt;n&lt;/code&gt; может быть любым типом, который может быть преобразован в целое число &lt;code&gt;Csize_t&lt;/code&gt; . ; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; неявно вызывает &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="533ae8282fbee75fbb95332329b16aa4f88660eb" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;n&lt;/code&gt; is passed by value, and so the function's input signature is simply declared as &lt;code&gt;(Csize_t,)&lt;/code&gt; without any &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt; necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature would instead be &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt;, since Fortran variables are passed by pointers.) Furthermore, &lt;code&gt;n&lt;/code&gt; can be any type that is convertible to a &lt;code&gt;Csize_t&lt;/code&gt; integer; the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; implicitly calls &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b235e73123abb02c8610a64480c17659bc5e36" translate="yes" xml:space="preserve">
          <source>The input matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; will not contain their eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called. They are used as workspaces.</source>
          <target state="translated">Входные матрицы &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; не будут содержать своих собственных значений после собственных значений &lt;code&gt;eigvals!&lt;/code&gt; называется. Они используются как рабочие места.</target>
        </trans-unit>
        <trans-unit id="a25e9d14fa9f0f89dab37c152c425a3aebebbd0f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;A&lt;/code&gt; will not contain its eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called on it - &lt;code&gt;A&lt;/code&gt; is used as a workspace.</source>
          <target state="translated">&lt;code&gt;eigvals!&lt;/code&gt; матрица &lt;code&gt;A&lt;/code&gt; не будет содержать своих собственных значений после собственных значений ! вызывается на нем - &lt;code&gt;A&lt;/code&gt; используется как рабочая область.</target>
        </trans-unit>
        <trans-unit id="1417019c8a8204f046e43b52db1e1b8dfe779fc9" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; is not transposed or conjugated.</source>
          <target state="translated">Входная матрица &lt;code&gt;X&lt;/code&gt; не транспонируется и не сопряжена.</target>
        </trans-unit>
        <trans-unit id="696317e85c44155ed1679065a21cab9ea0d94c6f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be conjugated and transposed.</source>
          <target state="translated">Входная матрица &lt;code&gt;X&lt;/code&gt; будет сопряжена и транспонирована.</target>
        </trans-unit>
        <trans-unit id="edc49f341fce73dbc1b810339993fe819e7483f6" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be transposed.</source>
          <target state="translated">Входная матрица &lt;code&gt;X&lt;/code&gt; будет транспонирована.</target>
        </trans-unit>
        <trans-unit id="ce8cf57c3583cc5f6f01c812980b6d9e8e041658" translate="yes" xml:space="preserve">
          <source>The intuition behind this behavior is that &lt;code&gt;x&lt;/code&gt; is evaluated once for each &lt;code&gt;$&lt;/code&gt;: one &lt;code&gt;$&lt;/code&gt; works similarly to &lt;code&gt;eval(:x)&lt;/code&gt;, giving &lt;code&gt;x&lt;/code&gt;'s value, while two &lt;code&gt;$&lt;/code&gt;s do the equivalent of &lt;code&gt;eval(eval(:x))&lt;/code&gt;.</source>
          <target state="translated">Интуиция, лежащая в основе такого поведения, заключается в том, что &lt;code&gt;x&lt;/code&gt; вычисляется один раз для каждого &lt;code&gt;$&lt;/code&gt; : one &lt;code&gt;$&lt;/code&gt; работает аналогично &lt;code&gt;eval(:x)&lt;/code&gt; , давая значение &lt;code&gt;x&lt;/code&gt; , а два &lt;code&gt;$&lt;/code&gt; s выполняют эквивалент &lt;code&gt;eval(eval(:x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9951fb03011eb6ccac99ddca5a1c8a2596a1921f" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt; functions is &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, which retrieves the inputs used to create the sparse array. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; returns the cartesian indices of non-zero entries in &lt;code&gt;x&lt;/code&gt; (including stored entries equal to zero).</source>
          <target state="translated">Обратно &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt; функций &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt; , который извлекает исходные данные , используемые для создания разреженного массива. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; возвращает декартовы индексы ненулевых записей в &lt;code&gt;x&lt;/code&gt; (включая сохраненные записи, равные нулю).</target>
        </trans-unit>
        <trans-unit id="08e030af941b44ba6a6057a4b8409ccf9a09fa65" translate="yes" xml:space="preserve">
          <source>The item or field is not defined for the given object.</source>
          <target state="translated">Элемент или поле не определены для данного объекта.</target>
        </trans-unit>
        <trans-unit id="b34eda5561d7a2242bd83cb6f099eb397c0b5c82" translate="yes" xml:space="preserve">
          <source>The iteration space is split among the threads, after which each thread writes its thread ID to its assigned locations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5978b1760bac737678645da104214e401ee6745d" translate="yes" xml:space="preserve">
          <source>The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:</source>
          <target state="translated">Пространство итераций делится между потоками,после чего каждый поток записывает свой идентификатор потока в назначенные ему места:</target>
        </trans-unit>
        <trans-unit id="aa67cafc379af040f95c65d3767fc728770e3507" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;debuginfo&lt;/code&gt; controls the amount of code metadata present in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27814682e2f12bb813126e15aaa61e9b9ecadb0b" translate="yes" xml:space="preserve">
          <source>The keyword argument &lt;code&gt;topology&lt;/code&gt; passed to &lt;code&gt;addprocs&lt;/code&gt; is used to specify how the workers must be connected to each other:</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; аргумента ключевого слова, переданная в &lt;code&gt;addprocs&lt;/code&gt; , используется для указания того, как рабочие должны быть связаны друг с другом:</target>
        </trans-unit>
        <trans-unit id="071e1626e259689d138d5d354cd990a797f9cc76" translate="yes" xml:space="preserve">
          <source>The keyword argument is:</source>
          <target state="translated">Ключевой аргумент:</target>
        </trans-unit>
        <trans-unit id="a0bf59d5d88128d67e3917cc9fc88ca7d247fb14" translate="yes" xml:space="preserve">
          <source>The keyword arguments &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt; correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53040371261a8a003dc97b8ee4567faef82b0f5" translate="yes" xml:space="preserve">
          <source>The keyword arguments are:</source>
          <target state="translated">Ключевые аргументы:</target>
        </trans-unit>
        <trans-unit id="aff2628de569031caf118a1cfbb476e502ae8a02" translate="yes" xml:space="preserve">
          <source>The keyword arguments can be any combination of:</source>
          <target state="translated">Аргументами ключевого слова могут быть любые комбинации:</target>
        </trans-unit>
        <trans-unit id="88a5016b4ada3cfa1d337884f9c60b1547e662dc" translate="yes" xml:space="preserve">
          <source>The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Аргументы ключевого слова определяют, какой из состояний чтения и / или записи следует отслеживать; хотя бы один из них должен иметь значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0461b4257dea448624f31f52377f5d07347ab62c" translate="yes" xml:space="preserve">
          <source>The keyword arguments supported here are the same as those in the 2-argument &lt;code&gt;isapprox&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c36d11485ade8e4d84f52006bfe2371bd7a3a31" translate="yes" xml:space="preserve">
          <source>The keyword debuginfo controls the amount of code metadata present in the output.</source>
          <target state="translated">Ключевое слово debuginfo управляет количеством метаданных кода,присутствующих в выводе.</target>
        </trans-unit>
        <trans-unit id="1c08fd56fd5a7ec1b4c4d5ce6e7cd9fc470d3bc9" translate="yes" xml:space="preserve">
          <source>The largest &lt;code&gt;a^n&lt;/code&gt; not greater than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must not be less than 1.</source>
          <target state="translated">Наибольшее &lt;code&gt;a^n&lt;/code&gt; не больше &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - неотрицательное целое число. &lt;code&gt;a&lt;/code&gt; должно быть больше 1, а &lt;code&gt;x&lt;/code&gt; не должно быть меньше 1.</target>
        </trans-unit>
        <trans-unit id="1950191e788c00e6e81f70c06794860257be97cd" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer representable in the given floating-point type &lt;code&gt;T&lt;/code&gt; that also does not exceed the maximum integer representable by the integer type &lt;code&gt;S&lt;/code&gt;. Equivalently, it is the minimum of &lt;code&gt;maxintfloat(T)&lt;/code&gt; and &lt;a href=&quot;#Base.typemax&quot;&gt;&lt;code&gt;typemax(S)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По величине последовательное целое число , представима в данной плавающей точкой типа &lt;code&gt;T&lt;/code&gt; , который также не превышает максимальное целое число , представима целого типа &lt;code&gt;S&lt;/code&gt; . Эквивалентно, это минимум &lt;code&gt;maxintfloat(T)&lt;/code&gt; и &lt;a href=&quot;#Base.typemax&quot;&gt; &lt;code&gt;typemax(S)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecdd0c5829d6c2ebd17e2173ff4d8725a651c73f" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type &lt;code&gt;T&lt;/code&gt; (which defaults to &lt;code&gt;Float64&lt;/code&gt;).</source>
          <target state="translated">Наибольшее последовательное целочисленное число с плавающей запятой, которое точно представлено в данном типе с плавающей запятой &lt;code&gt;T&lt;/code&gt; (который по умолчанию &lt;code&gt;Float64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="45d85758b569bacb3008f9cd5ec57f8b5348a342" translate="yes" xml:space="preserve">
          <source>The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call &lt;code&gt;free&lt;/code&gt; on the data pointer when the array is no longer referenced.</source>
          <target state="translated">Последний аргумент - это логическое значение, указывающее, должна ли Джулия стать владельцем данных. Если этот аргумент не равен нулю, сборщик мусора вызовет &lt;code&gt;free&lt;/code&gt; указатель данных, когда на массив больше не будет ссылаться.</target>
        </trans-unit>
        <trans-unit id="1c54e90c8086ffbb492a0993d80791c5e4dea811" translate="yes" xml:space="preserve">
          <source>The last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.</source>
          <target state="translated">Последним аргументом является выражение,в котором будут сохранены объект(ы).Предыдущие аргументы-это объекты,которые необходимо сохранить.</target>
        </trans-unit>
        <trans-unit id="ea0fbbe9568bcd71edf3e46185498b21db11849e" translate="yes" xml:space="preserve">
          <source>The last definition of &lt;code&gt;addone&lt;/code&gt; handles any type supporting &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; (which returns 1 in the same type as &lt;code&gt;x&lt;/code&gt;, which avoids unwanted type promotion) and the &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; function with those arguments. The key thing to realize is that there is &lt;em&gt;no performance penalty&lt;/em&gt; to defining &lt;em&gt;only&lt;/em&gt; the general &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt;, because Julia will automatically compile specialized versions as needed. For example, the first time you call &lt;code&gt;addone(12)&lt;/code&gt;, Julia will automatically compile a specialized &lt;code&gt;addone&lt;/code&gt; function for &lt;code&gt;x::Int&lt;/code&gt; arguments, with the call to &lt;code&gt;oneunit&lt;/code&gt; replaced by its inlined value &lt;code&gt;1&lt;/code&gt;. Therefore, the first three definitions of &lt;code&gt;addone&lt;/code&gt; above are completely redundant with the fourth definition.</source>
          <target state="translated">Последнее определение &lt;code&gt;addone&lt;/code&gt; обрабатывает любой тип, поддерживающий &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; (который возвращает 1 того же типа, что и &lt;code&gt;x&lt;/code&gt; , что позволяет избежать нежелательного продвижения типа) и функцию &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; с этими аргументами. Главное понимать, что не существует &lt;em&gt;не ухудшая производительность&lt;/em&gt; для определения &lt;em&gt;только&lt;/em&gt; общий &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt; , потому что Джулия будет автоматически обобщит специализированные версии по мере необходимости. Например, при первом вызове &lt;code&gt;addone(12)&lt;/code&gt; Джулия автоматически скомпилирует специализированную функцию &lt;code&gt;addone&lt;/code&gt; для аргументов &lt;code&gt;x::Int&lt;/code&gt; с вызовом &lt;code&gt;oneunit&lt;/code&gt; заменено его встроенным значением &lt;code&gt;1&lt;/code&gt; . Следовательно, первые три определения &lt;code&gt;addone&lt;/code&gt; приведенные выше, полностью дублируют четвертое определение.</target>
        </trans-unit>
        <trans-unit id="ce1654d58ffca436a4c577b1711a64e839d84f92" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; can also look for a character literal.</source>
          <target state="translated">В последнем примере показано, что в этом &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; также можно искать символьный литерал.</target>
        </trans-unit>
        <trans-unit id="c71585d1662e0c9426691e517fa7355c40e4926e" translate="yes" xml:space="preserve">
          <source>The last index, used in &lt;code&gt;X[end]&lt;/code&gt;</source>
          <target state="translated">Последний индекс, используемый в &lt;code&gt;X[end]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e99097d64e5f2e1b2a717dd030549921903ffab" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type &lt;a href=&quot;#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; can be the special type &lt;code&gt;Vararg&lt;/code&gt;, which denotes any number of trailing elements. The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg&lt;/code&gt; tuple types are used to represent the arguments accepted by varargs methods (see the section on &lt;a href=&quot;../../manual/functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt; in the manual.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a1c4b01d2974399d332fe3cfffd4d1b569afd3" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type &lt;a href=&quot;#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; can be the special type &lt;code&gt;Vararg&lt;/code&gt;, which denotes any number of trailing elements. The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg&lt;/code&gt; tuple types are used to represent the arguments accepted by varargs methods (see the section on &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt; in the manual.)</source>
          <target state="translated">Последним параметром кортежа типа &lt;a href=&quot;#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; может быть специальный тип &lt;code&gt;Vararg&lt;/code&gt; , который обозначает любое количество конечных элементов. Тип &lt;code&gt;Vararg{T,N}&lt;/code&gt; соответствует ровно &lt;code&gt;N&lt;/code&gt; элементов типа &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;Vararg{T}&lt;/code&gt; , соответствует нуль или более элементов типа &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;Vararg&lt;/code&gt; кортежей Vararg используются для представления аргументов, принимаемых методами varargs (см. Раздел о &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;функциях Varargs&lt;/a&gt; в руководстве).</target>
        </trans-unit>
        <trans-unit id="acef1648e92638f5fc5abaed16365a6d53367ba2" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type can be the special type &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;, which denotes any number of trailing elements:</source>
          <target state="translated">Последним параметром &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; типа может быть специальный тип Vararg , который обозначает любое количество конечных элементов:</target>
        </trans-unit>
        <trans-unit id="1d6eefa466648c5ff477244c5653b68c2b829837" translate="yes" xml:space="preserve">
          <source>The last point is potentially surprising and thus worth noting:</source>
          <target state="translated">Последний пункт потенциально удивителен и поэтому заслуживает внимания:</target>
        </trans-unit>
        <trans-unit id="e7ffcc1d6667c70bd8fd7c442814f44c7c9628ab" translate="yes" xml:space="preserve">
          <source>The last rule applies for immutable objects even if the variable binding would change, e.g.:</source>
          <target state="translated">Последнее правило применяется для неизменяемых объектов,даже если привязка переменных изменится,например:</target>
        </trans-unit>
        <trans-unit id="ac541895cad74a09061e0e8e7752d4412b01c909" translate="yes" xml:space="preserve">
          <source>The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A &lt;code&gt;ClusterManager&lt;/code&gt; is responsible for</source>
          <target state="translated">Запуск, управление и объединение процессов Julia в логический кластер осуществляется через менеджеры кластеров. &lt;code&gt;ClusterManager&lt;/code&gt; отвечает за</target>
        </trans-unit>
        <trans-unit id="88412ce5eb2e0660d566bcac5d3d266756d5e5a6" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;s&lt;/code&gt; must be even, and the returned array has half of the length of &lt;code&gt;s&lt;/code&gt;. See also &lt;a href=&quot;#Base.hex2bytes!&quot;&gt;&lt;code&gt;hex2bytes!&lt;/code&gt;&lt;/a&gt; for an in-place version, and &lt;a href=&quot;#Base.bytes2hex&quot;&gt;&lt;code&gt;bytes2hex&lt;/code&gt;&lt;/a&gt; for the inverse.</source>
          <target state="translated">Длина &lt;code&gt;s&lt;/code&gt; должна быть четной, а возвращаемый массив имеет половину длины &lt;code&gt;s&lt;/code&gt; . См. Также &lt;a href=&quot;#Base.hex2bytes!&quot;&gt; &lt;code&gt;hex2bytes!&lt;/code&gt; &lt;/a&gt;для &lt;a href=&quot;#Base.bytes2hex&quot;&gt; &lt;code&gt;bytes2hex&lt;/code&gt; &lt;/a&gt; версии и bytes2hex для инверсии.</target>
        </trans-unit>
        <trans-unit id="82277dc04b6a3c445e6b9754a249fdcb23f3c7cf" translate="yes" xml:space="preserve">
          <source>The line number in the file containing the execution context.</source>
          <target state="translated">Номер строки в файле,содержащем контекст выполнения.</target>
        </trans-unit>
        <trans-unit id="8e34d0276593663d51db2e1008617c96b00222ff" translate="yes" xml:space="preserve">
          <source>The location &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; contains the value at &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt;. All dimensions indexed with scalars are dropped. For example, if &lt;code&gt;J&lt;/code&gt; is an array of indices, then the result of &lt;code&gt;A[2, J, 3]&lt;/code&gt; is an array with size &lt;code&gt;size(J)&lt;/code&gt;. Its &lt;code&gt;j&lt;/code&gt;th element is populated by &lt;code&gt;A[2, J[j], 3]&lt;/code&gt;.</source>
          <target state="translated">Местоположение &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; содержит значение в &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt; , Все измерения, проиндексированные скалярами, отбрасываются. Например, если &lt;code&gt;J&lt;/code&gt; - это массив индексов, то результатом &lt;code&gt;A[2, J, 3]&lt;/code&gt; будет массив размера &lt;code&gt;size(J)&lt;/code&gt; . Его &lt;code&gt;j&lt;/code&gt; - й элемент заполнен &lt;code&gt;A[2, J[j], 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba9cf6bb4f8397cc28a79b830f4f985b9ab3a34" translate="yes" xml:space="preserve">
          <source>The location information can be accessed by referencing &lt;code&gt;__source__.line&lt;/code&gt; and &lt;code&gt;__source__.file&lt;/code&gt;:</source>
          <target state="translated">Доступ к информации о местоположении можно получить, &lt;code&gt;__source__.line&lt;/code&gt; и &lt;code&gt;__source__.file&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cb51b112926a1dd81d50332e9952ca8853bb8d8" translate="yes" xml:space="preserve">
          <source>The location of both the &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords within the scope block is irrelevant. The following is equivalent to the last example (although stylistically worse):</source>
          <target state="translated">Расположение как &lt;code&gt;local&lt;/code&gt; и &lt;code&gt;global&lt;/code&gt; ключевых слов в блоке области не имеет значения. Следующее эквивалентно последнему примеру (хотя стилистически хуже):</target>
        </trans-unit>
        <trans-unit id="98682ff20b7c08341d3c5e15b38c14b9a4d16f28" translate="yes" xml:space="preserve">
          <source>The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.</source>
          <target state="translated">Уровень журнала предоставляет ключ,по которому потенциальные записи журнала могут быть отфильтрованы,прежде чем будет произведена какая-либо другая работа по построению самой структуры данных журнала.</target>
        </trans-unit>
        <trans-unit id="fe0609505a9527026d24d710008d1bfe473fd7b3" translate="yes" xml:space="preserve">
          <source>The logical Julia program structure (Packages and Modules) is independent of the file strucutre (&lt;code&gt;include&lt;/code&gt; for additional files), whereas the Python code structure is defined by directories (Packages) and files (Modules).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318d32e896560b8d7266b2f324ddc4a3093ac0b9" translate="yes" xml:space="preserve">
          <source>The loop body must be straight-line code. Therefore, &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt; is currently needed for all array accesses. The compiler can sometimes turn short &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt; expressions into straight-line code if it is safe to evaluate all operands unconditionally. Consider using the &lt;a href=&quot;#Core.ifelse&quot;&gt;&lt;code&gt;ifelse&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;?:&lt;/code&gt; in the loop if it is safe to do so.</source>
          <target state="translated">Тело цикла должно быть прямолинейным кодом. Следовательно, &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; в настоящее время требуется для всех обращений к массиву. Компилятор может иногда &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , и &lt;code&gt;?:&lt;/code&gt; выражения в прямолинейный код, если можно безопасно оценить все операнды безоговорочно. Рассмотрите возможность использования функции &lt;a href=&quot;#Core.ifelse&quot;&gt; &lt;code&gt;ifelse&lt;/code&gt; &lt;/a&gt; вместо &lt;code&gt;?:&lt;/code&gt; В цикле, если это безопасно.</target>
        </trans-unit>
        <trans-unit id="e1520d8e0dbae93326950f00e9cb69f3cae60938" translate="yes" xml:space="preserve">
          <source>The loop must be an innermost loop</source>
          <target state="translated">Петля должна быть самой внутренней петлей</target>
        </trans-unit>
        <trans-unit id="1417d30bb5a87b95ed3077cbfd4cd113b702f8de" translate="yes" xml:space="preserve">
          <source>The lowest value representable by the given (real) numeric DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Наименьшее значение представима данного (реального) числовой DataType &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73472042c68fe0e8852a29376bec0fce0bf44289" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; generates the C-compatible function pointer for a call to a Julia function. Arguments to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">Макрос &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; генерирует указатель на C-совместимую функцию для вызова функции Julia. Аргументы в &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; следующие:</target>
        </trans-unit>
        <trans-unit id="240541bcb8e3f73fd00189d26b350e3696cca6f4" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; generates the C-compatible function pointer for a call to a Julia function. The arguments to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90d2d040a67a205cdeab40f74d8c8876f85fbd9" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; (or its function variant &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt;) can sometimes be helpful in diagnosing type-related problems. Here's an example:</source>
          <target state="translated">Макрос &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; (или его вариант функции &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt; ) иногда может быть полезен при диагностике проблем, связанных с типом. Вот пример:</target>
        </trans-unit>
        <trans-unit id="9e7d84ccb0a328a62c08d6f8b7389ef525b8bb84" translate="yes" xml:space="preserve">
          <source>The macro may be chained with &lt;code&gt;@test&lt;/code&gt; to also test the returned value:</source>
          <target state="translated">Макрос может быть &lt;code&gt;@test&lt;/code&gt; с @test, чтобы также проверить возвращаемое значение:</target>
        </trans-unit>
        <trans-unit id="ee8a907ab8fbfe293b4dae0afdde54a8eeab9dd2" translate="yes" xml:space="preserve">
          <source>The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:</source>
          <target state="translated">Основное назначение этого конструктора-интуитивный переход от каретцианского к линейному индексированию:</target>
        </trans-unit>
        <trans-unit id="525b6c6d88eda51b84031a3e53a3435af961ebe7" translate="yes" xml:space="preserve">
          <source>The master process does not listen on any port. It only connects out to the workers.</source>
          <target state="translated">Мастер-процесс не прослушивает ни один порт.Он соединяется только с рабочими.</target>
        </trans-unit>
        <trans-unit id="2ed15f9d452fe7aa2e8f8976ab10c5922bcca0ff" translate="yes" xml:space="preserve">
          <source>The master process parses this information and sets up TCP/IP connections to each worker.</source>
          <target state="translated">Ведущий процесс разбирает эту информацию и устанавливает TCP/IP-соединения с каждым рабочим.</target>
        </trans-unit>
        <trans-unit id="c61856ffa89efc2e6c1d6b663bec6b092cbe224f" translate="yes" xml:space="preserve">
          <source>The meaning of prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via &lt;code&gt;mutable struct&lt;/code&gt;). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, &lt;code&gt;&amp;amp;&lt;/code&gt; may be used with any expression, such as &lt;code&gt;&amp;amp;0&lt;/code&gt; or &lt;code&gt;&amp;amp;f(x)&lt;/code&gt;.</source>
          <target state="translated">Значение префикса &lt;code&gt;&amp;amp;&lt;/code&gt; не совсем то же, что и в C. В частности, любые изменения в ссылочных переменных не будут видны в Julia, если тип не является изменяемым (объявленным через &lt;code&gt;mutable struct&lt;/code&gt; ). Однако даже для неизменяемых структур попытка таких модификаций (то есть запись через переданные указатели) не причинит вреда вызываемым функциям. Более того, &lt;code&gt;&amp;amp;&lt;/code&gt; можно использовать с любым выражением, например &lt;code&gt;&amp;amp;0&lt;/code&gt; или &lt;code&gt;&amp;amp;f(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdb2209b7357825841deb8a7b0ab3a885d17542" translate="yes" xml:space="preserve">
          <source>The meaning of this form is that &lt;code&gt;F(x,y,...)&lt;/code&gt; is evaluated with the variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like &lt;code&gt;1:n&lt;/code&gt; or &lt;code&gt;2:(n-1)&lt;/code&gt;, or explicit arrays of values like &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt;. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges &lt;code&gt;rx&lt;/code&gt;, &lt;code&gt;ry&lt;/code&gt;, etc. and each &lt;code&gt;F(x,y,...)&lt;/code&gt; evaluation returns a scalar.</source>
          <target state="translated">Смысл этой формы в том, что &lt;code&gt;F(x,y,...)&lt;/code&gt; вычисляется с помощью переменных &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и т.д., принимающих каждое значение в своем заданном списке значений. Значения могут быть указаны как любой итеративный объект, но обычно это диапазоны, например &lt;code&gt;1:n&lt;/code&gt; или &lt;code&gt;2:(n-1)&lt;/code&gt; , или явные массивы значений, например &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt; . В результате получается плотный массив Nd с размерами, которые представляют собой конкатенацию измерений диапазонов переменных &lt;code&gt;rx&lt;/code&gt; , &lt;code&gt;ry&lt;/code&gt; и т. Д., И каждая оценка &lt;code&gt;F(x,y,...)&lt;/code&gt; возвращает скаляр.</target>
        </trans-unit>
        <trans-unit id="094836238d056b1580750e9abbf5cfe48e515f79" translate="yes" xml:space="preserve">
          <source>The mechanism by which Julia picks default sorting algorithms is implemented via the &lt;code&gt;Base.Sort.defalg&lt;/code&gt; function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt;&lt;code&gt;sort.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Механизм, с помощью которого Джулия выбирает алгоритмы сортировки по умолчанию, реализован с помощью функции &lt;code&gt;Base.Sort.defalg&lt;/code&gt; . Это позволяет зарегистрировать конкретный алгоритм по умолчанию во всех функциях сортировки для определенных массивов. Например, вот два метода по умолчанию из &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt; &lt;code&gt;sort.jl&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="43db34e5821153c9a137e29694256181086c27e9" translate="yes" xml:space="preserve">
          <source>The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; then we have:</source>
          <target state="translated">Механизм объединения структур данных корней, графов и путей компонентов стека среды прост: они объединяются как словари, в случае конфликта ключей более ранние записи предпочтительнее более поздних. Другими словами, если у нас есть &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; то мы имеем:</target>
        </trans-unit>
        <trans-unit id="ec55008649a0dc54bad05f3e8bc19d30ce40563f" translate="yes" xml:space="preserve">
          <source>The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using it, but also the command literal syntax (&lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt;) is implemented with the following innocuous-looking macro:</source>
          <target state="translated">Механизм для определяемых пользователем строковых литералов очень, очень мощный. С его помощью реализованы не только нестандартные литералы Джулии, но также и синтаксис командных литералов ( &lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt; ) со следующим безобидным на вид макросом:</target>
        </trans-unit>
        <trans-unit id="bcd798f681426c31836c9fda7a95d8d4ad32f495" translate="yes" xml:space="preserve">
          <source>The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.</source>
          <target state="translated">Оценка расхода памяти представляет собой приблизительную нижнюю границу размера внутренней структуры объекта.</target>
        </trans-unit>
        <trans-unit id="131ca4486e37b369d3e30c30d5b64041c99a698f" translate="yes" xml:space="preserve">
          <source>The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</source>
          <target state="translated">Поведение разделения памяти в перестроенном массиве игнорируется прекомпиляцией (каждое представление получает свою собственную копию)</target>
        </trans-unit>
        <trans-unit id="298da21a7dd2cc02f54513ff13a66eb673f4dedf" translate="yes" xml:space="preserve">
          <source>The message log level is checked against a global minimum level (set via &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt;&lt;code&gt;disable_logging&lt;/code&gt;&lt;/a&gt;). This is a crude but extremely cheap global setting.</source>
          <target state="translated">Уровень журнала сообщений сравнивается с глобальным минимальным уровнем (устанавливается через &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt; &lt;code&gt;disable_logging&lt;/code&gt; &lt;/a&gt; ). Это грубый, но чрезвычайно дешевый глобальный сеттинг.</target>
        </trans-unit>
        <trans-unit id="75a3b4a8bcb25896eadb4968a1815458fd7550b7" translate="yes" xml:space="preserve">
          <source>The message log level is checked against a global minimum level (set via &lt;a href=&quot;#Logging.disable_logging&quot;&gt;&lt;code&gt;disable_logging&lt;/code&gt;&lt;/a&gt;). This is a crude but extremely cheap global setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee1b8c607641ce31a518860743fee60270b010d" translate="yes" xml:space="preserve">
          <source>The message-processing loop waits on an &lt;code&gt;IO&lt;/code&gt; object (for example, a &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt;&lt;code&gt;TCPSocket&lt;/code&gt;&lt;/a&gt; in the default implementation), reads an entire message, processes it and waits for the next one.</source>
          <target state="translated">Цикл обработки сообщений ожидает объекта &lt;code&gt;IO&lt;/code&gt; (например, &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt; &lt;code&gt;TCPSocket&lt;/code&gt; &lt;/a&gt; в реализации по умолчанию), считывает все сообщение, обрабатывает его и ожидает следующего.</target>
        </trans-unit>
        <trans-unit id="34b07feb0bdcab65a9fbeace753dff1c13bab9a7" translate="yes" xml:space="preserve">
          <source>The method defined above adds parentheses around the call to &lt;code&gt;show&lt;/code&gt; when the precedence of the calling operator is higher than or equal to the precedence of multiplication. This check allows expressions which parse correctly without the parentheses (such as &lt;code&gt;:($a + 2)&lt;/code&gt; and &lt;code&gt;:($a == 2)&lt;/code&gt;) to omit them when printing:</source>
          <target state="translated">Определенный выше метод добавляет круглые скобки вокруг вызова, чтобы &lt;code&gt;show&lt;/code&gt; когда приоритет вызывающего оператора выше или равен приоритету умножения. Эта проверка позволяет выражениям, которые правильно разбираются без скобок (например &lt;code&gt;:($a + 2)&lt;/code&gt; и &lt;code&gt;:($a == 2)&lt;/code&gt; ), опускать их при печати:</target>
        </trans-unit>
        <trans-unit id="480991bedb511928dce09fcfa14be4d26a369c2c" translate="yes" xml:space="preserve">
          <source>The method which accepts a predicate function requires Julia 1.2 or later.</source>
          <target state="translated">Метод,который принимает предикатную функцию,требует Юлия 1.2 или более поздней версии.</target>
        </trans-unit>
        <trans-unit id="f97574c149c35a5f9c0479909c6ba575706d9f14" translate="yes" xml:space="preserve">
          <source>The method which accepts a type requires Julia 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f940b926f7e3b612433e90295b463c51a97504f9" translate="yes" xml:space="preserve">
          <source>The methods in &lt;code&gt;Profile&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;Profile.print()&lt;/code&gt;.</source>
          <target state="translated">Методы в &lt;code&gt;Profile&lt;/code&gt; не экспортируются и должны вызываться, например, как &lt;code&gt;Profile.print()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a65046dfbce016e3be9d63dceb54432e4f789ee8" translate="yes" xml:space="preserve">
          <source>The microsecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Микросекунда &lt;code&gt;Time&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9daf874100ff7e0440c12dfc313262d02c86576" translate="yes" xml:space="preserve">
          <source>The microsecond part of a Time as a &lt;code&gt;Microsecond&lt;/code&gt;.</source>
          <target state="translated">Микросекундная часть времени как &lt;code&gt;Microsecond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="600f058835f17e7a50a06fc528fa2b5032e36ca7" translate="yes" xml:space="preserve">
          <source>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt;. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator should be used explicitly (see &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0211eebcec0e70acc996cc19c6867555ed469b5e" translate="yes" xml:space="preserve">
          <source>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt;. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator should be used explicitly (see &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt;).</source>
          <target state="translated">Среднее выражение вычисляется только один раз, а не дважды, как если бы выражение было записано как &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt; . Однако порядок оценок в цепном сравнении не определен. Настоятельно рекомендуется не использовать выражения с побочными эффектами (например, печать) в цепных сравнениях. Если требуются побочные эффекты, следует явно использовать оператор короткого замыкания &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (см. &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Оценка короткого замыкания&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0dd44e8ebcb71bf9c89ef76d2d2682687dc6d684" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Миллисекунда &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a912f50c335b4d49dd33d6b3bdff08954f636271" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Миллисекунда &lt;code&gt;Time&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6a7eeee369dc2111377df37522ca806e23ee00" translate="yes" xml:space="preserve">
          <source>The millisecond part of a DateTime as a &lt;code&gt;Millisecond&lt;/code&gt;.</source>
          <target state="translated">Часть миллисекунды DateTime как &lt;code&gt;Millisecond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0efc4b9b581f6e3f5cda1b69fb5ed353c8f838e4" translate="yes" xml:space="preserve">
          <source>The minimum and maximum representable values of primitive numeric types such as integers are given by the &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">Минимальные и максимальные представимые значения примитивных числовых типов, таких как целые числа, задаются &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="85c14b13e4a83e3f641ac750e22da88ea684c364" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Минута &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1f5f0a330c1e54ad4dd4510d655f5340eec1c4" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Минута &lt;code&gt;Time&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c946111c81e7adfe6af7b762fccd905ec8f88a87" translate="yes" xml:space="preserve">
          <source>The minute part of a DateTime as a &lt;code&gt;Minute&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Minute&lt;/code&gt; часть DateTime как минута .</target>
        </trans-unit>
        <trans-unit id="847c706add1091574c034eb4a9e1b16f126a1aa6" translate="yes" xml:space="preserve">
          <source>The month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Месяц &lt;code&gt;Date&lt;/code&gt; или &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ffed8c4cf30ae11b37e19dbd7e317d781c6a99d" translate="yes" xml:space="preserve">
          <source>The most basic Julia workflows involve using a text editor in conjunction with the &lt;code&gt;julia&lt;/code&gt; command line. A common pattern includes the following elements:</source>
          <target state="translated">Самые простые рабочие процессы Julia включают использование текстового редактора в сочетании с командной строкой &lt;code&gt;julia&lt;/code&gt; . Обычный паттерн включает в себя следующие элементы:</target>
        </trans-unit>
        <trans-unit id="d8d0db7f857485bf8537d6760d93ea9e3026a18d" translate="yes" xml:space="preserve">
          <source>The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.</source>
          <target state="translated">Наиболее часто используемым типом в Юлии является структура,заданная в виде имени и набора полей.</target>
        </trans-unit>
        <trans-unit id="bd6910dc7e6ab3eb744adf6e8b4dbbd2635bda90" translate="yes" xml:space="preserve">
          <source>The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;blog post&lt;/a&gt;, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</source>
          <target state="translated">Самая разумная альтернатива наличию целочисленной арифметики с незаметным переполнением - это повсюду выполнять проверенные арифметические операции, вызывая ошибки при сложении, вычитании и умножении переполнения, создавая значения, которые не являются корректными по значению. В этом &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;сообщении в блоге&lt;/a&gt; Дэн Луу анализирует это и обнаруживает, что вместо тривиальных затрат, которые теоретически должен иметь этот подход, он приводит к существенным затратам из-за того, что компиляторы (LLVM и GCC) не оптимизируют должным образом добавленные проверки переполнения. Если это улучшится в будущем, мы могли бы рассмотреть возможность использования по умолчанию проверенной целочисленной арифметики в Julia, но пока мы должны жить с возможностью переполнения.</target>
        </trans-unit>
        <trans-unit id="5c96614bea2c2a0370b72e64ab597c56a3607929" translate="yes" xml:space="preserve">
          <source>The most significant departures of Julia from typical dynamic languages are:</source>
          <target state="translated">Наиболее значительными отходами Юлии от типичных динамических языков являются:</target>
        </trans-unit>
        <trans-unit id="227e81ea680d9761105bfdd7a757c011a63d4676" translate="yes" xml:space="preserve">
          <source>The most useful log pattern is a simple tuple of the form &lt;code&gt;(level,message)&lt;/code&gt;. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to &lt;code&gt;AbstractLogger&lt;/code&gt; via the &lt;code&gt;handle_message&lt;/code&gt; function: &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt;. Elements which are present will be matched pairwise with the log record fields using &lt;code&gt;==&lt;/code&gt; by default, with the special cases that &lt;code&gt;Symbol&lt;/code&gt;s may be used for the standard log levels, and &lt;code&gt;Regex&lt;/code&gt;s in the pattern will match string or Symbol fields using &lt;code&gt;occursin&lt;/code&gt;.</source>
          <target state="translated">Самый полезный шаблон журнала - это простой кортеж формы &lt;code&gt;(level,message)&lt;/code&gt; . Другое количество элементов кортежа может использоваться для сопоставления с другими метаданными журнала, соответствующими аргументам, передаваемым в &lt;code&gt;AbstractLogger&lt;/code&gt; через функцию &lt;code&gt;handle_message&lt;/code&gt; : &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt; . Присутствующие элементы будут сопоставляться попарно с полями записи журнала с использованием &lt;code&gt;==&lt;/code&gt; по умолчанию, с особыми случаями, когда &lt;code&gt;Symbol&lt;/code&gt; s может использоваться для стандартных уровней журнала, а &lt;code&gt;Regex&lt;/code&gt; s в шаблоне будет соответствовать полям строки или Symbol с использованием &lt;code&gt;occursin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7050ead4b7f2406a51989e3a96dcd274b5c4dc" translate="yes" xml:space="preserve">
          <source>The name of &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;).</source>
          <target state="translated">Имя &lt;code&gt;tag&lt;/code&gt; (например, &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aac1a5f61cbf21e0f76584158e2b1aa448b0700a" translate="yes" xml:space="preserve">
          <source>The name of the function containing the execution context.</source>
          <target state="translated">Имя функции,содержащей контекст выполнения.</target>
        </trans-unit>
        <trans-unit id="0b15e5d3b4e9ddd6442998593016569d415621b0" translate="yes" xml:space="preserve">
          <source>The nanosecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Наносекунда &lt;code&gt;Time&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aad1073892a176543a30631fd9ae9393da61cbfc" translate="yes" xml:space="preserve">
          <source>The nanosecond part of a Time as a &lt;code&gt;Nanosecond&lt;/code&gt;.</source>
          <target state="translated">Наносекундная часть времени как &lt;code&gt;Nanosecond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e0de7b0a951b098e85d827d86686abc302c514" translate="yes" xml:space="preserve">
          <source>The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; it is possible that the &lt;code&gt;options&lt;/code&gt; structure also contains a value for &lt;code&gt;width&lt;/code&gt;. In such a case the rightmost occurrence takes precedence; in this example, &lt;code&gt;width&lt;/code&gt; is certain to have the value &lt;code&gt;2&lt;/code&gt;. However, explicitly specifying the same keyword argument multiple times, for example &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt;, is not allowed and results in a syntax error.</source>
          <target state="translated">Природа аргументов ключевого слова позволяет указывать один и тот же аргумент более одного раза. Например, в &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; вызовов (x, y; options ..., width = 2) возможно, что структура &lt;code&gt;options&lt;/code&gt; также содержит значение для &lt;code&gt;width&lt;/code&gt; . В таком случае самое правое вхождение имеет приоритет; в этом примере &lt;code&gt;width&lt;/code&gt; будет иметь значение &lt;code&gt;2&lt;/code&gt; . Однако явное указание одного и того же аргумента ключевого слова несколько раз, например &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt; , не допускается и приводит к синтаксической ошибке.</target>
        </trans-unit>
        <trans-unit id="314d66ff5662511b17e76bf3864e0515f7414401" translate="yes" xml:space="preserve">
          <source>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a &lt;code&gt;:&lt;/code&gt;, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array &lt;code&gt;A&lt;/code&gt;. The total number of elements must not change.</source>
          <target state="translated">Новые размеры могут быть указаны либо как список аргументов, либо как кортеж формы. По большей мере в одном измерении может быть указан с &lt;code&gt;:&lt;/code&gt; , причем в этом случае его длина вычисляется таким образом, что его продукт со всеми указанными размерами равна длине исходного массива &lt;code&gt;A&lt;/code&gt; . Общее количество элементов не должно изменяться.</target>
        </trans-unit>
        <trans-unit id="c7c774e234a53110d1af9fd61a5cda8cbeee8a27" translate="yes" xml:space="preserve">
          <source>The next clear cut situation we'll consider is when there is already a local variable named &lt;code&gt;x&lt;/code&gt;, in which case &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; always assigns to this existing local &lt;code&gt;x&lt;/code&gt;. The function &lt;code&gt;sum_to&lt;/code&gt; computes the sum of the numbers from one up to &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec82b325e399ba219250018d4cd45bb47824912" translate="yes" xml:space="preserve">
          <source>The next example composes three functions and maps the result over an array of strings:</source>
          <target state="translated">Следующий пример состоит из трех функций и отображает результат по массиву строк:</target>
        </trans-unit>
        <trans-unit id="0141922960db98bd617ee28c2bf6139f8261ae58" translate="yes" xml:space="preserve">
          <source>The next step is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;parse&lt;/a&gt; each string into an object called an expression, represented by the Julia type &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Следующим шагом является &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;синтаксический анализ&lt;/a&gt; каждой строки в объект, называемый выражением, представленный типом Julia &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="571a7acf064deadfa35e0bae63b5faada78832c9" translate="yes" xml:space="preserve">
          <source>The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.</source>
          <target state="translated">Следующим шагом является настройка проекта,чтобы найти файлы,включенные в Julia и библиотеки.Важно знать,является ли установка Julia 32-или 64-битной.Удалите любую конфигурацию платформы,которая не соответствует установке Julia,прежде чем продолжить.</target>
        </trans-unit>
        <trans-unit id="87d90798d58eeb7d4e5d75a87f02bc64256ab91b" translate="yes" xml:space="preserve">
          <source>The next two higher-order methods, &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;tonext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;toprev&lt;/code&gt;&lt;/a&gt;, generalize working with temporal expressions by taking a &lt;code&gt;DateFunction&lt;/code&gt; as first argument, along with a starting &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;DateFunction&lt;/code&gt; is just a function, usually anonymous, that takes a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and returns a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;true&lt;/code&gt; indicating a satisfied adjustment criterion. For example:</source>
          <target state="translated">Следующие два метода более высокого порядка, &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;tonext&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;toprev&lt;/code&gt; &lt;/a&gt; , обобщают работу с темпоральными выражениями, принимая &lt;code&gt;DateFunction&lt;/code&gt; в качестве первого аргумента вместе с начальным &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;DateFunction&lt;/code&gt; это просто функция, как правило , анонимны, что принимает один &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; в качестве входных данных и возвращает &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;true&lt;/code&gt; указывает на удовлетворенный критерий регулировки. Например:</target>
        </trans-unit>
        <trans-unit id="bfdcd43295ca16b8983e8ac5f09ed7f5b30bbe1e" translate="yes" xml:space="preserve">
          <source>The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a &quot;style.&quot; Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer &amp;mdash; the &quot;destination style&quot;.</source>
          <target state="translated">Следующие два шага (выбор выходного массива и реализация) зависят от определения единственного ответа для данного набора аргументов. Широковещательная передача должна брать все различные типы своих аргументов и сворачивать их до одного выходного массива и одной реализации. Broadcast называет этот единственный ответ &amp;laquo;стилем&amp;raquo;. Каждый транслируемый объект имеет свой собственный предпочтительный стиль, и для объединения этих стилей в один ответ - &amp;laquo;стиль назначения&amp;raquo; используется система, похожая на продвижение.</target>
        </trans-unit>
        <trans-unit id="aa11e7d901418eb60c69c43212182dad6fd572f8" translate="yes" xml:space="preserve">
          <source>The no-equilibration, no-transpose simplification of &lt;code&gt;gesvx!&lt;/code&gt;.</source>
          <target state="translated">Упрощение &lt;code&gt;gesvx!&lt;/code&gt; без уравновешивания и транспонирования ! ,</target>
        </trans-unit>
        <trans-unit id="a3be6317f46ece197572e4701784f6328c75ca21" translate="yes" xml:space="preserve">
          <source>The node where the value is stored keeps track of which of the workers have a reference to it. Every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is serialized to a worker, the node pointed to by the reference is notified. And every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is garbage collected locally, the node owning the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running cluster. Serializing and deserializing references to and from regular &lt;code&gt;IO&lt;/code&gt; objects is not supported.</source>
          <target state="translated">Узел, на котором хранится значение, отслеживает, какие из рабочих имеют на него ссылку. Каждый раз, когда &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; или (не извлеченное) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; сериализуются для рабочего, уведомляется узел, на который указывает ссылка. И каждый раз, когда &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; или (невыделенное) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; собираются локально, узел, владеющий значением, снова уведомляется. Это реализовано во внутреннем сериализаторе, поддерживающем кластер. Удаленные ссылки действительны только в контексте работающего кластера. Сериализация и десериализация ссылок на обычные объекты &lt;code&gt;IO&lt;/code&gt; и из них не поддерживается.</target>
        </trans-unit>
        <trans-unit id="1ee269a033086fa0f88e3b8bd43c4d1005189ba4" translate="yes" xml:space="preserve">
          <source>The node which owns the value frees it once all references to it are cleared.</source>
          <target state="translated">Узел,которому принадлежит значение,освобождает его после очистки всех ссылок на него.</target>
        </trans-unit>
        <trans-unit id="f7755c5c54345d39219c99d946bb10594613370c" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; can be used to express the Julia analogue of a &lt;em&gt;covariant&lt;/em&gt; type, while &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; the analogue of a &lt;em&gt;contravariant&lt;/em&gt; type, but technically these represent &lt;em&gt;sets&lt;/em&gt; of types (see &lt;a href=&quot;#UnionAll-Types&quot;&gt;UnionAll Types&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9581a565bb9e56cce70d93ca5c19c14a7d3c0d" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; can be used to express the Julia analogue of a &lt;em&gt;covariant&lt;/em&gt; type, while &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; the analogue of a &lt;em&gt;contravariant&lt;/em&gt; type, but technically these represent &lt;em&gt;sets&lt;/em&gt; of types (see &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll Types&lt;/a&gt;).</source>
          <target state="translated">Обозначение &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; может использоваться для выражения аналога Julia &lt;em&gt;ковариантного&lt;/em&gt; типа, а &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; - аналога &lt;em&gt;контравариантного&lt;/em&gt; типа, но технически они представляют собой &lt;em&gt;наборы&lt;/em&gt; типов (см. &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;Типы UnionAll&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d8a556b93d1842772dc7f76de931e723dfee64b" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;T(x)&lt;/code&gt; or &lt;code&gt;convert(T,x)&lt;/code&gt; converts &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Обозначения &lt;code&gt;T(x)&lt;/code&gt; или &lt;code&gt;convert(T,x)&lt;/code&gt; преобразует &lt;code&gt;x&lt;/code&gt; к значению типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe139a73bee792b672a69d44b859332e9c6820f5" translate="yes" xml:space="preserve">
          <source>The notifications are done via sending of &quot;tracking&quot; messages&amp;ndash;an &quot;add reference&quot; message when a reference is serialized to a different process and a &quot;delete reference&quot; message when a reference is locally garbage collected.</source>
          <target state="translated">Уведомления выполняются посредством отправки сообщений &amp;laquo;отслеживания&amp;raquo; - сообщения &amp;laquo;добавить ссылку&amp;raquo;, когда ссылка сериализуется в другой процесс, и сообщения &amp;laquo;удалить ссылку&amp;raquo;, когда ссылка локально собирается сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="2cbf1f552e1a2901fc74809693aa1d1ec7161dbc" translate="yes" xml:space="preserve">
          <source>The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a &quot;UT second&quot;, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt; or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.</source>
          <target state="translated">Понятие секунды UT на самом деле довольно фундаментально. В основном существуют два общепринятых понятия времени: одно основано на физическом вращении Земли (одно полное вращение = 1 день), другое - на секунде СИ (фиксированное, постоянное значение). Это кардинально разные! Подумайте об этом: &amp;laquo;секунда UT&amp;raquo;, определяемая относительно вращения Земли, может иметь различную абсолютную длину в зависимости от дня! В любом случае, тот факт, что &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; основаны на секундах UT, является упрощающим, но честным предположением, так что можно избежать таких вещей, как дополнительные секунды и вся их сложность. Эта основа времени формально называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt;или UT1. Основание типов на секунде UT в основном означает, что каждая минута имеет 60 секунд, а каждый день - 24 часа, что приводит к более естественным вычислениям при работе с календарными датами.</target>
        </trans-unit>
        <trans-unit id="abccc41a26dc7addb4c68d102fecb6865b6fa56f" translate="yes" xml:space="preserve">
          <source>The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.</source>
          <target state="translated">Число после имени указывает, сколько бит памяти требуется типу. В настоящее время поддерживаются только размеры, кратные 8 битам. В &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; декларации показано , как примитивный тип может быть необязательно объявлен подтипом некоторого надтипа.</target>
        </trans-unit>
        <trans-unit id="5ce8d9c28b728282659fe445b5ac4e7293389f79" translate="yes" xml:space="preserve">
          <source>The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having &lt;code&gt;Any&lt;/code&gt; as its immediate supertype. The declaration of &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; above therefore means that a boolean value takes eight bits to store, and has &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported and you are likely to experience LLVM bugs with sizes other than those used above. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375b6efd3979207393378302c9f41c7a21121f28" translate="yes" xml:space="preserve">
          <source>The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having &lt;code&gt;Any&lt;/code&gt; as its immediate supertype. The declaration of &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; above therefore means that a boolean value takes eight bits to store, and has &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</source>
          <target state="translated">Количество битов указывает, сколько памяти требуется типу, а имя дает имя новому типу. Примитивный тип необязательно может быть объявлен подтипом некоторого супертипа. Если супертип опущен, то тип по умолчанию имеет &lt;code&gt;Any&lt;/code&gt; в качестве своего непосредственного супертипа. Таким образом, объявление &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; выше означает, что логическое значение требует для хранения восьми бит, а его непосредственным супертипом является &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; . В настоящее время поддерживаются только размеры, кратные 8 битам. Следовательно, логические значения, хотя им действительно нужен только один бит, не могут быть объявлены меньшими, чем восемь бит.</target>
        </trans-unit>
        <trans-unit id="e47d85b6b66b2f56b7aa9e07418e7bd219677af8" translate="yes" xml:space="preserve">
          <source>The number of characters in string &lt;code&gt;s&lt;/code&gt; from indices &lt;code&gt;i&lt;/code&gt; through &lt;code&gt;j&lt;/code&gt;. This is computed as the number of code unit indices from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt; which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; arguments it computes the number of indices between &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; inclusive that are valid indices in the string &lt;code&gt;s&lt;/code&gt;. In addition to in-bounds values, &lt;code&gt;i&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Количество символов в строке &lt;code&gt;s&lt;/code&gt; от индексов с &lt;code&gt;i&lt;/code&gt; до &lt;code&gt;j&lt;/code&gt; . Это вычисляется как количество индексов кодовых единиц от &lt;code&gt;i&lt;/code&gt; до &lt;code&gt;j&lt;/code&gt; , которые являются допустимыми индексами символов. При наличии только одного строкового аргумента вычисляется количество символов во всей строке. С аргументами &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; он вычисляет количество индексов от &lt;code&gt;i&lt;/code&gt; до &lt;code&gt;j&lt;/code&gt; включительно, которые являются допустимыми индексами в строке &lt;code&gt;s&lt;/code&gt; . В дополнение к входящим значениям, &lt;code&gt;i&lt;/code&gt; может принимать значение за пределами границ &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; а &lt;code&gt;j&lt;/code&gt; может принимать значение за пределами границ &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="716e2de76c8a5d41901615633885a66308369487" translate="yes" xml:space="preserve">
          <source>The number of execution threads is controlled either by using the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument or by using the &lt;a href=&quot;../environment-variables/index#JULIA_NUM_THREADS&quot;&gt;&lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt;&lt;/a&gt; environment variable. When both are specified, then &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; takes precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad86f1d6f640919b745cf8a5f2bdcf26fd5ffb5" translate="yes" xml:space="preserve">
          <source>The number of hard links to the file</source>
          <target state="translated">Количество жестких ссылок на файл</target>
        </trans-unit>
        <trans-unit id="24a208f4a834f5901bdf25637d96fa3b819cf46a" translate="yes" xml:space="preserve">
          <source>The number of items in each dimension, if known</source>
          <target state="translated">Количество элементов в каждом измерении,если известно.</target>
        </trans-unit>
        <trans-unit id="eba5aa4a440d944ee0ac4bd42c3f98d0088c8d6f" translate="yes" xml:space="preserve">
          <source>The number of items, if known</source>
          <target state="translated">Количество единиц,если известно</target>
        </trans-unit>
        <trans-unit id="fd0b7f33e8f96892366bb012a5417e87ca9ea66f" translate="yes" xml:space="preserve">
          <source>The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;hyper-threading&lt;/a&gt;.</source>
          <target state="translated">Количество логических ядер ЦП, доступных в системе, т. Е. Количество потоков, которые ЦП может выполнять одновременно. Обратите внимание, что это не обязательно количество ядер ЦП, например, при наличии &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;гиперпоточности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e345fe9c2de9253c74f924ce4e5ac488569c4e0e" translate="yes" xml:space="preserve">
          <source>The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; in the worker process's environment. Relevant only when using TCP/IP as transport.</source>
          <target state="translated">Количество секунд, в течение которых только что запущенный рабочий процесс ожидает установления соединения от мастера, можно указать с помощью переменной &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; в среде рабочего процесса. Актуально только при использовании TCP / IP в качестве транспорта.</target>
        </trans-unit>
        <trans-unit id="f364903fb4c2618f3b395fcdcccd998ed24fc310" translate="yes" xml:space="preserve">
          <source>The number of sequential code characters indicate the width of the code. A format of &lt;code&gt;yyyy-mm&lt;/code&gt; specifies that the code &lt;code&gt;y&lt;/code&gt; should have a width of four while &lt;code&gt;m&lt;/code&gt; a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401c50950c464431455634fa5427d8b16913972d" translate="yes" xml:space="preserve">
          <source>The number of such blocks allocated</source>
          <target state="translated">Количество таких блоков,выделенных</target>
        </trans-unit>
        <trans-unit id="e8e81fb72f02f0f0604e2587ad1458b114eaf4e4" translate="yes" xml:space="preserve">
          <source>The number of threads Julia starts up with is controlled by an environment variable called &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt;. Now, let's start up Julia with 4 threads:</source>
          <target state="translated">Количество потоков, с которых запускается Джулия, контролируется переменной окружения &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt; . Теперь давайте запустим Юлю с 4 потоками:</target>
        </trans-unit>
        <trans-unit id="b54c4650ad40754cdcfd0146457d2a4950f0fa52" translate="yes" xml:space="preserve">
          <source>The number of threads specified with &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; is propagated to worker processes that are spawned using the &lt;code&gt;-p&lt;/code&gt;/&lt;code&gt;--procs&lt;/code&gt; or &lt;code&gt;--machine-file&lt;/code&gt; command line options. For example, &lt;code&gt;julia -p2 -t2&lt;/code&gt; spawns 1 main process with 2 worker processes, and all three processes have 2 threads enabled. For more fine grained control over worker threads use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; and pass &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; as &lt;code&gt;exeflags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85834b4873990e0b8a9335e254e4dd1dde6aed2" translate="yes" xml:space="preserve">
          <source>The number of times a generated function is generated &lt;em&gt;might&lt;/em&gt; be only once, but it &lt;em&gt;might&lt;/em&gt; also be more often, or appear to not happen at all. As a consequence, you should &lt;em&gt;never&lt;/em&gt; write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; in a generated function is a sign that you're doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, so it is disallowed.</source>
          <target state="translated">Количество раз , генерируемая функция генерируется &lt;em&gt;может&lt;/em&gt; быть только один раз, но это &lt;em&gt;может&lt;/em&gt; также быть более часто, или по- видимому, не происходит вообще. Как следствие, вы &lt;em&gt;никогда не&lt;/em&gt; должны писать сгенерированную функцию с побочными эффектами - когда и как часто возникают побочные эффекты, не определено. (Это верно и для макросов - и, как и для макросов, использование &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; в сгенерированной функции является признаком того, что вы делаете что-то неправильно.) Однако, в отличие от макросов, система времени выполнения не может правильно обработать вызов &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; , поэтому он запрещен.</target>
        </trans-unit>
        <trans-unit id="0ae813381c0022ace29605243aaae816db8d2b62" translate="yes" xml:space="preserve">
          <source>The object has three fields:</source>
          <target state="translated">Объект имеет три поля:</target>
        </trans-unit>
        <trans-unit id="f26db4e1766d8278e77cd687e2593b52ae02c589" translate="yes" xml:space="preserve">
          <source>The object has two fields:</source>
          <target state="translated">У объекта есть два поля:</target>
        </trans-unit>
        <trans-unit id="4d6829e15fd876880334e8233e7664c2c9a74a93" translate="yes" xml:space="preserve">
          <source>The object iterated over in a &lt;code&gt;@simd for&lt;/code&gt; loop should be a one-dimensional range. By using &lt;code&gt;@simd&lt;/code&gt;, you are asserting several properties of the loop:</source>
          <target state="translated">Объект, повторяемый в &lt;code&gt;@simd for&lt;/code&gt; должен быть одномерным диапазоном. Используя &lt;code&gt;@simd&lt;/code&gt; , вы утверждаете несколько свойств цикла:</target>
        </trans-unit>
        <trans-unit id="ea26212270cffda304c1ae7e1979fbd52cf41822" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;Sampler&lt;/code&gt; is then used to generate the random values. When implementing the random generation interface for a value &lt;code&gt;X&lt;/code&gt; that can be sampled from, the implementor should define the method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a81b0cbf6e9a0a37ccae194bb527cb1e3d2158" translate="yes" xml:space="preserve">
          <source>The objects called do not have matching dimensionality. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">Вызываемые объекты не имеют соответствующей размерности. Необязательный аргумент &lt;code&gt;msg&lt;/code&gt; - это описательная строка ошибки.</target>
        </trans-unit>
        <trans-unit id="c67a85d00391dfa4e34905a89b16c12f29c02b01" translate="yes" xml:space="preserve">
          <source>The one-line sentence should use the imperative form (&quot;Do this&quot;, &quot;Return that&quot;) instead of the third person (do not write &quot;Returns the length...&quot;) when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).</source>
          <target state="translated">При документировании функций в однострочном предложении вместо третьего лица (не пишите &quot;Возвращает длину...&quot;)должна использоваться императивная форма (&quot;Сделать это&quot;,&quot;Вернуть то&quot;).Оно должно заканчиваться периодом.Если значение функции не может быть легко обобщено,было бы полезно разделить ее на отдельные составные части (хотя это не должно рассматриваться как абсолютное требование в каждом отдельном случае).</target>
        </trans-unit>
        <trans-unit id="b6ddf67182af91ce5f2d607a93387a34e5a2b0e5" translate="yes" xml:space="preserve">
          <source>The only exception to the use of &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.</source>
          <target state="translated">Единственное исключение из использования &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; в качестве эпохи округления - это округление до недель. Округление до ближайшей недели всегда возвращает понедельник (первый день недели, как указано в ISO 8601). По этой причине мы используем &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (первый день первой недели года 0000, как определено в ISO 8601) в качестве основы при округлении до числа недель.</target>
        </trans-unit>
        <trans-unit id="9363f36d4f2b17a0031fe8893a1c08b698e154a6" translate="yes" xml:space="preserve">
          <source>The only explicitly disallowed names for variables are the names of built-in statements:</source>
          <target state="translated">Единственные явно запрещенные имена переменных-это имена встроенных операторов:</target>
        </trans-unit>
        <trans-unit id="b9cae3e1b35cbcfdc4d7bd5b2d0c389c2d667286" translate="yes" xml:space="preserve">
          <source>The only explicitly disallowed names for variables are the names of the built-in &lt;a href=&quot;../../base/base/index#Keywords&quot;&gt;Keywords&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a96430cabd292322cdf6d0ab2a28460461ca0e" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;=&lt;/code&gt; always returns the right-hand side, therefore:</source>
          <target state="translated">Оператор &lt;code&gt;=&lt;/code&gt; всегда возвращает правую часть, поэтому:</target>
        </trans-unit>
        <trans-unit id="61c61a08879a6bdf3c24805cb6233ff2beffb8f1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; are non-associative. &lt;code&gt;a + b + c&lt;/code&gt; is parsed as &lt;code&gt;+(a, b, c)&lt;/code&gt; not &lt;code&gt;+(+(a, b), c)&lt;/code&gt;. However, the fallback methods for &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; and &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; both default to left-associative evaluation.</source>
          <target state="translated">Операторы &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; неассоциативны. &lt;code&gt;a + b + c&lt;/code&gt; анализируется как &lt;code&gt;+(a, b, c)&lt;/code&gt; not &lt;code&gt;+(+(a, b), c)&lt;/code&gt; . Однако резервные методы для &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; и &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; умолчанию используют левоассоциативную оценку.</target>
        </trans-unit>
        <trans-unit id="107f84ddc83f3132ac9e7c776c3ad804db96f800" translate="yes" xml:space="preserve">
          <source>The optimal choice of absolute (&lt;code&gt;atol&lt;/code&gt;) and relative tolerance (&lt;code&gt;rtol&lt;/code&gt;) varies both with the value of &lt;code&gt;M&lt;/code&gt; and the intended application of the pseudoinverse. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Оптимальный выбор абсолютного ( &lt;code&gt;atol&lt;/code&gt; ) и относительного допуска ( &lt;code&gt;rtol&lt;/code&gt; ) зависит как от значения &lt;code&gt;M&lt;/code&gt; ,так и от предполагаемого применения псевдообратной формулы. Относительно допуска по умолчанию &lt;code&gt;n*ϵ&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; является размер наименьшего размера &lt;code&gt;M&lt;/code&gt; , а &lt;code&gt;ϵ&lt;/code&gt; является &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; типа элемента из &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2df9f292c890ebf432c888dc85d326e28ff79fa" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;chars&lt;/code&gt; указывает, какие символы следует удалить: это может быть один символ, вектор или набор символов.</target>
        </trans-unit>
        <trans-unit id="58713c9681927cdb79ff5aaa798bc3500eccfa8e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, vector or set of characters.</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;chars&lt;/code&gt; указывает, какие символы следует удалить: это может быть один символ, вектор или набор символов.</target>
        </trans-unit>
        <trans-unit id="7d04d2d866b93a37d08384445eed5a33ef5a6c88" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;esc&lt;/code&gt; argument specifies any additional characters that should also be escaped by a prepending backslash (&lt;code&gt;&quot;&lt;/code&gt; is also escaped by default in the first form).</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;esc&lt;/code&gt; указывает любые дополнительные символы, которые также следует экранировать с помощью предшествующей обратной косой черты ( &lt;code&gt;&quot;&lt;/code&gt; также экранируется по умолчанию в первой форме).</target>
        </trans-unit>
        <trans-unit id="194efabb3b5dd2732e2e6600190698fedd3b0069" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;procs&lt;/code&gt; allows specifying a subset of all processes to have execute the expression.</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;procs&lt;/code&gt; позволяет указать подмножество всех процессов, которые должны выполнять выражение.</target>
        </trans-unit>
        <trans-unit id="880714bb7ddfa7f3f83801253a212b4edc50e2e9" translate="yes" xml:space="preserve">
          <source>The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.</source>
          <target state="translated">Необязательная строка деклараций содержит объявления внешних функций,которые необходимы для того,чтобы компания llvm могла скомпилировать IR-строку.Несколько деклараций могут быть переданы путем разделения их с помощью разрывов строк.</target>
        </trans-unit>
        <trans-unit id="93222f7e28d28cf59587027443a25e2c729448bc" translate="yes" xml:space="preserve">
          <source>The optional first argument &lt;code&gt;mapexpr&lt;/code&gt; can be used to transform the included code before it is evaluated: for each parsed expression &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;code&lt;/code&gt;, the &lt;code&gt;include_string&lt;/code&gt; function actually evaluates &lt;code&gt;mapexpr(expr)&lt;/code&gt;. If it is omitted, &lt;code&gt;mapexpr&lt;/code&gt; defaults to &lt;a href=&quot;#Base.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03b28806b3d651a4fd6d7abdbe690fb63800e14" translate="yes" xml:space="preserve">
          <source>The optional first argument &lt;code&gt;mapexpr&lt;/code&gt; can be used to transform the included code before it is evaluated: for each parsed expression &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;path&lt;/code&gt;, the &lt;code&gt;include&lt;/code&gt; function actually evaluates &lt;code&gt;mapexpr(expr)&lt;/code&gt;. If it is omitted, &lt;code&gt;mapexpr&lt;/code&gt; defaults to &lt;a href=&quot;#Base.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d319e50b1de0ad66b05495c666753f05c93c4fb2" translate="yes" xml:space="preserve">
          <source>The optional flags argument is a bitwise-or of zero or more of &lt;code&gt;RTLD_LOCAL&lt;/code&gt;, &lt;code&gt;RTLD_GLOBAL&lt;/code&gt;, &lt;code&gt;RTLD_LAZY&lt;/code&gt;, &lt;code&gt;RTLD_NOW&lt;/code&gt;, &lt;code&gt;RTLD_NODELETE&lt;/code&gt;, &lt;code&gt;RTLD_NOLOAD&lt;/code&gt;, &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt;, and &lt;code&gt;RTLD_FIRST&lt;/code&gt;. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default &lt;code&gt;dlopen&lt;/code&gt; flags are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; while on other platforms the defaults are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt;. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</source>
          <target state="translated">Необязательный аргумент flags является побитовым или равным нулю или более из &lt;code&gt;RTLD_LOCAL&lt;/code&gt; , &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; , &lt;code&gt;RTLD_LAZY&lt;/code&gt; , &lt;code&gt;RTLD_NOW&lt;/code&gt; , &lt;code&gt;RTLD_NODELETE&lt;/code&gt; , &lt;code&gt;RTLD_NOLOAD&lt;/code&gt; , &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt; и &lt;code&gt;RTLD_FIRST&lt;/code&gt; . Они преобразуются в соответствующие флаги команды dlopen POSIX (и / или GNU libc и / или MacOS), если это возможно, или игнорируются, если указанные функции недоступны на текущей платформе. Флаги по умолчанию зависят от платформы. По умолчанию MacOS на &lt;code&gt;dlopen&lt;/code&gt; флаги &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; в то время как на других платформах по умолчанию являются &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt; , Важное использование этих флагов - указать поведение, отличное от поведения по умолчанию, когда загрузчик динамической библиотеки связывает ссылки библиотеки с экспортируемыми символами и если связанные ссылки помещаются в локальную или глобальную область процесса. Например, &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; позволяет символам библиотеки быть доступными для использования в других разделяемых библиотеках, обращаясь к ситуациям, когда существуют зависимости между разделяемыми библиотеками.</target>
        </trans-unit>
        <trans-unit id="6852910866895c99e590be9b40672a6aa6893cd3" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;f&lt;/code&gt;. The optional &lt;code&gt;sizehint&lt;/code&gt; is a suggested size (in bytes) to allocate for the buffer used to write the string.</source>
          <target state="translated">Необязательный &lt;code&gt;context&lt;/code&gt; аргумента ключевого слова может иметь значение &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair или объект &lt;code&gt;IO&lt;/code&gt; или &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; , атрибуты которого используются для потока ввода / вывода, передаваемого в &lt;code&gt;f&lt;/code&gt; . Необязательный &lt;code&gt;sizehint&lt;/code&gt; - это рекомендуемый размер (в байтах) для выделения буфера, используемого для записи строки.</target>
        </trans-unit>
        <trans-unit id="dcac34ba486f2b65b96a033b6cb20a0748bc3d60" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">Необязательный &lt;code&gt;context&lt;/code&gt; аргумента ключевого слова может быть установлен в &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; пара значений или объект &lt;code&gt;IO&lt;/code&gt; или &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; , атрибуты которого используются для потока ввода-вывода, передаваемого для &lt;code&gt;show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5605ad644c7f46c7d640d10514c1e111f9c1381" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">Необязательный &lt;code&gt;context&lt;/code&gt; аргумента ключевого слова может быть установлен в &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; пара значений или объект &lt;code&gt;IO&lt;/code&gt; или &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; , атрибуты которого используются для потока ввода-вывода, передаваемого для &lt;code&gt;show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b019c5488e0a6b54b72c3dc4970022b5261bd3cf" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;writefunc&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="translated">Необязательный &lt;code&gt;context&lt;/code&gt; аргумента ключевого слова может иметь значение &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair или объект &lt;code&gt;IO&lt;/code&gt; или &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; , атрибуты которого используются для потока ввода-вывода, передаваемого функции &lt;code&gt;writefunc&lt;/code&gt; или &lt;code&gt;write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79723906c1f968e609f55475d1035da056cea38f" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">Необязательный &lt;code&gt;context&lt;/code&gt; аргумента ключевого слова может быть установлен как объект &lt;code&gt;IO&lt;/code&gt; или &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; , атрибуты которого используются для потока ввода-вывода, передаваемого для &lt;code&gt;show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d024d8ad27a045cd403adcafbb8a97939e2259d" translate="yes" xml:space="preserve">
          <source>The optional keyword arguments are:</source>
          <target state="translated">Необязательными являются аргументы по ключевым словам:</target>
        </trans-unit>
        <trans-unit id="7277b33c208d262f473b8b03d8c039301737232a" translate="yes" xml:space="preserve">
          <source>The optional list of &lt;code&gt;key=value&lt;/code&gt; pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record. If only a &lt;code&gt;value&lt;/code&gt; expression is supplied, a key representing the expression will be generated using &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;x=x&lt;/code&gt;, and &lt;code&gt;foo(10)&lt;/code&gt; becomes &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt;. For splatting a list of key value pairs, use the normal splatting syntax, &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt;.</source>
          <target state="translated">Необязательный список пар &lt;code&gt;key=value&lt;/code&gt; поддерживает произвольные определяемые пользователем метаданные, которые будут переданы в серверную часть ведения журнала как часть записи журнала. Если указано только выражение &lt;code&gt;value&lt;/code&gt; , ключ, представляющий выражение, будет сгенерирован с использованием &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; . Например, &lt;code&gt;x&lt;/code&gt; становится &lt;code&gt;x=x&lt;/code&gt; , а &lt;code&gt;foo(10)&lt;/code&gt; становится &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt; . Для splatting список пар ключ - значение, используйте обычный splatting синтаксис, &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01ff66cb9afdd1acbcec4725d95eb63b3a880ae3" translate="yes" xml:space="preserve">
          <source>The optional second argument restricts the search to a particular module or function (the default is all top-level modules).</source>
          <target state="translated">Необязательный второй аргумент ограничивает поиск определенным модулем или функцией (по умолчанию все модули верхнего уровня).</target>
        </trans-unit>
        <trans-unit id="d7be768e27f40f1d8f5725cc3b53d8120d8d7888" translate="yes" xml:space="preserve">
          <source>The order of the output here is non-deterministic because the two &lt;code&gt;echo&lt;/code&gt; processes are started nearly simultaneously, and race to make the first write to the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; descriptor they share with each other and the &lt;code&gt;julia&lt;/code&gt; parent process. Julia lets you pipe the output from both of these processes to another program:</source>
          <target state="translated">Порядок вывода здесь не является детерминированным, потому что два &lt;code&gt;echo&lt;/code&gt; процесса запускаются почти одновременно и стремятся сделать первую запись в дескриптор &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; ,который&lt;/a&gt; они разделяют друг с другом и с родительским процессом &lt;code&gt;julia&lt;/code&gt; . Джулия позволяет передавать вывод обоих этих процессов другой программе:</target>
        </trans-unit>
        <trans-unit id="7e6b1ba87ceb124ce09bfd4687b3d3e543a9688a" translate="yes" xml:space="preserve">
          <source>The ordinary way to index into an &lt;code&gt;N&lt;/code&gt;-dimensional array is to use exactly &lt;code&gt;N&lt;/code&gt; indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt;, &lt;code&gt;A[2, 3, 1]&lt;/code&gt; will select the number in the second row of the third column in the first &quot;page&quot; of the array. This is often referred to as &lt;em&gt;cartesian indexing&lt;/em&gt;.</source>
          <target state="translated">Обычный способ индексации в &lt;code&gt;N&lt;/code&gt; - мерный массив - использовать ровно &lt;code&gt;N&lt;/code&gt; индексов; каждый индекс выбирает позицию (позиции) в своем конкретном измерении. Например, в трехмерном массиве &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt; , &lt;code&gt;A[2, 3, 1]&lt;/code&gt; выберет номер во второй строке третьего столбца на первой &amp;laquo;странице&amp;raquo; массива. Это часто называют &lt;em&gt;декартовой индексацией&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="337d87d83fb3b26581b3bec9243dd5ba69ee3d14" translate="yes" xml:space="preserve">
          <source>The overflow protection may impose a perceptible performance penalty.</source>
          <target state="translated">Защита от перелива может повлечь за собой ощутимый штраф за исполнение.</target>
        </trans-unit>
        <trans-unit id="9a42e1576587fc87b690dd06577854cd76250509" translate="yes" xml:space="preserve">
          <source>The parameters of a &lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;parametric type&lt;/a&gt; can hold either types or bits values, and the type itself chooses how it makes use of these parameters. For example, &lt;code&gt;Array{Float64, 2}&lt;/code&gt; is parameterized by the type &lt;code&gt;Float64&lt;/code&gt; to express its element type and the integer value &lt;code&gt;2&lt;/code&gt; to express its number of dimensions. When defining your own parametric type, you can use subtype constraints to declare that a certain parameter must be a subtype (&lt;code&gt;&amp;lt;:&lt;/code&gt;) of some abstract type or a previous type parameter. There is not, however, a dedicated syntax to declare that a parameter must be a &lt;em&gt;value&lt;/em&gt; of a given type &amp;mdash; that is, you cannot directly declare that a dimensionality-like parameter &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Int&lt;/code&gt; within the &lt;code&gt;struct&lt;/code&gt; definition, for example. Similarly, you cannot do computations (including simple things like addition or subtraction) on type parameters. Instead, these sorts of constraints and relationships may be expressed through additional type parameters that are computed and enforced within the type's &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;constructors&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d86a00557c452d14c3435e0e6cf89aff65b0c2" translate="yes" xml:space="preserve">
          <source>The parameters to a function call do not match a valid signature. Argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">Параметры вызова функции не соответствуют действительной подписи. &lt;code&gt;msg&lt;/code&gt; аргумента - это описательная строка ошибки.</target>
        </trans-unit>
        <trans-unit id="b40e124fc4416cc6b2725b908dd2c2071926bcac" translate="yes" xml:space="preserve">
          <source>The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd165da81710969d9eacb18af008ac2650e61e9" translate="yes" xml:space="preserve">
          <source>The path to the file containing the execution context.</source>
          <target state="translated">Путь к файлу,содержащему контекст выполнения.</target>
        </trans-unit>
        <trans-unit id="cd91887e0e75258a20a4164a826e358b38427c66" translate="yes" xml:space="preserve">
          <source>The paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire &lt;code&gt;X&lt;/code&gt; by looking up &lt;code&gt;paths[uuid,:X]&lt;/code&gt; in the environment. Including this file should define a module named &lt;code&gt;X&lt;/code&gt;. Once this package is loaded, any subsequent import resolving to the same &lt;code&gt;uuid&lt;/code&gt; will create a new binding to the already-loaded package module.</source>
          <target state="translated">Карта путей назначает каждой паре UUID-имя пакета расположение исходного файла точки входа этого пакета. После того, как идентификатор &lt;code&gt;X&lt;/code&gt; в &lt;code&gt;import X&lt;/code&gt; был преобразован в UUID через корни или граф (в зависимости от того, загружен ли он из основного проекта или из зависимости), Джулия определяет, какой файл загрузить для получения &lt;code&gt;X&lt;/code&gt; , просматривая &lt;code&gt;paths[uuid,:X]&lt;/code&gt; в окружении. В том числе и этот файл должен определить модуль с именем &lt;code&gt;X&lt;/code&gt; . После загрузки этого пакета любое последующее разрешение импорта на тот же &lt;code&gt;uuid&lt;/code&gt; создаст новую привязку к уже загруженному модулю пакета.</target>
        </trans-unit>
        <trans-unit id="b2b8c82c38ec794200c611dc44cc4f20a1bd32a9" translate="yes" xml:space="preserve">
          <source>The pipe operator can also be used with broadcasting, as &lt;code&gt;.|&amp;gt;&lt;/code&gt;, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).</source>
          <target state="translated">Оператор канала также может использоваться с широковещательной передачей, например &lt;code&gt;.|&amp;gt;&lt;/code&gt; , Чтобы обеспечить полезную комбинацию синтаксиса цепочки / конвейерной передачи и точечной векторизации (описывается далее).</target>
        </trans-unit>
        <trans-unit id="597af63e387a0238ac0d63febd38bda10ccc2c0b" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try/catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt;&lt;code&gt;rethrow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; functions for more advanced error handling.</source>
          <target state="translated">Сила конструкции &lt;code&gt;try/catch&lt;/code&gt; заключается в возможности немедленно развернуть глубоко вложенное вычисление на гораздо более высокий уровень в стеке вызывающих функций. Бывают ситуации, когда ошибки не возникает, но желательна возможность раскрутить стек и передать значение на более высокий уровень. Джулия предоставляет функции &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt; &lt;code&gt;rethrow&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt; для более продвинутой обработки ошибок.</target>
        </trans-unit>
        <trans-unit id="8f828dfaf86a71af5078c4fd81a7efaae2debb74" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.</source>
          <target state="translated">Сила конструкции &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; заключается в возможности немедленно развернуть глубоко вложенное вычисление на гораздо более высокий уровень в стеке вызывающих функций.</target>
        </trans-unit>
        <trans-unit id="8c0dcb26b25cdb065ec42a8e6b69fc74bd648292" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So &lt;code&gt;-2x&lt;/code&gt; is parsed as &lt;code&gt;(-2) * x&lt;/code&gt; and &lt;code&gt;&amp;radic;2x&lt;/code&gt; is parsed as &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt;. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example &lt;code&gt;2^3x&lt;/code&gt; is parsed as &lt;code&gt;2^(3x)&lt;/code&gt;, and &lt;code&gt;2x^3&lt;/code&gt; is parsed as &lt;code&gt;2*(x^3)&lt;/code&gt;.</source>
          <target state="translated">Приоритет числовых буквальных коэффициентов немного ниже, чем у унарных операторов, таких как отрицание. Итак, &lt;code&gt;-2x&lt;/code&gt; анализируется как &lt;code&gt;(-2) * x&lt;/code&gt; а &lt;code&gt;&amp;radic;2x&lt;/code&gt; анализируется как &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt; . Однако числовые буквальные коэффициенты анализируются аналогично унарным операторам в сочетании с возведением в степень. Например, &lt;code&gt;2^3x&lt;/code&gt; анализируется как &lt;code&gt;2^(3x)&lt;/code&gt; , а &lt;code&gt;2x^3&lt;/code&gt; анализируется как &lt;code&gt;2*(x^3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8950edc0252b4e5921bc89b4f858ec39c03063d6" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (&lt;code&gt;*&lt;/code&gt;), and division (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;//&lt;/code&gt;). This means, for example, that &lt;code&gt;1 / 2im&lt;/code&gt; equals &lt;code&gt;-0.5im&lt;/code&gt; and &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; equals &lt;code&gt;1 // 1&lt;/code&gt;.</source>
          <target state="translated">Приоритет числовых буквальных коэффициентов, используемых для неявного умножения, выше, чем у других бинарных операторов, таких как умножение ( &lt;code&gt;*&lt;/code&gt; ) и деление ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; и &lt;code&gt;//&lt;/code&gt; ). Это означает, например, что &lt;code&gt;1 / 2im&lt;/code&gt; равно &lt;code&gt;-0.5im&lt;/code&gt; а &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; равно &lt;code&gt;1 // 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6252a13083e6a8d33233a629a05884040274a8ff" translate="yes" xml:space="preserve">
          <source>The precedence rules are defined by binary &lt;code&gt;BroadcastStyle&lt;/code&gt; calls:</source>
          <target state="translated">Правила приоритета определяются двоичными вызовами &lt;code&gt;BroadcastStyle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56837dd60f637c33dd3845553e8ea84690fc189a" translate="yes" xml:space="preserve">
          <source>The preferred style is to use instances by default, and only add methods involving &lt;code&gt;Type{MyType}&lt;/code&gt; later if they become necessary to solve some problem.</source>
          <target state="translated">Предпочтительным стилем является использование экземпляров по умолчанию и добавление методов, включающих &lt;code&gt;Type{MyType}&lt;/code&gt; позже, если они необходимы для решения какой-либо проблемы.</target>
        </trans-unit>
        <trans-unit id="279b514949e6ab10ca4a0b3d36a0afc9aa5e5bfd" translate="yes" xml:space="preserve">
          <source>The prefix operator &lt;code&gt;∛&lt;/code&gt; is equivalent to &lt;code&gt;cbrt&lt;/code&gt;.</source>
          <target state="translated">Префиксный оператор &lt;code&gt;∛&lt;/code&gt; эквивалентен &lt;code&gt;cbrt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ebef4458176844838b02e2b993df5f493f0829" translate="yes" xml:space="preserve">
          <source>The primary function used to obtain a stack trace is &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Основная функция, используемая для получения трассировки стека, - это &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e24543b8a6898ccaa9bbcf1e800fb858e73daf75" translate="yes" xml:space="preserve">
          <source>The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, which applies a function to each value of an array and returns a new array containing the resulting values:</source>
          <target state="translated">Основное использование анонимных функций - передача их функциям, которые принимают другие функции в качестве аргументов. Классическим примером является &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; , которая применяет функцию к каждому значению массива и возвращает новый массив, содержащий полученные значения:</target>
        </trans-unit>
        <trans-unit id="fc2c54892fd31e8ed27deff8fd6635a872466a56" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; depends on the &lt;code&gt;Pub&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages.</source>
          <target state="translated">Частный &lt;code&gt;Priv&lt;/code&gt; зависит от пакетов &lt;code&gt;Pub&lt;/code&gt; и &lt;code&gt;Zebra&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f74ae0037646d4d3ed052aa7f6f3acf520af197" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; package is &quot;&lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;vendored&lt;/a&gt;&quot; inside the &lt;code&gt;App&lt;/code&gt; repository.</source>
          <target state="translated">Частный &lt;code&gt;Priv&lt;/code&gt; пакет &amp;laquo; &lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;vendored&lt;/a&gt; &amp;raquo; внутри &lt;code&gt;App&lt;/code&gt; хранилища.</target>
        </trans-unit>
        <trans-unit id="661f073fc5da6760e6d7e4ab5f75f9c8ff27e153" translate="yes" xml:space="preserve">
          <source>The problem is that now any other module that uses &lt;code&gt;Base.*&lt;/code&gt; will also see this definition. Since &lt;code&gt;Symbol&lt;/code&gt; is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the &lt;code&gt;Symbol&lt;/code&gt;s in another type that you define.</source>
          <target state="translated">Проблема в том, что теперь любой другой модуль, использующий &lt;code&gt;Base.*&lt;/code&gt; , Также увидит это определение. Поскольку &lt;code&gt;Symbol&lt;/code&gt; определен в Base и используется другими модулями, это может неожиданно изменить поведение несвязанного кода. Здесь есть несколько альтернатив, включая использование другого имени функции или перенос &lt;code&gt;Symbol&lt;/code&gt; в другой тип, который вы определяете.</target>
        </trans-unit>
        <trans-unit id="285d72365829e919fd96051079cd8653575f8845" translate="yes" xml:space="preserve">
          <source>The problem is that users of this type can write &lt;code&gt;x[i]&lt;/code&gt; without realizing that the operation is unsafe, and then be susceptible to memory bugs.</source>
          <target state="translated">Проблема в том, что пользователи этого типа могут записать &lt;code&gt;x[i]&lt;/code&gt; не осознавая, что операция небезопасна, и тогда они будут подвержены ошибкам памяти.</target>
        </trans-unit>
        <trans-unit id="645c5293b137aedcba8417381b97d9b765e077f5" translate="yes" xml:space="preserve">
          <source>The problem is that we want &lt;code&gt;S&lt;/code&gt; to be a larger type than &lt;code&gt;T&lt;/code&gt;, so that we can sum many elements with less information loss. For example, when &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, we would like &lt;code&gt;S&lt;/code&gt; to be &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. Therefore we want to avoid an interface that allows the user to construct instances of the type &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt;. One way to do this is to provide a constructor only for &lt;code&gt;SummedArray&lt;/code&gt;, but inside the &lt;code&gt;struct&lt;/code&gt; definition block to suppress generation of default constructors:</source>
          <target state="translated">Проблема в том, что мы хотим, чтобы &lt;code&gt;S&lt;/code&gt; был более крупным типом, чем &lt;code&gt;T&lt;/code&gt; , чтобы мы могли суммировать множество элементов с меньшими потерями информации. Например, когда &lt;code&gt;T&lt;/code&gt; равно &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; , мы хотели бы, чтобы &lt;code&gt;S&lt;/code&gt; был &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . Поэтому мы хотим избежать интерфейса, который позволяет пользователю создавать экземпляры типа &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt; . Один из способов сделать это , чтобы обеспечить конструктор только для &lt;code&gt;SummedArray&lt;/code&gt; , но внутри &lt;code&gt;struct&lt;/code&gt; блока определения для подавления генерации конструкторов по умолчанию:</target>
        </trans-unit>
        <trans-unit id="fa9c416e3dd0eb96ee39260398af255d4af83ab0" translate="yes" xml:space="preserve">
          <source>The process id, &lt;code&gt;pid&lt;/code&gt;, associated with a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; identifies the process where the backing store, i.e., the backing &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; exists.</source>
          <target state="translated">Идентификатор процесса, &lt;code&gt;pid&lt;/code&gt; , связанный с &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; ,&lt;/a&gt; идентифицирует процесс, в котором существует резервное хранилище, то есть поддерживающий &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5711338a1a6b237dd10b96c18908bc64ecaf369" translate="yes" xml:space="preserve">
          <source>The process was stopped by a terminal interrupt (CTRL+C).</source>
          <target state="translated">Процесс был остановлен терминальным прерыванием (CTRL+C).</target>
        </trans-unit>
        <trans-unit id="333bddf0932a24c46f8668b521deb6c3a862550f" translate="yes" xml:space="preserve">
          <source>The program name and the individual arguments in a command can be accessed and iterated over as if the command were an array of strings:</source>
          <target state="translated">Имя программы и отдельные аргументы в команде могут быть доступны и итерацией,как если бы команда представляла собой массив строк:</target>
        </trans-unit>
        <trans-unit id="50007e3abed58b9e198eabc930fa126c0f7f28e5" translate="yes" xml:space="preserve">
          <source>The promotion mechanism ensures that combinations of operands of different types just work:</source>
          <target state="translated">Механизм продвижения гарантирует,что комбинации операндов разных типов просто работают:</target>
        </trans-unit>
        <trans-unit id="970007866f1b490fa6101a3c913eb7623d70c629" translate="yes" xml:space="preserve">
          <source>The protection mode of the file</source>
          <target state="translated">Режим защиты файла</target>
        </trans-unit>
        <trans-unit id="717c22bfef5d2282d64a55d9c60b43bea19c9cf1" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.</source>
          <target state="translated">Публичные пакеты &lt;code&gt;Priv&lt;/code&gt; и &lt;code&gt;Zebra&lt;/code&gt; находятся в системном хранилище, где находятся пакеты, установленные и управляемые системным администратором. Они доступны всем пользователям системы.</target>
        </trans-unit>
        <trans-unit id="1a1630b90939dc1ab04b673570b84792ee8ae787" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; has no dependencies.</source>
          <target state="translated">Публичный &lt;code&gt;Priv&lt;/code&gt; не имеет зависимостей.</target>
        </trans-unit>
        <trans-unit id="3a76e9ce5367492b5b8cf13bb66130558721cade" translate="yes" xml:space="preserve">
          <source>The quotient and remainder from Euclidean division. Equivalent to &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; or &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt;.</source>
          <target state="translated">Частное и остаток от евклидова деления. Эквивалентно &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; или &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f9488bd5101beaf4e5a34c2556e267d19b64d59" translate="yes" xml:space="preserve">
          <source>The quotient and remainder from Euclidean division. Equivalent to &lt;code&gt;(div(x,y,r), rem(x,y,r))&lt;/code&gt;. Equivalently, with the default value of &lt;code&gt;r&lt;/code&gt;, this call is equivalent to &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c852eff7359c80d607981a449403f86f7a08aae5" translate="yes" xml:space="preserve">
          <source>The quotient from Euclidean division. Computes &lt;code&gt;x/y&lt;/code&gt;, truncated to an integer.</source>
          <target state="translated">Частное от евклидова деления. Вычисляет &lt;code&gt;x/y&lt;/code&gt; , усеченное до целого числа.</target>
        </trans-unit>
        <trans-unit id="b4ff83a45750ab4a00521d3b0c9044c246c68431" translate="yes" xml:space="preserve">
          <source>The rationale for this behavior is that &lt;code&gt;eps&lt;/code&gt; bounds the floating point rounding error. Under the default &lt;code&gt;RoundNearest&lt;/code&gt; rounding mode, if $y$ is a real number and $x$ is the nearest floating point number to $y$, then</source>
          <target state="translated">Причина такого поведения в том, что &lt;code&gt;eps&lt;/code&gt; ограничивает ошибку округления с плавающей запятой. В &lt;code&gt;RoundNearest&lt;/code&gt; округления RoundNearest по умолчанию , если $ y $ - действительное число, а $ x $ - ближайшее к $ y $ число с плавающей запятой, тогда</target>
        </trans-unit>
        <trans-unit id="fb9190d6f027ae9e2de06d7e334ba64d5fd44e85" translate="yes" xml:space="preserve">
          <source>The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use &lt;code&gt;import&lt;/code&gt;, then you'll replace the other module's implementation of &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).</source>
          <target state="translated">Причина, по которой это достаточно важно, чтобы иметь отдельный синтаксис, заключается в том, что вы не хотите случайно расширять функцию, о существовании которой вы не знали, потому что это может легко вызвать ошибку. Скорее всего, это произойдет с методом, который принимает общий тип, такой как строка или целое число, потому что и вы, и другой модуль можете определить метод для обработки такого общего типа. Если вы используете &lt;code&gt;import&lt;/code&gt; , вы замените реализацию &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; другого модуля своей новой реализацией, которая может легко сделать что-то совершенно другое (и нарушить все / многие будущие использования других функций в модуле Foo, которые зависит от панели вызова).</target>
        </trans-unit>
        <trans-unit id="234a82c9299a864e20ceee7dc728fbbfc62b4ff9" translate="yes" xml:space="preserve">
          <source>The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt;&lt;code&gt;closures&lt;/code&gt;&lt;/a&gt; which have private state, for instance the &lt;code&gt;state&lt;/code&gt; variable in the following example:</source>
          <target state="translated">Причина, по которой разрешается изменять локальные переменные родительских областей видимости во вложенных функциях, состоит в том, чтобы разрешить создание &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt; &lt;code&gt;closures&lt;/code&gt; &lt;/a&gt; которые имеют частное состояние, например, переменную &lt;code&gt;state&lt;/code&gt; в следующем примере:</target>
        </trans-unit>
        <trans-unit id="d42e24ea3d0e2aa6d81b7dd3b153611807fc05f4" translate="yes" xml:space="preserve">
          <source>The reasoning is that &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;, and likewise, the value of &lt;code&gt;a || b&lt;/code&gt; must be true if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;. Both &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; associate to the right, but &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; has higher precedence than &lt;code&gt;||&lt;/code&gt; does. It's easy to experiment with this behavior:</source>
          <target state="translated">Рассуждение , что &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; должно быть &lt;code&gt;false&lt;/code&gt; , если является &lt;code&gt;false&lt;/code&gt; , независимо от значения &lt;code&gt;b&lt;/code&gt; , и аналогично, значение &lt;code&gt;a || b&lt;/code&gt; должно быть истинным , если является &lt;code&gt;true&lt;/code&gt; , независимо от значения &lt;code&gt;b&lt;/code&gt; . Оба &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; ассоциируется справа, но &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;||&lt;/code&gt; делает. С таким поведением легко поэкспериментировать: &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95dede2db6b492fc138679b4d2d27fe223e4ffc1" translate="yes" xml:space="preserve">
          <source>The recommended use case is sampling from values with precomputed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b91e5f0c03fa313fd5905d982928a4cd89df69e" translate="yes" xml:space="preserve">
          <source>The recommended use case is sampling from values without precomputed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179e487486d1af4b87de97016bef8d4656b4ec67" translate="yes" xml:space="preserve">
          <source>The recommended ways to iterate over a whole array are</source>
          <target state="translated">Рекомендуется выполнять итерации по всему массиву.</target>
        </trans-unit>
        <trans-unit id="d82c055defbd84ff03cc2e56fef7d08819740213" translate="yes" xml:space="preserve">
          <source>The reduction of &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;y&lt;/code&gt;, or equivalently, the remainder of &lt;code&gt;x&lt;/code&gt; after floored division by &lt;code&gt;y&lt;/code&gt;, i.e. &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; if computed without intermediate rounding.</source>
          <target state="translated">Уменьшение &lt;code&gt;x&lt;/code&gt; по модулю &lt;code&gt;y&lt;/code&gt; или, что то же самое, остатка от &lt;code&gt;x&lt;/code&gt; после деления на &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; на &lt;code&gt;y&lt;/code&gt; , то есть x - y * fld (x, y), если вычислено без промежуточного округления.</target>
        </trans-unit>
        <trans-unit id="c7a083bb1a1b10ec23125171dedac6f03596ea4e" translate="yes" xml:space="preserve">
          <source>The relation defined by &lt;code&gt;isless&lt;/code&gt; is transitive, i.e., &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; implies &lt;code&gt;isless(x, z)&lt;/code&gt;.</source>
          <target state="translated">Отношение, определяемое &lt;code&gt;isless&lt;/code&gt; , транзитивно, т. &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; влечет &lt;code&gt;isless(x, z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae50d1ec149a5bb325ee3ed684413be8beb00545" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is</source>
          <target state="translated">Отношения между &lt;code&gt;F&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="357ff91ebaa3be4c787ab446d6ed56a0b9394db7" translate="yes" xml:space="preserve">
          <source>The remaining parameters are evaluated at compile time, when the containing method is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f134ecdeee3cfa777ccd458bfed97ec72082e75e" translate="yes" xml:space="preserve">
          <source>The remote cache is maintained for the lifetime of the returned &lt;code&gt;CachingPool&lt;/code&gt; object. To clear the cache earlier, use &lt;code&gt;clear!(pool)&lt;/code&gt;.</source>
          <target state="translated">Удаленный кеш поддерживается в течение всего времени существования возвращенного объекта &lt;code&gt;CachingPool&lt;/code&gt; . Чтобы очистить кеш раньше, используйте &lt;code&gt;clear!(pool)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df901bb294129f7627dac22ff5e80e400643c39f" translate="yes" xml:space="preserve">
          <source>The required keyword argument &lt;code&gt;var&lt;/code&gt; was not assigned in a function call.</source>
          <target state="translated">Обязательный аргумент ключевого слова &lt;code&gt;var&lt;/code&gt; не был назначен при вызове функции.</target>
        </trans-unit>
        <trans-unit id="a9f7acaee551d1164b11cacdb547b0da33902de6" translate="yes" xml:space="preserve">
          <source>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Результатом является указатель, дающий адрес значения. Значением можно управлять с помощью этого указателя, используя &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="03cc3e3ef7a55f891b2fdc37e1dca5251bee7ee1" translate="yes" xml:space="preserve">
          <source>The result is of type &lt;code&gt;Bool&lt;/code&gt;, except when one of the operands is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;). For collections, &lt;code&gt;missing&lt;/code&gt; is returned if at least one of the operands contains a &lt;code&gt;missing&lt;/code&gt; value and all non-missing values are equal. Use &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; to always get a &lt;code&gt;Bool&lt;/code&gt; result.</source>
          <target state="translated">Результат имеет тип &lt;code&gt;Bool&lt;/code&gt; , за исключением случаев, когда один из операндов &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , и в этом случае возвращается значение &lt;code&gt;missing&lt;/code&gt; ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначная логика&lt;/a&gt; ). Для коллекций возвращается &lt;code&gt;missing&lt;/code&gt; если хотя бы один из операндов содержит &lt;code&gt;missing&lt;/code&gt; значение и все не пропущенные значения равны. Используйте &lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; ,&lt;/a&gt; чтобы всегда получать результат типа &lt;code&gt;Bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c007650ed1d2ab98bda9d8f6e9d2a6696a562053" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;nextfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;prevfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;n&lt;/code&gt; итеративных применений &lt;code&gt;nextfloat&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; , если &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; , или &lt;code&gt;-n&lt;/code&gt; применений &lt;code&gt;prevfloat&lt;/code&gt; , если &lt;code&gt;n &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94b46c3b276e64ea98bedcc1b3f79ab9ebee8c1f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;prevfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;nextfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;n&lt;/code&gt; итеративных применений &lt;code&gt;prevfloat&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; , если &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; , или &lt;code&gt;-n&lt;/code&gt; применений &lt;code&gt;nextfloat&lt;/code&gt; , если &lt;code&gt;n &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b9604e81f6338ca5014cd5645d78240588116b2" translate="yes" xml:space="preserve">
          <source>The result of an expression is too large for the specified type and will cause a wraparound.</source>
          <target state="translated">Результат выражения слишком велик для указанного типа и приведет к обертыванию.</target>
        </trans-unit>
        <trans-unit id="5e37838dee3788d25d7398516d199b796b585b2f" translate="yes" xml:space="preserve">
          <source>The result of indexing an &lt;code&gt;AbstractArray&lt;/code&gt; can itself be an array (for instance when indexing by an &lt;code&gt;AbstractRange&lt;/code&gt;). The &lt;code&gt;AbstractArray&lt;/code&gt; fallback methods use &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; to allocate an &lt;code&gt;Array&lt;/code&gt; of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</source>
          <target state="translated">Результатом индексирования &lt;code&gt;AbstractArray&lt;/code&gt; может быть сам массив (например, при индексировании с помощью &lt;code&gt;AbstractRange&lt;/code&gt; ). В &lt;code&gt;AbstractArray&lt;/code&gt; FALLBACK методы используют &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; , чтобы выделить &lt;code&gt;Array&lt;/code&gt; соответствующего размера и типа элемента, который заполняется при помощи основной способ индексации описано выше. Однако при реализации обертки массива вы часто хотите, чтобы результат тоже был обернут:</target>
        </trans-unit>
        <trans-unit id="9dddd93bc0d8f1d83b952a56d60f4d4d4dde4922" translate="yes" xml:space="preserve">
          <source>The result will have the same sign as &lt;code&gt;y&lt;/code&gt;, and magnitude less than &lt;code&gt;abs(y)&lt;/code&gt; (with some exceptions, see note below).</source>
          <target state="translated">Результат будет иметь тот же знак, что и &lt;code&gt;y&lt;/code&gt; , и величину меньше, чем &lt;code&gt;abs(y)&lt;/code&gt; (за некоторыми исключениями, см. Примечание ниже).</target>
        </trans-unit>
        <trans-unit id="2e42d4dacc7dd604beaf0aa38148dabcfc4501d7" translate="yes" xml:space="preserve">
          <source>The resulting array type depends on the types of the computed elements just like &lt;a href=&quot;#man-array-literals&quot;&gt;array literals&lt;/a&gt; do. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f568e8a5a2b842636c272653d157a8edcd885b90" translate="yes" xml:space="preserve">
          <source>The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</source>
          <target state="translated">Результирующий тип массива зависит от типов вычисляемых элементов.Для явного контроля над типом можно подготовить тип для понимания.Например,можно запросить результат с одинаковой точностью при записи:</target>
        </trans-unit>
        <trans-unit id="ccd36a28a2ffb3965813bdc3900b2e91091344fd" translate="yes" xml:space="preserve">
          <source>The resulting container type is established by the following rules:</source>
          <target state="translated">Полученный тип контейнера устанавливается следующими правилами:</target>
        </trans-unit>
        <trans-unit id="1fe1a92416b8011a58e509306cdd809a4d7403bb" translate="yes" xml:space="preserve">
          <source>The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.</source>
          <target state="translated">Результаты идентичны,а интерполяционное поведение Джулии имитирует поведение оболочки с некоторыми улучшениями благодаря тому,что Джулия поддерживает первоклассные итерабельные объекты,в то время как большинство оболочек используют для этого строки,разделенные на пробелы,что вводит неоднозначности.При попытке перенести команды оболочки на Julia,сначала попробуйте вырезать и вставить.Так как Джулия показывает вам команды перед их выполнением,вы можете легко и безопасно просто изучить их интерпретацию,не нанося при этом никакого вреда.</target>
        </trans-unit>
        <trans-unit id="38f3a90d878f6adff0fab13415fb19f7e29771de" translate="yes" xml:space="preserve">
          <source>The return array's &lt;code&gt;eltype&lt;/code&gt; is &lt;code&gt;Int&lt;/code&gt; for signed integers of less than system word size and &lt;code&gt;UInt&lt;/code&gt; for unsigned integers of less than system word size. To preserve &lt;code&gt;eltype&lt;/code&gt; of arrays with small signed or unsigned integer &lt;code&gt;accumulate(+, A)&lt;/code&gt; should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9c7956c24febdcf914d416fae3a917b2f39e3e" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;Int&lt;/code&gt; for signed integers of less than system word size, and &lt;code&gt;UInt&lt;/code&gt; for unsigned integers of less than system word size. For all other arguments, a common return type is found to which all arguments are promoted.</source>
          <target state="translated">Тип возврата - &lt;code&gt;Int&lt;/code&gt; для целых чисел со &lt;code&gt;UInt&lt;/code&gt; размер которых меньше системного слова, и UInt для целых чисел без знака, размер которых меньше системного слова. Для всех остальных аргументов находится общий тип возвращаемого значения, в который продвигаются все аргументы.</target>
        </trans-unit>
        <trans-unit id="060ee76adfcb8c1b93eeb957a42add7f77612d3a" translate="yes" xml:space="preserve">
          <source>The return type of this macro was changed from &lt;code&gt;Tuple&lt;/code&gt; to &lt;code&gt;NamedTuple&lt;/code&gt; in Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdd15fbc5eeeea487e741f6815e78f1d57eeca2" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">Возвращаемое значение - это диапазон индексов, в которых найдена соответствующая последовательность, например &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="296596adaa4e2ffb872d464b197ffa89509d78f4" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">Возвращаемое значение - это диапазон индексов, в которых найдена соответствующая последовательность, например &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="edd94ab3af8421f151d037f6b1c8c8e9c195e125" translate="yes" xml:space="preserve">
          <source>The return value is the &lt;code&gt;k&lt;/code&gt;th element of &lt;code&gt;ix&lt;/code&gt; if &lt;code&gt;k&lt;/code&gt; is an integer, or view into &lt;code&gt;ix&lt;/code&gt; if &lt;code&gt;k&lt;/code&gt; is a range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4a1e6fb47e3491c23ed68634d665b86e2b1224" translate="yes" xml:space="preserve">
          <source>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</source>
          <target state="translated">Возвращаемым значением будет новый объект,инициализированный для того,чтобы содержать копию содержимого ссылающейся памяти.Ссылающуюся память можно безопасно освободить или освободить.</target>
        </trans-unit>
        <trans-unit id="995e85d8c74168d9b1cb80ff9be361035188ad05" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.</source>
          <target state="translated">Возвращаются &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; может быть использован в качестве итератора объекта в &lt;code&gt;for&lt;/code&gt; цикла, в этом случае переменной цикла принимает на все полученные значения. Цикл завершается, когда канал закрывается.</target>
        </trans-unit>
        <trans-unit id="4905fa2086f7e7025e1f1fb3e602f0309c36c38d" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">Возвращаемая функция имеет тип &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt; , который можно использовать для реализации специализированных методов.</target>
        </trans-unit>
        <trans-unit id="d2b0ef788e8302311f9e8c57e74d525a3630605d" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(contains)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6c7b3762160369fb507be946e5100e21bab812" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(endswith)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76989de74c6183b202bef17365490bd9a3d31c70" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">Возвращаемая функция имеет тип &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt; , который может использоваться для реализации специализированных методов.</target>
        </trans-unit>
        <trans-unit id="6a5882fae0e5fa7580063c72c386192604725113" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(startswith)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5913ac9f9933573cc3f45ba086fb826464beb36" translate="yes" xml:space="preserve">
          <source>The returned object &lt;code&gt;F&lt;/code&gt; stores the factorization in a packed format:</source>
          <target state="translated">Возвращенный объект &lt;code&gt;F&lt;/code&gt; сохраняет факторизацию в упакованном формате:</target>
        </trans-unit>
        <trans-unit id="5b6b30b85a24f3b9aaa6b8733a6c0289157aac3b" translate="yes" xml:space="preserve">
          <source>The returned tuple must only contain either &lt;code&gt;Int&lt;/code&gt;s or &lt;code&gt;AbstractArray&lt;/code&gt;s of scalar indices that are supported by array &lt;code&gt;A&lt;/code&gt;. It will error upon encountering a novel index type that it does not know how to process.</source>
          <target state="translated">Возвращенный кортеж должен содержать только либо &lt;code&gt;Int&lt;/code&gt; s или &lt;code&gt;AbstractArray&lt;/code&gt; s скалярных индексов, которые поддерживаются массив &lt;code&gt;A&lt;/code&gt; . Это приведет к ошибке при обнаружении нового типа индекса, который не знает, как обрабатывать.</target>
        </trans-unit>
        <trans-unit id="d9c1e00640a368c30e904f9290ae3dcb10bd1ec3" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of watching the file.</source>
          <target state="translated">Возвращаемое значение - это объект с &lt;code&gt;changed&lt;/code&gt; , &lt;code&gt;renamed&lt;/code&gt; логическими полями и &lt;code&gt;timedout&lt;/code&gt; , дающий результат просмотра файла.</target>
        </trans-unit>
        <trans-unit id="0aae9d904638273f671fc4e418a0190f5b8a389f" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of the polling.</source>
          <target state="translated">Возвращаемое значение - это объект с логическими полями , &lt;code&gt;writable&lt;/code&gt; &lt;code&gt;readable&lt;/code&gt; , записи и &lt;code&gt;timedout&lt;/code&gt; , дающий результат опроса.</target>
        </trans-unit>
        <trans-unit id="49b2889cf141c81986b5559befd286291492017c" translate="yes" xml:space="preserve">
          <source>The returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the event.</source>
          <target state="translated">Возвращаемое значение - это пара, в которой первое поле - это имя измененного файла (если доступно), а второе поле - объект с &lt;code&gt;changed&lt;/code&gt; , &lt;code&gt;renamed&lt;/code&gt; логическими полями и &lt;code&gt;timedout&lt;/code&gt; , дающим событие.</target>
        </trans-unit>
        <trans-unit id="8636f9ac58bcf28e3d16135d951b8ff3e218cbd7" translate="yes" xml:space="preserve">
          <source>The reverse operation (writing data to a &lt;code&gt;Ptr{T}&lt;/code&gt;), can be performed using &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt;&lt;/a&gt;. Currently, this is only supported for primitive types or other pointer-free (&lt;code&gt;isbits&lt;/code&gt;) immutable struct types.</source>
          <target state="translated">Обратная операция (запись данных в &lt;code&gt;Ptr{T}&lt;/code&gt; ) может быть выполнена с помощью &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt; &lt;/a&gt; . В настоящее время это поддерживается только для примитивных типов или других неизменяемых структурных типов без указателей ( &lt;code&gt;isbits&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b7d58ee9a7a86e6aad0f59e6f9ed658c820e2192" translate="yes" xml:space="preserve">
          <source>The roots, graph and paths maps of a project environment are defined as follows:</source>
          <target state="translated">Корни,график и карты траекторий проектного окружения определяются следующим образом:</target>
        </trans-unit>
        <trans-unit id="8db1c63f81410ece76ca99d9ff0064394f7701c3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">То же, что и &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; , но экономит место за счет перезаписи входа &lt;code&gt;A&lt;/code&gt; вместо создания копии. &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; исключение , если разложение производит ряд не представим типом элемента &lt;code&gt;A&lt;/code&gt; , например , для целочисленных типов.</target>
        </trans-unit>
        <trans-unit id="7ac8db3a8fce7e45f1c23cbd8542a5bd84c64ad8" translate="yes" xml:space="preserve">
          <source>The same best practices also work for container types:</source>
          <target state="translated">Те же самые лучшие практики применимы и к типам контейнеров:</target>
        </trans-unit>
        <trans-unit id="7644c0d871ce59114cf83dbd0542336b1d1077e8" translate="yes" xml:space="preserve">
          <source>The same thing can be done using recursion:</source>
          <target state="translated">То же самое можно сделать и с помощью рекурсии:</target>
        </trans-unit>
        <trans-unit id="ce434c40b5667e45d99db93d9917e22507c58bf8" translate="yes" xml:space="preserve">
          <source>The schedule used by &lt;code&gt;@spawn&lt;/code&gt; is nondeterministic and should not be relied on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499f37304cc2bf38bfc1e123fdaa79c60bea1de4" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;julia-config.jl&lt;/code&gt; was created to aid in determining what build parameters are required by a program that uses embedded Julia. This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution. This script is located in the Julia shared data directory.</source>
          <target state="translated">Сценарий &lt;code&gt;julia-config.jl&lt;/code&gt; был создан, чтобы помочь определить, какие параметры сборки требуются программе, использующей встроенную Julia. Этот скрипт использует параметры сборки и системную конфигурацию конкретного дистрибутива Julia, которым он вызывается для экспорта необходимых флагов компилятора, чтобы программа внедрения могла взаимодействовать с этим дистрибутивом. Этот сценарий находится в каталоге общих данных Julia.</target>
        </trans-unit>
        <trans-unit id="6f8fe32c72b2738c988d9f8c4881f931f1ba36f2" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;p&lt;/code&gt; is not necessarily a part of the interface for &lt;code&gt;norm&lt;/code&gt;, i.e. a custom type may only implement &lt;code&gt;norm(A)&lt;/code&gt; without second argument.</source>
          <target state="translated">Второй аргумент &lt;code&gt;p&lt;/code&gt; не обязательно является частью интерфейса для &lt;code&gt;norm&lt;/code&gt; , т. Е. Настраиваемый тип может реализовывать &lt;code&gt;norm(A)&lt;/code&gt; без второго аргумента.</target>
        </trans-unit>
        <trans-unit id="b22778842445d7f70d31b000bce7d6cc33096518" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: &lt;code&gt;stdcall&lt;/code&gt;, &lt;code&gt;cdecl&lt;/code&gt;, &lt;code&gt;fastcall&lt;/code&gt;, and &lt;code&gt;thiscall&lt;/code&gt; (no-op on 64-bit Windows). For example (from &lt;code&gt;base/libc.jl&lt;/code&gt;) we see the same &lt;code&gt;gethostname&lt;/code&gt;&lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; as above, but with the correct signature for Windows:</source>
          <target state="translated">Второй аргумент &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; может необязательно быть спецификатором соглашения о вызовах (непосредственно предшествующий типу возвращаемого значения). Без какого-либо спецификатора используется соглашение о вызовах C по умолчанию. Другие поддерживаемые соглашения: &lt;code&gt;stdcall&lt;/code&gt; , &lt;code&gt;cdecl&lt;/code&gt; , &lt;code&gt;fastcall&lt;/code&gt; и &lt;code&gt;thiscall&lt;/code&gt; (no-op в 64-битной Windows). Например (из &lt;code&gt;base/libc.jl&lt;/code&gt; ) мы видим то же имя &lt;code&gt;gethostname&lt;/code&gt; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; ,&lt;/a&gt; что и выше, но с правильной подписью для Windows:</target>
        </trans-unit>
        <trans-unit id="73459aa685b4a3b889d50fc5fe7e0470f348a1b0" translate="yes" xml:space="preserve">
          <source>The second fact is why execution of the loop changes the global value of &lt;code&gt;s&lt;/code&gt; and the first fact is why &lt;code&gt;t&lt;/code&gt; is still undefined after the loop executes. Now, let's try evaluating this same code as though it were in a file instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae8f7c6c5ae9107bf9df78309eaedb266fcdbc6" translate="yes" xml:space="preserve">
          <source>The second form is also often better style and can lead to more code reuse.</source>
          <target state="translated">Вторая форма также часто имеет лучший стиль и может привести к большему количеству повторного использования кода.</target>
        </trans-unit>
        <trans-unit id="f5a1001e237b6ff86cbef193ea1ae22360accd73" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Второй из &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d31d476948ba89a2e9e64c6b33fad2cd0a026a5" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Второй из &lt;code&gt;Time&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="325c1f846c581874b3b9e8bdbf898464d53c77a6" translate="yes" xml:space="preserve">
          <source>The second part of a DateTime as a &lt;code&gt;Second&lt;/code&gt;.</source>
          <target state="translated">Вторая часть DateTime в качестве &lt;code&gt;Second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3329a718673195a0538b1050837014e0187920" translate="yes" xml:space="preserve">
          <source>The second statement in the test program evaluates a Julia statement using a call to &lt;code&gt;jl_eval_string&lt;/code&gt;.</source>
          <target state="translated">Второй оператор в тестовой программе оценивает оператор Julia, используя вызов &lt;code&gt;jl_eval_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc4451185981f40556584c6f362b372cf0d2413" translate="yes" xml:space="preserve">
          <source>The second syntactic purpose of the &lt;code&gt;:&lt;/code&gt; character is to create expression objects without using the explicit &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. This is referred to as &lt;em&gt;quoting&lt;/em&gt;. The &lt;code&gt;:&lt;/code&gt; character, followed by paired parentheses around a single statement of Julia code, produces an &lt;code&gt;Expr&lt;/code&gt; object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:</source>
          <target state="translated">Вторая синтаксическая цель символа &lt;code&gt;:&lt;/code&gt; - создавать объекты выражения без использования явного конструктора &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; . Это называется &lt;em&gt;цитированием&lt;/em&gt; . Символ &lt;code&gt;:&lt;/code&gt; , за которым следуют парные круглые скобки вокруг единственного оператора кода Julia, создает объект &lt;code&gt;Expr&lt;/code&gt; на основе заключенного кода. Вот пример краткой формы, используемой для цитирования арифметического выражения:</target>
        </trans-unit>
        <trans-unit id="915184092841becb822c9871efbbca52119b3359" translate="yes" xml:space="preserve">
          <source>The second version will convert &lt;code&gt;x&lt;/code&gt; to an appropriate type, instead of always the same type.</source>
          <target state="translated">Вторая версия преобразует &lt;code&gt;x&lt;/code&gt; в соответствующий тип, а не всегда в один и тот же тип.</target>
        </trans-unit>
        <trans-unit id="21005babd7e775084c5d9f5bf289076cc05e5e92" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; discussed the execution of multiple functions in a co-operative manner. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s can be quite useful to pass data between running tasks, particularly those involving I/O operations.</source>
          <target state="translated">В разделе &amp;laquo; &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;потоке управления&lt;/a&gt; обсуждается совместное выполнение нескольких функций. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; могут быть весьма полезны для передачи данных между запущенными задачами, особенно теми, которые связаны с операциями ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="d29f893f8cb7d336019acffa7a05d1fd7e30e1bd" translate="yes" xml:space="preserve">
          <source>The semicolon is used to separate required arguments (of which there must be at least one) from variadic arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8192d7c492df82ef09042dd5374aa1f14711d23" translate="yes" xml:space="preserve">
          <source>The shared array is valid as long as a reference to the &lt;code&gt;SharedArray&lt;/code&gt; object exists on the node which created the mapping.</source>
          <target state="translated">Общий массив действителен, пока ссылка на объект &lt;code&gt;SharedArray&lt;/code&gt; существует на узле, создавшем отображение.</target>
        </trans-unit>
        <trans-unit id="5dc8475813b4cdc5d96eb3c4625fbd7b58d50c66" translate="yes" xml:space="preserve">
          <source>The shortest complete expression after the &lt;code&gt;$&lt;/code&gt; is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</source>
          <target state="translated">Самое короткое полное выражение после символа &lt;code&gt;$&lt;/code&gt; принимается как выражение, значение которого должно быть вставлено в строку. Таким образом, вы можете вставить любое выражение в строку, используя круглые скобки:</target>
        </trans-unit>
        <trans-unit id="3d9f8e8412af884c31e022248ea444c48500d8b3" translate="yes" xml:space="preserve">
          <source>The simplest way to create a sparse array is to use a function equivalent to the &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an &lt;code&gt;sp&lt;/code&gt; prefix:</source>
          <target state="translated">Самый простой способ создать разреженный массив - использовать функцию, эквивалентную функции &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; которую Джулия предоставляет для работы с плотными массивами. Чтобы вместо этого создать разреженный массив, вы можете использовать то же имя с префиксом &lt;code&gt;sp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16be4bebce7cbb536220116c00b6f9d05ca83f19" translate="yes" xml:space="preserve">
          <source>The single argument &lt;code&gt;endswith(suffix)&lt;/code&gt; requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01b5055495d08a0cdfb3ee522579f3c77a12e9b" translate="yes" xml:space="preserve">
          <source>The single argument &lt;code&gt;startswith(prefix)&lt;/code&gt; requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c1b2cacc149914d1f87944b2e673b55e75f540" translate="yes" xml:space="preserve">
          <source>The singleton instance of &lt;code&gt;Colon&lt;/code&gt; is also a function used to construct ranges; see &lt;a href=&quot;../math/index#Base.::&quot;&gt;&lt;code&gt;:&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Одноэлементный экземпляр &lt;code&gt;Colon&lt;/code&gt; также является функцией, используемой для создания диапазонов; см . &lt;a href=&quot;../math/index#Base.::&quot;&gt; &lt;code&gt;:&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69dbdef625126b35b49d3d64442b9b0a176ab7d3" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt; representing a missing value.</source>
          <target state="translated">Одноэлементный экземпляр типа &lt;a href=&quot;#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; ,&lt;/a&gt; представляющий отсутствующее значение.</target>
        </trans-unit>
        <trans-unit id="d89078042c9eb6d352a7eb66e0b88b0400546bfa" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt;, used by convention when there is no value to return (as in a C &lt;code&gt;void&lt;/code&gt; function) or when a variable or field holds no value.</source>
          <target state="translated">Одноэлементный экземпляр типа &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; , используемый по соглашению, когда нет значения для возврата (как в функции &lt;code&gt;void&lt;/code&gt; C ) или когда переменная или поле не содержат значения.</target>
        </trans-unit>
        <trans-unit id="98c477c6e9d21cf836746a2bcff1d62c547964d7" translate="yes" xml:space="preserve">
          <source>The size (in bytes) of the file</source>
          <target state="translated">Размер (в байтах)файла</target>
        </trans-unit>
        <trans-unit id="b66123090eeef1135c4d4375118f6396f24e2b0e" translate="yes" xml:space="preserve">
          <source>The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter &lt;code&gt;T&lt;/code&gt; is not used in the definition of the type itself &amp;ndash; it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, &lt;code&gt;Ptr{Float64}&lt;/code&gt; and &lt;code&gt;Ptr{Int64}&lt;/code&gt; are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; type:</source>
          <target state="translated">Немного странная особенность этих объявлений по сравнению с типичными параметрическими составными типами состоит в том, что параметр типа &lt;code&gt;T&lt;/code&gt; не используется в определении самого типа - это просто абстрактный тег, по существу определяющий все семейство типов с идентичной структурой, различаются только по параметру типа. Таким образом, &lt;code&gt;Ptr{Float64}&lt;/code&gt; и &lt;code&gt;Ptr{Int64}&lt;/code&gt; являются разными типами, даже если они имеют идентичные представления. И, конечно же, все конкретные типы указателей являются подтипами зонтичного типа &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b70321f704716a765747450fd9a29400a288057e" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;a^n&lt;/code&gt; not less than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must be greater than 0.</source>
          <target state="translated">Наименьшее &lt;code&gt;a^n&lt;/code&gt; не меньше &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - неотрицательное целое число. &lt;code&gt;a&lt;/code&gt; должно быть больше 1, а &lt;code&gt;x&lt;/code&gt; должно быть больше 0.</target>
        </trans-unit>
        <trans-unit id="8e217f5379986c6dbb724913b9402b2744112320" translate="yes" xml:space="preserve">
          <source>The smallest in absolute value non-subnormal value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Наименьшее по абсолютной величине значения , не субнормальная представимыми данной плавающей точкой ТипДанных &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25349e0ef0dc3df135e9bbaceeafe9aedb6a8cb7" translate="yes" xml:space="preserve">
          <source>The so-called &quot;ternary operator&quot;, &lt;code&gt;?:&lt;/code&gt;, is closely related to the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:</source>
          <target state="translated">Так называемый &amp;laquo;тернарный оператор&amp;raquo; &lt;code&gt;?:&lt;/code&gt; Тесно связан с синтаксисом &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; , но используется там, где требуется условный выбор между значениями одного выражения, в отличие от условного выполнения более длинных блоков кода. Он получил свое название от того, что является единственным оператором на большинстве языков, принимающим три операнда:</target>
        </trans-unit>
        <trans-unit id="466b5c814e2cc3e14c74b0b3d7f3038223cc5afa" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;CartesianIndex{N}&lt;/code&gt; object represents a scalar index that behaves like an &lt;code&gt;N&lt;/code&gt;-tuple of integers spanning multiple dimensions. For example:</source>
          <target state="translated">Специальный объект &lt;code&gt;CartesianIndex{N}&lt;/code&gt; представляет скалярный индекс, который ведет себя как набор &lt;code&gt;N&lt;/code&gt; целых чисел, охватывающий несколько измерений. Например:</target>
        </trans-unit>
        <trans-unit id="762a1096309b147153ae61442ac8f98b5b44d380" translate="yes" xml:space="preserve">
          <source>The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, &lt;code&gt;@distributed&lt;/code&gt; performs local reductions on each worker with a final reduction on the calling process.</source>
          <target state="translated">Указанный диапазон разделяется и выполняется локально для всех рабочих процессов. Если указана дополнительная функция редуктора, &lt;code&gt;@distributed&lt;/code&gt; выполняет локальные сокращения для каждого рабочего с окончательным сокращением для вызывающего процесса.</target>
        </trans-unit>
        <trans-unit id="af76c7aa8adb68998b2eccf29c56d714b4910790" translate="yes" xml:space="preserve">
          <source>The stack of current exceptions can be accessed using the experimental &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; function. For example,</source>
          <target state="translated">Доступ к стеку текущих исключений можно получить с помощью экспериментальной функции &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="b314da4796576e2f7b71a666741e2ef66714401f" translate="yes" xml:space="preserve">
          <source>The standard way to obtain a value of a certain type &lt;code&gt;T&lt;/code&gt; is to call the type's constructor, &lt;code&gt;T(x)&lt;/code&gt;. However, there are cases where it's convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Vector{Float64}&lt;/code&gt;, the expression &lt;code&gt;A[1] = 2&lt;/code&gt; should work by automatically converting the &lt;code&gt;2&lt;/code&gt; from &lt;code&gt;Int&lt;/code&gt; to &lt;code&gt;Float64&lt;/code&gt;, and storing the result in the array. This is done via the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Стандартный способ получить значение определенного типа &lt;code&gt;T&lt;/code&gt; - вызвать конструктор типа &lt;code&gt;T(x)&lt;/code&gt; . Однако бывают случаи, когда удобно преобразовать значение из одного типа в другой без явного запроса программиста. Одним из примеров является присвоение значения массиву: если &lt;code&gt;A&lt;/code&gt; является &lt;code&gt;Vector{Float64}&lt;/code&gt; , выражение &lt;code&gt;A[1] = 2&lt;/code&gt; должно работать, автоматически преобразовывая &lt;code&gt;2&lt;/code&gt; из &lt;code&gt;Int&lt;/code&gt; в &lt;code&gt;Float64&lt;/code&gt; и сохраняя результат в массиве. Это делается с помощью функции &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09c9759ec2f73e324d46f0dc859670daa106989a" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; brings just the identifiers &lt;code&gt;thing1&lt;/code&gt; and &lt;code&gt;thing2&lt;/code&gt; into scope from module &lt;code&gt;BigLib&lt;/code&gt;. If these names refer to functions, adding methods to them will not be allowed (you may only &quot;use&quot; them, not extend them).</source>
          <target state="translated">Оператор &lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; переносит в область видимости только идентификаторы &lt;code&gt;thing1&lt;/code&gt; и &lt;code&gt;thing2&lt;/code&gt; из модуля &lt;code&gt;BigLib&lt;/code&gt; . Если эти имена относятся к функциям, добавление к ним методов будет запрещено (вы можете только &amp;laquo;использовать&amp;raquo; их, но не расширять).</target>
        </trans-unit>
        <trans-unit id="495d86d0b4d05239c00e12e65404916397e09df9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using Lib&lt;/code&gt; means that a module called &lt;code&gt;Lib&lt;/code&gt; will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by &lt;code&gt;Lib&lt;/code&gt; and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in &lt;code&gt;Lib&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;using Lib&lt;/code&gt; означает, что модуль с именем &lt;code&gt;Lib&lt;/code&gt; будет доступен для разрешения имен по мере необходимости. Когда обнаруживается глобальная переменная, не имеющая определения в текущем модуле, система будет искать ее среди переменных, экспортированных &lt;code&gt;Lib&lt;/code&gt; , и импортировать ее, если она там найдена. Это означает, что все использования этого глобального в текущем модуле будут разрешены для определения этой переменной в &lt;code&gt;Lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960d66936ab81ca5d156bae42ba7e8c239f12236" translate="yes" xml:space="preserve">
          <source>The statistical &lt;em&gt;distribution&lt;/em&gt; from which random samples are drawn &lt;em&gt;is&lt;/em&gt; guaranteed to be the same across any minor Julia releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9b401957be6cef37d6e4c9d1a4d83b1e534a70" translate="yes" xml:space="preserve">
          <source>The stride of the second dimension is the spacing between elements in the same row, skipping as many elements as there are in a single column (&lt;code&gt;5&lt;/code&gt;). Similarly, jumping between the two &quot;pages&quot; (in the third dimension) requires skipping &lt;code&gt;5*7 == 35&lt;/code&gt; elements. The &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; of this array is the tuple of these three numbers together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69251ee5ae969dde76ae7aecf53b32517ef054f" translate="yes" xml:space="preserve">
          <source>The stride should be unit stride.</source>
          <target state="translated">Шаг должен быть единичным.</target>
        </trans-unit>
        <trans-unit id="551daadc8e34eb38e96adac58c5a71e00e21218c" translate="yes" xml:space="preserve">
          <source>The string literal could also be used directly before the function name, if desired &lt;code&gt;&quot;libglib-2.0&quot;.g_uri_escape_string(...&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f6cb2eda0183a3a023b5793fbbc533b8630c5f" translate="yes" xml:space="preserve">
          <source>The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax trees&lt;/a&gt;. In contrast, preprocessor &quot;macro&quot; systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; capabilities are available to explore the internals of a program and its types just like any other data.</source>
          <target state="translated">Самым сильным наследием Lisp в языке Julia является его поддержка метапрограммирования. Как и Лисп, Джулия представляет свой собственный код как структуру данных самого языка. Поскольку код представлен объектами, которые могут быть созданы и управляться изнутри языка, программа может преобразовывать и генерировать свой собственный код. Это позволяет создавать сложный код без дополнительных шагов сборки, а также позволяет макросам в стиле Lisp работать на уровне &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;абстрактных синтаксических деревьев&lt;/a&gt; . Напротив, &quot;макросистемы&quot; препроцессора, такие как системы C и C ++, выполняют текстовые манипуляции и замену до того, как произойдет фактический синтаксический анализ или интерпретация. Поскольку все типы данных и код в Julia представлены структурами данных Julia, мощное &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;отражение&lt;/a&gt; Доступны возможности для изучения внутреннего устройства программы и ее типов, как и любых других данных.</target>
        </trans-unit>
        <trans-unit id="5e569356ccc37557b3dd3a4c9eb2b13531bfa9b1" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format such that &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">Поддиагональная часть содержит отражатели $ v_i $, хранящиеся в упакованном формате, так что &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c6aba56e3888ce8991d8adbbc0407169b7c0c0" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format where $v_i$ is the $i$th column of the matrix &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">Поддиагональная часть содержит отражатели $ v_i $, хранящиеся в упакованном формате, где $ v_i $ - это столбец $ i $ в матрице &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2a34ecc15f647be67c38e382f5d48daa6d45c2" translate="yes" xml:space="preserve">
          <source>The subscripted &lt;code&gt;rootsᵢ&lt;/code&gt;, &lt;code&gt;graphᵢ&lt;/code&gt; and &lt;code&gt;pathsᵢ&lt;/code&gt; variables correspond to the subscripted environments, &lt;code&gt;envᵢ&lt;/code&gt;, contained in &lt;code&gt;stack&lt;/code&gt;. The &lt;code&gt;reverse&lt;/code&gt; is present because &lt;code&gt;merge&lt;/code&gt; favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:</source>
          <target state="translated">В подстрочных &lt;code&gt;rootsᵢ&lt;/code&gt; , &lt;code&gt;graphᵢ&lt;/code&gt; и &lt;code&gt;pathsᵢ&lt;/code&gt; переменных соответствуют подстрочным средам, &lt;code&gt;envᵢ&lt;/code&gt; , содержащимся в &lt;code&gt;stack&lt;/code&gt; . &lt;code&gt;reverse&lt;/code&gt; присутствует потому , что &lt;code&gt;merge&lt;/code&gt; способствует последний аргумент , а не первый , когда возникают коллизии между ключами в его аргументов словарей. Есть несколько примечательных особенностей этой конструкции:</target>
        </trans-unit>
        <trans-unit id="996fc71a38fd366e817f73bce0377ef4ace5919b" translate="yes" xml:space="preserve">
          <source>The subtypes of &lt;code&gt;AbstractArray&lt;/code&gt; typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; abstract type; and a method to make a new uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base. Here is a basic example usage of them, guaranteeing that &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; are of the same type:</source>
          <target state="translated">Подтипы &lt;code&gt;AbstractArray&lt;/code&gt; обычно реализуют два метода для достижения этого: метод преобразования входного массива в подтип определенного абстрактного типа &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; ; и метод создания нового неинициализированного массива с определенным типом элемента. Примеры их реализации можно найти в Julia Base. Вот базовый пример их использования, гарантирующий, что &lt;code&gt;input&lt;/code&gt; и &lt;code&gt;output&lt;/code&gt; одного типа:</target>
        </trans-unit>
        <trans-unit id="63699aa33be9f33f21d62b86441a8ff8e274be42" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;M.x = y&lt;/code&gt; does not work to assign a global in another module; global assignment is always module-local.</source>
          <target state="translated">Синтаксис &lt;code&gt;M.x = y&lt;/code&gt; не работает для назначения глобального в другом модуле; глобальное присвоение всегда локально для модуля.</target>
        </trans-unit>
        <trans-unit id="8aef45ce051e500a72b345ef2f22cdbfc5692cd9" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; constructs a 1-d array (i.e., a vector) of its arguments. If all arguments have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Синтаксис &lt;code&gt;[A, B, C, ...]&lt;/code&gt; создает одномерный массив (т. Е. Вектор) своих аргументов. Если все аргументы имеют общий &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;тип продвижения,&lt;/a&gt; они преобразуются в этот тип с помощью &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e625bef095d2c8eb72ebaeebbec92f580bcf9df3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b = c&lt;/code&gt; calls &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt;.</source>
          <target state="translated">Синтаксис &lt;code&gt;a.b = c&lt;/code&gt; вызывает &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb9de73fee4d35f05a94de3650ba9db8d2743f66" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b&lt;/code&gt; calls &lt;code&gt;getproperty(a, :b)&lt;/code&gt;.</source>
          <target state="translated">Синтаксис &lt;code&gt;a.b&lt;/code&gt; вызывает &lt;code&gt;getproperty(a, :b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00608410463d33a3565dc12e2221379a6b79beb5" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;catch e&lt;/code&gt; (where &lt;code&gt;e&lt;/code&gt; is any variable) assigns the thrown exception object to the given variable within the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">Синтаксис &lt;code&gt;catch e&lt;/code&gt; (где &lt;code&gt;e&lt;/code&gt; - любая переменная) присваивает созданный объект исключения заданной переменной в блоке &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaa3305d41b8587b8f7d7509cefad00e6333ecec" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;var&quot;#example#&quot;&lt;/code&gt; refers to a variable named &lt;code&gt;Symbol(&quot;#example#&quot;)&lt;/code&gt;, even though &lt;code&gt;#example#&lt;/code&gt; is not a valid Julia identifier name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb021dba0d683eea0a7e9eec6250ba19720138f" translate="yes" xml:space="preserve">
          <source>The syntax for images is similar to the link syntax mentioned above. Prepending a &lt;code&gt;!&lt;/code&gt; character to a link will display an image from the specified URL rather than a link to it.</source>
          <target state="translated">Синтаксис изображений аналогичен синтаксису ссылок, упомянутому выше. Готовим &lt;code&gt;!&lt;/code&gt; символ ссылки будет отображать изображение с указанного URL, а не ссылку на него.</target>
        </trans-unit>
        <trans-unit id="4706abb51ce58ba5921e55c75731359f252d532a" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;remotecall&lt;/code&gt; is not especially convenient. The macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:</source>
          <target state="translated">Синтаксис &lt;code&gt;remotecall&lt;/code&gt; не особо удобен. Макрос &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; упрощает задачу. Он работает с выражением, а не с функцией, и выбирает, где выполнить операцию за вас:</target>
        </trans-unit>
        <trans-unit id="e63059505e9b54a2aa7f6f114401eafe55571016" translate="yes" xml:space="preserve">
          <source>The syntaxes &lt;code&gt;A[end]&lt;/code&gt; and &lt;code&gt;A[end, end]&lt;/code&gt; lower to &lt;code&gt;A[lastindex(A)]&lt;/code&gt; and &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt;, respectively.</source>
          <target state="translated">Синтаксисы &lt;code&gt;A[end]&lt;/code&gt; и &lt;code&gt;A[end, end]&lt;/code&gt; ниже &lt;code&gt;A[lastindex(A)]&lt;/code&gt; и &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="76ff0041a09cb9e2761ca760c9e89d92dece6223" translate="yes" xml:space="preserve">
          <source>The system also generates some standard information for each event:</source>
          <target state="translated">Система также генерирует некоторую стандартную информацию для каждого события:</target>
        </trans-unit>
        <trans-unit id="1291d08b43c51644b75972a68949c78194cf4ab6" translate="yes" xml:space="preserve">
          <source>The system provides several advantages over peppering your source code with calls to &lt;code&gt;println()&lt;/code&gt;. First, it allows you to control the visibility and presentation of messages without editing the source code. For example, in contrast to the &lt;code&gt;@warn&lt;/code&gt; above</source>
          <target state="translated">Система предоставляет несколько преимуществ по сравнению с добавлением исходного кода в вызовы &lt;code&gt;println()&lt;/code&gt; . Во-первых, он позволяет вам контролировать видимость и представление сообщений без редактирования исходного кода. Например, в отличие от &lt;code&gt;@warn&lt;/code&gt; выше</target>
        </trans-unit>
        <trans-unit id="35ef5183de88aa885d43235fbe1c95c14449a9c3" translate="yes" xml:space="preserve">
          <source>The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:</source>
          <target state="translated">Клавиша табуляции также может быть использована для замены математических символов LaTeX на их эквиваленты Unicode,а также для получения списка совпадений LaTeX:</target>
        </trans-unit>
        <trans-unit id="eeaa0530b289803476c7e7f2356ac443d47f8ecd" translate="yes" xml:space="preserve">
          <source>The ternary operator &lt;code&gt;x &amp;gt; 0 ? 1 : -1&lt;/code&gt; in Julia corresponds to conditional expression in Python &lt;code&gt;1 if x &amp;gt; 0 else -1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4dddfd04ca6f7504094f4bf51ec3f336d04266" translate="yes" xml:space="preserve">
          <source>The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the &lt;a href=&quot;#Footnotes&quot;&gt;Footnotes&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bb24eed2bccbd623888cb79506fd88f02fa796" translate="yes" xml:space="preserve">
          <source>The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the &lt;a href=&quot;#Footnotes-1&quot;&gt;Footnotes&lt;/a&gt; section below.</source>
          <target state="translated">Текст, связанный со сноской, может быть написан в любом месте той же страницы, что и ссылка на сноску. Синтаксис, используемый для определения текста сноски, обсуждается в разделе &amp;laquo; &lt;a href=&quot;#Footnotes-1&quot;&gt;Сноски&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="89803a19d844f78ae00674dace9498726fc7f334" translate="yes" xml:space="preserve">
          <source>The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called &lt;em&gt;environment stacks&lt;/em&gt;. The Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; global defines an environment stack&amp;mdash;the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in &lt;code&gt;LOAD_PATH&lt;/code&gt;. It is often quite useful, however, to have access to some of your favorite tools&amp;mdash;standard libraries, profilers, debuggers, personal utilities, etc.&amp;mdash;even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.</source>
          <target state="translated">Третий и последний вид среды - это среда, которая объединяет другие среды путем наложения нескольких из них, делая пакеты в каждой доступной в единой составной среде. Эти составные среды называются &lt;em&gt;стеками сред&lt;/em&gt; . Глобальная &lt;code&gt;LOAD_PATH&lt;/code&gt; Julia LOAD_PATH определяет стек среды - среду, в которой работает процесс Julia. Если вы хотите, чтобы ваш процесс Julia имел доступ только к пакетам в одном проекте или каталоге пакетов, сделайте его единственной записью в &lt;code&gt;LOAD_PATH&lt;/code&gt; , Однако часто бывает очень полезно иметь доступ к некоторым из ваших любимых инструментов - стандартным библиотекам, профилировщикам, отладчикам, личным утилитам и т. Д. - даже если они не являются зависимостями проекта, над которым вы работаете. Добавив среду, содержащую эти инструменты, в путь загрузки, вы сразу же получите к ним доступ в коде верхнего уровня без необходимости добавлять их в свой проект.</target>
        </trans-unit>
        <trans-unit id="60aabe2463f937334820dc78a19b796fb10a2bf1" translate="yes" xml:space="preserve">
          <source>The third dimension is interesting because its order is reversed! Thus to get from the first &quot;page&quot; to the second one it must go &lt;em&gt;backwards&lt;/em&gt; in memory, and so its stride in this dimension is negative!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5e0709035da59f79f484697f8e3df4d573f5fc" translate="yes" xml:space="preserve">
          <source>The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share the same key properties:</source>
          <target state="translated">Три типа (абстрактный,примитивный,составной),рассмотренные в предыдущих разделах,на самом деле все они тесно взаимосвязаны.Они имеют одни и те же ключевые свойства:</target>
        </trans-unit>
        <trans-unit id="96a22cbc00a4020163f8bf8451c0cb52f4fe8ed1" translate="yes" xml:space="preserve">
          <source>The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests using the &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; operator return &lt;code&gt;missing&lt;/code&gt; whenever the result cannot be determined without knowing the actual value of the &lt;code&gt;missing&lt;/code&gt; entry. In practice, this means that &lt;code&gt;missing&lt;/code&gt; is returned if all non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly at different positions)</source>
          <target state="translated">Трехзначная логика, описанная выше для логических операторов, также используется логическими функциями, применяемыми к массивам. Таким образом, при проверке равенства массивов с использованием оператора &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; return &lt;code&gt;missing&lt;/code&gt; всякий раз, когда результат не может быть определен без знания фактического значения &lt;code&gt;missing&lt;/code&gt; записи. На практике это означает, что &lt;code&gt;missing&lt;/code&gt; возвращается, если все не пропущенные значения сравниваемых массивов равны, но один или оба массива содержат пропущенные значения (возможно, в разных позициях).</target>
        </trans-unit>
        <trans-unit id="705f306c2133309c48bfd3bbe51630bace32d834" translate="yes" xml:space="preserve">
          <source>The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F::Cholesky&lt;/code&gt; via &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb56cdc3790ef15101c199a297fa409d4481928d" translate="yes" xml:space="preserve">
          <source>The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F::CholeskyPivoted&lt;/code&gt; via &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb480c16cbf47fe55bf38e90f5861a483a884fb" translate="yes" xml:space="preserve">
          <source>The tuple must be the same size as the SIMD type. For example, a tuple representing an &lt;code&gt;__m128&lt;/code&gt; on x86 must have a size of 16 bytes.</source>
          <target state="translated">Кортеж должен быть того же размера, что и тип SIMD. Например, кортеж, представляющий &lt;code&gt;__m128&lt;/code&gt; на x86, должен иметь размер 16 байт.</target>
        </trans-unit>
        <trans-unit id="d71d89013d2d694c3c90bff3726394654345117f" translate="yes" xml:space="preserve">
          <source>The two expressions constructed above &amp;ndash; by parsing and by direct construction &amp;ndash; are equivalent:</source>
          <target state="translated">Два выражения, построенные выше - путем синтаксического анализа и путем прямого построения - эквивалентны:</target>
        </trans-unit>
        <trans-unit id="3b3360fde4989c6fe95a691dce2016abf50d9177" translate="yes" xml:space="preserve">
          <source>The two uses of the &lt;code&gt;...&lt;/code&gt; operator: slurping and splatting</source>
          <target state="translated">Два использования оператора &lt;code&gt;...&lt;/code&gt; : прихлебывание и разбрызгивание</target>
        </trans-unit>
        <trans-unit id="b96a5c8aeea4ce2a16e47711028fe9eaf98f3763" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Point{Float64}&lt;/code&gt; is a point whose coordinates are 64-bit floating-point values, while the type &lt;code&gt;Point{AbstractString}&lt;/code&gt; is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt;).</source>
          <target state="translated">Тип &lt;code&gt;Point{Float64}&lt;/code&gt; - это точка, координаты которой представляют собой 64-битные значения с плавающей запятой, а тип &lt;code&gt;Point{AbstractString}&lt;/code&gt; - это &amp;laquo;точка&amp;raquo;, &amp;laquo;координаты&amp;raquo; которой являются строковыми объектами (см. &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Строки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d40d9987e4be3343cc1ff7a67bcd2a4182159aca" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Point{Float64}&lt;/code&gt; is a point whose coordinates are 64-bit floating-point values, while the type &lt;code&gt;Point{AbstractString}&lt;/code&gt; is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#Strings&quot;&gt;Strings&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7369108ecd55df4b36265309c9d17ce4d10c19" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;NTuple{N,T}&lt;/code&gt; is a convenient alias for &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt;, i.e. a tuple type containing exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;Vararg{T,N}&lt;/code&gt; соответствует ровно &lt;code&gt;N&lt;/code&gt; элементов типа &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;NTuple{N,T}&lt;/code&gt; является удобным псевдонимом для &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt; , т.е. кортежа типа , содержащего ровно &lt;code&gt;N&lt;/code&gt; элементов типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bedae316814d6156803443fcc9c13d8c64877a4" translate="yes" xml:space="preserve">
          <source>The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with &lt;code&gt;let&lt;/code&gt; blocks as follows.</source>
          <target state="translated">Аннотация типа частично восстанавливает потерянную производительность из-за захвата, поскольку синтаксический анализатор может связать конкретный тип с объектом в блоке. Далее, если захваченную переменную вообще не нужно помещать в коробку (поскольку она не будет переназначена после создания замыкания), это можно указать с помощью блоков &lt;code&gt;let&lt;/code&gt; следующим образом.</target>
        </trans-unit>
        <trans-unit id="6fbcbd4db01a84d712a7283dfeb43aba8b033041" translate="yes" xml:space="preserve">
          <source>The type application syntax &lt;code&gt;A{B,C}&lt;/code&gt; requires &lt;code&gt;A&lt;/code&gt; to be a &lt;code&gt;UnionAll&lt;/code&gt; type, and first substitutes &lt;code&gt;B&lt;/code&gt; for the outermost type variable in &lt;code&gt;A&lt;/code&gt;. The result is expected to be another &lt;code&gt;UnionAll&lt;/code&gt; type, into which &lt;code&gt;C&lt;/code&gt; is then substituted. So &lt;code&gt;A{B,C}&lt;/code&gt; is equivalent to &lt;code&gt;A{B}{C}&lt;/code&gt;. This explains why it is possible to partially instantiate a type, as in &lt;code&gt;Array{Float64}&lt;/code&gt;: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit &lt;code&gt;where&lt;/code&gt; syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as &lt;code&gt;Array{T,1} where T&lt;/code&gt;.</source>
          <target state="translated">Прикладной синтаксис типа &lt;code&gt;A{B,C}&lt;/code&gt; требует &lt;code&gt;A&lt;/code&gt; быть &lt;code&gt;UnionAll&lt;/code&gt; типа, а первые заменителями &lt;code&gt;B&lt;/code&gt; для переменного типа в наружном &lt;code&gt;A&lt;/code&gt; . Ожидается, что результатом будет другой тип &lt;code&gt;UnionAll&lt;/code&gt; , в который затем подставляется &lt;code&gt;C&lt;/code&gt; . Итак, &lt;code&gt;A{B,C}&lt;/code&gt; эквивалентно &lt;code&gt;A{B}{C}&lt;/code&gt; . Это объясняет, почему можно частично создать экземпляр типа, как в &lt;code&gt;Array{Float64}&lt;/code&gt; : первое значение параметра было фиксированным, но второе по-прежнему охватывает все возможные значения. Использование явного &lt;code&gt;where&lt;/code&gt; синтаксис, любое подмножество параметров может быть исправлено. Например, тип всех 1-мерных массивов может быть записана в виде &lt;code&gt;Array{T,1} where T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffb66b4dabff5050a74ff3cadfb7762c384071e4" translate="yes" xml:space="preserve">
          <source>The type arguments to &lt;code&gt;ccall&lt;/code&gt; and &lt;code&gt;@cfunction&lt;/code&gt; are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</source>
          <target state="translated">Аргументы типа для &lt;code&gt;ccall&lt;/code&gt; и &lt;code&gt;@cfunction&lt;/code&gt; оцениваются статически, когда определяется метод, содержащий использование. Поэтому они должны иметь форму буквального кортежа, а не переменной, и не могут ссылаться на локальные переменные.</target>
        </trans-unit>
        <trans-unit id="1a668fb8c29cba9ffa772e3e0ec9a1a70c5fa795" translate="yes" xml:space="preserve">
          <source>The type is an &lt;code&gt;Array{T,N}&lt;/code&gt; with a bits-type element of &lt;code&gt;T&lt;/code&gt; and dimension &lt;code&gt;N&lt;/code&gt; that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).</source>
          <target state="translated">Типом является &lt;code&gt;Array{T,N}&lt;/code&gt; с элементом битового типа &lt;code&gt;T&lt;/code&gt; и размерностью &lt;code&gt;N&lt;/code&gt; , которая определяет, как интерпретируются байты массива. Обратите внимание, что файл должен храниться в двоичном формате, и преобразование формата невозможно (это ограничение операционных систем, а не Julia).</target>
        </trans-unit>
        <trans-unit id="e499662e725cd499be9193549f691bff7a5c084f" translate="yes" xml:space="preserve">
          <source>The type of exception thrown when an error occurs in DNS lookup. The &lt;code&gt;host&lt;/code&gt; field indicates the host URL string. The &lt;code&gt;code&lt;/code&gt; field indicates the error code based on libuv.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5dd90cb0f8495d6d15c26b83250961e3145b2f" translate="yes" xml:space="preserve">
          <source>The type of field &lt;code&gt;a&lt;/code&gt; can be readily determined from the type of &lt;code&gt;m&lt;/code&gt;, but not from the type of &lt;code&gt;t&lt;/code&gt;. Indeed, in &lt;code&gt;t&lt;/code&gt; it's possible to change the type of the field &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">Тип поля &lt;code&gt;a&lt;/code&gt; можно легко определить по типу &lt;code&gt;m&lt;/code&gt; , но не по типу &lt;code&gt;t&lt;/code&gt; . Действительно, в &lt;code&gt;t&lt;/code&gt; можно изменить тип поля &lt;code&gt;a&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="282394fd5d6e1d690607a98e995ab7809b63cd8e" translate="yes" xml:space="preserve">
          <source>The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). &lt;code&gt;Symbol&lt;/code&gt;s can be entered using the &lt;code&gt;:&lt;/code&gt; quote operator:</source>
          <target state="translated">Тип объекта, используемый для представления идентификаторов в анализируемом коде julia (AST). Также часто используется как имя или метка для идентификации объекта (например, как ключ словаря). &lt;code&gt;Symbol&lt;/code&gt; s может быть введен с помощью &lt;code&gt;:&lt;/code&gt; цитата оператора:</target>
        </trans-unit>
        <trans-unit id="82012051565c5ddd98325c85c6b81ed88d932dea" translate="yes" xml:space="preserve">
          <source>The type of the admonition can be any word made up of only lowercase Latin characters (a-z), but some types produce special styling, namely (in order of decreasing severity): &lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;note&lt;/code&gt;, and &lt;code&gt;tip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d435d74348a381158dd6b8006d6bf402fcef60" translate="yes" xml:space="preserve">
          <source>The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): &lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;/&lt;code&gt;note&lt;/code&gt;, and &lt;code&gt;tip&lt;/code&gt;.</source>
          <target state="translated">Тип предупреждения может быть любым словом, но некоторые типы имеют особый стиль, а именно (в порядке убывания серьезности): &lt;code&gt;danger&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; / &lt;code&gt;note&lt;/code&gt; и &lt;code&gt;tip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4848f4198d788d8fa0ad8db3a3e5d610c5797c10" translate="yes" xml:space="preserve">
          <source>The type of the first argument of this method is a &lt;a href=&quot;../types/index#man-singleton-types&quot;&gt;singleton type&lt;/a&gt;, &lt;code&gt;Type{MyType}&lt;/code&gt;, the only instance of which is &lt;code&gt;MyType&lt;/code&gt;. Thus, this method is only invoked when the first argument is the type value &lt;code&gt;MyType&lt;/code&gt;. Notice the syntax used for the first argument: the argument name is omitted prior to the &lt;code&gt;::&lt;/code&gt; symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cde77f6d397a5966075de74e297cbf03487660" translate="yes" xml:space="preserve">
          <source>The type of the first argument of this method is a &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;singleton type&lt;/a&gt;, &lt;code&gt;Type{MyType}&lt;/code&gt;, the only instance of which is &lt;code&gt;MyType&lt;/code&gt;. Thus, this method is only invoked when the first argument is the type value &lt;code&gt;MyType&lt;/code&gt;. Notice the syntax used for the first argument: the argument name is omitted prior to the &lt;code&gt;::&lt;/code&gt; symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.</source>
          <target state="translated">Тип первого аргумента этого метода - &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;одноэлементный тип&lt;/a&gt; , &lt;code&gt;Type{MyType}&lt;/code&gt; , единственный экземпляр которого - &lt;code&gt;MyType&lt;/code&gt; . Таким образом, этот метод вызывается только тогда, когда первым аргументом является значение типа &lt;code&gt;MyType&lt;/code&gt; . Обратите внимание на синтаксис, используемый для первого аргумента: имя аргумента опускается перед символом &lt;code&gt;::&lt;/code&gt; , и указывается только тип. Это синтаксис в Julia для аргумента функции, тип которого указан, но на значение которого не нужно ссылаться по имени. В этом примере, поскольку тип является одноэлементным, мы уже знаем его значение, не обращаясь к имени аргумента.</target>
        </trans-unit>
        <trans-unit id="3cdf4225b7d8119f12b6f1e72fd124d403b4e26b" translate="yes" xml:space="preserve">
          <source>The type of the first entry of the tuple returned by &lt;code&gt;iterate()&lt;/code&gt;</source>
          <target state="translated">Тип первой записи кортежа, возвращаемого &lt;code&gt;iterate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa022df5697534e05992976fa7f76aa1feeee08" translate="yes" xml:space="preserve">
          <source>The types &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; all have identical representations: they are eight-bit chunks of memory. Since Julia's type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;'s direct supertype is &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt;. All other differences between &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; are matters of behavior &amp;ndash; the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; behave any differently than &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Типы &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; имеют идентичное представление: они представляют собой восьмибитные блоки памяти. Однако, поскольку система типов Джулии является именительным падежом, они не взаимозаменяемы, несмотря на идентичную структуру. Фундаментальное различие между ними состоит в том , что они имеют разные супертипы: &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; &amp;laquo;прямой супертипом s является &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; &amp;raquo; s является &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; , и &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; &amp;laquo;s является &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; . Все остальные различия между &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;- это вопросы поведения - то, как функции определены для действий, когда в качестве аргументов заданы объекты этих типов. Вот почему необходима система номинативного типа: если тип определяется структурой, который, в свою очередь, диктует поведение, тогда невозможно заставить &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; вести себя иначе, чем &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0109db562376dbf272015811ad8745f34d0c123" translate="yes" xml:space="preserve">
          <source>The types of keyword arguments can be made explicit as follows:</source>
          <target state="translated">Типы аргументов по ключевым словам можно выразить следующим образом:</target>
        </trans-unit>
        <trans-unit id="677137168efdb765c37514f4c028e99760d5566b" translate="yes" xml:space="preserve">
          <source>The typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented with the &lt;a href=&quot;https://github.com/timholy/Revise.jl&quot;&gt;Revise.jl&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150a26f4f49fe87245564e04ceb960fcfbaf40b2" translate="yes" xml:space="preserve">
          <source>The unary operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; require explicit parentheses around their argument to disambiguate them from the operator &lt;code&gt;++&lt;/code&gt;, etc. Other compositions of unary operators are parsed with right-associativity, e. g., &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; as &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt;.</source>
          <target state="translated">Унарные операторы &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;-&lt;/code&gt; требуют явных круглых скобок вокруг их аргументов, чтобы отделить их от оператора &lt;code&gt;++&lt;/code&gt; и т. Д. Другие композиции унарных операторов &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; , например, &amp;radic;&amp;radic;-a как &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="e6715363fde6cdd7a1a24ce6e74d2c35a82ab804" translate="yes" xml:space="preserve">
          <source>The underscore &lt;code&gt;_&lt;/code&gt; can be used as digit separator:</source>
          <target state="translated">Знак подчеркивания &lt;code&gt;_&lt;/code&gt; можно использовать как разделитель цифр:</target>
        </trans-unit>
        <trans-unit id="5dc9c5b98b8ad88332e71a97e793e826e1cab445" translate="yes" xml:space="preserve">
          <source>The uniform scaling operator</source>
          <target state="translated">Оператор унифицированного масштабирования</target>
        </trans-unit>
        <trans-unit id="37b7ee86ac667d6f86c0ad3037e31cb90445aa51" translate="yes" xml:space="preserve">
          <source>The updating versions of all the binary arithmetic and bitwise operators are:</source>
          <target state="translated">Обновлены версии всех двоичных арифметических и битовых операторов:</target>
        </trans-unit>
        <trans-unit id="1cf2be628194a336d3bbb72bed6445464a756995" translate="yes" xml:space="preserve">
          <source>The upper triangular part contains the elements of $R$, that is &lt;code&gt;R = triu(F.factors)&lt;/code&gt; for a &lt;code&gt;QR&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">Верхняя треугольная часть содержит элементы $ R $, то есть &lt;code&gt;R = triu(F.factors)&lt;/code&gt; для более &lt;code&gt;QR&lt;/code&gt; объекта &lt;code&gt;F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b49169c7561890a28f7d592fadc2b06ce72bef8" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;$&lt;/code&gt; for expression interpolation is intentionally reminiscent of &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;string interpolation&lt;/a&gt; and &lt;a href=&quot;../running-external-programs/index#command-interpolation&quot;&gt;command interpolation&lt;/a&gt;. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227320fa312076c32b3808304d06cb30fbcb2399" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;$&lt;/code&gt; for expression interpolation is intentionally reminiscent of &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; and &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;command interpolation&lt;/a&gt;. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</source>
          <target state="translated">Использование &lt;code&gt;$&lt;/code&gt; для выражения интерполяции намеренно напоминают &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;интерполяции строк&lt;/a&gt; и &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;командной интерполяции&lt;/a&gt; . Интерполяция выражений обеспечивает удобное и удобное программное построение сложных выражений Джулии.</target>
        </trans-unit>
        <trans-unit id="414780375a6643e2453e6d8634fae95c5ade2420" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; keyword is exactly the same as in other languages, but is often optional. A function without an explicit &lt;code&gt;return&lt;/code&gt; statement will return the last expression in the function body.</source>
          <target state="translated">Использование &lt;a href=&quot;#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; ключевого слова точно так же , как и в других языках, но часто по желанию. Функция без явного &lt;code&gt;return&lt;/code&gt; заявления возвращает последнее выражение в теле функции.</target>
        </trans-unit>
        <trans-unit id="a2d597104e09bc0cd5d3b4e8b871fd483fedc685" translate="yes" xml:space="preserve">
          <source>The user id of the owner of the file</source>
          <target state="translated">Идентификатор пользователя владельца файла</target>
        </trans-unit>
        <trans-unit id="6c6699f50d2afb2e82521e06f95a5e242ef5260f" translate="yes" xml:space="preserve">
          <source>The usual representation of a &lt;code&gt;quote&lt;/code&gt; form in an AST is an &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; with head &lt;code&gt;:quote&lt;/code&gt;:</source>
          <target state="translated">Обычное представление формы &lt;code&gt;quote&lt;/code&gt; в AST - это &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; с заголовком &lt;code&gt;:quote&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="35f0445ac7033162f95af7dffff6b9386fa1de30" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; is used to construct the expression &lt;code&gt;ex&lt;/code&gt; which applies the &lt;code&gt;+&lt;/code&gt; function to the value 1 and the variable &lt;code&gt;b&lt;/code&gt;. Note the important distinction between the way &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are used:</source>
          <target state="translated">Значение &lt;code&gt;a&lt;/code&gt; используется для построения выражения &lt;code&gt;ex&lt;/code&gt; , которое применяет функцию &lt;code&gt;+&lt;/code&gt; к значению 1 и переменной &lt;code&gt;b&lt;/code&gt; . Обратите внимание на важное различие между способами использования &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62de8f816c4cc9e366c76d8b6179874f1c02891f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is only valid immediately after a &lt;code&gt;ccall&lt;/code&gt; to a C library routine that sets it. Specifically, you cannot call &lt;code&gt;errno&lt;/code&gt; at the next prompt in a REPL, because lots of code is executed between prompts.</source>
          <target state="translated">Значение &lt;code&gt;errno&lt;/code&gt; действительно только сразу после &lt;code&gt;ccall&lt;/code&gt; подпрограммы библиотеки C, которая его устанавливает. В частности, вы не можете вызвать &lt;code&gt;errno&lt;/code&gt; в следующем приглашении в REPL, потому что между приглашениями выполняется много кода.</target>
        </trans-unit>
        <trans-unit id="aa580957fe65ae6ff4c7a945625a32e87a3c4957" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;variable&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; at expression construction time is used as an immediate value in the expression. Thus, the value of &lt;code&gt;a&lt;/code&gt; when the expression is evaluated no longer matters: the value in the expression is already &lt;code&gt;1&lt;/code&gt;, independent of whatever the value of &lt;code&gt;a&lt;/code&gt; might be.</source>
          <target state="translated">Значение &lt;em&gt;переменной &lt;/em&gt; &lt;code&gt;a&lt;/code&gt; во время построения выражения используется как непосредственное значение в выражении. Таким образом, значение &lt;code&gt;a&lt;/code&gt; при вычислении выражения больше не имеет значения: значение в выражении уже равно &lt;code&gt;1&lt;/code&gt; , независимо от того, каким может быть значение &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62fc47d335f1e7570e2269aaa97a12567b02a166" translate="yes" xml:space="preserve">
          <source>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, &lt;code&gt;f&lt;/code&gt;, from the previous section this is the value of the expression &lt;code&gt;x + y&lt;/code&gt;. As an alternative, as in many other languages, the &lt;code&gt;return&lt;/code&gt; keyword causes a function to return immediately, providing an expression whose value is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9712274625a8ada140a13908f35f8b798b923a70" translate="yes" xml:space="preserve">
          <source>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, &lt;code&gt;f&lt;/code&gt;, from the previous section this is the value of the expression &lt;code&gt;x + y&lt;/code&gt;. As in C and most other imperative or functional languages, the &lt;code&gt;return&lt;/code&gt; keyword causes a function to return immediately, providing an expression whose value is returned:</source>
          <target state="translated">Значение, возвращаемое функцией, является значением последнего вычисленного выражения, которое по умолчанию является последним выражением в теле определения функции. В примере функции &lt;code&gt;f&lt;/code&gt; из предыдущего раздела это значение выражения &lt;code&gt;x + y&lt;/code&gt; . Как и в C и большинстве других императивных или функциональных языков, ключевое слово &lt;code&gt;return&lt;/code&gt; заставляет функцию немедленно возвращаться, обеспечивая выражение, значение которого возвращается:</target>
        </trans-unit>
        <trans-unit id="c36bf156fd24214b4253de2ab2fb9c5aaef1f580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field &lt;code&gt;a&lt;/code&gt;, the fact that the memory representation of a &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; differs from a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.</source>
          <target state="translated">Значения &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; имеют один и тот же тип, но их базовое представление данных в памяти сильно различается. Даже если вы сохранили только числовые значения в поле &lt;code&gt;a&lt;/code&gt; , тот факт, что представление памяти &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; отличается от &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; ,&lt;/a&gt; также означает, что ЦП должен обрабатывать их, используя два разных типа инструкций. Поскольку требуемая информация недоступна в типе, такие решения необходимо принимать во время выполнения. Это снижает производительность.</target>
        </trans-unit>
        <trans-unit id="9433ae585b495873d9d9e9fc1681dd7a34a786cf" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; are always of the given argument type. (The above expression uses several features that have yet to be introduced, including &lt;a href=&quot;../control-flow/index#man-loops&quot;&gt;for loops&lt;/a&gt;, &lt;a href=&quot;../strings/index#man-strings&quot;&gt;Strings&lt;/a&gt;, and &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;Interpolation&lt;/a&gt;, but should be easy enough to understand for users with some existing programming experience.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8485dbcd7c0bda629f4ab2a94790ee6bae11f052" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; are always of the given argument type. (The above expression uses several features that have yet to be introduced, including &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;for loops&lt;/a&gt;, &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;Strings&lt;/a&gt;, and &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;Interpolation&lt;/a&gt;, but should be easy enough to understand for users with some existing programming experience.)</source>
          <target state="translated">Значения, возвращаемые &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; , всегда относятся к заданному типу аргумента. (В приведенном выше выражении используется несколько функций, которые еще предстоит внедрить, в том числе &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;для циклов&lt;/a&gt; , &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;строк&lt;/a&gt; и &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;интерполяции&lt;/a&gt; , но они должны быть достаточно легкими для понимания пользователями, имеющими некоторый опыт программирования.)</target>
        </trans-unit>
        <trans-unit id="10056f49c16766ab5a7d038814128061f1bc2774" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;relation&lt;/code&gt; is declared inside the &lt;code&gt;if&lt;/code&gt; block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error</source>
          <target state="translated">Переменная &lt;code&gt;relation&lt;/code&gt; объявляется внутри , &lt;code&gt;if&lt;/code&gt; блок, но использовали снаружи. Однако в зависимости от этого поведения убедитесь, что все возможные пути кода определяют значение для переменной. Следующее изменение вышеуказанной функции приводит к ошибке выполнения.</target>
        </trans-unit>
        <trans-unit id="67a867d229f7011e541a374fedf8ebf1c9e53637" translate="yes" xml:space="preserve">
          <source>The variable bound defaults to &lt;a href=&quot;#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; if it is omitted:</source>
          <target state="translated">Граница переменной по умолчанию имеет значение &lt;a href=&quot;#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; ,&lt;/a&gt; если она не указана:</target>
        </trans-unit>
        <trans-unit id="e448ca292ee1dbe02f872083148deaa835508c61" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are bound to the first two argument values as usual, and the variable &lt;code&gt;x&lt;/code&gt; is bound to an iterable collection of the zero or more values passed to &lt;code&gt;bar&lt;/code&gt; after its first two arguments:</source>
          <target state="translated">Переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , как обычно, привязаны к первым двум значениям аргументов, а переменная &lt;code&gt;x&lt;/code&gt; привязана к итерируемой коллекции из нуля или более значений, переданных &lt;code&gt;bar&lt;/code&gt; после его первых двух аргументов:</target>
        </trans-unit>
        <trans-unit id="4a9e1ff901c13ad87d154ae8aa5cd1e9d49a1456" translate="yes" xml:space="preserve">
          <source>The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.</source>
          <target state="translated">Подавляющее большинство функций не будет принимать все виды аргументов,перечисленные выше;числа просто обозначают приоритет,который должен использоваться для любых применимых к функции аргументов.</target>
        </trans-unit>
        <trans-unit id="7e112d8ac7b6cbcda1facaf504ce365573c15593" translate="yes" xml:space="preserve">
          <source>The write barrier is also necessary for arrays of pointers when updating their data directly. For example:</source>
          <target state="translated">Барьер записи также необходим для массивов указателей при непосредственном обновлении их данных.Например:</target>
        </trans-unit>
        <trans-unit id="7df222412e61e0a840295167e1315d4946e8a4b5" translate="yes" xml:space="preserve">
          <source>The year of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Год &lt;code&gt;Date&lt;/code&gt; или &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d787e71667084faaf9bf03d9298e5d0d53aa7e6" translate="yes" xml:space="preserve">
          <source>Then if the environment variable &lt;code&gt;JULIA_BINDIR&lt;/code&gt; is set to &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt;, the output &lt;code&gt;test&lt;/code&gt; program can be executed.</source>
          <target state="translated">Затем, если переменная среды &lt;code&gt;JULIA_BINDIR&lt;/code&gt; установлена ​​в &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt; , программа &lt;code&gt;test&lt;/code&gt; вывода может быть выполнена.</target>
        </trans-unit>
        <trans-unit id="4e05fcf9067a3ef56f500e5010a1c790b20af02a" translate="yes" xml:space="preserve">
          <source>Then if you call &lt;code&gt;Hinter.only_int&lt;/code&gt; on something that isn't an &lt;code&gt;Int&lt;/code&gt; (thereby triggering a &lt;code&gt;MethodError&lt;/code&gt;), it issues the hint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6412317563b7f3c5f3f315499f2ccbf4c0cedb" translate="yes" xml:space="preserve">
          <source>Then navigate to the directory containing your test file (here assumed to be &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt;) and do the following:</source>
          <target state="translated">Затем перейдите в каталог, содержащий ваш тестовый файл (здесь предполагается &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt; ), и выполните следующие действия:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
