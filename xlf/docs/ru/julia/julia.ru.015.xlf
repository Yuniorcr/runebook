<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="7e112d8ac7b6cbcda1facaf504ce365573c15593" translate="yes" xml:space="preserve">
          <source>The write barrier is also necessary for arrays of pointers when updating their data directly. For example:</source>
          <target state="translated">Барьер записи также необходим для массивов указателей при непосредственном обновлении их данных.Например:</target>
        </trans-unit>
        <trans-unit id="7df222412e61e0a840295167e1315d4946e8a4b5" translate="yes" xml:space="preserve">
          <source>The year of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Год &lt;code&gt;Date&lt;/code&gt; или &lt;code&gt;DateTime&lt;/code&gt; как &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d787e71667084faaf9bf03d9298e5d0d53aa7e6" translate="yes" xml:space="preserve">
          <source>Then if the environment variable &lt;code&gt;JULIA_BINDIR&lt;/code&gt; is set to &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt;, the output &lt;code&gt;test&lt;/code&gt; program can be executed.</source>
          <target state="translated">Затем, если переменная среды &lt;code&gt;JULIA_BINDIR&lt;/code&gt; установлена ​​в &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt; , программа &lt;code&gt;test&lt;/code&gt; вывода может быть выполнена.</target>
        </trans-unit>
        <trans-unit id="4e05fcf9067a3ef56f500e5010a1c790b20af02a" translate="yes" xml:space="preserve">
          <source>Then if you call &lt;code&gt;Hinter.only_int&lt;/code&gt; on something that isn't an &lt;code&gt;Int&lt;/code&gt; (thereby triggering a &lt;code&gt;MethodError&lt;/code&gt;), it issues the hint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6412317563b7f3c5f3f315499f2ccbf4c0cedb" translate="yes" xml:space="preserve">
          <source>Then navigate to the directory containing your test file (here assumed to be &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt;) and do the following:</source>
          <target state="translated">Затем перейдите в каталог, содержащий ваш тестовый файл (здесь предполагается &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt; ), и выполните следующие действия:</target>
        </trans-unit>
        <trans-unit id="37376ba231ea09d81df1a6ce675e26bfeb779597" translate="yes" xml:space="preserve">
          <source>Then the internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt; can dispatch on &lt;code&gt;y&lt;/code&gt; without concern about ambiguities with each other with respect to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Затем внутренние методы &lt;code&gt;_fA&lt;/code&gt; и &lt;code&gt;_fB&lt;/code&gt; могут выполнять отправку по &lt;code&gt;y&lt;/code&gt; , не беспокоясь о двусмысленности друг друга относительно &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a87872d7de61942177513edb4dd2621b2f6b9fd" translate="yes" xml:space="preserve">
          <source>Then, replace the main() function in the project with this code:</source>
          <target state="translated">Затем заменить функцию main()в проекте этим кодом:</target>
        </trans-unit>
        <trans-unit id="a59a7debbc5dd22ea37ee07cde6e2c750243ab3c" translate="yes" xml:space="preserve">
          <source>There Does Not Exist</source>
          <target state="translated">Не существует</target>
        </trans-unit>
        <trans-unit id="174782af6882dfdbfbff70b32afe8068951f600e" translate="yes" xml:space="preserve">
          <source>There Exists</source>
          <target state="translated">Существует</target>
        </trans-unit>
        <trans-unit id="f661b9bec6d9caa654535733d72b2847ffe7c84b" translate="yes" xml:space="preserve">
          <source>There also exists a macro &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; that is perhaps a bit more convenient than the &lt;code&gt;macroexpand&lt;/code&gt; function:</source>
          <target state="translated">Также существует макрос &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; ,&lt;/a&gt; который, возможно, немного удобнее функции &lt;code&gt;macroexpand&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ed131b34b67efd7bcdc68ef678577fe7e39a368" translate="yes" xml:space="preserve">
          <source>There are a few more methods we can extend to give Julia more information about this iterable collection. We know that the elements in a &lt;code&gt;Squares&lt;/code&gt; sequence will always be &lt;code&gt;Int&lt;/code&gt;. By extending the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;, too:</source>
          <target state="translated">Есть еще несколько методов, которые мы можем расширить, чтобы предоставить Джулии больше информации об этой повторяемой коллекции. Мы знаем, что элементы в последовательности &lt;code&gt;Squares&lt;/code&gt; всегда будут &lt;code&gt;Int&lt;/code&gt; . Расширяя метод &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; , мы можем передать эту информацию Джулии и помочь ей создать более специализированный код для более сложных методов. Мы также знаем количество элементов в нашей последовательности, поэтому мы можем увеличить &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e637cf035706fa4551de012038849a438d7502e7" translate="yes" xml:space="preserve">
          <source>There are a few noteworthy high-level features about Julia's strings:</source>
          <target state="translated">Есть несколько примечательных особенностей высокого уровня в струнах Джулии:</target>
        </trans-unit>
        <trans-unit id="34b3b70591c85cc9c9daac918201c51d400becd5" translate="yes" xml:space="preserve">
          <source>There are a few specific limitations and warnings to be aware of when using threads in Julia:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f24a9d06c3582bc696ff9d33986f227daf0b74d" translate="yes" xml:space="preserve">
          <source>There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable &lt;code&gt;ans&lt;/code&gt;. A trailing semicolon on the line can be used as a flag to suppress showing the result.</source>
          <target state="translated">Есть ряд полезных функций, уникальных для интерактивной работы. Помимо отображения результата, REPL также связывает результат с переменной &lt;code&gt;ans&lt;/code&gt; . Завершающая точка с запятой в строке может использоваться как флаг для подавления отображения результата.</target>
        </trans-unit>
        <trans-unit id="bd609a022f57cae38b5deceaa4789ea9e71b2150" translate="yes" xml:space="preserve">
          <source>There are also two variants with a &lt;code&gt;mime&lt;/code&gt; argument (a MIME type string, such as &lt;code&gt;&quot;image/png&quot;&lt;/code&gt;), which attempt to display &lt;code&gt;x&lt;/code&gt; using the requested MIME type &lt;em&gt;only&lt;/em&gt;, throwing a &lt;code&gt;MethodError&lt;/code&gt; if this type is not supported by either the display(s) or by &lt;code&gt;x&lt;/code&gt;. With these variants, one can also supply the &quot;raw&quot; data in the requested MIME type by passing &lt;code&gt;x::AbstractString&lt;/code&gt; (for MIME types with text-based storage, such as text/html or application/postscript) or &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; (for binary MIME types).</source>
          <target state="translated">Есть также два варианта с &lt;code&gt;mime&lt;/code&gt; аргумента (тип строки MIME, такие как &lt;code&gt;&quot;image/png&quot;&lt;/code&gt; ), которые пытаются отображения &lt;code&gt;x&lt;/code&gt; , используя запрошенный тип MIME &lt;em&gt;только&lt;/em&gt; , бросать &lt;code&gt;MethodError&lt;/code&gt; , если этот тип не поддерживается либо на дисплее ( s) или &lt;code&gt;x&lt;/code&gt; . В этих вариантах можно также предоставить &amp;laquo;сырые&amp;raquo; данные в запрошенном типе MIME, передав &lt;code&gt;x::AbstractString&lt;/code&gt; (для типов MIME с текстовым хранилищем, таких как text / html или application / postscript) или &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; (для двоичных типов MIME).</target>
        </trans-unit>
        <trans-unit id="da6a42179d7b850f29255071dd5215f3813868d7" translate="yes" xml:space="preserve">
          <source>There are currently four sorting algorithms available in base Julia:</source>
          <target state="translated">В настоящее время в базе данных Джулии доступны четыре алгоритма сортировки:</target>
        </trans-unit>
        <trans-unit id="f7b934f4e2dd58131955f021068fd71f3d77a05f" translate="yes" xml:space="preserve">
          <source>There are differences between &lt;code&gt;@macroexpand&lt;/code&gt; and &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Между &lt;code&gt;@macroexpand&lt;/code&gt; и &lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; есть различия&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04c5ce881d71fd5eb88fb1f43a2852a100537a0d" translate="yes" xml:space="preserve">
          <source>There are four general kinds of cases where constructors differ from &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">Существует четыре основных типа случаев, когда конструкторы отличаются от &lt;code&gt;convert&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="28b7763a452b0a0124e162d0088e4f9f3b24f691" translate="yes" xml:space="preserve">
          <source>There are many more interesting things that you can measure about your program, to get a comprehensive list please read the &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux perf examples page&lt;/a&gt;.</source>
          <target state="translated">Есть еще много интересных вещей, которые вы можете измерить в своей программе. Чтобы получить исчерпывающий список, прочтите &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;страницу примеров производительности Linux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d680424432e24c9faadefbc8f1cb532ede6d65ad" translate="yes" xml:space="preserve">
          <source>There are no classes in Julia. Instead they are structures (mutable or immutable), containing data but no methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e179a904cbafe3721438ffeb346220f23d78177e" translate="yes" xml:space="preserve">
          <source>There are of course a few exceptions. For example, in &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, the type should always come first. In &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, the value comes before the indices so that the indices can be provided as varargs.</source>
          <target state="translated">Конечно, есть несколько исключений. Например, в &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; тип всегда должен стоять первым. В &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;, значение стоит перед индексами, так что индексы могут быть представлены как varargs.</target>
        </trans-unit>
        <trans-unit id="35f0957d73c0fe5b71dd1c5c8bdab57684e38edf" translate="yes" xml:space="preserve">
          <source>There are several different ways to think about this iterator wrapper:</source>
          <target state="translated">Есть несколько различных способов подумать об этой итерационной обертке:</target>
        </trans-unit>
        <trans-unit id="bbb07cbd34fbfc1d048df46439a5fa70e66eefad" translate="yes" xml:space="preserve">
          <source>There are several special types to be aware of, as no other type can be defined to behave the same:</source>
          <target state="translated">Существует несколько специальных типов,о которых следует знать,так как ни один другой тип не может быть определен,чтобы вести себя так же:</target>
        </trans-unit>
        <trans-unit id="9288c1a0f0901c4cadcdfe9e40efa95dc47fcf27" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a2008a07be2d9f32034d88c362d6f0eb2082a1" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">Бывают ситуации, когда вы хотите построить строку или использовать семантику строки, но поведение стандартной строковой конструкции не совсем то, что нужно. Для таких ситуаций Джулия предоставляет &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;нестандартные строковые литералы&lt;/a&gt; . Нестандартный строковый литерал выглядит как обычный строковый литерал в двойных кавычках, но сразу получает префикс идентификатора и не ведет себя совсем как обычный строковый литерал. Регулярные выражения, литералы байтовых массивов и литералы номеров версий, как описано ниже, являются некоторыми примерами нестандартных строковых литералов. Другие примеры приведены в разделе &amp;laquo; &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;Метапрограммирование&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="89cbb0c73360645fdecca6950c82515a07e71685" translate="yes" xml:space="preserve">
          <source>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of &lt;code&gt;T&lt;/code&gt; like so:</source>
          <target state="translated">Бывают ситуации, когда для параметров типа не имеет смысла свободно варьироваться по всем возможным типам. В таких ситуациях можно ограничить диапазон &lt;code&gt;T&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="7fd0dbd27001bbf0cf571035d6ca76de3cfc30cb" translate="yes" xml:space="preserve">
          <source>There are some functions to control the GC. In normal use cases, these should not be necessary.</source>
          <target state="translated">Есть некоторые функции для управления ГК.При нормальном использовании в них не должно быть необходимости.</target>
        </trans-unit>
        <trans-unit id="f09765a26c89d3ba4efc525f188b8d20fe2e6806" translate="yes" xml:space="preserve">
          <source>There are some keys which allow automatically generated log data to be overridden:</source>
          <target state="translated">Есть несколько ключей,которые позволяют переопределять автоматически генерируемые лог-данные:</target>
        </trans-unit>
        <trans-unit id="a452182cf4d04b3b872134735654a28996e85391" translate="yes" xml:space="preserve">
          <source>There are three important standard modules:</source>
          <target state="translated">Существует три важных стандартных модуля:</target>
        </trans-unit>
        <trans-unit id="7aeed63be2ceefd859fdddad806d6d15b8832022" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">Библиотека предоставляет три типа регистраторов. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt; - это средство ведения журнала по умолчанию, которое вы видите при запуске REPL. Он отображает события в удобочитаемом текстовом формате и пытается предоставить простой, но удобный контроль над форматированием и фильтрацией. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt; - удобный способ отбрасывать все сообщения, где это необходимо; это эквивалент потока &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt; - это очень упрощенный регистратор форматирования текста, который в основном полезен для отладки самой системы регистрации.</target>
        </trans-unit>
        <trans-unit id="5e690eabf31525aac327d09327076212853ab17f" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Logging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Logging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bf1c403bd69afc5e26a9a958d5e1ff68b86fdd" translate="yes" xml:space="preserve">
          <source>There are three possible points of return from this function, returning the values of three different expressions, depending on the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The &lt;code&gt;return&lt;/code&gt; on the last line could be omitted since it is the last expression.</source>
          <target state="translated">У этой функции есть три возможных точки возврата, возвращающих значения трех различных выражений, в зависимости от значений &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . &lt;code&gt;return&lt;/code&gt; на последнюю строку можно опустить , так как это последнее выражение.</target>
        </trans-unit>
        <trans-unit id="18fca925f2f77e2b65c8fdde85952641e1650d33" translate="yes" xml:space="preserve">
          <source>There are three specified standard floating-point values that do not correspond to any point on the real number line:</source>
          <target state="translated">Существует три указанных стандартных значения с плавающей точкой,которые не соответствуют ни одной точке на вещественной числовой линии:</target>
        </trans-unit>
        <trans-unit id="2ce18266eafd4e5743ff642c71c4f327eae5b08a" translate="yes" xml:space="preserve">
          <source>There are two categories: generating values from a type (e.g. &lt;code&gt;rand(Int)&lt;/code&gt;), or from a collection (e.g. &lt;code&gt;rand(1:3)&lt;/code&gt;). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use &lt;code&gt;AbstractRNG&lt;/code&gt; in our signatures.</source>
          <target state="translated">Есть две категории: создание значений из типа (например, &lt;code&gt;rand(Int)&lt;/code&gt; ) или из коллекции (например, &lt;code&gt;rand(1:3)&lt;/code&gt; ). Сначала объясняются простые случаи, а более сложные варианты использования представлены позже. Здесь мы предполагаем, что выбор алгоритма не зависит от RNG, поэтому мы используем &lt;code&gt;AbstractRNG&lt;/code&gt; в наших подписях.</target>
        </trans-unit>
        <trans-unit id="57f9b987aba6af24cda8e7334000e333dbb62bc6" translate="yes" xml:space="preserve">
          <source>There are two constructs for repeated evaluation of expressions: the &lt;code&gt;while&lt;/code&gt; loop and the &lt;code&gt;for&lt;/code&gt; loop. Here is an example of a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">Есть две конструкций для повторной оценки выражения: в &lt;code&gt;while&lt;/code&gt; петля и &lt;code&gt;for&lt;/code&gt; цикла. Ниже приведен пример в &lt;code&gt;while&lt;/code&gt; цикла:</target>
        </trans-unit>
        <trans-unit id="5da5a1ee059f0ac2e0add637de14f3676c7deb7b" translate="yes" xml:space="preserve">
          <source>There are two different packages named &lt;code&gt;Priv&lt;/code&gt; that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through &lt;code&gt;Pub&lt;/code&gt;. These are differentiated by their distinct UUIDs, and they have different deps:</source>
          <target state="translated">Приложение использует два разных пакета с именем &lt;code&gt;Priv&lt;/code&gt; . Он использует частный пакет, который является корневой зависимостью, и общедоступный, который является косвенной зависимостью через &lt;code&gt;Pub&lt;/code&gt; . Они различаются по своим уникальным UUID и имеют разные значения:</target>
        </trans-unit>
        <trans-unit id="a80cf781eb3e259c907910355de5e57b87258bfc" translate="yes" xml:space="preserve">
          <source>There are two mostly orthogonal ways to extend &lt;code&gt;Random&lt;/code&gt; functionalities:</source>
          <target state="translated">Существует два в основном ортогональных способа расширения функциональности &lt;code&gt;Random&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d2e30fededfc9e0acc9aec32cc305e4b3edfd71f" translate="yes" xml:space="preserve">
          <source>There are two possible shortened forms for the &lt;code&gt;return nothing&lt;/code&gt; expression. On the one hand, the &lt;code&gt;return&lt;/code&gt; keyword implicitly returns &lt;code&gt;nothing&lt;/code&gt;, so it can be used alone. On the other hand, since functions implicitly return their last expression evaluated, &lt;code&gt;nothing&lt;/code&gt; can be used alone when it's the last expression. The preference for the expression &lt;code&gt;return nothing&lt;/code&gt; as opposed to &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; alone is a matter of coding style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15f1d9e0b0d6aa79c92366d6d55c444ac8dd9c4" translate="yes" xml:space="preserve">
          <source>There are various ways to run Julia code and provide options, similar to those available for the &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;ruby&lt;/code&gt; programs:</source>
          <target state="translated">Есть различные способы запустить код Julia и предоставить параметры, аналогичные тем, которые доступны для программ &lt;code&gt;perl&lt;/code&gt; и &lt;code&gt;ruby&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe7ec7d12394b96c015a1c2e093208538245f475" translate="yes" xml:space="preserve">
          <source>There exists no loop-carried memory dependencies</source>
          <target state="translated">Зависимостей в зацикленной памяти не существует.</target>
        </trans-unit>
        <trans-unit id="167978b2ab5201a534fdd8a54c05583e0811193a" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../base/collections/index#Base.Pair&quot;&gt;&lt;code&gt;Pair&lt;/code&gt;&lt;/a&gt; type, but it is not meant to be used as a &lt;code&gt;COMMON-LISP:CONS&lt;/code&gt;. Various iterable collections can be used interchangeably in most parts of the language (eg splatting, tuples, etc). &lt;code&gt;Tuple&lt;/code&gt;s are the closest to Common Lisp lists for &lt;em&gt;short&lt;/em&gt; collections of heterogeneous elements. Use &lt;code&gt;NamedTuple&lt;/code&gt;s in place of alists. For larger collections of homogeneous types, &lt;code&gt;Array&lt;/code&gt;s and &lt;code&gt;Dict&lt;/code&gt;s should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe9d20052debba9991c8dfc120934a6e59ce3f0" translate="yes" xml:space="preserve">
          <source>There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</source>
          <target state="translated">Существует удобный синтаксис для именования таких типов,аналогичный короткой форме синтаксиса определения функций:</target>
        </trans-unit>
        <trans-unit id="c4273d4f01461968327256a1b4317f5663291a1c" translate="yes" xml:space="preserve">
          <source>There is a global named &lt;code&gt;s&lt;/code&gt;, so &lt;code&gt;s = t&lt;/code&gt; assigns to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3481a52901e12b38922b7141656dfae7e68cc28" translate="yes" xml:space="preserve">
          <source>There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in &lt;code&gt;quote ... end&lt;/code&gt;.</source>
          <target state="translated">Существует вторая синтаксическая форма цитирования для нескольких выражений: блоки кода, заключенные в &lt;code&gt;quote ... end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89fb23b7683ecb8e95311e78406e7a19ca4a906a" translate="yes" xml:space="preserve">
          <source>There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact &quot;assignment form&quot;:</source>
          <target state="translated">Существует второй,более лаконичный синтаксис для определения функции в Джулии.Традиционный синтаксис декларирования функций,продемонстрированный выше,эквивалентен следующей компактной &quot;форме назначения&quot;:</target>
        </trans-unit>
        <trans-unit id="b0f3efad279d61a3ae46bad7c874ec9a27487608" translate="yes" xml:space="preserve">
          <source>There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, &lt;code&gt;T&lt;/code&gt;, the &quot;singleton type&quot; &lt;code&gt;Type{T}&lt;/code&gt; is an abstract type whose only instance is the object &lt;code&gt;T&lt;/code&gt;. Since the definition is a little difficult to parse, let's look at some examples:</source>
          <target state="translated">Здесь следует упомянуть особый вид абстрактного параметрического типа: одиночные типы. Для каждого типа, &lt;code&gt;T&lt;/code&gt; , то &amp;laquo;одноэлементный тип&amp;raquo; &lt;code&gt;Type{T}&lt;/code&gt; является абстрактным типом которого единственный экземпляр является объектом &lt;code&gt;T&lt;/code&gt; . Поскольку определение немного сложно разобрать, давайте рассмотрим несколько примеров:</target>
        </trans-unit>
        <trans-unit id="4edd8c08b09effa574afae30fbef7845d91eb8b4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; function, and a more general &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt;&lt;code&gt;oftype(x, y)&lt;/code&gt;&lt;/a&gt; function, which returns &lt;code&gt;y&lt;/code&gt; converted to the type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Существует также функция &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; и более общая &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt; &lt;code&gt;oftype(x, y)&lt;/code&gt; &lt;/a&gt; , которая возвращает &lt;code&gt;y&lt;/code&gt; , преобразованный в тип &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734126eef49207ddeb0d4f566a4461c7a515e501" translate="yes" xml:space="preserve">
          <source>There is also a concise syntax for nested &lt;code&gt;where&lt;/code&gt; expressions. For example, this:</source>
          <target state="translated">Также существует краткий синтаксис для вложенных выражений &lt;code&gt;where&lt;/code&gt; . Например, это:</target>
        </trans-unit>
        <trans-unit id="3485de030aea8df4c966053791640ea9fedf8c2e" translate="yes" xml:space="preserve">
          <source>There is also a method &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; to checksum &lt;code&gt;nb&lt;/code&gt; bytes from a stream &lt;code&gt;io&lt;/code&gt;, or &lt;code&gt;crc32c(io, crc)&lt;/code&gt; to checksum all the remaining bytes. Hence you can do &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open(crc32c, filename)&lt;/code&gt;&lt;/a&gt; to checksum an entire file, or &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; to checksum an &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; without calling &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">Также существует метод &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; для контрольной суммы &lt;code&gt;nb&lt;/code&gt; байтов из потока &lt;code&gt;io&lt;/code&gt; или &lt;code&gt;crc32c(io, crc)&lt;/code&gt; для контрольной суммы всех оставшихся байтов. Следовательно, вы можете выполнить &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open(crc32c, filename)&lt;/code&gt; &lt;/a&gt; для проверки контрольной суммы всего файла или &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; для &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; контрольной суммы IOBuffer без вызова &lt;code&gt;take!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="923a006c576c90e740ad341ee467086ea5813910" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5507a1ebe82bf577a426867e01303c626cf9abd7" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">О том, как создаются экземпляры составных типов, можно сказать гораздо больше, но это обсуждение зависит как от &lt;a href=&quot;#Parametric-Types-1&quot;&gt;параметрических типов, так&lt;/a&gt; и от &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;методов&lt;/a&gt; и достаточно важно, чтобы его рассмотреть в отдельном разделе: &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Конструкторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ae09c7d6ba8798034e4671d0b26e5b85ce05ddc" translate="yes" xml:space="preserve">
          <source>There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</source>
          <target state="translated">Нет разделения между объектными и необъектными значениями:все значения в Юлии являются истинными объектами,имеющими тип,принадлежащий единому,полностью связанному графу типа,все узлы которого одинаково первоклассны,как и типы.</target>
        </trans-unit>
        <trans-unit id="d4c6baab6e4cf883e88c1aedd0d9bd2aa047689e" translate="yes" xml:space="preserve">
          <source>There is no global named &lt;code&gt;t&lt;/code&gt;, so &lt;code&gt;t = s + i&lt;/code&gt; creates a new &lt;code&gt;t&lt;/code&gt; that is local to the &lt;code&gt;for&lt;/code&gt; loop;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799561e1d3a80d4e278504aa2e10c84451ac9ffd" translate="yes" xml:space="preserve">
          <source>There is no invalid (NULL) &lt;code&gt;Ref&lt;/code&gt; in Julia, but a &lt;code&gt;C_NULL&lt;/code&gt; instance of &lt;code&gt;Ptr&lt;/code&gt; can be passed to a &lt;code&gt;ccall&lt;/code&gt; Ref argument.</source>
          <target state="translated">Там нет недействительна (NULL) &lt;code&gt;Ref&lt;/code&gt; в Джулию, но &lt;code&gt;C_NULL&lt;/code&gt; экземпляр &lt;code&gt;Ptr&lt;/code&gt; может быть передана в &lt;code&gt;ccall&lt;/code&gt; реф аргумент.</target>
        </trans-unit>
        <trans-unit id="11bffac25c301a4657b1c60789201ca8aff715a3" translate="yes" xml:space="preserve">
          <source>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running. This is called a &quot;run-time type&quot; in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</source>
          <target state="translated">Нет никакого осмысленного понятия &quot;тип времени компиляции&quot;:единственный тип,которым обладает значение,это его фактический тип во время выполнения программы.В объектно-ориентированных языках это называется &quot;run-time type&quot;,где сочетание статической компиляции с полиморфизмом делает это различие существенным.</target>
        </trans-unit>
        <trans-unit id="e3d48c4d50de4372a5a2ecbc4a1b8db9674c176e" translate="yes" xml:space="preserve">
          <source>There is no more to the implementation of &lt;code&gt;Val&lt;/code&gt; than this. Some functions in Julia's standard library accept &lt;code&gt;Val&lt;/code&gt; instances as arguments, and you can also use it to write your own functions. For example:</source>
          <target state="translated">Реализация &lt;code&gt;Val&lt;/code&gt; - это не что иное, как это. Некоторые функции в стандартной библиотеке Julia принимают экземпляры &lt;code&gt;Val&lt;/code&gt; в качестве аргументов, и вы также можете использовать их для написания своих собственных функций. Например:</target>
        </trans-unit>
        <trans-unit id="225dfa7c16e90d2f9982aa1b83dde6be688afb63" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="translated">Существует еще одно специальное соглашение о &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt; &lt;code&gt;llvmcall&lt;/code&gt; &lt;/a&gt; , которое позволяет напрямую вставлять вызовы встроенным функциям LLVM. Это может быть особенно полезно при нацеливании на необычные платформы, такие как GPGPU. Например, для &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt; нам нужно иметь возможность читать индекс потока:</target>
        </trans-unit>
        <trans-unit id="15a160baa2fcd00f2095be3f6987dc4bfa73177f" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;https://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982d9172cf71b589801a04a1718b7e1140ec78b8" translate="yes" xml:space="preserve">
          <source>There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; is that with &lt;code&gt;using&lt;/code&gt; you need to say &lt;code&gt;function Foo.bar(..&lt;/code&gt; to extend module Foo's function bar with a new method, but with &lt;code&gt;import Foo.bar&lt;/code&gt;, you only need to say &lt;code&gt;function bar(...&lt;/code&gt; and it automatically extends module Foo's function bar.</source>
          <target state="translated">Есть только одно отличие, и на первый взгляд (с точки зрения синтаксиса) оно может показаться очень незначительным. Разница между &lt;code&gt;using&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; заключается в том, что при &lt;code&gt;using&lt;/code&gt; вам нужно сказать &lt;code&gt;function Foo.bar(..&lt;/code&gt; чтобы расширить функциональную панель модуля Foo новым методом, но при &lt;code&gt;import Foo.bar&lt;/code&gt; вам нужно только сказать &lt;code&gt;function bar(...&lt;/code&gt; и он автоматически расширяет функциональную панель модуля Foo.</target>
        </trans-unit>
        <trans-unit id="40b79a3c7d53b455d5a062d0c3faf4f4007912a3" translate="yes" xml:space="preserve">
          <source>There is some overlap between these rules since the behavior of &lt;code&gt;\x&lt;/code&gt; and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</source>
          <target state="translated">Между этими правилами есть некоторое совпадение, поскольку поведение &lt;code&gt;\x&lt;/code&gt; и восьмеричных escape-символов меньше 0x80 (128) покрывается обоими из первых двух правил, но здесь эти правила согласуются. Вместе эти правила позволяют легко использовать символы ASCII, произвольные значения байтов и последовательности UTF-8 для создания массивов байтов. Вот пример использования всех трех:</target>
        </trans-unit>
        <trans-unit id="9a0371b0510547518bd685c0ced89d4cf0d5a48b" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8e36fc8e9774033114f307d267a46fecf4de03" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">Есть еще один случай, который обрабатывает фактический макрос &lt;code&gt;@assert&lt;/code&gt; : что, если бы, помимо вывода &amp;laquo;a должно быть равно b&amp;raquo;, мы хотели бы распечатать их значения? Можно наивно попытаться использовать интерполяцию строк в настраиваемом сообщении, например, &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; , но это не будет работать должным образом с указанным выше макросом. Вы понимаете почему? Вспомните из &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;интерполяции строк,&lt;/a&gt; что интерполированная строка переписывается в вызов &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; . Для сравнения:</target>
        </trans-unit>
        <trans-unit id="d3e7d0ac84e899740c4a2f0bb3ee4413427fcc34" translate="yes" xml:space="preserve">
          <source>There's also some key value pairs which have conventional meaning:</source>
          <target state="translated">Есть также некоторые пары ключевых значений,которые имеют условное значение:</target>
        </trans-unit>
        <trans-unit id="f6f36ec125f2f895a5ef2bd1d15fb610bf42b808" translate="yes" xml:space="preserve">
          <source>Therefore</source>
          <target state="translated">Therefore</target>
        </trans-unit>
        <trans-unit id="2f243754615f97fed5cd732a70910cb99d584308" translate="yes" xml:space="preserve">
          <source>Therefore, if an &lt;code&gt;Array&lt;/code&gt; contains data in the wrong format, it will have to be explicitly converted using a call such as &lt;code&gt;trunc(Int32, a)&lt;/code&gt;.</source>
          <target state="translated">Следовательно, если &lt;code&gt;Array&lt;/code&gt; содержит данные в неправильном формате, его необходимо будет явно преобразовать с помощью такого вызова, как &lt;code&gt;trunc(Int32, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db219bff6d21bdc3e30fad396993a55966a94d9d" translate="yes" xml:space="preserve">
          <source>These are all single-argument functions, with &lt;code&gt;atan&lt;/code&gt; also accepting two arguments corresponding to a traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Все это функции с одним аргументом, при этом &lt;code&gt;atan&lt;/code&gt; также принимает два аргумента, соответствующих традиционной функции &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14803da413b77436b3c2d4357e087f5e0536c055" translate="yes" xml:space="preserve">
          <source>These are some minor points that might help in tight inner loops.</source>
          <target state="translated">Это некоторые незначительные моменты,которые могут помочь в узких внутренних петлях.</target>
        </trans-unit>
        <trans-unit id="f489d10be7b6a63303842ebf419258e8b767140d" translate="yes" xml:space="preserve">
          <source>These are standard system mutexes for locking critical sections of logic.</source>
          <target state="translated">Это стандартные системные мьютексы для блокировки критических участков логики.</target>
        </trans-unit>
        <trans-unit id="d1641abea44eab3cf0ec515a65636237d8dacb4d" translate="yes" xml:space="preserve">
          <source>These building blocks are used to create the regular synchronization objects.</source>
          <target state="translated">Эти строительные блоки используются для создания объектов регулярной синхронизации.</target>
        </trans-unit>
        <trans-unit id="565962f2637fab496a10fd1e88eadfa7fec7f65c" translate="yes" xml:space="preserve">
          <source>These can be intermixed to create &lt;strong&gt;a stacked environment&lt;/strong&gt;: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.</source>
          <target state="translated">Их можно смешивать для создания &lt;strong&gt;многослойной среды&lt;/strong&gt; : упорядоченного набора сред проекта и каталогов пакетов, наложенных &lt;strong&gt;друг на друга&lt;/strong&gt; , чтобы создать единую составную среду. Затем правила приоритета и видимости объединяются, чтобы определить, какие пакеты доступны и откуда они загружаются. Например, путь загрузки Джулии образует сложную среду.</target>
        </trans-unit>
        <trans-unit id="ad9e158cfed42f0988f112a79734599400b1a65e" translate="yes" xml:space="preserve">
          <source>These environment each serve a different purpose:</source>
          <target state="translated">Каждая из этих сред служит своей цели:</target>
        </trans-unit>
        <trans-unit id="df0dd5f0a0b3669798f0ca8386e219bbefc17e9d" translate="yes" xml:space="preserve">
          <source>These environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">Эти переменные среды действуют только в том случае, если Julia была скомпилирована с отладкой со сборкой мусора (то есть, если &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; установлено в &lt;code&gt;1&lt;/code&gt; в конфигурации сборки).</target>
        </trans-unit>
        <trans-unit id="8da007debd6546e5bcd6fdc6a81faf692113b0dd" translate="yes" xml:space="preserve">
          <source>These events are disabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0986fe52ee36d8b5c27e28a863c7c354ad5a04" translate="yes" xml:space="preserve">
          <source>These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, &lt;em&gt;don't copy them&lt;/em&gt;, for the following reasons:</source>
          <target state="translated">Надеемся, что эти примеры помогут проиллюстрировать, как работают сгенерированные функции, как в конце определения, так и в месте вызова; однако &lt;em&gt;не копируйте их&lt;/em&gt; по следующим причинам:</target>
        </trans-unit>
        <trans-unit id="aa722e52b03e87753d276a993e9d5484f0d06210" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22560ff89133b8a8d38ebe85a09966debefcae5" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">Эти функции полезны в &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;числовых сравнениях,&lt;/a&gt; чтобы избежать накладных расходов из-за ненужного &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;преобразования типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="901a72532a01b48c0a0b20d9a2bd0c5a053c7001" translate="yes" xml:space="preserve">
          <source>These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations &amp;ndash; it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, but beyond that, there are hardly any calls to &lt;code&gt;promote&lt;/code&gt; required in Julia Base. The most common usages of &lt;code&gt;promote&lt;/code&gt; occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt; provides the following outer constructor method:</source>
          <target state="translated">В этих определениях методов говорится, что в отсутствие более конкретных правил сложения, вычитания, умножения и деления пар числовых значений преобразовать значения в общий тип и затем повторить попытку. Вот и все: больше нигде не нужно беспокоиться о переводе арифметических операций в общий числовой тип - это просто происходит автоматически. Есть определения улова-все методы продвижения для ряда других арифметических и математических функций в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt; , но помимо этого, есть едва любые вызовы &lt;code&gt;promote&lt;/code&gt; необходимым в Джулии базе. Наиболее распространенные способы &lt;code&gt;promote&lt;/code&gt; встречаются в методах внешних конструкторов, предоставленных для удобства, чтобы позволить вызовам конструкторов со смешанными типами делегировать внутреннему типу с полями, повышенными до соответствующего общего типа. Например, напомним, что &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt; предоставляет следующий метод внешнего конструктора:</target>
        </trans-unit>
        <trans-unit id="38c599bfc89604d7c3dd9692be93915fc155443a" translate="yes" xml:space="preserve">
          <source>These questions are answered by searching through the project environments listed in &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; for project files (&lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt;), manifest files (&lt;code&gt;Manifest.toml&lt;/code&gt; or &lt;code&gt;JuliaManifest.toml&lt;/code&gt;), or folders of source files.</source>
          <target state="translated">Эти вопросы отвечают путем поиска сред проектов , перечисленных в &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;/a&gt; файлов проекта ( &lt;code&gt;Project.toml&lt;/code&gt; или &lt;code&gt;JuliaProject.toml&lt;/code&gt; ), файлы манифеста ( &lt;code&gt;Manifest.toml&lt;/code&gt; или &lt;code&gt;JuliaManifest.toml&lt;/code&gt; ) или папки исходных файлов.</target>
        </trans-unit>
        <trans-unit id="9e5166e13cc42aee4b6f34ab71374c703764b19f" translate="yes" xml:space="preserve">
          <source>These rules indicate that the combination of a &lt;code&gt;SparseVecStyle&lt;/code&gt; with 0- or 1-dimensional arrays yields another &lt;code&gt;SparseVecStyle&lt;/code&gt;, that its combination with a 2-dimensional array yields a &lt;code&gt;SparseMatStyle&lt;/code&gt;, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an &lt;code&gt;Array&lt;/code&gt; for any other dimensionality.</source>
          <target state="translated">Эти правила показывают, что комбинация &lt;code&gt;SparseVecStyle&lt;/code&gt; с 0- или 1-мерными массивами дает другой &lt;code&gt;SparseVecStyle&lt;/code&gt; , что его комбинация с 2-мерным массивом дает &lt;code&gt;SparseMatStyle&lt;/code&gt; , а все, что имеет более высокую размерность, возвращается к плотной структуре произвольной размерности. Эти правила позволяют широковещательной рассылке сохранять разреженное представление для операций, которые приводят к одно- или двумерным выходным данным, но создают &lt;code&gt;Array&lt;/code&gt; для любой другой размерности.</target>
        </trans-unit>
        <trans-unit id="ff63dfa77616c617504be7f6834247f76c057dc5" translate="yes" xml:space="preserve">
          <source>These values are &lt;code&gt;2.0^-23&lt;/code&gt; and &lt;code&gt;2.0^-52&lt;/code&gt; as &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, respectively. The &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, &lt;code&gt;eps(x)&lt;/code&gt; yields a value of the same type as &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;x + eps(x)&lt;/code&gt; is the next representable floating-point value larger than &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">Эти значения равны &lt;code&gt;2.0^-23&lt;/code&gt; и &lt;code&gt;2.0^-52&lt;/code&gt; как значения &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; соответственно. Функция &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; также может принимать значение с плавающей запятой в качестве аргумента и дает абсолютную разницу между этим значением и следующим представимым значением с плавающей запятой. То есть &lt;code&gt;eps(x)&lt;/code&gt; возвращает значение того же типа, что и &lt;code&gt;x&lt;/code&gt; , так что &lt;code&gt;x + eps(x)&lt;/code&gt; является следующим представимым значением с плавающей запятой, большим, чем &lt;code&gt;x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3b947ad0ffcb0e9ad54a5598ed57c34a7f7c5d4" translate="yes" xml:space="preserve">
          <source>These will not specialize:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33ed7c0575b9d7d40952cddc046e39e47a4df14" translate="yes" xml:space="preserve">
          <source>They are explicitly declared.</source>
          <target state="translated">Они прямо объявлены.</target>
        </trans-unit>
        <trans-unit id="9da6c9effd58ab0ae90e923f7a38a897dca353b9" translate="yes" xml:space="preserve">
          <source>They have explicitly declared supertypes.</source>
          <target state="translated">Они прямо заявили о супертипах.</target>
        </trans-unit>
        <trans-unit id="6e52fab1fc6f56c83a090442135c118d8a782f83" translate="yes" xml:space="preserve">
          <source>They have names.</source>
          <target state="translated">У них есть имена.</target>
        </trans-unit>
        <trans-unit id="062847d8bdfc031c0804b383d54688583d1d3428" translate="yes" xml:space="preserve">
          <source>They may have parameters.</source>
          <target state="translated">У них могут быть параметры.</target>
        </trans-unit>
        <trans-unit id="ce535b7c90d1f3779f26e6dbf670c470fd87540b" translate="yes" xml:space="preserve">
          <source>Thin Space</source>
          <target state="translated">Тонкое пространство</target>
        </trans-unit>
        <trans-unit id="b917e561d5e2ee00e3622e65889d344d78e37e20" translate="yes" xml:space="preserve">
          <source>Think of it as an alternative to using &lt;code&gt;println&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794b36899e8ad96433bb7cbe178ed7bf875ad605" translate="yes" xml:space="preserve">
          <source>This &quot;declaration&quot; behavior only occurs in specific contexts:</source>
          <target state="translated">Такое &quot;декларативное&quot; поведение имеет место только в конкретных контекстах:</target>
        </trans-unit>
        <trans-unit id="41a800e609852a7906e603a30a74797aa896d16f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;errno&lt;/code&gt; symbol may not be found in a library named &quot;libc&quot;, as this is an implementation detail of your system compiler. Typically standard library symbols should be accessed just by name, allowing the compiler to fill in the correct one. Also, however, the &lt;code&gt;errno&lt;/code&gt; symbol shown in this example is special in most compilers, and so the value seen here is probably not what you expect or want. Compiling the equivalent code in C on any multi-threaded-capable system would typically actually call a different function (via macro preprocessor overloading), and may give a different result than the legacy value printed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e55b956134479b369056b6e59411296357349dc" translate="yes" xml:space="preserve">
          <source>This addresses both issues while preserving the &quot;programming at scale&quot; benefits of the 1.0 behavior: global variables have no spooky effect on the meaning of code that may be far away; in the REPL copy-and-paste debugging works and beginners don't have any issues; any time someone either forgets a &lt;code&gt;global&lt;/code&gt; annotation or accidentally shadows an existing global with a local in a soft scope, which would be confusing anyway, they get a nice clear warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8272048e9f98c6a3a33f1987ea12ed1eecadb9" translate="yes" xml:space="preserve">
          <source>This adds the numbers first, then finds the square root of the result.</source>
          <target state="translated">Сначала он добавляет числа,а затем находит квадратный корень результата.</target>
        </trans-unit>
        <trans-unit id="7e48b7632d07fb8a10c769f17c80cd8b54e9e2ae" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;a&lt;/code&gt; to be of any type. This can often be useful, but it does have a downside: for objects of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;:</source>
          <target state="translated">Это позволяет быть любого типа. Часто это может быть полезно, но у него есть обратная сторона: для объектов типа &lt;code&gt;MyAmbiguousType&lt;/code&gt; компилятор не сможет генерировать высокопроизводительный код. Причина в том, что компилятор использует типы объектов, а не их значения, чтобы определить, как строить код. К сожалению, об объекте типа &lt;code&gt;MyAmbiguousType&lt;/code&gt; можно сделать очень мало выводов : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ab1e715cac0200b469eb5f929c0503f3de4aef" translate="yes" xml:space="preserve">
          <source>This allows a type assertion to be attached to any expression in-place.</source>
          <target state="translated">Это позволяет прикрепить утверждение типа к любому выражению на месте.</target>
        </trans-unit>
        <trans-unit id="3f66025a332eaca14516e5e48d7273aad3164c30" translate="yes" xml:space="preserve">
          <source>This allows calls like the following to work:</source>
          <target state="translated">Это позволяет работать со следующими вызовами:</target>
        </trans-unit>
        <trans-unit id="c0d02575ed936e3b66af9d0af1e8728459d34bc3" translate="yes" xml:space="preserve">
          <source>This allows functions which operate on indices to work in combination with &lt;code&gt;skipmissing&lt;/code&gt;. This is notably the case for search and find functions, which return indices valid for the object returned by &lt;code&gt;skipmissing&lt;/code&gt; which are also the indices of the matching entries &lt;em&gt;in the parent array&lt;/em&gt;</source>
          <target state="translated">Это позволяет функциям, работающим с индексами, работать в сочетании с &lt;code&gt;skipmissing&lt;/code&gt; . Это особенно характерно для функций поиска и поиска, которые возвращают индексы, действительные для объекта, возвращенного путем &lt;code&gt;skipmissing&lt;/code&gt; которые также являются индексами совпадающих записей &lt;em&gt;в родительском массиве.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964d516d9978a231b3ac23253bbb246eab6f09f8" translate="yes" xml:space="preserve">
          <source>This approach works very well: the compiler can figure out that &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;Array{Float64,2}&lt;/code&gt; because it knows the type of the fill value (&lt;code&gt;5.0::Float64&lt;/code&gt;) and the dimensionality (&lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt;). This implies that the compiler can generate very efficient code for any future usage of &lt;code&gt;A&lt;/code&gt; in the same function.</source>
          <target state="translated">Этот подход работает очень хорошо: компилятор может определить, что &lt;code&gt;A&lt;/code&gt; является &lt;code&gt;Array{Float64,2}&lt;/code&gt; потому что ему известен тип значения заполнения ( &lt;code&gt;5.0::Float64&lt;/code&gt; ) и размерность ( &lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt; ). Это означает, что компилятор может сгенерировать очень эффективный код для любого будущего использования &lt;code&gt;A&lt;/code&gt; в той же функции.</target>
        </trans-unit>
        <trans-unit id="65ab8a07106b1c3de72359a692edb4ea0bcec610" translate="yes" xml:space="preserve">
          <source>This argument will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">Этот аргумент будет вычислен во время компиляции,когда будет определен содержащий метод.</target>
        </trans-unit>
        <trans-unit id="88e9b548070741ac9a8e34f0ecf3fa01c0587738" translate="yes" xml:space="preserve">
          <source>This avoids the need to continually check for &lt;code&gt;null&lt;/code&gt; values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</source>
          <target state="translated">Это избавляет от необходимости постоянно проверять &lt;code&gt;null&lt;/code&gt; значения. Однако не все поля объекта являются ссылками. Джулия считает некоторые типы &amp;laquo;простыми данными&amp;raquo;, то есть все их данные являются самодостаточными и не ссылаются на другие объекты. Простые типы данных состоят из примитивных типов (например, &lt;code&gt;Int&lt;/code&gt; ) и неизменяемых структур других простых типов данных. Начальное содержимое простого типа данных не определено:</target>
        </trans-unit>
        <trans-unit id="ce41dd9c15eebc75ffb2137b16913cc2ba4e006d" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32fb96b8a45f2e62ae5fc588473c2b576e96e47" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">Такое поведение является неудобным следствием требования стабильности типов. В случае &lt;code&gt;sqrt&lt;/code&gt; большинство пользователей хотят, чтобы &lt;code&gt;sqrt(2.0)&lt;/code&gt; давал действительное число, и были бы недовольны, если бы он произвел комплексное число &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; . Можно написать функцию &lt;code&gt;sqrt&lt;/code&gt; для переключения на комплексный вывод только при передаче отрицательного числа (это то, что &lt;code&gt;sqrt&lt;/code&gt; делает на некоторых других языках), но тогда результат не будет &lt;a href=&quot;#man-type-stability-1&quot;&gt;стабильным по типу,&lt;/a&gt; и функция &lt;code&gt;sqrt&lt;/code&gt; будет иметь низкую производительность. ,</target>
        </trans-unit>
        <trans-unit id="df974535f8d9fdf5af581b7209a9a7d77c94fbc7" translate="yes" xml:space="preserve">
          <source>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</source>
          <target state="translated">Такое поведение основано на наблюдении,что при использовании беззнаковых гекс-литералов для целочисленных значений,человек обычно использует их для представления фиксированной числовой последовательности байтов,а не просто для целочисленного значения.</target>
        </trans-unit>
        <trans-unit id="e939e0293859dfba0c56cba20185fcd5c0865911" translate="yes" xml:space="preserve">
          <source>This behavior is frequently used in Julia to form an alternative to very short &lt;code&gt;if&lt;/code&gt; statements. Instead of &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;and then&lt;/em&gt; &amp;lt;statement&amp;gt;). Similarly, instead of &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;or else&lt;/em&gt; &amp;lt;statement&amp;gt;).</source>
          <target state="translated">Такое поведение часто используется в Julia для создания альтернативы очень коротким операторам &lt;code&gt;if&lt;/code&gt; . Вместо &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; , можно написать &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (что может читаться как: &amp;lt;second&amp;gt;, &lt;em&gt;а затем&lt;/em&gt; &amp;lt;statement&amp;gt;). Точно так же вместо &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; , можно написать &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; (которое можно читать как: &amp;lt;секунда&amp;gt; &lt;em&gt;или иначе&lt;/em&gt; &amp;lt;утверждение&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="d466a277725d7aaf417bf4b4dabee60f49d4157d" translate="yes" xml:space="preserve">
          <source>This behavior may seem slightly odd for a normal variable, but allows for named functions &amp;ndash; which are just normal variables holding function objects &amp;ndash; to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:</source>
          <target state="translated">Такое поведение может показаться немного странным для обычной переменной, но позволяет использовать именованные функции, которые являются просто обычными переменными, содержащими объекты функций, до их определения. Это позволяет определять функции в любом порядке, который интуитивно понятен и удобен, вместо того, чтобы принудительно упорядочивать их снизу вверх или требовать предварительных объявлений, если они определены на момент их фактического вызова. В качестве примера, вот неэффективный, взаимно рекурсивный способ проверить, являются ли положительные целые числа четными или нечетными:</target>
        </trans-unit>
        <trans-unit id="3e1626f887cd8eeaf56c26ebd7e57a24196949b2" translate="yes" xml:space="preserve">
          <source>This behavior of this function varies slightly across platforms. See &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; for more detailed information.</source>
          <target state="translated">Такое поведение этой функции незначительно отличается на разных платформах. См. &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;Https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="c6ca83ad215b371ad26283d27822e70d4564ed25" translate="yes" xml:space="preserve">
          <source>This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</source>
          <target state="translated">Этот звонок,похоже,ничего не даст.Однако можно проверить,было ли сделано исключение:</target>
        </trans-unit>
        <trans-unit id="60083a6ef6ec3da96fc4da91379010508c3c9d6d" translate="yes" xml:space="preserve">
          <source>This calls the C standard library function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d143c9aa138ee903b0f4b83e6fabab2460ecb668" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3faddba8dc5ff630709111fd27507fc4b444f486" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">Это можно выразить гораздо проще с помощью &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;широковещательной рассылки точек&lt;/a&gt; и объединения ее с обычным целочисленным индексом (вместо извлечения первой &lt;code&gt;page&lt;/code&gt; из &lt;code&gt;A&lt;/code&gt; как отдельного шага). Его можно даже комбинировать с &lt;code&gt;:&lt;/code&gt; для одновременного извлечения обеих диагоналей с двух страниц:</target>
        </trans-unit>
        <trans-unit id="547aafc7ff388590993edee0cc0798c17880cfea" translate="yes" xml:space="preserve">
          <source>This can be identical to the signature present in the Julia code (like &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt;), or a simplified form. Optional arguments should be represented with their default values (i.e. &lt;code&gt;f(x, y=1)&lt;/code&gt;) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. &lt;code&gt;f(x[, y])&lt;/code&gt; and &lt;code&gt;f(x[, y[, z]])&lt;/code&gt;). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; placeholder in the signature (i.e. &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt;), and give the complete list under an &lt;code&gt;# Arguments&lt;/code&gt; section (see point 4 below).</source>
          <target state="translated">Это может быть идентично подписи, присутствующей в коде Julia (например, &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt; ), или упрощенной форме. Необязательные аргументы должны быть представлены с их значениями по умолчанию (т.е. &lt;code&gt;f(x, y=1)&lt;/code&gt; ), когда это возможно, в соответствии с фактическим синтаксисом Julia. Необязательные аргументы, которые не имеют значения по умолчанию, должны быть заключены в скобки (т.е. &lt;code&gt;f(x[, y])&lt;/code&gt; и &lt;code&gt;f(x[, y[, z]])&lt;/code&gt; ). Альтернативное решение - использовать несколько строк: одну без необязательных аргументов, другую с ними. Это решение также можно использовать для документирования нескольких связанных методов данной функции. Когда функция принимает множество аргументов ключевого слова, включайте в подпись только заполнитель &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; (например, &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt; ), а полный список приведите в разделе &lt;code&gt;# Arguments&lt;/code&gt; (см. пункт 4 ниже).</target>
        </trans-unit>
        <trans-unit id="48dae0d7f0cfc247d97cdffb950575c2c53131a7" translate="yes" xml:space="preserve">
          <source>This can be remedied by passing the result of &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;. Instead of returning callstack information for the current context, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; returns stack information for the context of the most recent exception:</source>
          <target state="translated">Это можно исправить, передав результат &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; . Вместо того, чтобы возвращать информацию о стеке вызовов для текущего контекста, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt; возвращает информацию о стеке для контекста самого последнего исключения:</target>
        </trans-unit>
        <trans-unit id="31e05199a1305748953864ea5a4fca890bd60950" translate="yes" xml:space="preserve">
          <source>This can be useful for interoperability with programming languages which have different rules for the construction of valid identifiers. For example, to refer to the &lt;code&gt;R&lt;/code&gt; variable &lt;code&gt;draw.segments&lt;/code&gt;, you can use &lt;code&gt;var&quot;draw.segments&quot;&lt;/code&gt; in your Julia code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23915be66d58b3010247cc477edf10741516449" translate="yes" xml:space="preserve">
          <source>This can be written more concisely and efficiently as:</source>
          <target state="translated">Это может быть написано более лаконично и эффективно:</target>
        </trans-unit>
        <trans-unit id="da228c6572574c6e3edc7a497b323e67243e96a5" translate="yes" xml:space="preserve">
          <source>This can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is recommended instead.</source>
          <target state="translated">Это может привести к состояниям гонки, если другой процесс получит то же имя файла и создаст его раньше, чем вы. Вместо этого рекомендуется использовать &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="705c957d58f550245aaa4f046fe3e92349850b38" translate="yes" xml:space="preserve">
          <source>This can lead to security holes if another process obtains the same file name and creates the file before you are able to. Open the file with &lt;code&gt;JL_O_EXCL&lt;/code&gt; if this is a concern. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is also recommended instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464b5fa1d6c0b5441a8fbbb213e02432dc783d43" translate="yes" xml:space="preserve">
          <source>This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.</source>
          <target state="translated">Этот catch-all менее специфичен,чем любое другое возможное определение метода для пары значений параметров,поэтому он будет вызываться только для пар аргументов,к которым не применяется никакое другое определение метода.</target>
        </trans-unit>
        <trans-unit id="687032e0ca0291c6f37d903f4b4a585e263d0c23" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d32190f9f82717ff7b036e591c82b7be9c20e35" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">В этой главе рассматриваются технические детали загрузки пакетов. Для установки пакетов используйте &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; &lt;/a&gt; , встроенный менеджер пакетов Julia, чтобы добавить пакеты в вашу активную среду. Чтобы использовать пакеты, уже находящиеся в вашей активной среде, напишите &lt;code&gt;import X&lt;/code&gt; или &lt;code&gt;using X&lt;/code&gt; , как описано в &lt;a href=&quot;../modules/index#modules-1&quot;&gt;документации&lt;/a&gt; по модулям .</target>
        </trans-unit>
        <trans-unit id="4a06224a21aa063e4c9f046613bebaabd39494a6" translate="yes" xml:space="preserve">
          <source>This check is usually &lt;em&gt;costless&lt;/em&gt;, as the compiler can elide the check for valid concrete types. If the second argument is also computed, it may be advantageous to provide an &lt;a href=&quot;../constructors/index#man-outer-constructor-methods&quot;&gt;outer constructor method&lt;/a&gt; that performs this calculation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f560041e9c1b16deb7ab6bd9aff4671ee86058bc" translate="yes" xml:space="preserve">
          <source>This code is an implementation of the algorithm described in: An Improved Algorithm for &lt;code&gt;hypot(a,b)&lt;/code&gt; by Carlos F. Borges The article is available online at ArXiv at the link https://arxiv.org/abs/1904.09481</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d88d1d0a18f5d7f665080e348536b07fa18d945" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea11403bb989c686f5968328179e98cbaa9f269" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">Этот код не будет инициализировать все &lt;code&gt;a&lt;/code&gt; , поскольку каждый процесс будет иметь его отдельную копию. Следует избегать подобных параллельных циклов for. К счастью, это ограничение можно использовать с помощью &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;общих массивов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d51d7a463700079744f5ff1d3af6ba57fc16feaf" translate="yes" xml:space="preserve">
          <source>This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case &lt;code&gt;(+)&lt;/code&gt;). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</source>
          <target state="translated">Эта конструкция реализует шаблон назначения итераций нескольким процессам и объединения их с указанным сокращением (в данном случае &lt;code&gt;(+)&lt;/code&gt; ). Результат каждой итерации принимается как значение последнего выражения внутри цикла. Все выражение параллельного цикла дает окончательный ответ.</target>
        </trans-unit>
        <trans-unit id="56c993971b23a28c699db5a6937a4a9bfd78df8b" translate="yes" xml:space="preserve">
          <source>This construction avoids the multiplication and addition operations.</source>
          <target state="translated">Такая конструкция позволяет избежать операций умножения и сложения.</target>
        </trans-unit>
        <trans-unit id="aa8d7cac7cb360d58676d491242e77dac0c56e52" translate="yes" xml:space="preserve">
          <source>This constructor will be invoked by the syntax &lt;code&gt;SummedArray(a)&lt;/code&gt;. The syntax &lt;code&gt;new{T,S}&lt;/code&gt; allows specifying parameters for the type to be constructed, i.e. this call will return a &lt;code&gt;SummedArray{T,S}&lt;/code&gt;. &lt;code&gt;new{T,S}&lt;/code&gt; can be used in any constructor definition, but for convenience the parameters to &lt;code&gt;new{}&lt;/code&gt; are automatically derived from the type being constructed when possible.</source>
          <target state="translated">Этот конструктор будет вызываться синтаксисом &lt;code&gt;SummedArray(a)&lt;/code&gt; . Синтаксис &lt;code&gt;new{T,S}&lt;/code&gt; позволяет указывать параметры для конструируемого типа, то есть этот вызов вернет &lt;code&gt;SummedArray{T,S}&lt;/code&gt; . &lt;code&gt;new{T,S}&lt;/code&gt; можно использовать в любом определении конструктора, но для удобства параметры &lt;code&gt;new{}&lt;/code&gt; автоматически выводятся из создаваемого типа, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="b7a16492f267624e6cffa44c16d2f3cbbc8fdcef" translate="yes" xml:space="preserve">
          <source>This convenience function returns an iterator which filters out &lt;code&gt;missing&lt;/code&gt; values efficiently. It can therefore be used with any function which supports iterators</source>
          <target state="translated">Эта вспомогательная функция возвращает итератор, который эффективно фильтрует &lt;code&gt;missing&lt;/code&gt; значения. Поэтому его можно использовать с любой функцией, которая поддерживает итераторы.</target>
        </trans-unit>
        <trans-unit id="7839ec061c3b0d3cae9d3ceb52f6e6b0eb7552ce" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.</source>
          <target state="translated">Это соглашение об упорядочивании массивов распространено во многих языках, таких как Fortran, Matlab и R (и это лишь некоторые из них). Альтернативой упорядочению по столбцам является порядок по строкам, который является соглашением, принятым C и Python ( &lt;code&gt;numpy&lt;/code&gt; ) среди других языков. Запоминание порядка массивов может иметь значительное влияние на производительность при циклическом обходе массивов. Следует иметь в виду, что для массивов со старшими столбцами первый индекс изменяется наиболее быстро. По сути, это означает, что цикл будет быстрее, если индекс самого внутреннего цикла будет первым в выражении среза.</target>
        </trans-unit>
        <trans-unit id="1645b7896bc037bdea36ccff78d78a2be6b15f8e" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression. Keep in mind that indexing an array with &lt;code&gt;:&lt;/code&gt; is an implicit loop that iteratively accesses all elements within a particular dimension; it can be faster to extract columns than rows, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7355c6564b5fcc9846f7acd500769583417df709" translate="yes" xml:space="preserve">
          <source>This creates a 25-by-30000 &lt;code&gt;BitArray&lt;/code&gt;, linked to the file associated with stream &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">Это создает &lt;code&gt;BitArray&lt;/code&gt; размером 25 на 30000 , связанный с файлом, связанным с потоком &lt;code&gt;io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94e825958b08717e7b2f87e178ba335682000732" translate="yes" xml:space="preserve">
          <source>This creates a function taking one argument &lt;code&gt;x&lt;/code&gt; and returning the value of the polynomial &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</source>
          <target state="translated">Это создает функцию, принимающую один аргумент &lt;code&gt;x&lt;/code&gt; и возвращающую значение полинома &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; при этом значении. Обратите внимание, что результатом является универсальная функция, но с именем, созданным компилятором на основе последовательной нумерации.</target>
        </trans-unit>
        <trans-unit id="c16c73de1b45daf105f01df93653955f2810669b" translate="yes" xml:space="preserve">
          <source>This declaration defines a new parametric type, &lt;code&gt;Point{T}&lt;/code&gt;, holding two &quot;coordinates&quot; of type &lt;code&gt;T&lt;/code&gt;. What, one may ask, is &lt;code&gt;T&lt;/code&gt;? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used as a type). &lt;code&gt;Point{Float64}&lt;/code&gt; is a concrete type equivalent to the type defined by replacing &lt;code&gt;T&lt;/code&gt; in the definition of &lt;code&gt;Point&lt;/code&gt; with &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Thus, this single declaration actually declares an unlimited number of types: &lt;code&gt;Point{Float64}&lt;/code&gt;, &lt;code&gt;Point{AbstractString}&lt;/code&gt;, &lt;code&gt;Point{Int64}&lt;/code&gt;, etc. Each of these is now a usable concrete type:</source>
          <target state="translated">Эта декларация определяет новый тип параметрического, &lt;code&gt;Point{T}&lt;/code&gt; , проведение двух &amp;laquo;координаты&amp;raquo; типа &lt;code&gt;T&lt;/code&gt; . Можно спросить, что такое &lt;code&gt;T&lt;/code&gt; ? Что ж, в этом и суть параметрических типов: это может быть вообще любой тип (или значение любого битового типа, собственно, хотя здесь оно явно используется как тип). &lt;code&gt;Point{Float64}&lt;/code&gt; - это конкретный тип, эквивалентный типу, определенному заменой &lt;code&gt;T&lt;/code&gt; в определении &lt;code&gt;Point&lt;/code&gt; на &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . Таким образом, это единственное объявление фактически объявляет неограниченное количество типов: &lt;code&gt;Point{Float64}&lt;/code&gt; , &lt;code&gt;Point{AbstractString}&lt;/code&gt; , &lt;code&gt;Point{Int64}&lt;/code&gt; и т. Д. Теперь каждый из них является пригодным для использования конкретным типом:</target>
        </trans-unit>
        <trans-unit id="b01b6974b06d7624ee6c363ea6ebb8266c1f09ca" translate="yes" xml:space="preserve">
          <source>This declaration has the same effect as the earlier definition of the &lt;code&gt;Foo&lt;/code&gt; type without an explicit inner constructor method. The following two types are equivalent &amp;ndash; one with a default constructor, the other with an explicit constructor:</source>
          <target state="translated">Это объявление имеет тот же эффект, что и более раннее определение типа &lt;code&gt;Foo&lt;/code&gt; , без явного метода внутреннего конструктора. Следующие два типа эквивалентны - один с конструктором по умолчанию, другой с явным конструктором:</target>
        </trans-unit>
        <trans-unit id="e6768dfeff6ea03f38de8deb6433998fc2233bac" translate="yes" xml:space="preserve">
          <source>This demonstrates some important aspects of scope: in a scope, each variable can only have one meaning, and that meaning is determined regardless of the order of expressions. The presence of the expression &lt;code&gt;s = t&lt;/code&gt; in the loop causes &lt;code&gt;s&lt;/code&gt; to be local to the loop, which means that it is also local when it appears on the right hand side of &lt;code&gt;t = s + i&lt;/code&gt;, even though that expression appears first and is evaluated first. One might imagine that the &lt;code&gt;s&lt;/code&gt; on the first line of the loop could be global while the &lt;code&gt;s&lt;/code&gt; on the second line of the loop is local, but that's not possible since the two lines are in the same scope block and each variable can only mean one thing in a given scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cae1102db29e2ef980a4d7e4e7854fb0a34c8cd" translate="yes" xml:space="preserve">
          <source>This dependency graph represented as a dictionary, looks like this:</source>
          <target state="translated">Этот график зависимостей,представленный в виде словаря,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b9aaf0a6f68d326c3813770015ef1479f59b61ec" translate="yes" xml:space="preserve">
          <source>This distinction determines which scalar indexing methods the type must define. &lt;code&gt;IndexLinear()&lt;/code&gt; arrays are simple: just define &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt;. When the array is subsequently indexed with a multidimensional set of indices, the fallback &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; efficiently converts the indices into one linear index and then calls the above method. &lt;code&gt;IndexCartesian()&lt;/code&gt; arrays, on the other hand, require methods to be defined for each supported dimensionality with &lt;code&gt;ndims(A)&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices. For example, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;SparseArrays&lt;/code&gt; standard library module, only supports two dimensions, so it just defines &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt;. The same holds for &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это различие определяет, какие скалярные методы индексирования должен определять тип. &lt;code&gt;IndexLinear()&lt;/code&gt; просты: просто определите &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt; . Когда массив впоследствии индексируется с помощью многомерного набора индексов, резервный &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; эффективно преобразует индексы в один линейный индекс, а затем вызывает вышеуказанный метод. &lt;code&gt;IndexCartesian()&lt;/code&gt; другой стороны, массивы IndexCartesian () требуют определения методов для каждой поддерживаемой размерности с помощью &lt;code&gt;ndims(A)&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; . Например, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt; из стандартного библиотечного модуля &lt;code&gt;SparseArrays&lt;/code&gt; поддерживает только два измерения, поэтому он просто определяет &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt; . То же самое и с &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="341c5e7333e9b447849339d0853fcd7d14d2830b" translate="yes" xml:space="preserve">
          <source>This does not apply to &lt;code&gt;function&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</source>
          <target state="translated">Это не относится к объявлениям &lt;code&gt;function&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; . Однако анонимные функции, привязанные к глобальным переменным, сериализуются, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="86f9320eb728977a1d66ab43b8b74b16022a0160" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with JIT profiling support, using either</source>
          <target state="translated">Эта переменная окружения имеет эффект только в том случае,если Джулия была скомпилирована с поддержкой JIT-профилирования,используя любой из следующих вариантов</target>
        </trans-unit>
        <trans-unit id="b8ecde1ad84c7fa04736dc884f170c7012ed70ab" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">Эта переменная среды действует только в том случае, если Julia была скомпилирована с отладкой со сборкой мусора (то есть, если &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; установлено в &lt;code&gt;1&lt;/code&gt; в конфигурации сборки).</target>
        </trans-unit>
        <trans-unit id="9da7aae5652d5d79a524e4cda3f0dfe80c0acd90" translate="yes" xml:space="preserve">
          <source>This error indicates that the conditional was of the wrong type: &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; rather than the required &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта ошибка указывает на то, что условное выражение было неправильного типа: &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; ,&lt;/a&gt; а не требуемого &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="041d6d9502e571d35122b54e3f7555ea1dca4d3a" translate="yes" xml:space="preserve">
          <source>This escaping mechanism can be used to &quot;violate&quot; hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets &lt;code&gt;x&lt;/code&gt; to zero in the call environment:</source>
          <target state="translated">Этот механизм экранирования может быть использован для &amp;laquo;нарушения&amp;raquo; гигиены, когда это необходимо, для введения или управления пользовательскими переменными. Например, следующий макрос устанавливает &lt;code&gt;x&lt;/code&gt; равным нулю в среде вызова:</target>
        </trans-unit>
        <trans-unit id="9c5c328c41b593f3c08a09090fb0468199894a7b" translate="yes" xml:space="preserve">
          <source>This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a &lt;em&gt;reduction&lt;/em&gt;, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern &lt;code&gt;x = f(x,v[i])&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the accumulator, &lt;code&gt;f&lt;/code&gt; is the reduction function, and the &lt;code&gt;v[i]&lt;/code&gt; are the elements being reduced. It is desirable for &lt;code&gt;f&lt;/code&gt; to be associative, so that it does not matter what order the operations are performed in.</source>
          <target state="translated">Этот пример демонстрирует мощный и часто используемый шаблон параллельного программирования. Многие итерации выполняются независимо над несколькими процессами, а затем их результаты объединяются с помощью некоторой функции. Процесс комбинирования называется &lt;em&gt;сокращением&lt;/em&gt; , так как он, как правило, уменьшает тензорный ранг: вектор чисел сокращается до одного числа, или матрица сокращается до одной строки или столбца и т. Д. В коде это обычно выглядит как шаблон &lt;code&gt;x = f(x,v[i])&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; - аккумулятор, &lt;code&gt;f&lt;/code&gt; - функция сокращения, а &lt;code&gt;v[i]&lt;/code&gt; - уменьшаемые элементы. Желательно, чтобы &lt;code&gt;f&lt;/code&gt; была ассоциативной, чтобы не имело значения, в каком порядке выполняются операции.</target>
        </trans-unit>
        <trans-unit id="6dfb71272e9303585708d721385dced1cec06a7d" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes, then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">В этом примере сначала выделяется массив байтов, затем вызывается функция библиотеки C &lt;code&gt;gethostname&lt;/code&gt; для заполнения массива именем хоста, принимает указатель на буфер имени хоста и преобразует указатель в строку Julia, предполагая, что это NUL-завершение. Строка C. Библиотеки C часто используют этот шаблон, требующий от вызывающего выделить память, которая будет передана вызываемому и заполнена. Выделение памяти от Джулии, как это, обычно выполняется путем создания неинициализированного массива и передачи указателя на его данные в функция C. Вот почему мы не используем &lt;code&gt;Cstring&lt;/code&gt; тип Cstring : поскольку массив неинициализирован, он может содержать NUL байтов. Преобразование в &lt;code&gt;Cstring&lt;/code&gt; как часть &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; проверяет наличие байтов NUL и, следовательно, может вызвать ошибку преобразования.</target>
        </trans-unit>
        <trans-unit id="81f56d42721e023666b42ce5d20872f19e3f3c1b" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes. It then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and populated. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1ac1e55fd925a7d22f5a60b11f3b3c1b4549bc" translate="yes" xml:space="preserve">
          <source>This example generates many subnormal numbers because the values in &lt;code&gt;a&lt;/code&gt; become an exponentially decreasing curve, which slowly flattens out over time.</source>
          <target state="translated">В этом примере генерируется много субнормальных чисел, потому что значения в &lt;code&gt;a&lt;/code&gt; становятся экспоненциально убывающей кривой, которая со временем постепенно выравнивается.</target>
        </trans-unit>
        <trans-unit id="9daa7910681479c02c2c50ed435d4f90bf88e739" translate="yes" xml:space="preserve">
          <source>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</source>
          <target state="translated">Этот пример подчеркивает общий принцип,что соседние представляемые числа с плавающей точкой также имеют соседние двоичные целочисленные представления.</target>
        </trans-unit>
        <trans-unit id="908e2e897728777e829b7f08db5b9e855ae0cc96" translate="yes" xml:space="preserve">
          <source>This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.</source>
          <target state="translated">Этот пример похож на предыдущий,за исключением того,что есть две ступени потребителей,а ступени имеют разную латентность,поэтому для поддержания насыщенной пропускной способности они используют разное количество параллельных рабочих.</target>
        </trans-unit>
        <trans-unit id="547c626a1378ed0fe9150c862ad51213777da963" translate="yes" xml:space="preserve">
          <source>This example map includes three different kinds of package locations (the first and third are part of the default load path):</source>
          <target state="translated">Эта карта примера включает в себя три различных типа расположения пакетов (первое и третье-часть пути загрузки по умолчанию):</target>
        </trans-unit>
        <trans-unit id="1a00200535ab1c13ccef86e68b0800e8609303b1" translate="yes" xml:space="preserve">
          <source>This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change in the future.</source>
          <target state="translated">Этот экспериментальный интерфейс поддерживает возможности многопоточности Джулии.Типы и функции,описанные здесь,могут (и,скорее всего,будут)меняться в будущем.</target>
        </trans-unit>
        <trans-unit id="57cf6614fe11299d25cdfc84dad18699d2670d90" translate="yes" xml:space="preserve">
          <source>This expression constructs a name using &lt;code&gt;string&lt;/code&gt;, then substitutes this name into a new &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; expression, which is then evaluated. Keep in mind that &lt;code&gt;eval&lt;/code&gt; only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with &lt;code&gt;$&lt;/code&gt;). For this reason, &lt;code&gt;eval&lt;/code&gt; is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это выражение создает имя, используя &lt;code&gt;string&lt;/code&gt; , затем заменяет это имя новым выражением &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , которое затем вычисляется. Имейте в виду, что &lt;code&gt;eval&lt;/code&gt; работает только на верхнем уровне, поэтому в этом выражении локальные переменные не будут доступны (если их значения не заменены на &lt;code&gt;$&lt;/code&gt; ). По этой причине &lt;code&gt;eval&lt;/code&gt; обычно используется только для формирования определений верхнего уровня, например, при упаковке библиотек, содержащих множество похожих функций. Аналогичный пример можно построить для &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db9c10f7c39ed65401660ce94eeb87fdf0a1c09b" translate="yes" xml:space="preserve">
          <source>This expression invokes the &lt;code&gt;echo&lt;/code&gt; command with three words as arguments: &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;. The result is that a single line is printed: &lt;code&gt;hello | sort&lt;/code&gt;. How, then, does one construct a pipeline? Instead of using &lt;code&gt;'|'&lt;/code&gt; inside of backticks, one uses &lt;code&gt;pipeline&lt;/code&gt;:</source>
          <target state="translated">Это выражение вызывает команду &lt;code&gt;echo&lt;/code&gt; с тремя словами в качестве аргументов: &lt;code&gt;hello&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , и &lt;code&gt;sort&lt;/code&gt; . В результате печатается одна строка: &lt;code&gt;hello | sort&lt;/code&gt; . Как же тогда построить трубопровод? Вместо использования &lt;code&gt;'|'&lt;/code&gt; внутри обратных кавычек используется &lt;code&gt;pipeline&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d8eb7a249785528e4f915a12603e4055a737c99e" translate="yes" xml:space="preserve">
          <source>This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the &lt;code&gt;@simd&lt;/code&gt; macro may cause unexpected results.</source>
          <target state="translated">Эта функция является экспериментальной и может измениться или исчезнуть в будущих версиях Julia. Неправильное использование макроса &lt;code&gt;@simd&lt;/code&gt; может привести к неожиданным результатам.</target>
        </trans-unit>
        <trans-unit id="d5a37ab2e3447a402ef6dae9693a9619588c5031" translate="yes" xml:space="preserve">
          <source>This feature is useful for avoiding performance &quot;gotchas&quot; that could occur if one of the assignments to a variable changed its type unexpectedly.</source>
          <target state="translated">Эта функция полезна,чтобы избежать &quot;дотаций&quot; производительности,которые могут возникнуть,если одно из присваиваний к переменной неожиданно изменит свой тип.</target>
        </trans-unit>
        <trans-unit id="783c0c8452e06904718657237123803cbb8eb1c2" translate="yes" xml:space="preserve">
          <source>This form is often found on method signatures.</source>
          <target state="translated">Эта форма часто встречается на подписях методов.</target>
        </trans-unit>
        <trans-unit id="cc3b7f9edb1c8e585d8a1d71b69faf0b48006d70" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;.</source>
          <target state="translated">Этот формат не следует путать с более старым &lt;em&gt;WY&lt;/em&gt; представления &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5430a5df9a2060598aa23b84f7a5871adf25fad" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;sup&gt;&lt;a href=&quot;#footnote-Bischof1987&quot; id=&quot;citeref-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12c069ce178f9d50647ca11f433a6b7234b2e36" translate="yes" xml:space="preserve">
          <source>This function accepts two arguments &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and returns the value of the last expression evaluated, which is &lt;code&gt;x + y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590cd9bbe677a0c8ce068af3ae23d18c7dfa14a9" translate="yes" xml:space="preserve">
          <source>This function can be used to implement transactional semantics. Before the transaction, one records the value in &lt;code&gt;x&lt;/code&gt;. After the transaction, the new value is stored only if &lt;code&gt;x&lt;/code&gt; has not been modified in the mean time.</source>
          <target state="translated">Эта функция может использоваться для реализации семантики транзакций. Перед транзакцией записывается значение в &lt;code&gt;x&lt;/code&gt; . После транзакции новое значение сохраняется только в том случае, если &lt;code&gt;x&lt;/code&gt; за это время не был изменен.</target>
        </trans-unit>
        <trans-unit id="65b3ba291cce49f270b3e77d3c5998270ae43f60" translate="yes" xml:space="preserve">
          <source>This function computes a floating point representation of the modulus after division by numerically exact &lt;code&gt;2&amp;pi;&lt;/code&gt;, and is therefore not exactly the same as &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt;, which would compute the modulus of &lt;code&gt;x&lt;/code&gt; relative to division by the floating-point number &lt;code&gt;2&amp;pi;&lt;/code&gt;.</source>
          <target state="translated">Эта функция вычисляет представление модуля с плавающей запятой после деления на численно точное &lt;code&gt;2&amp;pi;&lt;/code&gt; и, следовательно, не совсем то же самое, что и &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt; , который вычисляет модуль &lt;code&gt;x&lt;/code&gt; относительно деления на число с плавающей запятой &lt;code&gt;2&amp;pi;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a69b876a715ff91aee9ac1dc1a1270f07d74d257" translate="yes" xml:space="preserve">
          <source>This function definition applies only to calls where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both values of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Это определение функции применяется только к вызовам, где &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются значениями типа &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="de80929c3e71c9bc153a3794af9f7a9ac61e7bc0" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;Base&lt;/code&gt; with Julia 1.1, consider using &lt;code&gt;copy!(dst, src)&lt;/code&gt; instead. &lt;code&gt;Future.copy!&lt;/code&gt; will be deprecated in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307f9d2672dc49a684aa7fe31c18fec869c44c7b" translate="yes" xml:space="preserve">
          <source>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to &lt;code&gt;array&lt;/code&gt; exists as long as this pointer will be used. The &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt;&lt;code&gt;GC.@preserve&lt;/code&gt;&lt;/a&gt; macro should be used to protect the &lt;code&gt;array&lt;/code&gt; argument from garbage collection within a given block of code.</source>
          <target state="translated">Эта функция &amp;laquo;небезопасна&amp;raquo;. Будьте осторожны и убедитесь, что ссылка Julia на &lt;code&gt;array&lt;/code&gt; существует до тех пор, пока будет использоваться этот указатель. &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt; &lt;code&gt;GC.@preserve&lt;/code&gt; &lt;/a&gt; макрос должен использоваться для защиты &lt;code&gt;array&lt;/code&gt; аргумента от сбора мусора в пределах данного блока кода.</target>
        </trans-unit>
        <trans-unit id="1048e33a2e1de2e001c3991baed944e77c02b5fe" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;lazy&lt;/em&gt;; that is, it is guaranteed to return in $&amp;Theta;(1)$ time and use $&amp;Theta;(1)$ additional space, and &lt;code&gt;flt&lt;/code&gt; will not be called by an invocation of &lt;code&gt;filter&lt;/code&gt;. Calls to &lt;code&gt;flt&lt;/code&gt; will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.</source>
          <target state="translated">Эта функция &lt;em&gt;ленивая&lt;/em&gt; ; то есть гарантируется возврат через $ &amp;Theta; (1) $ time и использование дополнительного пространства $ &amp;Theta; (1) $, и &lt;code&gt;flt&lt;/code&gt; не будет вызываться при вызове &lt;code&gt;filter&lt;/code&gt; . Вызовы к &lt;code&gt;flt&lt;/code&gt; будут выполняться при итерации по возвращаемому повторяемому объекту. Эти вызовы не кэшируются, и при повторении будут выполняться повторные вызовы.</target>
        </trans-unit>
        <trans-unit id="df83e0cd3a021e2eda678d29363b61d1d821ffd0" translate="yes" xml:space="preserve">
          <source>This function is a backwards-compatibility wrapper around &lt;a href=&quot;#Sockets.getipaddrs&quot;&gt;&lt;code&gt;getipaddrs&lt;/code&gt;&lt;/a&gt;. New applications should use &lt;a href=&quot;#Sockets.getipaddrs&quot;&gt;&lt;code&gt;getipaddrs&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c598eb72103944814ddd5bff7557e538bb8759" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.2.</source>
          <target state="translated">Эта функция доступна начиная с Джулии 1.2.</target>
        </trans-unit>
        <trans-unit id="da85261a4de72bb648f4ec6ce0ef1d4e3e0d885c" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c744a1e60d0343bb54950e43c44ab4cd5d6e31b7" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de757df5fb576721e27ff36bb95b8961e32a7fdd" translate="yes" xml:space="preserve">
          <source>This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).</source>
          <target state="translated">Эта функция является экспериментальной в Julia 1.1 и,вероятно,будет переименована в будущем релизе (см.https://github.com/JuliaLang/julia/pull/29901).</target>
        </trans-unit>
        <trans-unit id="8f852b6c88a2b121cce224d6c4d1adc0aba50b5c" translate="yes" xml:space="preserve">
          <source>This function is exported as of Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e1bbd78f8e3b5f7d1147a85e5728b547b5d88f" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;p&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">Эта функция помечена как &amp;laquo;небезопасная&amp;raquo;, потому что она выйдет из строя, если &lt;code&gt;p&lt;/code&gt; не является допустимым адресом памяти для данных запрошенной длины.</target>
        </trans-unit>
        <trans-unit id="82038c376053156505a04a6c869bf7122237faf2" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;pointer&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">Эта функция помечена как &amp;laquo;небезопасная&amp;raquo;, потому что она выйдет из строя, если &lt;code&gt;pointer&lt;/code&gt; не является допустимым адресом памяти для данных запрошенной длины.</target>
        </trans-unit>
        <trans-unit id="5b892b839448ad3b615e4b9ec54defee6e074b87" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c3d9d8620860cee722b6a9f452e249efef56c2" translate="yes" xml:space="preserve">
          <source>This function is part of the implementation of &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;, if a module is not already defined in &lt;code&gt;Main&lt;/code&gt;. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</source>
          <target state="translated">Эта функция является частью реализации &lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; , если модуль еще не определен в &lt;code&gt;Main&lt;/code&gt; . Его также можно вызвать напрямую, чтобы принудительно перезагрузить модуль, независимо от того, загружался ли он раньше (например, при интерактивной разработке библиотек).</target>
        </trans-unit>
        <trans-unit id="f62aceafe3cafbddb8ce3acbb1dad94e7fdf1815" translate="yes" xml:space="preserve">
          <source>This function may not be called on immutable objects, since they do not have stable memory addresses.</source>
          <target state="translated">Эта функция может не вызываться на непреложных объектах,так как они не имеют стабильных адресов памяти.</target>
        </trans-unit>
        <trans-unit id="5de59bd4497cdb331716cc233726a0a8b9678b01" translate="yes" xml:space="preserve">
          <source>This function only affects the current thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d8139504e5c695799999f525f1e4ce111d803d" translate="yes" xml:space="preserve">
          <source>This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.</source>
          <target state="translated">Эта функция вызывает ошибку в операционных системах,которые не поддерживают символические ссылки,такие как Windows XP.</target>
        </trans-unit>
        <trans-unit id="e2895f8ba02c0856affa3262c2ea2aa12ea82abd" translate="yes" xml:space="preserve">
          <source>This function requires Julia 1.4 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4fed1257bdc9c86a6438d7c81f0cba15e713a" translate="yes" xml:space="preserve">
          <source>This function requires Julia 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322c609b6865dc8c717685db96eea7836880f968" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1.</source>
          <target state="translated">Эта функция требует,по крайней мере,Джулии 1.1.</target>
        </trans-unit>
        <trans-unit id="a78f5bdc6ba25c6757efa254c7a5dcb1069f02e2" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library &lt;code&gt;InteractiveUtils&lt;/code&gt;.</source>
          <target state="translated">Для этой функции требуется как минимум версия Julia 1.1. В Julia 1.0 он доступен из стандартной библиотеки &lt;code&gt;InteractiveUtils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a8778ddbd4ece155922c919b7d3de7c16b4b6b0" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.2.</source>
          <target state="translated">Эта функция требует,по крайней мере,Джулии 1.2.</target>
        </trans-unit>
        <trans-unit id="1aebd8ffdb83e4dbea00c26626665df625006081" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a51a88fd91e95896285adef28ef9c196b5c4360" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7503036b2b1d5c6cdd3e30a18b4569d18e9b3d" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f615a9f2e5154689d2348ca6e6e212e19365dd5e" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">Эта функция всегда будет возвращать &lt;code&gt;Int8&lt;/code&gt; независимо от типов &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . См. &amp;laquo; &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;Объявления типов&amp;raquo;&lt;/a&gt; для получения дополнительной информации о возвращаемых типах.</target>
        </trans-unit>
        <trans-unit id="1b364264e31d49453fa585f561786364c3d08cfe" translate="yes" xml:space="preserve">
          <source>This functionality exists to allow Julia to bootstrap the standard primitive types that LLVM supports. Once they are defined, there is very little reason to define more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208d7b42f568795accbdf6593a0dabeec159feae" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.1.</source>
          <target state="translated">Эта функциональность требует,по крайней мере,Джулии 1.1.</target>
        </trans-unit>
        <trans-unit id="d55acd278bb097e8fd9b34b3f2891bb67508ba49" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.2.</source>
          <target state="translated">Эта функциональность требует,по крайней мере,Джулии 1.2.</target>
        </trans-unit>
        <trans-unit id="d794b3922c789d2d5bf428145d7b58218609a4d8" translate="yes" xml:space="preserve">
          <source>This gives an output similar to</source>
          <target state="translated">Это дает результат,похожий на</target>
        </trans-unit>
        <trans-unit id="4351de18141317da8dc4e7b0765ffdf10ccf9585" translate="yes" xml:space="preserve">
          <source>This guide provides a comprehensive overview of how to attach documentation to all Julia syntax constructs for which providing documentation is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d340087c42aeb6323d557dfd0b48fcc9885f45" translate="yes" xml:space="preserve">
          <source>This guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API Reference&lt;/a&gt; section of the Pkg documentation.</source>
          <target state="translated">В этом руководстве для выполнения команд Pkg используется Pkg REPL. Для неинтерактивного использования мы рекомендуем Pkg API. API Pkg полностью задокументирован в разделе &amp;laquo; &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;Справочник&lt;/a&gt; по API&amp;raquo; документации Pkg.</target>
        </trans-unit>
        <trans-unit id="bcc764f3d130244febc5241a24425d0f8955d7ca" translate="yes" xml:space="preserve">
          <source>This guide should help you get started with &lt;code&gt;Pkg&lt;/code&gt;. &lt;code&gt;Pkg&lt;/code&gt; has much more to offer in terms of powerful package management, read the full manual to learn more!</source>
          <target state="translated">Это руководство должно помочь вам начать работу с &lt;code&gt;Pkg&lt;/code&gt; . &lt;code&gt;Pkg&lt;/code&gt; может предложить гораздо больше с точки зрения мощного управления пакетами, прочтите полное руководство, чтобы узнать больше!</target>
        </trans-unit>
        <trans-unit id="2e07b6f624fccfda8f96076a48a7ed08e8beca2e" translate="yes" xml:space="preserve">
          <source>This has the exact same effect as the previous definition of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Это имеет тот же эффект, что и предыдущее определение &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a3774592faf08d584a328465b32aaef91dad38" translate="yes" xml:space="preserve">
          <source>This illustrates the default &quot;tree&quot; dump; an alternative is the &quot;flat&quot; dump, which accumulates counts independent of their nesting:</source>
          <target state="translated">Это иллюстрирует дамп &quot;дерева&quot; по умолчанию;альтернативным вариантом является &quot;плоский&quot; дамп,который накапливает числа независимо от их вложенности:</target>
        </trans-unit>
        <trans-unit id="acc80a0f41503dcb1b7e460050ce274ae0e83048" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from &lt;code&gt;Foo&lt;/code&gt;, but only inside the module &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">Это импортирует все символы из &lt;code&gt;Foo&lt;/code&gt; , но только внутри модуля &lt;code&gt;Bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c62d5f28832b263b7519c969320ae1bece54d1" translate="yes" xml:space="preserve">
          <source>This interface is experimental and subject to change or removal without notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e598599b0d95357e3968722563ce2a0da7930f2" translate="yes" xml:space="preserve">
          <source>This interface is experimental and subject to change or removal without notice. To insulate yourself against changes, consider putting any registrations inside an &lt;code&gt;if isdefined(Base.Experimental, :register_error_hint) ... end&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c905f3e19a8500c9e8e89a5d6b2d48b63e3fd8" translate="yes" xml:space="preserve">
          <source>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: &lt;code&gt;LocalManager&lt;/code&gt;, for launching additional workers on the same host, and &lt;code&gt;SSHManager&lt;/code&gt;, for launching on remote hosts via &lt;code&gt;ssh&lt;/code&gt;. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</source>
          <target state="translated">Этот интерфейс предоставляет механизм для запуска рабочих Julia и управления ими в различных кластерных средах. В Base присутствует два типа менеджеров: &lt;code&gt;LocalManager&lt;/code&gt; для запуска дополнительных воркеров на одном хосте и &lt;code&gt;SSHManager&lt;/code&gt; для запуска на удаленных хостах через &lt;code&gt;ssh&lt;/code&gt; . Сокеты TCP / IP используются для соединения и передачи сообщений между процессами. Менеджеры кластера могут предоставить другой транспорт.</target>
        </trans-unit>
        <trans-unit id="962b26b87665c4f3df59ad9f2395deca95b45d10" translate="yes" xml:space="preserve">
          <source>This is a &lt;em&gt;convention&lt;/em&gt; in the sense that &lt;code&gt;nothing&lt;/code&gt; is not a Julia keyword but a only singleton object of type &lt;code&gt;Nothing&lt;/code&gt;. Also, you may notice that the &lt;code&gt;printx&lt;/code&gt; function example above is contrived, because &lt;code&gt;println&lt;/code&gt; already returns &lt;code&gt;nothing&lt;/code&gt;, so that the &lt;code&gt;return&lt;/code&gt; line is redundant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deff481ef7abfd9c149d6a30d8b9bfb2fec2b9fb" translate="yes" xml:space="preserve">
          <source>This is a Julia wrapper around a pointer to a &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Это оболочка Julia вокруг указателя на объект &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c422825d888738af38d09b58685510aefce5bd8f" translate="yes" xml:space="preserve">
          <source>This is a better choice than</source>
          <target state="translated">Это лучший выбор,чем</target>
        </trans-unit>
        <trans-unit id="85e469ae13d4f052567eb5f96057c4c8c1633d8d" translate="yes" xml:space="preserve">
          <source>This is a classic example of a single producer feeding two concurrent consumers: one &lt;code&gt;perl&lt;/code&gt; process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter &quot;A&quot;, the other with the letter &quot;B&quot;. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting &lt;code&gt;$|=1&lt;/code&gt; in Perl causes each print statement to flush the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)</source>
          <target state="translated">Это классический пример того, как один производитель кормит двух одновременных потребителей: один процесс &lt;code&gt;perl&lt;/code&gt; генерирует строки с номерами от 0 до 5, в то время как два параллельных процесса потребляют этот вывод, один из которых добавляет к строке букву &amp;laquo;A&amp;raquo;, а другой - буква &amp;laquo;Б&amp;raquo;. То, какой потребитель получит первую строку, не является детерминированным, но после того, как эта гонка выиграна, строки используются поочередно одним процессом, а затем другим. (Установка &lt;code&gt;$|=1&lt;/code&gt; в Perl заставляет каждый оператор печати &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; дескриптор stdout , который необходим для работы этого примера. В противном случае весь вывод буферизуется и печатается в конвейер одновременно, чтобы быть прочитанным только одним процессом-потребителем. )</target>
        </trans-unit>
        <trans-unit id="cf79f7f6027262a30f115ab7b0f785a426cd7073" translate="yes" xml:space="preserve">
          <source>This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:</source>
          <target state="translated">Это обычная закономерность,наблюдаемая при преобразовании из большого класса типов в один конкретный тип аргумента,который на самом деле поддерживается алгоритмом:</target>
        </trans-unit>
        <trans-unit id="ab1f9c741287d248928e11803550091dd722085d" translate="yes" xml:space="preserve">
          <source>This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the &lt;code&gt;println&lt;/code&gt; call inside the &lt;code&gt;if&lt;/code&gt; block. In realistic usage there is more code to be evaluated after the &lt;code&gt;continue&lt;/code&gt;, and often there are multiple points from which one calls &lt;code&gt;continue&lt;/code&gt;.</source>
          <target state="translated">Это несколько надуманный пример, поскольку мы могли бы добиться того же поведения более четко, отрицая условие и помещая вызов &lt;code&gt;println&lt;/code&gt; внутри блока &lt;code&gt;if&lt;/code&gt; . В реалистичном использовании после &lt;code&gt;continue&lt;/code&gt; нужно оценить больше кода , и часто есть несколько точек, с которых один вызов &lt;code&gt;continue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c9ba627d76c7cc49aeb4d6fdbc49ae25f7076ce" translate="yes" xml:space="preserve">
          <source>This is a verbose version of the &lt;code&gt;@time&lt;/code&gt; macro. It first prints the same information as &lt;code&gt;@time&lt;/code&gt;, then any non-zero memory allocation counters, and then returns the value of the expression.</source>
          <target state="translated">Это &lt;code&gt;@time&lt;/code&gt; макроса @time . Сначала он печатает ту же информацию, что и &lt;code&gt;@time&lt;/code&gt; , затем любые ненулевые счетчики выделения памяти, а затем возвращает значение выражения.</target>
        </trans-unit>
        <trans-unit id="3dde492bc6a0d4212d6f3ce351cddd4c3cc1560e" translate="yes" xml:space="preserve">
          <source>This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</source>
          <target state="translated">Это очень распространенная закономерность в Базе Джулии:небольшой набор требуемых методов определяет неформальный интерфейс,который позволяет многим фантазиям вести себя более причудливо.В некоторых случаях,типы захотят дополнительно специализироваться на этих дополнительных видах поведения,когда они знают,что более эффективный алгоритм может быть использован в их конкретном случае.</target>
        </trans-unit>
        <trans-unit id="967704622307a1b435262f66f63c35ab2df37cdd" translate="yes" xml:space="preserve">
          <source>This is accomplished by the following definition:</source>
          <target state="translated">Это достигается следующим определением:</target>
        </trans-unit>
        <trans-unit id="a064a0d086a44fbda83912ae13c4a94a63595798" translate="yes" xml:space="preserve">
          <source>This is accomplished via the following code in &lt;code&gt;base/boot.jl&lt;/code&gt;:</source>
          <target state="translated">Это достигается с помощью следующего кода в &lt;code&gt;base/boot.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3583c3fe581e3e08550a563e55b3f4e249fd47f" translate="yes" xml:space="preserve">
          <source>This is also true for remotecalls on the local node as seen in the following example:</source>
          <target state="translated">Это также верно для удаленных вызовов на локальном узле,как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="57f9c64c4e06a92a8accdfe0153dcfbc237317b8" translate="yes" xml:space="preserve">
          <source>This is best seen in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa42412894f46475c32ad0f5cf96db8417157008" translate="yes" xml:space="preserve">
          <source>This is better style because &lt;code&gt;foo&lt;/code&gt; does not really accept numbers of all types; it really needs &lt;code&gt;Int&lt;/code&gt; s.</source>
          <target state="translated">Это лучший стиль, потому что &lt;code&gt;foo&lt;/code&gt; на самом деле не принимает числа всех типов; ему действительно нужны &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c63a317e555926f5cec6415634c44654066c6532" translate="yes" xml:space="preserve">
          <source>This is effectively a lazy version of &lt;a href=&quot;../arrays/index#Base.accumulate&quot;&gt;&lt;code&gt;Base.accumulate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac355916b9abde70111dfabfe3ce99e5f07ae086" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt;. Writing &lt;code&gt;Vector{Float64}&lt;/code&gt; is equivalent to writing &lt;code&gt;Array{Float64,1}&lt;/code&gt;, and the umbrella type &lt;code&gt;Vector&lt;/code&gt; has as instances all &lt;code&gt;Array&lt;/code&gt; objects where the second parameter &amp;ndash; the number of array dimensions &amp;ndash; is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just &lt;code&gt;Vector&lt;/code&gt; for the abstract type including all one-dimensional dense arrays of any element type.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt; . Запись &lt;code&gt;Vector{Float64}&lt;/code&gt; эквивалентна записи &lt;code&gt;Array{Float64,1}&lt;/code&gt; , а зонтичный тип &lt;code&gt;Vector&lt;/code&gt; имеет в качестве экземпляров все объекты &lt;code&gt;Array&lt;/code&gt; , где второй параметр - количество измерений массива - равен 1, независимо от типа элемента. В языках, где параметрические типы всегда должны указываться полностью, это не особенно полезно, но в Julia это позволяет писать только &lt;code&gt;Vector&lt;/code&gt; для абстрактного типа, включая все одномерные плотные массивы любого типа элемента.</target>
        </trans-unit>
        <trans-unit id="aaca4a13507268ab605b72c529b012ba239f5cf8" translate="yes" xml:space="preserve">
          <source>This is equivalent to the uglier test &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt;. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (&lt;code&gt;k=v&lt;/code&gt;).</source>
          <target state="translated">Это эквивалентно более уродливому тесту &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt; . Ошибкой является предоставление более одного выражения, если первое не является выражением вызова, а остальные - присваиваниями ( &lt;code&gt;k=v&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="075cde66f62e612ace972fa5c52ba3c9977edd64" translate="yes" xml:space="preserve">
          <source>This is fine if a named function effecting the transform already exists to pass as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</source>
          <target state="translated">Это нормально, если именованная функция, выполняющая преобразование, уже существует для передачи в качестве первого аргумента в &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; . Однако часто готовая к использованию именованная функция не существует. В этих ситуациях конструкция анонимной функции позволяет легко создать объект одноразовой функции без необходимости имени:</target>
        </trans-unit>
        <trans-unit id="d2c04622602343797c4542bea9af2f8f42f131f2" translate="yes" xml:space="preserve">
          <source>This is happening because, while the &lt;code&gt;write&lt;/code&gt; call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</source>
          <target state="translated">Это происходит потому, что, хотя вызов &lt;code&gt;write&lt;/code&gt; является синхронным, запись каждого аргумента уступает место другим задачам, ожидая завершения этой части ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="c8a50eb2bf3cc3094e347236252e67c0ff90ae38" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax</source>
          <target state="translated">Это предназначено для вызова с использованием синтаксиса блока &lt;code&gt;do&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cdfa85f9233b8624988cb8413bc1b9a6dc03d9c" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax:</source>
          <target state="translated">Он предназначен для вызова с использованием синтаксиса блока &lt;code&gt;do&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dd320fe267c845b089f3801cdc399b59ed6ba172" translate="yes" xml:space="preserve">
          <source>This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.</source>
          <target state="translated">Скорее всего,это очень дорогая операция.Учитывая,что все другие атомные операции в Юлии уже имеют семантику приобретения/освобождения,явные заборы не должны быть необходимы в большинстве случаев.</target>
        </trans-unit>
        <trans-unit id="4c368eefb6926a50691e6a9f9ec7714b2c918956" translate="yes" xml:space="preserve">
          <source>This is more readable and convenient and equivalent to the above string concatenation &amp;ndash; the system rewrites this apparent single string literal into the call &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt;.</source>
          <target state="translated">Это более читабельно и удобно и эквивалентно приведенной выше конкатенации строк - система переписывает этот кажущийся одностроковый литерал в &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt; вызова (приветствие, &quot;,&quot;, who, &quot;. \ N&quot;) .</target>
        </trans-unit>
        <trans-unit id="f04a7b3a9c6223bad051fa21f901be067148fe9d" translate="yes" xml:space="preserve">
          <source>This is not needed on worker threads (&lt;code&gt;Threads.threadid() != 1&lt;/code&gt;) since the &lt;code&gt;InterruptException&lt;/code&gt; will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</source>
          <target state="translated">Это не требуется для рабочих потоков ( &lt;code&gt;Threads.threadid() != 1&lt;/code&gt; ), поскольку исключение &lt;code&gt;InterruptException&lt;/code&gt; будет доставлено только в главный поток. Внешние функции, которые не вызывают код julia или среду выполнения julia, автоматически отключают sigint во время своего выполнения.</target>
        </trans-unit>
        <trans-unit id="71e546fccd494df52bebb481be657d852aebe11b" translate="yes" xml:space="preserve">
          <source>This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.</source>
          <target state="translated">Часто это правильная стратегия,однако бывают обстоятельства,когда слепое следование советам может оказаться контрпродуктивным.В частности,чем больше методов имеет общая функция,тем больше возможностей для двусмысленности.Когда иерархия методов усложняется по сравнению с этим простым примером,вам может стоить хорошенько подумать об альтернативных стратегиях.</target>
        </trans-unit>
        <trans-unit id="e2fa8331115c72567b8859c8f4636de4982ac69c" translate="yes" xml:space="preserve">
          <source>This is only needed if your module depends on a file that is not used via &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;. It has no effect outside of compilation.</source>
          <target state="translated">Это необходимо только в том случае, если ваш модуль зависит от файла, который не используется через &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; . Он не действует вне компиляции.</target>
        </trans-unit>
        <trans-unit id="2784b134096220702383ae6c9d7a1302554b1771" translate="yes" xml:space="preserve">
          <source>This is the default comparison used by &lt;a href=&quot;../sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это сравнение по умолчанию, используемое при &lt;a href=&quot;../sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c85ba23a6506d2939aa5b839a013bcd606af833c" translate="yes" xml:space="preserve">
          <source>This is the list of reserved keywords in Julia: &lt;code&gt;baremodule&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;global&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;. Those keywords are not allowed to be used as variable names.</source>
          <target state="translated">Это список зарезервированных ключевых слов в Julia: &lt;code&gt;baremodule&lt;/code&gt; , &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; , &lt;code&gt;do&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;elseif&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;export&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;finally&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;function&lt;/code&gt; , &lt;code&gt;global&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;import&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;local&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;quote&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;try&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; . Эти ключевые слова нельзя использовать в качестве имен переменных.</target>
        </trans-unit>
        <trans-unit id="96c2e84d8dd228822a97cd0751dcb6c1eebd84d2" translate="yes" xml:space="preserve">
          <source>This is the mechanism that is also used in the standard library, e.g. by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c8784ecdd309ab380e1280eddd527fe7e9db81" translate="yes" xml:space="preserve">
          <source>This is useful for preventing the propagation of &lt;code&gt;NaN&lt;/code&gt; values in quantities that are known to be zero. See &lt;a href=&quot;https://arxiv.org/abs/math/9205211&quot;&gt;Knuth (1992)&lt;/a&gt; for motivation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90facb0407832d3445cbf12e098939b6ab30525" translate="yes" xml:space="preserve">
          <source>This is useful with the do-block syntax for more complex temporal expressions:</source>
          <target state="translated">Это полезно при использовании синтаксиса do-block для более сложных временных выражений:</target>
        </trans-unit>
        <trans-unit id="1f135ed365e0881687323b4b2b1b547c6be25fa8" translate="yes" xml:space="preserve">
          <source>This is wasteful when dimensions get large, so Julia provides &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</source>
          <target state="translated">Это бесполезно, когда размеры становятся большими, поэтому Джулия предоставляет &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; , которая расширяет одноэлементные измерения в аргументах массива, чтобы соответствовать соответствующему измерению в другом массиве без использования дополнительной памяти, и применяет данную функцию поэлементно:</target>
        </trans-unit>
        <trans-unit id="7bd078ba5ec9612bff8795fa65ea85e0e4a4b835" translate="yes" xml:space="preserve">
          <source>This iterator is &quot;lazy&quot; in that it does not make a copy of the collection in order to reverse it; see &lt;code&gt;Base.reverse&lt;/code&gt; for an eager implementation.</source>
          <target state="translated">Этот итератор &amp;laquo;ленив&amp;raquo; в том смысле, что он не создает копию коллекции, чтобы отменить ее; см. &lt;code&gt;Base.reverse&lt;/code&gt; для активной реализации.</target>
        </trans-unit>
        <trans-unit id="668dce0079a5c7ecaeda787c6c43c4abed16e82f" translate="yes" xml:space="preserve">
          <source>This keeps things simple, while allowing the compiler to generate optimized code in all cases.</source>
          <target state="translated">Это упрощает ситуацию,позволяя компилятору генерировать оптимизированный код во всех случаях.</target>
        </trans-unit>
        <trans-unit id="618a3a65c5497ca323b88a316514b70e984e986d" translate="yes" xml:space="preserve">
          <source>This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">Такой тип потока управления может значительно облегчить решение определенных проблем.В некоторых задачах различные части требуемой работы естественным образом не связаны вызовами функций;среди задач,которые необходимо выполнить,нет явного &quot;вызывающего&quot; или &quot;вызываемого&quot;.Примером может служить проблема &quot;производитель-потребитель&quot;,когда одна сложная процедура генерирует ценности,а другая-потребляет их.Потребитель не может просто вызвать функцию производителя,чтобы получить ценность,поскольку у производителя может быть больше ценностей,которые нужно генерировать,и поэтому он может быть еще не готов к возвращению.С помощью задач производитель и потребитель могут работать столько,сколько им необходимо,передавая ценности туда и обратно по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="0a88599aaef0898fffd99491510ed87461ecc31f" translate="yes" xml:space="preserve">
          <source>This kind of definition of function behavior by dispatch is quite common &amp;ndash; idiomatic, even &amp;ndash; in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here's an example where the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the type parameter to the parametric type &lt;code&gt;Vector{T}&lt;/code&gt; in the method signature:</source>
          <target state="translated">Такое определение поведения функции по отправке довольно часто - идиоматично - в Julia. Параметры типа метода не ограничиваются использованием в качестве типов аргументов: их можно использовать везде, где значение будет в сигнатуре функции или теле функции. Вот пример, в котором параметр типа метода &lt;code&gt;T&lt;/code&gt; используется в качестве параметра типа для параметрического типа &lt;code&gt;Vector{T}&lt;/code&gt; в сигнатуре метода:</target>
        </trans-unit>
        <trans-unit id="ec4239bc4b5dc918f448b6994ffeb011eb260c23" translate="yes" xml:space="preserve">
          <source>This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.</source>
          <target state="translated">Подобные манипуляции с переменными следует использовать разумно,но иногда они довольно удобны.</target>
        </trans-unit>
        <trans-unit id="5cf1880888ac71427a2a472f83ebc4e3ee3aeac7" translate="yes" xml:space="preserve">
          <source>This last point is &lt;em&gt;very&lt;/em&gt; important: even though &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; we &lt;strong&gt;DO NOT&lt;/strong&gt; have &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt;.</source>
          <target state="translated">Этот последний пункт является &lt;em&gt;очень&lt;/em&gt; важным: несмотря на то, &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; мы &lt;strong&gt;НЕ&lt;/strong&gt; имеем &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7542405e58ae981f14134e43a96aca7f30233f49" translate="yes" xml:space="preserve">
          <source>This leverages a fallback implementation of &lt;code&gt;copyto!&lt;/code&gt; that converts the wrapper into a &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt;. Consequently, specializing on &lt;code&gt;DestType&lt;/code&gt; has lower precedence than methods that specialize on &lt;code&gt;DestStyle&lt;/code&gt;.</source>
          <target state="translated">При этом используется &lt;code&gt;copyto!&lt;/code&gt; реализация copyto! который преобразует оболочку в &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt; . Следовательно, специализация на &lt;code&gt;DestType&lt;/code&gt; имеет более низкий приоритет, чем методы, специализирующиеся на &lt;code&gt;DestStyle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563a17c90111523e5b2f5d6e8d16952ec180646f" translate="yes" xml:space="preserve">
          <source>This loads the module &lt;code&gt;Foo&lt;/code&gt; and defines a variable &lt;code&gt;Foo&lt;/code&gt; that refers to the module, but does not import any of the other symbols from the module into the current namespace. You refer to the &lt;code&gt;Foo&lt;/code&gt; symbols by their qualified names &lt;code&gt;Foo.bar&lt;/code&gt; etc.</source>
          <target state="translated">Это загружает модуль &lt;code&gt;Foo&lt;/code&gt; и определяет переменную &lt;code&gt;Foo&lt;/code&gt; , которая ссылается на модуль, но не импортирует какие-либо другие символы из модуля в текущее пространство имен. Вы ссылаетесь на символы &lt;code&gt;Foo&lt;/code&gt; по их &lt;code&gt;Foo.bar&lt;/code&gt; именам Foo.bar и т. Д.</target>
        </trans-unit>
        <trans-unit id="4612a42efe8a5bdd3c4138ff12dd117c4e94f8e6" translate="yes" xml:space="preserve">
          <source>This macro can be used like this:</source>
          <target state="translated">Этот макрос можно использовать вот так:</target>
        </trans-unit>
        <trans-unit id="d3a5424713c4662a407bbf558841062e07735c84" translate="yes" xml:space="preserve">
          <source>This macro gives a more convenient syntax for declaring &lt;code&gt;NamedTuple&lt;/code&gt; types. It returns a &lt;code&gt;NamedTuple&lt;/code&gt; type with the given keys and types, equivalent to &lt;code&gt;NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}&lt;/code&gt;. If the &lt;code&gt;::Type&lt;/code&gt; declaration is omitted, it is taken to be &lt;code&gt;Any&lt;/code&gt;. The &lt;code&gt;begin ... end&lt;/code&gt; form allows the declarations to be split across multiple lines (similar to a &lt;code&gt;struct&lt;/code&gt; declaration), but is otherwise equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d42881c0e50cef46bcd4335722e2d4da406ce4c" translate="yes" xml:space="preserve">
          <source>This macro is available as of Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801b86f68b3c0cefd135f8c96330176952188ece" translate="yes" xml:space="preserve">
          <source>This macro is available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796fb2fc91375e842873f0f25490416b48076f98" translate="yes" xml:space="preserve">
          <source>This macro takes one argument: &lt;code&gt;name&lt;/code&gt;. When &lt;code&gt;@sayhello&lt;/code&gt; is encountered, the quoted expression is &lt;em&gt;expanded&lt;/em&gt; to interpolate the value of the argument into the final expression:</source>
          <target state="translated">Этот макрос принимает один аргумент: &lt;code&gt;name&lt;/code&gt; . Когда встречается &lt;code&gt;@sayhello&lt;/code&gt; , цитируемое выражение &lt;em&gt;расширяется&lt;/em&gt; для интерполяции значения аргумента в окончательное выражение:</target>
        </trans-unit>
        <trans-unit id="fb5cd3420a15fab4676b11324ac55221c551d00f" translate="yes" xml:space="preserve">
          <source>This makes it clearer where docstrings start and end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99355d54955b26bda6881d3a32f0394ad662278e" translate="yes" xml:space="preserve">
          <source>This makes it easy to use an arbitrary object (here a &lt;code&gt;raw&lt;/code&gt; string) as a docstring.</source>
          <target state="translated">Это упрощает использование произвольного объекта (здесь &lt;code&gt;raw&lt;/code&gt; строка) в качестве строки документации.</target>
        </trans-unit>
        <trans-unit id="e352f04f9f33e3e34fa37d2a0e22a677123c5a98" translate="yes" xml:space="preserve">
          <source>This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow &lt;em&gt;is&lt;/em&gt; associative. Consider finding the midpoint between integer values &lt;code&gt;lo&lt;/code&gt; and &lt;code&gt;hi&lt;/code&gt; in Julia using the expression &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt;:</source>
          <target state="translated">Это затрудняет написание многих базовых целочисленных алгоритмов, поскольку многие распространенные методы зависят от того факта, что машинное сложение с переполнением &lt;em&gt;является&lt;/em&gt; ассоциативным. Рассмотрим поиск середины между целыми значениями &lt;code&gt;lo&lt;/code&gt; и &lt;code&gt;hi&lt;/code&gt; в Julia, используя выражение &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bddf7a0f25a0e5f4299199009d8763508187037e" translate="yes" xml:space="preserve">
          <source>This makes it more clear where docstrings start and end.</source>
          <target state="translated">Это делает более понятным,где начинаются и заканчиваются стыковочные узлы.</target>
        </trans-unit>
        <trans-unit id="f1fb07e562617380cc2e285350641983b6f7d13d" translate="yes" xml:space="preserve">
          <source>This makes it possible to use expressions other than normal string literals (such as the &lt;code&gt;raw&quot;&quot;&lt;/code&gt; string macro) as a docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1390ee7b9f8d0f8dd34a701e5fbadb4b8b3c9256" translate="yes" xml:space="preserve">
          <source>This makes stack trace information available programmatically for logging, error handling, and more.</source>
          <target state="translated">Это делает информацию о трассировке стека доступной программно для протоколирования,обработки ошибок и многого другого.</target>
        </trans-unit>
        <trans-unit id="118a450839bcd493b9a3323bf1931949bac102ac" translate="yes" xml:space="preserve">
          <source>This manifest file describes a possible complete dependency graph for the &lt;code&gt;App&lt;/code&gt; project:</source>
          <target state="translated">Этот файл манифеста описывает возможный полный граф зависимостей для проекта &lt;code&gt;App&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa9bdb6f39c12cde4099183225c25db089937837" translate="yes" xml:space="preserve">
          <source>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</source>
          <target state="translated">Это может показаться странным ограничением,но помните,что поскольку C не является динамическим языком,как Julia,его функции могут принимать только типы аргументов со статически известной,фиксированной сигнатурой.</target>
        </trans-unit>
        <trans-unit id="ccbe0f854d08689742c5122439446d8ae7400b8b" translate="yes" xml:space="preserve">
          <source>This means that calling &lt;code&gt;f()&lt;/code&gt; is equivalent to calling &lt;code&gt;f(1,2)&lt;/code&gt;. In this case the result is &lt;code&gt;5&lt;/code&gt;, because &lt;code&gt;f(1,2)&lt;/code&gt; invokes the first method of &lt;code&gt;f&lt;/code&gt; above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</source>
          <target state="translated">Это означает, что вызов &lt;code&gt;f()&lt;/code&gt; эквивалентен вызову &lt;code&gt;f(1,2)&lt;/code&gt; . В этом случае результат равен &lt;code&gt;5&lt;/code&gt; , потому что &lt;code&gt;f(1,2)&lt;/code&gt; вызывает первый метод &lt;code&gt;f&lt;/code&gt; выше. Однако это не всегда так. Если вы определите четвертый метод, более специализированный для целых чисел:</target>
        </trans-unit>
        <trans-unit id="d91824530ea1dcad07d2ce3b7c87745b23855a91" translate="yes" xml:space="preserve">
          <source>This means that new &lt;code&gt;Number&lt;/code&gt; types only need to define constructors, since this definition will handle &lt;code&gt;convert&lt;/code&gt; for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</source>
          <target state="translated">Это означает, что новые &lt;code&gt;Number&lt;/code&gt; типы должны определять только конструкторы, поскольку это определение будет обрабатывать &lt;code&gt;convert&lt;/code&gt; для них. Также предоставляется преобразование идентичности для обработки случая, когда аргумент уже имеет запрошенный тип:</target>
        </trans-unit>
        <trans-unit id="d95d868bc45acbbf3d653adf2e5564fd580718ec" translate="yes" xml:space="preserve">
          <source>This means that rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with an even value in that field, while rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.</source>
          <target state="translated">Это означает, что округление &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; до четного числа секунд, минут, часов или лет (поскольку спецификация ISO 8601 включает нулевой год) приведет к &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; с четным значением в этом поле, а &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; будет округлен до четного кратное месяцам приведет к тому, что поле месяцев будет иметь нечетное значение. Поскольку и месяцы, и годы могут содержать нерегулярное количество дней, неясно, приведет ли округление к четному количеству дней к четному значению в поле дней.</target>
        </trans-unit>
        <trans-unit id="e022c0c027f7431615a2e6bfce810bd80d7f71b8" translate="yes" xml:space="preserve">
          <source>This means that the &lt;code&gt;pointer&lt;/code&gt; for &lt;code&gt;V&lt;/code&gt; is actually pointing into the middle of &lt;code&gt;A&lt;/code&gt;'s memory block, and it refers to elements both backwards and forwards in memory. See the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays&quot;&gt;interface guide for strided arrays&lt;/a&gt; for more details on defining your own strided arrays. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1724fb3df29f491e1db30646921be60d52e085" translate="yes" xml:space="preserve">
          <source>This means we must also define a corresponding &lt;code&gt;similar&lt;/code&gt; method:</source>
          <target state="translated">Это означает, что мы также должны определить соответствующий &lt;code&gt;similar&lt;/code&gt; метод:</target>
        </trans-unit>
        <trans-unit id="8164014a03b0ed9d2a2a01cfd412eb70f3f6cf4e" translate="yes" xml:space="preserve">
          <source>This mechanism can be implemented easily by custom exception types following the way &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt;&lt;code&gt;UndefVarError&lt;/code&gt;&lt;/a&gt; is written:</source>
          <target state="translated">Этот механизм можно легко реализовать с помощью настраиваемых типов исключений, следуя способу записи &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt; &lt;code&gt;UndefVarError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="00b20545036f8cfdf164022ed01300b951b2a39d" translate="yes" xml:space="preserve">
          <source>This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.</source>
          <target state="translated">Этот механизм также является ключом к тому,как конструкторы типов и замыкания (внутренние функции,которые относятся к окружающей их среде)работают в Юлии.</target>
        </trans-unit>
        <trans-unit id="87a9a57282476dafb9bfcdbc06caa5e75c2590eb" translate="yes" xml:space="preserve">
          <source>This mechanism is of course used by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization:</source>
          <target state="translated">Этот механизм, конечно, используется стандартной реализацией генерации случайных массивов (например, в &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ). Чтобы реализовать это разделение для пользовательского типа, можно использовать вспомогательный тип. Возвращаясь к нашему примеру &lt;code&gt;Die&lt;/code&gt; : &lt;code&gt;rand(::Die)&lt;/code&gt; использует случайную генерацию из диапазона, поэтому есть возможность для этой оптимизации:</target>
        </trans-unit>
        <trans-unit id="f75a278538a1522abc6fa98d70bcb27983fcccb3" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">Этот метод создает объект &lt;code&gt;DateFormat&lt;/code&gt; при каждом его вызове. Если вы анализируете много строк даты одного и того же формата, подумайте о создании объекта &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; один раз и вместо этого используйте его в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="9d972e8cda3b91e650e6ff3541ce6f8b54cbae93" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date time strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">Этот метод создает объект &lt;code&gt;DateFormat&lt;/code&gt; при каждом его вызове. Если вы анализируете много строк даты и времени одного и того же формата, рассмотрите возможность создания объекта &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; один раз и использования его в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="cb2233a83e18eafded9574a3a241275b67521981" translate="yes" xml:space="preserve">
          <source>This method definition applies to any pair of arguments that are instances of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression &lt;code&gt;2x - y&lt;/code&gt;.</source>
          <target state="translated">Это определение метода применяется к любой паре аргументов, которые являются экземплярами &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; . Они не обязательно должны быть одного типа, если каждое из них является числовым значением. Проблема обработки несопоставимых числовых типов делегируется арифметическим операциям в выражении &lt;code&gt;2x - y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25be108587097965bc1d457d2798dc697b2b0387" translate="yes" xml:space="preserve">
          <source>This method is available as of Julia 1.1.</source>
          <target state="translated">Этот метод доступен начиная с Юлии 1.1.</target>
        </trans-unit>
        <trans-unit id="7154e71f550aec85c7b6230d9f61b37f4a29ed8a" translate="yes" xml:space="preserve">
          <source>This method requires Julia 1.2 or later.</source>
          <target state="translated">Для этого метода требуется Юлия 1.2 или более поздняя.</target>
        </trans-unit>
        <trans-unit id="899440f2ea2fee6c702b6f89d814399868b760bc" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.1.</source>
          <target state="translated">Этот метод требует,по крайней мере,Джулии 1.1.</target>
        </trans-unit>
        <trans-unit id="870b2fd7cad296236db6b2acee5daac8bcbed1f1" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.2.</source>
          <target state="translated">Этот метод требует,по крайней мере,Джулии 1.2.</target>
        </trans-unit>
        <trans-unit id="a7dd277ce3d58fa80c3ba1f6a270f1433aab79aa" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287181424f41545827889fe6d1cd971c13deceb7" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df192a99d234108a172dc69e2511778133fdb5c8" translate="yes" xml:space="preserve">
          <source>This method uses the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function to explicitly convert &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; and then delegates construction to the general constructor for the case where both arguments are &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition what was previously a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; now successfully creates a point of type &lt;code&gt;Point{Float64}&lt;/code&gt;:</source>
          <target state="translated">Этот метод использует функцию &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; для явного преобразования &lt;code&gt;x&lt;/code&gt; в &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; ,&lt;/a&gt; а затем делегирует построение общему конструктору в случае, когда оба аргумента являются &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . С этим определением метода то, что раньше было &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; ,&lt;/a&gt; теперь успешно создает точку типа &lt;code&gt;Point{Float64}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6303e3b58af767dd0d1fbddaa5592d4577466dc" translate="yes" xml:space="preserve">
          <source>This might be worthwhile when either of the following are true:</source>
          <target state="translated">Это может стоить того,если одно из нижеследующего верно:</target>
        </trans-unit>
        <trans-unit id="caca6d3dad29a6885489c96c973507436880d558" translate="yes" xml:space="preserve">
          <source>This module defines a type &lt;code&gt;MyType&lt;/code&gt;, and two functions. Function &lt;code&gt;foo&lt;/code&gt; and type &lt;code&gt;MyType&lt;/code&gt; are exported, and so will be available for importing into other modules. Function &lt;code&gt;bar&lt;/code&gt; is private to &lt;code&gt;MyModule&lt;/code&gt;.</source>
          <target state="translated">Этот модуль определяет тип &lt;code&gt;MyType&lt;/code&gt; и две функции. Функция &lt;code&gt;foo&lt;/code&gt; и тип &lt;code&gt;MyType&lt;/code&gt; экспортируются, поэтому их можно будет импортировать в другие модули. &lt;code&gt;bar&lt;/code&gt; функций является частной для &lt;code&gt;MyModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e361081ac903885d30799d0af09374c26253366e" translate="yes" xml:space="preserve">
          <source>This new compact representation will be used when the passed IO stream is an &lt;code&gt;IOContext&lt;/code&gt; object with the &lt;code&gt;:compact&lt;/code&gt; property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</source>
          <target state="translated">Это новое компактное представление будет использоваться, когда переданный поток ввода-вывода является объектом &lt;code&gt;IOContext&lt;/code&gt; с набором свойств &lt;code&gt;:compact&lt;/code&gt; . В частности, это имеет место при печати массивов с несколькими столбцами (где горизонтальное пространство ограничено):</target>
        </trans-unit>
        <trans-unit id="c9d9b11cb845e47e607c614fa51676b8589b0e20" translate="yes" xml:space="preserve">
          <source>This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt;&lt;code&gt;numerator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt;&lt;code&gt;denominator&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">Эта нормализованная форма отношения целых чисел уникальна, поэтому равенство рациональных значений можно проверить, проверив равенство числителя и знаменателя. Стандартизированный числитель и знаменатель рационального значения могут быть извлечены с помощью функций &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt; &lt;code&gt;numerator&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt; &lt;code&gt;denominator&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6ae131da59b641e6a04de571be058c6c357d2762" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">Этот объект НЕ является потокобезопасным. См. &lt;a href=&quot;#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt; для версии с потокобезопасностью.</target>
        </trans-unit>
        <trans-unit id="dd76756319b3c7370a847bd7b93c70cdd9b67ec0" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;../multi-threading/index#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4a7f18d5f3325b0b4b506c0553650e84bb55e2" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;, which is non-recursive.</source>
          <target state="translated">Эта операция предназначена для использования линейной алгебры - для общих операций с данными см. &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt; , которая не является рекурсивной.</target>
        </trans-unit>
        <trans-unit id="68fb902f0905ca9a9a84e0916a21520831fc7805" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта операция предназначена для использования линейной алгебры - для общих операций с данными см. &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5890e27550178f3b3f621b391f08592d04b935ac" translate="yes" xml:space="preserve">
          <source>This operator follows IEEE semantics for floating-point numbers: &lt;code&gt;0.0 == -0.0&lt;/code&gt; and &lt;code&gt;NaN != NaN&lt;/code&gt;.</source>
          <target state="translated">Этот оператор следует семантике IEEE для чисел с плавающей запятой: &lt;code&gt;0.0 == -0.0&lt;/code&gt; и &lt;code&gt;NaN != NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f45001a85e32a4368ea2b2117472a674fb4b812d" translate="yes" xml:space="preserve">
          <source>This output tells us that &lt;code&gt;f&lt;/code&gt; is a function object with two methods. To find out what the signatures of those methods are, use the &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Этот вывод сообщает нам, что &lt;code&gt;f&lt;/code&gt; - это функциональный объект с двумя методами. Чтобы узнать, каковы сигнатуры этих методов, используйте функцию &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="27399a34acfc119b2b6802fe2da7d02ba2868aed" translate="yes" xml:space="preserve">
          <source>This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on performance compared to normal dispatch.</source>
          <target state="translated">Этот образец реализуется путем определения общей функции,которая вычисляет различное однокнопочное значение (или тип)для каждого набора признаков,к которому могут принадлежать аргументы функции.Если эта функция является чистой,то это не влияет на производительность по сравнению с обычной диспетчеризацией.</target>
        </trans-unit>
        <trans-unit id="c8dd670a38453a8c5ac96a2263bb252ef6b9b2f1" translate="yes" xml:space="preserve">
          <source>This pattern is so frequent that a helper type named &lt;code&gt;Random.SamplerSimple&lt;/code&gt; is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="translated">Этот шаблон настолько распространен, что доступен вспомогательный тип с именем &lt;code&gt;Random.SamplerSimple&lt;/code&gt; , что сохраняет нам определение &lt;code&gt;SamplerDie&lt;/code&gt; : мы могли бы реализовать нашу развязку с помощью:</target>
        </trans-unit>
        <trans-unit id="788eade9955684aef54020e83665092b3b21d4bd" translate="yes" xml:space="preserve">
          <source>This pattern is used in several places in Julia Base. For example, see &lt;code&gt;vcat&lt;/code&gt; and &lt;code&gt;hcat&lt;/code&gt; in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt;&lt;code&gt;abstractarray.jl&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!&lt;/code&gt;&lt;/a&gt; function, which we could have used instead of writing our own &lt;code&gt;fill_twos!&lt;/code&gt;.</source>
          <target state="translated">Этот шаблон используется в нескольких местах в Julia Base. Например, см. &lt;code&gt;vcat&lt;/code&gt; и &lt;code&gt;hcat&lt;/code&gt; в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt; &lt;code&gt;abstractarray.jl&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!&lt;/code&gt; &lt;/a&gt;функцию, которую мы могли бы использовать вместо написания собственного &lt;code&gt;fill_twos!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a07692e105ddc917557be8ec34d26c6d0d0ad87f" translate="yes" xml:space="preserve">
          <source>This pipes the output of the &lt;code&gt;echo&lt;/code&gt; command to the &lt;code&gt;sort&lt;/code&gt; command. Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:</source>
          <target state="translated">Это передает вывод команды &lt;code&gt;echo&lt;/code&gt; команде &lt;code&gt;sort&lt;/code&gt; . Конечно, это не очень интересно, поскольку нужно отсортировать только одну строку, но мы, безусловно, можем делать гораздо больше интересных вещей:</target>
        </trans-unit>
        <trans-unit id="28745bdf70806fa587f3e325d2378a4dbc6461d5" translate="yes" xml:space="preserve">
          <source>This prints the highest five user IDs on a UNIX system. The &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; commands are all spawned as immediate children of the current &lt;code&gt;julia&lt;/code&gt; process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.</source>
          <target state="translated">Это напечатает пять старших идентификаторов пользователей в системе UNIX. &lt;code&gt;cut&lt;/code&gt; , &lt;code&gt;sort&lt;/code&gt; и &lt;code&gt;tail&lt;/code&gt; команды все порождала как непосредственные ребенок текущего &lt;code&gt;julia&lt;/code&gt; процесса, без промежуточного процесса оболочки. Джулия сама выполняет работу по настройке каналов и подключению файловых дескрипторов, что обычно выполняется оболочкой. Поскольку Julia делает это сама, он сохраняет лучший контроль и может делать некоторые вещи, которые не могут выполнять оболочки.</target>
        </trans-unit>
        <trans-unit id="23fa7f062adc867f3f830f4783d112980678deb3" translate="yes" xml:space="preserve">
          <source>This project file implies the following roots map, if it was represented by a Julia dictionary:</source>
          <target state="translated">Этот файл проекта подразумевает следующую карту корней,если она была представлена в словаре Julia:</target>
        </trans-unit>
        <trans-unit id="abc51e24a31d52999d77393c1e2d796880b68886" translate="yes" xml:space="preserve">
          <source>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</source>
          <target state="translated">В литературе это количество также известно как число условий Бауэра,относительное число условий или компонентное относительное число условий.</target>
        </trans-unit>
        <trans-unit id="2e42070fb796891f9806f28a3d77516fa4beb07e" translate="yes" xml:space="preserve">
          <source>This regex has the first three flags enabled.</source>
          <target state="translated">В этом регексе включены первые три флага.</target>
        </trans-unit>
        <trans-unit id="ee3fcabcdbbc8234e7f06a55081b08ead3e3a1c5" translate="yes" xml:space="preserve">
          <source>This relationship is also invariant:</source>
          <target state="translated">Эти отношения также инвариантны:</target>
        </trans-unit>
        <trans-unit id="59fcc1007eeaedfc2adf51cf837dd399f227cb88" translate="yes" xml:space="preserve">
          <source>This returns a &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt;, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for &lt;code&gt;Bidiagonal&lt;/code&gt; types.</source>
          <target state="translated">Это возвращает &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt; , который теперь можно передать другим функциям линейной алгебры (например, собственным вычислителям), которые будут использовать специализированные методы для &lt;code&gt;Bidiagonal&lt;/code&gt; типов.</target>
        </trans-unit>
        <trans-unit id="51739dfebbc5e267c6346f6dae65d7a77c8eb77b" translate="yes" xml:space="preserve">
          <source>This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:</source>
          <target state="translated">В этом разделе описывается синтаксис Julia markdown,который включен стандартной библиотекой Markdown.Поддерживаются следующие элементы Markdown:</target>
        </trans-unit>
        <trans-unit id="dfa63ea10e93a9723f06f6e4891ca5c36280959e" translate="yes" xml:space="preserve">
          <source>This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:</source>
          <target state="translated">Это кажется очевидным,потому что два из этих периодов все еще равномерно делятся на следующий более крупный период порядка.Но в случае двух месяцев (которые все равно равномерно делятся на один год)ответ может быть удивительным:</target>
        </trans-unit>
        <trans-unit id="a3589971fa43934068938b8a676f4699efd4cc5b" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f8183fe3e114c60192daf58de9ecad787e8334" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">Это устанавливает &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;флаги LLVM Fast-Math&lt;/a&gt; и соответствует параметру &lt;code&gt;-ffast-math&lt;/code&gt; в clang. См. &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;Примечания к аннотациям производительности&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="a320d47b1e4321c23069852a2c2baadde10da388" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;https://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1e8b5b57b03661a32579fb9fe3d14174f160bb" translate="yes" xml:space="preserve">
          <source>This setting will cause &lt;code&gt;eachindex&lt;/code&gt; iteration over a &lt;code&gt;MyArray&lt;/code&gt; to use integers. If you don't specify this trait, the default value &lt;code&gt;IndexCartesian()&lt;/code&gt; is used.</source>
          <target state="translated">Этот параметр заставит &lt;code&gt;eachindex&lt;/code&gt; итерацию индекса &lt;code&gt;MyArray&lt;/code&gt; использовать целые числа. Если вы не укажете этот признак, будет использовано значение по умолчанию &lt;code&gt;IndexCartesian()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd212ee97174c1074845d2f071ed810c2eb44e14" translate="yes" xml:space="preserve">
          <source>This should be written as:</source>
          <target state="translated">Это должно быть написано как:</target>
        </trans-unit>
        <trans-unit id="61e8d88c0f9a32cfa6a86779f848c68e25d1219f" translate="yes" xml:space="preserve">
          <source>This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.</source>
          <target state="translated">Такая ситуация может возникнуть только для недействительных строк UTF-8.Для допустимых UTF-8 строк конкатенация сохраняет все символы в строках и аддитивность длин строк.</target>
        </trans-unit>
        <trans-unit id="602515b8cfd836d63ad817e8e5eb0cdf75d4d344" translate="yes" xml:space="preserve">
          <source>This small handful of promotion rules, together with the type's constructors and the default &lt;code&gt;convert&lt;/code&gt; method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types &amp;ndash; integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.</source>
          <target state="translated">Эта небольшая горстка правил продвижения вместе с конструкторами типа и методом &lt;code&gt;convert&lt;/code&gt; по умолчанию для чисел достаточна для того, чтобы рациональные числа совершенно естественно взаимодействовали со всеми другими числовыми типами Джулии - целыми числами, числами с плавающей запятой и комплексными числами. Предоставляя подходящие методы преобразования и правила продвижения таким же образом, любой определяемый пользователем числовой тип может столь же естественно взаимодействовать с предопределенными числовыми значениями Джулии.</target>
        </trans-unit>
        <trans-unit id="62b4befadfb2df7bd237a94a52e5e887dfce736d" translate="yes" xml:space="preserve">
          <source>This sort of in-language code generation, however, using the &lt;code&gt;eval(quote(...))&lt;/code&gt; pattern, is common enough that Julia comes with a macro to abbreviate this pattern:</source>
          <target state="translated">Однако подобная генерация кода на языке с использованием шаблона &lt;code&gt;eval(quote(...))&lt;/code&gt; достаточно распространена, поэтому Джулия предлагает макрос для сокращения этого шаблона:</target>
        </trans-unit>
        <trans-unit id="29761b0f52dd794108c079b8401444ddd6c7292e" translate="yes" xml:space="preserve">
          <source>This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block. &quot;Captured&quot; variables such as &lt;code&gt;r&lt;/code&gt; that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated &quot;box&quot; accessible to both inner and outer functions because the language specifies that &lt;code&gt;r&lt;/code&gt; in the inner scope must be identical to &lt;code&gt;r&lt;/code&gt; in the outer scope even after the outer scope (or another inner function) modifies &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Этот стиль кода создает проблемы с производительностью для языка. Синтаксический анализатор, переводя его в инструкции более низкого уровня, существенно реорганизует приведенный выше код, выделяя внутреннюю функцию в отдельный блок кода. &amp;laquo;Захваченные&amp;raquo; переменные, такие как &lt;code&gt;r&lt;/code&gt; , которые совместно используются внутренними функциями и их охватывающая область видимости, также извлекаются в выделенную кучей &amp;laquo;коробку&amp;raquo;, доступную как для внутренних, так и для внешних функций, поскольку язык определяет, что &lt;code&gt;r&lt;/code&gt; во внутренней области действия должна быть идентична &lt;code&gt;r&lt;/code&gt; во внешней области видимости даже после того, как внешняя область (или другая внутренняя функция) изменяет &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84f5c4c03a8a8eafdd24b33dcdffe8977865737f" translate="yes" xml:space="preserve">
          <source>This style point is especially relevant to function arguments. For example, don't declare an argument to be of type &lt;code&gt;Int&lt;/code&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; if it really could be any integer, expressed with the abstract type &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;duck typing&lt;/a&gt;.)</source>
          <target state="translated">Эта точка стиля особенно важна для аргументов функции. Например, не объявляйте аргумент как тип &lt;code&gt;Int&lt;/code&gt; или &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; ,&lt;/a&gt; если он действительно может быть любым целым числом, выраженным с помощью абстрактного типа &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; . Фактически, во многих случаях вы можете полностью опустить тип аргумента, если это не требуется для устранения неоднозначности из других определений методов, поскольку в &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; случае будет выброшена ошибка MethodError , если передан тип, который не поддерживает какие-либо требуемые операции. (Это называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;утиным набором текста&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="02f73861f45f55f4dfd018f62afadda932fbecbd" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to &lt;code&gt;if a; b else c end&lt;/code&gt;, but is often used to emphasize the value &lt;code&gt;b&lt;/code&gt;-or-&lt;code&gt;c&lt;/code&gt; which is being used as part of a larger expression, rather than the side effects that evaluating &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; may have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b85e4944b2e592e05f80877bae9cf75b7c4b64c" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb1d086124f576400d48da57453f979b82b1320" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">Этот синтаксис сочетается со встроенным синтаксисом для &lt;a href=&quot;#Footnote-references-1&quot;&gt;ссылок сноски&lt;/a&gt; . Обязательно прочтите и этот раздел.</target>
        </trans-unit>
        <trans-unit id="c6d5e6bac01082ca8f7d5c92e2fcad7892b0deee" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;(;)&lt;/code&gt; chains be single-line:</source>
          <target state="translated">Этот синтаксис особенно полезен с краткой однострочной формой определения функции, представленной в разделе &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Функции&lt;/a&gt; . Хотя это типично, не требуется, чтобы блоки &lt;code&gt;begin&lt;/code&gt; были многострочными или чтобы цепочки &lt;code&gt;(;)&lt;/code&gt; были однострочными:</target>
        </trans-unit>
        <trans-unit id="83194f70ea7b6512bb44658828e86b5786ad5bb1" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;;&lt;/code&gt; chains be single-line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f077087d177239939e6f396d6a624b184f2ac650" translate="yes" xml:space="preserve">
          <source>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, such as managing system state. For example, there is a version of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; that runs code ensuring that the opened file is eventually closed:</source>
          <target state="translated">Этот синтаксис упрощает использование функций для эффективного расширения языка, поскольку вызовы выглядят как обычные блоки кода. Есть много возможных применений, совершенно отличных от &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; , таких как управление состоянием системы. Например, есть версия &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; ,&lt;/a&gt; которая запускает код, гарантирующий, что открытый файл в конечном итоге закрыт:</target>
        </trans-unit>
        <trans-unit id="f43fea58e0ae0e5d3bca8325c7f2571bc765f36f" translate="yes" xml:space="preserve">
          <source>This syntax requires at least Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1ae67ce8368a39428c877f009a37b4f880a256" translate="yes" xml:space="preserve">
          <source>This table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.</source>
          <target state="translated">Эта таблица может содержать пропущенные символы во втором столбце или даже показывать символы,которые не соответствуют символам,отображаемым в Julia REPL.В этих случаях пользователям настоятельно рекомендуется проверить выбор шрифтов в браузере и среде REPL,так как во многих шрифтах есть известные проблемы с глифами.</target>
        </trans-unit>
        <trans-unit id="a5ba3b718070c3a0261004f71106e6c8df784735" translate="yes" xml:space="preserve">
          <source>This task will wait for five seconds, and then print &lt;code&gt;done&lt;/code&gt;. However, it has not started running yet. We can run it whenever we're ready by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89bcac53db86417f8d21a8b570dbed4f33b9ba7" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</source>
          <target state="translated">Этот признак обычно используется для выбора между алгоритмами,которые предварительно выделяют определенный тип результата,и алгоритмами,которые выбирают тип результата исходя из типов полученных значений.</target>
        </trans-unit>
        <trans-unit id="1f0edb00527596f441fd9eb4ee2e34299adf317c" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</source>
          <target state="translated">Этот признак обычно используется для выбора между алгоритмами,которые предварительно выделяют место для их результата,и алгоритмами,которые изменяют размер результата инкрементно.</target>
        </trans-unit>
        <trans-unit id="2b71013f6265bcf3fbfa85be77bdc79abb70d813" translate="yes" xml:space="preserve">
          <source>This trait-based approach is also present in the &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt; mechanism employed by the scalar &lt;code&gt;+&lt;/code&gt;. It uses &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.</source>
          <target state="translated">Этот подход, основанный на признаках, также присутствует в механизме &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt; , используемом скалярным &lt;code&gt;+&lt;/code&gt; . Он использует &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; , который возвращает оптимальный общий тип для вычисления операции с учетом двух типов операндов. Это позволяет свести проблему реализации каждой функции для каждой пары возможных аргументов типа к гораздо меньшей проблеме реализации операции преобразования каждого типа в общий тип плюс таблица предпочтительных правил попарного продвижения.</target>
        </trans-unit>
        <trans-unit id="c92d7110a049bc7dcfccf1f71e9a16f713393738" translate="yes" xml:space="preserve">
          <source>This type is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип предназначен для использования линейной алгебры - для общих &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt; данными см. Permutedims .</target>
        </trans-unit>
        <trans-unit id="14576a2d3cb9e572c8640a36656bd2d6880b92e4" translate="yes" xml:space="preserve">
          <source>This type may appear innocuous enough, until one considers how to construct an instance of it. If &lt;code&gt;a&lt;/code&gt; is an instance of &lt;code&gt;SelfReferential&lt;/code&gt;, then a second instance can be created by the call:</source>
          <target state="translated">Этот тип может показаться достаточно безобидным, пока кто-то не подумает, как построить его экземпляр. Если &lt;code&gt;a&lt;/code&gt; является экземпляром &lt;code&gt;SelfReferential&lt;/code&gt; , то второй экземпляр может быть создан с помощью вызова:</target>
        </trans-unit>
        <trans-unit id="48abfe02204852dcf9f8e73526e2ce7ae985ea01" translate="yes" xml:space="preserve">
          <source>This typically means that types for which a custom &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;isequal&lt;/code&gt; method exists must implement a corresponding &lt;code&gt;hash&lt;/code&gt; method (and vice versa). Collections typically implement &lt;code&gt;isequal&lt;/code&gt; by calling &lt;code&gt;isequal&lt;/code&gt; recursively on all contents.</source>
          <target state="translated">Обычно это означает, что типы, для которых существует собственный метод &lt;code&gt;==&lt;/code&gt; или &lt;code&gt;isequal&lt;/code&gt; , должны реализовывать соответствующий метод &lt;code&gt;hash&lt;/code&gt; (и наоборот). Коллекции обычно реализуют &lt;code&gt;isequal&lt;/code&gt; , рекурсивно вызывая &lt;code&gt;isequal&lt;/code&gt; для всего содержимого.</target>
        </trans-unit>
        <trans-unit id="b28a88f90eb34855ebcb028f2694d128ce6e0f54" translate="yes" xml:space="preserve">
          <source>This version returns &lt;code&gt;s&lt;/code&gt; as before but it also uses the &lt;code&gt;@isdefined&lt;/code&gt; macro to return a boolean indicating whether there is a local variable named &lt;code&gt;t&lt;/code&gt; defined in the function's outermost local scope. As you can see, there is no &lt;code&gt;t&lt;/code&gt; defined outside of the &lt;code&gt;for&lt;/code&gt; loop body. This is because of the hard scope rule again: since the assignment to &lt;code&gt;t&lt;/code&gt; occurs inside of a function, which introduces a hard scope, the assignment causes &lt;code&gt;t&lt;/code&gt; to become a new local variable in the local scope where it appears, i.e. inside of the loop body. Even if there were a global named &lt;code&gt;t&lt;/code&gt;, it would make no difference&amp;mdash;the hard scope rule isn't affected by anything in global scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732e45fbae13bbb344c9807714543561cca2e0ec" translate="yes" xml:space="preserve">
          <source>This view is similarly selecting every other column from our original &lt;code&gt;A&lt;/code&gt; &amp;mdash; and thus it needs to skip the equivalent of two five-element columns when moving between indices in the second dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e583420152cbf4b34f9b32d8a694ae8548f399df" translate="yes" xml:space="preserve">
          <source>This will continuing tracking changes for &lt;code&gt;path&lt;/code&gt; in the background until &lt;code&gt;unwatch_folder&lt;/code&gt; is called on the same &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Это будет продолжать отслеживать изменения &lt;code&gt;path&lt;/code&gt; в фоновом режиме до тех &lt;code&gt;unwatch_folder&lt;/code&gt; пока по тому же &lt;code&gt;path&lt;/code&gt; будет вызвана unwatch_folder .</target>
        </trans-unit>
        <trans-unit id="f13e78aea1113a7ecb31103654e0f08522f06f04" translate="yes" xml:space="preserve">
          <source>This will create a link in the generated docs to the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; documentation (which has more information about what this function actually does), and to the &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; documentation. It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.</source>
          <target state="translated">Это создаст ссылку в сгенерированных документах на документацию по &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; (в которой содержится дополнительная информация о том, что на самом деле делает эта функция), и на документацию &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; . Хорошо включать перекрестные ссылки на изменяющиеся / не изменяющиеся версии функции или выделять разницу между двумя похожими функциями.</target>
        </trans-unit>
        <trans-unit id="b96927e2f1de092a211a143e54dd74f41007bb3e" translate="yes" xml:space="preserve">
          <source>This will not specialize:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a99e60f54b8d446ae19455b15a099ea1107a66" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;(-1, 0)&lt;/code&gt;.</source>
          <target state="translated">Это вернет &lt;code&gt;(-1, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="286660d1556fa7b595f130646ffbfab297bc669e" translate="yes" xml:space="preserve">
          <source>This will run afoul of a method that supplies default padding:</source>
          <target state="translated">Это будет противоречить методу,который поставляет набивку по умолчанию:</target>
        </trans-unit>
        <trans-unit id="0f5b3315acf48556d7fa62b1bfb954506305c5d1" translate="yes" xml:space="preserve">
          <source>This will typically be the parent directory of &lt;code&gt;gitdir(repo)&lt;/code&gt;, but can be different in some cases: e.g. if either the &lt;code&gt;core.worktree&lt;/code&gt; configuration variable or the &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable is set.</source>
          <target state="translated">Обычно это родительский каталог &lt;code&gt;gitdir(repo)&lt;/code&gt; , но в некоторых случаях может быть другим: например, если установлена ​​переменная конфигурации &lt;code&gt;core.worktree&lt;/code&gt; или &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; среды GIT_WORK_TREE .</target>
        </trans-unit>
        <trans-unit id="465cd08242692b4a225db05b65fef6a04fbb4c51" translate="yes" xml:space="preserve">
          <source>This works, but (as you can verify for yourself using &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt;) the problem is that the output type cannot be inferred: the argument &lt;code&gt;N&lt;/code&gt; is a &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;Int&lt;/code&gt;, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of &lt;code&gt;A&lt;/code&gt;; such code will be very slow.</source>
          <target state="translated">Это работает, но (как вы можете сами убедиться, используя &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt; ) проблема в том, что тип вывода не может быть выведен: аргумент &lt;code&gt;N&lt;/code&gt; является &lt;em&gt;значением&lt;/em&gt; типа &lt;code&gt;Int&lt;/code&gt; , а вывод типа - нет (и не может) заранее предсказать его стоимость. Это означает, что код, использующий выходные данные этой функции, должен быть консервативным, проверяя тип при каждом доступе к &lt;code&gt;A&lt;/code&gt; ; такой код будет очень медленным.</target>
        </trans-unit>
        <trans-unit id="91dccd376458eb0eba1948b74924d4cacdf4e65c" translate="yes" xml:space="preserve">
          <source>This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like &lt;code&gt;Vector()&lt;/code&gt; to behave in a certain way, and overly customizing its behavior can make it harder to work with.</source>
          <target state="translated">Это обеспечит настраиваемое отображение векторов с определенным новым типом элемента. Хотя соблазнительно, этого следует избегать. Проблема в том, что пользователи ожидают, что известный тип, такой как &lt;code&gt;Vector()&lt;/code&gt; будет вести себя определенным образом, и чрезмерная настройка его поведения может затруднить работу с ним.</target>
        </trans-unit>
        <trans-unit id="ce93190f2d45e03cc3d832dd1dbdeefa914b4a96" translate="yes" xml:space="preserve">
          <source>Those that are parsed like &lt;code&gt;*&lt;/code&gt; (in terms of precedence) include &lt;code&gt;* / &amp;divide; % &amp;amp; &amp;sdot; ∘ &amp;times; |\\| &amp;cap; &amp;and; &amp;otimes; ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ &amp;lowast; ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗&lt;/code&gt; and those that are parsed like &lt;code&gt;+&lt;/code&gt; include &lt;code&gt;+ - |\|| &amp;oplus; ⊖ ⊞ ⊟ |++| &amp;cup; &amp;or; ⊔ &amp;plusmn; ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣&lt;/code&gt; There are many others that are related to arrows, comparisons, and powers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad99bad1a037688795be38c39427fa0769348cbe" translate="yes" xml:space="preserve">
          <source>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation &amp;ndash; even from the interactive prompt. This is accomplished just by making an appropriate call with &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; syntax, which looks like an ordinary function call.</source>
          <target state="translated">Хотя большая часть кода может быть написана на Julia, существует множество высококачественных зрелых библиотек для численных вычислений, уже написанных на C и Fortran. Чтобы упростить использование этого существующего кода, Джулия делает простой и эффективный вызов функций C и Fortran. Джулия придерживается философии &amp;laquo;без шаблонов&amp;raquo;: функции можно вызывать прямо из Джулии без какого-либо &amp;laquo;связующего&amp;raquo; кода, генерации кода или компиляции - даже из интерактивной подсказки. Это достигается простым вызовом с синтаксисом &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , который выглядит как обычный вызов функции.</target>
        </trans-unit>
        <trans-unit id="b1098d0533850d709c2eea0b6cccb4d789ad7a33" translate="yes" xml:space="preserve">
          <source>Thought Balloon</source>
          <target state="translated">Воздушный шар мыслей</target>
        </trans-unit>
        <trans-unit id="e7d883028ca01a1fd0855b14863bfa7121240ec4" translate="yes" xml:space="preserve">
          <source>Thread-safety</source>
          <target state="translated">Thread-safety</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e419e1146ddb88bafc45f8ebac6b8292c4ced05a" translate="yes" xml:space="preserve">
          <source>Threads.@threads</source>
          <target state="translated">Threads.@threads</target>
        </trans-unit>
        <trans-unit id="af0966b4fd9f2b0cc49a7865b215af5194f37f0a" translate="yes" xml:space="preserve">
          <source>Threads.Atomic</source>
          <target state="translated">Threads.Atomic</target>
        </trans-unit>
        <trans-unit id="6d681958311270ce80eaf4515832385236fe2aa7" translate="yes" xml:space="preserve">
          <source>Threads.Condition</source>
          <target state="translated">Threads.Condition</target>
        </trans-unit>
        <trans-unit id="35d529a964d25f4e3aa6ca9d1ca0ce8f4be400d6" translate="yes" xml:space="preserve">
          <source>Threads.Mutex</source>
          <target state="translated">Threads.Mutex</target>
        </trans-unit>
        <trans-unit id="fdec23601f6d79aec8f6567bbffa2c92cd56f7b8" translate="yes" xml:space="preserve">
          <source>Threads.SpinLock</source>
          <target state="translated">Threads.SpinLock</target>
        </trans-unit>
        <trans-unit id="dc252ab69b1ee919bcf5db69994a187e411ca970" translate="yes" xml:space="preserve">
          <source>Threads.atomic_add!()</source>
          <target state="translated">Threads.atomic_add!()</target>
        </trans-unit>
        <trans-unit id="0d6bade715cafd9dcdad87d2c22d90bbfc1e9bc3" translate="yes" xml:space="preserve">
          <source>Threads.atomic_and!()</source>
          <target state="translated">Threads.atomic_and!()</target>
        </trans-unit>
        <trans-unit id="fc348be87bc254a3559139ac661b72946bb39a71" translate="yes" xml:space="preserve">
          <source>Threads.atomic_cas!()</source>
          <target state="translated">Threads.atomic_cas!()</target>
        </trans-unit>
        <trans-unit id="f62c63142218283b0037fda6af5f0f3a02c2975f" translate="yes" xml:space="preserve">
          <source>Threads.atomic_fence()</source>
          <target state="translated">Threads.atomic_fence()</target>
        </trans-unit>
        <trans-unit id="4bb65236b89d5d31da9f4d8820a38668a9dbf21c" translate="yes" xml:space="preserve">
          <source>Threads.atomic_max!()</source>
          <target state="translated">Threads.atomic_max!()</target>
        </trans-unit>
        <trans-unit id="8833f2d74d5a7e5aa857580591ba695e2d6fc9b4" translate="yes" xml:space="preserve">
          <source>Threads.atomic_min!()</source>
          <target state="translated">Threads.atomic_min!()</target>
        </trans-unit>
        <trans-unit id="9d6eae92e1cf6253daf74605c345f63d354fc4f7" translate="yes" xml:space="preserve">
          <source>Threads.atomic_nand!()</source>
          <target state="translated">Threads.atomic_nand!()</target>
        </trans-unit>
        <trans-unit id="560bfbccb3de090b47f2c10c244f66c66c580494" translate="yes" xml:space="preserve">
          <source>Threads.atomic_or!()</source>
          <target state="translated">Threads.atomic_or!()</target>
        </trans-unit>
        <trans-unit id="f3e1cd9ba44ee30e82bb0904faa52cbf59c0038d" translate="yes" xml:space="preserve">
          <source>Threads.atomic_sub!()</source>
          <target state="translated">Threads.atomic_sub!()</target>
        </trans-unit>
        <trans-unit id="13028b27bde6678508d39212264589ec6a15feea" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xchg!()</source>
          <target state="translated">Threads.atomic_xchg!()</target>
        </trans-unit>
        <trans-unit id="733c9373c4a5344eab540082f44fb3d0c9691c39" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xor!()</source>
          <target state="translated">Threads.atomic_xor!()</target>
        </trans-unit>
        <trans-unit id="be840129016948f129890bec761377fa710398c9" translate="yes" xml:space="preserve">
          <source>Threads.nthreads()</source>
          <target state="translated">Threads.nthreads()</target>
        </trans-unit>
        <trans-unit id="a889ac57822379f233ec938a1f7a38f70d5c6296" translate="yes" xml:space="preserve">
          <source>Threads.threadid()</source>
          <target state="translated">Threads.threadid()</target>
        </trans-unit>
        <trans-unit id="0aad1c36c5f4e6d7170e1c4b0293604b8b212cfa" translate="yes" xml:space="preserve">
          <source>Three Consecutive Equals Signs</source>
          <target state="translated">Три знака последовательного равенства</target>
        </trans-unit>
        <trans-unit id="275c8d26b15f014b3ee22a364da92aa616ab6c12" translate="yes" xml:space="preserve">
          <source>Three Dimensional Angle</source>
          <target state="translated">Трехмерный угол</target>
        </trans-unit>
        <trans-unit id="34c44d666ec4b94d3bbda9f288521e6aef7e833a" translate="yes" xml:space="preserve">
          <source>Three Leftwards Arrows</source>
          <target state="translated">Три стрелки влево</target>
        </trans-unit>
        <trans-unit id="6845b5c6dca3f04d0fc4092b2f6f1fa8ad41c493" translate="yes" xml:space="preserve">
          <source>Three Rightwards Arrows</source>
          <target state="translated">Три стрелки вправо</target>
        </trans-unit>
        <trans-unit id="649300e311dc9e0d97883f25214a816938115a07" translate="yes" xml:space="preserve">
          <source>Throw a &lt;a href=&quot;#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; unless &lt;code&gt;x isa type&lt;/code&gt;. The syntax &lt;code&gt;x::type&lt;/code&gt; calls this function.</source>
          <target state="translated">Выбросить &lt;a href=&quot;#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;x isa type&lt;/code&gt; . Синтаксис &lt;code&gt;x::type&lt;/code&gt; вызывает эту функцию.</target>
        </trans-unit>
        <trans-unit id="714760623b81eda189caf56e00d3dd66b2ad778d" translate="yes" xml:space="preserve">
          <source>Throw an &lt;a href=&quot;#Core.AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Preferred syntax for writing assertions. Message &lt;code&gt;text&lt;/code&gt; is optionally displayed upon assertion failure.</source>
          <target state="translated">Бросьте &lt;a href=&quot;#Core.AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;cond&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; . Предпочтительный синтаксис для написания утверждений. &lt;code&gt;text&lt;/code&gt; сообщения необязательно отображается в случае ошибки утверждения.</target>
        </trans-unit>
        <trans-unit id="fde334b7c50e867ec42457ab4cfac34135b82f0a" translate="yes" xml:space="preserve">
          <source>Throw an error if the specified indices &lt;code&gt;I&lt;/code&gt; are not in bounds for the given array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Бросьте ошибку , если указанные индексы &lt;code&gt;I&lt;/code&gt; не в пределах для данного массива &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f0af829c424acf2aaed30a43af670830af1bf4e" translate="yes" xml:space="preserve">
          <source>Throw an object as an exception.</source>
          <target state="translated">Бросьте объект как исключение.</target>
        </trans-unit>
        <trans-unit id="140ef8a807386c342270a60ed53ce02c73c18d34" translate="yes" xml:space="preserve">
          <source>Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a &lt;code&gt;catch&lt;/code&gt; block).</source>
          <target state="translated">Выбросить объект без изменения трассировки текущего исключения. Аргументом по умолчанию является текущее исключение (если вызывается в блоке &lt;code&gt;catch&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="580dadd5162b2d0824b14a53a53520885f69bb7a" translate="yes" xml:space="preserve">
          <source>Throwing Julia Exceptions</source>
          <target state="translated">Бросая Джулию Исключения</target>
        </trans-unit>
        <trans-unit id="b55eb9740df570160a4568c629959c237f6eace8" translate="yes" xml:space="preserve">
          <source>Thumbs Down Sign</source>
          <target state="translated">Знак &quot;Большие пальцы вниз</target>
        </trans-unit>
        <trans-unit id="605c4f2d25dae572dac0bd7100ede0e91ce19009" translate="yes" xml:space="preserve">
          <source>Thumbs Up Sign</source>
          <target state="translated">Подпишитесь</target>
        </trans-unit>
        <trans-unit id="760c9c88e6ab4015bdda89ce2b03fc29323c09ed" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that the scope of variables can be inferred from the source code alone.</source>
          <target state="translated">Таким образом, &lt;em&gt;лексическая область видимости&lt;/em&gt; означает, что область видимости переменных может быть выведена только из исходного кода.</target>
        </trans-unit>
        <trans-unit id="ff70b958cdd14735d439df7f031d3f90247ced00" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that what a variable in a particular piece of code refers to can be deduced from the code in which it appears alone and does not depend on how the program executes. A scope nested inside another scope can &quot;see&quot; variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1904bf1147b9a9b4718a957b259ff3b20ed4ec" translate="yes" xml:space="preserve">
          <source>Thus global variables are only inherited for reading, not for writing:</source>
          <target state="translated">Таким образом,глобальные переменные наследуются только для чтения,а не для записи:</target>
        </trans-unit>
        <trans-unit id="37807420ee61e708d970e7d90819e0a642c8a0c3" translate="yes" xml:space="preserve">
          <source>Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using &lt;code&gt;let&lt;/code&gt; blocks to localize global variables.</source>
          <target state="translated">Таким образом, программы должны быть осторожны, ссылаясь на глобальные объекты в удаленных вызовах. На самом деле, по возможности предпочтительно их вообще избегать. Если вы должны ссылаться на глобальные переменные, рассмотрите возможность использования блоков &lt;code&gt;let&lt;/code&gt; для локализации глобальных переменных.</target>
        </trans-unit>
        <trans-unit id="1ec3104629ec61f45eec6025fd4920b5b97b82ff" translate="yes" xml:space="preserve">
          <source>Thus, a minimal cluster manager would need to:</source>
          <target state="translated">Таким образом,потребуется минимальный менеджер кластера:</target>
        </trans-unit>
        <trans-unit id="7b4c9299e93152df59eb2d7a356e597a287f7f91" translate="yes" xml:space="preserve">
          <source>Thus, a task executing a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt; (C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Таким образом, задача, выполняющая &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; ,&lt;/a&gt; эффективно предотвращает выполнение планировщиком Julia любых других задач, пока вызов не вернется. Это верно для всех вызовов внешних библиотек. Исключения - это вызовы пользовательского кода C, который обращается к Julia (который затем может дать результат), или код C, который вызывает &lt;code&gt;jl_yield()&lt;/code&gt; (эквивалент &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; для&lt;/a&gt; C ).</target>
        </trans-unit>
        <trans-unit id="12a48793aeeeb710ac9dcc9260ed6b02480a02b9" translate="yes" xml:space="preserve">
          <source>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</source>
          <target state="translated">Таким образом,абстрактные типы позволяют программистам писать общие функции,которые в дальнейшем могут быть использованы в качестве метода по умолчанию многими комбинациями конкретных типов.Благодаря многократной диспетчеризации,программист имеет полный контроль над тем,используется ли метод по умолчанию или более конкретный метод.</target>
        </trans-unit>
        <trans-unit id="f601caf538448fdd3302f7c350467ef72143226f" translate="yes" xml:space="preserve">
          <source>Thus, although the &lt;code&gt;⊘&lt;/code&gt; operator usually returns an instance of &lt;code&gt;OurRational&lt;/code&gt;, if either of its arguments are complex integers, it will return an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; instead. The interested reader should consider perusing the rest of &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt;: it is short, self-contained, and implements an entire basic Julia type.</source>
          <target state="translated">Таким образом, хотя оператор &lt;code&gt;⊘&lt;/code&gt; обычно возвращает экземпляр &lt;code&gt;OurRational&lt;/code&gt; , если один из его аргументов является комплексным целым &lt;code&gt;Complex{OurRational}&lt;/code&gt; вместо этого он вернет экземпляр Complex {OurRational} . Заинтересованный читатель должен рассмотреть возможность просмотра остальной части &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt; : он короткий, самодостаточный и реализует весь базовый тип Julia.</target>
        </trans-unit>
        <trans-unit id="d4a7cf3884ed1ab47ea12e5c77940efcf3a6f460" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626f028f772316f29a1f3bc180af9b3cc6e9feec" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">Таким образом, арифметика с целыми числами Джулии на самом деле является формой &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;модульной арифметики&lt;/a&gt; . Это отражает характеристики базовой арифметики целых чисел, реализованной на современных компьютерах. В приложениях, где возможно переполнение, важна явная проверка циклического перехода, вызванного переполнением; в противном случае вместо этого рекомендуется &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; тип BigInt в &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;арифметике произвольной точности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2b83f1b321c20d701d32773b7f124c10518c979" translate="yes" xml:space="preserve">
          <source>Thus, the parser does not know that &lt;code&gt;r&lt;/code&gt; has a fixed type (&lt;code&gt;Int&lt;/code&gt;). nor that &lt;code&gt;r&lt;/code&gt; does not change value once the inner function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object with an abstract type such as &lt;code&gt;Any&lt;/code&gt;, which requires run-time type dispatch for each occurrence of &lt;code&gt;r&lt;/code&gt;. This can be verified by applying &lt;code&gt;@code_warntype&lt;/code&gt; to the above function. Both the boxing and the run-time type dispatch can cause loss of performance.</source>
          <target state="translated">Таким образом, парсер не знает, что &lt;code&gt;r&lt;/code&gt; имеет фиксированный тип ( &lt;code&gt;Int&lt;/code&gt; ). ни то, что &lt;code&gt;r&lt;/code&gt; не изменяет значение после создания внутренней функции (так что поле не нужно). Следовательно, синтаксический анализатор генерирует код для box, который содержит объект с абстрактным типом, например &lt;code&gt;Any&lt;/code&gt; , который требует диспетчеризации типа во время выполнения для каждого вхождения &lt;code&gt;r&lt;/code&gt; . Это можно проверить, применив &lt;code&gt;@code_warntype&lt;/code&gt; к указанной выше функции. Как упаковка, так и диспетчеризация типа времени выполнения могут вызвать потерю производительности.</target>
        </trans-unit>
        <trans-unit id="405f79bc0440035cdbe7cdfa2f5f8191b1e769bd" translate="yes" xml:space="preserve">
          <source>Thus, use &lt;code&gt;Int&lt;/code&gt; literals when possible, with &lt;code&gt;Rational{Int}&lt;/code&gt; for literal non-integer numbers, in order to make it easier to use your code.</source>
          <target state="translated">Таким образом, по возможности используйте литералы &lt;code&gt;Int&lt;/code&gt; с &lt;code&gt;Rational{Int}&lt;/code&gt; для буквальных нецелых чисел, чтобы упростить использование вашего кода.</target>
        </trans-unit>
        <trans-unit id="7dfa2079791005dea78a84f2b9726b0bdb6de3e2" translate="yes" xml:space="preserve">
          <source>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</source>
          <target state="translated">Таким образом,хотя неявные конструкторы параметров типа,предусмотренные в Юлии по умолчанию,достаточно строги,можно сделать так,чтобы они вели себя более расслабленно,но разумно,довольно легко.Более того,поскольку конструкторы могут использовать всю мощь системы типов,методов и множественной диспетчеризации,определение сложного поведения обычно довольно просто.</target>
        </trans-unit>
        <trans-unit id="a7677e84b6660292620566337bcfc94144911cc7" translate="yes" xml:space="preserve">
          <source>Ticket</source>
          <target state="translated">Ticket</target>
        </trans-unit>
        <trans-unit id="dd697aa8cce5c810f10070878f9d6f89c5a5937c" translate="yes" xml:space="preserve">
          <source>Tiger</source>
          <target state="translated">Tiger</target>
        </trans-unit>
        <trans-unit id="abee288b1344129c8247490b49084155f62a8492" translate="yes" xml:space="preserve">
          <source>Tiger Face</source>
          <target state="translated">тигровое лицо</target>
        </trans-unit>
        <trans-unit id="a213b01ff977ddc2b77a2851775a17888cf936a4" translate="yes" xml:space="preserve">
          <source>Tilde Operator</source>
          <target state="translated">Тильде-оператор</target>
        </trans-unit>
        <trans-unit id="81f0f8e7286707e1e34046d94807c0c638e949b0" translate="yes" xml:space="preserve">
          <source>Tilde Operator Above Leftwards Arrow</source>
          <target state="translated">Тильде оператор Стрелка вверх Стрелка влево</target>
        </trans-unit>
        <trans-unit id="248cc81b5c32172ec329e2bbdd1480c988bb3388" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Dot Above</source>
          <target state="translated">Тильде оператор с точкой выше</target>
        </trans-unit>
        <trans-unit id="6835d0448d1238ede880e3906c4de76444a3efae" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Rising Dots</source>
          <target state="translated">Тильде оператор с восходящими точками</target>
        </trans-unit>
        <trans-unit id="358886c6ac36a9af9f2410bb87185645588db7c9" translate="yes" xml:space="preserve">
          <source>Time in a signature. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt;&lt;code&gt;git_time&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Время в подписи. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt; &lt;code&gt;git_time&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1aef662800be3b19d04a84bdbd802cb869572bc" translate="yes" xml:space="preserve">
          <source>TimeType-Period Arithmetic</source>
          <target state="translated">Арифметика TimeType-Period</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="e524304a680bc45ab65762e1df41198ad5434553" translate="yes" xml:space="preserve">
          <source>Timer()</source>
          <target state="translated">Timer()</target>
        </trans-unit>
        <trans-unit id="4e252bb0e117c9cedaeca8da5f4796af646d44a9" translate="yes" xml:space="preserve">
          <source>Timing results:</source>
          <target state="translated">Результаты по времени:</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="0d5993668385f8eefae208c8f706f8bc977fc760" translate="yes" xml:space="preserve">
          <source>Tired Face</source>
          <target state="translated">Уставшее лицо</target>
        </trans-unit>
        <trans-unit id="d8411edb15bb7d4ab010f7414d30f893e168d44a" translate="yes" xml:space="preserve">
          <source>To access the raw code units (bytes for UTF-8) of the encoding, you can use the &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt;&lt;code&gt;codeunit(s,i)&lt;/code&gt;&lt;/a&gt; function, where the index &lt;code&gt;i&lt;/code&gt; runs consecutively from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ncodeunits(s)&lt;/code&gt;. The &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt;&lt;code&gt;codeunits(s)&lt;/code&gt;&lt;/a&gt; function returns an &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; wrapper that lets you access these raw codeunits (bytes) as an array.</source>
          <target state="translated">Чтобы получить доступ к единицам исходного кода (байты для UTF-8) кодировки, вы можете использовать функцию &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt; &lt;code&gt;codeunit(s,i)&lt;/code&gt; &lt;/a&gt; , где индекс &lt;code&gt;i&lt;/code&gt; выполняется последовательно от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;ncodeunits(s)&lt;/code&gt; . Функция &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt; &lt;code&gt;codeunits(s)&lt;/code&gt; &lt;/a&gt; возвращает оболочку &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; которая позволяет вам получить доступ к этим необработанным кодовым единицам (байтам) как к массиву.</target>
        </trans-unit>
        <trans-unit id="e95b1141b5118da7c6df142a7dc74b9f038403fe" translate="yes" xml:space="preserve">
          <source>To add a package, use &lt;code&gt;add&lt;/code&gt;:</source>
          <target state="translated">Чтобы добавить пакет, используйте &lt;code&gt;add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fca3c84bc7bcf6dfd1b3203ec788903367443803" translate="yes" xml:space="preserve">
          <source>To address these scenarios, Julia provides &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s (also known by several other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations). When a piece of computing work (in practice, executing a particular function) is designated as a &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, it becomes possible to interrupt it by switching to another &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;. The original &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences. First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d353ae44a58cccba974a5708143d72c88b86a0" translate="yes" xml:space="preserve">
          <source>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; and the &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR Library&lt;/a&gt;, respectively. The &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; types are available in Julia for arbitrary precision integer and floating point numbers respectively.</source>
          <target state="translated">Чтобы разрешить вычисления с целыми числами произвольной точности и числами с плавающей запятой, Джулия обертывает &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; и &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR Library&lt;/a&gt; соответственно. В &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; типов доступны в Джулию для произвольной точности целых и чисел с плавающей точкой соответственно.</target>
        </trans-unit>
        <trans-unit id="f92958b0eb5e7d500f4fc83e966e176ae982e7c8" translate="yes" xml:space="preserve">
          <source>To allow for the creation of incompletely initialized objects, Julia allows the &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the &lt;code&gt;SelfReferential&lt;/code&gt; type, this time using a zero-argument inner constructor returning instances having &lt;code&gt;obj&lt;/code&gt; fields pointing to themselves:</source>
          <target state="translated">Чтобы разрешить создание не полностью инициализированных объектов, Джулия позволяет вызывать &lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; функцию с меньшим количеством полей, чем имеет тип, возвращая объект с неинициализированными неопределенными полями. Затем метод внутреннего конструктора может использовать неполный объект, завершив его инициализацию перед его возвратом. Вот, например, еще одна попытка определения типа &lt;code&gt;SelfReferential&lt;/code&gt; , на этот раз с использованием внутреннего конструктора с нулевым аргументом, возвращающего экземпляры, имеющие поля &lt;code&gt;obj&lt;/code&gt; , указывающие на себя:</target>
        </trans-unit>
        <trans-unit id="647cb570f3aba993aaa46d9c3e91117ed01a95c0" translate="yes" xml:space="preserve">
          <source>To amplify a bit further, consider the following function:</source>
          <target state="translated">Чтобы немного усилить,рассмотрим следующую функцию:</target>
        </trans-unit>
        <trans-unit id="7e940b0d75467f1279dc9099ee9a7a7226dd9aa5" translate="yes" xml:space="preserve">
          <source>To avoid even having to define a named function, you can use the &lt;code&gt;do&lt;/code&gt; syntax, which creates an anonymous function on the fly:</source>
          <target state="translated">Чтобы даже не определять именованную функцию, вы можете использовать синтаксис &lt;code&gt;do&lt;/code&gt; , который создает анонимную функцию на лету:</target>
        </trans-unit>
        <trans-unit id="7511ec9a398ed68674d80480ecea6a9ca91ed0f1" translate="yes" xml:space="preserve">
          <source>To call &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Threads.Condition&lt;/code&gt;, you must first call &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; on it. When &lt;code&gt;wait&lt;/code&gt; is called, the lock is atomically released during blocking, and will be reacquired before &lt;code&gt;wait&lt;/code&gt; returns. Therefore idiomatic use of a &lt;code&gt;Threads.Condition&lt;/code&gt;&lt;code&gt;c&lt;/code&gt; looks like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dc537d704eaca673949b4e42b6c53501bae68d" translate="yes" xml:space="preserve">
          <source>To check if a regex matches a string, use &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы проверить, соответствует ли регулярное выражение строке, используйте &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="eed84206f52f8f65140a28df43e2ff030f4f3a51" translate="yes" xml:space="preserve">
          <source>To concatenate in the first (&quot;vertical&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with semicolons (&lt;code&gt;[x; y; z]&lt;/code&gt;).</source>
          <target state="translated">Для объединения в первом (&amp;laquo;вертикальном&amp;raquo;) измерении используйте либо &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat(x,y,z)&lt;/code&gt; &lt;/a&gt; либо разделите их точкой с запятой ( &lt;code&gt;[x; y; z]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="836f5fac5628ace8eede45159f560aedbc2e431e" translate="yes" xml:space="preserve">
          <source>To concatenate in the second (&quot;horizontal&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with spaces (&lt;code&gt;[x y z]&lt;/code&gt;).</source>
          <target state="translated">Для объединения во втором (&amp;laquo;горизонтальном&amp;raquo;) измерении используйте &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat(x,y,z)&lt;/code&gt; &lt;/a&gt; или разделите пробелами ( &lt;code&gt;[x y z]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c1db2888c6f2a52fec0ea3a56df9e7e662b6768f" translate="yes" xml:space="preserve">
          <source>To construct block matrices (concatenating in the first two dimensions), use either &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt; or combine spaces and semicolons (&lt;code&gt;[a b; c d]&lt;/code&gt;).</source>
          <target state="translated">Чтобы построить блочные матрицы (объединение в первых двух измерениях), используйте либо &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; ,&lt;/a&gt; либо объедините пробелы и точки с запятой ( &lt;code&gt;[a b; c d]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c9dbf08e7476ec37f2720092790ffb3b8fd03ca2" translate="yes" xml:space="preserve">
          <source>To customize how instances of a type are displayed, overload &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; rather than &lt;code&gt;display&lt;/code&gt;, as explained in the manual section on &lt;a href=&quot;../../manual/types/index#man-custom-pretty-printing&quot;&gt;custom pretty-printing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99653d877bbee5b290b6ca0e94590ab093ad658f" translate="yes" xml:space="preserve">
          <source>To customize human-readable text output for objects of type &lt;code&gt;T&lt;/code&gt;, define &lt;code&gt;show(io::IO, ::MIME&quot;text/plain&quot;, ::T)&lt;/code&gt; instead. Checking the &lt;code&gt;:compact&lt;/code&gt;&lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; property of &lt;code&gt;io&lt;/code&gt; in such methods is recommended, since some containers show their elements by calling this method with &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a141c1fb8d334654feff124c660c2fb4df2cb73d" translate="yes" xml:space="preserve">
          <source>To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for &lt;code&gt;f&lt;/code&gt; over all pairs of instances of the abstract type &lt;code&gt;Number&lt;/code&gt; &amp;ndash; but with a different behavior specific to pairs of &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. If one of the arguments is a 64-bit float but the other one is not, then the &lt;code&gt;f(Float64,Float64)&lt;/code&gt; method cannot be called and the more general &lt;code&gt;f(Number,Number)&lt;/code&gt; method must be used:</source>
          <target state="translated">Чтобы определить функцию с несколькими методами, нужно просто определить функцию несколько раз с разными числами и типами аргументов. Первое определение метода для функции создает объект функции, а последующие определения методов добавляют новые методы к существующему объекту функции. Наиболее конкретное определение метода, соответствующее количеству и типам аргументов, будет выполнено при применении функции. Таким образом, два приведенных выше определения метода, взятые вместе, определяют поведение для &lt;code&gt;f&lt;/code&gt; для всех пар экземпляров абстрактного типа &lt;code&gt;Number&lt;/code&gt; - но с другим поведением, характерным для пар значений &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . Если один из аргументов - 64-битное число с плавающей запятой, а другой - нет, то &lt;code&gt;f(Float64,Float64)&lt;/code&gt; метод не может быть вызван, и необходимо использовать более общий метод &lt;code&gt;f(Number,Number)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="021f78e4d9ed5f18a45c45e25c0e08e2b86fc477" translate="yes" xml:space="preserve">
          <source>To define a new &lt;code&gt;rand&lt;/code&gt; method for an hypothetical &lt;code&gt;MyRNG&lt;/code&gt; generator, and a value specification &lt;code&gt;s&lt;/code&gt; (e.g. &lt;code&gt;s == Int&lt;/code&gt;, or &lt;code&gt;s == 1:10&lt;/code&gt;) of type &lt;code&gt;S==typeof(s)&lt;/code&gt; or &lt;code&gt;S==Type{s}&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is a type, the same two methods as we saw before must be defined:</source>
          <target state="translated">Чтобы определить новый метод &lt;code&gt;rand&lt;/code&gt; для гипотетического генератора &lt;code&gt;MyRNG&lt;/code&gt; и спецификацию значения &lt;code&gt;s&lt;/code&gt; (например, &lt;code&gt;s == Int&lt;/code&gt; или &lt;code&gt;s == 1:10&lt;/code&gt; ) типа &lt;code&gt;S==typeof(s)&lt;/code&gt; или &lt;code&gt;S==Type{s}&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; - это тип, должны быть определены те же два метода, что мы видели ранее:</target>
        </trans-unit>
        <trans-unit id="3e9f8911771a0e2e2a0a5444620f45dabaeaf75f" translate="yes" xml:space="preserve">
          <source>To demonstrate these issues, let us consider writing a &lt;code&gt;@time&lt;/code&gt; macro that takes an expression as its argument, records the time, evaluates the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression as its final value. The macro might look like this:</source>
          <target state="translated">Чтобы продемонстрировать эти проблемы, давайте рассмотрим написание макроса &lt;code&gt;@time&lt;/code&gt; , который принимает выражение в качестве аргумента, записывает время, оценивает выражение, снова записывает время, печатает разницу между временем до и после, а затем имеет значение выражение как его окончательное значение. Макрос может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="1e958f0a47bef2b5712e58abc88f1cd0cfc60a1f" translate="yes" xml:space="preserve">
          <source>To demonstrate, we might rewrite the &lt;code&gt;@time&lt;/code&gt; example above as:</source>
          <target state="translated">Чтобы продемонстрировать, мы могли бы переписать &lt;code&gt;@time&lt;/code&gt; выше пример @time как:</target>
        </trans-unit>
        <trans-unit id="e21d833954293a006de2f75f7b9609e75185bac1" translate="yes" xml:space="preserve">
          <source>To determine when a file was modified, compare &lt;code&gt;current isa StatStruct &amp;amp;&amp;amp; mtime(prev) != mtime(current)&lt;/code&gt; to detect notification of changes. However, using &lt;a href=&quot;#FileWatching.watch_file&quot;&gt;&lt;code&gt;watch_file&lt;/code&gt;&lt;/a&gt; for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.</source>
          <target state="translated">Чтобы определить, когда файл был изменен, сравните &lt;code&gt;current isa StatStruct &amp;amp;&amp;amp; mtime(prev) != mtime(current)&lt;/code&gt; чтобы обнаружить уведомление об изменениях. Однако использование &lt;a href=&quot;#FileWatching.watch_file&quot;&gt; &lt;code&gt;watch_file&lt;/code&gt; &lt;/a&gt; для этой операции предпочтительнее, так как это более надежно и эффективно, хотя в некоторых ситуациях может быть недоступно.</target>
        </trans-unit>
        <trans-unit id="8be4728a2375d8712deda132de2e0a083b597cad" translate="yes" xml:space="preserve">
          <source>To determine whether an item is not in a given collection, see &lt;a href=&quot;#Base.:%E2%88%89&quot;&gt;&lt;code&gt;:&amp;notin;&lt;/code&gt;&lt;/a&gt;. You may also negate the &lt;code&gt;in&lt;/code&gt; by doing &lt;code&gt;!(a in b)&lt;/code&gt; which is logically similar to &quot;not in&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95f5439d369c4ea0678d04f0efd9b2968e81782" translate="yes" xml:space="preserve">
          <source>To enable convenient vectorization of mathematical and other operations, Julia &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;provides the dot syntax&lt;/a&gt;&lt;code&gt;f.(args...)&lt;/code&gt;, e.g. &lt;code&gt;sin.(x)&lt;/code&gt; or &lt;code&gt;min.(x,y)&lt;/code&gt;, for elementwise operations over arrays or mixtures of arrays and scalars (a &lt;a href=&quot;#Broadcasting&quot;&gt;Broadcasting&lt;/a&gt; operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. &lt;code&gt;sin.(cos.(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb1602cac2df929c4186b626049a5c2b1947830" translate="yes" xml:space="preserve">
          <source>To enable convenient vectorization of mathematical and other operations, Julia &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;provides the dot syntax&lt;/a&gt;&lt;code&gt;f.(args...)&lt;/code&gt;, e.g. &lt;code&gt;sin.(x)&lt;/code&gt; or &lt;code&gt;min.(x,y)&lt;/code&gt;, for elementwise operations over arrays or mixtures of arrays and scalars (a &lt;a href=&quot;#Broadcasting-1&quot;&gt;Broadcasting&lt;/a&gt; operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. &lt;code&gt;sin.(cos.(x))&lt;/code&gt;.</source>
          <target state="translated">Чтобы обеспечить удобную векторизацию математических и других операций, Джулия &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;предоставляет точечный синтаксис &lt;/a&gt; &lt;code&gt;f.(args...)&lt;/code&gt; , например &lt;code&gt;sin.(x)&lt;/code&gt; или &lt;code&gt;min.(x,y)&lt;/code&gt; , для поэлементных операций над массивами или смесями массивов и скаляров. ( &lt;a href=&quot;#Broadcasting-1&quot;&gt;Радиовещательная&lt;/a&gt; операция); у них есть дополнительное преимущество в виде &amp;laquo;слияния&amp;raquo; в один цикл в сочетании с другими вызовами точек, например &lt;code&gt;sin.(cos.(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4881f7b56909ffe39aad882ec50ca3bf70065833" translate="yes" xml:space="preserve">
          <source>To end this short exposure to external packages, we can consider &lt;code&gt;MPI.jl&lt;/code&gt;, a Julia wrapper of the MPI protocol. As it would take too long to consider every inner function, it would be better to simply appreciate the approach used to implement the protocol.</source>
          <target state="translated">Чтобы закончить это краткое знакомство с внешними пакетами, мы можем рассмотреть &lt;code&gt;MPI.jl&lt;/code&gt; , оболочку Julia протокола MPI. Поскольку рассмотрение каждой внутренней функции заняло бы слишком много времени, было бы лучше просто оценить подход, используемый для реализации протокола.</target>
        </trans-unit>
        <trans-unit id="c43fc002027f4db455fa1bdf710dfb8409261bff" translate="yes" xml:space="preserve">
          <source>To ensure that the file can be opened at the given line, you may need to call &lt;code&gt;define_editor&lt;/code&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489d97da9ae4b28c1ee31bbdf2fe4066c4d9aee9" translate="yes" xml:space="preserve">
          <source>To evaluate expressions written in a source file &lt;code&gt;file.jl&lt;/code&gt;, write &lt;code&gt;include(&quot;file.jl&quot;)&lt;/code&gt;.</source>
          <target state="translated">Чтобы оценить выражения, записанные в исходном файле &lt;code&gt;file.jl&lt;/code&gt; , напишите &lt;code&gt;include(&quot;file.jl&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="962778343f824ab64f6e67f07132dd6412ec3b62" translate="yes" xml:space="preserve">
          <source>To exit the interactive session, type &lt;code&gt;CTRL-D&lt;/code&gt; (press the Control/&lt;code&gt;^&lt;/code&gt; key together with the &lt;code&gt;d&lt;/code&gt; key), or type &lt;code&gt;exit()&lt;/code&gt;. When run in interactive mode, &lt;code&gt;julia&lt;/code&gt; displays a banner and prompts the user for input. Once the user has entered a complete expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and hits enter, the interactive session evaluates the expression and shows its value. If an expression is entered into an interactive session with a trailing semicolon, its value is not shown. The variable &lt;code&gt;ans&lt;/code&gt; is bound to the value of the last evaluated expression whether it is shown or not. The &lt;code&gt;ans&lt;/code&gt; variable is only bound in interactive sessions, not when Julia code is run in other ways.</source>
          <target state="translated">Чтобы выйти из интерактивного сеанса, введите &lt;code&gt;CTRL-D&lt;/code&gt; (нажмите клавишу Control / &lt;code&gt;^&lt;/code&gt; вместе с клавишей &lt;code&gt;d&lt;/code&gt; ) или введите &lt;code&gt;exit()&lt;/code&gt; . При запуске в интерактивном режиме &lt;code&gt;julia&lt;/code&gt; отображает баннер и предлагает пользователю ввести данные. После того, как пользователь ввел полное выражение, такое как &lt;code&gt;1 + 2&lt;/code&gt; , и нажал клавишу ввода, интерактивный сеанс оценивает выражение и показывает его значение. Если выражение вводится в интерактивный сеанс с точкой с запятой в конце, его значение не отображается. Переменная &lt;code&gt;ans&lt;/code&gt; привязана к значению последнего оцененного выражения независимо от того, отображается оно или нет. В &lt;code&gt;ans&lt;/code&gt; переменная связывается только в интерактивных сеансах, а не когда код Julia запускается другими способами.</target>
        </trans-unit>
        <trans-unit id="efa7a75658fed01212612bb6890412e7df41c343" translate="yes" xml:space="preserve">
          <source>To exit the interactive session, type &lt;code&gt;^D&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;d&lt;/code&gt; key on a blank line &amp;ndash; or type &lt;code&gt;exit()&lt;/code&gt; followed by the return or enter key. The REPL greets you with a banner and a &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">Чтобы выйти из интерактивного сеанса, введите &lt;code&gt;^D&lt;/code&gt; - управляющую клавишу вместе с клавишей &lt;code&gt;d&lt;/code&gt; в пустой строке - или введите &lt;code&gt;exit()&lt;/code&gt; а затем нажмите клавишу возврата или ввода. REPL приветствует вас баннером и приглашением &lt;code&gt;julia&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="112540091595511d77b03fc13bb20dcaf3704da2" translate="yes" xml:space="preserve">
          <source>To extend &lt;code&gt;round&lt;/code&gt; to new numeric types, it is typically sufficient to define &lt;code&gt;Base.round(x::NewType, r::RoundingMode)&lt;/code&gt;.</source>
          <target state="translated">Чтобы расширить &lt;code&gt;round&lt;/code&gt; до новых числовых типов, обычно достаточно определить &lt;code&gt;Base.round(x::NewType, r::RoundingMode)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="195ad355d3d21e9f09e35cca5f9f687ede9688d3" translate="yes" xml:space="preserve">
          <source>To facilitate chaining, the operator associates from right to left.</source>
          <target state="translated">Чтобы облегчить приковывание,оператор связывается справа налево.</target>
        </trans-unit>
        <trans-unit id="0b86b2585faadb1e7b87fb8f83afa86601547bb7" translate="yes" xml:space="preserve">
          <source>To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a &lt;em&gt;method&lt;/em&gt;. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.</source>
          <target state="translated">Чтобы упростить использование множества различных реализаций одной и той же концепции, функции не нужно определять все сразу, их можно определять фрагментарно, предоставляя конкретное поведение для определенных комбинаций типов аргументов и количества. Определение одного возможного поведения функции называется &lt;em&gt;методом.&lt;/em&gt;, До сих пор мы представили только примеры функций, определенных с помощью одного метода, применимых ко всем типам аргументов. Однако подписи определений методов могут быть аннотированы, чтобы указать типы аргументов в дополнение к их количеству, и может быть предоставлено более одного определения метода. Когда функция применяется к определенному кортежу аргументов, применяется наиболее конкретный метод, применимый к этим аргументам. Таким образом, общее поведение функции представляет собой лоскутное одеяло из поведений ее различных определений методов. Если лоскутное одеяло хорошо спроектировано, даже несмотря на то, что реализации методов могут сильно отличаться, внешнее поведение функции будет выглядеть гладким и согласованным.</target>
        </trans-unit>
        <trans-unit id="685da3713fd32cec996f6d8bc31bd51d482869ca" translate="yes" xml:space="preserve">
          <source>To get your TTY size,</source>
          <target state="translated">Чтобы получить твой размер TTY,</target>
        </trans-unit>
        <trans-unit id="18e5dfa5bee5af4e19ea61c8f359c20a393fe69f" translate="yes" xml:space="preserve">
          <source>To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia's &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:</source>
          <target state="translated">Чтобы дать реальный пример того, как весь этот механизм параметрических типов может быть полезен, вот фактическое определение неизменяемого типа Julia &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; (за исключением того, что мы опускаем конструктор здесь для простоты), представляющее точное соотношение целых чисел:</target>
        </trans-unit>
        <trans-unit id="75c2b4412f89f47fcb218ff2c8fc9993a26854fc" translate="yes" xml:space="preserve">
          <source>To implement this specialization for &lt;code&gt;MyRNG&lt;/code&gt; and for a specification &lt;code&gt;s&lt;/code&gt;, producing elements of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)&lt;/code&gt;, where &lt;code&gt;SamplerS&lt;/code&gt; is the type of the sampler returned by &lt;code&gt;Sampler(MyRNG, s, Val(Inf))&lt;/code&gt;. Instead of &lt;code&gt;AbstractArray&lt;/code&gt;, it's possible to implement the functionality only for a subtype, e.g. &lt;code&gt;Array{S}&lt;/code&gt;. The non-mutating array method of &lt;code&gt;rand&lt;/code&gt; will automatically call this specialization internally.</source>
          <target state="translated">Чтобы реализовать эту специализацию для &lt;code&gt;MyRNG&lt;/code&gt; и для спецификации &lt;code&gt;s&lt;/code&gt; , производящей элементы типа &lt;code&gt;S&lt;/code&gt; , можно определить следующий метод: &lt;code&gt;rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)&lt;/code&gt; , где &lt;code&gt;SamplerS&lt;/code&gt; - это тип семплера, возвращаемого семплером &lt;code&gt;Sampler(MyRNG, s, Val(Inf))&lt;/code&gt; . Вместо &lt;code&gt;AbstractArray&lt;/code&gt; можно реализовать функциональность только для подтипа, например, &lt;code&gt;Array{S}&lt;/code&gt; . Неизменяющий метод массива &lt;code&gt;rand&lt;/code&gt; автоматически вызовет эту специализацию внутри.</target>
        </trans-unit>
        <trans-unit id="5abb5f441f651501d418ed7d715b551afc8ae682" translate="yes" xml:space="preserve">
          <source>To include a backtick character within literal text use three backticks rather than one to enclose the text.</source>
          <target state="translated">Для включения символа подписи в буквальный текст используйте три подписи,а не одну для вложения текста.</target>
        </trans-unit>
        <trans-unit id="57aafd915b8744c5b807fb8c566670246a4bbec8" translate="yes" xml:space="preserve">
          <source>To include a literal &lt;code&gt;$&lt;/code&gt; in a string literal, escape it with a backslash:</source>
          <target state="translated">Чтобы включить литерал &lt;code&gt;$&lt;/code&gt; в строковый литерал, экранируйте его обратной косой чертой:</target>
        </trans-unit>
        <trans-unit id="911d758b9209b3d7402bd8133b67ca7a1ddf60e0" translate="yes" xml:space="preserve">
          <source>To indicate that the output result is truncated, you may write &lt;code&gt;[...]&lt;/code&gt; at the line where checking should stop. This is useful to hide a stacktrace (which contains non-permanent references to lines of julia code) when the doctest shows that an exception is thrown, for example:</source>
          <target state="translated">Чтобы указать, что выходной результат усечен, вы можете написать &lt;code&gt;[...]&lt;/code&gt; в строке, где проверка должна остановиться. Это полезно, чтобы скрыть трассировку стека (которая содержит непостоянные ссылки на строки кода julia), когда doctest показывает, что выбрано исключение, например:</target>
        </trans-unit>
        <trans-unit id="bc826a295b20ebe4ca4b7027a22bd794fb5707c0" translate="yes" xml:space="preserve">
          <source>To insert &lt;code&gt;replacement&lt;/code&gt; before an index &lt;code&gt;n&lt;/code&gt; without removing any items, use &lt;code&gt;splice!(collection, n:n-1, replacement)&lt;/code&gt;.</source>
          <target state="translated">Чтобы вставить &lt;code&gt;replacement&lt;/code&gt; перед индексом &lt;code&gt;n&lt;/code&gt; без удаления каких-либо элементов, используйте &lt;code&gt;splice!(collection, n:n-1, replacement)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1254256d236772cc78d0a2e9b923db6bf919f9ea" translate="yes" xml:space="preserve">
          <source>To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:</source>
          <target state="translated">Чтобы все было просто,мы начинаем с 1D массива.Создание массива,содержащего Float64 элементов длиной 10,производится с помощью:</target>
        </trans-unit>
        <trans-unit id="8199f62d4f59aa3fc75b15e0a259ff3e40e0a51d" translate="yes" xml:space="preserve">
          <source>To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute &lt;code&gt;addprocs&lt;/code&gt; in its own task.</source>
          <target state="translated">Чтобы запустить воркеры без блокировки REPL или содержащей функцию при программном &lt;code&gt;addprocs&lt;/code&gt; , выполните addprocs в своей собственной задаче.</target>
        </trans-unit>
        <trans-unit id="00ab4bffe8af922f0b9025c505c1b0b45cd720f2" translate="yes" xml:space="preserve">
          <source>To list all the instances of an enum use &lt;code&gt;instances&lt;/code&gt;, e.g.</source>
          <target state="translated">Чтобы перечислить все экземпляры перечисления, используйте &lt;code&gt;instances&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="7c1bcc9adb11774306436860ba8fa8832de24b31" translate="yes" xml:space="preserve">
          <source>To load a module, two main keywords can be used: &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;. To understand their differences, consider the following example:</source>
          <target state="translated">Для загрузки модуля можно использовать два основных ключевых слова: &lt;code&gt;using&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; . Чтобы понять их различия, рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="1484daa3c86481c79c70bc5444871ebf78a284a7" translate="yes" xml:space="preserve">
          <source>To make common numeric formulae and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:</source>
          <target state="translated">Чтобы сделать общие числовые формулы и выражения более понятными,Джулия позволяет переменным непосредственно предшествовать численному литералу,подразумевающему умножение.Это делает написание многозначных выражений намного чище:</target>
        </trans-unit>
        <trans-unit id="e9809512202b8f4f9e1d3eed9dff9a39e7fbe9d3" translate="yes" xml:space="preserve">
          <source>To make it easier to write documentation, the parser treats the macro name &lt;code&gt;@doc&lt;/code&gt; specially: if a call to &lt;code&gt;@doc&lt;/code&gt; has one argument, but another expression appears after a single line break, then that additional expression is added as an argument to the macro. Therefore the following syntax is parsed as a 2-argument call to &lt;code&gt;@doc&lt;/code&gt;:</source>
          <target state="translated">Чтобы упростить написание документации, синтаксический анализатор специально обрабатывает имя макроса &lt;code&gt;@doc&lt;/code&gt; : если вызов &lt;code&gt;@doc&lt;/code&gt; имеет один аргумент, но другое выражение появляется после одного разрыва строки, то это дополнительное выражение добавляется в качестве аргумента макроса. , Поэтому следующий синтаксис анализируется как вызов &lt;code&gt;@doc&lt;/code&gt; с двумя аргументами :</target>
        </trans-unit>
        <trans-unit id="83af23997915ae15ff2f3b65db53b150559fdcfe" translate="yes" xml:space="preserve">
          <source>To make things easier, the symbol &lt;code&gt;:any&lt;/code&gt; can be passed to [&lt;code&gt;@spawnat&lt;/code&gt;], which picks where to do the operation for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f47e315ab3527a05dae0afbff5487e713054912" translate="yes" xml:space="preserve">
          <source>To measure allocation line-by-line, start Julia with the &lt;code&gt;--track-allocation=&amp;lt;setting&amp;gt;&lt;/code&gt; command-line option, for which you can choose &lt;code&gt;none&lt;/code&gt; (the default, do not measure allocation), &lt;code&gt;user&lt;/code&gt; (measure memory allocation everywhere except Julia's core code), or &lt;code&gt;all&lt;/code&gt; (measure memory allocation at each line of Julia code). Allocation gets measured for each line of compiled code. When you quit Julia, the cumulative results are written to text files with &lt;code&gt;.mem&lt;/code&gt; appended after the file name, residing in the same directory as the source file. Each line lists the total number of bytes allocated. The &lt;a href=&quot;https://github.com/JuliaCI/Coverage.jl&quot;&gt;&lt;code&gt;Coverage&lt;/code&gt; package&lt;/a&gt; contains some elementary analysis tools, for example to sort the lines in order of number of bytes allocated.</source>
          <target state="translated">Чтобы измерить выделение построчно, запустите Julia с &lt;code&gt;--track-allocation=&amp;lt;setting&amp;gt;&lt;/code&gt; командной строки --track-allocation = &amp;lt;setting&amp;gt; , для которого вы можете выбрать &lt;code&gt;none&lt;/code&gt; (по умолчанию, не измерять выделение), &lt;code&gt;user&lt;/code&gt; (измерять выделение памяти везде, кроме Основной код Джулии) или &lt;code&gt;all&lt;/code&gt; (измерьте выделение памяти в каждой строке кода Джулии). Распределение измеряется для каждой строки скомпилированного кода. Когда вы закрываете Julia, совокупные результаты записываются в текстовые файлы с добавлением &lt;code&gt;.mem&lt;/code&gt; после имени файла и находятся в том же каталоге, что и исходный файл. В каждой строке указано общее количество выделенных байтов. &lt;a href=&quot;https://github.com/JuliaCI/Coverage.jl&quot;&gt; &lt;code&gt;Coverage&lt;/code&gt; пакет&lt;/a&gt; содержит некоторые инструменты элементарного анализа, например, для сортировки строк по количеству выделенных байтов.</target>
        </trans-unit>
        <trans-unit id="55a59a811688ae0a09c9c081d6eacd92c8c0ce25" translate="yes" xml:space="preserve">
          <source>To orchestrate more advanced work distribution patterns, &lt;a href=&quot;../../stdlib/sockets/index#Base.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; can be used in conjunction with &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructors to explicitly link a set of channels with a set of producer/consumer tasks.</source>
          <target state="translated">Чтобы организовать более сложные шаблоны распределения работы, &lt;a href=&quot;../../stdlib/sockets/index#Base.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; можно использовать в сочетании с конструкторами &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; ,&lt;/a&gt; чтобы явно связать набор каналов с набором задач производителя / потребителя.</target>
        </trans-unit>
        <trans-unit id="88891fe439361664a726897679e596b4ddf0b648" translate="yes" xml:space="preserve">
          <source>To override these defaults, you can define a custom &lt;code&gt;BroadcastStyle&lt;/code&gt; for your object:</source>
          <target state="translated">Чтобы переопределить эти значения по умолчанию, вы можете определить собственный стиль &lt;code&gt;BroadcastStyle&lt;/code&gt; для своего объекта:</target>
        </trans-unit>
        <trans-unit id="8e77e7d4476c074003412309908eb0f580d2e357" translate="yes" xml:space="preserve">
          <source>To pass an array &lt;code&gt;A&lt;/code&gt; as a pointer of a different type &lt;em&gt;without&lt;/em&gt; converting the data beforehand (for example, to pass a &lt;code&gt;Float64&lt;/code&gt; array to a function that operates on uninterpreted bytes), you can declare the argument as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;.</source>
          <target state="translated">Чтобы передать массив &lt;code&gt;A&lt;/code&gt; в качестве указателя другого типа &lt;em&gt;без&lt;/em&gt; предварительного преобразования данных (например, чтобы передать массив &lt;code&gt;Float64&lt;/code&gt; в функцию, которая работает с неинтерпретируемыми байтами), вы можете объявить аргумент как &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37a6e640cde5e775ecaa007f5b2352c84dabd421" translate="yes" xml:space="preserve">
          <source>To provide extra type information to the compiler, which can then improve performance in some cases</source>
          <target state="translated">Предоставить компилятору дополнительную типовую информацию,которая в некоторых случаях может улучшить производительность</target>
        </trans-unit>
        <trans-unit id="0378c13c470b1c82f603ba161f8d44139e199b76" translate="yes" xml:space="preserve">
          <source>To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы случайным образом переставить произвольный вектор, см. &lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="41ee867278b2aedd0d53b55cf8896f331cca7dbe" translate="yes" xml:space="preserve">
          <source>To read every line from &lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;../../base/io-network/index#Base.eachline&quot;&gt;&lt;code&gt;eachline&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Для того, чтобы прочитать каждую строку из &lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; можно использовать &lt;a href=&quot;../../base/io-network/index#Base.eachline&quot;&gt; &lt;code&gt;eachline&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b518f1536e23e8203566d1b1cfa014affb065edc" translate="yes" xml:space="preserve">
          <source>To recap, two essential properties define immutability in Julia:</source>
          <target state="translated">Подводя итог,можно сказать,что два существенных свойства определяют неизменяемость в Юлии:</target>
        </trans-unit>
        <trans-unit id="3337fde1fe683c82cc86c991764b6058738e2732" translate="yes" xml:space="preserve">
          <source>To remove packages, use &lt;code&gt;rm&lt;/code&gt;:</source>
          <target state="translated">Чтобы удалить пакеты, используйте &lt;code&gt;rm&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="14bc0723b7cb80976b33a13b7846798f89f200c9" translate="yes" xml:space="preserve">
          <source>To repeat, in general this is not an issue. If the local node is also being used as a compute node, and the arguments used post the call, this behavior needs to be factored in and if required deep copies of arguments must be passed to the call invoked on the local node. Calls on remote nodes will always operate on copies of arguments.</source>
          <target state="translated">Повторюсь,в целом это не проблема.Если локальный узел также используется в качестве вычислительного узла,а аргументы,используемые после вызова,такое поведение должно быть учтено,и при необходимости глубокие копии аргументов должны быть переданы вызываемому на локальном узле вызову.Вызовы на удаленных узлах всегда будут работать с копиями аргументов.</target>
        </trans-unit>
        <trans-unit id="0f95a56d7e12d8a1364b795c70b8b074db4e5914" translate="yes" xml:space="preserve">
          <source>To represent missing data in the statistical sense (&lt;code&gt;NA&lt;/code&gt; in R or &lt;code&gt;NULL&lt;/code&gt; in SQL), use the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object. See the &lt;a href=&quot;../missing/index#missing&quot;&gt;&lt;code&gt;Missing Values&lt;/code&gt;&lt;/a&gt; section for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae4959b7ce22135d2a8a5e52c24ae41734ed81e" translate="yes" xml:space="preserve">
          <source>To represent missing data in the statistical sense (&lt;code&gt;NA&lt;/code&gt; in R or &lt;code&gt;NULL&lt;/code&gt; in SQL), use the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object. See the &lt;a href=&quot;../missing/index#missing-1&quot;&gt;&lt;code&gt;Missing Values&lt;/code&gt;&lt;/a&gt; section for more details.</source>
          <target state="translated">Чтобы представить отсутствующие данные в статистическом смысле ( &lt;code&gt;NA&lt;/code&gt; в R или &lt;code&gt;NULL&lt;/code&gt; в SQL), используйте &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; объект. Для получения более подробной информации см. Раздел &amp;laquo; &lt;a href=&quot;../missing/index#missing-1&quot;&gt; &lt;code&gt;Missing Values&lt;/code&gt; &lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7a42a57073f63eda82c8f34e187355b8a55592f7" translate="yes" xml:space="preserve">
          <source>To return a new permutation, use &lt;code&gt;v[p]&lt;/code&gt;. Note that this is generally faster than &lt;code&gt;permute!(v,p)&lt;/code&gt; for large vectors.</source>
          <target state="translated">Чтобы вернуть новую перестановку, используйте &lt;code&gt;v[p]&lt;/code&gt; . Обратите внимание, что это обычно быстрее, чем &lt;code&gt;permute!(v,p)&lt;/code&gt; для больших векторов.</target>
        </trans-unit>
        <trans-unit id="b43086127fab6b61eddd060c4ab1a5c67fe3f40b" translate="yes" xml:space="preserve">
          <source>To run code in a file non-interactively, you can give it as the first argument to the &lt;code&gt;julia&lt;/code&gt; command:</source>
          <target state="translated">Чтобы запустить код в файле в неинтерактивном режиме, вы можете передать его в качестве первого аргумента команде &lt;code&gt;julia&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="31db79e8dfaa63f030f5e043edf7eb3288ba9c8b" translate="yes" xml:space="preserve">
          <source>To see the &lt;code&gt;UniformScaling&lt;/code&gt; operator in action:</source>
          <target state="translated">Чтобы увидеть оператор &lt;code&gt;UniformScaling&lt;/code&gt; в действии:</target>
        </trans-unit>
        <trans-unit id="14eeb4620d461f92f19ad75b427c889e5f871fa2" translate="yes" xml:space="preserve">
          <source>To see the profiling results, there are several graphical browsers. One &quot;family&quot; of visualizers is based on &lt;a href=&quot;https://github.com/timholy/FlameGraphs.jl&quot;&gt;FlameGraphs.jl&lt;/a&gt;, with each family member providing a different user interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf8c3f0dc9d9a3a4b278d4d342f1e20d2ccbfc2" translate="yes" xml:space="preserve">
          <source>To see the profiling results, there is a &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;graphical browser&lt;/a&gt; available, but here we'll use the text-based display that comes with the standard library:</source>
          <target state="translated">Для просмотра результатов профилирования доступен &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;графический браузер&lt;/a&gt; , но здесь мы будем использовать текстовое отображение, которое поставляется со стандартной библиотекой:</target>
        </trans-unit>
        <trans-unit id="ec3664c20b57cfea56dfe265259865dc89ffd6ee" translate="yes" xml:space="preserve">
          <source>To see the various ways we can pass dimensions to these constructors, consider the following examples:</source>
          <target state="translated">Чтобы увидеть различные способы передачи размеров этим конструкторам,рассмотрим следующие примеры:</target>
        </trans-unit>
        <trans-unit id="b562caf38673e98867f8d24249d28785455823ef" translate="yes" xml:space="preserve">
          <source>To see the various ways we can pass dimensions to these functions, consider the following examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd84751a56be507d9887116a70caf40018058b32" translate="yes" xml:space="preserve">
          <source>To solve this problem, the language provides syntax for writing normal, non-generated alternative implementations of generated functions. Applied to the &lt;code&gt;sub2ind&lt;/code&gt; example above, it would look like this:</source>
          <target state="translated">Чтобы решить эту проблему, язык предоставляет синтаксис для написания обычных, не сгенерированных альтернативных реализаций сгенерированных функций. Применительно к &lt;code&gt;sub2ind&lt;/code&gt; выше примеру sub2ind это будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="54282ab58b68c2496b0103219b8718109152a291" translate="yes" xml:space="preserve">
          <source>To sort an array in-place, use the &quot;bang&quot; version of the sort function:</source>
          <target state="translated">Для сортировки массива на месте используйте &quot;bang&quot; версию функции сортировки:</target>
        </trans-unit>
        <trans-unit id="7211b367ac9e62dd165b6cef64e18a2d04d92c28" translate="yes" xml:space="preserve">
          <source>To sort slices of an array, refer to &lt;a href=&quot;#Base.sortslices&quot;&gt;&lt;code&gt;sortslices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы отсортировать срезы массива, обратитесь к &lt;a href=&quot;#Base.sortslices&quot;&gt; &lt;code&gt;sortslices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6eff1f59edaf0f06ebb9ad646cdc71f40b39d99" translate="yes" xml:space="preserve">
          <source>To test whether an array element is defined, use &lt;a href=&quot;../arrays/index#Base.isassigned&quot;&gt;&lt;code&gt;isassigned&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Чтобы проверить, определен ли элемент массива, используйте вместо этого &lt;a href=&quot;../arrays/index#Base.isassigned&quot;&gt; &lt;code&gt;isassigned&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01c8720e122ebab6d2066fc725c6565609e09aa5" translate="yes" xml:space="preserve">
          <source>To those familiar with the Unix socket API, the method names will feel familiar, though their usage is somewhat simpler than the raw Unix socket API. The first call to &lt;code&gt;listen&lt;/code&gt; will create a server waiting for incoming connections on the specified port (2000) in this case. The same function may also be used to create various other kinds of servers:</source>
          <target state="translated">Тем, кто знаком с API сокетов Unix, имена методов будут знакомы, хотя их использование несколько проще, чем исходный API сокетов Unix. Первый вызов &lt;code&gt;listen&lt;/code&gt; создаст сервер, ожидающий входящих соединений на указанном порту (2000) в этом случае. Эту же функцию можно использовать для создания различных других типов серверов:</target>
        </trans-unit>
        <trans-unit id="86225ac570f468a04ae4083e4730243b1b54f060" translate="yes" xml:space="preserve">
          <source>To turn debug logging on from the REPL, set &lt;code&gt;ENV[&quot;JULIA_DEBUG&quot;]&lt;/code&gt; to the name of the module of interest. Functions defined in the REPL belong to module &lt;code&gt;Main&lt;/code&gt;; logging for them can be enabled like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37782f88e79a30a638fe1c4b17869179913336be" translate="yes" xml:space="preserve">
          <source>To update all installed packages, use &lt;code&gt;update&lt;/code&gt; without any arguments:</source>
          <target state="translated">Чтобы обновить все установленные пакеты, используйте &lt;code&gt;update&lt;/code&gt; без аргументов:</target>
        </trans-unit>
        <trans-unit id="0f5d769d3a6a2a22d1c9a917d6ffd8d8e3ba2035" translate="yes" xml:space="preserve">
          <source>To use module functions, use &lt;code&gt;import Module&lt;/code&gt; to import the module, and &lt;code&gt;Module.fn(x)&lt;/code&gt; to use the functions.</source>
          <target state="translated">Чтобы использовать функции модуля, используйте &lt;code&gt;import Module&lt;/code&gt; для импорта модуля и &lt;code&gt;Module.fn(x)&lt;/code&gt; для использования функций.</target>
        </trans-unit>
        <trans-unit id="c9e2a6c247a0a520e69b509cc364e0a77e00dcc4" translate="yes" xml:space="preserve">
          <source>Together, these two methods generate an infinite recursion with &lt;code&gt;A&lt;/code&gt; constantly growing bigger.</source>
          <target state="translated">Вместе эти два метода генерируют бесконечную рекурсию, при которой &lt;code&gt;A&lt;/code&gt; постоянно увеличивается.</target>
        </trans-unit>
        <trans-unit id="0a527316e82cb18df4aebd0b111b71ab441d9fae" translate="yes" xml:space="preserve">
          <source>Toilet</source>
          <target state="translated">Toilet</target>
        </trans-unit>
        <trans-unit id="3068a31d1f4455b374321b9ea25711d164d193a2" translate="yes" xml:space="preserve">
          <source>Tokyo Tower</source>
          <target state="translated">Токийская башня</target>
        </trans-unit>
        <trans-unit id="85cd2366c323520d4f6ca54daa5ce7108263ec82" translate="yes" xml:space="preserve">
          <source>Tomato</source>
          <target state="translated">Tomato</target>
        </trans-unit>
        <trans-unit id="2c0af9c54fe52a8117bb6a8ffd7c31c20e12b7e9" translate="yes" xml:space="preserve">
          <source>Tongue</source>
          <target state="translated">Tongue</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a47d5ff7493944bba18ff7a622f259b12c79f21f" translate="yes" xml:space="preserve">
          <source>Tools for collecting and manipulating stack traces. Mainly used for building errors.</source>
          <target state="translated">Инструменты для сбора и манипуляции со следами стека.В основном используются для построения ошибок.</target>
        </trans-unit>
        <trans-unit id="3e83cb174ec130f0f93f810a0b44e22e6201ed95" translate="yes" xml:space="preserve">
          <source>Top Curly Bracket</source>
          <target state="translated">Кронштейн сверху</target>
        </trans-unit>
        <trans-unit id="f2d046811da3fdc34f49d7fc3a74c1883f787a1c" translate="yes" xml:space="preserve">
          <source>Top Hat</source>
          <target state="translated">Лучшая шляпа</target>
        </trans-unit>
        <trans-unit id="fc078810ae21519f9debbccf082738a4563290fe" translate="yes" xml:space="preserve">
          <source>Top Left Corner</source>
          <target state="translated">Левый верхний угол</target>
        </trans-unit>
        <trans-unit id="c1653a7564996eb5d9b98bcaeb8e7f6800ad78ed" translate="yes" xml:space="preserve">
          <source>Top Right Corner</source>
          <target state="translated">Правый верхний угол</target>
        </trans-unit>
        <trans-unit id="0db2fdee55ffa3d8617249d91bb7c7e0a1fd08cd" translate="yes" xml:space="preserve">
          <source>Top Square Bracket</source>
          <target state="translated">Кронштейн верхней площади</target>
        </trans-unit>
        <trans-unit id="feae3638873ff76a7d306f4a128884d7a27289e2" translate="yes" xml:space="preserve">
          <source>Top With Upwards Arrow Above</source>
          <target state="translated">Стрелка вверх со стрелкой вверх</target>
        </trans-unit>
        <trans-unit id="7d0d5998569f1576a0f2ba8a5349d65f84435b8c" translate="yes" xml:space="preserve">
          <source>Toplevel elements</source>
          <target state="translated">Элементы верхнего уровня</target>
        </trans-unit>
        <trans-unit id="38c33375ac13545f89d5e835135e4a9e0cee1eb3" translate="yes" xml:space="preserve">
          <source>Tractor</source>
          <target state="translated">Tractor</target>
        </trans-unit>
        <trans-unit id="77b5fefa8d9a6d18651c91b1b665b4e10f4d869e" translate="yes" xml:space="preserve">
          <source>Trade Mark Sign / Trademark</source>
          <target state="translated">Торговый знак/Торговая марка</target>
        </trans-unit>
        <trans-unit id="425d15442171bfb5ea100947c75ec0ba9c146e2c" translate="yes" xml:space="preserve">
          <source>Trailing whitespace is left unaltered.</source>
          <target state="translated">Следы белого пробела оставлены без изменений.</target>
        </trans-unit>
        <trans-unit id="3b278ea9e74a042719a58f33d9cbb403be99f4ca" translate="yes" xml:space="preserve">
          <source>Train</source>
          <target state="translated">Train</target>
        </trans-unit>
        <trans-unit id="d912f0acc1b118c025b1345d633ba920615f5571" translate="yes" xml:space="preserve">
          <source>Trait-based dispatch</source>
          <target state="translated">трэйт-ориентированная отправка</target>
        </trans-unit>
        <trans-unit id="d5838baf7a0cdd2c01f0b9aad26d4b577472aeb0" translate="yes" xml:space="preserve">
          <source>Tram</source>
          <target state="translated">Tram</target>
        </trans-unit>
        <trans-unit id="fd49baa6a07af107b147f6c54ee8d0e9b28fd8ce" translate="yes" xml:space="preserve">
          <source>Tram Car</source>
          <target state="translated">Трамвайный вагон</target>
        </trans-unit>
        <trans-unit id="742b78a52f1ec6f46ea0e8ce25d61611232abdad" translate="yes" xml:space="preserve">
          <source>Transform an array to its complex conjugate in-place.</source>
          <target state="translated">Трансформируйте массив в его сложный спрягающийся на месте.</target>
        </trans-unit>
        <trans-unit id="fe67b43b94628556bbf8a1979e5bb4a616c981e5" translate="yes" xml:space="preserve">
          <source>Transform collection &lt;code&gt;c&lt;/code&gt; by applying &lt;code&gt;f&lt;/code&gt; to each element using available workers and tasks.</source>
          <target state="translated">Преобразуйте коллекцию &lt;code&gt;c&lt;/code&gt; , применив &lt;code&gt;f&lt;/code&gt; к каждому элементу, используя доступные рабочие процессы и задачи.</target>
        </trans-unit>
        <trans-unit id="53273d7443cc45adf7bcb374bbb1ed108fc37052" translate="yes" xml:space="preserve">
          <source>Transform collection &lt;code&gt;c&lt;/code&gt; by applying &lt;code&gt;f&lt;/code&gt; to each element. For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">Преобразуйте коллекцию &lt;code&gt;c&lt;/code&gt; , применив &lt;code&gt;f&lt;/code&gt; к каждому элементу. Для нескольких аргументов коллекции примените &lt;code&gt;f&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="9c3a64c4f09f42065e08d17127a4cf1dbd8b1a80" translate="yes" xml:space="preserve">
          <source>Transform the eigenvectors &lt;code&gt;V&lt;/code&gt; of a matrix balanced using &lt;code&gt;gebal!&lt;/code&gt; to the unscaled/unpermuted eigenvectors of the original matrix. Modifies &lt;code&gt;V&lt;/code&gt; in-place. &lt;code&gt;side&lt;/code&gt; can be &lt;code&gt;L&lt;/code&gt; (left eigenvectors are transformed) or &lt;code&gt;R&lt;/code&gt; (right eigenvectors are transformed).</source>
          <target state="translated">Преобразуйте собственные векторы &lt;code&gt;V&lt;/code&gt; сбалансированной матрицы с помощью &lt;code&gt;gebal!&lt;/code&gt; в немасштабированные / неперестановочные собственные векторы исходной матрицы. Изменяет &lt;code&gt;V&lt;/code&gt; на месте. &lt;code&gt;side&lt;/code&gt; может быть &lt;code&gt;L&lt;/code&gt; (преобразуются левые собственные векторы) или &lt;code&gt;R&lt;/code&gt; (преобразуются правые собственные векторы).</target>
        </trans-unit>
        <trans-unit id="589e1ff32866be5e43daf649cc6902633fad511a" translate="yes" xml:space="preserve">
          <source>Transform the given dimensions of array &lt;code&gt;A&lt;/code&gt; using function &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; is called on each slice of &lt;code&gt;A&lt;/code&gt; of the form &lt;code&gt;A[...,:,...,:,...]&lt;/code&gt;. &lt;code&gt;dims&lt;/code&gt; is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;[1,2]&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is 4-dimensional, &lt;code&gt;f&lt;/code&gt; is called on &lt;code&gt;A[:,:,i,j]&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">Преобразуйте заданные размеры массива &lt;code&gt;A&lt;/code&gt; с помощью функции &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; вызывается на каждом срезе &lt;code&gt;A&lt;/code&gt; формы &lt;code&gt;A[...,:,...,:,...]&lt;/code&gt; . &lt;code&gt;dims&lt;/code&gt; - это целочисленный вектор, определяющий место двоеточия в этом выражении. Результаты объединяются по оставшимся измерениям. Например, если &lt;code&gt;dims&lt;/code&gt; является &lt;code&gt;[1,2]&lt;/code&gt; и представляет собой 4-мерное, &lt;code&gt;f&lt;/code&gt; называется на &lt;code&gt;A[:,:,i,j]&lt;/code&gt; для всех &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50cedbb47d15ee34a2d802bd7d89f363094704e1" translate="yes" xml:space="preserve">
          <source>Transforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.</source>
          <target state="translated">Преобразовывает индексируемый контейнер в словарь-просмотр тех же данных.Изменение области ключей базовых данных может сделать этот объект недействительным.</target>
        </trans-unit>
        <trans-unit id="66a40eda3c1161ed62ea96e24adba8e71d0ba78c" translate="yes" xml:space="preserve">
          <source>Transforms the upper trapezoidal matrix &lt;code&gt;A&lt;/code&gt; to upper triangular form in-place. Returns &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;tau&lt;/code&gt;, the scalar parameters for the elementary reflectors of the transformation.</source>
          <target state="translated">Преобразует верхнюю трапециевидную матрицу &lt;code&gt;A&lt;/code&gt; в верхнюю треугольную форму на месте. Возвращает &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;tau&lt;/code&gt; , скалярные параметры для элементарных отражателей преобразования.</target>
        </trans-unit>
        <trans-unit id="fc4c2841798d8e2d6fab4f58a0bd8b1dde31ae90" translate="yes" xml:space="preserve">
          <source>Transpose array &lt;code&gt;src&lt;/code&gt; and store the result in the preallocated array &lt;code&gt;dest&lt;/code&gt;, which should have a size corresponding to &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt;. No in-place transposition is supported and unexpected results will happen if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; have overlapping memory regions.</source>
          <target state="translated">Транспонируйте массив &lt;code&gt;src&lt;/code&gt; и сохраните результат в предварительно выделенном массиве &lt;code&gt;dest&lt;/code&gt; , который должен иметь размер, соответствующий &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt; . Перестановка на месте не поддерживается, и непредвиденные результаты будут возникать, если &lt;code&gt;src&lt;/code&gt; и &lt;code&gt;dest&lt;/code&gt; имеют перекрывающиеся области памяти.</target>
        </trans-unit>
        <trans-unit id="8f90329c80aba7f64de39c4d167572bb26f230b8" translate="yes" xml:space="preserve">
          <source>Transpose current line with line above</source>
          <target state="translated">Пропустите токовую линию с линией выше</target>
        </trans-unit>
        <trans-unit id="3687a79c6f0057ebfb38f5f6a37b95eeaa41c961" translate="yes" xml:space="preserve">
          <source>Transpose current line with line below</source>
          <target state="translated">Пропустите токовую линию со строкой ниже</target>
        </trans-unit>
        <trans-unit id="48be66c4f5c89d5b655d081c49787c6dc2120182" translate="yes" xml:space="preserve">
          <source>Transpose the characters about the cursor</source>
          <target state="translated">Переместить символы о курсоре</target>
        </trans-unit>
        <trans-unit id="fb403df4dd376fe10346f5998fcc78a8bb44e0b5" translate="yes" xml:space="preserve">
          <source>Transposition Operation</source>
          <target state="translated">Транспозиция Эксплуатация</target>
        </trans-unit>
        <trans-unit id="e59e9a12661e6b012b7d657cf12b62dc5b571082" translate="yes" xml:space="preserve">
          <source>Transposition operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfd8b1ba3d62f7ad1ee66b9f0fb873cb6da8327" translate="yes" xml:space="preserve">
          <source>Transversal Intersection</source>
          <target state="translated">Поперечное пересечение</target>
        </trans-unit>
        <trans-unit id="7cde555988492eea4432149156cbe06f0b076e67" translate="yes" xml:space="preserve">
          <source>Traverse the entries in &lt;code&gt;tree&lt;/code&gt; and its subtrees in post or pre order. Preorder means beginning at the root and then traversing the leftmost subtree (and recursively on down through that subtree's leftmost subtrees) and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree, traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and finally visiting the tree root last of all.</source>
          <target state="translated">Просматривайте записи в &lt;code&gt;tree&lt;/code&gt; и его поддеревьях в порядке публикации или предварительного заказа. Предварительный порядок означает начало с корня, затем обход самого левого поддерева (и рекурсивно вниз через самые левые поддеревья этого поддерева) и перемещение вправо по поддеревьям. Поступорядочение означает начало в самом низу самого левого поддерева, прохождение по нему вверх, затем прохождение следующего правого поддерева (снова начиная с нижней части) и, наконец, посещение корня дерева последним.</target>
        </trans-unit>
        <trans-unit id="791e68e780c0f86ed7620277a18ccb7b2f0900e4" translate="yes" xml:space="preserve">
          <source>Treat Subnormal Numbers as Zeros</source>
          <target state="translated">Субнормальные числа считать нулями.</target>
        </trans-unit>
        <trans-unit id="c4fadb4fd45f206006c2e243d850b8c3f0ed9575" translate="yes" xml:space="preserve">
          <source>Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as &lt;code&gt;x-y == 0&lt;/code&gt; implies &lt;code&gt;x == y&lt;/code&gt;:</source>
          <target state="translated">К субнормальным значениям как к нулям следует относиться с осторожностью, поскольку это нарушает некоторые идентичности, например &lt;code&gt;x-y == 0&lt;/code&gt; подразумевает &lt;code&gt;x == y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9c9ca807bb2ab4244216bbe667dca9d54adffd7f" translate="yes" xml:space="preserve">
          <source>Triangle Referencing</source>
          <target state="translated">Треугольник Ссылка на треугольник</target>
        </trans-unit>
        <trans-unit id="2bb3f66057a0bac3d2fe069941cb9f2a05c4b5bc" translate="yes" xml:space="preserve">
          <source>Triangle With Dot Above</source>
          <target state="translated">Треугольник с точкой выше</target>
        </trans-unit>
        <trans-unit id="b7c13ac265c6665e49bdb94db0d8083d9f778bcb" translate="yes" xml:space="preserve">
          <source>Triangle With Underbar</source>
          <target state="translated">Треугольник с подбалкой</target>
        </trans-unit>
        <trans-unit id="160c26397adf4988e0b7455c4f857604b9fb8d0d" translate="yes" xml:space="preserve">
          <source>Triangle referencing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc6199243314b8c0c53ed674ea486fd217ade89" translate="yes" xml:space="preserve">
          <source>Triangular</source>
          <target state="translated">Triangular</target>
        </trans-unit>
        <trans-unit id="6d90e2fedf2c3a69bc762b826e673df767a24a84" translate="yes" xml:space="preserve">
          <source>Triangular Flag On Post</source>
          <target state="translated">Треугольный флаг на посту</target>
        </trans-unit>
        <trans-unit id="35a961685d74e87fb2defd8c3eaff910ff2eb0eb" translate="yes" xml:space="preserve">
          <source>Triangular Ruler</source>
          <target state="translated">Треугольный регулятор</target>
        </trans-unit>
        <trans-unit id="9e336984f920581ee4ce0df13dfa14b0e2ae3a42" translate="yes" xml:space="preserve">
          <source>Tricky? Perhaps. What is an innocent &lt;code&gt;Dates&lt;/code&gt; user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that's pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the &quot;joys&quot; of dealing with daylight savings, leap seconds, etc.).</source>
          <target state="translated">Хитрый? Может быть. Что делать невиновному пользователю &lt;code&gt;Dates&lt;/code&gt; ? Суть в том, чтобы знать, что явное форсирование определенной ассоциативности при работе с месяцами может привести к некоторым неожиданным результатам, но в противном случае все должно работать, как ожидалось. К счастью, это в значительной степени степень нечетных случаев в арифметике даты и периода при работе со временем в UT (избегая &amp;laquo;радостей&amp;raquo; работы с летним днем, дополнительными секундами и т. Д.).</target>
        </trans-unit>
        <trans-unit id="98200808753c64066fca0c2f60e6540c2f9304ca" translate="yes" xml:space="preserve">
          <source>Tricolon</source>
          <target state="translated">Tricolon</target>
        </trans-unit>
        <trans-unit id="4b05482034189f500d70df4463d2dbc3fd792fa1" translate="yes" xml:space="preserve">
          <source>Trident Emblem</source>
          <target state="translated">Трезубец эмблема</target>
        </trans-unit>
        <trans-unit id="0f0fe0b102122af9b3e1aa3066e10188316b7e80" translate="yes" xml:space="preserve">
          <source>Tridiagonal</source>
          <target state="translated">Tridiagonal</target>
        </trans-unit>
        <trans-unit id="4f23fdcbf978b1f174f1f0150b4e839f69d24afc" translate="yes" xml:space="preserve">
          <source>Tridiagonal matrix</source>
          <target state="translated">тридиагональная матрица</target>
        </trans-unit>
        <trans-unit id="e789c19841ebe0317ebcd28434e36e772dc7a83d" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions</source>
          <target state="translated">Тригонометрические и гиперболические функции</target>
        </trans-unit>
        <trans-unit id="f20cc8cf4fba3cc7d93846dfbed75994f6215f36" translate="yes" xml:space="preserve">
          <source>Triple Colon Operator</source>
          <target state="translated">оператор с тройной колонной</target>
        </trans-unit>
        <trans-unit id="4a03809cfb647189e67fad647f769643426eb524" translate="yes" xml:space="preserve">
          <source>Triple Integral</source>
          <target state="translated">тройное целое</target>
        </trans-unit>
        <trans-unit id="4c843fa3d064b1637b9a934e39f0951786b86357" translate="yes" xml:space="preserve">
          <source>Triple Nested Greater-Than</source>
          <target state="translated">Тройное гнездо больше тана</target>
        </trans-unit>
        <trans-unit id="bc48dc85d97fd346bea02435f83eacf69e6b6aa3" translate="yes" xml:space="preserve">
          <source>Triple Nested Less-Than</source>
          <target state="translated">Тройное гнездо меньше</target>
        </trans-unit>
        <trans-unit id="10e187cab7bb4c297ed3b8b0dc8a7e7c1b437b6e" translate="yes" xml:space="preserve">
          <source>Triple Plus</source>
          <target state="translated">тройной плюс</target>
        </trans-unit>
        <trans-unit id="e4107a129a477eb4305d09a04ff620342e6d5a39" translate="yes" xml:space="preserve">
          <source>Triple Prime</source>
          <target state="translated">Тройная премьера</target>
        </trans-unit>
        <trans-unit id="f91ac0ecf21472d6ccd15f4ba9af28d149dc8f7d" translate="yes" xml:space="preserve">
          <source>Triple Tilde</source>
          <target state="translated">тройная тильда</target>
        </trans-unit>
        <trans-unit id="9aad96f795695616a77fd0b86856873ada33c081" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Binary Relation</source>
          <target state="translated">Тройная вертикальная барная двоичная связь</target>
        </trans-unit>
        <trans-unit id="5aa94f488e3751771f1642dc28467e3117351ee0" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Delimiter</source>
          <target state="translated">Тройной вертикальный разделитель баров</target>
        </trans-unit>
        <trans-unit id="3be66a3b16b2414eeb14c7e1589bb01ace3385b3" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Right Turnstile</source>
          <target state="translated">Тройной вертикальный балочный правый турникет</target>
        </trans-unit>
        <trans-unit id="15fb453f3bd4fb6b3dc4c8fc111b98e0cb966ca8" translate="yes" xml:space="preserve">
          <source>Triple-Quoted String Literals</source>
          <target state="translated">Тройные струнные литералы</target>
        </trans-unit>
        <trans-unit id="2920ab57511d06b8770e0cbbb95a3cbbf0a249d1" translate="yes" xml:space="preserve">
          <source>Triple-quoted regex strings, of the form &lt;code&gt;r&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt;, are also supported (and may be convenient for regular expressions containing quotation marks or newlines).</source>
          <target state="translated">Также поддерживаются строки регулярных выражений в тройных кавычках формы &lt;code&gt;r&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt; (и могут быть удобны для регулярных выражений, содержащих кавычки или символы новой строки).</target>
        </trans-unit>
        <trans-unit id="b54e3c85f204b81397a7c84b48965d41b5754fba" translate="yes" xml:space="preserve">
          <source>Triple-quoted string literals can contain &lt;code&gt;&quot;&lt;/code&gt; characters without escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01aa9c142c3bf18faaea1950666658f968f3131c" translate="yes" xml:space="preserve">
          <source>Triple-quoted string literals can contain &lt;code&gt;&quot;&lt;/code&gt; symbols without escaping.</source>
          <target state="translated">Triple-цитируемые строковые литералы могут содержать &lt;code&gt;&quot;&lt;/code&gt; символы без побега.</target>
        </trans-unit>
        <trans-unit id="957886bc006fb19c37ca4b45b5f2e8ebf53008e7" translate="yes" xml:space="preserve">
          <source>Trolleybus</source>
          <target state="translated">Trolleybus</target>
        </trans-unit>
        <trans-unit id="1075c086b703df3b01e8d6013dae65668d6d865d" translate="yes" xml:space="preserve">
          <source>Trophy</source>
          <target state="translated">Trophy</target>
        </trans-unit>
        <trans-unit id="f27ecef221139e5fd432ae45c48c9d80fb89e7df" translate="yes" xml:space="preserve">
          <source>Tropical Drink</source>
          <target state="translated">тропический напиток</target>
        </trans-unit>
        <trans-unit id="2983c072197329832df76d88b69aef1b73478110" translate="yes" xml:space="preserve">
          <source>Tropical Fish</source>
          <target state="translated">тропическая рыба</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="63bc99348fac41157f28181105c7b5ea6bb7afd2" translate="yes" xml:space="preserve">
          <source>True if the code is from C.</source>
          <target state="translated">Верно,если код от C.</target>
        </trans-unit>
        <trans-unit id="ec75cc300e047be39d0a9fb14737dd15be5276d7" translate="yes" xml:space="preserve">
          <source>True if the code is from an inlined frame.</source>
          <target state="translated">Правда,если код получен из инкассационного кадра.</target>
        </trans-unit>
        <trans-unit id="66c3284825be09870b41244ed701aea7191cb82e" translate="yes" xml:space="preserve">
          <source>Trumpet</source>
          <target state="translated">Trumpet</target>
        </trans-unit>
        <trans-unit id="4b46414e1c27f9b8937db64044b2e81c89c3c481" translate="yes" xml:space="preserve">
          <source>Truncates the value of &lt;code&gt;dt&lt;/code&gt; according to the provided &lt;code&gt;Period&lt;/code&gt; type.</source>
          <target state="translated">Усекает значение &lt;code&gt;dt&lt;/code&gt; в соответствии с предоставленным типом &lt;code&gt;Period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ab5d704e1ea0cac99a119ecd2665b6a98ac90ba" translate="yes" xml:space="preserve">
          <source>Try to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.</source>
          <target state="translated">Постарайтесь не использовать слишком много уровней заголовков в одном документе.Тяжело вложенный документ может указывать на необходимость его реструктуризации или разделения на несколько страниц,охватывающих отдельные темы.</target>
        </trans-unit>
        <trans-unit id="a5782807a1634c799255f28c6609330ea2948623" translate="yes" xml:space="preserve">
          <source>Trying to construct a &lt;a href=&quot;../../base/numbers/index#Base.NaN&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; rational value, however, is invalid:</source>
          <target state="translated">Однако попытка построить рациональное значение &lt;a href=&quot;../../base/numbers/index#Base.NaN&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; недопустима:</target>
        </trans-unit>
        <trans-unit id="0a45f936f6d904e3db7eb90ebb14b6146ce40542" translate="yes" xml:space="preserve">
          <source>Tulip</source>
          <target state="translated">Tulip</target>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="translated">Типы кортежей</target>
        </trans-unit>
        <trans-unit id="845b33803adcb6fd7b83aa05a48e2e532cdedbb3" translate="yes" xml:space="preserve">
          <source>Tuple and NTuple arguments</source>
          <target state="translated">Аргументы Tuple и NTuple</target>
        </trans-unit>
        <trans-unit id="1d7518da5e57e98af113ed9ca0544eae23ceace9" translate="yes" xml:space="preserve">
          <source>Tuple types are &lt;em&gt;covariant&lt;/em&gt; in their parameters: &lt;code&gt;Tuple{Int}&lt;/code&gt; is a subtype of &lt;code&gt;Tuple{Any}&lt;/code&gt;. Therefore &lt;code&gt;Tuple{Any}&lt;/code&gt; is considered an abstract type, and tuple types are only concrete if their parameters are.</source>
          <target state="translated">Типы кортежей &lt;em&gt;ковариантны&lt;/em&gt; по своим параметрам: &lt;code&gt;Tuple{Int}&lt;/code&gt; является подтипом &lt;code&gt;Tuple{Any}&lt;/code&gt; . Поэтому &lt;code&gt;Tuple{Any}&lt;/code&gt; считается абстрактным типом, а типы кортежей являются конкретными только в том случае, если таковыми являются их параметры.</target>
        </trans-unit>
        <trans-unit id="f158b42c8df38fba7edc2516cf30067a6f3c3fd2" translate="yes" xml:space="preserve">
          <source>Tuple types are covariant in their parameters: &lt;code&gt;Tuple{Int}&lt;/code&gt; is a subtype of &lt;code&gt;Tuple{Any}&lt;/code&gt;. Therefore &lt;code&gt;Tuple{Any}&lt;/code&gt; is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.</source>
          <target state="translated">Типы кортежей ковариантны по своим параметрам: &lt;code&gt;Tuple{Int}&lt;/code&gt; является подтипом &lt;code&gt;Tuple{Any}&lt;/code&gt; . Поэтому &lt;code&gt;Tuple{Any}&lt;/code&gt; считается абстрактным типом, а типы кортежей являются конкретными только в том случае, если таковыми являются их параметры. Кортежи не имеют имен полей; Доступ к полям осуществляется только по индексу.</target>
        </trans-unit>
        <trans-unit id="c3dd2cf49e1c762ee0d977a8827179a18862e514" translate="yes" xml:space="preserve">
          <source>Tuple types may have any number of parameters.</source>
          <target state="translated">Типы кортежей могут иметь любое количество параметров.</target>
        </trans-unit>
        <trans-unit id="436cabb920e9afcb6c39fb96f4c8e856c77ac70f" translate="yes" xml:space="preserve">
          <source>Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:</source>
          <target state="translated">Значения кортежей записываются круглыми скобками и запятыми.При построении кортежа по требованию генерируется соответствующий тип кортежа:</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="2b853ab04d00cf57d1ce546398e1b79f3f051f32" translate="yes" xml:space="preserve">
          <source>Tuples are an abstraction of the arguments of a function &amp;ndash; without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:</source>
          <target state="translated">Кортежи - это абстракция аргументов функции без самой функции. Важнейшими аспектами аргументов функции являются их порядок и их типы. Таким образом, кортежный тип похож на параметризованный неизменяемый тип, где каждый параметр является типом одного поля. Например, двухэлементный кортеж похож на следующий неизменяемый тип:</target>
        </trans-unit>
        <trans-unit id="38f517ecb99a7d22ca712e684653b53d2da013e1" translate="yes" xml:space="preserve">
          <source>Tuples are an abstraction of the arguments of a function &amp;ndash; without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.</source>
          <target state="translated">Кортежи - это абстракция аргументов функции без самой функции. Важнейшими аспектами аргументов функции являются их порядок и их типы. Таким образом, кортежный тип похож на параметризованный неизменяемый тип, где каждый параметр является типом одного поля. Типы кортежей могут иметь любое количество параметров.</target>
        </trans-unit>
        <trans-unit id="10a000d9419f2a05d7ec82307740cfc2f368764c" translate="yes" xml:space="preserve">
          <source>Tuples do not have field names; fields are only accessed by index.</source>
          <target state="translated">Кортежи не имеют имен полей;доступ к полям осуществляется только по индексу.</target>
        </trans-unit>
        <trans-unit id="d475d0ed8dbda37de3962c553ee1cf6bad5acd73" translate="yes" xml:space="preserve">
          <source>Turned Ampersand</source>
          <target state="translated">Перевёрнутый амперсанд</target>
        </trans-unit>
        <trans-unit id="44e7aa783e6e21961447d92fabcb381a889f661a" translate="yes" xml:space="preserve">
          <source>Turned Angle</source>
          <target state="translated">Поворотный угол</target>
        </trans-unit>
        <trans-unit id="8b3464100be6c8cfd6483bbda164ded5b9f3dda5" translate="yes" xml:space="preserve">
          <source>Turned Capital F / Turned F</source>
          <target state="translated">Перевёрнутый капитал F/Перевёрнутый F</target>
        </trans-unit>
        <trans-unit id="c0d9680d54a56600626a6e13ab971c5a7946bf28" translate="yes" xml:space="preserve">
          <source>Turned Greek Small Letter Iota</source>
          <target state="translated">Перевёрнутая греческая Маленькая Письмо Иота</target>
        </trans-unit>
        <trans-unit id="a0d677f4e8b54c3e427ed668e6e7e5fb71640f1b" translate="yes" xml:space="preserve">
          <source>Turned Not Sign</source>
          <target state="translated">Перевёрнутый без знака</target>
        </trans-unit>
        <trans-unit id="65de22879a9e05c48035f0650a2aba5faf638568" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital G</source>
          <target state="translated">Перевёрнутый Сан-Сериф Капитал G</target>
        </trans-unit>
        <trans-unit id="a0b3c92d57fcbd9e284b1f1bc355f9c62a47e627" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital L</source>
          <target state="translated">Перевёрнутый Сан-Сериф Капитал L</target>
        </trans-unit>
        <trans-unit id="c98f94d5a7cb8446bd8b48114b19424f10405e51" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital Y</source>
          <target state="translated">Перевёрнутый Сан-Сериф Капитал Y</target>
        </trans-unit>
        <trans-unit id="7039da614328dbb74b73091f274ceec249a388f5" translate="yes" xml:space="preserve">
          <source>Turtle</source>
          <target state="translated">Turtle</target>
        </trans-unit>
        <trans-unit id="eaef77aca961ecc2cacd2ed540321a53b86f2c60" translate="yes" xml:space="preserve">
          <source>Tweaks</source>
          <target state="translated">Tweaks</target>
        </trans-unit>
        <trans-unit id="2c47ac9f8b779ed312982f36375e817cfd461a0d" translate="yes" xml:space="preserve">
          <source>Twisted Rightwards Arrows</source>
          <target state="translated">Стрелки вправо-вправо витые</target>
        </trans-unit>
        <trans-unit id="850aa4e89f36cf847f4d161726e5625623c23118" translate="yes" xml:space="preserve">
          <source>Two Consecutive Equals Signs</source>
          <target state="translated">Два последовательных знака равенства</target>
        </trans-unit>
        <trans-unit id="d41d4a075c8d174ebb10603c708c639e709f0109" translate="yes" xml:space="preserve">
          <source>Two Hearts</source>
          <target state="translated">Два сердца</target>
        </trans-unit>
        <trans-unit id="7a3530233c722f61a2c0d529c3b9d5062536abc0" translate="yes" xml:space="preserve">
          <source>Two Intersecting Logical And</source>
          <target state="translated">Два Пересекающихся Логических И</target>
        </trans-unit>
        <trans-unit id="55266f0a48713c6bc0f773b39d521dc70499465f" translate="yes" xml:space="preserve">
          <source>Two Intersecting Logical Or</source>
          <target state="translated">Два пересекающихся Логических Или</target>
        </trans-unit>
        <trans-unit id="66b2f43372d062ff8e38e2e1c1860db370e78e02" translate="yes" xml:space="preserve">
          <source>Two Logical And Operator</source>
          <target state="translated">Два логических и оператора</target>
        </trans-unit>
        <trans-unit id="12c9295bb902c2fb14793da783a921da3fd8054a" translate="yes" xml:space="preserve">
          <source>Two Logical Or Operator</source>
          <target state="translated">Два логических или оператора</target>
        </trans-unit>
        <trans-unit id="fd1eb7f02c8f49a97ad1aaa21bd916045738c759" translate="yes" xml:space="preserve">
          <source>Two Men Holding Hands</source>
          <target state="translated">Двое мужчин держатся за руки</target>
        </trans-unit>
        <trans-unit id="ea9b8150660b031f305860c61406c3d6161a7b06" translate="yes" xml:space="preserve">
          <source>Two Women Holding Hands</source>
          <target state="translated">Две женщины держатся за руки</target>
        </trans-unit>
        <trans-unit id="14a1f210884121dab1e048ee8ff43a770883c685" translate="yes" xml:space="preserve">
          <source>Two dimensional &lt;a href=&quot;#Base.StridedArray&quot;&gt;&lt;code&gt;StridedArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Двумерный &lt;a href=&quot;#Base.StridedArray&quot;&gt; &lt;code&gt;StridedArray&lt;/code&gt; &lt;/a&gt; с элементами типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8f09c4cf86a87bcead55bcb46b75740b635c442" translate="yes" xml:space="preserve">
          <source>Two other handy string functions are &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Две другие удобные строковые функции - это &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/strings/index#Base.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="19a22abb2af2528acd0706b6d05a99511e3cad19" translate="yes" xml:space="preserve">
          <source>Two typical uses of &lt;code&gt;__init__&lt;/code&gt; are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries. For example, suppose that we are calling a C library &lt;code&gt;libfoo&lt;/code&gt; that requires us to call a &lt;code&gt;foo_init()&lt;/code&gt; initialization function at runtime. Suppose that we also want to define a global constant &lt;code&gt;foo_data_ptr&lt;/code&gt; that holds the return value of a &lt;code&gt;void *foo_data()&lt;/code&gt; function defined by &lt;code&gt;libfoo&lt;/code&gt; &amp;ndash; this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run. You could accomplish this by defining the following &lt;code&gt;__init__&lt;/code&gt; function in your module:</source>
          <target state="translated">Два типичных использования &lt;code&gt;__init__&lt;/code&gt; - это вызов функций инициализации среды выполнения внешних библиотек C и инициализация глобальных констант, которые включают указатели, возвращаемые внешними библиотеками. Например, предположим, что мы вызываем библиотеку C &lt;code&gt;libfoo&lt;/code&gt; , которая требует от нас вызова функции инициализации &lt;code&gt;foo_init()&lt;/code&gt; во время выполнения. Предположим, что мы также хотим определить глобальную константу &lt;code&gt;foo_data_ptr&lt;/code&gt; , которая содержит возвращаемое значение функции &lt;code&gt;void *foo_data()&lt;/code&gt; определенной &lt;code&gt;libfoo&lt;/code&gt; - эта константа должна быть инициализирована во время выполнения (а не во время компиляции), потому что адрес указателя изменится от запуска к запустить. Вы можете добиться этого, определив следующий &lt;code&gt;__init__&lt;/code&gt; функция в вашем модуле:</target>
        </trans-unit>
        <trans-unit id="34e8818ff6722512c7d2d5bdcca9e688c6d5dbba" translate="yes" xml:space="preserve">
          <source>Two-dimensional &lt;a href=&quot;#Core.DenseArray&quot;&gt;&lt;code&gt;DenseArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;. Alias for &lt;code&gt;DenseArray{T,2}&lt;/code&gt;.</source>
          <target state="translated">Двумерная &lt;a href=&quot;#Core.DenseArray&quot;&gt; &lt;code&gt;DenseArray&lt;/code&gt; &lt;/a&gt; с элементами типа &lt;code&gt;T&lt;/code&gt; . Псевдоним для &lt;code&gt;DenseArray{T,2}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="520563ee1cb32d20148c405d4ac444576ac80929" translate="yes" xml:space="preserve">
          <source>Two-dimensional dense array with elements of type &lt;code&gt;T&lt;/code&gt;, often used to represent a mathematical matrix. Alias for &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array{T,2}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Двумерный плотный массив с элементами типа &lt;code&gt;T&lt;/code&gt; , часто используемый для представления математической матрицы. Псевдоним для &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array{T,2}&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="699c321e34c4b272cb0e92dbf84b36d8841e2209" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;T1&lt;/code&gt; defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next. On the other hand, type &lt;code&gt;T2&lt;/code&gt; defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type. Note that &lt;code&gt;T2&lt;/code&gt; is an abstract type, e.g., &lt;code&gt;Array{Array{Int,1},1} &amp;lt;: T2&lt;/code&gt;, whereas &lt;code&gt;T1&lt;/code&gt; is a concrete type. As a consequence, &lt;code&gt;T1&lt;/code&gt; can be constructed with a zero-argument constructor &lt;code&gt;a=T1()&lt;/code&gt; but &lt;code&gt;T2&lt;/code&gt; cannot.</source>
          <target state="translated">Тип &lt;code&gt;T1&lt;/code&gt; определяет одномерный массив одномерных массивов; каждый из внутренних массивов состоит из объектов одного типа, но этот тип может варьироваться от одного внутреннего массива к другому. С другой стороны, тип &lt;code&gt;T2&lt;/code&gt; определяет одномерный массив одномерных массивов, все внутренние массивы которого должны иметь один и тот же тип. Обратите внимание, что &lt;code&gt;T2&lt;/code&gt; - абстрактный тип, например, &lt;code&gt;Array{Array{Int,1},1} &amp;lt;: T2&lt;/code&gt; , тогда как &lt;code&gt;T1&lt;/code&gt; - конкретный тип. Как следствие, &lt;code&gt;T1&lt;/code&gt; может быть построен с помощью конструктора с нулевым аргументом &lt;code&gt;a=T1()&lt;/code&gt; но &lt;code&gt;T2&lt;/code&gt; не может.</target>
        </trans-unit>
        <trans-unit id="9336947ff1fcdc631e771b9b86afd198836eb20c" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;VecElement{T}&lt;/code&gt; is intended for building libraries of SIMD operations. Practical use of it requires using &lt;code&gt;llvmcall&lt;/code&gt;. The type is defined as:</source>
          <target state="translated">Тип &lt;code&gt;VecElement{T}&lt;/code&gt; предназначен для построения библиотек операций SIMD. Практическое использование требует использования &lt;code&gt;llvmcall&lt;/code&gt; . Тип определяется как:</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">псевдонимы типа</target>
        </trans-unit>
        <trans-unit id="1242b5a7bcfba49f41a8936f551747918a7040c3" translate="yes" xml:space="preserve">
          <source>Type Correspondences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fa287d5611bc4f8123b770126f1a09136ca477" translate="yes" xml:space="preserve">
          <source>Type Correspondences:</source>
          <target state="translated">Введите Корреспонденцию:</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="translated">Типовые декларации</target>
        </trans-unit>
        <trans-unit id="c50d144660c5c67e814a21e78a048bb4d4c2ec30" translate="yes" xml:space="preserve">
          <source>Type Parameters</source>
          <target state="translated">Тип Параметры</target>
        </trans-unit>
        <trans-unit id="3984fbe729382dd2cebe0b8952bf750232d09730" translate="yes" xml:space="preserve">
          <source>Type Unions</source>
          <target state="translated">Типовые союзы</target>
        </trans-unit>
        <trans-unit id="7ab532ff895c9c41984a98ec53a2137840835c70" translate="yes" xml:space="preserve">
          <source>Type annotation will not enhance (and can actually hinder) performance if the type is constructed at run-time. This is because the compiler cannot use the annotation to specialize the subsequent code, and the type-check itself takes time. For example, in the code:</source>
          <target state="translated">Аннотация типа не улучшит (и фактически может помешать)производительность,если тип построен во время выполнения.Это связано с тем,что компилятор не может использовать аннотацию для специализации последующего кода,а сама проверка типа требует времени.Например,в коде:</target>
        </trans-unit>
        <trans-unit id="315f6367d2e7e25cde681d099ca28e1c2c774de1" translate="yes" xml:space="preserve">
          <source>Type declarations</source>
          <target state="translated">Типовые заявления</target>
        </trans-unit>
        <trans-unit id="d823421474b9921ea903ae47a40988974efcaac1" translate="yes" xml:space="preserve">
          <source>Type parameters are introduced immediately after the type name, surrounded by curly braces:</source>
          <target state="translated">Параметры типа вводятся сразу после названия типа,окруженного фигурными скобками:</target>
        </trans-unit>
        <trans-unit id="7b5326008bc0cc9fa7f08d020855f5918767c17c" translate="yes" xml:space="preserve">
          <source>Type parameters for parametric composite types can be restricted in the same manner:</source>
          <target state="translated">Параметры типа для параметрических составных типов могут быть ограничены аналогичным образом:</target>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="translated">Типовые отношения</target>
        </trans-unit>
        <trans-unit id="12d64d97cdd4d210c956404867f73d6285cb3aa2" translate="yes" xml:space="preserve">
          <source>Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be written without the precise types of values being known at compile time. The ability to write code that can operate on different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values ever restricted.</source>
          <target state="translated">Системы типов традиционно разделяются на два совершенно разных лагеря:статические системы типов,где каждое программное выражение должно иметь тип,вычисляемый перед выполнением программы,и динамические системы типов,где о типах ничего не известно до тех пор,пока не наступит время исполнения,когда будут доступны фактические значения,которыми манипулирует программа.Ориентация на объект позволяет проявлять некоторую гибкость в статически типизированных языках,позволяя писать код без точных типов значений,известных на этапе компиляции.Возможность написания кода,который может работать с различными типами,называется полиморфизмом.Весь код в классических динамически типизированных языках является полиморфным:только явно проверяя типы,или когда объекты не поддерживают операции во время исполнения,ограничиваются типы любых значений.</target>
        </trans-unit>
        <trans-unit id="7972379a3c2cbad083d2ed614182962961c71c72" translate="yes" xml:space="preserve">
          <source>Type used by &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt;&lt;code&gt;ClusterManager&lt;/code&gt;&lt;/a&gt;s to control workers added to their clusters. Some fields are used by all cluster managers to access a host:</source>
          <target state="translated">Тип, используемый &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt; &lt;code&gt;ClusterManager&lt;/code&gt; &lt;/a&gt; s для управления рабочими процессами, добавленными в их кластеры. Некоторые поля используются всеми менеджерами кластера для доступа к хосту:</target>
        </trans-unit>
        <trans-unit id="9fbab0c4a9d7c9cb4f0cf6a2eb051a99d0b23d5d" translate="yes" xml:space="preserve">
          <source>Type variables can be restricted with subtype relations. &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; refers to all arrays whose element type is some kind of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. The syntax &lt;code&gt;Array{&amp;lt;:Integer}&lt;/code&gt; is a convenient shorthand for &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt;. Type variables can have both lower and upper bounds. &lt;code&gt;Array{T} where Int&amp;lt;:T&amp;lt;:Number&lt;/code&gt; refers to all arrays of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;s that are able to contain &lt;code&gt;Int&lt;/code&gt;s (since &lt;code&gt;T&lt;/code&gt; must be at least as big as &lt;code&gt;Int&lt;/code&gt;). The syntax &lt;code&gt;where T&amp;gt;:Int&lt;/code&gt; also works to specify only the lower bound of a type variable, and &lt;code&gt;Array{&amp;gt;:Int}&lt;/code&gt; is equivalent to &lt;code&gt;Array{T} where T&amp;gt;:Int&lt;/code&gt;.</source>
          <target state="translated">Переменные типа могут быть ограничены отношениями подтипов. &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; относится ко всем массивам, тип элемента которых является &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; . Синтаксис &lt;code&gt;Array{&amp;lt;:Integer}&lt;/code&gt; - удобное сокращение для &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; . Переменные типа могут иметь как нижнюю, так и верхнюю границы. &lt;code&gt;Array{T} where Int&amp;lt;:T&amp;lt;:Number&lt;/code&gt; относится ко всем массивам &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; s, которые могут содержать &lt;code&gt;Int&lt;/code&gt; (поскольку &lt;code&gt;T&lt;/code&gt; должен быть не меньше &lt;code&gt;Int&lt;/code&gt; ). Синтаксис, в &lt;code&gt;where T&amp;gt;:Int&lt;/code&gt; также работает, чтобы указать только нижнюю границу переменной типа, а &lt;code&gt;Array{&amp;gt;:Int}&lt;/code&gt; эквивалентен &lt;code&gt;Array{T} where T&amp;gt;:Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b58c015fd584b426ddd183d3bd379a95d6be97" translate="yes" xml:space="preserve">
          <source>Typed array initializers</source>
          <target state="translated">Типизированные инициализаторы массива</target>
        </trans-unit>
        <trans-unit id="cf7a25a9e02171630e17f66a177ae70ee69aaf9a" translate="yes" xml:space="preserve">
          <source>Typed array literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="fbe557b5793644a7901cb800d76030ed78f31ec9" translate="yes" xml:space="preserve">
          <source>Types can be declared without specifying the types of their fields:</source>
          <target state="translated">Типы могут быть объявлены без указания типов их полей:</target>
        </trans-unit>
        <trans-unit id="fdedb89e25bef406c502b07b3fc7f90af76076d3" translate="yes" xml:space="preserve">
          <source>Types in module &lt;code&gt;Main&lt;/code&gt; cannot be redefined.</source>
          <target state="translated">Типы в модуле &lt;code&gt;Main&lt;/code&gt; не могут быть переопределены.</target>
        </trans-unit>
        <trans-unit id="650af697d6f97ac31d8e939763f2089920715297" translate="yes" xml:space="preserve">
          <source>Types such as &lt;code&gt;Union{Function,AbstractString}&lt;/code&gt; are often a sign that some design could be cleaner.</source>
          <target state="translated">Такие типы, как &lt;code&gt;Union{Function,AbstractString}&lt;/code&gt; , часто являются признаком того, что какой-то дизайн может быть чище.</target>
        </trans-unit>
        <trans-unit id="06e7787daf9f1b80047a5404b114c43c5fe951aa" translate="yes" xml:space="preserve">
          <source>Types with values-as-parameters</source>
          <target state="translated">Типы со значениями по параметрам</target>
        </trans-unit>
        <trans-unit id="3f3f5c7adeb5ad8f6d9e378b2333ccf650b57cd7" translate="yes" xml:space="preserve">
          <source>Types, type declarations, and constructors</source>
          <target state="translated">Типы,декларации типов и конструкторы</target>
        </trans-unit>
        <trans-unit id="eaef1931ed9538c659ce53165ed9d4e8ce061afe" translate="yes" xml:space="preserve">
          <source>Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.</source>
          <target state="translated">Обычно используется большое количество тестов для проверки правильности работы функций на различных входах.В случае неудачи теста,поведение по умолчанию заключается в том,чтобы немедленно бросить исключение.Однако,как правило,предпочтительнее сначала запустить остальные тесты,чтобы получить лучшее представление о том,сколько ошибок имеется в тестируемом коде.</target>
        </trans-unit>
        <trans-unit id="bc0c2b73a898cd3376224f049c214a04bf91c4ec" translate="yes" xml:space="preserve">
          <source>Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.</source>
          <target state="translated">Обычно объекты Юлии освобождаются сборщиком мусора (GC),но GC автоматически не знает,что у нас есть ссылка на значение Юлии из C.Это означает,что GC может освобождать объекты из-под вас,делая указатели недействительными.</target>
        </trans-unit>
        <trans-unit id="7419e2c7a1164809fb8ab4ac690a6e5483811275" translate="yes" xml:space="preserve">
          <source>U+000A1</source>
          <target state="translated">U+000A1</target>
        </trans-unit>
        <trans-unit id="f732db6bfaceaf0fc8ce5731c40779ee88385e6b" translate="yes" xml:space="preserve">
          <source>U+000A3</source>
          <target state="translated">U+000A3</target>
        </trans-unit>
        <trans-unit id="833d790d7abefa68b4017fdb2b0846169ce6efb2" translate="yes" xml:space="preserve">
          <source>U+000A5</source>
          <target state="translated">U+000A5</target>
        </trans-unit>
        <trans-unit id="58a6aa3f7f66e4affa4c092d7c6f847968ea3de9" translate="yes" xml:space="preserve">
          <source>U+000A6</source>
          <target state="translated">U+000A6</target>
        </trans-unit>
        <trans-unit id="211d177d90638c1a066376a7be8af6d0d158c6a4" translate="yes" xml:space="preserve">
          <source>U+000A7</source>
          <target state="translated">U+000A7</target>
        </trans-unit>
        <trans-unit id="d9dc28f2fa7e30eb9c0f439b5750f3838f2cee87" translate="yes" xml:space="preserve">
          <source>U+000A9</source>
          <target state="translated">U+000A9</target>
        </trans-unit>
        <trans-unit id="513de6b2fcc5e7696ac5c1feba0bb18320067443" translate="yes" xml:space="preserve">
          <source>U+000AA</source>
          <target state="translated">U+000AA</target>
        </trans-unit>
        <trans-unit id="d300f7fa4371b181daf488187043f16662716af6" translate="yes" xml:space="preserve">
          <source>U+000AC</source>
          <target state="translated">U+000AC</target>
        </trans-unit>
        <trans-unit id="c7280374ed3343e39969c2ac82c6ddd1f10b831b" translate="yes" xml:space="preserve">
          <source>U+000AE</source>
          <target state="translated">U+000AE</target>
        </trans-unit>
        <trans-unit id="2edb7755d90188c4712771ad592728075ed41e24" translate="yes" xml:space="preserve">
          <source>U+000AF</source>
          <target state="translated">U+000AF</target>
        </trans-unit>
        <trans-unit id="aa7cc7286046f5dd25504a6c0d0a12491fbeda0f" translate="yes" xml:space="preserve">
          <source>U+000B0</source>
          <target state="translated">U+000B0</target>
        </trans-unit>
        <trans-unit id="bc0c6ac2a505a0f8f6872d9acdc254342e989518" translate="yes" xml:space="preserve">
          <source>U+000B1</source>
          <target state="translated">U+000B1</target>
        </trans-unit>
        <trans-unit id="5f6be68884bd3dff697042668c570d5fe480e75c" translate="yes" xml:space="preserve">
          <source>U+000B2</source>
          <target state="translated">U+000B2</target>
        </trans-unit>
        <trans-unit id="e628cf09ed074b1079cb8eb5dd91967d983f7444" translate="yes" xml:space="preserve">
          <source>U+000B3</source>
          <target state="translated">U+000B3</target>
        </trans-unit>
        <trans-unit id="bb8b943f43a734647d4be7fbdf8e9aeb6abe4e97" translate="yes" xml:space="preserve">
          <source>U+000B6</source>
          <target state="translated">U+000B6</target>
        </trans-unit>
        <trans-unit id="6600a279e4eb4336043915244350bcee45219d89" translate="yes" xml:space="preserve">
          <source>U+000B7</source>
          <target state="translated">U+000B7</target>
        </trans-unit>
        <trans-unit id="d0581e625d32999da8ec6ad1c102f7b084fb10d0" translate="yes" xml:space="preserve">
          <source>U+000B9</source>
          <target state="translated">U+000B9</target>
        </trans-unit>
        <trans-unit id="6a0b7c9ae3d95116839c792180becb32a4eb1aa2" translate="yes" xml:space="preserve">
          <source>U+000BA</source>
          <target state="translated">U+000BA</target>
        </trans-unit>
        <trans-unit id="af8d71e515f3816902d8621058dd0a1fffb02d28" translate="yes" xml:space="preserve">
          <source>U+000BC</source>
          <target state="translated">U+000BC</target>
        </trans-unit>
        <trans-unit id="f7929245fb046770d68bd353f0cb56d884faeaf8" translate="yes" xml:space="preserve">
          <source>U+000BD</source>
          <target state="translated">U+000BD</target>
        </trans-unit>
        <trans-unit id="1e389602653ddaef9088ff864e19a57a118668f8" translate="yes" xml:space="preserve">
          <source>U+000BE</source>
          <target state="translated">U+000BE</target>
        </trans-unit>
        <trans-unit id="abf751d4270b495290ba758290cd8cc30e0fc2c2" translate="yes" xml:space="preserve">
          <source>U+000BF</source>
          <target state="translated">U+000BF</target>
        </trans-unit>
        <trans-unit id="1163f1afd4392e3fdc01f33aa911294c9e5579f3" translate="yes" xml:space="preserve">
          <source>U+000C5</source>
          <target state="translated">U+000C5</target>
        </trans-unit>
        <trans-unit id="05b7168d4a3b7e544c07ac7dfac1a23c612ebfa4" translate="yes" xml:space="preserve">
          <source>U+000C6</source>
          <target state="translated">U+000C6</target>
        </trans-unit>
        <trans-unit id="8aefab16dcf0ed235064441308b0156f4f0781b0" translate="yes" xml:space="preserve">
          <source>U+000D0</source>
          <target state="translated">U+000D0</target>
        </trans-unit>
        <trans-unit id="43ca4d9749dbf2b9ba07bbe85b9d3a57230866e2" translate="yes" xml:space="preserve">
          <source>U+000D7</source>
          <target state="translated">U+000D7</target>
        </trans-unit>
        <trans-unit id="b55c75bf336976c87a823de7eaf0c105decaf9ea" translate="yes" xml:space="preserve">
          <source>U+000D8</source>
          <target state="translated">U+000D8</target>
        </trans-unit>
        <trans-unit id="fa31076aac4fc077167ef6b42f2541b7c25f0ff9" translate="yes" xml:space="preserve">
          <source>U+000DE</source>
          <target state="translated">U+000DE</target>
        </trans-unit>
        <trans-unit id="6d8c7be3aae9c7877583cf61703efbfcea6ad185" translate="yes" xml:space="preserve">
          <source>U+000DF</source>
          <target state="translated">U+000DF</target>
        </trans-unit>
        <trans-unit id="2988d0457d6c48a8f06d801f595d2dcef851a96f" translate="yes" xml:space="preserve">
          <source>U+000E5</source>
          <target state="translated">U+000E5</target>
        </trans-unit>
        <trans-unit id="f332510ba8dac469b6d1212966044bf56a7112d6" translate="yes" xml:space="preserve">
          <source>U+000E6</source>
          <target state="translated">U+000E6</target>
        </trans-unit>
        <trans-unit id="12dccbd7c4e0fb222ddd7db261fdf7b54ea85979" translate="yes" xml:space="preserve">
          <source>U+000F0</source>
          <target state="translated">U+000F0</target>
        </trans-unit>
        <trans-unit id="cb2c136f402df9ed86e130e84f1e76ce52a3a8f6" translate="yes" xml:space="preserve">
          <source>U+000F7</source>
          <target state="translated">U+000F7</target>
        </trans-unit>
        <trans-unit id="0de3d46a54055e956c406646c96350c1711258d5" translate="yes" xml:space="preserve">
          <source>U+000F8</source>
          <target state="translated">U+000F8</target>
        </trans-unit>
        <trans-unit id="774a36f37882c565b6e1a8c6da68506e50495f70" translate="yes" xml:space="preserve">
          <source>U+000FE</source>
          <target state="translated">U+000FE</target>
        </trans-unit>
        <trans-unit id="1291de41445c70b8167722b4bad48913e7b5a4a9" translate="yes" xml:space="preserve">
          <source>U+00110</source>
          <target state="translated">U+00110</target>
        </trans-unit>
        <trans-unit id="e389d4dfa1ae96bce106b3994f574f843dc801fb" translate="yes" xml:space="preserve">
          <source>U+00111</source>
          <target state="translated">U+00111</target>
        </trans-unit>
        <trans-unit id="b3a3814c99d325b6730ca42d3cc8cc2b51ceec87" translate="yes" xml:space="preserve">
          <source>U+00127</source>
          <target state="translated">U+00127</target>
        </trans-unit>
        <trans-unit id="4968e90007db7224e93699b7f20b461717d5eb8c" translate="yes" xml:space="preserve">
          <source>U+00131</source>
          <target state="translated">U+00131</target>
        </trans-unit>
        <trans-unit id="88ad15ac149402ea9f1a9bd9fd8ea887293d266a" translate="yes" xml:space="preserve">
          <source>U+00141</source>
          <target state="translated">U+00141</target>
        </trans-unit>
        <trans-unit id="bf6e35a30049db640ab91f1494f1f612637ffe04" translate="yes" xml:space="preserve">
          <source>U+00142</source>
          <target state="translated">U+00142</target>
        </trans-unit>
        <trans-unit id="e7d287bba0dfb9de5eade077b23014aa729f3d6e" translate="yes" xml:space="preserve">
          <source>U+0014A</source>
          <target state="translated">U+0014A</target>
        </trans-unit>
        <trans-unit id="18ae38fd4e2b56f6c821f408380a109cb6acfa94" translate="yes" xml:space="preserve">
          <source>U+0014B</source>
          <target state="translated">U+0014B</target>
        </trans-unit>
        <trans-unit id="39dff18eca38d64db46a57f8de43d0e39f2f1235" translate="yes" xml:space="preserve">
          <source>U+00152</source>
          <target state="translated">U+00152</target>
        </trans-unit>
        <trans-unit id="8651e7b8fce35fd0351a57eb44a27ae9ff54049a" translate="yes" xml:space="preserve">
          <source>U+00153</source>
          <target state="translated">U+00153</target>
        </trans-unit>
        <trans-unit id="2d435468173be8bdfd61aa039618e08e954d15ab" translate="yes" xml:space="preserve">
          <source>U+00195</source>
          <target state="translated">U+00195</target>
        </trans-unit>
        <trans-unit id="a36a973f10dd16c9e619f6603156d35894ce21e0" translate="yes" xml:space="preserve">
          <source>U+0019E</source>
          <target state="translated">U+0019E</target>
        </trans-unit>
        <trans-unit id="d00bad4253303e09a738476636ce66202011ebe4" translate="yes" xml:space="preserve">
          <source>U+001B5</source>
          <target state="translated">U+001B5</target>
        </trans-unit>
        <trans-unit id="3d2010424160248324bda296e63dc5baa5abccc3" translate="yes" xml:space="preserve">
          <source>U+001C2</source>
          <target state="translated">U+001C2</target>
        </trans-unit>
        <trans-unit id="a97e1fa68e72b7a67a42424ce121072cd94ed47f" translate="yes" xml:space="preserve">
          <source>U+00237</source>
          <target state="translated">U+00237</target>
        </trans-unit>
        <trans-unit id="4d69ba9aeef07b7e6aec00ad39a4d321bc1283b1" translate="yes" xml:space="preserve">
          <source>U+00250</source>
          <target state="translated">U+00250</target>
        </trans-unit>
        <trans-unit id="22d1c75b25948d29404ba4763f03160a217f8ce1" translate="yes" xml:space="preserve">
          <source>U+00252</source>
          <target state="translated">U+00252</target>
        </trans-unit>
        <trans-unit id="af8bd3d4ba63fc745ea3e4420a61bdd3a064ee4a" translate="yes" xml:space="preserve">
          <source>U+00254</source>
          <target state="translated">U+00254</target>
        </trans-unit>
        <trans-unit id="e2f72aadbe54071d147f6341efdb29de9ad14e4b" translate="yes" xml:space="preserve">
          <source>U+00256</source>
          <target state="translated">U+00256</target>
        </trans-unit>
        <trans-unit id="3b743298c3105d1e76b2ef99bd922992ca69eb0b" translate="yes" xml:space="preserve">
          <source>U+00259</source>
          <target state="translated">U+00259</target>
        </trans-unit>
        <trans-unit id="f6b5e244fb522c59115f69c715d0354897fe151d" translate="yes" xml:space="preserve">
          <source>U+00263</source>
          <target state="translated">U+00263</target>
        </trans-unit>
        <trans-unit id="84a38ffd2f818a690ebf8ad3c32a0dee3976d3c2" translate="yes" xml:space="preserve">
          <source>U+00264</source>
          <target state="translated">U+00264</target>
        </trans-unit>
        <trans-unit id="ce22b1cc1b063128eb38973ddd4dc12b732b062a" translate="yes" xml:space="preserve">
          <source>U+00265</source>
          <target state="translated">U+00265</target>
        </trans-unit>
        <trans-unit id="3feda74990460ad97bf2af797b4de92ad4e69377" translate="yes" xml:space="preserve">
          <source>U+0026C</source>
          <target state="translated">U+0026C</target>
        </trans-unit>
        <trans-unit id="fb8940a89678648a62ccaeecc567280d198499bf" translate="yes" xml:space="preserve">
          <source>U+0026D</source>
          <target state="translated">U+0026D</target>
        </trans-unit>
        <trans-unit id="30b320089b0ebe1dc924fabdc7959e07f9017558" translate="yes" xml:space="preserve">
          <source>U+0026F</source>
          <target state="translated">U+0026F</target>
        </trans-unit>
        <trans-unit id="7c8f384244ed4d4f3a67d4b88a379a42a62a3450" translate="yes" xml:space="preserve">
          <source>U+00270</source>
          <target state="translated">U+00270</target>
        </trans-unit>
        <trans-unit id="ba23d082c51d02d4d3b0cf3c417e7b0d5b1882fb" translate="yes" xml:space="preserve">
          <source>U+00271</source>
          <target state="translated">U+00271</target>
        </trans-unit>
        <trans-unit id="7636f3f9673f30014a2fdc6478383d9c87614698" translate="yes" xml:space="preserve">
          <source>U+00272</source>
          <target state="translated">U+00272</target>
        </trans-unit>
        <trans-unit id="01dddefc8eae304db1b7e88736a5587a1268359c" translate="yes" xml:space="preserve">
          <source>U+00273</source>
          <target state="translated">U+00273</target>
        </trans-unit>
        <trans-unit id="ce39969ebf02b230d2ba87bed283105fbe1cea59" translate="yes" xml:space="preserve">
          <source>U+00277</source>
          <target state="translated">U+00277</target>
        </trans-unit>
        <trans-unit id="b96d46c699a7e2987266871732af97ce398adc70" translate="yes" xml:space="preserve">
          <source>U+00278</source>
          <target state="translated">U+00278</target>
        </trans-unit>
        <trans-unit id="3d8fcb3eaf7d68d0996ce6a5c5b10bd3f138dc0b" translate="yes" xml:space="preserve">
          <source>U+00279</source>
          <target state="translated">U+00279</target>
        </trans-unit>
        <trans-unit id="295b04b25d0a4364b7d20624bbfd762a1ac2d24d" translate="yes" xml:space="preserve">
          <source>U+0027A</source>
          <target state="translated">U+0027A</target>
        </trans-unit>
        <trans-unit id="428b00c9bfc76f2d3f7e81dbafdef44c81f9383c" translate="yes" xml:space="preserve">
          <source>U+0027B</source>
          <target state="translated">U+0027B</target>
        </trans-unit>
        <trans-unit id="85987a0454fb312e830cb7309532a52d7afc75db" translate="yes" xml:space="preserve">
          <source>U+0027C</source>
          <target state="translated">U+0027C</target>
        </trans-unit>
        <trans-unit id="2558e38e8474acc53ec4982d93e9d13a4bc63041" translate="yes" xml:space="preserve">
          <source>U+0027D</source>
          <target state="translated">U+0027D</target>
        </trans-unit>
        <trans-unit id="42b6e861ffe437b44baf1c237ce68646f708c277" translate="yes" xml:space="preserve">
          <source>U+0027E</source>
          <target state="translated">U+0027E</target>
        </trans-unit>
        <trans-unit id="0e54c84a5b06d72b3c31654eaf05f17a286c77ab" translate="yes" xml:space="preserve">
          <source>U+00282</source>
          <target state="translated">U+00282</target>
        </trans-unit>
        <trans-unit id="9542be08bf2ba79f4ea69b9dce257338ef18751d" translate="yes" xml:space="preserve">
          <source>U+00283</source>
          <target state="translated">U+00283</target>
        </trans-unit>
        <trans-unit id="adab2604f6d1b888adaca2bbfe3af33ea3792f5d" translate="yes" xml:space="preserve">
          <source>U+00287</source>
          <target state="translated">U+00287</target>
        </trans-unit>
        <trans-unit id="b301021720610d1741fdf78006f7bb45c6daee9a" translate="yes" xml:space="preserve">
          <source>U+00288</source>
          <target state="translated">U+00288</target>
        </trans-unit>
        <trans-unit id="57b25fd29c3fe282486ef4b1be0821f6d50446df" translate="yes" xml:space="preserve">
          <source>U+0028A</source>
          <target state="translated">U+0028A</target>
        </trans-unit>
        <trans-unit id="ec9d1ded054e0129d538fb38e06b9d0ce47f8ebf" translate="yes" xml:space="preserve">
          <source>U+0028B</source>
          <target state="translated">U+0028B</target>
        </trans-unit>
        <trans-unit id="801b02166c700cd7542c1d28cc993933d11b5412" translate="yes" xml:space="preserve">
          <source>U+0028C</source>
          <target state="translated">U+0028C</target>
        </trans-unit>
        <trans-unit id="6681e52b2ad820f3911c74349c0ab85b44080f65" translate="yes" xml:space="preserve">
          <source>U+0028D</source>
          <target state="translated">U+0028D</target>
        </trans-unit>
        <trans-unit id="4a3deac43610c6162ac1cb41f886e09400fe08b8" translate="yes" xml:space="preserve">
          <source>U+0028E</source>
          <target state="translated">U+0028E</target>
        </trans-unit>
        <trans-unit id="331e4ea4162519246372acf31bcfccd90b5f2e19" translate="yes" xml:space="preserve">
          <source>U+00290</source>
          <target state="translated">U+00290</target>
        </trans-unit>
        <trans-unit id="73e3b7292e0a22832e3cc4ddc5bb2d2599af142c" translate="yes" xml:space="preserve">
          <source>U+00292</source>
          <target state="translated">U+00292</target>
        </trans-unit>
        <trans-unit id="80d635cdf633fe7e924dbe4468906dbbf7629a1d" translate="yes" xml:space="preserve">
          <source>U+00294</source>
          <target state="translated">U+00294</target>
        </trans-unit>
        <trans-unit id="c16d5472652ef43bd638938bd480a057e0eaacab" translate="yes" xml:space="preserve">
          <source>U+00295</source>
          <target state="translated">U+00295</target>
        </trans-unit>
        <trans-unit id="0e52c441e19ba3e888d10d423e575efde3a6bafa" translate="yes" xml:space="preserve">
          <source>U+00296</source>
          <target state="translated">U+00296</target>
        </trans-unit>
        <trans-unit id="2b16c81e0802bf6f6afb5177341c611f360783b5" translate="yes" xml:space="preserve">
          <source>U+0029E</source>
          <target state="translated">U+0029E</target>
        </trans-unit>
        <trans-unit id="6cb9c239aa546e0dcfb7a419346c4206a2606b50" translate="yes" xml:space="preserve">
          <source>U+002A4</source>
          <target state="translated">U+002A4</target>
        </trans-unit>
        <trans-unit id="097c8d622a507f2de93f19daada70e15265cf1fb" translate="yes" xml:space="preserve">
          <source>U+002A7</source>
          <target state="translated">U+002A7</target>
        </trans-unit>
        <trans-unit id="e877d7918f1b3d8d701dd59cba562a8efd857b1f" translate="yes" xml:space="preserve">
          <source>U+002B0</source>
          <target state="translated">U+002B0</target>
        </trans-unit>
        <trans-unit id="3bf87c668ddfeeee7c2060cef24e5ab77904adaf" translate="yes" xml:space="preserve">
          <source>U+002B2</source>
          <target state="translated">U+002B2</target>
        </trans-unit>
        <trans-unit id="42fd5c55674fbddf51d7de0aefcd3b3fc495919d" translate="yes" xml:space="preserve">
          <source>U+002B3</source>
          <target state="translated">U+002B3</target>
        </trans-unit>
        <trans-unit id="4192c941cf326b515a30c940185e4c0d9c126830" translate="yes" xml:space="preserve">
          <source>U+002B7</source>
          <target state="translated">U+002B7</target>
        </trans-unit>
        <trans-unit id="25b13743aa073ff8722db26721538f49723e0b90" translate="yes" xml:space="preserve">
          <source>U+002B8</source>
          <target state="translated">U+002B8</target>
        </trans-unit>
        <trans-unit id="1d752823fa407500f75196a49ca86514c3c0879d" translate="yes" xml:space="preserve">
          <source>U+002BC</source>
          <target state="translated">U+002BC</target>
        </trans-unit>
        <trans-unit id="03ac95360c12f8887b17b20232d25679453703b0" translate="yes" xml:space="preserve">
          <source>U+002C8</source>
          <target state="translated">U+002C8</target>
        </trans-unit>
        <trans-unit id="a4c78134d2d7d185a40523250f9ee8fd16257a9b" translate="yes" xml:space="preserve">
          <source>U+002CC</source>
          <target state="translated">U+002CC</target>
        </trans-unit>
        <trans-unit id="cccb2ff7d94994055f3a3dc0fc58deb9a341d036" translate="yes" xml:space="preserve">
          <source>U+002D0</source>
          <target state="translated">U+002D0</target>
        </trans-unit>
        <trans-unit id="e29b1c1aafd6ed8fcd9e87c84945aea8b226d734" translate="yes" xml:space="preserve">
          <source>U+002D1</source>
          <target state="translated">U+002D1</target>
        </trans-unit>
        <trans-unit id="6831363163e11e2d59a8ededebfeb95a465ee8fd" translate="yes" xml:space="preserve">
          <source>U+002D2</source>
          <target state="translated">U+002D2</target>
        </trans-unit>
        <trans-unit id="bdda9736ee6f277af7b3ffe1fa983f66286cabef" translate="yes" xml:space="preserve">
          <source>U+002D3</source>
          <target state="translated">U+002D3</target>
        </trans-unit>
        <trans-unit id="25c327b01ba9d5d7d0871dd085d8e57b1c54b413" translate="yes" xml:space="preserve">
          <source>U+002D4</source>
          <target state="translated">U+002D4</target>
        </trans-unit>
        <trans-unit id="ff8fb6fd2ceb7bfc04a2d2559bfa93174d5bae88" translate="yes" xml:space="preserve">
          <source>U+002D5</source>
          <target state="translated">U+002D5</target>
        </trans-unit>
        <trans-unit id="d2c582a407b6e9ccfef06f8f3fde0d05fb039e9e" translate="yes" xml:space="preserve">
          <source>U+002D8</source>
          <target state="translated">U+002D8</target>
        </trans-unit>
        <trans-unit id="129d476bea61b7592a6ca0cf4b20c1135330db3f" translate="yes" xml:space="preserve">
          <source>U+002DC</source>
          <target state="translated">U+002DC</target>
        </trans-unit>
        <trans-unit id="78ecb83484352a8149143cfcb7d53f21893e4267" translate="yes" xml:space="preserve">
          <source>U+002E1</source>
          <target state="translated">U+002E1</target>
        </trans-unit>
        <trans-unit id="4e596f80ec8c828f1336b9e07b3601d2574beafa" translate="yes" xml:space="preserve">
          <source>U+002E2</source>
          <target state="translated">U+002E2</target>
        </trans-unit>
        <trans-unit id="96ca94df5b58f7b819b3d05821fec1d621c2c31b" translate="yes" xml:space="preserve">
          <source>U+002E3</source>
          <target state="translated">U+002E3</target>
        </trans-unit>
        <trans-unit id="5af3e022587eadb32cb8956bc9e0cb23febc482d" translate="yes" xml:space="preserve">
          <source>U+00300</source>
          <target state="translated">U+00300</target>
        </trans-unit>
        <trans-unit id="57384dd962625f4e707ca83219aa4026ba580823" translate="yes" xml:space="preserve">
          <source>U+00301</source>
          <target state="translated">U+00301</target>
        </trans-unit>
        <trans-unit id="25622a25320793f31198afe1e84dd14cdbd7db4e" translate="yes" xml:space="preserve">
          <source>U+00302</source>
          <target state="translated">U+00302</target>
        </trans-unit>
        <trans-unit id="2e2e115497d6c34b4c651551de95cf99f558cf7a" translate="yes" xml:space="preserve">
          <source>U+00303</source>
          <target state="translated">U+00303</target>
        </trans-unit>
        <trans-unit id="b9ad39d07e9c200699b65f3ac1b38bf322374704" translate="yes" xml:space="preserve">
          <source>U+00304</source>
          <target state="translated">U+00304</target>
        </trans-unit>
        <trans-unit id="5fb9f31fe383aad4cb9d7441b9ec3371efa9a4fd" translate="yes" xml:space="preserve">
          <source>U+00305</source>
          <target state="translated">U+00305</target>
        </trans-unit>
        <trans-unit id="186bb579588f3cce4563a9889e2b8107ea903a5d" translate="yes" xml:space="preserve">
          <source>U+00306</source>
          <target state="translated">U+00306</target>
        </trans-unit>
        <trans-unit id="35e6b9edc64633750dd2847c1350f0fa7f18500d" translate="yes" xml:space="preserve">
          <source>U+00307</source>
          <target state="translated">U+00307</target>
        </trans-unit>
        <trans-unit id="df91588955565e56b0ea5b0159eb8b0b6cd086bc" translate="yes" xml:space="preserve">
          <source>U+00308</source>
          <target state="translated">U+00308</target>
        </trans-unit>
        <trans-unit id="3ee774a3cc0cc9fdb1cec91598b3ab8b5a0bea72" translate="yes" xml:space="preserve">
          <source>U+00309</source>
          <target state="translated">U+00309</target>
        </trans-unit>
        <trans-unit id="73c4bfa5fcc98a4fe52861638ccbe57da12866f9" translate="yes" xml:space="preserve">
          <source>U+0030A</source>
          <target state="translated">U+0030A</target>
        </trans-unit>
        <trans-unit id="d80abf6f2f5f7c03b83b0c4bf773a1f3ecf6c879" translate="yes" xml:space="preserve">
          <source>U+0030B</source>
          <target state="translated">U+0030B</target>
        </trans-unit>
        <trans-unit id="cc7bed5251d91f923160d5275b3eeb6ed9309bd4" translate="yes" xml:space="preserve">
          <source>U+0030C</source>
          <target state="translated">U+0030C</target>
        </trans-unit>
        <trans-unit id="464a998232158c39793943141d5b367027d70b0c" translate="yes" xml:space="preserve">
          <source>U+00310</source>
          <target state="translated">U+00310</target>
        </trans-unit>
        <trans-unit id="7b7776208309e402b95172dc44806b4dbde6e413" translate="yes" xml:space="preserve">
          <source>U+00312</source>
          <target state="translated">U+00312</target>
        </trans-unit>
        <trans-unit id="d4b942fd861993b03dab4cdaada7e7c5372e6fcc" translate="yes" xml:space="preserve">
          <source>U+00315</source>
          <target state="translated">U+00315</target>
        </trans-unit>
        <trans-unit id="8ae80e88513cf6d54ed7f44fe46aaa1be02aa584" translate="yes" xml:space="preserve">
          <source>U+0031A</source>
          <target state="translated">U+0031A</target>
        </trans-unit>
        <trans-unit id="c54642fb58a9554774c76d94a3ef8aff97628f55" translate="yes" xml:space="preserve">
          <source>U+00321</source>
          <target state="translated">U+00321</target>
        </trans-unit>
        <trans-unit id="51bca611401ba8b89892496564622660d07ec3bc" translate="yes" xml:space="preserve">
          <source>U+00322</source>
          <target state="translated">U+00322</target>
        </trans-unit>
        <trans-unit id="be27d3066a012f06854ab1f51e9fb893211b8eff" translate="yes" xml:space="preserve">
          <source>U+00327</source>
          <target state="translated">U+00327</target>
        </trans-unit>
        <trans-unit id="3a8260b15bb83ec16781a5d3f77fc9967bd74f0f" translate="yes" xml:space="preserve">
          <source>U+00328</source>
          <target state="translated">U+00328</target>
        </trans-unit>
        <trans-unit id="48692a94d00d38eeb8507caed4505142e3cc14c6" translate="yes" xml:space="preserve">
          <source>U+0032A</source>
          <target state="translated">U+0032A</target>
        </trans-unit>
        <trans-unit id="8fd859998199d54e4fb3893eef33aea9481ac2b6" translate="yes" xml:space="preserve">
          <source>U+00330</source>
          <target state="translated">U+00330</target>
        </trans-unit>
        <trans-unit id="2891e8e914f9f7325c955665fb7eff0a6c27e22d" translate="yes" xml:space="preserve">
          <source>U+00332</source>
          <target state="translated">U+00332</target>
        </trans-unit>
        <trans-unit id="5a7ed7dca2330883f5f7e084a758cf0ca813fb63" translate="yes" xml:space="preserve">
          <source>U+00336</source>
          <target state="translated">U+00336</target>
        </trans-unit>
        <trans-unit id="7a273ba8594fdb20158946bf6a254a0fe61dd80c" translate="yes" xml:space="preserve">
          <source>U+00338</source>
          <target state="translated">U+00338</target>
        </trans-unit>
        <trans-unit id="cd0fb4dc0279677094a443b5ec744ef27bd89968" translate="yes" xml:space="preserve">
          <source>U+0034D</source>
          <target state="translated">U+0034D</target>
        </trans-unit>
        <trans-unit id="7966a98e38de21d2e4a6a2f262d7b3918dcd199c" translate="yes" xml:space="preserve">
          <source>U+00391</source>
          <target state="translated">U+00391</target>
        </trans-unit>
        <trans-unit id="d0b8a82183aad42e701c39ceba7d360218063df9" translate="yes" xml:space="preserve">
          <source>U+00392</source>
          <target state="translated">U+00392</target>
        </trans-unit>
        <trans-unit id="21e769d07a8bac0374b5e1ff35fcdc525c3a0570" translate="yes" xml:space="preserve">
          <source>U+00393</source>
          <target state="translated">U+00393</target>
        </trans-unit>
        <trans-unit id="7f904e2ee1a348881515f7decd9e3f23bf6dc26c" translate="yes" xml:space="preserve">
          <source>U+00394</source>
          <target state="translated">U+00394</target>
        </trans-unit>
        <trans-unit id="874f226781592e1532ed7436b4e42bc8d2623b30" translate="yes" xml:space="preserve">
          <source>U+00395</source>
          <target state="translated">U+00395</target>
        </trans-unit>
        <trans-unit id="cedf61e542d13a336c2a628c1099326c0f63969a" translate="yes" xml:space="preserve">
          <source>U+00396</source>
          <target state="translated">U+00396</target>
        </trans-unit>
        <trans-unit id="3ca968a155717e85467418e67d2610ba368a4d66" translate="yes" xml:space="preserve">
          <source>U+00397</source>
          <target state="translated">U+00397</target>
        </trans-unit>
        <trans-unit id="87ed7c2231196be8910d2431694088b68771153f" translate="yes" xml:space="preserve">
          <source>U+00398</source>
          <target state="translated">U+00398</target>
        </trans-unit>
        <trans-unit id="b51e81c4c9e7a0cd5d61c3962bd3e7e9d53cbad6" translate="yes" xml:space="preserve">
          <source>U+00399</source>
          <target state="translated">U+00399</target>
        </trans-unit>
        <trans-unit id="97851e883fe3fac9942cb0f36a8ececcff49f289" translate="yes" xml:space="preserve">
          <source>U+0039A</source>
          <target state="translated">U+0039A</target>
        </trans-unit>
        <trans-unit id="2d0db6ebb502514c3a6895893038af4b7f8a9fa0" translate="yes" xml:space="preserve">
          <source>U+0039B</source>
          <target state="translated">U+0039B</target>
        </trans-unit>
        <trans-unit id="2af5164dc2a9ba06dbb73864082e76909bdb9cb0" translate="yes" xml:space="preserve">
          <source>U+0039C</source>
          <target state="translated">U+0039C</target>
        </trans-unit>
        <trans-unit id="191917b63fcaf534c3267b3fedac596812b92fa8" translate="yes" xml:space="preserve">
          <source>U+0039D</source>
          <target state="translated">U+0039D</target>
        </trans-unit>
        <trans-unit id="7608890a629a72f35fa9c49e4ddbfc577d3144e8" translate="yes" xml:space="preserve">
          <source>U+0039E</source>
          <target state="translated">U+0039E</target>
        </trans-unit>
        <trans-unit id="8993ed83e6a2420ffd66e48a8e14ff67abfb34a7" translate="yes" xml:space="preserve">
          <source>U+0039F</source>
          <target state="translated">U+0039F</target>
        </trans-unit>
        <trans-unit id="6647e8df9733081f6109aa97088862e0e4abcc2f" translate="yes" xml:space="preserve">
          <source>U+003A0</source>
          <target state="translated">U+003A0</target>
        </trans-unit>
        <trans-unit id="9ade840b2eaccf8824bb01b9a58355de5a4db766" translate="yes" xml:space="preserve">
          <source>U+003A1</source>
          <target state="translated">U+003A1</target>
        </trans-unit>
        <trans-unit id="48c088188b148514e71e0c8cdbaf794530759dde" translate="yes" xml:space="preserve">
          <source>U+003A3</source>
          <target state="translated">U+003A3</target>
        </trans-unit>
        <trans-unit id="251b1650fa3e7210ec229397ee6d7a5700ee5e52" translate="yes" xml:space="preserve">
          <source>U+003A4</source>
          <target state="translated">U+003A4</target>
        </trans-unit>
        <trans-unit id="b76ffee0ec8b7f087677c31f6b2a5f52458a9800" translate="yes" xml:space="preserve">
          <source>U+003A5</source>
          <target state="translated">U+003A5</target>
        </trans-unit>
        <trans-unit id="19ede9f206390ad0ddee6b1fb38a306428305f60" translate="yes" xml:space="preserve">
          <source>U+003A6</source>
          <target state="translated">U+003A6</target>
        </trans-unit>
        <trans-unit id="3ac9debd3d56489ff8cc8f1aceb7a3959cf30586" translate="yes" xml:space="preserve">
          <source>U+003A7</source>
          <target state="translated">U+003A7</target>
        </trans-unit>
        <trans-unit id="f8c95dbd6c98b96c44b7187f2136d2df5b80baa4" translate="yes" xml:space="preserve">
          <source>U+003A8</source>
          <target state="translated">U+003A8</target>
        </trans-unit>
        <trans-unit id="b5b49f6804dd1027a3b1b1149fc05e55ea028657" translate="yes" xml:space="preserve">
          <source>U+003A9</source>
          <target state="translated">U+003A9</target>
        </trans-unit>
        <trans-unit id="7df4c4d8574e0257f7b554e72154b40a4f961e40" translate="yes" xml:space="preserve">
          <source>U+003B1</source>
          <target state="translated">U+003B1</target>
        </trans-unit>
        <trans-unit id="38b05037dfcca16e3bc0aec40a79fe5f3f7a6bae" translate="yes" xml:space="preserve">
          <source>U+003B2</source>
          <target state="translated">U+003B2</target>
        </trans-unit>
        <trans-unit id="2017af14c2418d90536823e9c1cfb41a73a97387" translate="yes" xml:space="preserve">
          <source>U+003B3</source>
          <target state="translated">U+003B3</target>
        </trans-unit>
        <trans-unit id="8489235bd9087a3790bb0c0a99390be264d8d42d" translate="yes" xml:space="preserve">
          <source>U+003B4</source>
          <target state="translated">U+003B4</target>
        </trans-unit>
        <trans-unit id="0ad7e02862c7e6a2b120177c0a5806e81ecd90fa" translate="yes" xml:space="preserve">
          <source>U+003B5</source>
          <target state="translated">U+003B5</target>
        </trans-unit>
        <trans-unit id="f86fb3232412afb5ca7a0568cb934725d5ae2571" translate="yes" xml:space="preserve">
          <source>U+003B6</source>
          <target state="translated">U+003B6</target>
        </trans-unit>
        <trans-unit id="ad44f693fd33cb248ddd8ec41a912b824b27afa8" translate="yes" xml:space="preserve">
          <source>U+003B7</source>
          <target state="translated">U+003B7</target>
        </trans-unit>
        <trans-unit id="1c8798670c5f19f4d4b30e3ea0398df6f3da0e38" translate="yes" xml:space="preserve">
          <source>U+003B8</source>
          <target state="translated">U+003B8</target>
        </trans-unit>
        <trans-unit id="a514df160b479280b550a9dbd13772aa1835ad42" translate="yes" xml:space="preserve">
          <source>U+003B9</source>
          <target state="translated">U+003B9</target>
        </trans-unit>
        <trans-unit id="104b9e81ad12eeb0661deea9dda2b3c4723787b1" translate="yes" xml:space="preserve">
          <source>U+003BA</source>
          <target state="translated">U+003BA</target>
        </trans-unit>
        <trans-unit id="b4a242d16cea0ddfebf1382603d6d19208d8cae8" translate="yes" xml:space="preserve">
          <source>U+003BB</source>
          <target state="translated">U+003BB</target>
        </trans-unit>
        <trans-unit id="50db9f12fc5a232bf3528c5a10d947e05c5f9c2a" translate="yes" xml:space="preserve">
          <source>U+003BC</source>
          <target state="translated">U+003BC</target>
        </trans-unit>
        <trans-unit id="7635ce1de66b2503108277821ff32585538c38f6" translate="yes" xml:space="preserve">
          <source>U+003BD</source>
          <target state="translated">U+003BD</target>
        </trans-unit>
        <trans-unit id="ed86215a643340439e73b43c12ec22cd74a09342" translate="yes" xml:space="preserve">
          <source>U+003BE</source>
          <target state="translated">U+003BE</target>
        </trans-unit>
        <trans-unit id="5b74cb8e40d2b1ed841b6067924c1bb3f3081218" translate="yes" xml:space="preserve">
          <source>U+003BF</source>
          <target state="translated">U+003BF</target>
        </trans-unit>
        <trans-unit id="8cf73e2899a7d36e9f5bbd4b5a425f706ef33084" translate="yes" xml:space="preserve">
          <source>U+003C0</source>
          <target state="translated">U+003C0</target>
        </trans-unit>
        <trans-unit id="ee39537c45109587e3c6142781d56c0bd39af74c" translate="yes" xml:space="preserve">
          <source>U+003C1</source>
          <target state="translated">U+003C1</target>
        </trans-unit>
        <trans-unit id="fc117fba7f15ba9d71216e3c390473eee4d9691d" translate="yes" xml:space="preserve">
          <source>U+003C2</source>
          <target state="translated">U+003C2</target>
        </trans-unit>
        <trans-unit id="eaabe77bc0eacfab586dd67830aa955b7ecb2abb" translate="yes" xml:space="preserve">
          <source>U+003C3</source>
          <target state="translated">U+003C3</target>
        </trans-unit>
        <trans-unit id="886f6e97a866bf8552f82f80b5cd54d69deb6edc" translate="yes" xml:space="preserve">
          <source>U+003C4</source>
          <target state="translated">U+003C4</target>
        </trans-unit>
        <trans-unit id="37f57a526420b1b434ced0d421633312bfacb43a" translate="yes" xml:space="preserve">
          <source>U+003C5</source>
          <target state="translated">U+003C5</target>
        </trans-unit>
        <trans-unit id="47fa09bd231213c6ef064645c7a9a37d01d7a340" translate="yes" xml:space="preserve">
          <source>U+003C6</source>
          <target state="translated">U+003C6</target>
        </trans-unit>
        <trans-unit id="05bd5f84778ecbe4800ec121d5cff09af25879b2" translate="yes" xml:space="preserve">
          <source>U+003C7</source>
          <target state="translated">U+003C7</target>
        </trans-unit>
        <trans-unit id="721198dd581f50ac452dd324cdd78024e3f0ea83" translate="yes" xml:space="preserve">
          <source>U+003C8</source>
          <target state="translated">U+003C8</target>
        </trans-unit>
        <trans-unit id="cb5185c50b8e1cc18ef11fcd725b6f5f34fbd6be" translate="yes" xml:space="preserve">
          <source>U+003C9</source>
          <target state="translated">U+003C9</target>
        </trans-unit>
        <trans-unit id="9f6a8ca363f10b4b3b309c17eaadf1051f19e694" translate="yes" xml:space="preserve">
          <source>U+003D0</source>
          <target state="translated">U+003D0</target>
        </trans-unit>
        <trans-unit id="bc5c825b8dc84bc4cd8b8d4ea4013440a734f35d" translate="yes" xml:space="preserve">
          <source>U+003D1</source>
          <target state="translated">U+003D1</target>
        </trans-unit>
        <trans-unit id="7aea0cab7b710b4d843d21594fbe14aefcfed4b0" translate="yes" xml:space="preserve">
          <source>U+003D5</source>
          <target state="translated">U+003D5</target>
        </trans-unit>
        <trans-unit id="b4f7595d714f72bfe55c1fcb84a3e89af7755a50" translate="yes" xml:space="preserve">
          <source>U+003D6</source>
          <target state="translated">U+003D6</target>
        </trans-unit>
        <trans-unit id="4401a4d25fbd6623fc6012216b21bcd1a2a739e3" translate="yes" xml:space="preserve">
          <source>U+003D8</source>
          <target state="translated">U+003D8</target>
        </trans-unit>
        <trans-unit id="e478f2f51e8d87db9b42731a4f38cfdf153a1ab7" translate="yes" xml:space="preserve">
          <source>U+003D9</source>
          <target state="translated">U+003D9</target>
        </trans-unit>
        <trans-unit id="fd18e42bf717cf4641f290ef53660e47279580ad" translate="yes" xml:space="preserve">
          <source>U+003DA</source>
          <target state="translated">U+003DA</target>
        </trans-unit>
        <trans-unit id="b675867190ca1ec0938e31a984cdf05979ecd3e0" translate="yes" xml:space="preserve">
          <source>U+003DB</source>
          <target state="translated">U+003DB</target>
        </trans-unit>
        <trans-unit id="92b09d13f646288f372d15ca7398b72236d3e04b" translate="yes" xml:space="preserve">
          <source>U+003DC</source>
          <target state="translated">U+003DC</target>
        </trans-unit>
        <trans-unit id="3ade589f9dd6d374474593df9134c7efebec6b94" translate="yes" xml:space="preserve">
          <source>U+003DD</source>
          <target state="translated">U+003DD</target>
        </trans-unit>
        <trans-unit id="0a92af0f627aa4fcc46123b87ceee9c99b396e0e" translate="yes" xml:space="preserve">
          <source>U+003DE</source>
          <target state="translated">U+003DE</target>
        </trans-unit>
        <trans-unit id="59c206717250d5c1b1abee82cd488c369d4eae18" translate="yes" xml:space="preserve">
          <source>U+003DF</source>
          <target state="translated">U+003DF</target>
        </trans-unit>
        <trans-unit id="5b469342b60deb763e4d94f943821445e3cd4910" translate="yes" xml:space="preserve">
          <source>U+003E0</source>
          <target state="translated">U+003E0</target>
        </trans-unit>
        <trans-unit id="0f3e4bc0231981c839c803015c8410b20dfc4bcd" translate="yes" xml:space="preserve">
          <source>U+003E1</source>
          <target state="translated">U+003E1</target>
        </trans-unit>
        <trans-unit id="07fc86395ddc909da4d31f240fb5e1cb0c418d8e" translate="yes" xml:space="preserve">
          <source>U+003F0</source>
          <target state="translated">U+003F0</target>
        </trans-unit>
        <trans-unit id="07cd0547b13165fe26a097f326f44a691e487328" translate="yes" xml:space="preserve">
          <source>U+003F1</source>
          <target state="translated">U+003F1</target>
        </trans-unit>
        <trans-unit id="7b7b6789e29307728ee9f301af1e0d351e536bf5" translate="yes" xml:space="preserve">
          <source>U+003F4</source>
          <target state="translated">U+003F4</target>
        </trans-unit>
        <trans-unit id="4901bc1852316df9e9dc777fdb7aad5592a6a0f7" translate="yes" xml:space="preserve">
          <source>U+003F5</source>
          <target state="translated">U+003F5</target>
        </trans-unit>
        <trans-unit id="92620f957c75e73c58904d8b0538e74afadfb90c" translate="yes" xml:space="preserve">
          <source>U+003F6</source>
          <target state="translated">U+003F6</target>
        </trans-unit>
        <trans-unit id="c5566e46f42aac1f8e11d42dcfc259d87a7a10fb" translate="yes" xml:space="preserve">
          <source>U+01D2C</source>
          <target state="translated">U+01D2C</target>
        </trans-unit>
        <trans-unit id="37b10b6a06b252506911945e6db92b0b9c6d95f4" translate="yes" xml:space="preserve">
          <source>U+01D2E</source>
          <target state="translated">U+01D2E</target>
        </trans-unit>
        <trans-unit id="a00d8269be4c3eb9f91c1b40696ae76cc8589071" translate="yes" xml:space="preserve">
          <source>U+01D30</source>
          <target state="translated">U+01D30</target>
        </trans-unit>
        <trans-unit id="5c29e525faf0a50aecb6fb3a5f9b7e486e1ef1e9" translate="yes" xml:space="preserve">
          <source>U+01D31</source>
          <target state="translated">U+01D31</target>
        </trans-unit>
        <trans-unit id="99eec604971e8c65be4840320e7a69306ad535a6" translate="yes" xml:space="preserve">
          <source>U+01D33</source>
          <target state="translated">U+01D33</target>
        </trans-unit>
        <trans-unit id="440561aa92670ad776b4e75b23fad5219dee516a" translate="yes" xml:space="preserve">
          <source>U+01D34</source>
          <target state="translated">U+01D34</target>
        </trans-unit>
        <trans-unit id="fbb7a3bc03c96572e4387ff20df34fbc05f8fb3f" translate="yes" xml:space="preserve">
          <source>U+01D35</source>
          <target state="translated">U+01D35</target>
        </trans-unit>
        <trans-unit id="eb47bce466c235deca517ea5540e4d147ebe1a9e" translate="yes" xml:space="preserve">
          <source>U+01D36</source>
          <target state="translated">U+01D36</target>
        </trans-unit>
        <trans-unit id="17959ef44c1b0741106ba78930d26a1c07a3caf0" translate="yes" xml:space="preserve">
          <source>U+01D37</source>
          <target state="translated">U+01D37</target>
        </trans-unit>
        <trans-unit id="cb222e37dc1ee67b19e08f29dd06ed5347e1fa23" translate="yes" xml:space="preserve">
          <source>U+01D38</source>
          <target state="translated">U+01D38</target>
        </trans-unit>
        <trans-unit id="f848ac41c0abe672127b3606e9d0c9b2c905c84b" translate="yes" xml:space="preserve">
          <source>U+01D39</source>
          <target state="translated">U+01D39</target>
        </trans-unit>
        <trans-unit id="156f084d069ee73bdf463b033eff3e6fc5d68a08" translate="yes" xml:space="preserve">
          <source>U+01D3A</source>
          <target state="translated">U+01D3A</target>
        </trans-unit>
        <trans-unit id="c6774c926ad79fecccfd4abca40531a24c3b7a55" translate="yes" xml:space="preserve">
          <source>U+01D3C</source>
          <target state="translated">U+01D3C</target>
        </trans-unit>
        <trans-unit id="20d904a6751c57b2859b8c67b0b30073b01cc53b" translate="yes" xml:space="preserve">
          <source>U+01D3E</source>
          <target state="translated">U+01D3E</target>
        </trans-unit>
        <trans-unit id="d053d05169ebb281dedc9ae9dfe2590a6c369c1d" translate="yes" xml:space="preserve">
          <source>U+01D3F</source>
          <target state="translated">U+01D3F</target>
        </trans-unit>
        <trans-unit id="9b2ab1ad7be189b75bfb7de1714d1ad8a985c107" translate="yes" xml:space="preserve">
          <source>U+01D40</source>
          <target state="translated">U+01D40</target>
        </trans-unit>
        <trans-unit id="34aae8c7365b76e9e21ce5f42ad04f1e94b1f3b8" translate="yes" xml:space="preserve">
          <source>U+01D41</source>
          <target state="translated">U+01D41</target>
        </trans-unit>
        <trans-unit id="441ba9dede9005279c903a6e57f96fe78206c8d8" translate="yes" xml:space="preserve">
          <source>U+01D42</source>
          <target state="translated">U+01D42</target>
        </trans-unit>
        <trans-unit id="163b08686ee14dbd18f23a98a52a47fd62d588ee" translate="yes" xml:space="preserve">
          <source>U+01D43</source>
          <target state="translated">U+01D43</target>
        </trans-unit>
        <trans-unit id="30fdf3ad9db991dd0466575db2f89a26a852c7ee" translate="yes" xml:space="preserve">
          <source>U+01D45</source>
          <target state="translated">U+01D45</target>
        </trans-unit>
        <trans-unit id="797e81a34a07bac310482131acefad71a5abef2d" translate="yes" xml:space="preserve">
          <source>U+01D47</source>
          <target state="translated">U+01D47</target>
        </trans-unit>
        <trans-unit id="a411f60238db6f6b63261d8c07617746ca432266" translate="yes" xml:space="preserve">
          <source>U+01D48</source>
          <target state="translated">U+01D48</target>
        </trans-unit>
        <trans-unit id="c9fb343fc16c5b72e32f29927937a89b7af099fb" translate="yes" xml:space="preserve">
          <source>U+01D49</source>
          <target state="translated">U+01D49</target>
        </trans-unit>
        <trans-unit id="27b54333a235194c6ac53a272d181cb739911513" translate="yes" xml:space="preserve">
          <source>U+01D4B</source>
          <target state="translated">U+01D4B</target>
        </trans-unit>
        <trans-unit id="afb04e59e5d5261a7404bb86c49e2dda11e7d50f" translate="yes" xml:space="preserve">
          <source>U+01D4D</source>
          <target state="translated">U+01D4D</target>
        </trans-unit>
        <trans-unit id="0455ff4d12b80da3fab3d52ffb0b623e56441abb" translate="yes" xml:space="preserve">
          <source>U+01D4F</source>
          <target state="translated">U+01D4F</target>
        </trans-unit>
        <trans-unit id="dbee94c172667d77dbb460fe05b105b373ed9eb9" translate="yes" xml:space="preserve">
          <source>U+01D50</source>
          <target state="translated">U+01D50</target>
        </trans-unit>
        <trans-unit id="ca425c53e63ac2819b4b1438353c6f41043d7a41" translate="yes" xml:space="preserve">
          <source>U+01D52</source>
          <target state="translated">U+01D52</target>
        </trans-unit>
        <trans-unit id="1510ed9914e77d0f8fd3e94ad0c76b070ae53d74" translate="yes" xml:space="preserve">
          <source>U+01D56</source>
          <target state="translated">U+01D56</target>
        </trans-unit>
        <trans-unit id="39f62505bed4b421bf0728e1b93111477d77435c" translate="yes" xml:space="preserve">
          <source>U+01D57</source>
          <target state="translated">U+01D57</target>
        </trans-unit>
        <trans-unit id="8b29aea27d0cf669223fb74be47e4710519173e1" translate="yes" xml:space="preserve">
          <source>U+01D58</source>
          <target state="translated">U+01D58</target>
        </trans-unit>
        <trans-unit id="88779dd2e4508d37bd39f537906180eb80a4ba7b" translate="yes" xml:space="preserve">
          <source>U+01D5B</source>
          <target state="translated">U+01D5B</target>
        </trans-unit>
        <trans-unit id="6c05ec71eeb4ed95030bc369513a9c776e552879" translate="yes" xml:space="preserve">
          <source>U+01D5D</source>
          <target state="translated">U+01D5D</target>
        </trans-unit>
        <trans-unit id="435d4825e1c943f064c7a47783bfcbdf7cde0725" translate="yes" xml:space="preserve">
          <source>U+01D5E</source>
          <target state="translated">U+01D5E</target>
        </trans-unit>
        <trans-unit id="0aa39de854d3a50b9b10d2e69c0d4d92bc238432" translate="yes" xml:space="preserve">
          <source>U+01D5F</source>
          <target state="translated">U+01D5F</target>
        </trans-unit>
        <trans-unit id="4a0cee142db79062d3341c0f8505515c14d123fe" translate="yes" xml:space="preserve">
          <source>U+01D60</source>
          <target state="translated">U+01D60</target>
        </trans-unit>
        <trans-unit id="e741d8c3aa7d60204eda169c57106e15f8882d08" translate="yes" xml:space="preserve">
          <source>U+01D61</source>
          <target state="translated">U+01D61</target>
        </trans-unit>
        <trans-unit id="d4bc07109e6ceceb3eaccbb2b8e8939ab0efbd49" translate="yes" xml:space="preserve">
          <source>U+01D62</source>
          <target state="translated">U+01D62</target>
        </trans-unit>
        <trans-unit id="50763e8cb88d2a94fbd6e8bbf258ac2f3d205929" translate="yes" xml:space="preserve">
          <source>U+01D63</source>
          <target state="translated">U+01D63</target>
        </trans-unit>
        <trans-unit id="346d9c11c21d1b7105090de2749717a2d445a941" translate="yes" xml:space="preserve">
          <source>U+01D64</source>
          <target state="translated">U+01D64</target>
        </trans-unit>
        <trans-unit id="da208e5126e0afc89dce4184ae73f645f4278d97" translate="yes" xml:space="preserve">
          <source>U+01D65</source>
          <target state="translated">U+01D65</target>
        </trans-unit>
        <trans-unit id="822153e6da7056909aa3045783b805c02b93fbc4" translate="yes" xml:space="preserve">
          <source>U+01D66</source>
          <target state="translated">U+01D66</target>
        </trans-unit>
        <trans-unit id="38a14ca2e36f22c3c3809fa99933315f23f92ccc" translate="yes" xml:space="preserve">
          <source>U+01D67</source>
          <target state="translated">U+01D67</target>
        </trans-unit>
        <trans-unit id="20f1483de267b860c85f652204cd1f93f696da21" translate="yes" xml:space="preserve">
          <source>U+01D68</source>
          <target state="translated">U+01D68</target>
        </trans-unit>
        <trans-unit id="233d5e218fc2a0060e8c1bc038d1a74beeb754ce" translate="yes" xml:space="preserve">
          <source>U+01D69</source>
          <target state="translated">U+01D69</target>
        </trans-unit>
        <trans-unit id="5ffdf6e6becfd7d7a6907d2806ba362cb32ee7ab" translate="yes" xml:space="preserve">
          <source>U+01D6A</source>
          <target state="translated">U+01D6A</target>
        </trans-unit>
        <trans-unit id="54a5801c603f0530be0e5268e32f06e62414e7cc" translate="yes" xml:space="preserve">
          <source>U+01D9C</source>
          <target state="translated">U+01D9C</target>
        </trans-unit>
        <trans-unit id="e2edeb19ea8e681fefbd9a4bcbfe98ba0e602949" translate="yes" xml:space="preserve">
          <source>U+01DA0</source>
          <target state="translated">U+01DA0</target>
        </trans-unit>
        <trans-unit id="c8b08720266cd22f34f16a43a75856cd70610c2e" translate="yes" xml:space="preserve">
          <source>U+01DA5</source>
          <target state="translated">U+01DA5</target>
        </trans-unit>
        <trans-unit id="c4ee296bbf06e4d45d1ea5ed87a8a04b75e1e207" translate="yes" xml:space="preserve">
          <source>U+01DB2</source>
          <target state="translated">U+01DB2</target>
        </trans-unit>
        <trans-unit id="a44d758f0df9a4bfd941e5517bb24c8174dacfc6" translate="yes" xml:space="preserve">
          <source>U+01DBB</source>
          <target state="translated">U+01DBB</target>
        </trans-unit>
        <trans-unit id="9465fb99cea4715205a1c75bb4fce4ef25e41dcd" translate="yes" xml:space="preserve">
          <source>U+01DBF</source>
          <target state="translated">U+01DBF</target>
        </trans-unit>
        <trans-unit id="3de5f445040ec9f82e5d0f7be1114da98b3824e9" translate="yes" xml:space="preserve">
          <source>U+02002</source>
          <target state="translated">U+02002</target>
        </trans-unit>
        <trans-unit id="7ed4f9267e6ab7118d848989813ef0313baef1c1" translate="yes" xml:space="preserve">
          <source>U+02003</source>
          <target state="translated">U+02003</target>
        </trans-unit>
        <trans-unit id="42f12996d3ec39f6df05c0141c3c1c2960e3b4d3" translate="yes" xml:space="preserve">
          <source>U+02005</source>
          <target state="translated">U+02005</target>
        </trans-unit>
        <trans-unit id="dc54e003671d7d9356c197db1df194b01cdc025f" translate="yes" xml:space="preserve">
          <source>U+02009</source>
          <target state="translated">U+02009</target>
        </trans-unit>
        <trans-unit id="6d199f8b861652f6b03dd0371fdf6cef0a20bb9e" translate="yes" xml:space="preserve">
          <source>U+0200A</source>
          <target state="translated">U+0200A</target>
        </trans-unit>
        <trans-unit id="54b2c267ddbbf1a38b0df143b7feae19c2b3b675" translate="yes" xml:space="preserve">
          <source>U+02013</source>
          <target state="translated">U+02013</target>
        </trans-unit>
        <trans-unit id="91a455cf9bf5641d8dcb36e61a713b743388b2b9" translate="yes" xml:space="preserve">
          <source>U+02014</source>
          <target state="translated">U+02014</target>
        </trans-unit>
        <trans-unit id="871fd5b4639ffc22262b27271eebe1f5a15dfa8b" translate="yes" xml:space="preserve">
          <source>U+02016</source>
          <target state="translated">U+02016</target>
        </trans-unit>
        <trans-unit id="01237e76c48f125ae7368ff228668715b09fd166" translate="yes" xml:space="preserve">
          <source>U+02018</source>
          <target state="translated">U+02018</target>
        </trans-unit>
        <trans-unit id="0eb233c9d60b05a1ebd74cbe88384226b43cdb6d" translate="yes" xml:space="preserve">
          <source>U+02019</source>
          <target state="translated">U+02019</target>
        </trans-unit>
        <trans-unit id="27981c42fbe101279cd9112d5d0e4a5967f72e54" translate="yes" xml:space="preserve">
          <source>U+0201B</source>
          <target state="translated">U+0201B</target>
        </trans-unit>
        <trans-unit id="fec2f513e523c411070eaf46be64b07cf927cbba" translate="yes" xml:space="preserve">
          <source>U+0201C</source>
          <target state="translated">U+0201C</target>
        </trans-unit>
        <trans-unit id="05b273439e23dbd70de0618defd73bd52fafefd8" translate="yes" xml:space="preserve">
          <source>U+0201D</source>
          <target state="translated">U+0201D</target>
        </trans-unit>
        <trans-unit id="d9a8337f65d4bfe3fdd44241cb7c936971b12090" translate="yes" xml:space="preserve">
          <source>U+02020</source>
          <target state="translated">U+02020</target>
        </trans-unit>
        <trans-unit id="51e65c64dccac09993ecb39aba5db77093ced71a" translate="yes" xml:space="preserve">
          <source>U+02021</source>
          <target state="translated">U+02021</target>
        </trans-unit>
        <trans-unit id="6a89805f557530dd85e0f992fd6f2b9ab2119a0f" translate="yes" xml:space="preserve">
          <source>U+02022</source>
          <target state="translated">U+02022</target>
        </trans-unit>
        <trans-unit id="606d247e38e4f88d07ac7af7b3a2988d674ab100" translate="yes" xml:space="preserve">
          <source>U+02026</source>
          <target state="translated">U+02026</target>
        </trans-unit>
        <trans-unit id="7069c8a14244c42d1eb9eeafe2a54d3707e415a2" translate="yes" xml:space="preserve">
          <source>U+02030</source>
          <target state="translated">U+02030</target>
        </trans-unit>
        <trans-unit id="51ee0c647f9e7d54d78c0bca676090c3ed3a58ab" translate="yes" xml:space="preserve">
          <source>U+02031</source>
          <target state="translated">U+02031</target>
        </trans-unit>
        <trans-unit id="d35b0db70efbcf055ebe5d255382dac5a8c513a9" translate="yes" xml:space="preserve">
          <source>U+02032</source>
          <target state="translated">U+02032</target>
        </trans-unit>
        <trans-unit id="aff69f7e2c75a413ebf0ae8e5e2e3274abef57cf" translate="yes" xml:space="preserve">
          <source>U+02033</source>
          <target state="translated">U+02033</target>
        </trans-unit>
        <trans-unit id="5d913be71042ef8f5aaec8feff826a19c6bafa80" translate="yes" xml:space="preserve">
          <source>U+02034</source>
          <target state="translated">U+02034</target>
        </trans-unit>
        <trans-unit id="16c2015f83babb15b41b582ae1ad4b93020c1e8e" translate="yes" xml:space="preserve">
          <source>U+02035</source>
          <target state="translated">U+02035</target>
        </trans-unit>
        <trans-unit id="7e44d236062ccca1c221b6d032404da42950e91e" translate="yes" xml:space="preserve">
          <source>U+02036</source>
          <target state="translated">U+02036</target>
        </trans-unit>
        <trans-unit id="2844451d093078b267408c29d08b80334758c880" translate="yes" xml:space="preserve">
          <source>U+02037</source>
          <target state="translated">U+02037</target>
        </trans-unit>
        <trans-unit id="98711fdfbbcf42c62a5faf024882880528e15cf8" translate="yes" xml:space="preserve">
          <source>U+02039</source>
          <target state="translated">U+02039</target>
        </trans-unit>
        <trans-unit id="41ffd3912c77f96e037ea691fad61cdbf02c8b23" translate="yes" xml:space="preserve">
          <source>U+0203A</source>
          <target state="translated">U+0203A</target>
        </trans-unit>
        <trans-unit id="b8dc2d1d755a5fdfbc9b3bf3479d34e1c241cadf" translate="yes" xml:space="preserve">
          <source>U+0203C</source>
          <target state="translated">U+0203C</target>
        </trans-unit>
        <trans-unit id="09fd53c1a858647b42d511d9c015fee67fb9445c" translate="yes" xml:space="preserve">
          <source>U+02040</source>
          <target state="translated">U+02040</target>
        </trans-unit>
        <trans-unit id="b477796eb380471732cec950b3b8f7940a1e7e45" translate="yes" xml:space="preserve">
          <source>U+02049</source>
          <target state="translated">U+02049</target>
        </trans-unit>
        <trans-unit id="ca926b0118288b830cb51c220e41ee7e352a28a9" translate="yes" xml:space="preserve">
          <source>U+02057</source>
          <target state="translated">U+02057</target>
        </trans-unit>
        <trans-unit id="1bc69948707de37d18ec28f69dd19f065541aae7" translate="yes" xml:space="preserve">
          <source>U+0205D</source>
          <target state="translated">U+0205D</target>
        </trans-unit>
        <trans-unit id="d39d51da22a7906847da6453bde31ff3b754dfa9" translate="yes" xml:space="preserve">
          <source>U+02060</source>
          <target state="translated">U+02060</target>
        </trans-unit>
        <trans-unit id="1efdd22dc573d2edef8ee5ea3382e63d224d137e" translate="yes" xml:space="preserve">
          <source>U+02070</source>
          <target state="translated">U+02070</target>
        </trans-unit>
        <trans-unit id="1dc71366ffb5b8b3e001f3a9aa2f6bb12d28be57" translate="yes" xml:space="preserve">
          <source>U+02071</source>
          <target state="translated">U+02071</target>
        </trans-unit>
        <trans-unit id="4dd066f38efb209c9f79538e5a2ea272214b954d" translate="yes" xml:space="preserve">
          <source>U+02074</source>
          <target state="translated">U+02074</target>
        </trans-unit>
        <trans-unit id="f9ddb001c9f5fd2e27fbae237f25c28b8f5ae871" translate="yes" xml:space="preserve">
          <source>U+02075</source>
          <target state="translated">U+02075</target>
        </trans-unit>
        <trans-unit id="cdd7f27ef18f2611da391c880f368056e0477cc1" translate="yes" xml:space="preserve">
          <source>U+02076</source>
          <target state="translated">U+02076</target>
        </trans-unit>
        <trans-unit id="1aef93443bcba12e0e269ea6437722a5efd9165b" translate="yes" xml:space="preserve">
          <source>U+02077</source>
          <target state="translated">U+02077</target>
        </trans-unit>
        <trans-unit id="9dff77c28d6e4f9f9a7a07a1a99dbfde46ad0e2d" translate="yes" xml:space="preserve">
          <source>U+02078</source>
          <target state="translated">U+02078</target>
        </trans-unit>
        <trans-unit id="ca05f7941a68cd5dbe4ad921bce62a99bc20a13e" translate="yes" xml:space="preserve">
          <source>U+02079</source>
          <target state="translated">U+02079</target>
        </trans-unit>
        <trans-unit id="18a3eef792215619326e47c5780075df279de886" translate="yes" xml:space="preserve">
          <source>U+0207A</source>
          <target state="translated">U+0207A</target>
        </trans-unit>
        <trans-unit id="6859918ed86a97585a8af7827424e777f0012f32" translate="yes" xml:space="preserve">
          <source>U+0207B</source>
          <target state="translated">U+0207B</target>
        </trans-unit>
        <trans-unit id="4f9765389af5519dc7a0d091c472c04d25872e51" translate="yes" xml:space="preserve">
          <source>U+0207C</source>
          <target state="translated">U+0207C</target>
        </trans-unit>
        <trans-unit id="dbd3025a6eeefb504b83034db7784310cd98a7b8" translate="yes" xml:space="preserve">
          <source>U+0207D</source>
          <target state="translated">U+0207D</target>
        </trans-unit>
        <trans-unit id="2a01a9a590ac5e58a83b33d92499326aa532de31" translate="yes" xml:space="preserve">
          <source>U+0207E</source>
          <target state="translated">U+0207E</target>
        </trans-unit>
        <trans-unit id="522f4f2ebb95bd280743693b122524e8e120ca0b" translate="yes" xml:space="preserve">
          <source>U+0207F</source>
          <target state="translated">U+0207F</target>
        </trans-unit>
        <trans-unit id="854460d95686b5484c63e7b1c97dc7aec182f465" translate="yes" xml:space="preserve">
          <source>U+02080</source>
          <target state="translated">U+02080</target>
        </trans-unit>
        <trans-unit id="bb66a953411c5a7aa98e0ccd90b088e7efca0359" translate="yes" xml:space="preserve">
          <source>U+02081</source>
          <target state="translated">U+02081</target>
        </trans-unit>
        <trans-unit id="0c9776b8d8584f3558900c0e35ed1c199b85dc56" translate="yes" xml:space="preserve">
          <source>U+02082</source>
          <target state="translated">U+02082</target>
        </trans-unit>
        <trans-unit id="188629784648ed64f4880102c6ef53e00c48260f" translate="yes" xml:space="preserve">
          <source>U+02083</source>
          <target state="translated">U+02083</target>
        </trans-unit>
        <trans-unit id="ced37ed4c1992fa0c2e4792186605cdbbfe0813b" translate="yes" xml:space="preserve">
          <source>U+02084</source>
          <target state="translated">U+02084</target>
        </trans-unit>
        <trans-unit id="1c6821bf6c9d056467564e078d12132617914b74" translate="yes" xml:space="preserve">
          <source>U+02085</source>
          <target state="translated">U+02085</target>
        </trans-unit>
        <trans-unit id="f2c71c2c5946e5589ab2fbec4497aea575670406" translate="yes" xml:space="preserve">
          <source>U+02086</source>
          <target state="translated">U+02086</target>
        </trans-unit>
        <trans-unit id="f8b7a8d02fe7d8fd1e4e41165a96012f3085e3aa" translate="yes" xml:space="preserve">
          <source>U+02087</source>
          <target state="translated">U+02087</target>
        </trans-unit>
        <trans-unit id="e83c0c08dcd85b6a1d1e03d24eb32bfacef748a3" translate="yes" xml:space="preserve">
          <source>U+02088</source>
          <target state="translated">U+02088</target>
        </trans-unit>
        <trans-unit id="88afb3350de2e79fc09ed34801b089b50c323102" translate="yes" xml:space="preserve">
          <source>U+02089</source>
          <target state="translated">U+02089</target>
        </trans-unit>
        <trans-unit id="477cf57fceee603207b7029bea84e0d917ed01f2" translate="yes" xml:space="preserve">
          <source>U+0208A</source>
          <target state="translated">U+0208A</target>
        </trans-unit>
        <trans-unit id="23ef044b8d9c1cffcbe8f0bcd2bcd3dc5402e505" translate="yes" xml:space="preserve">
          <source>U+0208B</source>
          <target state="translated">U+0208B</target>
        </trans-unit>
        <trans-unit id="c6576c517955cbddf0fd30aec93e93789c487e12" translate="yes" xml:space="preserve">
          <source>U+0208C</source>
          <target state="translated">U+0208C</target>
        </trans-unit>
        <trans-unit id="d8029bd98cc0ac6ce5f6867fe9af4fb3de6a6b00" translate="yes" xml:space="preserve">
          <source>U+0208D</source>
          <target state="translated">U+0208D</target>
        </trans-unit>
        <trans-unit id="26b965df9ca2cbda682041b8cec3843d73d50b3d" translate="yes" xml:space="preserve">
          <source>U+0208E</source>
          <target state="translated">U+0208E</target>
        </trans-unit>
        <trans-unit id="da03f3f8ee238f200d4eddc0c4bd224192f75622" translate="yes" xml:space="preserve">
          <source>U+02090</source>
          <target state="translated">U+02090</target>
        </trans-unit>
        <trans-unit id="e7a5cb7c2c27388b416316e0acd0df63aef6d4f3" translate="yes" xml:space="preserve">
          <source>U+02091</source>
          <target state="translated">U+02091</target>
        </trans-unit>
        <trans-unit id="1a07878c5fdec82f99db1dc83ca11685edb72205" translate="yes" xml:space="preserve">
          <source>U+02092</source>
          <target state="translated">U+02092</target>
        </trans-unit>
        <trans-unit id="d85957c055f87ab66f8bb33e718c3eaf011c2d48" translate="yes" xml:space="preserve">
          <source>U+02093</source>
          <target state="translated">U+02093</target>
        </trans-unit>
        <trans-unit id="fc73e56e067c604fb38ed9d86ccf090e38a9f7c9" translate="yes" xml:space="preserve">
          <source>U+02094</source>
          <target state="translated">U+02094</target>
        </trans-unit>
        <trans-unit id="f890547c349527828a298f56e7fdc0da52c6e83a" translate="yes" xml:space="preserve">
          <source>U+02095</source>
          <target state="translated">U+02095</target>
        </trans-unit>
        <trans-unit id="5fd296e5bda2cce5c69dd8bd57d96e1e0d22b9b2" translate="yes" xml:space="preserve">
          <source>U+02096</source>
          <target state="translated">U+02096</target>
        </trans-unit>
        <trans-unit id="5c1c15f178eb0b654388c5f6475b3ba25b33c6dd" translate="yes" xml:space="preserve">
          <source>U+02097</source>
          <target state="translated">U+02097</target>
        </trans-unit>
        <trans-unit id="9d30a621292caf7bece2e9ce2d8b9581d55c8f2e" translate="yes" xml:space="preserve">
          <source>U+02098</source>
          <target state="translated">U+02098</target>
        </trans-unit>
        <trans-unit id="7e31400a5922fae3a81d4a1c28d6ad22d2bb926a" translate="yes" xml:space="preserve">
          <source>U+02099</source>
          <target state="translated">U+02099</target>
        </trans-unit>
        <trans-unit id="b8e32228d0b21d4afdfb09b9eb01835c4488956d" translate="yes" xml:space="preserve">
          <source>U+0209A</source>
          <target state="translated">U+0209A</target>
        </trans-unit>
        <trans-unit id="4ae8c33eeb20b986b3a68dd5c8f755537da0cc35" translate="yes" xml:space="preserve">
          <source>U+0209B</source>
          <target state="translated">U+0209B</target>
        </trans-unit>
        <trans-unit id="22883db9c2eae90f058a6ec060a0a1d7934fc524" translate="yes" xml:space="preserve">
          <source>U+0209C</source>
          <target state="translated">U+0209C</target>
        </trans-unit>
        <trans-unit id="a770d073d828312a3f412b4d196fcea78f022c6b" translate="yes" xml:space="preserve">
          <source>U+020A7</source>
          <target state="translated">U+020A7</target>
        </trans-unit>
        <trans-unit id="cec998138ab5bb31b2262d17296ad23086f8304d" translate="yes" xml:space="preserve">
          <source>U+020AC</source>
          <target state="translated">U+020AC</target>
        </trans-unit>
        <trans-unit id="be69f61217e1f1748ad03bdc4546176950dda473" translate="yes" xml:space="preserve">
          <source>U+020D0</source>
          <target state="translated">U+020D0</target>
        </trans-unit>
        <trans-unit id="ce511e7f9775929b60852032b4fa5b32681c7cb8" translate="yes" xml:space="preserve">
          <source>U+020D1</source>
          <target state="translated">U+020D1</target>
        </trans-unit>
        <trans-unit id="91b07feaa744c6688774083feb3443b13189fb5f" translate="yes" xml:space="preserve">
          <source>U+020D2</source>
          <target state="translated">U+020D2</target>
        </trans-unit>
        <trans-unit id="af681668f18319aab998e021e28763dd7d0f3f17" translate="yes" xml:space="preserve">
          <source>U+020D6</source>
          <target state="translated">U+020D6</target>
        </trans-unit>
        <trans-unit id="570c4c40f536d880f35d90049a5fc80334ded35b" translate="yes" xml:space="preserve">
          <source>U+020D7</source>
          <target state="translated">U+020D7</target>
        </trans-unit>
        <trans-unit id="f9c8acbccb3bb9e59c23842d6854d6ffe3cda209" translate="yes" xml:space="preserve">
          <source>U+020DB</source>
          <target state="translated">U+020DB</target>
        </trans-unit>
        <trans-unit id="124a18fae2c40bf7ad2fc342bead50ee6a3edb2e" translate="yes" xml:space="preserve">
          <source>U+020DC</source>
          <target state="translated">U+020DC</target>
        </trans-unit>
        <trans-unit id="9fcbf1d8195b405d6c289e7de0d461ccdeb5126d" translate="yes" xml:space="preserve">
          <source>U+020DD</source>
          <target state="translated">U+020DD</target>
        </trans-unit>
        <trans-unit id="12f776f6e3a074855f26553b489117cb5664c07d" translate="yes" xml:space="preserve">
          <source>U+020DE</source>
          <target state="translated">U+020DE</target>
        </trans-unit>
        <trans-unit id="476a6d0d44d7e0ee0c7a1eb7300c6ccb5e8e8819" translate="yes" xml:space="preserve">
          <source>U+020DF</source>
          <target state="translated">U+020DF</target>
        </trans-unit>
        <trans-unit id="36a22cb9ea7baffde06e396cfebdc0661c04e913" translate="yes" xml:space="preserve">
          <source>U+020E1</source>
          <target state="translated">U+020E1</target>
        </trans-unit>
        <trans-unit id="4fd6aa654f40bc0d1fec9761c3b30fa972c4b26e" translate="yes" xml:space="preserve">
          <source>U+020E4</source>
          <target state="translated">U+020E4</target>
        </trans-unit>
        <trans-unit id="e63bdbad9a6fbf0dbf6715d8bec7bcd775432592" translate="yes" xml:space="preserve">
          <source>U+020E7</source>
          <target state="translated">U+020E7</target>
        </trans-unit>
        <trans-unit id="b1a6163cfe2122326bc02c224adf7f8d6e5ffba7" translate="yes" xml:space="preserve">
          <source>U+020E8</source>
          <target state="translated">U+020E8</target>
        </trans-unit>
        <trans-unit id="3850520adad69b9d57a55e0a79e674a7bf6967c2" translate="yes" xml:space="preserve">
          <source>U+020E9</source>
          <target state="translated">U+020E9</target>
        </trans-unit>
        <trans-unit id="e45a7120fdc5d1b21987b099aeed9919e3d159bf" translate="yes" xml:space="preserve">
          <source>U+020EC</source>
          <target state="translated">U+020EC</target>
        </trans-unit>
        <trans-unit id="96a99a0c9bbd7eaa955fe8b3d30fe4dfec582fd9" translate="yes" xml:space="preserve">
          <source>U+020ED</source>
          <target state="translated">U+020ED</target>
        </trans-unit>
        <trans-unit id="3babb4708c5e4b432d55e2eff2f03ed9b62870db" translate="yes" xml:space="preserve">
          <source>U+020EE</source>
          <target state="translated">U+020EE</target>
        </trans-unit>
        <trans-unit id="fc835fa7d02a8c817884cb00384b5e9922183683" translate="yes" xml:space="preserve">
          <source>U+020EF</source>
          <target state="translated">U+020EF</target>
        </trans-unit>
        <trans-unit id="0c6129bb507bb470263fc68a8d02831a53adfac3" translate="yes" xml:space="preserve">
          <source>U+020F0</source>
          <target state="translated">U+020F0</target>
        </trans-unit>
        <trans-unit id="2adc2c6bebe3339c446d7e23907f1dc655e420a2" translate="yes" xml:space="preserve">
          <source>U+02102</source>
          <target state="translated">U+02102</target>
        </trans-unit>
        <trans-unit id="2afc9e72e8df124d80b35edc62c73cb1f19c10d6" translate="yes" xml:space="preserve">
          <source>U+02107</source>
          <target state="translated">U+02107</target>
        </trans-unit>
        <trans-unit id="ebfed4281bd65acfa46591c8ddd1317cfd1b5242" translate="yes" xml:space="preserve">
          <source>U+0210A</source>
          <target state="translated">U+0210A</target>
        </trans-unit>
        <trans-unit id="024787cf22bf2842dba0be7847ca8f38dc5fa7b4" translate="yes" xml:space="preserve">
          <source>U+0210B</source>
          <target state="translated">U+0210B</target>
        </trans-unit>
        <trans-unit id="2feefe2362663ee1ffb0fc6da3896a6df35b143e" translate="yes" xml:space="preserve">
          <source>U+0210C</source>
          <target state="translated">U+0210C</target>
        </trans-unit>
        <trans-unit id="663f2a23d864546260f30cd2d124b343002e3958" translate="yes" xml:space="preserve">
          <source>U+0210D</source>
          <target state="translated">U+0210D</target>
        </trans-unit>
        <trans-unit id="fbc22138cd7a815897649944bd0296b4b1707e29" translate="yes" xml:space="preserve">
          <source>U+0210E</source>
          <target state="translated">U+0210E</target>
        </trans-unit>
        <trans-unit id="8258fdd464e12d5471e5dccf50cccae82495f1a1" translate="yes" xml:space="preserve">
          <source>U+0210F</source>
          <target state="translated">U+0210F</target>
        </trans-unit>
        <trans-unit id="517e7c3cf117e768d82906bdea2b9d73b0d093b9" translate="yes" xml:space="preserve">
          <source>U+02110</source>
          <target state="translated">U+02110</target>
        </trans-unit>
        <trans-unit id="bca7eb892f1a6edce7356fe44b05b07629e09e34" translate="yes" xml:space="preserve">
          <source>U+02111</source>
          <target state="translated">U+02111</target>
        </trans-unit>
        <trans-unit id="bee1d61c619164abe275a3c3556fbb2ac4e97e19" translate="yes" xml:space="preserve">
          <source>U+02112</source>
          <target state="translated">U+02112</target>
        </trans-unit>
        <trans-unit id="342959e0e16070b1247f1f44564ecb3ec9396b91" translate="yes" xml:space="preserve">
          <source>U+02113</source>
          <target state="translated">U+02113</target>
        </trans-unit>
        <trans-unit id="298b156c4985cc6f1df475cf209f863ef4cc4b3a" translate="yes" xml:space="preserve">
          <source>U+02115</source>
          <target state="translated">U+02115</target>
        </trans-unit>
        <trans-unit id="456a13c7b9fab48f48291b017dd4ee50155f5964" translate="yes" xml:space="preserve">
          <source>U+02116</source>
          <target state="translated">U+02116</target>
        </trans-unit>
        <trans-unit id="325b4a2c0faae3a209a87bf5e3a5c83401a0aaff" translate="yes" xml:space="preserve">
          <source>U+02118</source>
          <target state="translated">U+02118</target>
        </trans-unit>
        <trans-unit id="dae9b18d73050b644687a61effdf17b8f841e040" translate="yes" xml:space="preserve">
          <source>U+02119</source>
          <target state="translated">U+02119</target>
        </trans-unit>
        <trans-unit id="8288406fd14e141f15c517704db3a02746c05fba" translate="yes" xml:space="preserve">
          <source>U+0211A</source>
          <target state="translated">U+0211A</target>
        </trans-unit>
        <trans-unit id="a23b5f3fd36ff2842b6c25933ff3f70b6fd66af2" translate="yes" xml:space="preserve">
          <source>U+0211B</source>
          <target state="translated">U+0211B</target>
        </trans-unit>
        <trans-unit id="72a9ec39387b201efc778708d7f6d52069ad7b13" translate="yes" xml:space="preserve">
          <source>U+0211C</source>
          <target state="translated">U+0211C</target>
        </trans-unit>
        <trans-unit id="9dfccf15a23a02ba3b953d1c7d7f6abc05fa682c" translate="yes" xml:space="preserve">
          <source>U+0211D</source>
          <target state="translated">U+0211D</target>
        </trans-unit>
        <trans-unit id="6c51822bf19550c0ee6d5a384cc0cf486b30a8f4" translate="yes" xml:space="preserve">
          <source>U+0211E</source>
          <target state="translated">U+0211E</target>
        </trans-unit>
        <trans-unit id="0a39b4ce2d86e268da567ab2a2a342737157f4f7" translate="yes" xml:space="preserve">
          <source>U+02122</source>
          <target state="translated">U+02122</target>
        </trans-unit>
        <trans-unit id="ff13fb5cd296523bc4b707cf6e46dc6766380430" translate="yes" xml:space="preserve">
          <source>U+02124</source>
          <target state="translated">U+02124</target>
        </trans-unit>
        <trans-unit id="f037e7e6304e03a5f7f4aac86130df6dc576311a" translate="yes" xml:space="preserve">
          <source>U+02126</source>
          <target state="translated">U+02126</target>
        </trans-unit>
        <trans-unit id="7d2655b3517935e484d6b1a4e997ff5843a31e87" translate="yes" xml:space="preserve">
          <source>U+02127</source>
          <target state="translated">U+02127</target>
        </trans-unit>
        <trans-unit id="cb7b969c3501850a4060cfd7e7f59c0da7c3cb7c" translate="yes" xml:space="preserve">
          <source>U+02128</source>
          <target state="translated">U+02128</target>
        </trans-unit>
        <trans-unit id="b79f1ccc58a0757660d0bc91a00ac119559e2338" translate="yes" xml:space="preserve">
          <source>U+02129</source>
          <target state="translated">U+02129</target>
        </trans-unit>
        <trans-unit id="239a3c1c1d9c7ae49e284a49968bcabd8c5b7042" translate="yes" xml:space="preserve">
          <source>U+0212B</source>
          <target state="translated">U+0212B</target>
        </trans-unit>
        <trans-unit id="92faddf2df3101e2ea354ca32e0b3f3543850210" translate="yes" xml:space="preserve">
          <source>U+0212C</source>
          <target state="translated">U+0212C</target>
        </trans-unit>
        <trans-unit id="36e6bb2196feb03f4b43d924bb79e3c8be31b9a9" translate="yes" xml:space="preserve">
          <source>U+0212D</source>
          <target state="translated">U+0212D</target>
        </trans-unit>
        <trans-unit id="16660c15da1843f5c1a0edfd5cb7b5a695e2e521" translate="yes" xml:space="preserve">
          <source>U+0212F</source>
          <target state="translated">U+0212F</target>
        </trans-unit>
        <trans-unit id="aaeb74116b049a77e6ec9ce1d001dfd92cbaf0c5" translate="yes" xml:space="preserve">
          <source>U+02130</source>
          <target state="translated">U+02130</target>
        </trans-unit>
        <trans-unit id="8dd9faccb501c29739c49458d2a93b67ef810716" translate="yes" xml:space="preserve">
          <source>U+02131</source>
          <target state="translated">U+02131</target>
        </trans-unit>
        <trans-unit id="e099608b2d63cb110f6dac82c14749c62295dc74" translate="yes" xml:space="preserve">
          <source>U+02132</source>
          <target state="translated">U+02132</target>
        </trans-unit>
        <trans-unit id="7fce3e99b8d386428a44b9ba9cd77168f4a90b54" translate="yes" xml:space="preserve">
          <source>U+02133</source>
          <target state="translated">U+02133</target>
        </trans-unit>
        <trans-unit id="0fc13fe64d053aa6289ea319c71a4691d5ed6634" translate="yes" xml:space="preserve">
          <source>U+02134</source>
          <target state="translated">U+02134</target>
        </trans-unit>
        <trans-unit id="1563aedef419208c50595e16109be4c42f5a4364" translate="yes" xml:space="preserve">
          <source>U+02135</source>
          <target state="translated">U+02135</target>
        </trans-unit>
        <trans-unit id="3891e0fc176e12065431c43db1f74fc494411f82" translate="yes" xml:space="preserve">
          <source>U+02136</source>
          <target state="translated">U+02136</target>
        </trans-unit>
        <trans-unit id="a593920648b7a0628980af8818432607aee2b26b" translate="yes" xml:space="preserve">
          <source>U+02137</source>
          <target state="translated">U+02137</target>
        </trans-unit>
        <trans-unit id="09c96fc69d62f78396fe578ae0a734946ca45119" translate="yes" xml:space="preserve">
          <source>U+02138</source>
          <target state="translated">U+02138</target>
        </trans-unit>
        <trans-unit id="9fd776e8fb45b0a99d86b77b183c64b5128e4853" translate="yes" xml:space="preserve">
          <source>U+02139</source>
          <target state="translated">U+02139</target>
        </trans-unit>
        <trans-unit id="d0888576b0913d65a8450a31d9441aaccf7e4435" translate="yes" xml:space="preserve">
          <source>U+0213C</source>
          <target state="translated">U+0213C</target>
        </trans-unit>
        <trans-unit id="fb3fbd77e803f3bf4cab253f0bf3f908c7ad718c" translate="yes" xml:space="preserve">
          <source>U+0213D</source>
          <target state="translated">U+0213D</target>
        </trans-unit>
        <trans-unit id="e440bfd991013a84e4602155792d47bba2093ba8" translate="yes" xml:space="preserve">
          <source>U+0213E</source>
          <target state="translated">U+0213E</target>
        </trans-unit>
        <trans-unit id="29227106656a985eab84a0e228e588ed042c2b81" translate="yes" xml:space="preserve">
          <source>U+0213F</source>
          <target state="translated">U+0213F</target>
        </trans-unit>
        <trans-unit id="fb9d15cdeb6082c60f875c40cf5bf8071c89e5a0" translate="yes" xml:space="preserve">
          <source>U+02140</source>
          <target state="translated">U+02140</target>
        </trans-unit>
        <trans-unit id="25c33074d8075a29f499832613c3cbf490c765f4" translate="yes" xml:space="preserve">
          <source>U+02141</source>
          <target state="translated">U+02141</target>
        </trans-unit>
        <trans-unit id="8d593c3ede8a900f775ba49e99e44b2441f0a82a" translate="yes" xml:space="preserve">
          <source>U+02142</source>
          <target state="translated">U+02142</target>
        </trans-unit>
        <trans-unit id="e15e780412bb80d5134e94a8aaf019527b157036" translate="yes" xml:space="preserve">
          <source>U+02143</source>
          <target state="translated">U+02143</target>
        </trans-unit>
        <trans-unit id="0985adfd896a1876bf4859487cc1416a43097be3" translate="yes" xml:space="preserve">
          <source>U+02144</source>
          <target state="translated">U+02144</target>
        </trans-unit>
        <trans-unit id="e5df3ea43ae68e5c9216957b9ac77eebbf312d22" translate="yes" xml:space="preserve">
          <source>U+02145</source>
          <target state="translated">U+02145</target>
        </trans-unit>
        <trans-unit id="aad47338d4f31abfaf8fecb938a8c63fc984db6b" translate="yes" xml:space="preserve">
          <source>U+02146</source>
          <target state="translated">U+02146</target>
        </trans-unit>
        <trans-unit id="4836d6e98db2972df1e4babecc7404f8bc565dec" translate="yes" xml:space="preserve">
          <source>U+02147</source>
          <target state="translated">U+02147</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
