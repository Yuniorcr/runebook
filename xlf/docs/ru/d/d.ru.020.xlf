<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="cb1503c554d562fcb4fdd362460ca0e88facc2f1" translate="yes" xml:space="preserve">
          <source>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union returns a tuple with one element &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Получить как кортеж типы полей структуры, класса или объединения. Он состоит из полей, занимающих место в памяти, за исключением скрытых полей, таких как указатель таблицы виртуальной функции или указатель контекста для вложенных типов. Если &lt;code&gt;T&lt;/code&gt; не является структура, класс или объединение возвращает кортеж с одним элементом &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8352810d8951fe7d425bf1322ba1521329088590" translate="yes" xml:space="preserve">
          <source>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union, an expression tuple with an empty string is returned.</source>
          <target state="translated">Получить в качестве выражения кортежи имен полей структуры, класса или объединения. Он состоит из полей, занимающих место в памяти, за исключением скрытых полей, таких как указатель таблицы виртуальной функции или указатель контекста для вложенных типов. Унаследованные поля (для классов) не включены. Если &lt;code&gt;T&lt;/code&gt; не является структурой, классом или объединением, возвращается кортеж выражения с пустой строкой.</target>
        </trans-unit>
        <trans-unit id="a198ff5da76a4a9aab19b26589c9b2c10f34f479" translate="yes" xml:space="preserve">
          <source>Get creation/access/modified times of file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Получить доступ / создание / измененные времена файла &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="691bafc770aff46bbe0856f713e81a3d1edbf405" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in SIMD register(s) if available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0005ffe3affeeb682da9580156ed97b001d178e" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in XMM register</source>
          <target state="translated">Получить флаги для типа:1 означает,что GC должен сканировать указатели,2 означает,что в регистре XMM передается аргумент этого типа.</target>
        </trans-unit>
        <trans-unit id="d67dceb8ecd32907f4c80efef5b62cf3e873c8e4" translate="yes" xml:space="preserve">
          <source>Get index of field. Returns -1 if not found.</source>
          <target state="translated">Получить индекс поля.Возвращает -1,если не найден.</target>
        </trans-unit>
        <trans-unit id="7cbd98494450e74ae712eba7afdee4e2a97eaec8" translate="yes" xml:space="preserve">
          <source>Get nth Parameter, folding in tuples.</source>
          <target state="translated">Получить nth Parameter,складывать кортежи.</target>
        </trans-unit>
        <trans-unit id="b0d99cd151ddfeaf2b13f0d9a95c891f89fbb223" translate="yes" xml:space="preserve">
          <source>Get offset of base class's vtbl[] initializer from start of csym. Returns ~0 if not this csym.</source>
          <target state="translated">Получить смещение инициализатора базового класса vtbl[]от старта csym.Возвращает ~0,если не этот ксим.</target>
        </trans-unit>
        <trans-unit id="188a425106e789190ec847f6a6792e93a54341a7" translate="yes" xml:space="preserve">
          <source>Get or set compression method used for this member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee99e17347439a45b11edd2de3c4f3e29784dd4" translate="yes" xml:space="preserve">
          <source>Get or set data of member in uncompressed form. When an existing archive is read &lt;code&gt;ZipArchive.expand&lt;/code&gt; needs to be called before this can be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7d46f4532c87d8a4e544df5791739440cc36ce" translate="yes" xml:space="preserve">
          <source>Get or set the OS specific file attributes for this archive member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1296d6fdc83b6b554050c4b4aa7fef3699ac90e1" translate="yes" xml:space="preserve">
          <source>Get or set the last modification time for this member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4feb1bf141a1d88be78b9a3366a4467fa93a965" translate="yes" xml:space="preserve">
          <source>Get range that spans all of the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; intervals in this &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Получить диапазон, который охватывает все интервалы &lt;a href=&quot;#Code%20point&quot;&gt;кодовой точки&lt;/a&gt; в этом &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f03d5bd32538b64243f7cd6441ecfa2b2622dbab" translate="yes" xml:space="preserve">
          <source>Get size of file &lt;code&gt;name&lt;/code&gt; in bytes.</source>
          <target state="translated">Получить размер файла &lt;code&gt;name&lt;/code&gt; в байтах.</target>
        </trans-unit>
        <trans-unit id="461490b8f32608cfbfd66725579129263619bc8c" translate="yes" xml:space="preserve">
          <source>Get size of ty</source>
          <target state="translated">Получить размер шин</target>
        </trans-unit>
        <trans-unit id="be155f80e71c94e749bac3dc7da0073ca4565577" translate="yes" xml:space="preserve">
          <source>Get targetInfo by key</source>
          <target state="translated">Получить информацию о целиПолучить информацию о цели с помощью клавиши</target>
        </trans-unit>
        <trans-unit id="73796f5728cf9c28582274f26067b749361695c9" translate="yes" xml:space="preserve">
          <source>Get the Key type of an Associative Array.</source>
          <target state="translated">Получите Ключевой тип ассоциативного массива.</target>
        </trans-unit>
        <trans-unit id="d22a099130780c3f0f5de0e5b8d691ed79199316" translate="yes" xml:space="preserve">
          <source>Get the OS specific file attributes for the archive member.</source>
          <target state="translated">Получить атрибуты файлов,специфичных для ОС,для участника архива.</target>
        </trans-unit>
        <trans-unit id="79ecfb6529a74964e1e68cd5ab4d563b90f3da7a" translate="yes" xml:space="preserve">
          <source>Get the Value type of an Associative Array.</source>
          <target state="translated">Получите тип массива значений.</target>
        </trans-unit>
        <trans-unit id="98635513b7474e13e846f5ff833241b41e74887e" translate="yes" xml:space="preserve">
          <source>Get the access and modified times of file or folder &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Получить доступ и измененные времена файла или папки &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e205b38d81166876ff783947529f334bd179d77" translate="yes" xml:space="preserve">
          <source>Get the cached block info of an interior pointer. Returns null if the interior pointer's block is not cached.</source>
          <target state="translated">Получите кэшированную информацию о блоке с внутренним указателем.Возвращает ноль,если блок внутреннего указателя не кэширован.</target>
        </trans-unit>
        <trans-unit id="4282bb82ffa1bb1dd9a0f9f0f2bf4c8c171f011b" translate="yes" xml:space="preserve">
          <source>Get the code unit at index i</source>
          <target state="translated">Получить единицу кода по индексу i</target>
        </trans-unit>
        <trans-unit id="7c3dd3625eabe5a78ecd2dfc079c83bf66c607d8" translate="yes" xml:space="preserve">
          <source>Get the current thread's instance. Returns by ref. Note that calling &lt;code&gt;get&lt;/code&gt; from any thread outside the &lt;code&gt;TaskPool&lt;/code&gt; that created this instance will return the same reference, so an instance of worker-local storage should only be accessed from one thread outside the pool that created it. If this rule is violated, undefined behavior will result.</source>
          <target state="translated">Получить экземпляр текущего потока. Возвращает реф. Обратите внимание, что вызов &lt;code&gt;get&lt;/code&gt; из любого потока вне &lt;code&gt;TaskPool&lt;/code&gt; , который создал этот экземпляр, вернет ту же ссылку, поэтому доступ к экземпляру локального хранилища должен осуществляться только из одного потока вне пула, который его создал. Если это правило нарушается, результатом будет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="2fa40eed5d4831ba4894fa0d2f99824123d18451" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Получить текущее время как &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8dce800f00dab2a31ba905f4b229d5e41f026c6" translate="yes" xml:space="preserve">
          <source>Get the current time from the system clock</source>
          <target state="translated">Получить текущее время от системных часов</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">Получить текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="b3b0d480375a5d6d1deedae54218ae4809699a35" translate="yes" xml:space="preserve">
          <source>Get the default &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; implementation for the platform</source>
          <target state="translated">Получить стандартную реализацию &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; для платформы</target>
        </trans-unit>
        <trans-unit id="1a4ef6fd99cfc2a1e29f50c6d9ba5ed116754be8" translate="yes" xml:space="preserve">
          <source>Get the drive portion of a path.</source>
          <target state="translated">Получите приводную часть пути.</target>
        </trans-unit>
        <trans-unit id="c1d426ae9f2d48f1089e0e4fbe50dd7b4c9abc89" translate="yes" xml:space="preserve">
          <source>Get the first argument &lt;code&gt;a&lt;/code&gt; that passes an &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; test. If no argument passes the test, return the last argument.</source>
          <target state="translated">Получите первый аргумент &lt;code&gt;a&lt;/code&gt; , который проходит &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; . Если ни один аргумент не прошел тест, верните последний аргумент.</target>
        </trans-unit>
        <trans-unit id="71fd3b068f374669047aed8f9838bd5650f74328" translate="yes" xml:space="preserve">
          <source>Get the full package name for the given symbol.</source>
          <target state="translated">Получите полное название пакета для данного символа.</target>
        </trans-unit>
        <trans-unit id="e88db6759fbbcb530d5bab26ba3ec77a124f346e" translate="yes" xml:space="preserve">
          <source>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter.</source>
          <target state="translated">Получите полное название типа или символа.Может выступать в качестве интеллектуального преобразования типа/символа в строковый преобразователь.</target>
        </trans-unit>
        <trans-unit id="e02735fcab968c6e59f5f8bdf04603517f7d65eb" translate="yes" xml:space="preserve">
          <source>Get the function type from a callable object &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Получить тип функции из вызываемого объекта &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0126813350919cfa23ae233f4d4ec97faf37d1f5" translate="yes" xml:space="preserve">
          <source>Get the last modification time for this member.</source>
          <target state="translated">Получить последнее время модификации для этого члена.</target>
        </trans-unit>
        <trans-unit id="2b55b05c55c5a5fab2ff26e964d410c035b4ab1b" translate="yes" xml:space="preserve">
          <source>Get the linger option.</source>
          <target state="translated">Попробуй задерживаться.</target>
        </trans-unit>
        <trans-unit id="2731449c54e0db2efeec9062c6ec93a54eb72587" translate="yes" xml:space="preserve">
          <source>Get the message describing the error. Base behavior is to return the &lt;code&gt;Throwable.msg&lt;/code&gt; field. Override to return some other error message.</source>
          <target state="translated">Получите сообщение с описанием ошибки. Основное поведение - возвращать поле &lt;code&gt;Throwable.msg&lt;/code&gt; . Переопределить, чтобы вернуть другое сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="4b21108b2b9de9b6cbf7e566c0a2ddc0c0ca72f0" translate="yes" xml:space="preserve">
          <source>Get the module name (including package) for the given symbol.</source>
          <target state="translated">Получить имя модуля (включая пакет)для данного символа.</target>
        </trans-unit>
        <trans-unit id="3288e20d4e0a2e8cea872e1f5d70b8c2b93389f8" translate="yes" xml:space="preserve">
          <source>Get the primitive types of the fields of a struct or class, in topological order.</source>
          <target state="translated">Получить примитивные типы полей структуры или класса,в топологическом порядке.</target>
        </trans-unit>
        <trans-unit id="3543b05579b2dbf35e3b0cd1e4b2b942a6076e5c" translate="yes" xml:space="preserve">
          <source>Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</source>
          <target state="translated">Получить размер файла,ulong.max,если файл не доступен для поиска,но все равно бросается при возникновении реальной ошибки.</target>
        </trans-unit>
        <trans-unit id="79a49f491dcc81c94695a311e67110f25317cf05" translate="yes" xml:space="preserve">
          <source>Get the socket's address family.</source>
          <target state="translated">Получите семейство адресов сокета.</target>
        </trans-unit>
        <trans-unit id="4e5a697008886f18598415a18e551017ef50a8a2" translate="yes" xml:space="preserve">
          <source>Get the the default initialization expression for a type.</source>
          <target state="translated">Получить выражение инициализации типа по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ebb8fbb5373a6b9ecc71521fb5c82104b76b2dda" translate="yes" xml:space="preserve">
          <source>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an &lt;code&gt;opCall&lt;/code&gt;. Please note that ref is not part of a type, but the attribute of the function (see template &lt;a href=&quot;#functionAttributes&quot;&gt;&lt;code&gt;functionAttributes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Получите тип возвращаемого значения из функции, указатель на функцию, делегат, структуру с opCall, указатель на структуру с opCall или класс с &lt;code&gt;opCall&lt;/code&gt; . Обратите внимание, что ref не является частью типа, а является атрибутом функции (см. Шаблон &lt;a href=&quot;#functionAttributes&quot;&gt; &lt;code&gt;functionAttributes&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f15e792b4182f5761446203a960686f6a1fd8cb" translate="yes" xml:space="preserve">
          <source>Get the type that a scalar type &lt;code&gt;T&lt;/code&gt; will &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;promote&lt;/a&gt; to in multi-term arithmetic expressions.</source>
          <target state="translated">Получите тип, который скалярный тип &lt;code&gt;T&lt;/code&gt; будет &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;продвигать&lt;/a&gt; в многочленных арифметических выражениях.</target>
        </trans-unit>
        <trans-unit id="d86851901246015e180e22d937a94cdd4a67d0cf" translate="yes" xml:space="preserve">
          <source>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns void if passed an empty list, or if the types have no common type.</source>
          <target state="translated">Получить тип,к которому все типы могут быть неявно приведены.Полезно,например,при вычислении типа массива из связки инициализирующих значений.Возвращает пустой,если передан пустой список,или если типы не имеют общего типа.</target>
        </trans-unit>
        <trans-unit id="d8834c0e5c45f02dee115c0af5916029dd3645eb" translate="yes" xml:space="preserve">
          <source>Get the type that will really be used for passing the given argument to an &lt;code&gt;extern(C++)&lt;/code&gt; function.</source>
          <target state="translated">Получите тип, который действительно будет использоваться для передачи данного аргумента в функцию &lt;code&gt;extern(C++)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a8db062181587e0a37ac18deba2e6a2d99a21b8" translate="yes" xml:space="preserve">
          <source>Get the underlying path.</source>
          <target state="translated">Получить путь,лежащий в основе.</target>
        </trans-unit>
        <trans-unit id="8aa89601daef2aac5d5712f9ccfde65d17aeb883" translate="yes" xml:space="preserve">
          <source>Get the underlying type which a &lt;code&gt;Typedef&lt;/code&gt; wraps. If &lt;code&gt;T&lt;/code&gt; is not a &lt;code&gt;Typedef&lt;/code&gt; it will alias itself to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Получите базовый тип, который &lt;code&gt;Typedef&lt;/code&gt; Typedef. Если &lt;code&gt;T&lt;/code&gt; не &lt;code&gt;Typedef&lt;/code&gt; это псевдоним себя &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc66c2f8e24da37f6181d5e17247039b03831383" translate="yes" xml:space="preserve">
          <source>Get the value of the .max/.min property as an Expression. Lazily computes the value and caches it in maxval/minval. Reports any errors.</source>
          <target state="translated">Получить значение свойства .max/.min как Expression.Лениво вычисляет значение и кэширует его в maxval/minval.Сообщает об ошибках.</target>
        </trans-unit>
        <trans-unit id="bb25c1e8984031c906b57204ab00dc5ad735d012" translate="yes" xml:space="preserve">
          <source>Get the various timings like name lookup time, total time, connect time etc. The timed category is passed through the timing parameter while the timing value is stored at val. The value is usable only if res is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">Получите различные значения времени, такие как время поиска имени, общее время, время соединения и т. Д. Временная категория пропускается через параметр синхронизации, в то время как значение синхронизации сохраняется в val. Это значение можно использовать только в том случае, если res равно &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="912a474bb0a0204ed6b0e20848237a640087bf6c" translate="yes" xml:space="preserve">
          <source>Get tuple, one per function parameter, of the storage classes of the parameters.</source>
          <target state="translated">Получить кортеж,по одному на параметр функции,классов хранения параметров.</target>
        </trans-unit>
        <trans-unit id="36c705a4549f55994270c31cf59dc15c22af56b1" translate="yes" xml:space="preserve">
          <source>Get type information on the contents of the type; null if not available</source>
          <target state="translated">Получить информацию о содержании типа;нулевой,если не доступен</target>
        </trans-unit>
        <trans-unit id="96f72b00f8ed83794b8d1d1ca2272471a19aedec" translate="yes" xml:space="preserve">
          <source>Get underlying socket handle.</source>
          <target state="translated">Возьми ручку гнезда.</target>
        </trans-unit>
        <trans-unit id="48ec336cb3c23da76d213eaa7aef8a04ca5f0b14" translate="yes" xml:space="preserve">
          <source>Get various timings defined in &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt;&lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt;&lt;/a&gt;. The value is usable only if the return value is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">Получить различные сроки, определенные в &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt; &lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt; &lt;/a&gt; . Это значение можно использовать только в том случае, если возвращаемое значение равно &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efecd1a1ec18ed172626c58e06a872720a3ea949" translate="yes" xml:space="preserve">
          <source>Get with custom data receivers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb969faa69556a50edb8b7474adfcb5288a0eabc" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, &lt;code&gt;void&lt;/code&gt; is returned instead.</source>
          <target state="translated">Получить в качестве кортежа значение параметров по умолчанию для символа функции. Если параметр не имеет значения по умолчанию, вместо него возвращается &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e5eb1b88f56e22db495838fb23d06aff7902858" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the identifiers of the parameters to a function symbol.</source>
          <target state="translated">Получить в качестве кортежа идентификаторы параметров к символу функции.</target>
        </trans-unit>
        <trans-unit id="0d9be8cea698e918f8f5553c38491cc55f980684" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an &lt;code&gt;opCall&lt;/code&gt;, a pointer to a struct with an &lt;code&gt;opCall&lt;/code&gt;, or a class with an &lt;code&gt;opCall&lt;/code&gt;.</source>
          <target state="translated">Получите в качестве кортежа типы параметров для функции, указатель на функцию, делегат, структуру с &lt;code&gt;opCall&lt;/code&gt; , указатель на структуру с &lt;code&gt;opCall&lt;/code&gt; или класс с &lt;code&gt;opCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a2a322d7843413da4411904750627b588381236" translate="yes" xml:space="preserve">
          <source>Get/set number of elements in the array. It is of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">Получить / установить количество элементов в массиве. Это имеет тип &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e903dced1589591dccd55f4a2a573704d37b25f7" translate="yes" xml:space="preserve">
          <source>Get/set socket's blocking flag.</source>
          <target state="translated">Блокирующий флаг &quot;Получить/установить розетку&quot;.</target>
        </trans-unit>
        <trans-unit id="8143cfad11bbcb508b2faa890c629adbe90a1326" translate="yes" xml:space="preserve">
          <source>GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;(T...)(ref string[] args, T opts);</source>
          <target state="translated">GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt; (T ...) (ref string [] args, T opts);</target>
        </trans-unit>
        <trans-unit id="3639898092fae686744daf985b5a5af78426e672" translate="yes" xml:space="preserve">
          <source>Gets a &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; at the given index in this cluster.</source>
          <target state="translated">Получает &lt;a href=&quot;#Code%20point&quot;&gt;кодовую точку&lt;/a&gt; по указанному индексу в этом кластере.</target>
        </trans-unit>
        <trans-unit id="3b7dd24ad864c772981b0d66dc0022feced1b999" translate="yes" xml:space="preserve">
          <source>Gets a larger buffer &lt;code&gt;buf&lt;/code&gt; by calling &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt;. If &lt;code&gt;buf&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;. Otherwise, returns &lt;code&gt;buf[0 .. n]&lt;/code&gt;.</source>
          <target state="translated">Получает больший буфер &lt;code&gt;buf&lt;/code&gt; , вызывая &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt; . Если &lt;code&gt;buf&lt;/code&gt; равен &lt;code&gt;null&lt;/code&gt; , возвращает &lt;code&gt;null&lt;/code&gt; . В противном случае возвращает &lt;code&gt;buf[0 .. n]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c0f14712193b76cf9f29f4a2238a646ef9482c" translate="yes" xml:space="preserve">
          <source>Gets a range of key/values for &lt;code&gt;aa&lt;/code&gt;.</source>
          <target state="translated">Получает диапазон ключей / значений для &lt;code&gt;aa&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f00eae4c2ff9337f7291213da97c9dc6aebf8d8" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo, which should be used as the default instance when info is requested for a thread not created by the Scheduler.</source>
          <target state="translated">Получает потоколокальный экземпляр ThreadInfo,который должен использоваться по умолчанию,когда информация запрашивается для потока,не созданного Планировщиком.</target>
        </trans-unit>
        <trans-unit id="f6f18bccfb576e34d7b5fa60615448449996ea12" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo.</source>
          <target state="translated">Получает потоколокальный экземпляр ThreadInfo.</target>
        </trans-unit>
        <trans-unit id="b472fcab365d2a6ba9fdba822432b62db948d127" translate="yes" xml:space="preserve">
          <source>Gets an object representing the reader lock for the associated mutex.</source>
          <target state="translated">Получает объект,представляющий собой блокировку читателя для связанного с ним мьютекса.</target>
        </trans-unit>
        <trans-unit id="2bad6a1697863b959c51608194a08c6aaf894ca4" translate="yes" xml:space="preserve">
          <source>Gets an object representing the writer lock for the associated mutex.</source>
          <target state="translated">Получает объект,представляющий собой блокировку пишущего мьютекса.</target>
        </trans-unit>
        <trans-unit id="c2134c8e8821e26937fe2aedd4aa0e2891a164f8" translate="yes" xml:space="preserve">
          <source>Gets called on program shutdown just after GC is terminated.</source>
          <target state="translated">Вызывается при завершении работы программы сразу после завершения работы GC.</target>
        </trans-unit>
        <trans-unit id="3863a33d5ec162d09008cccc833b8dbca9f1864e" translate="yes" xml:space="preserve">
          <source>Gets called on program startup just before GC is initialized.</source>
          <target state="translated">Вызывается при запуске программы непосредственно перед инициализацией GC.</target>
        </trans-unit>
        <trans-unit id="fdc75e27ba04f67b552a395ef0dbfb72c8501519" translate="yes" xml:space="preserve">
          <source>Gets expression at offset of type. Returns NULL if not found.</source>
          <target state="translated">Получает выражение при смещении типа.Возвращает NULL,если не найдено.</target>
        </trans-unit>
        <trans-unit id="cc94d4edefc014f546538ff3e9cb05bec4999447" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;i&lt;/code&gt;'th bit in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">Получает &lt;code&gt;i&lt;/code&gt; -й бит в &lt;code&gt;BitArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8011563ddbd748ff521930918dc8bcb499b269a2" translate="yes" xml:space="preserve">
          <source>Gets the OS identifier for this thread.</source>
          <target state="translated">Получает идентификатор операционной системы для этого потока.</target>
        </trans-unit>
        <trans-unit id="685489f583759f962fe7c1daab0034a07cb9d516" translate="yes" xml:space="preserve">
          <source>Gets the Tid associated with name.</source>
          <target state="translated">Получает Tid,связанный с именем.</target>
        </trans-unit>
        <trans-unit id="5c6e15b07949cc6ff89428732b9e3b99b89bcdc8" translate="yes" xml:space="preserve">
          <source>Gets the current collect handler.</source>
          <target state="translated">Получает текущего обработчика сбора.</target>
        </trans-unit>
        <trans-unit id="4ee9c2ec9df011130e3394bc652f9b3e7978ed43" translate="yes" xml:space="preserve">
          <source>Gets the current legacy module unit tester.</source>
          <target state="translated">Получает текущий тестер устаревших модульных блоков.</target>
        </trans-unit>
        <trans-unit id="b9fd850a635cce1ec806814a7cb5c442887ef8c8" translate="yes" xml:space="preserve">
          <source>Gets the current module unit tester.</source>
          <target state="translated">Получает текущий тестер модульных блоков.</target>
        </trans-unit>
        <trans-unit id="e72b94a5c6c1c6b67ed9a2ba11a48dec6fb51fea" translate="yes" xml:space="preserve">
          <source>Gets the current state of this fiber.</source>
          <target state="translated">Получает текущее состояние этого волокна.</target>
        </trans-unit>
        <trans-unit id="86b54a37d38df76c69490341ad477a651e752312" translate="yes" xml:space="preserve">
          <source>Gets the current trace handler.</source>
          <target state="translated">Получает текущий обработчик трассировки.</target>
        </trans-unit>
        <trans-unit id="48b50302326e46ace0f0f71974024ade98c4d812" translate="yes" xml:space="preserve">
          <source>Gets the daemon status for this thread. While the runtime will wait for all normal threads to complete before tearing down the process, daemon threads are effectively ignored and thus will not prevent the process from terminating. In effect, daemon threads will be terminated automatically by the OS when the process exits.</source>
          <target state="translated">Получает статус демона для этой нити.В то время как время выполнения будет ждать завершения всех обычных потоков,прежде чем снести процесс,демонские потоки эффективно игнорируются и,таким образом,не будут препятствовать завершению процесса.По сути,демонические потоки будут автоматически завершены операционной системой при завершении процесса.</target>
        </trans-unit>
        <trans-unit id="6388b81675e677f57fc44bb674c4998dc61bbf09" translate="yes" xml:space="preserve">
          <source>Gets the index of the current thread relative to this &lt;code&gt;TaskPool&lt;/code&gt;. Any thread not in this pool will receive an index of 0. The worker threads in this pool receive unique indices of 1 through &lt;code&gt;this.size&lt;/code&gt;.</source>
          <target state="translated">Получает индекс текущего потока относительно этого &lt;code&gt;TaskPool&lt;/code&gt; . Любой поток, не &lt;code&gt;this.size&lt;/code&gt; в этот пул, получит индекс 0. Рабочие потоки в этом пуле получают уникальные индексы от 1 до this.size .</target>
        </trans-unit>
        <trans-unit id="397d4288bd9f56373ed42093b36baf0cf34c80d4" translate="yes" xml:space="preserve">
          <source>Gets the matching &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;user-defined attributes&lt;/a&gt; from the given symbol.</source>
          <target state="translated">Получает соответствующие &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;пользовательские атрибуты&lt;/a&gt; из данного символа.</target>
        </trans-unit>
        <trans-unit id="ff4bb9618e0f172c3deb93f3fe4c73732cb67c80" translate="yes" xml:space="preserve">
          <source>Gets the mutex associated with this condition.</source>
          <target state="translated">Получает мьютекс,связанный с этим состоянием.</target>
        </trans-unit>
        <trans-unit id="b1cafc8d1ad4c93a1519578fd6ef07cfbae8c0d4" translate="yes" xml:space="preserve">
          <source>Gets the nth number in the underlying representation that makes up the whole &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">Получает n-е число в базовом представлении, которое составляет весь &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="801e40683c25723cacc6326aca38101be95c4627" translate="yes" xml:space="preserve">
          <source>Gets the policy used by this mutex.</source>
          <target state="translated">Получает политику,используемую этим мьютексом.</target>
        </trans-unit>
        <trans-unit id="8aba27c226485427875db239e8c2e09071484ea6" translate="yes" xml:space="preserve">
          <source>Gets the scheduling priority for the associated thread.</source>
          <target state="translated">Получает приоритет планирования для соответствующего потока.</target>
        </trans-unit>
        <trans-unit id="cf58bd5c03eda3fe4cc7594124c4b61e9c109dc9" translate="yes" xml:space="preserve">
          <source>Gets the type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">Получает тип объекта &lt;code&gt;TypeInfo&lt;/code&gt; , связанного с &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9211b2fb8e24a472f1780790cfdc50455081852e" translate="yes" xml:space="preserve">
          <source>Gets the user-readable label for this thread.</source>
          <target state="translated">Получает удобочитаемую этикетку для этой нити.</target>
        </trans-unit>
        <trans-unit id="611d2080794dfc9ee82363d9d9da4aa9a138b19f" translate="yes" xml:space="preserve">
          <source>Gets the value if not null. If &lt;code&gt;this&lt;/code&gt; is in the null state, and the optional parameter &lt;code&gt;fallback&lt;/code&gt; was provided, it will be returned. Without &lt;code&gt;fallback&lt;/code&gt;, calling &lt;code&gt;get&lt;/code&gt; with a null state is invalid.</source>
          <target state="translated">Получает значение, если не ноль. Если &lt;code&gt;this&lt;/code&gt; в нулевом состоянии, и был предоставлен необязательный параметр &lt;code&gt;fallback&lt;/code&gt; , он будет возвращен Без &lt;code&gt;fallback&lt;/code&gt; вызов &lt;code&gt;get&lt;/code&gt; с нулевым состоянием недопустим.</target>
        </trans-unit>
        <trans-unit id="7ce43e8e9e8874c455bc1d408b4db63789ae5ade" translate="yes" xml:space="preserve">
          <source>Gets the value. &lt;code&gt;this&lt;/code&gt; must not be in the null state. This function is also called for the implicit conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Получает значение. &lt;code&gt;this&lt;/code&gt; не должно быть в нулевом состоянии. Эта функция также называется для неявного преобразования в &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27ec2c5053941a53ff7bc20b3630c9aa87b310af" translate="yes" xml:space="preserve">
          <source>Gets vendor-specific type mangling for C++ ABI.</source>
          <target state="translated">Получает управление типом для C++ABI в зависимости от поставщика.</target>
        </trans-unit>
        <trans-unit id="7e2612461374b070bc3713b89e3df4f4c33fbf6f" translate="yes" xml:space="preserve">
          <source>Gets/sets assert hander. null means the default handler is used.</source>
          <target state="translated">Getts/sets assert hander.null означает,что используется обработчик по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8a46199cc00d346a1fe72a372a1bcb52b3b1947f" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">Получает / устанавливает распределитель для текущего процесса. Этот распределитель должен использоваться для распределения памяти, разделяемой между потоками. Объекты, созданные с помощью этого распределителя, могут быть переданы в &lt;code&gt;shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f3fc74fb3ec91a1abfd15e2f2178014ba02b91" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use &lt;code&gt;processAllocator&lt;/code&gt; (below). By default, &lt;code&gt;theAllocator&lt;/code&gt; ultimately fetches memory from &lt;code&gt;processAllocator&lt;/code&gt;, which in turn uses the garbage collected heap.</source>
          <target state="translated">Получает / устанавливает распределитель для текущего потока. Это распределитель по умолчанию, который должен использоваться для выделения локальной памяти потока. Для выделения памяти для совместного использования между потоками используйте &lt;code&gt;processAllocator&lt;/code&gt; (ниже). По умолчанию, &lt;code&gt;theAllocator&lt;/code&gt; конечном итоге извлекает память из &lt;code&gt;processAllocator&lt;/code&gt; , который, в свою очередь, использует кучу мусора, собираемого мусором.</target>
        </trans-unit>
        <trans-unit id="ce0e5e384b0423d01fbe02461b7f604937af05a9" translate="yes" xml:space="preserve">
          <source>Getting a range of all the named captures in the regex.</source>
          <target state="translated">Получение диапазона всех названных снимков в регексе.</target>
        </trans-unit>
        <trans-unit id="3239f451b140324af46d3a3db896ec8a5a618fbd" translate="yes" xml:space="preserve">
          <source>Getting the benefits of multiple adaptable freelists that do not need to be tuned for one specific size but insted automatically adapts itself to frequently used sizes.</source>
          <target state="translated">Получение преимуществ множества адаптируемых фрилистов,которые не нуждаются в настройке для одного конкретного размера,но инстинктивно автоматически адаптируется к часто используемым размерам.</target>
        </trans-unit>
        <trans-unit id="c7ae27f036579182bace286ba1e0cf636e5ff36f" translate="yes" xml:space="preserve">
          <source>Getting the priority of a thread that already terminated might return the default priority.</source>
          <target state="translated">Получение приоритета уже завершенного потока может вернуть приоритет по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d5546b9dfb555ac771be9469163d9af49686adbe" translate="yes" xml:space="preserve">
          <source>Give error if we're not an lvalue. If we can, convert expression to be an lvalue.</source>
          <target state="translated">Дайте ошибку,если мы не являемся ценностью.Если сможем,преобразовать выражение в l-значение.</target>
        </trans-unit>
        <trans-unit id="74474e23aa26985e7a98ca671962a908920e33b2" translate="yes" xml:space="preserve">
          <source>Give up.</source>
          <target state="translated">Сдавайся.</target>
        </trans-unit>
        <trans-unit id="6839d82e03f5268d9a7cc97802db76c48c8cce6e" translate="yes" xml:space="preserve">
          <source>Given</source>
          <target state="translated">Given</target>
        </trans-unit>
        <trans-unit id="545c45c89bb40c5d7b7b442770eb2c94a5c06899" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a == b&lt;/code&gt; :</source>
          <target state="translated">Учитывая &lt;code&gt;a == b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53726705da0088ae9fbab83c8c50c091febc70d1" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;flags&lt;/code&gt; as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values, or a type &lt;code&gt;T&lt;/code&gt;, returns the allocator that's a closest fit in capabilities.</source>
          <target state="translated">Учитывая &lt;code&gt;flags&lt;/code&gt; как комбинацию значений &lt;code&gt;AllocFlag&lt;/code&gt; или типа &lt;code&gt;T&lt;/code&gt; , возвращает распределитель, который наиболее соответствует возможностям.</target>
        </trans-unit>
        <trans-unit id="62b1bd97df8e740424d65deb5d1e60e2802ffce0" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;index&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt; and assuming that &lt;code&gt;index&lt;/code&gt; is at the start of a UTF sequence, &lt;code&gt;toUCSindex&lt;/code&gt; determines the number of UCS characters up to &lt;code&gt;index&lt;/code&gt;. So, &lt;code&gt;index&lt;/code&gt; is the index of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</source>
          <target state="translated">Учитывая &lt;code&gt;index&lt;/code&gt; в &lt;code&gt;str&lt;/code&gt; и предполагая, что &lt;code&gt;index&lt;/code&gt; находится в начале последовательности UTF, &lt;code&gt;toUCSindex&lt;/code&gt; определяет количество символов UCS до &lt;code&gt;index&lt;/code&gt; . Итак, &lt;code&gt;index&lt;/code&gt; - это индекс единицы кода в начале кодовой точки, а возвращаемое значение - это количество точек кода в строке, которой является эта кодовая точка.</target>
        </trans-unit>
        <trans-unit id="bb7cf3072f3bd953aeae94de343ed5c6b8a94867" translate="yes" xml:space="preserve">
          <source>Given D code like:</source>
          <target state="translated">Учитывая код D:</target>
        </trans-unit>
        <trans-unit id="d736ecdf41cd9fce2597d330cc34519b6b941a39" translate="yes" xml:space="preserve">
          <source>Given EBP, find return address to caller, and caller's EBP.</source>
          <target state="translated">Учитывая EBP,найдите обратный адрес звонящего и EBP звонящего.</target>
        </trans-unit>
        <trans-unit id="eb6400b34d9067d59b3f43922d46e893c8d36002" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;source&lt;/code&gt; range that is expensive to iterate over, returns an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that asynchronously buffers the contents of &lt;code&gt;source&lt;/code&gt; into a buffer of &lt;code&gt;bufSize&lt;/code&gt; elements in a worker thread, while making previously buffered elements from a second buffer, also of size &lt;code&gt;bufSize&lt;/code&gt;, available via the range interface of the returned object. The returned range has a length iff &lt;code&gt;hasLength!S&lt;/code&gt;. &lt;code&gt;asyncBuf&lt;/code&gt; is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network.</source>
          <target state="translated">При наличии &lt;code&gt;source&lt;/code&gt; диапазона, который &lt;code&gt;bufSize&lt;/code&gt; дорого, возвращается &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;входной диапазон,&lt;/a&gt; который асинхронно буферизует содержимое &lt;code&gt;source&lt;/code&gt; в буфер элементов bufSize в рабочем потоке, в то же время делая ранее буферизованные элементы из второго буфера, также размера &lt;code&gt;bufSize&lt;/code&gt; , доступными через интерфейс диапазона возвращаемого объекта. Возвращаемый диапазон имеет длину тогда и только тогда &lt;code&gt;hasLength!S&lt;/code&gt; . &lt;code&gt;asyncBuf&lt;/code&gt; полезен, например, при выполнении дорогостоящих операций над элементами диапазонов, которые представляют данные на диске или в сети.</target>
        </trans-unit>
        <trans-unit id="699c74248abd14b4250ad690ede845e5aad24631" translate="yes" xml:space="preserve">
          <source>Given a Base64 encoded string, calculates the length of the decoded string.</source>
          <target state="translated">Получив строку в кодировке Base64,вычислит длину расшифрованной строки.</target>
        </trans-unit>
        <trans-unit id="bc7d61e132762100a6e8861609dacf0581eebca4" translate="yes" xml:space="preserve">
          <source>Given a C++ function in a C++ source file:</source>
          <target state="translated">Получить функцию C++в исходном файле C++:</target>
        </trans-unit>
        <trans-unit id="7de884353daa1d02f969775316b89c9805864eba" translate="yes" xml:space="preserve">
          <source>Given a UCS index &lt;code&gt;n&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt;, returns the UTF index. So, &lt;code&gt;n&lt;/code&gt; is how many code points into the string the code point is, and the array index of the code unit is returned.</source>
          <target state="translated">С учетом индекса UCS &lt;code&gt;n&lt;/code&gt; в &lt;code&gt;str&lt;/code&gt; возвращает индекс UTF. Итак, &lt;code&gt;n&lt;/code&gt; - это количество точек кода в строке, в которой находится точка кода, и возвращается индекс массива единицы кода.</target>
        </trans-unit>
        <trans-unit id="3aa76f9d8ead49fe4c4634dcc93f9d715d5abf9c" translate="yes" xml:space="preserve">
          <source>Given a and p, the function finds x such that</source>
          <target state="translated">Учитывая a и p,функция находит x таким образом,что</target>
        </trans-unit>
        <trans-unit id="97696594fbe0457c99be87ef93b37c947e4a5703" translate="yes" xml:space="preserve">
          <source>Given a callable object &lt;code&gt;next&lt;/code&gt; that writes to a user-provided buffer and a second callable object &lt;code&gt;empty&lt;/code&gt; that determines whether more data is available to write via &lt;code&gt;next&lt;/code&gt;, returns an input range that asynchronously calls &lt;code&gt;next&lt;/code&gt; with a set of size &lt;code&gt;nBuffers&lt;/code&gt; of buffers and makes the results available in the order they were obtained via the input range interface of the returned object. Similarly to the input range overload of &lt;code&gt;asyncBuf&lt;/code&gt;, the first half of the buffers are made available via the range interface while the second half are filled and vice-versa.</source>
          <target state="translated">При наличии вызываемого объекта &lt;code&gt;next&lt;/code&gt; , который записывает в предоставленный пользователем буфер, и второго вызываемого объекта &lt;code&gt;empty&lt;/code&gt; который определяет, доступно ли больше данных для записи через &lt;code&gt;next&lt;/code&gt; , возвращает входной диапазон, который асинхронно вызывает &lt;code&gt;next&lt;/code&gt; с набором буферов размера &lt;code&gt;nBuffers&lt;/code&gt; , и делает результаты доступны в том порядке, в котором они были получены через интерфейс диапазона ввода возвращаемого объекта. Подобно перегрузке входного диапазона &lt;code&gt;asyncBuf&lt;/code&gt; , первая половина буферов становится доступной через интерфейс диапазона, в то время как вторая половина заполняется, и наоборот.</target>
        </trans-unit>
        <trans-unit id="f4bc9912c00cf7ade5e6f59f3c7bafa79a0098bb" translate="yes" xml:space="preserve">
          <source>Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;[a .. b]&lt;/code&gt; such that &lt;code&gt;f(a)&lt;/code&gt; and &lt;code&gt;f(b)&lt;/code&gt; have opposite signs or at least one of them equals &amp;plusmn;0, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a root of &lt;code&gt;f(x)&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one root in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN, NaN will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">Если функция &lt;code&gt;f&lt;/code&gt; и диапазон &lt;code&gt;[a .. b]&lt;/code&gt; такой, что &lt;code&gt;f(a)&lt;/code&gt; и &lt;code&gt;f(b)&lt;/code&gt; имеют противоположные знаки или хотя бы один из них равен &amp;plusmn; 0, возвращает значение &lt;code&gt;x&lt;/code&gt; в диапазоне, ближайшем к a корень &lt;code&gt;f(x)&lt;/code&gt; . Если &lt;code&gt;f(x)&lt;/code&gt; имеет более одного корня в диапазоне, один будет выбран произвольно. Если &lt;code&gt;f(x)&lt;/code&gt; возвращает NaN, NaN будет возвращен; в противном случае этот алгоритм гарантированно будет успешным.</target>
        </trans-unit>
        <trans-unit id="b3d905355b0b0e68c40d2c94bafa678611e3caae" translate="yes" xml:space="preserve">
          <source>Given a new instance tithis of this TemplateDeclaration, see if there already exists an instance. If so, return that existing instance.</source>
          <target state="translated">Учитывая новую десятину экземпляра этого шаблона-декларации,посмотрите,существует ли уже этот экземпляр.Если да,верните этот существующий экземпляр.</target>
        </trans-unit>
        <trans-unit id="7902cf88ea3243b9d5f9eb153e89c6c4585563c1" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as &lt;code&gt;T&lt;/code&gt;), constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to null.</source>
          <target state="translated">Учитывая указатель &lt;code&gt;chunk&lt;/code&gt; для неинициализированного памяти (но уже набрано , как &lt;code&gt;T&lt;/code&gt; ), создает объект непредставленного &lt;code&gt;class&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; по этому адресу. Если &lt;code&gt;T&lt;/code&gt; является классом, инициализирует ссылку на класс на нуль.</target>
        </trans-unit>
        <trans-unit id="abaa134bbbf8060e8ac6344879f8e8d611739ebe" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;.</source>
          <target state="translated">С учетом &lt;code&gt;chunk&lt;/code&gt; указателя на неинициализированную память (но уже типизированного как неклассовый тип &lt;code&gt;T&lt;/code&gt; ) создается объект типа &lt;code&gt;T&lt;/code&gt; по этому адресу из аргументов &lt;code&gt;args&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является классом, инициализирует ссылку на класс в &lt;code&gt;args[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58557c048614c0f1ce20fdb67b5db3ba6bf2d1b4" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;. This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">С учетом &lt;code&gt;chunk&lt;/code&gt; указателя на неинициализированную память (но уже типизированного как неклассовый тип &lt;code&gt;T&lt;/code&gt; ) создается объект типа &lt;code&gt;T&lt;/code&gt; по этому адресу из аргументов &lt;code&gt;args&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является классом, инициализирует ссылку на класс в &lt;code&gt;args[0]&lt;/code&gt; . Эта функция может быть &lt;code&gt;@trusted&lt;/code&gt; , если соответствующий конструктор &lt;code&gt;T&lt;/code&gt; равен &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18ffdf892cf328d6d063a845b68a6520844d64c2" translate="yes" xml:space="preserve">
          <source>Given a pointer: If it is an Object, return that Object. If it is an interface, return the Object implementing the interface. If it is null, return null. Else, undefined crash</source>
          <target state="translated">Давая указатель:Если это Объект,верните этот Объект.Если это интерфейс,верните Object,реализующий интерфейс.Если он нулевой,вернуть ноль.Иначе,неопределенное падение</target>
        </trans-unit>
        <trans-unit id="a2a17bffc5b9d113dc0183d4777b121f1563c333" translate="yes" xml:space="preserve">
          <source>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point.</source>
          <target state="translated">При случайном диапазоне доступа и начальной точке,создает диапазон,который попеременно возвращает следующий левый и следующий правый элемент к начальной точке.</target>
        </trans-unit>
        <trans-unit id="cf77f4783176c69f24bf5139063bed48dbcdbc05" translate="yes" xml:space="preserve">
          <source>Given a range of elements, constructs an index of its top</source>
          <target state="translated">С учетом ряда элементов,строит индекс его вершины.</target>
        </trans-unit>
        <trans-unit id="f82f27390a9cc6295ef9d3e2c499d003645adbcb" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the &lt;code&gt;n&lt;/code&gt;th element of each of the enclosed ranges. This function is similar to &lt;code&gt;unzip&lt;/code&gt; in other languages.</source>
          <target state="translated">Учитывая диапазон диапазонов, проходите итерацию через &lt;code&gt;n&lt;/code&gt; - й элемент каждого из вложенных диапазонов. Эта функция похожа на &lt;code&gt;unzip&lt;/code&gt; в других языках.</target>
        </trans-unit>
        <trans-unit id="99d831c39b761ba6173d077a392b684dab424593" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</source>
          <target state="translated">Учитывая диапазон диапазонов,итерация проходит в поперечном направлении через первые элементы каждого из прилагаемых диапазонов.</target>
        </trans-unit>
        <trans-unit id="76deeb26e0b9b94a659a1c8d77489812eb190823" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, returns a range of ranges where the</source>
          <target state="translated">Учитывая диапазон диапазонов,возвращает диапазон диапазонов,где</target>
        </trans-unit>
        <trans-unit id="23b1b22050fe1a6a85e37baec0da8ef5a908711a" translate="yes" xml:space="preserve">
          <source>Given a range of sorted &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward ranges&lt;/a&gt;&lt;code&gt;ror&lt;/code&gt;, copies to &lt;code&gt;tgt&lt;/code&gt; the elements that are common to most ranges, along with their number of occurrences. All ranges in &lt;code&gt;ror&lt;/code&gt; are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Only the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements are returned.</source>
          <target state="translated">Принимая во внимание ряда сортируется &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;вперед диапазоны &lt;/a&gt; &lt;code&gt;ror&lt;/code&gt; , копии &lt;code&gt;tgt&lt;/code&gt; элементов , которые являются общими для большинства диапазонов, наряду с их числом вхождений. Предполагается, что все диапазоны в &lt;code&gt;ror&lt;/code&gt; отсортированы по &lt;code&gt;less&lt;/code&gt; . Только самые частые элементы &lt;code&gt;tgt.length&lt;/code&gt; возвращаются.</target>
        </trans-unit>
        <trans-unit id="6cadfddfad656a52536264d1af9f3900d194ed5c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">Учитывая область памяти сырьевой &lt;code&gt;chunk&lt;/code&gt; (но уже набран , как тип класса &lt;code&gt;T&lt;/code&gt; ), строит объект &lt;code&gt;class&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; по этому адресу. В конструктор передаются аргументы &lt;code&gt;Args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adbee075f1252282f1c423c0af02edd4265ab66b" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Учитывая область памяти сырьевой &lt;code&gt;chunk&lt;/code&gt; (но уже набран , как тип класса &lt;code&gt;T&lt;/code&gt; ), строит объект &lt;code&gt;class&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; по этому адресу. В конструктор передаются аргументы &lt;code&gt;Args&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является внутренним классом, &lt;code&gt;outer&lt;/code&gt; поле которого можно использовать для доступа к экземпляру включающего класса, то &lt;code&gt;Args&lt;/code&gt; не должен быть пустым, и первый его член должен быть допустимым инициализатором для этого &lt;code&gt;outer&lt;/code&gt; поля. Правильная инициализация этого поля необходима для доступа к членам внешнего класса внутри методов &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0653a1ab81721bb4c49575b0fcabecb4d629612a" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">Учитывая область памяти сырьевой &lt;code&gt;chunk&lt;/code&gt; , строит объект &lt;code&gt;class&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; по этому адресу. В конструктор передаются аргументы &lt;code&gt;Args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74cf19c0277fb6a57dd8ab3cb630a33bfe4fee0c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Учитывая область памяти сырьевой &lt;code&gt;chunk&lt;/code&gt; , строит объект &lt;code&gt;class&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; по этому адресу. В конструктор передаются аргументы &lt;code&gt;Args&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является внутренним классом, &lt;code&gt;outer&lt;/code&gt; поле которого можно использовать для доступа к экземпляру включающего класса, то &lt;code&gt;Args&lt;/code&gt; не должен быть пустым, и первый его член должен быть допустимым инициализатором для этого &lt;code&gt;outer&lt;/code&gt; поля. Правильная инициализация этого поля необходима для доступа к членам внешнего класса внутри методов &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e137ad6b52d9b560e6ecf089479316e86462ce01" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;args&lt;/code&gt;, if any.</source>
          <target state="translated">Учитывая сырой область памяти &lt;code&gt;chunk&lt;/code&gt; , строит объект не- &lt;code&gt;class&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; по этому адресу. В конструктор передаются аргументы &lt;code&gt;args&lt;/code&gt; , если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="f8745e4f392d96921746aba6d016d8b75a3eaf5b" translate="yes" xml:space="preserve">
          <source>Given a symbol that could be either a FuncDeclaration or a function template, resolve it to a function symbol.</source>
          <target state="translated">Получив символ,который может быть либо FuncDeclaration,либо шаблоном функции,преобразовать его в символ функции.</target>
        </trans-unit>
        <trans-unit id="3ec7e3b2070dd15d8c86e7da24a716e09d94b001" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;S&lt;/code&gt; that is one of:</source>
          <target state="translated">Учитывая тип &lt;code&gt;S&lt;/code&gt; , который является одним из:</target>
        </trans-unit>
        <trans-unit id="5bf486ff307c1ac9da00abda18e996a0151d6f51" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, returns its allocation-related flags as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values.</source>
          <target state="translated">Учитывая тип &lt;code&gt;T&lt;/code&gt; , возвращает свои связанные с выделением флаги как комбинацию значений &lt;code&gt;AllocFlag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ec656f1b47e3a570669cfd79e664b45a8112e7a" translate="yes" xml:space="preserve">
          <source>Given address that is inside a function, figure out which function it is in. Return DHandlerTable if there is one, NULL if not.</source>
          <target state="translated">Получив адрес,который находится внутри функции,выясните,в какой функции она находится.Возвращает DHandlerTable,если он есть,NULL,если нет.</target>
        </trans-unit>
        <trans-unit id="84fb4bae252188c74a52ee250ba7895934a71e72" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;object factory&lt;/a&gt; of type &lt;code&gt;Factory&lt;/code&gt; or a factory function &lt;code&gt;factoryFunction&lt;/code&gt;, and optionally also &lt;code&gt;BookkeepingAllocator&lt;/code&gt; as a supplemental allocator for bookkeeping, &lt;code&gt;AllocatorList&lt;/code&gt; creates an allocator that lazily creates as many allocators are needed for satisfying client allocation requests.</source>
          <target state="translated">Учитывая &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;объектную фабрику&lt;/a&gt; типа &lt;code&gt;Factory&lt;/code&gt; или фабричную функцию &lt;code&gt;factoryFunction&lt;/code&gt; , а также дополнительно &lt;code&gt;BookkeepingAllocator&lt;/code&gt; в качестве дополнительного распределителя для учета, &lt;code&gt;AllocatorList&lt;/code&gt; создает распределитель, который лениво создает столько распределителей, сколько необходимо для удовлетворения запросов на выделение ресурсов клиентом.</target>
        </trans-unit>
        <trans-unit id="2c2ffbad9b196900545a99b58a4a8084fb8e968f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;AssignExp&lt;/code&gt;, determine if the lvalue will cause the contents of the rvalue to escape. Print error messages when these are detected. Infer &lt;code&gt;scope&lt;/code&gt; attribute for the lvalue where possible, in order to eliminate the error.</source>
          <target state="translated">На основании &lt;code&gt;AssignExp&lt;/code&gt; определите, будет ли lvalue вызывать экранирование содержимого rvalue. Распечатайте сообщения об ошибках, когда они обнаружены. По &lt;code&gt;scope&lt;/code&gt; выводите атрибут области видимости для lvalue, чтобы устранить ошибку.</target>
        </trans-unit>
        <trans-unit id="f4edc9674fd3041f4bd8fcdf8c36704d26537a1f" translate="yes" xml:space="preserve">
          <source>Given an Expression, find the variable it really is.</source>
          <target state="translated">Получив выражение,найдите переменную,которой оно является на самом деле.</target>
        </trans-unit>
        <trans-unit id="10135b6f779b47ff66661cf2060528825cdb0465" translate="yes" xml:space="preserve">
          <source>Given an allocator factory, lazily creates as many allocators as needed to satisfy allocation requests. The allocators are stored in a linked list. Requests for allocation are satisfied by searching the list in a linear manner.</source>
          <target state="translated">Учитывая наличие фабрики по производству распределителей,лениво создает столько распределителей,сколько необходимо для удовлетворения заявок на выделение ресурсов.Аллокаторы хранятся в связанном списке.Запросы на выделение ресурсов удовлетворяются путем линейного поиска по списку.</target>
        </trans-unit>
        <trans-unit id="c68fd4e0d6a4caa1cbbef6c7b7cc84e1b16b2800" translate="yes" xml:space="preserve">
          <source>Given an error instantiating the TemplateInstance, give the nested TemplateInstance instantiations that got us here. Those are a list threaded into the nested scopes.</source>
          <target state="translated">Учитывая ошибку,приведшую к инстанциии Шаблона,дайте вложенные инстанциии Шаблона,которые привели нас сюда.Это список,вложенный во вложенные диапазоны.</target>
        </trans-unit>
        <trans-unit id="0d192178ddf2961ae655bd11083f31d24b553ec6" translate="yes" xml:space="preserve">
          <source>Given an expression e that is an array, determine and set the 'length' variable.</source>
          <target state="translated">Получив выражение e,которое является массивом,определите и установите переменную 'length'.</target>
        </trans-unit>
        <trans-unit id="13b4b240c1888ba281f7a8d067f704fc09eba179" translate="yes" xml:space="preserve">
          <source>Given array literal oldval of type ArrayLiteralExp or StringExp, of length oldlen, change its length to newlen. If the newlen is longer than oldlen, all new elements will be set to the default initializer for the element type.</source>
          <target state="translated">При заданном массиве литерала oldval типа ArrayLiteralExp или StringExp,длины oldlen,измените его длину на newlen.Если newlen длиннее oldlen,то все новые элементы будут установлены в инициализатор по умолчанию для типа элемента.</target>
        </trans-unit>
        <trans-unit id="4fe6c27981ac387048ac652b298a3c233afd1136" translate="yes" xml:space="preserve">
          <source>Given array of foreach parameters and an aggregate type, find best opApply overload, if any of the parameter types are missing, attempt to infer them from the aggregate type.</source>
          <target state="translated">Учитывая массив параметров фораха и агрегированный тип,найдите наилучшую перегрузку opApply,если какой-либо из типов параметров отсутствует,попытайтесь вывести их из агрегированного типа.</target>
        </trans-unit>
        <trans-unit id="548081a2237345a0383114c21603c8b8dab1f303" translate="yes" xml:space="preserve">
          <source>Given callable (&lt;a href=&quot;std_traits#isCallable&quot;&gt;&lt;code&gt;std.traits.isCallable&lt;/code&gt;&lt;/a&gt;) &lt;code&gt;fun&lt;/code&gt;, create as a range whose front is defined by successive calls to &lt;code&gt;fun()&lt;/code&gt;. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire &lt;code&gt;front&lt;/code&gt;/&lt;code&gt;popFront&lt;/code&gt;/&lt;code&gt;empty&lt;/code&gt; structure. &lt;code&gt;fun&lt;/code&gt; maybe be passed either a template alias parameter (existing function, delegate, struct type defining &lt;code&gt;static opCall&lt;/code&gt;) or a run-time value argument (delegate, function object). The result range models an InputRange (&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;). The resulting range will call &lt;code&gt;fun()&lt;/code&gt; on construction, and every call to &lt;code&gt;popFront&lt;/code&gt;, and the cached value will be returned when &lt;code&gt;front&lt;/code&gt; is called.</source>
          <target state="translated">Принимая во внимание вызываемое ( &lt;a href=&quot;std_traits#isCallable&quot;&gt; &lt;code&gt;std.traits.isCallable&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;fun&lt;/code&gt; , создайте как диапазон, фронт которого определяется последовательными вызовами &lt;code&gt;fun()&lt;/code&gt; . Это особенно полезно для вызова функции с глобальными побочными эффектами (случайные функции) или для создания диапазонов, выраженных в виде одного делегата, а не всей структуры &lt;code&gt;front&lt;/code&gt; / &lt;code&gt;popFront&lt;/code&gt; / &lt;code&gt;empty&lt;/code&gt; . &lt;code&gt;fun&lt;/code&gt; может быть передан либо параметр псевдонима шаблона (существующая функция, делегат, тип структуры, определяющий &lt;code&gt;static opCall&lt;/code&gt; ), либо аргумент значения времени выполнения (делегат, объект функции). Диапазон результатов моделирует InputRange ( &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt; ). Полученный диапазон вызовет &lt;code&gt;fun()&lt;/code&gt; на конструкции, и каждый вызов &lt;code&gt;popFront&lt;/code&gt; , и кэшированное значение будет возвращено при вызове &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6cdf45c5874188e502ef446c2f299954ad8e06e" translate="yes" xml:space="preserve">
          <source>Given function arguments, figure out which template function to expand, and return matching result.</source>
          <target state="translated">Получив аргументы функции,выясните,какую шаблонную функцию следует развернуть,и верните результат совпадения.</target>
        </trans-unit>
        <trans-unit id="2c41e0d5b6e5292f4394dbada3bf0e11b9965e54" translate="yes" xml:space="preserve">
          <source>Given that it is only called with &lt;a href=&quot;#safe-values&quot;&gt;safe values&lt;/a&gt; and &lt;a href=&quot;#safe-aliasing&quot;&gt;safe aliasing&lt;/a&gt;, a function has a safe interface when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c0666f9da353f9c6f10f1cf5edecb5189140bb" translate="yes" xml:space="preserve">
          <source>Given that the most frequent use of &lt;code&gt;InSituRegion&lt;/code&gt; is as a stack allocator, it allocates starting at the end on systems where stack grows downwards, such that hot memory is used first.</source>
          <target state="translated">Учитывая, что чаще всего &lt;code&gt;InSituRegion&lt;/code&gt; используется в качестве распределителя стека, он выделяется, начиная с конца, в системах, где размер стека уменьшается , так что сначала используется горячая память.</target>
        </trans-unit>
        <trans-unit id="433dfce23255598b88ff3eee832e615faf6acb1f" translate="yes" xml:space="preserve">
          <source>Given that ti is an instance of this TemplateDeclaration, deduce the types of the parameters to this, and store those deduced types in dedtypes[].</source>
          <target state="translated">Учитывая,что ti является экземпляром данного TemplateDeclaration,выведите типы параметров к этому,и сохраните эти выведенные типы в виде dedtypes[].</target>
        </trans-unit>
        <trans-unit id="de6b7e538358277d4d77d0a6dfdd22d328ebcdc2" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such log(x) - digamma(x) = y.</source>
          <target state="translated">Учитывая y,функция находит x такой log(x)-digamma(x)=y.</target>
        </trans-unit>
        <trans-unit id="992b94a2b2bacb1095a0b111a75eb520df8ea274" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such that</source>
          <target state="translated">Учитывая y,функция находит x таким образом,что</target>
        </trans-unit>
        <trans-unit id="b5ce07b779103b2800f63623f7d95755262b29ac" translate="yes" xml:space="preserve">
          <source>Gives a hint to the processor that the calling thread is in a 'spin-wait' loop, allowing to more efficiently allocate resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d6838e980e7d735fe427a6cf2d72e4e8647a21" translate="yes" xml:space="preserve">
          <source>Gives a string containing all of the member variables on their own line.</source>
          <target state="translated">Дает строку,содержащую все переменные-члены в собственной строке.</target>
        </trans-unit>
        <trans-unit id="7913f0379d403503a25672003418cf5f3eca8630" translate="yes" xml:space="preserve">
          <source>Gives a string in the form of &lt;code&gt;Appender!(A)(data)&lt;/code&gt;.</source>
          <target state="translated">Дает строку в виде &lt;code&gt;Appender!(A)(data)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ea4a4989f9ed3007485f30bc4c477cf8cf78af" translate="yes" xml:space="preserve">
          <source>Gives a template that can be used to apply the same attributes that are on the given type &lt;code&gt;T&lt;/code&gt;. E.g. passing &lt;code&gt;inout shared int&lt;/code&gt; will return &lt;code&gt;SharedInoutOf&lt;/code&gt;.</source>
          <target state="translated">Дает шаблон , который может быть использован , чтобы применить те же атрибуты , которые находятся на данном типе &lt;code&gt;T&lt;/code&gt; . Например, передача &lt;code&gt;inout shared int&lt;/code&gt; вернет &lt;code&gt;SharedInoutOf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2633d057ea2e2d5df044edc1a3e53e74d5c07e4" translate="yes" xml:space="preserve">
          <source>Gives size in bytes of the memory mapped file.</source>
          <target state="translated">Дает размер в байтах отображаемого файла памяти.</target>
        </trans-unit>
        <trans-unit id="16bbae332a1e2ca617ea29aad4cae716be022cf2" translate="yes" xml:space="preserve">
          <source>Gives the &lt;code&gt;sizeof&lt;/code&gt; the largest type given.</source>
          <target state="translated">Дает &lt;code&gt;sizeof&lt;/code&gt; самого большого заданного типа.</target>
        </trans-unit>
        <trans-unit id="83055a3a0dd1a147d856955312d10beee008598a" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Дает разницу между двумя &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7aeb61024a32a4be6fbe1fa0169b6dc0e34e0c60" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Дает разницу между двумя &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; с.</target>
        </trans-unit>
        <trans-unit id="a3e5e3dc87d1abe001240e5d15a0f4c35cd6e9f2" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Дает разницу между двумя &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="e0ddf7ec5492699d7655f4aa024331ee0d174c96" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Дает разницу между двумя &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="23a706ac15ae0a2795d3b9540c47b5bd8f3ce3a4" translate="yes" xml:space="preserve">
          <source>Gives the last power of two before &lt;code&gt;val&lt;/code&gt;. &amp;lt;&amp;gt;&amp;gt; can be any built-in numerical type.</source>
          <target state="translated">Дает последнюю силу двоих перед &lt;code&gt;val&lt;/code&gt; . &amp;lt;&amp;gt;&amp;gt; может быть любым встроенным числовым типом.</target>
        </trans-unit>
        <trans-unit id="5eba15a4a12033f10f76ecaeb54e9264300c3d84" translate="yes" xml:space="preserve">
          <source>Gives the next power of two after &lt;code&gt;val&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; can be any built-in numerical type.</source>
          <target state="translated">Дает следующую силу двух после &lt;code&gt;val&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; может быть любым встроенным числовым типом.</target>
        </trans-unit>
        <trans-unit id="5dcd127d912205c801dfa9fd55aab21bc7540488" translate="yes" xml:space="preserve">
          <source>Gives the precision for numeric conversions. If the precision is a &lt;b&gt;*&lt;/b&gt;, an additional argument of type &lt;b&gt;int&lt;/b&gt;, preceding the actual argument, is taken as the precision. If it is negative, it is as if there was no</source>
          <target state="translated">Дает точность для числовых преобразований. Если точность равна &lt;b&gt;*&lt;/b&gt; , дополнительный аргумент типа &lt;b&gt;int&lt;/b&gt; , предшествующий фактическому аргументу, принимается за точность. Если это отрицательно, это как если бы не было</target>
        </trans-unit>
        <trans-unit id="066636e1bed1369dff6efcd3fab1c1e8776d7710" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from</source>
          <target state="translated">Дает результат сложения или вычитания &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; from</target>
        </trans-unit>
        <trans-unit id="13fd9f69f64522f3bd20d1184529d631b3677431" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дает результат сложения или вычитания &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; из этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , а также присваивания результата этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c64b6298caea8c356268035bf6bb2213d1e63d" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дает результат сложения или вычитания &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; из этого &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1405f5ebc75767bb0c5bcf744b2d2f96a676122" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дает результат добавления или вычитания &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; из этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; , а также присваивания результата этому &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aea621df7ee3b5185f92bf03dc43838e74f11ab8" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дает результат сложения или вычитания &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; из этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d5dfde7603919eee6582396d3e52686e64f60c3" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дает результат добавления или вычитания &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; из этого &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; , а также присваивания результата этому &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1b9fd1a6e616c022dd85e5f596721b33e55dad9" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дает результат сложения или вычитания &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; из этого &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7bb55c3ac43c11992ce982a465028a297070c37" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a duration from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дает результат сложения или вычитания длительности из этого &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; , а также присваивания результата этому &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b010645431226eb0d475a6508504f6360118e2aa" translate="yes" xml:space="preserve">
          <source>Gives the string &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; if &lt;code&gt;isNull&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is equivalent to calling &lt;a href=&quot;std_format#formattedWrite&quot;&gt;&lt;code&gt;std.format.formattedWrite&lt;/code&gt;&lt;/a&gt; on the underlying value.</source>
          <target state="translated">Дает строку &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; , если &lt;code&gt;isNull&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; . В противном случае результат эквивалентен вызову &lt;a href=&quot;std_format#formattedWrite&quot;&gt; &lt;code&gt;std.format.formattedWrite&lt;/code&gt; &lt;/a&gt; для базового значения.</target>
        </trans-unit>
        <trans-unit id="ee3ba1f4d58b51dacaf77da9e736c2398dd52211" translate="yes" xml:space="preserve">
          <source>Giving better error messages inside generic code than the sometimes hard to follow compiler ones.</source>
          <target state="translated">Дает лучшие сообщения об ошибках внутри общего кода,чем иногда трудно следовать компилятору.</target>
        </trans-unit>
        <trans-unit id="fe40132df9803a579f2616316fd9f36e8b76b6f5" translate="yes" xml:space="preserve">
          <source>Glagolitic</source>
          <target state="translated">Glagolitic</target>
        </trans-unit>
        <trans-unit id="52d16b8e3607d3a956a90dad397b270e88b2a626" translate="yes" xml:space="preserve">
          <source>Glibc C runtime</source>
          <target state="translated">время выполнения Глибк С</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">Глобальные функции</target>
        </trans-unit>
        <trans-unit id="60d510ca3fec034b096ecb101e79c44baa3bcfa4" translate="yes" xml:space="preserve">
          <source>Global and Static Initializers</source>
          <target state="translated">Глобальные и статические инициализаторы</target>
        </trans-unit>
        <trans-unit id="ad8992e0e77b510d8dd8c9f31b8493285307157f" translate="yes" xml:space="preserve">
          <source>Global names</source>
          <target state="translated">Глобальные имена</target>
        </trans-unit>
        <trans-unit id="fb160cab6ebf08ae16224b7387fbe010ff67af79" translate="yes" xml:space="preserve">
          <source>Global random number generator used by various functions in this module whenever no generator is specified. It is allocated per-thread and initialized to an unpredictable value for each thread.</source>
          <target state="translated">Генератор глобальных случайных чисел,используемый различными функциями в данном модуле,когда не указан ни один генератор.Он выделяется на поток и инициализируется до непредсказуемого значения для каждого потока.</target>
        </trans-unit>
        <trans-unit id="359a7909d420e528181333df942be655d355c0d2" translate="yes" xml:space="preserve">
          <source>Global regex, repeat over the whole input.</source>
          <target state="translated">Глобальный регекс,повторите по всему входу.</target>
        </trans-unit>
        <trans-unit id="9d8204544b72aac8944f7aa50f34d5f2b83ebda7" translate="yes" xml:space="preserve">
          <source>Global status of the CTFE engine. Mostly used for performance diagnostics</source>
          <target state="translated">Глобальный статус двигателя CTFE.В основном используется для диагностики производительности</target>
        </trans-unit>
        <trans-unit id="3bb8f4a4ce9e8fc53902a34f5711af6100354847" translate="yes" xml:space="preserve">
          <source>Global variables.</source>
          <target state="translated">Глобальные переменные.</target>
        </trans-unit>
        <trans-unit id="322346956002b43d1272ba3ca4fad36e87acf31f" translate="yes" xml:space="preserve">
          <source>Go through the variables in function fd that are to be allocated in a closure, and set the .offset fields for those variables to their positions relative to the start of the closure instance. Also turns off nrvo for closure variables.</source>
          <target state="translated">Просмотрите переменные в функции fd,которые должны быть выделены при закрытии,и установите поля .offset для этих переменных в их позиции относительно начала экземпляра закрытия.Также отключает nrvo для переменных close.</target>
        </trans-unit>
        <trans-unit id="83644e2182412c095ed367b8519c41f7f1a72b2f" translate="yes" xml:space="preserve">
          <source>Good error handling code tends to clutter up what otherwise would be a neat and clean looking implementation.</source>
          <target state="translated">Хороший код обработки ошибок имеет тенденцию загромождать то,что в противном случае было бы аккуратной и чистой реализацией.</target>
        </trans-unit>
        <trans-unit id="a4cc20ddddd5df91dbeeeac20e28069cdc6d35d5" translate="yes" xml:space="preserve">
          <source>Gothic</source>
          <target state="translated">Gothic</target>
        </trans-unit>
        <trans-unit id="523bd87e510be4584eb678bda56047b4e81b4e41" translate="yes" xml:space="preserve">
          <source>Goto Statement</source>
          <target state="translated">программное заявление</target>
        </trans-unit>
        <trans-unit id="d153d2afa0d10e789b42decd9c86f4c6ba7c4b32" translate="yes" xml:space="preserve">
          <source>GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt;;</source>
          <target state="translated">GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2d75a452fb197b862328ddf89077f60c5411007e" translate="yes" xml:space="preserve">
          <source>GotoStatement</source>
          <target state="translated">GotoStatement</target>
        </trans-unit>
        <trans-unit id="469b09861974ba8cba6608f5b50f5a4378e847aa" translate="yes" xml:space="preserve">
          <source>GotoStatements* &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt;;</source>
          <target state="translated">GotoStatements * &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b1b76e26ed39195055923abbd6da5da5869145b4" translate="yes" xml:space="preserve">
          <source>Gotos with forward references</source>
          <target state="translated">Gotos с прямыми ссылками</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="40e6976321b98f0050106aca23fe0094f3e12aec" translate="yes" xml:space="preserve">
          <source>Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;(Input)(ref Input inp)</source>
          <target state="translated">Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt; (входной) (ссылка входной вход)</target>
        </trans-unit>
        <trans-unit id="09e21aefbc5d72becfb6e61403ad83558925c509" translate="yes" xml:space="preserve">
          <source>Grapheme cluster length in &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">Длина кластера графемы в &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точках&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85a58af54a6759d4a9d1a773cb4f960185f26fe4" translate="yes" xml:space="preserve">
          <source>Grapheme_Base</source>
          <target state="translated">Grapheme_Base</target>
        </trans-unit>
        <trans-unit id="9aa96ceeca035f99f4979af4785877395b3fcca9" translate="yes" xml:space="preserve">
          <source>Grapheme_Extend</source>
          <target state="translated">Grapheme_Extend</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="305ccd272b16a96e13db1c4faa38b1913caf51d8" translate="yes" xml:space="preserve">
          <source>Greek Extended</source>
          <target state="translated">греческий Расширенный</target>
        </trans-unit>
        <trans-unit id="63e0451063c60d5f6eae102313ee1b6d993a1f76" translate="yes" xml:space="preserve">
          <source>Greek and Coptic</source>
          <target state="translated">греческий и коптский</target>
        </trans-unit>
        <trans-unit id="73fb2dd5cc2643e9f02bc351410b98713e0c50c9" translate="yes" xml:space="preserve">
          <source>Group separator</source>
          <target state="translated">Групповой сепаратор</target>
        </trans-unit>
        <trans-unit id="10986e5fcbdd40c81d3e51dfc3ad691df9a6347c" translate="yes" xml:space="preserve">
          <source>Group!(pred, Range) &lt;strong id=&quot;group&quot;&gt;group&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range r);</source>
          <target state="translated">Группа! (Pred, Range) &lt;strong id=&quot;group&quot;&gt;группа&lt;/strong&gt; (псевдоним pred = &quot;a == b&quot;, Range) (Range r);</target>
        </trans-unit>
        <trans-unit id="83af1301254c2810b776d48cab533ffdca19f557" translate="yes" xml:space="preserve">
          <source>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions.</source>
          <target state="translated">Группирует последовательно эквивалентные элементы в один кортеж элемента и количество его повторений.</target>
        </trans-unit>
        <trans-unit id="afb8bcba7055a53eb0c5db950f6c2af39388fdf2" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using &lt;code&gt;alloc&lt;/code&gt;. The extra elements added are either default- initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Увеличивает &lt;code&gt;array&lt;/code&gt; , добавляя &lt;code&gt;delta&lt;/code&gt; больше элементов. Необходимая память выделяется с помощью &lt;code&gt;alloc&lt;/code&gt; . Добавленные дополнительные элементы либо инициализируются по умолчанию, либо заполняются копиями &lt;code&gt;init&lt;/code&gt; , либо инициализируются значениями, полученными из &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e03f30a2f53aecda689ec68c63bc0d88b73542a6" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using the same allocator that was used for the array type. The extra elements added are either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Увеличивает &lt;code&gt;array&lt;/code&gt; , добавляя &lt;code&gt;delta&lt;/code&gt; больше элементов. Необходимая память выделяется с использованием того же распределителя, который использовался для типа массива. Добавленные дополнительные элементы либо инициализируются по умолчанию, либо заполняются копиями &lt;code&gt;init&lt;/code&gt; , либо инициализируются значениями, полученными из &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77afda6ffc95cc0f06adb904e94cef0fc69add7d" translate="yes" xml:space="preserve">
          <source>Guaranteed &amp;Omicron;(&lt;code&gt;abs(length - newLength)&lt;/code&gt;) if &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt;. If &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; the worst case is &amp;Omicron;(&lt;code&gt;newLength&lt;/code&gt;).</source>
          <target state="translated">Гарантировано &amp;Omicron; ( &lt;code&gt;abs(length - newLength)&lt;/code&gt; ), если &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt; . Если &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; наихудший случай - &amp;Omicron; ( &lt;code&gt;newLength&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="35776951606a73d6ff2bfb1c43d6ba2de2721cad" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet</source>
          <target state="translated">Шателе Гийома</target>
        </trans-unit>
        <trans-unit id="971317803587830757efb436fa41eeb1d9292828" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet Manu Evans</source>
          <target state="translated">Гийом Шателе Ману Эванс</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="72c5d728b8c5e13d38cf050220cb41c1803704d1" translate="yes" xml:space="preserve">
          <source>H &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">H &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44602ce53397cc7e3837311abb7db1d03042b84" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="translated">&lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;Учебное пособие&lt;/a&gt; HS Teoh по компонентному программированию с диапазонами для реальной демонстрации влияния программирования на основе диапазонов на сложные алгоритмы.</target>
        </trans-unit>
        <trans-unit id="bbe1ea5931e3b073b2c3409ef7882568b8096068" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;https://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa36c2d12dc8308dd96737ca9539591241ccb57" translate="yes" xml:space="preserve">
          <source>HTML can be embedded into the documentation comments, and it will be passed through to the HTML output unchanged. However, since it is not necessarily true that HTML will be the desired output format of the embedded documentation comment extractor, it is best to avoid using it where practical.</source>
          <target state="translated">HTML может быть встроен в комментарий к документации,и он будет передаваться в HTML-вывод без изменений.Однако,поскольку HTML не обязательно будет нужным форматом вывода встроенного комментария к документации,лучше избегать его использования там,где это целесообразно.</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="0481530df63832f72dfdebbe0c7a51d57e32da26" translate="yes" xml:space="preserve">
          <source>HTTP &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">HTTP- &lt;code&gt;conn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca83e4b247db9f9a4bf080067c192c5cb65a0d61" translate="yes" xml:space="preserve">
          <source>HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="e4e09a7d12cb155ba460134c8bdd1f1479d801ce" translate="yes" xml:space="preserve">
          <source>HTTP POST method</source>
          <target state="translated">метод HTTP POST</target>
        </trans-unit>
        <trans-unit id="923988ff39d0e3042c9df0f259d1de84a01fde11" translate="yes" xml:space="preserve">
          <source>HTTP PUT</source>
          <target state="translated">HTTP PUT</target>
        </trans-unit>
        <trans-unit id="cc2478137d7b71e72935b2fddc027880593e756f" translate="yes" xml:space="preserve">
          <source>HTTP client functionality.</source>
          <target state="translated">Функциональность HTTP-клиента.</target>
        </trans-unit>
        <trans-unit id="827e4a67a71c875b43e732a905d1fd8e7200d6d6" translate="yes" xml:space="preserve">
          <source>HTTP connect request.</source>
          <target state="translated">Запрос HTTP-соединения.</target>
        </trans-unit>
        <trans-unit id="51449b9a0615713cbd19f5f01e23d5f58e4358b0" translate="yes" xml:space="preserve">
          <source>HTTP connection to use</source>
          <target state="translated">HTTP-соединение для использования</target>
        </trans-unit>
        <trans-unit id="797634e3b267b6d81699bf16ac8a0f81dc1a1ba6" translate="yes" xml:space="preserve">
          <source>HTTP connection to use  The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">HTTP-соединение для использования Параметр шаблона &lt;code&gt;T&lt;/code&gt; указывает тип для возврата. Возможные значения: &lt;code&gt;char&lt;/code&gt; и &lt;code&gt;ubyte&lt;/code&gt; для возврата &lt;code&gt;char[]&lt;/code&gt; или &lt;code&gt;ubyte[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5b69d980b7b8a0f8d5057989430d112ecf22206" translate="yes" xml:space="preserve">
          <source>HTTP method used.</source>
          <target state="translated">Использован метод HTTP.</target>
        </trans-unit>
        <trans-unit id="bedfc3b8a98f74436dfffc470905a4cb727d6eb4" translate="yes" xml:space="preserve">
          <source>HTTP options request.</source>
          <target state="translated">Запрос опций HTTP.</target>
        </trans-unit>
        <trans-unit id="eca27a5fb0f79404f93ba2b2ff7621d850fa94c3" translate="yes" xml:space="preserve">
          <source>HTTP patch content.</source>
          <target state="translated">Содержимое HTTP-патчей.</target>
        </trans-unit>
        <trans-unit id="0f24bcb381b514379fb794061233a0fac483e67d" translate="yes" xml:space="preserve">
          <source>HTTP post content.</source>
          <target state="translated">Содержимое сообщения HTTP.</target>
        </trans-unit>
        <trans-unit id="fd473bd4cc525d8634b2d06223e94be806e9169e" translate="yes" xml:space="preserve">
          <source>HTTP request, for odd commands like DELETE, TRACE and others</source>
          <target state="translated">HTTP запрос,для нечетных команд типа DELETE,TRACE и др.</target>
        </trans-unit>
        <trans-unit id="7c360b79abb627a8a4c93e546c995b917aedbbb1" translate="yes" xml:space="preserve">
          <source>HTTP status line code e.g. 200.</source>
          <target state="translated">код строки состояния HTTP,например 200.</target>
        </trans-unit>
        <trans-unit id="7fb8b94d5f23dd0fd12704704bd5724a9a81dd11" translate="yes" xml:space="preserve">
          <source>HTTP status line ie. the first line returned in an HTTP response.</source>
          <target state="translated">Строка состояния HTTP,т.е.первая строка,возвращаемая в ответе HTTP.</target>
        </trans-unit>
        <trans-unit id="5c1ee2091ce3bea9e5a23e0562f6b6fd7953de16" translate="yes" xml:space="preserve">
          <source>HTTP status line of last response. One call to perform may result in several requests because of redirection.</source>
          <target state="translated">HTTP статус строки последнего ответа.Один вызов на выполнение может привести к нескольким запросам из-за переадресации.</target>
        </trans-unit>
        <trans-unit id="45f917922bd09e11086c274630d2415137d36f0f" translate="yes" xml:space="preserve">
          <source>HTTP status line reason string.</source>
          <target state="translated">Строка причины строки состояния HTTP.</target>
        </trans-unit>
        <trans-unit id="1909e6b2261783a8d317d6f55a66a50ec6cfafb1" translate="yes" xml:space="preserve">
          <source>HTTP trace request.</source>
          <target state="translated">Запрос трассировки HTTP.</target>
        </trans-unit>
        <trans-unit id="52f8dbc2c259a9731d9751db65ced2bb8937f72a" translate="yes" xml:space="preserve">
          <source>HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</source>
          <target state="translated">HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59dd0563a7efe56dbe888a8e6b63f08d0ec7b1a" translate="yes" xml:space="preserve">
          <source>HTTP/FTP delete content.</source>
          <target state="translated">HTTP/FTP удалить содержимое.</target>
        </trans-unit>
        <trans-unit id="c911addb5a09d460fe739f0ee6699cd1115b2ceb" translate="yes" xml:space="preserve">
          <source>HTTP/FTP download to local file system.</source>
          <target state="translated">HTTP/FTP загрузка в локальную файловую систему.</target>
        </trans-unit>
        <trans-unit id="444e75970e6f6b8a13c7660b530b8789eb9d1688" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks asynchronously.</source>
          <target state="translated">HTTP/FTP извлекать содержимое в виде диапазона кусков асинхронно.</target>
        </trans-unit>
        <trans-unit id="067f2a38c032292745289e6d568747297c1eb36d" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks.</source>
          <target state="translated">HTTP/FTP извлекать содержимое в виде диапазона блоков.</target>
        </trans-unit>
        <trans-unit id="ba7a6201d2a706377c412c319526144deec7201e" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines asynchronously.</source>
          <target state="translated">HTTP/FTP извлекать содержимое как диапазон строк асинхронно.</target>
        </trans-unit>
        <trans-unit id="a30ab80f3f96882837554330daf0f4a6aaa048ff" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines.</source>
          <target state="translated">HTTP/FTP извлекать содержимое в виде диапазона строк.</target>
        </trans-unit>
        <trans-unit id="0a0a651b4d9a70a2c11401ce60fa08020ea7c52c" translate="yes" xml:space="preserve">
          <source>HTTP/FTP get content.</source>
          <target state="translated">HTTP/FTP получать контент.</target>
        </trans-unit>
        <trans-unit id="a18566ddab985dc1d64ecd1c3e55c7fe0283f6cd" translate="yes" xml:space="preserve">
          <source>HTTP/FTP put content.</source>
          <target state="translated">HTTP/FTP вкладывать контент.</target>
        </trans-unit>
        <trans-unit id="fd41ab93c5537d58968dc08902626f4aedcfc790" translate="yes" xml:space="preserve">
          <source>Halfwidth and Fullwidth Forms</source>
          <target state="translated">Половину ширины и полную ширину форм</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="495fba644d4dd3d28a3df2c5e262bc0aa344bdc1" translate="yes" xml:space="preserve">
          <source>Handle and transcode between various text encodings.</source>
          <target state="translated">Обработка и перекодировка между различными текстовыми кодировками.</target>
        </trans-unit>
        <trans-unit id="4cae35b945ed013183aeec759fb173f2b5e74ee5" translate="yes" xml:space="preserve">
          <source>Handle enums.</source>
          <target state="translated">Обращайся к перечню.</target>
        </trans-unit>
        <trans-unit id="70c0fd2c64cbbc7d9a73e18bc0fd02b46b142b9f" translate="yes" xml:space="preserve">
          <source>Handle exceptions thrown from range primitives.</source>
          <target state="translated">Обращаться с исключениями,брошенными из примитивов диапазона.</target>
        </trans-unit>
        <trans-unit id="ed3da861f4c68bd404277c3815bb4277903ee0c7" translate="yes" xml:space="preserve">
          <source>Handle the postblit call on lvalue, or the move of rvalue.</source>
          <target state="translated">Обращайтесь к послесимвольному вызову на lvalue,или к движению rvalue.</target>
        </trans-unit>
        <trans-unit id="e61477ad33d711243071181209298dcaac99b754" translate="yes" xml:space="preserve">
          <source>Handle to the system-specific semaphore.</source>
          <target state="translated">Обратитесь к семафору,специфическому для данной системы.</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="46a74e921ed0b81734815d203a76d63ac9b445e2" translate="yes" xml:space="preserve">
          <source>Hangul Compatibility Jamo</source>
          <target state="translated">Джамо-совместимость Хангуль</target>
        </trans-unit>
        <trans-unit id="6e435e03b7ff7b49d783dd12f4139eb337e88129" translate="yes" xml:space="preserve">
          <source>Hangul Jamo</source>
          <target state="translated">Хангуль-Джамо</target>
        </trans-unit>
        <trans-unit id="1af30ae437546a0c8f4e8c904b38e9e32c465cd5" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-A</source>
          <target state="translated">Хангуль Джамо Расширенный-A</target>
        </trans-unit>
        <trans-unit id="7f76ea3a5ca65b3f7be6271028b86fb4c24ad5b4" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-B</source>
          <target state="translated">Хангульское Джамо Расширенное-B</target>
        </trans-unit>
        <trans-unit id="a3c09f1beeeb5e6518d7a5aa130f9229a5bab1c8" translate="yes" xml:space="preserve">
          <source>Hangul Syllables</source>
          <target state="translated">слоги Хангула</target>
        </trans-unit>
        <trans-unit id="9649db5db6338c7bb1ab5215b20988c58817b67a" translate="yes" xml:space="preserve">
          <source>Hangul syllables are not covered by this function. See &lt;code&gt;composeJamo&lt;/code&gt; below.</source>
          <target state="translated">Слоги хангыль не охватываются этой функцией. Смотрите &lt;code&gt;composeJamo&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="e938944cea2d9cc40e1f9955e4a0cfe8a2544308" translate="yes" xml:space="preserve">
          <source>Hardware Control</source>
          <target state="translated">Управление аппаратным обеспечением</target>
        </trans-unit>
        <trans-unit id="624a7b201d0ea02f7b27a09976e5469ea739a9e3" translate="yes" xml:space="preserve">
          <source>Has the same meaning as outside of a character class.</source>
          <target state="translated">Имеет то же значение,что и вне класса персонажей.</target>
        </trans-unit>
        <trans-unit id="ff69afc8afb157be53fcca5d806ead0afca8f54a" translate="yes" xml:space="preserve">
          <source>Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;(Hash)();</source>
          <target state="translated">Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt; (Хэш) ();</target>
        </trans-unit>
        <trans-unit id="512530e2001855653aa805d74cb64a05638ad3fd" translate="yes" xml:space="preserve">
          <source>Hash options.</source>
          <target state="translated">Есть варианты.</target>
        </trans-unit>
        <trans-unit id="82c3b55a6e6190b4ea897a708e89b49564008ef7" translate="yes" xml:space="preserve">
          <source>Hash syntax for json objects.</source>
          <target state="translated">Синтаксис хэша для объектов Джсона.</target>
        </trans-unit>
        <trans-unit id="8d05adeedcb7aa54cc03e4f260b3e38d1479ae1c" translate="yes" xml:space="preserve">
          <source>HashTab container for internal usage.</source>
          <target state="translated">Контейнер HashTab для внутреннего использования.</target>
        </trans-unit>
        <trans-unit id="201cd54dff7c562fa04665ce3ec7f389323b7356" translate="yes" xml:space="preserve">
          <source>Have some variables that are maybescopes that were assigned values from other maybescope variables. Now that semantic analysis of the function is complete, we can finalize this by turning off maybescope for array elements that cannot be scope.</source>
          <target state="translated">Есть некоторые переменные,которые являются maybescopes,которым были присвоены значения из других переменных maybescope.Теперь,когда семантический анализ функции завершен,мы можем закончить это,отключив Maybescope для элементов массива,которые не могут быть доступны.</target>
        </trans-unit>
        <trans-unit id="dea56ebbd4737b0cd9262ab0c819e3683d0b5416" translate="yes" xml:space="preserve">
          <source>Having unmatched parentheses can hose the output of Ddoc, as the macros depend on properly nested parentheses. This function replaces all ( with ( and ) with ) to preserve text literally. This also means macros in the text won't be expanded.</source>
          <target state="translated">Имея несопоставимые круглые скобки,можно шлангом выводить Ddoc,так как макросы зависят от правильно вложенных круглых скобок.Эта функция заменяет все(на(и)на)для сохранения текста в буквальном смысле.Это также означает,что макросы в тексте не будут расширены.</target>
        </trans-unit>
        <trans-unit id="71653e5271aa72abad98ba52f8927b0be428b96b" translate="yes" xml:space="preserve">
          <source>Haystack &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">Хейстек &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0403de1effb4e88849c3d2d079f299e89f093ed" translate="yes" xml:space="preserve">
          <source>HeaderFormat &lt;code&gt;header&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; HeaderFormat</target>
        </trans-unit>
        <trans-unit id="c97d4c3dede14ee24bc42018c52f19917fd481c9" translate="yes" xml:space="preserve">
          <source>Headings</source>
          <target state="translated">Headings</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="fbea2ec13adcf999e380e13a429a4e17dc3d8090" translate="yes" xml:space="preserve">
          <source>Help Information Generation</source>
          <target state="translated">Генерация справочной информации</target>
        </trans-unit>
        <trans-unit id="1e7eebdb08c9dbf27c7668e2badd51e667707d3c" translate="yes" xml:space="preserve">
          <source>Helper</source>
          <target state="translated">Helper</target>
        </trans-unit>
        <trans-unit id="5e31a530e83afec402c4c09898e79e56b473dc7d" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create a string literal consisting of 'value' duplicated 'dim' times.</source>
          <target state="translated">Помощник для NewExp Создать строковый литерал,состоящий из 'value' дублированного 'dim' раза.</target>
        </trans-unit>
        <trans-unit id="766c386647e8e48a9fcd435724f1d350167f7ed5" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create an array literal consisting of 'elem' duplicated 'dim' times.</source>
          <target state="translated">Помощник для NewExp Создать литерал массива,состоящего из 'elem' дублированного 'dim' раза.</target>
        </trans-unit>
        <trans-unit id="c02c79263e4ed8c5595da2dd0c63a6d49edcd0eb" translate="yes" xml:space="preserve">
          <source>Helper function for &lt;code&gt;getRightThis()&lt;/code&gt;. Gets &lt;code&gt;this&lt;/code&gt; of the next outer aggregate.</source>
          <target state="translated">Вспомогательная функция для &lt;code&gt;getRightThis()&lt;/code&gt; . Получает &lt;code&gt;this&lt;/code&gt; из следующего внешнего агрегата.</target>
        </trans-unit>
        <trans-unit id="467531459771317152c9703e3f120447d81f80b5" translate="yes" xml:space="preserve">
          <source>Helper function for easy error propagation. If error occurs, returns ErrorExp. Otherwise returns NULL.</source>
          <target state="translated">Функция помощи для легкого распространения ошибок.При возникновении ошибки возвращает ErrorExp.В противном случае возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="3576c823fa70ffbb40f146b4e65274f6dc08a676" translate="yes" xml:space="preserve">
          <source>Helper function for the expansion of manifest constant.</source>
          <target state="translated">Функция помощника для расширения манифестной константы.</target>
        </trans-unit>
        <trans-unit id="f45a0f048cca01c298f3e28147b97707c3bec7c9" translate="yes" xml:space="preserve">
          <source>Helper function that returns a &lt;code&gt;FormatSpec&lt;/code&gt; for a single specifier given in &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Вспомогательная функция, которая возвращает &lt;code&gt;FormatSpec&lt;/code&gt; для одного спецификатора, указанного в &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10a93d4497e85393cb5499fb73d96c729ebc3ddb" translate="yes" xml:space="preserve">
          <source>Helper function that returns a complex number with the specified real and imaginary parts.</source>
          <target state="translated">Функция помощи,которая возвращает комплексное число с указанными реальной и мнимой частями.</target>
        </trans-unit>
        <trans-unit id="b43936919328317134bad177cd4f68d6f84246ac" translate="yes" xml:space="preserve">
          <source>Helper function to turn operator into template argument list</source>
          <target state="translated">Функция помощника для превращения оператора в список аргументов шаблона</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">Функции помощника</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="736e7e325114a8cd6d30377592f7bf25b8688457" translate="yes" xml:space="preserve">
          <source>Hence, the following errors can be statically detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e62a53ff4cde1bc51ffbf3814a1010c7743286" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the</source>
          <target state="translated">Вот &lt;code&gt;o&lt;/code&gt; поставляет</target>
        </trans-unit>
        <trans-unit id="1ede5efd1d10c5200eb2a32aa68abb7fc6f76c2f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the &lt;code&gt;this&lt;/code&gt; reference to the inner class instance of &lt;code&gt;Outer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf320d31b7dd0774140c8f2ed90c8c274ff772d" translate="yes" xml:space="preserve">
          <source>Here block names are unambiguous as no scripts are searched and thus to search use simply &lt;code&gt;unicode.block.BlockName&lt;/code&gt; notation.</source>
          <target state="translated">Здесь имена блоков однозначны, так как не выполняется поиск ни одного скрипта и, следовательно, для поиска используется просто &lt;code&gt;unicode.block.BlockName&lt;/code&gt; запись .</target>
        </trans-unit>
        <trans-unit id="6dcb204b7bfbc922a65c81d29d2d9fe0db1b0d9c" translate="yes" xml:space="preserve">
          <source>Here is an example function in both forms:</source>
          <target state="translated">Приведем пример функции в обеих формах:</target>
        </trans-unit>
        <trans-unit id="d0b4b9e647805e60f485e34136037cafd1a89034" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;add&lt;/code&gt; returns the base type, which doesn't implement the &lt;code&gt;remove&lt;/code&gt; method. The &lt;code&gt;template this&lt;/code&gt; parameter can be used for this purpose:</source>
          <target state="translated">Здесь метод &lt;code&gt;add&lt;/code&gt; возвращает базовый тип, который не реализует метод &lt;code&gt;remove&lt;/code&gt; . &lt;code&gt;template this&lt;/code&gt; параметр может быть использован для этой цели:</target>
        </trans-unit>
        <trans-unit id="c4a0b731de4fd47e1ec934359b73224f54545eef" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;initWith&lt;/code&gt; is overloaded with two versions, one accepting &lt;code&gt;in char*&lt;/code&gt;, the other one &lt;code&gt;NSString&lt;/code&gt;. These two methods are mapped to two different Objective-C selectors, &lt;code&gt;initWithUTF8String:&lt;/code&gt; and &lt;code&gt;initWithString:&lt;/code&gt;.</source>
          <target state="translated">Здесь метод &lt;code&gt;initWith&lt;/code&gt; перегружен двумя версиями, одна из которых принимает &lt;code&gt;in char*&lt;/code&gt; , другая &lt;code&gt;NSString&lt;/code&gt; . Эти два метода отображаются в двух различных селекторов Objective-C, &lt;code&gt;initWithUTF8String:&lt;/code&gt; и &lt;code&gt;initWithString:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7394eed5672426c0a80d302b8f8393ed7eec5e66" translate="yes" xml:space="preserve">
          <source>Here's an example of C code providing a callback to D code:</source>
          <target state="translated">Приведем пример кода на языке Си,обеспечивающего обратный вызов на код D:</target>
        </trans-unit>
        <trans-unit id="ca207d127693f0056dad58049c5cee1c802022ff" translate="yes" xml:space="preserve">
          <source>Here's an example of a</source>
          <target state="translated">Вот пример</target>
        </trans-unit>
        <trans-unit id="62b798df4ae2b665a95d9fcc9f504deddb178a54" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S&lt;/code&gt; has a temporary workspace &lt;code&gt;buf[]&lt;/code&gt;. The normal postblit will pointlessly free and reallocate it. The custom &lt;code&gt;opAssign&lt;/code&gt; will reuse the existing storage.</source>
          <target state="translated">Здесь &lt;code&gt;S&lt;/code&gt; имеет временную рабочую область &lt;code&gt;buf[]&lt;/code&gt; . Обычный постблит будет бессмысленно освобождать и перераспределять его. Обычай &lt;code&gt;opAssign&lt;/code&gt; будет повторно использовать существующее хранилище.</target>
        </trans-unit>
        <trans-unit id="8062e6745c830b66848176f824bd120bb6ff6bff" translate="yes" xml:space="preserve">
          <source>Here, an implementation may assume (without having knowledge of the body of &lt;code&gt;make&lt;/code&gt;) that all references in &lt;code&gt;make&lt;/code&gt;'s result refer to other &lt;code&gt;List&lt;/code&gt; objects created by &lt;code&gt;make&lt;/code&gt;, and that no other part of the program refers to any of these objects.</source>
          <target state="translated">Здесь реализация может предполагать (не имея знания тела &lt;code&gt;make&lt;/code&gt; ), что все ссылки в результате &lt;code&gt;make&lt;/code&gt; ссылаются на другие объекты &lt;code&gt;List&lt;/code&gt; , созданные &lt;code&gt;make&lt;/code&gt; . , и что никакая другая часть программы не ссылается ни на один из этих объектов.</target>
        </trans-unit>
        <trans-unit id="aa7249d3729c33470954c40f7854c88ac6ea3626" translate="yes" xml:space="preserve">
          <source>Hex Strings</source>
          <target state="translated">Шестигранные струны</target>
        </trans-unit>
        <trans-unit id="55d1c93cb26fa4369bf6dcef06802017d907bd51" translate="yes" xml:space="preserve">
          <source>Hex strings allow string literals to be created using hex data. The hex data need not form valid UTF characters.</source>
          <target state="translated">Шестнадцатеричные строки позволяют создавать строковые литералы с использованием шестнадцатиричных данных.Гекс-данные не должны формировать действительные UTF-символы.</target>
        </trans-unit>
        <trans-unit id="d39bdde77ca95b7a4b0450ffc2d016efdeac30d3" translate="yes" xml:space="preserve">
          <source>Hex_Digit</source>
          <target state="translated">Hex_Digit</target>
        </trans-unit>
        <trans-unit id="c45ee0a2d08a303c51fd2da33a102a3979857332" translate="yes" xml:space="preserve">
          <source>Hexadecimal floats are preceded by a &lt;b&gt;0x&lt;/b&gt; or &lt;b&gt;0X&lt;/b&gt; and the exponent is a &lt;b&gt;p&lt;/b&gt; or &lt;b&gt;P&lt;/b&gt; followed by a decimal number serving as the exponent of 2.</source>
          <target state="translated">Шестнадцатеричным числам с плавающей запятой предшествуют &lt;b&gt;0x&lt;/b&gt; или &lt;b&gt;0X,&lt;/b&gt; а показателем степени является &lt;b&gt;p&lt;/b&gt; или &lt;b&gt;P,&lt;/b&gt; за которым следует десятичное число, служащее показателем 2.</target>
        </trans-unit>
        <trans-unit id="f16858a5f250d36219d82e048f143333094b2747" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers are a sequence of hexadecimal digits preceded by a &amp;lsquo;0x&amp;rsquo; or &amp;lsquo;0X&amp;rsquo;.</source>
          <target state="translated">Шестнадцатеричные целые числа представляют собой последовательность шестнадцатеричных цифр, перед которыми стоит &amp;laquo;0x&amp;raquo; или &amp;laquo;0X&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="11ddb91ab70b44df8f22cc56bf0f33cd3a59aeec" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation</source>
          <target state="translated">шестнадцатеричная нотация</target>
        </trans-unit>
        <trans-unit id="66364879eee2501137250fec2b98de691bb34dff" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation with explicit suffixes</source>
          <target state="translated">Шестнадцатеричная нотация с явными суффиксами</target>
        </trans-unit>
        <trans-unit id="4606d5486909f59f9ecd950c1b17f287693253b2" translate="yes" xml:space="preserve">
          <source>Hexadecimal, lower case</source>
          <target state="translated">шестнадцатеричный,нижний регистр</target>
        </trans-unit>
        <trans-unit id="bf0117ce1416e40b23cca8ffd7b3aa016afb333f" translate="yes" xml:space="preserve">
          <source>Hexadecimal, upper case</source>
          <target state="translated">шестнадцатеричный,верхний регистр</target>
        </trans-unit>
        <trans-unit id="30b3eea9819f7439bb0562c0c53437f8d9a50617" translate="yes" xml:space="preserve">
          <source>Hidden parameters include the &lt;code&gt;this&lt;/code&gt; parameter of a class, struct or nested function and the selector parameter for Objective-C methods.</source>
          <target state="translated">Скрытые параметры включают параметр &lt;code&gt;this&lt;/code&gt; класса, структуры или вложенной функции и параметр селектора для методов Objective-C.</target>
        </trans-unit>
        <trans-unit id="53541869fd4c351759ad332d3244e2355b446808" translate="yes" xml:space="preserve">
          <source>High Private Use Surrogates</source>
          <target state="translated">Высокие частные заменители использования</target>
        </trans-unit>
        <trans-unit id="a2c5b830397db70f03f56d26786a97a92aad7755" translate="yes" xml:space="preserve">
          <source>High Surrogates</source>
          <target state="translated">Высокие Суррогаты</target>
        </trans-unit>
        <trans-unit id="f8ac1be04c27612db7a3ef64fd5edd48a9cbefb5" translate="yes" xml:space="preserve">
          <source>High level</source>
          <target state="translated">Высокий уровень</target>
        </trans-unit>
        <trans-unit id="0720fad238d3af6e0d988b6041fc7aff02b725de" translate="yes" xml:space="preserve">
          <source>High level bit level manipulation, bit arrays, bit fields.</source>
          <target state="translated">Высокоуровневая манипуляция с битовым уровнем,битовые массивы,битовые поля.</target>
        </trans-unit>
        <trans-unit id="a05a4fbe2b607cf88b24dc00ca5c949b2b6f1756" translate="yes" xml:space="preserve">
          <source>High level primitives for SMP parallelism.</source>
          <target state="translated">Высокоуровневые примитивы для параллелизма SMP.</target>
        </trans-unit>
        <trans-unit id="2ced0d4c7e1faee3d9f900306c2e846112d18012" translate="yes" xml:space="preserve">
          <source>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation.</source>
          <target state="translated">Интерфейс высокого уровня для распределителей. Реализует связанное распределение / создание и уничтожение / освобождение данных, включая &lt;code&gt;struct&lt;/code&gt; и &lt;code&gt;class&lt;/code&gt; , а также массив примитивов, связанных с распределением. Этот модуль является отправной точкой как для использования распределителей, так и для их документации.</target>
        </trans-unit>
        <trans-unit id="e4a71da2c94aa8ebb4eabe525bf9bfaf87c49456" translate="yes" xml:space="preserve">
          <source>Highest generated value (&lt;code&gt;modulus - 1&lt;/code&gt;).</source>
          <target state="translated">Наибольшее генерируемое значение ( &lt;code&gt;modulus - 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a7ebfdbeeab34f9a74c5ea30182aae05ebb58ca" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Максимально возможный &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464c7e7834d9d7bd5320fc6bf866ca1e41042986" translate="yes" xml:space="preserve">
          <source>Highlighting</source>
          <target state="translated">Highlighting</target>
        </trans-unit>
        <trans-unit id="b95101e7e46150f6462631854125e5fff96c059a" translate="yes" xml:space="preserve">
          <source>Highlighting of D code is performed by the following macros:</source>
          <target state="translated">Выделение кода D осуществляется с помощью следующих макросов:</target>
        </trans-unit>
        <trans-unit id="683f475e2ebb85d31bca86c12acb027ecf0e8eb2" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords</source>
          <target state="translated">Выделение ключевых слов D</target>
        </trans-unit>
        <trans-unit id="c4ca1644d89763135e446cfbeade41acbff8ee52" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords.</source>
          <target state="translated">Выделение ключевых слов D.</target>
        </trans-unit>
        <trans-unit id="935e04346b38d14f49040acb6c379fad11a7bf81" translate="yes" xml:space="preserve">
          <source>Highlighting of a function parameter section.</source>
          <target state="translated">Выделение раздела параметров функции.</target>
        </trans-unit>
        <trans-unit id="826389bac96eaeab4717271d63b43c94f3297c72" translate="yes" xml:space="preserve">
          <source>Highlighting of a name=value function parameter.</source>
          <target state="translated">Выделение параметра функции name=value.</target>
        </trans-unit>
        <trans-unit id="51eda7a8eeff739d414894834699b4db25dca6d2" translate="yes" xml:space="preserve">
          <source>Highlighting of a template constraint.</source>
          <target state="translated">Выделение ограничения шаблона.</target>
        </trans-unit>
        <trans-unit id="cc13dc42b045774509fcd534fa3f901ea5ee4636" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's individual parameters.</source>
          <target state="translated">Выделение индивидуальных параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="61100e35b4349aa073e0605d9e5a97e7d22147a5" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's parameter list.</source>
          <target state="translated">Выделение списка параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="c13fcc9292d599790bf9edbd77af674db96191fd" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a class.</source>
          <target state="translated">Выделение всех членов класса.</target>
        </trans-unit>
        <trans-unit id="e4ae17c8f2cb1ec34256f6f0903677d6b391295e" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a module.</source>
          <target state="translated">Выделение всех участников модуля.</target>
        </trans-unit>
        <trans-unit id="c09feb09e99ce22a8559d127647547ccdb5c7c15" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a struct.</source>
          <target state="translated">Выделение всех членов структуры.</target>
        </trans-unit>
        <trans-unit id="cbef76e4daad8898695a45761c2de54a52f8635b" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a template.</source>
          <target state="translated">Выделение всех членов шаблона.</target>
        </trans-unit>
        <trans-unit id="0faf83c3ae32ade36ccd67312a59a723e525d473" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of an enum.</source>
          <target state="translated">Выделение всех членов переписи.</target>
        </trans-unit>
        <trans-unit id="e8d93f96992576e6ba1194d00e53b1efd8bd3019" translate="yes" xml:space="preserve">
          <source>Highlighting of all the sections.</source>
          <target state="translated">Выделение всех разделов.</target>
        </trans-unit>
        <trans-unit id="4778b67265bf5d04ac6df97ab091affb27b022ea" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected keywords</source>
          <target state="translated">Выделение автоопределенных ключевых слов</target>
        </trans-unit>
        <trans-unit id="dd81b3fecd0f20ab2c7c2cd23019f77363841968" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected parameters</source>
          <target state="translated">Выделение автоопределяемых параметров</target>
        </trans-unit>
        <trans-unit id="2d5dbc630aa84bc9b06ad40e57222a60ed6a293a" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol</source>
          <target state="translated">Выделение автоопределяемого символа</target>
        </trans-unit>
        <trans-unit id="5a59602c4760ed030bee0db0f8f2fc1e157c8fe6" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol that starts with underscore</source>
          <target state="translated">Выделение символа с автоопределением,который начинается с символа подчеркивания</target>
        </trans-unit>
        <trans-unit id="03eeb845c1ab1c169a400e57021a9975be5fcd70" translate="yes" xml:space="preserve">
          <source>Highlighting of comments</source>
          <target state="translated">Выделение комментариев</target>
        </trans-unit>
        <trans-unit id="b342620229626113c8bd37f08c3e00019479575f" translate="yes" xml:space="preserve">
          <source>Highlighting of current declaration name</source>
          <target state="translated">Выделение текущего декларационного названия</target>
        </trans-unit>
        <trans-unit id="176f12498ba670eeda224994c2d82350441886fe" translate="yes" xml:space="preserve">
          <source>Highlighting of current function declaration parameters</source>
          <target state="translated">Выделение параметров объявления текущей функции</target>
        </trans-unit>
        <trans-unit id="6b99cfaf4826b1d374574b650af15bdd57440bdb" translate="yes" xml:space="preserve">
          <source>Highlighting of declaration name to which a particular section is referring.</source>
          <target state="translated">Выделение названия декларации,к которой относится тот или иной раздел.</target>
        </trans-unit>
        <trans-unit id="0ccd215d873103285e575951e68bee16377784a3" translate="yes" xml:space="preserve">
          <source>Highlighting of ditto declarations.</source>
          <target state="translated">Выделение деклараций из разряда дитто.</target>
        </trans-unit>
        <trans-unit id="e60176b3b0d8bba6525dbfb5d2184816b026c16d" translate="yes" xml:space="preserve">
          <source>Highlighting of function parameters.</source>
          <target state="translated">Выделение параметров функции.</target>
        </trans-unit>
        <trans-unit id="738f3d1a73adb20a6fc751e428562fd5770c4fbf" translate="yes" xml:space="preserve">
          <source>Highlighting of non-special sections is done.</source>
          <target state="translated">Выделение неспециализированных участков выполнено.</target>
        </trans-unit>
        <trans-unit id="4e9319188986e049a769be81e81ed23eb17972c2" translate="yes" xml:space="preserve">
          <source>Highlighting of string literals</source>
          <target state="translated">Выделение строковых литералов</target>
        </trans-unit>
        <trans-unit id="9dc393c818c0c8fcccd04642b35f2031235608ef" translate="yes" xml:space="preserve">
          <source>Highlighting of the authors section.</source>
          <target state="translated">Выделение авторского раздела.</target>
        </trans-unit>
        <trans-unit id="c04db9dc0d813c1ccd8c3f2345ab8b620b85f230" translate="yes" xml:space="preserve">
          <source>Highlighting of the base type of a class.</source>
          <target state="translated">Выделение базового типа класса.</target>
        </trans-unit>
        <trans-unit id="a07587fe4175acb9782fe36fd142c60cdfdd6da4" translate="yes" xml:space="preserve">
          <source>Highlighting of the bugs section.</source>
          <target state="translated">Выделение раздела &quot;Ошибки&quot;.</target>
        </trans-unit>
        <trans-unit id="7882769ed43990ada8c8b23f2c29f9e27cd0f71b" translate="yes" xml:space="preserve">
          <source>Highlighting of the contents of a non-standard section.</source>
          <target state="translated">Выделение содержания нестандартного раздела.</target>
        </trans-unit>
        <trans-unit id="4f9d3c220f1308abbd19a33e68d9159fe1a7bcac" translate="yes" xml:space="preserve">
          <source>Highlighting of the copyright section.</source>
          <target state="translated">Выделение раздела авторских прав.</target>
        </trans-unit>
        <trans-unit id="7d6e48fe7e09c72518d7c42b2053ac6afd252e38" translate="yes" xml:space="preserve">
          <source>Highlighting of the date section.</source>
          <target state="translated">Выделение раздела даты.</target>
        </trans-unit>
        <trans-unit id="895c3d9b137fe00aae27a823464b74cfac8c6e8b" translate="yes" xml:space="preserve">
          <source>Highlighting of the declaration.</source>
          <target state="translated">Выделение декларации.</target>
        </trans-unit>
        <trans-unit id="63dc31f05686ee2516c9b1d4403bc34707de916c" translate="yes" xml:space="preserve">
          <source>Highlighting of the deprecated section.</source>
          <target state="translated">Освещение устаревшего участка.</target>
        </trans-unit>
        <trans-unit id="c8decd9303e1480e7050896c2d68e41aba55a19d" translate="yes" xml:space="preserve">
          <source>Highlighting of the description of a declaration.</source>
          <target state="translated">Выделение описания декларации.</target>
        </trans-unit>
        <trans-unit id="c34c68b3feaf8a8af047b5dc0b27284ee8a4a976" translate="yes" xml:space="preserve">
          <source>Highlighting of the description section.</source>
          <target state="translated">Выделение раздела описания.</target>
        </trans-unit>
        <trans-unit id="66395af507be6d2f2c64374c4dcc34d87ba08e37" translate="yes" xml:space="preserve">
          <source>Highlighting of the examples section.</source>
          <target state="translated">Выделение раздела примеров.</target>
        </trans-unit>
        <trans-unit id="6c9891d5d62ba75e6f4bc3861099aa91d8757c3e" translate="yes" xml:space="preserve">
          <source>Highlighting of the history section.</source>
          <target state="translated">Выделение раздела истории.</target>
        </trans-unit>
        <trans-unit id="b7f85e62f0cd3405e5bd64486a1604e80fdbaccf" translate="yes" xml:space="preserve">
          <source>Highlighting of the license section.</source>
          <target state="translated">Выделение раздела лицензий.</target>
        </trans-unit>
        <trans-unit id="a1bf0eef04a7e415262c4a93c4981e89e888edcc" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter name.</source>
          <target state="translated">Выделение имени параметра.</target>
        </trans-unit>
        <trans-unit id="f88d01cfff7b61b2efa32b18d2de859fdd295ab7" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter value.</source>
          <target state="translated">Выделение значения параметра.</target>
        </trans-unit>
        <trans-unit id="e1964e06337cb784d3309fe34806373d2ea7eb8f" translate="yes" xml:space="preserve">
          <source>Highlighting of the returns section.</source>
          <target state="translated">Выделение секции возврата.</target>
        </trans-unit>
        <trans-unit id="833453d17a268f3c235ee74c7f3da2609550d437" translate="yes" xml:space="preserve">
          <source>Highlighting of the section name of a non-standard section.</source>
          <target state="translated">Выделение названия нестандартного раздела.</target>
        </trans-unit>
        <trans-unit id="c7903d232b908137bafe89e336276f896f569fc5" translate="yes" xml:space="preserve">
          <source>Highlighting of the see-also section.</source>
          <target state="translated">Выделение раздела см.также.</target>
        </trans-unit>
        <trans-unit id="df390d31d75e9b616a073ce0adb1eeb2634d7fd5" translate="yes" xml:space="preserve">
          <source>Highlighting of the standards section.</source>
          <target state="translated">Выделение раздела стандартов.</target>
        </trans-unit>
        <trans-unit id="f0d2af38c35f5e37acd97274204555972b2988bd" translate="yes" xml:space="preserve">
          <source>Highlighting of the summary section.</source>
          <target state="translated">Выделение раздела резюме.</target>
        </trans-unit>
        <trans-unit id="21e5f168213fe615e9ee4675e90cca4182bf4f11" translate="yes" xml:space="preserve">
          <source>Highlighting of the throws section.</source>
          <target state="translated">Выделение секции бросков.</target>
        </trans-unit>
        <trans-unit id="0dff0c156a9e500788193fc7d13465ffae833297" translate="yes" xml:space="preserve">
          <source>Highlighting of the type an enum is based upon</source>
          <target state="translated">Выделение типа перечисления на основе</target>
        </trans-unit>
        <trans-unit id="6b50d26c177d3621167352e70fcbe2f923cd28c3" translate="yes" xml:space="preserve">
          <source>Highlighting of the version section.</source>
          <target state="translated">Выделение раздела версий.</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="835fe32e11d06c07988640ea18d5a882081aeaae" translate="yes" xml:space="preserve">
          <source>History:</source>
          <target state="translated">History:</target>
        </trans-unit>
        <trans-unit id="b44fed8b2ad60db45d1dfeb77fbed8d582ca1505" translate="yes" xml:space="preserve">
          <source>Hoist-load + hoist-store barrier. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_acquire&lt;/code&gt;.</source>
          <target state="translated">Грузоподъемный + подъемно-складской барьер. Соответствует &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; и C ++ 11 / C11 &lt;code&gt;memory_order_acquire&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e61310c65ecb57873a154d2408b9cc4403ad4a2" translate="yes" xml:space="preserve">
          <source>Holds information about a socket address retrieved by &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">Содержит информацию об адресе сокета, полученную методом &lt;code&gt;getAddressInfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c10ba96a990de4f937f02e9f283e74796b47e3f8" translate="yes" xml:space="preserve">
          <source>Home of the TZ Database files</source>
          <target state="translated">Главная часть файлов Базы данных TZ</target>
        </trans-unit>
        <trans-unit id="b3e0a103daa9ae3f375b2654f0a482c7c0d36297" translate="yes" xml:space="preserve">
          <source>Hook</source>
          <target state="translated">Hook</target>
        </trans-unit>
        <trans-unit id="df83ba56b9bf84a7f6828386bfb0ec0b4ea31298" translate="yes" xml:space="preserve">
          <source>Hook &lt;strong id=&quot;hook&quot;&gt;hook&lt;/strong&gt;;</source>
          <target state="translated">Крюк &lt;strong id=&quot;hook&quot;&gt;крюк&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c491dcee1ba5406ded29938b72d3efa58c8898bc" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values, for example &lt;code&gt;0u &amp;lt; -1&lt;/code&gt;. The call &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; is smaller than &lt;code&gt;y&lt;/code&gt; in abstract arithmetic sense.</source>
          <target state="translated">Хук для &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; , обеспечивающий сравнение с целочисленными значениями, имеет поведение, ожидаемое по обычным арифметическим правилам. Встроенная семантика дает удивительное поведение при сравнении значений со &lt;code&gt;0u &amp;lt; -1&lt;/code&gt; значений без знака, например, 0u &amp;lt;-1 . Вызов &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; возвращает &lt;code&gt;-1&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;x&lt;/code&gt; меньше, чем &lt;code&gt;y&lt;/code&gt; , в абстрактном арифметическом смысле.</target>
        </trans-unit>
        <trans-unit id="9cf42c2609ccf8480c4c29b09d1eeb015d535402" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values for equality, for example &lt;code&gt;uint.max == -1&lt;/code&gt; or &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt;. The call &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent the same arithmetic number.</source>
          <target state="translated">Хук для &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Гарантирует, что сравнение с целочисленными значениями будет соответствовать обычным арифметическим правилам. Встроенная семантика дает удивительное поведение при сравнении значений со &lt;code&gt;uint.max == -1&lt;/code&gt; значений без знака на равенство, например, uint.max == -1 или &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt; . Вызов &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; представляют одно и то же арифметическое число.</target>
        </trans-unit>
        <trans-unit id="041c61fdd24218cf59730fd0cdbaa1de754b6893" translate="yes" xml:space="preserve">
          <source>Hook that implements</source>
          <target state="translated">Крюк для орудия</target>
        </trans-unit>
        <trans-unit id="b449d04fd061c7af394902d015ecf01abcf02e96" translate="yes" xml:space="preserve">
          <source>Hook that prints to &lt;code&gt;stderr&lt;/code&gt; a trace of all integral errors, without affecting default behavior.</source>
          <target state="translated">Крюк , который печатает на &lt;code&gt;stderr&lt;/code&gt; трассировки всех интегральных ошибок, не влияя на поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="efbf28167139074d8823a898190b189c85ea78aa" translate="yes" xml:space="preserve">
          <source>Hook that provides arithmetically correct comparisons for equality and ordering. Comparing an object of type &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; against another integral (for equality or ordering) ensures that no surprising conversions from signed to unsigned integral occur before the comparison. Using &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; on either side of a comparison for equality against a floating-point number makes sure the integral can be properly converted to the floating point type, thus making sure equality is transitive.</source>
          <target state="translated">Крюк, который обеспечивает арифметически правильные сравнения для равенства и упорядочения. Сравнение объекта типа &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; с другим интегралом (для равенства или упорядочения) гарантирует, что перед сравнением не произойдет никаких удивительных преобразований из знакомого в беззнаковый интеграл. Использование &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; по обе стороны от сравнения на равенство с числом с плавающей запятой гарантирует, что интеграл может быть должным образом преобразован в тип с плавающей запятой, таким образом гарантируя, что равенство транзитивно.</target>
        </trans-unit>
        <trans-unit id="d806e6661a85f88dc9eaa221319b2117db0f755d" translate="yes" xml:space="preserve">
          <source>Hook that reserves a special value as a &quot;Not a Number&quot; representative. For signed integrals, the reserved value is &lt;code&gt;T.min&lt;/code&gt;. For signed integrals, the reserved value is &lt;code&gt;T.max&lt;/code&gt;.</source>
          <target state="translated">Крюк, который оставляет за собой особое значение в качестве представителя &quot;Не число&quot;. Для знаковых интегралов зарезервированное значение - &lt;code&gt;T.min&lt;/code&gt; . Для знаковых интегралов зарезервированное значение &lt;code&gt;T.max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33488d4b3cbb5ba16b0673469e60db7094fb670e" translate="yes" xml:space="preserve">
          <source>Horizontal Rules</source>
          <target state="translated">Горизонтальные правила</target>
        </trans-unit>
        <trans-unit id="7212f381e90838fabdee36fb0501fbba0ed9cd58" translate="yes" xml:space="preserve">
          <source>Horizontal tab</source>
          <target state="translated">горизонтальная вкладка</target>
        </trans-unit>
        <trans-unit id="3ac6fafe4ab0f338471b45cb71f20d044e5f5cc2" translate="yes" xml:space="preserve">
          <source>Horizontal tab (U+0009).</source>
          <target state="translated">Горизонтальная вкладка (U+0009).</target>
        </trans-unit>
        <trans-unit id="bbb1b4f452c31b5eb2b5c0983d50e71cb342831f" translate="yes" xml:space="preserve">
          <source>Host compiler vendor string and language version.</source>
          <target state="translated">Строка и языковая версия хост-компилятора производителя.</target>
        </trans-unit>
        <trans-unit id="e118cd39d323f526da5b0f63e4f3c3b86e96af36" translate="yes" xml:space="preserve">
          <source>Hour of the day [0 - 24).</source>
          <target state="translated">Час дня [0-24].</target>
        </trans-unit>
        <trans-unit id="47f45a8e9beb5422f5775e424c56239ab38cf0a6" translate="yes" xml:space="preserve">
          <source>Hours past midnight.</source>
          <target state="translated">Часы после полуночи.</target>
        </trans-unit>
        <trans-unit id="aea1f84448c4cd135127feb893d3e5b86649ead7" translate="yes" xml:space="preserve">
          <source>How Garbage Collection Works</source>
          <target state="translated">Как работает сбор мусора</target>
        </trans-unit>
        <trans-unit id="5e1ecfe3dd4c1b701a8f4295c2bd308de6db519e" translate="yes" xml:space="preserve">
          <source>How a socket is shutdown:</source>
          <target state="translated">Как отключается розетка:</target>
        </trans-unit>
        <trans-unit id="14072cd783ee679dcd4faa9d6011722e64957f7d" translate="yes" xml:space="preserve">
          <source>How does this meet our assumptions about errors?</source>
          <target state="translated">Как это соответствует нашим предположениям об ошибках?</target>
        </trans-unit>
        <trans-unit id="2cef028c4c427db32ab248fb0fa09f711b8938d4" translate="yes" xml:space="preserve">
          <source>How does this meet our criteria?</source>
          <target state="translated">Как это отвечает нашим критериям?</target>
        </trans-unit>
        <trans-unit id="46c019e7726b602bf175d16d3e47d3c9855717af" translate="yes" xml:space="preserve">
          <source>How much &lt;code&gt;r&lt;/code&gt; was actually advanced, which may be less than &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; did not have at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">Сколько &lt;code&gt;r&lt;/code&gt; фактически было продвинуто, что может быть меньше &lt;code&gt;n&lt;/code&gt; , если у &lt;code&gt;r&lt;/code&gt; не было хотя бы &lt;code&gt;n&lt;/code&gt; элементов</target>
        </trans-unit>
        <trans-unit id="39a1caec9f5c9eff0c38eb6253af004f14eeaf48" translate="yes" xml:space="preserve">
          <source>How the deprecation messages are presented to the user.</source>
          <target state="translated">Как сообщения об удалении представляются пользователю.</target>
        </trans-unit>
        <trans-unit id="45ad0b30a0ba21c8300555e31b930fb7fa5c8e56" translate="yes" xml:space="preserve">
          <source>How to check an entire string</source>
          <target state="translated">Как проверить целую строку</target>
        </trans-unit>
        <trans-unit id="3944bdd486c5b281b0d76b6fea24f7aa42d88928" translate="yes" xml:space="preserve">
          <source>However for class types, identity assignment is not allowed. All class types have reference semantics, so identity assignment by default rebinds the left-hand-side to the argument at the right, and this is not overridable.</source>
          <target state="translated">Однако,для типов классов,присвоение идентичности не разрешается.Все типы классов имеют ссылочную семантику,поэтому присвоение идентичности по умолчанию возвращает левую сторону к аргументу справа,и это не переопределяется.</target>
        </trans-unit>
        <trans-unit id="d81485ead3a03b09d4ef041206a388f9ba3d1726" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; does allow reassignment, while otherwise behaving exactly like a &lt;code&gt;const Widget&lt;/code&gt;.</source>
          <target state="translated">Однако &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; разрешает переназначение, а в остальном ведет себя точно так же, как &lt;code&gt;const Widget&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39fcf81b03ae2153072256cf5c2ed783812c0162" translate="yes" xml:space="preserve">
          <source>However, if the AA element type is a struct which supports an implicit constructor call from the assigned value, implicit construction is used for setting the AA entry:</source>
          <target state="translated">Однако,если тип AA-элемента является структурой,которая поддерживает неявный вызов конструктора из присвоенного значения,то для установки элемента AA используется неявная конструкция:</target>
        </trans-unit>
        <trans-unit id="be6cc5f771eb95dadab03bad5c4c89972ffb70a4" translate="yes" xml:space="preserve">
          <source>However, in &lt;code&gt;-betterC&lt;/code&gt;&lt;code&gt;assert&lt;/code&gt; expressions don't use Druntime's assert and are directed to &lt;code&gt;assert&lt;/code&gt; of the C runtime library instead.</source>
          <target state="translated">Однако в выражениях &lt;code&gt;-betterC&lt;/code&gt; &lt;code&gt;assert&lt;/code&gt; не используется Druntime assert, и вместо этого они направлены на &lt;code&gt;assert&lt;/code&gt; библиотеки времени выполнения C.</target>
        </trans-unit>
        <trans-unit id="5a66b8122994e01e172373073ab6d4fa34b94942" translate="yes" xml:space="preserve">
          <source>However, it should be noted that the time zone information on Windows is frequently less accurate than that in the IANA time zone database, and if someone really wants accurate time zone information, they should use the IANA time zone database files with &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Windows rather than &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, whereas &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; makes more sense when trying to match what Windows will think the time is in a specific time zone.</source>
          <target state="translated">Однако следует отметить, что информация о часовом поясе в Windows часто менее точна, чем в базе данных часового пояса IANA, и если кто-то действительно хочет получить точную информацию о часовом поясе, ему следует использовать файлы базы данных часового пояса IANA с &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; в Windows, а не чем &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; , тогда как &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; имеет больше смысла при попытке сопоставить то, что Windows будет считать временем в определенном часовом поясе.</target>
        </trans-unit>
        <trans-unit id="6fe9389c4ddd121d6493079f489aee81befd5618" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Daylight Time). Regardless, it is not the same as name.</source>
          <target state="translated">Однако в Windows это может быть и несокращенное название (например,Pacific Daylight Time).Независимо от этого,это не то же самое,что и имя.</target>
        </trans-unit>
        <trans-unit id="47c13d8e213a10f9001fd45644c1b3afeb68823d" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Standard Time). Regardless, it is not the same as name.</source>
          <target state="translated">Однако в Windows это может быть и несокращенное название (например,Pacific Standard Time).Независимо от этого,это не то же самое,что и имя.</target>
        </trans-unit>
        <trans-unit id="eff8dd0f2d633371467a00fc8759aea595ab2872" translate="yes" xml:space="preserve">
          <source>However, when doing overload resolution, the functions in the base class are not considered:</source>
          <target state="translated">Однако при разрешении перегрузки функции базового класса не учитываются:</target>
        </trans-unit>
        <trans-unit id="599b7a863c6a59d1092f07e1710589a8785bdb8d" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">Человеческая читаемая строка,представляющая IPv4-адрес в точечно-цифровом виде.</target>
        </trans-unit>
        <trans-unit id="aff39bc2ec043587101457aaa3ae19023826875e" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 port.</source>
          <target state="translated">Человеческая читаемая строка,представляющая порт IPv4.</target>
        </trans-unit>
        <trans-unit id="a79746cad8ecf9d33b60d8dd5347136a9d85ef98" translate="yes" xml:space="preserve">
          <source>Human readable string representing this address.</source>
          <target state="translated">Человеческая читаемая строка,представляющая этот адрес.</target>
        </trans-unit>
        <trans-unit id="4c4d996a690c3ac43662d610a18221ccc97faec3" translate="yes" xml:space="preserve">
          <source>Hyphen</source>
          <target state="translated">Hyphen</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="47af55839c3e9c9ba933349c6295cd1ce082a6a3" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;im&lt;/code&gt;</source>
          <target state="translated">Я &lt;code&gt;im&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84ff080e0a1bf2c778d5efdc523acd4678a5928f" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;sizes&lt;/code&gt;</source>
          <target state="translated">Я &lt;code&gt;sizes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4ce4e386de11613809ef416e70170284dffb219" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;startingIndex&lt;/code&gt;</source>
          <target state="translated">Я &lt;code&gt;startingIndex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3df1df26aa4ea931d9e988f62da215ed0c3e81a7" translate="yes" xml:space="preserve">
          <source>I came, I coded, I crashed.</source>
          <target state="translated">Я пришел,я закодировался,я разбился.</target>
        </trans-unit>
        <trans-unit id="81cb37800b131d16bca390e388601790ff6f313b" translate="yes" xml:space="preserve">
          <source>I.e. is it a single return statement or some compound statement that unconditionally hits a return statement.</source>
          <target state="translated">Т.е.это единичное заявление о возврате или какое-либо составное заявление,которое безоговорочно попадает в заявление о возврате.</target>
        </trans-unit>
        <trans-unit id="d8212950b3ac05f1c5deaff0d3a32ce51c051e7f" translate="yes" xml:space="preserve">
          <source>I/O operation successful</source>
          <target state="translated">успешная операция ввода/вывода</target>
        </trans-unit>
        <trans-unit id="a07107356f25616c07b6fd35ca4ce30f409251c5" translate="yes" xml:space="preserve">
          <source>IBM Advanced Interactive eXecutive OS</source>
          <target state="translated">IBM Advanced Interactive eXecutive OS</target>
        </trans-unit>
        <trans-unit id="7e73f4b459341f6552e0a60723ed4f4fb582c963" translate="yes" xml:space="preserve">
          <source>IDS_Binary_Operator</source>
          <target state="translated">IDS_Binary_Operator</target>
        </trans-unit>
        <trans-unit id="dfddbbc74d0d43db63cde2a6e1024f6ba8221fff" translate="yes" xml:space="preserve">
          <source>IDS_Trinary_Operator</source>
          <target state="translated">IDS_Trinary_Operator</target>
        </trans-unit>
        <trans-unit id="0a50f9983af5839dd0d0dc6f249331d57b64db6f" translate="yes" xml:space="preserve">
          <source>ID_Continue</source>
          <target state="translated">ID_Continue</target>
        </trans-unit>
        <trans-unit id="92936d6f1e8f3e471e6f43d46a9887af5d007bd8" translate="yes" xml:space="preserve">
          <source>ID_Start</source>
          <target state="translated">ID_Start</target>
        </trans-unit>
        <trans-unit id="3f4e414c32b3902ba3f69c8b82e07f90e3313525" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic can set several flags based on what happened with a computation:</source>
          <target state="translated">Арифметика с плавающей точкой IEEE 754 может устанавливать несколько флагов,основываясь на том,что происходило при вычислениях:</target>
        </trans-unit>
        <trans-unit id="ca31149be1b5f9a497eaee503fda4915c7e1c829" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic includes the ability to set 4 different rounding modes. These are accessible via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">IEEE 754 арифметика с плавающей запятой включает в себя возможность установки 4 различных режимов округления. Они доступны через функции в &lt;code&gt;core.stdc.fenv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9fbff470ecc71dad6d33f5eeaccc83f4e863050" translate="yes" xml:space="preserve">
          <source>IEEE exception status flags ('sticky bits')</source>
          <target state="translated">флаги статуса исключения IEEE (&quot;липкие биты&quot;)</target>
        </trans-unit>
        <trans-unit id="a2584841fe85abc74e15db0f23c9cdba2dd8ab2a" translate="yes" xml:space="preserve">
          <source>IEEE hardware exceptions. By default, all exceptions are masked (disabled).</source>
          <target state="translated">Исключения для аппаратного обеспечения IEEE.По умолчанию все исключения маскируются (отключаются).</target>
        </trans-unit>
        <trans-unit id="b9e2d958b9ca41f87ae15ec8c35999c50ae4ff8c" translate="yes" xml:space="preserve">
          <source>IEEE rounding modes. The default mode is roundToNearest.</source>
          <target state="translated">Режимы округления IEEE.Режим по умолчанию RoundToNearest.</target>
        </trans-unit>
        <trans-unit id="7d81343ef8eab15b8d8f8c68c7c8bdb404ed88bb" translate="yes" xml:space="preserve">
          <source>ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt;;</source>
          <target state="translated">ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="362fa36f30a060b9e1fcf247cb78ff4ce49924f2" translate="yes" xml:space="preserve">
          <source>IMP</source>
          <target state="translated">IMP</target>
        </trans-unit>
        <trans-unit id="bdc4004339f8557d5a75257afe0bb8aef0ebaaba" translate="yes" xml:space="preserve">
          <source>IP multicast hops</source>
          <target state="translated">IP многоадресные хмели</target>
        </trans-unit>
        <trans-unit id="20fe7e463770b20399ece7b586c1bbb5d3def572" translate="yes" xml:space="preserve">
          <source>IP multicast interface</source>
          <target state="translated">IP-мультикаст-интерфейс</target>
        </trans-unit>
        <trans-unit id="7279e4b3160656f1f51a778df4e83b92cb83cf30" translate="yes" xml:space="preserve">
          <source>IP multicast loopback</source>
          <target state="translated">многоадресная передача IP-адресов</target>
        </trans-unit>
        <trans-unit id="9ebd1fbe7ba3cf5bdc775290d0d686e15bf4c0b2" translate="yes" xml:space="preserve">
          <source>IP unicast hop limit</source>
          <target state="translated">IP-нелинейный хмель</target>
        </trans-unit>
        <trans-unit id="cc01b492cee0acdf48f0b298c26fa47256bd3faf" translate="yes" xml:space="preserve">
          <source>IPA Extensions</source>
          <target state="translated">Расширения IPA</target>
        </trans-unit>
        <trans-unit id="80570baac1433d8da38eb560349f85ffa3c24938" translate="yes" xml:space="preserve">
          <source>IPv6 address ends with a single colon</source>
          <target state="translated">IPv6-адрес заканчивается одной двоеточием</target>
        </trans-unit>
        <trans-unit id="f971f61e6734e2eb397d8944032e3b5547c71b4c" translate="yes" xml:space="preserve">
          <source>IPv6 address starts with a single colon</source>
          <target state="translated">IPv6-адрес начинается с одной двоеточия</target>
        </trans-unit>
        <trans-unit id="ffeae36229b4084ab3f5431d5a5e2894acff57f8" translate="yes" xml:space="preserve">
          <source>IPv6-enabled</source>
          <target state="translated">IPv6-enabled</target>
        </trans-unit>
        <trans-unit id="ae9887477b5a4dc86ce15b0c56db938ec92c9140" translate="yes" xml:space="preserve">
          <source>IRState* &lt;code&gt;irs&lt;/code&gt;</source>
          <target state="translated">IRState * &lt;code&gt;irs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="0f3e173e17d8fbdbf144076143d8cd16c3b60805" translate="yes" xml:space="preserve">
          <source>ISO Week Date</source>
          <target state="translated">Недельная дата ИСО</target>
        </trans-unit>
        <trans-unit id="6edb4ac9bcba71ad7ccb4ee02897a84fda819a4e" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)</source>
          <target state="translated">ИЗО/ВЕК 9899:1999 (Е)</target>
        </trans-unit>
        <trans-unit id="8e40d146e834aa0554ad9d258a39d303ac74b95c" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)  These are the various functions called by the assert() macro. They are all noreturn functions, although D doesn't have a specific attribute for that.</source>
          <target state="translated">ISO/IEC 9899:1999 (E)Это различные функции,вызываемые макросом assert().Все они являются функциями норетурна,хотя D не имеет для этого конкретного атрибута.</target>
        </trans-unit>
        <trans-unit id="79c91cb6efbe5dfcc03f77ea0bf59ceecfb03a1b" translate="yes" xml:space="preserve">
          <source>Iain Buclaw</source>
          <target state="translated">Иен Буклау</target>
        </trans-unit>
        <trans-unit id="a61268b8e652624d626d166308f20560b1d3aa63" translate="yes" xml:space="preserve">
          <source>Id::max or Id::min</source>
          <target state="translated">Ид::макс или Ид:мин</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="d884429135c14548b3e978b368447365cb96cfc8" translate="yes" xml:space="preserve">
          <source>Identifier (inside Identifier.idPool) with deterministic name based on the source location.</source>
          <target state="translated">Идентификатор (внутри Identifier.idPool)с детерминированным именем,основанным на местоположении источника.</target>
        </trans-unit>
        <trans-unit id="d39412a656d9c3c7bf8a3a174965f8e76b9c6aae" translate="yes" xml:space="preserve">
          <source>Identifier : NonVoidInitializer</source>
          <target state="translated">Идентифицируйте:Не-Воидиалиализатор</target>
        </trans-unit>
        <trans-unit id="2ea823871928966eb34d2d6331730d76f54cfc52" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;id&lt;/code&gt;</source>
          <target state="translated">Идентификатор &lt;code&gt;id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd812024edf80fc26687c86baab342484d1cca2a" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;ident&lt;/code&gt;</source>
          <target state="translated">Идентификатор &lt;code&gt;ident&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f032313123f1ffabc6636b37a2cdfb763957f48d" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;module_&lt;/code&gt;</source>
          <target state="translated">Идентификатор &lt;code&gt;module_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff20fb48822c4ece471eaa71420a8e3f17752e0" translate="yes" xml:space="preserve">
          <source>Identifier &lt;strong id=&quot;identifier&quot;&gt;identifier&lt;/strong&gt;;</source>
          <target state="translated">Идентификатор &lt;strong id=&quot;identifier&quot;&gt;идентификатор&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="964e8904f66adfee7e7841e9b8d4ec24e389fed4" translate="yes" xml:space="preserve">
          <source>Identifier Emphasis</source>
          <target state="translated">Акцент на идентификаторе</target>
        </trans-unit>
        <trans-unit id="57fd2f9988cc1bead6d88fdd99fa28550daa5071" translate="yes" xml:space="preserve">
          <source>Identifier required for this condition to pass. If &lt;code&gt;null&lt;/code&gt;, this conditiion will use an integer level.</source>
          <target state="translated">Идентификатор, необходимый для выполнения этого условия. Если &lt;code&gt;null&lt;/code&gt; , это conditiion будет использовать уровень целого.</target>
        </trans-unit>
        <trans-unit id="72a03d37bdb5a52d9cfa01295909001833684faa" translate="yes" xml:space="preserve">
          <source>Identifier value (e.g. &lt;code&gt;Id.unitTest&lt;/code&gt;) or &lt;code&gt;TOK.identifier&lt;/code&gt;</source>
          <target state="translated">Значение идентификатора (например, &lt;code&gt;Id.unitTest&lt;/code&gt; ) или &lt;code&gt;TOK.identifier&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22dcd4202be0468eb915e08817484731c04ef629" translate="yes" xml:space="preserve">
          <source>IdentifierList</source>
          <target state="translated">IdentifierList</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="29849b8a9887214097873771c1ada1e4a2b26c67" translate="yes" xml:space="preserve">
          <source>Identifiers in documentation comments that are function parameters or are names that are in scope at the associated declaration are emphasized in the output. This emphasis can take the form of italics, boldface, a hyperlink, etc. How it is emphasized depends on what it is</source>
          <target state="translated">Идентификаторы в комментариях к документации,которые являются параметрами функции или именами,входящими в область применения соответствующего объявления,выделяются в выходных данных.Этот акцент может иметь форму курсива,жирного шрифта,гиперссылки и т.д.То,как он выделен,зависит от того,что это такое</target>
        </trans-unit>
        <trans-unit id="ee26ed57025d5c31d0bf47a619bdb084494918ff" translate="yes" xml:space="preserve">
          <source>Identifiers start with a letter, &lt;code&gt;_&lt;/code&gt;, or universal alpha, and are followed by any number of letters, &lt;code&gt;_&lt;/code&gt;, digits, or universal alphas. Universal alphas are as defined in ISO/IEC 9899:1999(E) Appendix D of the C99 Standard. Identifiers can be arbitrarily long, and are case sensitive.</source>
          <target state="translated">Идентификаторы начинаются с буквы, &lt;code&gt;_&lt;/code&gt; или универсальной альфы, и сопровождаются любым количеством букв, &lt;code&gt;_&lt;/code&gt; , цифр или универсальных альфа. Универсальные альфа определены в ИСО / МЭК 9899: 1999 (E), Приложение D к Стандарту C99. Идентификаторы могут быть произвольно длинными и чувствительными к регистру.</target>
        </trans-unit>
        <trans-unit id="745651339d520944f46b951509355e65410d85d8" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;ids&lt;/code&gt;</source>
          <target state="translated">Идентификаторы * &lt;code&gt;ids&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bce0759953389b7f6673a7b1dcdcbe2f5adafd6" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;pkg_identifiers&lt;/code&gt;</source>
          <target state="translated">Идентификаторы * &lt;code&gt;pkg_identifiers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd196121fbac89b149b3c74f08384f1bdda01148" translate="yes" xml:space="preserve">
          <source>Identify Statement types with this enum rather than virtual functions.</source>
          <target state="translated">Определите типы операторов с помощью этого перечисления,а не виртуальных функций.</target>
        </trans-unit>
        <trans-unit id="897cc900af9b1d4567cf3ac949c0ce028e5b29c4" translate="yes" xml:space="preserve">
          <source>Identify the characteristics of the host CPU, providing information about cache sizes and assembly optimisation hints. This module is provided primarily for assembly language programmers.</source>
          <target state="translated">Определение характеристик центрального процессора хоста,предоставление информации о размерах кэша и подсказок по оптимизации сборки.Данный модуль предназначен в первую очередь для программистов,работающих с ассемблерными языками.</target>
        </trans-unit>
        <trans-unit id="294c861b2aa613142591a5192af15c07f9d87cde" translate="yes" xml:space="preserve">
          <source>Identify the compiler used and its various features.</source>
          <target state="translated">Определить используемый компилятор и его различные особенности.</target>
        </trans-unit>
        <trans-unit id="2adbbf9ddb856b5eee69eb90a8ddc235f490d75b" translate="yes" xml:space="preserve">
          <source>Identify whether a variable is defined in the environment.</source>
          <target state="translated">Определите,определена ли переменная в окружении.</target>
        </trans-unit>
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">Перегрузка при присвоении идентификационных данных</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">Выражения идентичности</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">Идеографическое описание Символы</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">Идиоматическое использование &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">Если !равен нулю,элементы[]могут быть разрежены,и для значения элемента &quot;по умолчанию&quot; используется основа.Другими словами,ненулевые элементы[i]переопределяют это &quot;базовое&quot; значение.</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">Если 'e'-дерево запятых,возвращает крайнее правое выражение,удаляя его из дерева.Оставшаяся часть дерева возвращается через e0.В противном случае 'e' возвращается напрямую и e0 устанавливается в NULL.</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Если &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt; ! R - это тип с плавающей запятой, а &lt;code&gt;R&lt;/code&gt; - &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;диапазон произвольного доступа&lt;/a&gt; с длиной и срезом, то для &lt;code&gt;sum&lt;/code&gt; используется алгоритм &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;попарного суммирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5461d4fe41b7c975dcc4f74fcf29adecaffabc9a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">Если &lt;code&gt;!!value&lt;/code&gt; истинно, &lt;code&gt;value&lt;/code&gt; возвращается. В противном случае &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; . &lt;code&gt;WindowsException&lt;/code&gt; предполагает, что последняя операция установила &lt;code&gt;GetLastError()&lt;/code&gt; соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">Если &lt;code&gt;!isInfinite!Source&lt;/code&gt; и &lt;code&gt;source.walkLength&lt;/code&gt; не делятся поровну на &lt;code&gt;chunkSize&lt;/code&gt; , то задний элемент этого диапазона будет содержать меньше элементов &lt;code&gt;chunkSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">Если &lt;code&gt;!value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; возвращается. В противном случае генерируется &lt;code&gt;new E(msg, file, line)&lt;/code&gt; . Или, если &lt;code&gt;E&lt;/code&gt; не принимает сообщение и может быть сконструировано с &lt;code&gt;new E(file, line)&lt;/code&gt; , тогда будет выброшено &lt;code&gt;new E(file, line)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ae58cb23b72d887da98d9fdd1704ba37b0874fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@live&lt;/code&gt; functions call non-&lt;code&gt;@live&lt;/code&gt; functions, those called functions are expected to present an &lt;code&gt;@live&lt;/code&gt; compatible interface, although it is not checked. if non-&lt;code&gt;@live&lt;/code&gt; functions call &lt;code&gt;@live&lt;/code&gt; functions, arguments passed are expected to follow &lt;code&gt;@live&lt;/code&gt; conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; не имеет состояния, результирующий объект размещается в статическом общем хранилище.</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; имеет состояние и является копируемым, результатом будет &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; предоставленного распределителя &lt;code&gt;A a&lt;/code&gt; внутри. Сам результат размещается в собственном статически распределенном распределителе.</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; имеет состояние и не подлежит копированию, результат переместит переданный аргумент в результат. Сам результат размещается в собственном статически распределенном распределителе.</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; имеет состояние, результатом будет &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; предоставленного распределителя &lt;code&gt;A a&lt;/code&gt; внутри. Сам результат размещается в собственном статически распределенном распределителе.</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Allocator&lt;/code&gt; реализует &lt;code&gt;owns&lt;/code&gt; , пересылает к нему. В противном случае возвращает &lt;code&gt;Ternary.unknown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">Если &lt;code&gt;BookkeepingAllocator&lt;/code&gt; не &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;bkalloc&lt;/code&gt; определяется и доступным.</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Если &lt;code&gt;ElementType!R&lt;/code&gt; является типом с плавающей запятой, а &lt;code&gt;R&lt;/code&gt; - конечным входным диапазоном (но не диапазоном произвольного доступа со срезами), то для &lt;code&gt;sum&lt;/code&gt; используется алгоритм &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;суммирования Кахана&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc27324f1313ac32b98b4d9a0fcd3f12a5ee0a27" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Если &lt;code&gt;FreeList&lt;/code&gt; был &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; с maxSize == chooseAtRuntime , то свойство &lt;code&gt;max&lt;/code&gt; доступно для записи. Установка должна предшествовать любому распределению.</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Если &lt;code&gt;FreeList&lt;/code&gt; был создан с помощью &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; , тогда свойство &lt;code&gt;min&lt;/code&gt; доступно для записи. Установка должна предшествовать любому распределению.</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">Если &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;hookOpOpAssign&lt;/code&gt; , &lt;code&gt;opOpAssign&lt;/code&gt; пересылается на &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; , где &lt;code&gt;payload&lt;/code&gt; является ссылкой на данные , хранящиеся внутри, так что ловушка может их изменить.</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">Если &lt;code&gt;Hook&lt;/code&gt; не определяет &lt;code&gt;hookOpBinary&lt;/code&gt; , но определяет &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opBinary&lt;/code&gt; переадресует к &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; в случае переполнения.</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Hook&lt;/code&gt; не определяет &lt;code&gt;hookOpUnary&lt;/code&gt; , но определяет &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opUnary&lt;/code&gt; пересылает &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; в случае переполнения. Для &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; полезная нагрузка назначается из результата вызова &lt;code&gt;onOverflow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; содержит состояние, &lt;code&gt;parent&lt;/code&gt; является открытым членом типа &lt;code&gt;KRRegion&lt;/code&gt; . В противном случае &lt;code&gt;parent&lt;/code&gt; является &lt;code&gt;alias&lt;/code&gt; для &lt;code&gt;ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; равен &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , определяется только конструктор, принимающий &lt;code&gt;data&lt;/code&gt; и пользователь отвечает за освобождение &lt;code&gt;data&lt;/code&gt; если это необходимо.</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; отличается от &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Region&lt;/code&gt; освобождает часть памяти во время уничтожения.</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; с состоянием, &lt;code&gt;parent&lt;/code&gt; - это свойство, предоставляющее доступ к &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; . В противном случае &lt;code&gt;parent&lt;/code&gt; является псевдонимом &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">Если &lt;code&gt;Prefix&lt;/code&gt; является &lt;code&gt;void&lt;/code&gt; , выравниванием является то , что родитель. В противном случае выравнивание совпадает с выравниванием &lt;code&gt;Prefix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Prefix&lt;/code&gt; не является &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;Allocator&lt;/code&gt; должен гарантировать выравнивание, по крайней мере, &lt;code&gt;Prefix.alignof&lt;/code&gt; как Prefix.alignof .</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">Если &lt;code&gt;S&lt;/code&gt; определяет деструктор, сгенерированный код для &lt;code&gt;opAssign&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">Если &lt;code&gt;S&lt;/code&gt; не имеет постблита или деструктора, но содержит хотя бы одно поле, которое определяет функцию &lt;code&gt;opAssign&lt;/code&gt; (которая не отключена), то тело выполнит назначения для членов:</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;S&lt;/code&gt; имеет отключенный деструктор или хотя бы одно поле с отключенным &lt;code&gt;opAssign&lt;/code&gt; , &lt;code&gt;S.opAssign&lt;/code&gt; будет сгенерирован, но помечен &lt;code&gt;@disable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">Если &lt;code&gt;Source&lt;/code&gt; имеет структурное соответствие с &lt;code&gt;interface&lt;/code&gt; &lt;code&gt;Targets&lt;/code&gt; , wrap создает внутренний класс-обертку, который наследует &lt;code&gt;Targets&lt;/code&gt; и оборачивает объект &lt;code&gt;src&lt;/code&gt; , а затем возвращает его.</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Source&lt;/code&gt; является прямой диапазон, результирующий диапазон также будет прямым диапазоном. В противном случае полученные чанки будут входными диапазонами, потребляющими один и тот же ввод: итерация &lt;code&gt;front&lt;/code&gt; сократит чанк так, что последующие вызовы &lt;code&gt;front&lt;/code&gt; больше не будут возвращать полный чанк, а вызов &lt;code&gt;popFront&lt;/code&gt; во внешнем диапазоне лишит законной силы любые ссылки на предыдущие значения из &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">Если используется &lt;code&gt;StopWatch.init&lt;/code&gt; , то созданный StopWatch не работает (и не может быть, так как не работал ни один конструктор).</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">Если &lt;code&gt;Store&lt;/code&gt; является диапазоном, &lt;code&gt;BinaryHeap&lt;/code&gt; не может расти за пределами этого диапазона. Если &lt;code&gt;Store&lt;/code&gt; является контейнером, который поддерживает &lt;code&gt;insertBack&lt;/code&gt; , &lt;code&gt;BinaryHeap&lt;/code&gt; может расти, добавляя элементы в контейнер.</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса, возвращает ссылку на созданный объект &lt;code&gt;T&lt;/code&gt; .В противном случае возвращает символ &lt;code&gt;T*&lt;/code&gt; указывающий на созданный объект. Во всех случаях возвращает &lt;code&gt;null&lt;/code&gt; если выделение не удалось.</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является вложенной структурой, указатель контекста в &lt;code&gt;T.init&lt;/code&gt; является &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является структурой, которая имеет &lt;code&gt;@disable this();&lt;/code&gt; , &lt;code&gt;T.init&lt;/code&gt; может возвращать логически неправильный объект.</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является структурой с определенным деструктором или постблитом, источник возвращается к своему значению &lt;code&gt;.init&lt;/code&gt; после перемещения в цель, в противном случае он остается неизменным.</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом значения, то &lt;code&gt;Unique!T&lt;/code&gt; будет реализован в виде ссылки на &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является внутренним классом, &lt;code&gt;outer&lt;/code&gt; поле которого можно использовать для доступа к экземпляру включающего класса, то &lt;code&gt;Args&lt;/code&gt; не должен быть пустым, и первый его член должен быть допустимым инициализатором для этого &lt;code&gt;outer&lt;/code&gt; поля. Правильная инициализация этого поля необходима для доступа к членам внешнего класса внутри методов &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">Если конструктор &lt;code&gt;T&lt;/code&gt; выбрасывает, освобождает выделенную память и распространяет исключение.</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Если &lt;code&gt;U&lt;/code&gt; также является экземпляром &lt;code&gt;Checked&lt;/code&gt; , для метода &lt;code&gt;hookOpCmp&lt;/code&gt; интроспективно рассматриваются оба хука (левый и правый) . Если оба определяют его, приоритет отдается левой стороне.</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Если &lt;code&gt;U&lt;/code&gt; также является экземпляром &lt;code&gt;Checked&lt;/code&gt; , оба хука (левая и правая сторона) являются &lt;code&gt;hookOpEquals&lt;/code&gt; для метода hookOpEquals . Если оба определяют его, приоритет отдается левой стороне.</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">Если &lt;code&gt;Yes.checkDns&lt;/code&gt; , тогда будет сделана проверка DNS для записей MX</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; , просто итерация диапазона никогда не вызывая &lt;code&gt;front&lt;/code&gt; достаточно иметь &lt;code&gt;tee&lt;/code&gt; зеркальных элементов &lt;code&gt;outputRange&lt;/code&gt; (или, соответственно, &lt;code&gt;fun&lt;/code&gt; ). Если &lt;code&gt;No.pipeOnPop&lt;/code&gt; , то только те элементы, для которых вызывается &lt;code&gt;front&lt;/code&gt; , также будут отправлены в &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a50176d4624d41b95b9071257e16a7702021f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). Note that each &lt;code&gt;popFront()&lt;/code&gt; call will mirror the old &lt;code&gt;front&lt;/code&gt; value, not the new one. This means that the last value will not be forwarded if the range isn't iterated until empty. If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;. If &lt;code&gt;front&lt;/code&gt; is called twice for the same element, it will still be sent only once. If this caching is undesired, consider using &lt;a href=&quot;std_algorithm_iteration#map&quot;&gt;&lt;code&gt;std.algorithm.iteration.map&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; , то &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; и листья без изменений, тогда как &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; продвигает к &lt;code&gt;&quot;de&quot;&lt;/code&gt; , и возвращает &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; и &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; , &lt;code&gt;bringToFront(a, b)&lt;/code&gt; оставляет &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; и &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; , &lt;code&gt;reverse(a)&lt;/code&gt; меняет его на &lt;code&gt;[3, 2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; , то &lt;code&gt;initializeAll(a)&lt;/code&gt; оставляет &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">Если &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; , и &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; , а затем &lt;code&gt;completeSort(a, b)&lt;/code&gt; оставляет &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; , и &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; . Диапазон &lt;code&gt;a&lt;/code&gt; должен быть отсортирован до вызова, и в результате &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; комбинация std.range.chain (a, b) .</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">Если &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; , то &lt;code&gt;partialSort(a, 3)&lt;/code&gt; оставляет &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; . Другие элементы &lt;code&gt;a&lt;/code&gt; оставлены в неуказанном порядке.</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">Если для &lt;code&gt;allowDuplicates&lt;/code&gt; задано значение &lt;code&gt;true&lt;/code&gt; , то вставка одного и того же элемента более одного раза продолжает добавлять больше элементов. Если это &lt;code&gt;false&lt;/code&gt; , дубликаты элементов игнорируются при вставке. Если дубликаты разрешены, новые элементы вставляются после всех существующих дубликатов.</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Если &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; , ничего не делает и возвращает &lt;code&gt;false&lt;/code&gt; . В противном случае уничтожает последние &lt;code&gt;arr.length - delta&lt;/code&gt; элементы arr.length в массиве, а затем перераспределяет буфер массива. В случае сбоя перераспределения заполняет массив инициализированными по умолчанию данными.</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Если &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; , ничего не делает и возвращает &lt;code&gt;false&lt;/code&gt; . В противном случае уничтожает последние &lt;code&gt;array.length - delta&lt;/code&gt; в массиве, а затем перераспределяет буфер массива. В случае сбоя перераспределения заполняет массив инициализированными по умолчанию данными.</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">Если &lt;code&gt;b is null&lt;/code&gt; , ничего не делает и возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае освобождает память, ранее выделенную этим распределителем, и возвращает &lt;code&gt;true&lt;/code&gt; в случае успеха, иначе &lt;code&gt;false&lt;/code&gt; . Реализация, которая не будет поддерживать освобождение (то есть всегда будет возвращать &lt;code&gt;false&lt;/code&gt; , вообще не должна определять этот примитив.)</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">Если &lt;code&gt;ba&lt;/code&gt; равно нулю (по умолчанию), атрибуты существующей памяти будут использоваться для выделения. Если &lt;code&gt;ba&lt;/code&gt; не равно нулю и новая память не выделена, биты в ba заменят биты текущего блока памяти.</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">Если &lt;code&gt;block.length&lt;/code&gt; находится в пределах &lt;code&gt;[min, max]&lt;/code&gt; или если свободный список не проверен ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ), тогда вставляется блок в начало свободного списка. Для всех остальных пересылается в &lt;code&gt; parent.deallocate&lt;/code&gt; , если определен &lt;code&gt;Parent.deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Если &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;BitmappedBlock&lt;/code&gt; предлагает свойство чтения / записи &lt;code&gt;blockSize&lt;/code&gt; . Он должен быть установлен перед любым использованием распределителя. В противном случае (то есть &lt;code&gt;theBlockSize&lt;/code&gt; является допустимой константой), &lt;code&gt;blockSize&lt;/code&gt; является псевдонимом для &lt;code&gt;theBlockSize&lt;/code&gt; . Независимо от того, является ли она постоянной или переменной, она также должна быть кратна &lt;code&gt;alignment&lt;/code&gt; . Это ограничение &lt;code&gt;assert&lt;/code&gt; статически и динамически.</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Если &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; предлагает свойство чтения / записи &lt;code&gt;blockSize&lt;/code&gt; . Он должен быть установлен перед любым использованием распределителя. В противном случае (то есть &lt;code&gt;theBlockSize&lt;/code&gt; является допустимой константой), &lt;code&gt;blockSize&lt;/code&gt; является псевдонимом для &lt;code&gt;theBlockSize&lt;/code&gt; . Независимо от того, является ли она постоянной или переменной, она также должна быть кратна &lt;code&gt;alignment&lt;/code&gt; . Это ограничение &lt;code&gt;assert&lt;/code&gt; статически и динамически.</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; является &lt;a href=&quot;#Character&quot;&gt;символом&lt;/a&gt; нижнего регистра Unicode , тогда возвращается его заглавный эквивалент. В противном случае возвращается &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; является заглавным &lt;a href=&quot;#Character&quot;&gt;символом&lt;/a&gt; Unicode , то возвращается его строчный эквивалент. В противном случае возвращается &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">Если &lt;code&gt;dir == Direction.fwd&lt;/code&gt; , то диапазон повторяется вперед во времени, тогда как если &lt;code&gt;dir == Direction.bwd&lt;/code&gt; , то он повторяется назад во времени. Итак, если &lt;code&gt;dir == Direction.fwd&lt;/code&gt; то &lt;code&gt;front == interval.begin&lt;/code&gt; , тогда как если &lt;code&gt;dir == Direction.bwd&lt;/code&gt; то &lt;code&gt;front == interval.end&lt;/code&gt; . &lt;code&gt;func&lt;/code&gt; должен сгенерировать момент времени, идущий в правильном направлении итерации, &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; будет сгенерировано исключение std.datetime.date.DateTimeException . Таким образом, чтобы выполнить итерацию во времени, момент времени, который генерирует &lt;code&gt;func&lt;/code&gt; , должен быть позже, чем тот, который был передан ему. Если оно идентично или ранее, то &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;будет брошен. Чтобы выполнить итерацию в обратном направлении, сгенерированный момент времени должен предшествовать моменту времени, который был передан.</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">Если &lt;code&gt;filler&lt;/code&gt; пуст.</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;fun&lt;/code&gt; это &lt;code&gt;string&lt;/code&gt; , новая функция с одним параметром. Если &lt;code&gt;fun&lt;/code&gt; не &lt;code&gt;string&lt;/code&gt; , это псевдоним &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;fun&lt;/code&gt; не является строкой, &lt;code&gt;binaryFun&lt;/code&gt; объединяет себя с &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">Если &lt;code&gt;hasLength!Range&lt;/code&gt; , просто возвращает &lt;code&gt;range.length&lt;/code&gt; без проверки &lt;code&gt;upTo&lt;/code&gt; (если указано).</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;haystack&lt;/code&gt; является диапазоном произвольного доступа, все три компонента кортежа имеют тот же тип, что и &lt;code&gt;haystack&lt;/code&gt; . В противном случае &lt;code&gt;haystack&lt;/code&gt; должен иметь &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямой диапазон,&lt;/a&gt; а тип &lt;code&gt;result[0]&lt;/code&gt; и &lt;code&gt;result[1]&lt;/code&gt; совпадает с &lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;impl.alignedAllocate&lt;/code&gt; существует, вызывает его и возвращает результат. В противном случае всегда возвращает &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">Если &lt;code&gt;impl.deallocate&lt;/code&gt; не определен, возвращает &lt;code&gt;false&lt;/code&gt; . В противном случае он перенаправляет вызов.</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">Если &lt;code&gt;input&lt;/code&gt; - &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямой диапазон&lt;/a&gt; , &lt;code&gt;needle&lt;/code&gt; может быть &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;передним диапазоном&lt;/a&gt; . В этом случае &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; оцениваются при каждой оценке.</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">Если &lt;code&gt;less&lt;/code&gt; - оператор меньше чем, что является опцией по умолчанию, тогда &lt;code&gt;BinaryHeap&lt;/code&gt; определяет так называемую max-heap, которая оптимизирует извлечение</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; и оператор не переполняется, функция возвращает тот же результат, что и встроенный оператор. Во всех остальных случаях возвращает &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">Если &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , возвращает &lt;code&gt;double.init&lt;/code&gt; . В противном случае, имеет ту же семантику, что и сравнение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">Если &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; ссылаются на один и тот же экземпляр, то ничего не делается.</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; , &lt;code&gt;dchar[]&lt;/code&gt; , содержимое строки будет повторно использовано (перезаписано) при чтении.</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; , поведение аналогично case (1), за исключением того, что проверка UTF не выполняется при вводе.</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;wstring&lt;/code&gt; или &lt;code&gt;dstring&lt;/code&gt; , новая строка соответствующего типа выделяется при каждом чтении.</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;ubyte[]&lt;/code&gt; , поведение аналогично случаю (2), за исключением того, что при вводе не выполняется проверка UTF.</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">Если &lt;code&gt;main()&lt;/code&gt; или поток возвращается нормально (не выдает исключение), статический деструктор добавляется в список функций, вызываемых при завершении потока.</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">Если &lt;code&gt;maxSize == unbounded&lt;/code&gt; , возвращает &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; . В противном случае возвращает &lt;code&gt;max&lt;/code&gt; для размеров в интервале &lt;code&gt;[min, max]&lt;/code&gt; и &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; , алгоритм не имеет эффекта и возвращает &lt;code&gt;r[0 .. r.length]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; имеет право на фриланс, возвращает &lt;code&gt;max&lt;/code&gt; . В противном случае возвращает &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; не определено, бесконечный диапазон произвольного доступа с нарезкой. Если &lt;code&gt;n&lt;/code&gt; определено, диапазон произвольного доступа с нарезкой.</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">Если &lt;code&gt;opCall&lt;/code&gt; переопределен для структуры, и структура инициализируется значением другого типа, то &lt;code&gt;opCall&lt;/code&gt; оператор opCall :</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">Если &lt;code&gt;opIndex&lt;/code&gt; объявлен только с одним аргументом, аргумент времени компиляции для &lt;code&gt;opDollar&lt;/code&gt; может быть опущен. В этом случае недопустимо использовать &lt;code&gt;$&lt;/code&gt; внутри выражения индексации массива с более чем одним аргументом.</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; является указателем где-то внутри блока, выделенного этим распределителем, &lt;code&gt;result&lt;/code&gt; содержит указатель на начало выделенного блока и возвращает &lt;code&gt;Ternary.yes&lt;/code&gt; . В противном случае &lt;code&gt;result&lt;/code&gt; имеет значение &lt;code&gt;null&lt;/code&gt; и возвращает &lt;code&gt;Ternary.no&lt;/code&gt; . Если указатель указывает сразу после выделенного блока, результат определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является относительным каталогом, верните его без изменений.</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; уже абсолютен, верните его.</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; пуст, вернуть &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; в форме &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), isValidFilename применяется к</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; начинается с &lt;code&gt;\\.\&lt;/code&gt; (Пространство имен устройства Win32), эта функция возвращает &lt;code&gt;false&lt;/code&gt; ; такие пути выходят за рамки этого модуля.</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; начинается с &lt;code&gt;\\?\&lt;/code&gt; (Длинный UNC-путь), единственным условием для остальной части строки является то, что она не содержит нулевой символ.</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">Если &lt;code&gt;postData&lt;/code&gt; не равен NULL, метод будет установлен на &lt;code&gt;post&lt;/code&gt; HTTP-запросов.</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">Если &lt;code&gt;pretty&lt;/code&gt; - false, пробелы не генерируются. Если &lt;code&gt;pretty&lt;/code&gt; is true, сериализованная строка форматируется так, чтобы она была удобочитаемой. Установите флаг &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; ,&lt;/a&gt; установленный в &lt;code&gt;options&lt;/code&gt; для кодирования NaN / Infinity в виде строк.</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;primary&lt;/code&gt; не принадлежит &lt;code&gt;b&lt;/code&gt; , то попытка &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; . Если это не удается, делается попытка переместить выделение с &lt;code&gt;fallback&lt;/code&gt; на &lt;code&gt;primary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">Если требуется регистрация в стиле &lt;code&gt;printf&lt;/code&gt; , добавьте &lt;b&gt;f&lt;/b&gt; к вызову регистрации, например &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; или &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; . Дополнительный &lt;b&gt;е&lt;/b&gt; добавляется к имени функции позволяет &lt;code&gt;printf&lt;/code&gt; -style ведения журнала для всех комбинаций явного &lt;code&gt;LogLevel&lt;/code&gt; и условных функций и методов регистрации.</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; содержит эквивалентные элементы, множественные перестановки &lt;code&gt;r&lt;/code&gt; удовлетворяют этим ограничениям. В таких случаях &lt;code&gt;pivotPartition&lt;/code&gt; пытается распределить эквивалентные элементы влево и вправо от &lt;code&gt;k&lt;/code&gt; так , чтобы &lt;code&gt;k&lt;/code&gt; оставалось близко к &lt;code&gt;r.length / 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; имеет длину, то это &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). В противном случае это &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; является строкой с символами Unicode в ней, &lt;code&gt;padLeft&lt;/code&gt; следует правилам D о длине для строк, которая является не количеством символов или графем, а числом кодирующих единиц. Если вы хотите обрабатывать каждую графему как только одну единицу кодирования, то вызовите &lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt; перед вызовом этой функции.</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; не является автоматически декодируемой строкой (то есть узкой строкой или пользовательским типом, который подразумевает преобразование в строковый тип), тогда возвращается &lt;code&gt;r&lt;/code&gt; . В противном случае, &lt;code&gt;r&lt;/code&gt; преобразуется в соответствующий ему тип строки (если это еще не строка) и переносится в диапазон произвольного доступа, где тип кодирования элемента строки (ее кодовая единица) является типом элемента диапазона, и этот диапазон вернулся. В ассортименте есть нарезка. Если &lt;code&gt;r&lt;/code&gt; достаточно причудливый, чтобы быть структурой или классом, который сам по себе является входным диапазоном символов (т.е. он имеет API входного диапазона в качестве функций-членов),</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;range&lt;/code&gt; не имеет длины, и &lt;code&gt;popFront&lt;/code&gt; вызывается, когда &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; , индекс будет переполнен и продолжится из &lt;code&gt;Enumerator.min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">Если &lt;code&gt;range&lt;/code&gt; имеет длину, то ошибочно передавать значение для &lt;code&gt;start&lt;/code&gt; так что &lt;code&gt;start + range.length&lt;/code&gt; больше, чем &lt;code&gt;Enumerator.max&lt;/code&gt; , таким образом гарантируется, что переполнение не может произойти.</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; и оператор не переполняется, функция возвращает тот же результат, что и встроенный оператор. Во всех остальных случаях возвращает &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rhs&lt;/code&gt; - &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; , возвращает &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; . В противном случае возвращает &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">Если &lt;code&gt;s == 0&lt;/code&gt; , вызов может вернуть любой пустой фрагмент (включая &lt;code&gt;null&lt;/code&gt; ). В противном случае вызов выделяет &lt;code&gt;s&lt;/code&gt; байтов памяти и возвращает выделенный блок, или &lt;code&gt;null&lt;/code&gt; если запрос не может быть удовлетворен.</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">Если &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; , то элементы перемещаются из конца диапазона в слоты для заполнения. В этом случае выполняется абсолютный минимум ходов.</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является шаблоном функции, то есть единственным членом шаблона, и этот элемент является функцией, вернуть этот шаблон.</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Если &lt;code&gt;str&lt;/code&gt; заканчивается &lt;code&gt;delimiter&lt;/code&gt; , то возвращается &lt;code&gt;str&lt;/code&gt; без &lt;code&gt;delimiter&lt;/code&gt; на его конце. Если это делает &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Если &lt;code&gt;str&lt;/code&gt; начинается с &lt;code&gt;delimiter&lt;/code&gt; , возвращается часть &lt;code&gt;str&lt;/code&gt; , следующая за &lt;code&gt;delimiter&lt;/code&gt; . Если &lt;code&gt;str&lt;/code&gt; делает</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">Если &lt;code&gt;sz&lt;/code&gt; равно нулю, память, на которую ссылается p, будет освобождена, как если бы это был вызов &lt;code&gt;free&lt;/code&gt; . Если &lt;code&gt;p&lt;/code&gt; равно &lt;code&gt;null&lt;/code&gt; , новая память будет выделяться через &lt;code&gt;malloc&lt;/code&gt; . Если &lt;code&gt;p&lt;/code&gt; указывает на память, не выделенную из ГХ, или на внутреннюю часть выделенного блока памяти, никакая операция не выполняется, и возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">Если &lt;code&gt;ticksPerSec&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; , то &lt;code&gt;TickDuration&lt;/code&gt; не удалось получить значение &lt;code&gt;ticksPerSec&lt;/code&gt; в текущей системе, и &lt;code&gt;TickDuration&lt;/code&gt; не будет работать. Это было бы очень ненормально, хотя.</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">Если &lt;code&gt;timeval.tv_sec&lt;/code&gt; - это int, а результат не может поместиться в int, то для &lt;code&gt;tv_sec&lt;/code&gt; будет использовано самое близкое значение, которое может храниться в 32 битах . (поэтому &lt;code&gt;int.max&lt;/code&gt; , если он переходит, и &lt;code&gt;int.min&lt;/code&gt; , если он переходит).</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Если &lt;code&gt;toHash&lt;/code&gt; должен постоянно иметь одинаковое значение, когда &lt;code&gt;opEquals&lt;/code&gt; возвращает true. Другими словами, два объекта, которые считаются равными, всегда должны иметь одинаковое значение хеш-функции. В противном случае произойдет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Если &lt;code&gt;toHash&lt;/code&gt; должен постоянно иметь одинаковое значение, когда &lt;code&gt;opEquals&lt;/code&gt; возвращает true. Другими словами, две структуры, которые считаются равными, всегда должны иметь одинаковое значение хеш-функции. В противном случае произойдет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">Если преобразование B в A является конверсионным,требующим корректировки смещения,то все возвращаемые выражения должны быть скорректированы на возвращаемые выражения,набранные A.</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">Если значение JSON равно нулю, то оператор инициализирует его объектом, а затем устанавливает для него &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Если Source является &lt;code&gt;struct&lt;/code&gt; то упаковка / развертывание создаст копию; невозможно повлиять на исходную &lt;code&gt;struct&lt;/code&gt; через оболочку.</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">Если заявление</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Если у Targets есть только одна запись, а Source является классом, который явно ее реализует, wrap просто возвращает src, переданный в &lt;code&gt;Targets[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">Если предоставляется &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; , поля инициализируются синтаксисом &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d74a8d147475df621b5e8ac9d1c6cc1de44dcbfd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;union S&lt;/code&gt; has fields that define a copy constructor, whenever an object of type &lt;code&gt;S&lt;/code&gt; is initialized by copy, an error will be issued. The same rule applies to overlapped fields (anonymous unions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">Если a и b являются объектами обоих классов,то выражение переписывается как:</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Если запрашивается приведение к типу с плавающей точкой, и &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;onBadCast&lt;/code&gt; , приведение проверяется, проверяя &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; . Если это не &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Если запрашивается приведение к целочисленному типу, и &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;onBadCast&lt;/code&gt; , приведение проверяется, проверяя, чтобы &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;cast(U) get&lt;/code&gt; были одним и тем же арифметическим числом. (Обратите внимание , что &lt;code&gt;int(-1)&lt;/code&gt; и &lt;code&gt;uint(1)&lt;/code&gt; разные значения арифметически , хотя они имеют такое же представление побитовое и сравнение равных по правилам языка.) Если числа не равны арифметически, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; возвращается ,</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">Если тип возврата выбора является недействительным,то выбор должен бросить исключение,если только все варианты не являются недействительными.В этом случае сам переключатель castSwitch вернет пустоту.</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">Если код конструктора содержит вызов конструктора делегата,то все возможные пути выполнения через конструктор должны выполнить ровно один вызов конструктора делегата:</target>
        </trans-unit>
        <trans-unit id="289f1bcf6286485bf50554692831db27b58239e4" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegating constructor call, all possible execution paths through the constructor must make exactly one delegating constructor call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">Если определен конструктор копирования,то неявные обращения к нему будут вставляться в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">Если за объявлением следует документированный юнит-тест, код в юнит-тесте будет вставлен в &lt;b&gt;пример&lt;/b&gt; раздела объявления:</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">Если декларация начинается с</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">Если делегат пропущен, безопасность и чистота этой функции выводятся из безопасности и чистоты &lt;code&gt;Dg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">Если делегат, который принимает &lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt; , включен в качестве последнего &lt;code&gt;receive&lt;/code&gt; аргумента , он будет соответствовать любому сообщению, которое не было сопоставлено более ранним делегатом. Если отправлено более одного аргумента, &lt;code&gt;Variant&lt;/code&gt; будет содержать &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; всех отправленных значений.</target>
        </trans-unit>
        <trans-unit id="7c6073aed324734814b1c5af997eb904b7a1d366" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">Если делегирующий конструктор не вызывается,то происходит вызов конструктора базового класса по умолчанию.</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">Если производный класс переопределяет функцию-член базового класса с помощью различных &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt; , недостающие атрибуты будут автоматически компенсированы компилятором.</target>
        </trans-unit>
        <trans-unit id="9133da665b338dc9f2d280b762259fd2a4cf7d31" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with different &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">Если комментарий к документации для объявления состоит только из идентификатора &lt;code&gt;ditto&lt;/code&gt; , то к этой декларации также применяется комментарий к документации для предыдущего объявления в той же области действия объявления.</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">Если тип поля имеет отключенную конструкцию по умолчанию,то он должен быть инициализирован в конструкторе.</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">Если плавающий литерал имеет &lt;b&gt;. &lt;/b&gt;и суффикс типа, между ними должна быть хотя бы одна цифра:</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">Если за плавающим литералом следует &lt;b&gt;i&lt;/b&gt; , то это</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">Если функция пытается проверить себя на наличие этих атрибутов,то предполагается,что она не имеет этих атрибутов.</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">Если вызов функции не передает явного аргумента, т. Е. Он синтаксически использует &lt;code&gt;()&lt;/code&gt; , то эти скобки могут быть опущены, аналогично вызову метода получения &lt;a href=&quot;#property-functions&quot;&gt;функции свойства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">Если функция в производном классе отменяет функцию из своего суперкласса, то только один из &lt;code&gt;in&lt;/code&gt; договорах функции и ее базовые функции должны быть удовлетворено. Переопределение функций становится процессом</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">Если функция возвращает делегата или указатель функции,то для вызова возвращаемого значения требуются парантезы.</target>
        </trans-unit>
        <trans-unit id="3fb0c821f0139e65cc3fa8dd141873150a7b34b1" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parentheses are required if the returned value is to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">Если указана функция с нетиповым параметром,то эта функция вызывается,когда вариант содержит тип,не совпадающий ни с какой другой функцией.Это может быть использовано для применения одной и той же функции к нескольким возможным типам.Допускается только одна общая функция.</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">Если указана функция без параметров, эта функция вызывается, когда &lt;code&gt;variant&lt;/code&gt; не содержит значения. Допускается только одна функция без параметров.</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">Если используется устаревший логический возвращающий пользовательский обработчик, &lt;code&gt;false&lt;/code&gt; отображается на &lt;code&gt;UnitTestResult.fail&lt;/code&gt; , а &lt;code&gt;true&lt;/code&gt; отображается на &lt;code&gt;UnitTestResult.pass&lt;/code&gt; . Это было оригинальное поведение системы модульного тестирования.</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">Если библиотечная подпрограмма не может обработать тип &lt;code&gt;TypedefType&lt;/code&gt; , вы можете использовать шаблон TypedefType для извлечения типа, который упаковывает Typedef .</target>
        </trans-unit>
        <trans-unit id="6017cad6474bb7ce228682e278fda385b81e533f" translate="yes" xml:space="preserve">
          <source>If a memory object has only one pointer to it, that pointer is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">Если смесь имеет</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">Если модуль C импортирует модули A и B,любые изменения в B не будут беззвучно изменять код в C,который зависит от A.</target>
        </trans-unit>
        <trans-unit id="c291b53fa8bebca9657457c0dc4a5986d2a7e4df" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt; reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Если вложенный класс имеет &lt;code&gt;static&lt;/code&gt; атрибут, он не может получить доступ к переменным окружения, которые являются локальными для стека или нуждаются в &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="384ca96bef7bf27444107f5f4fec2bea50635462" translate="yes" xml:space="preserve">
          <source>If a new scope is desired for each expansion, use another set of braces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">Если опция необходима,то если ее не передать,то это приведет к ошибке</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">Если указана функция без параметров, она вызывается, когда любой из &lt;code&gt;variant&lt;/code&gt; не содержит значения или содержит тип, который не обрабатывается посещающими функциями.</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">Если указатель содержит</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">Если функция свойств не имеет параметров,она работает как геттер.Если имеет ровно один параметр,то работает как сеттер.</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">Если имя протокола опущено,то любой протокол будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Если диапазон, возвращаемый &lt;code&gt;map&lt;/code&gt; или &lt;code&gt;asyncBuf&lt;/code&gt; , используется в качестве входных данных для &lt;code&gt;map&lt;/code&gt; , то в качестве оптимизации исключается копирование из выходного буфера первого диапазона во входной буфер второго диапазона, даже если диапазоны возвращаются &lt;code&gt;map&lt;/code&gt; и &lt;code&gt;asyncBuf&lt;/code&gt; . являются диапазонами неслучайного доступа. Это означает, что параметр &lt;code&gt;bufSize&lt;/code&gt; , передаваемый текущему вызову &lt;code&gt;map&lt;/code&gt; , будет игнорироваться, а размер буфера будет равен размеру буфера &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">Если в качестве левой стороны выражения присваивания появляется оператор среза,а тип правой стороны совпадает с типом элемента левой стороны,то содержимое массива левой стороны устанавливается на правую сторону.</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">Если сильно чистая функция бросает исключение или ошибку,предположения,связанные с запоминанием и ссылками,не несут в себе бросаемое исключение.</target>
        </trans-unit>
        <trans-unit id="b78555ca8d430d27e26cbbff76c2b38ef65ebc11" translate="yes" xml:space="preserve">
          <source>If a struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">Если подвыражение выражения вызывает исключение,то все временные промежутки,созданные до оценки этого подвыражения,будут уничтожены в соответствии с правилами,приведенными выше.Для еще не построенных временных объектов вызовы деструкторов не будут производиться.</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">Если аргумент шаблона соответствует специализированный параметр шаблона, аргумент подогнаны с префиксом &lt;b&gt;H&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">Если шаблон содержит членов,имя которых совпадает с идентификатором шаблона,и если тип или тип параметров этих членов включает,по крайней мере,все параметры шаблона,то предполагается,что на этих членов ссылаются в конкретизации шаблона:</target>
        </trans-unit>
        <trans-unit id="89c78b76971977e3949d885ca70ed72b7e954c2c" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier then these members are assumed to be referred to in a template instantiation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae6a5dbef8ce07c71db2a20a8cd25a725a5d57c" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template (see &lt;a href=&quot;#implicit_template_properties&quot;&gt;Eponymous Templates&lt;/a&gt;:)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">Если шаблон объявляет ровно один член,а этот член является классом с тем же именем,что и шаблон:</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Если шаблон объявляет ровно один член, и этот член является функцией с тем же именем, что и шаблон, это объявление шаблона функции. В качестве альтернативы, объявление шаблона функции - это объявление функции с &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList,&lt;/i&gt;&lt;/a&gt; непосредственно предшествующим &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;параметрам&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">Если шаблон имеет &lt;a href=&quot;#aliasparameters&quot;&gt;параметр псевдонима шаблона&lt;/a&gt; и создается с локальным символом, созданная функция неявно становится вложенной для доступа к данным времени выполнения данного локального символа.</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">Если шаблон объявлен в совокупности или в локальной области видимости функции,то инстанцированные функции будут неявно захватывать контекст охватывающей области видимости.</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">Если переменная имеет вызов деструктора области видимости,вернитесь к его вызову.В противном случае верните NULL.</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">Если после рассмотрения всех аргументов типов остаются какие-либо параметры типа без присваивания типа,то им присваиваются типы,соответствующие аргументу шаблона,в той же позиции в параметре</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">Если псевдоним одного и того же объекта или оба null =&amp;gt; равны</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enum&lt;/code&gt; используется в качестве типа, случайная случайная величина обращается с равной вероятностью из любого из возможных значений перечисления &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">Если &lt;code&gt;opCmp&lt;/code&gt; объявление определяет метод opCmp или &lt;code&gt;opEquals&lt;/code&gt; , он будет иметь приоритет перед псевдонимом этого члена. Обратите внимание, что, в отличие от метода &lt;code&gt;opCmp&lt;/code&gt; , метод &lt;code&gt;opEquals&lt;/code&gt; неявно определяется для объявления &lt;code&gt;struct&lt;/code&gt; если пользовательский не указан; это означает, что если псевдоним этот член &lt;code&gt;opEquals&lt;/code&gt; является предпочтительным, он должен быть явно определен:</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">Если приложение должно перераспределить срез без возможности расширения, то возвращается &lt;code&gt;0&lt;/code&gt; . Это происходит, когда слайс ссылается на статический массив, или если другой слайс ссылается на элементы после конца текущего слайса.</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">Если приложению необходимо выполнить собственную обработку любых аргументов, которые &lt;code&gt;getopt&lt;/code&gt; не понял, оно может передать директиву &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; в &lt;code&gt;getopt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">Если перечисление имеет в качестве базового типа один из типов в левом столбце,то оно преобразуется в тип в правом столбце.</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">Если при компиляции программы возникает ошибка,то использование перегрузок и перезагрузок должно быть пересмотрено в соответствующих классах.</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">Если в</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;emptyExceptionMsg&lt;/code&gt; исключение, но оно содержит пустое сообщение, то возвращается emptyExceptionMsg .</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">Если идентичный типа к &lt;code&gt;type&lt;/code&gt; в &lt;code&gt;type.stringtable&lt;/code&gt; , вернуть последнюю. В противном случае добавьте его в &lt;code&gt;type.stringtable&lt;/code&gt; . Некоторые типы не объединяются и возвращаются как есть.</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">Если перегрузка присвоения идентификатора требуется и не существует, автоматически генерируется функция перегрузки присвоения идентификатора типа &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">Если неявное преобразование запрещено таблицей, &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражение&lt;/i&gt;&lt;/a&gt; может быть преобразовано, если:</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">Если индексное выражение может быть переписано с использованием &lt;code&gt;opIndexAssign&lt;/code&gt; или &lt;code&gt;opIndexOpAssign&lt;/code&gt; , они предпочтительнее, чем &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">Если интерфейс имеет &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; класс памяти, то все члены интерфейса являются &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; . Этот класс хранения не наследуется.</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опция привязана к числовому типу,то номер ожидается как следующий опцион,или прямо внутри опции,разделенной знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опцион привязан к строке,то строка ожидается как следующий опцион,или прямо внутри опциона,разделенного знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">Если опция привязана к массиву,то каждый раз при установке опции к массиву добавляется новый элемент:</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опция привязана к ассоциативному массиву,то в качестве следующего варианта ожидается строка вида &quot;name=value&quot;,либо прямо внутри опции,разделенной знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опцион привязан к перечислению,символ перечисления в виде строки ожидается как следующий опцион,или прямо внутри опциона,разделенного знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">Если имя опции имеет суффикс &quot;+&quot; и привязано к числовому типу,то значение опции отслеживает количество раз,которое произошло в командной строке:</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">Если за строкой параметра следует другая строка, эта строка служит описанием этой опции. Функция &lt;code&gt;getopt&lt;/code&gt; возвращает структуру типа &lt;code&gt;GetoptResult&lt;/code&gt; . Это возвращаемое значение содержит информацию обо всех переданных параметрах, а также флаг &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; , указывающий, запрашивалась ли информация об этих параметрах. Функция &lt;code&gt;getopt&lt;/code&gt; всегда добавляет опцию &lt;code&gt;--help|-h&lt;/code&gt; чтобы установить флаг, если эта опция видна в командной строке.</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">Если &lt;code&gt;TaskPool&lt;/code&gt; какой-либо TaskPool с потоками, не являющимися демонами, для его &lt;code&gt;finish&lt;/code&gt; необходимо вызвать &lt;code&gt;stop&lt;/code&gt; или finish .</target>
        </trans-unit>
        <trans-unit id="2442edf64b05fed93875352de9ddef61974e4dcd" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, struct default construction is also disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">Если какие-либо поля имеют отключенную конструкцию по умолчанию,то конструкция по умолчанию также отключена.</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">Если какой-либо из &lt;code&gt;lead&lt;/code&gt; и &lt;code&gt;vowel&lt;/code&gt; не является допустимым хангул джамо соответствующего класса &lt;a href=&quot;#Character&quot;&gt;символов,&lt;/a&gt; возвращается dchar.init.</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">Если какой-либо из аргументов в &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; является</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">Если какая-либо из проверок окажется неудачной,произойдет ошибка компиляции.</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">Если какая-либо из клавиш или значений в</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">Если применение вышеуказанных правил не приводит к одному типу для каждого параметра шаблона,то это является ошибкой.</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">Если утверждения включены и &lt;code&gt;toRange&lt;/code&gt; , то этот экземпляр WorkerLocalStorage больше не является локальным для рабочих, и при вызове этого метода возникнет ошибка подтверждения. Это не проверяется, когда утверждения отключены по соображениям производительности.</target>
        </trans-unit>
        <trans-unit id="2a4c7b046cde0bb5e12a60d5ebe77f7e562208f5" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f4197814b0d68b55040d1d95ed5fec00d9458" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt;&lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51eb056f1717f5d30ca42a509337be76f7a52798" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt;&lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">Если хотя бы один из диапазонов является мультимножеством, то учитываются все вхождения дублирующего элемента. Результат эквивалентен объединению всех входных диапазонов и выбору самых высоких &lt;code&gt;tgt.length&lt;/code&gt; элементов ранжирования на основе веса.</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">Если аутентификация или переадресация выполнена,то статус будет присвоен последнему полученному ответу.</target>
        </trans-unit>
        <trans-unit id="cd6490598a4d93059510177bb453af0037be62bb" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned off, then this is equivalent to duplicating the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742bd1e8cf3c2f25ee274ec3880df5cf7f721969" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned on (default), then they are handled as a separate overload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">Если аргумент блокировки имеет значение true, дождитесь завершения всех рабочих потоков перед возвратом. Эта опция может использоваться в приложениях, где результаты задач никогда не используются - например, когда &lt;code&gt;TaskPool&lt;/code&gt; используется в качестве элементарного планировщика для задач, которые взаимодействуют с помощью средств, отличных от возвращаемых значений.</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Primary&lt;/code&gt; и &lt;code&gt;Fallback&lt;/code&gt; не имеют состояния, &lt;code&gt;FallbackAllocator&lt;/code&gt; определяет статический экземпляр с именем &lt;code&gt;instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">Если и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; являются целыми числами (могут быть сложены в константу), выражение среза можно преобразовать в тип статического массива &lt;code&gt;T[b - a]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">Если и шаблон с параметром последовательности,и шаблон без параметра последовательности точно совпадают по инстанцированности с шаблоном,то шаблон без параметра</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">Если оба распределители являются &lt;code&gt;shared&lt;/code&gt; , тем &lt;code&gt;Segregator&lt;/code&gt; также будет предлагать &lt;code&gt;shared&lt;/code&gt; методы.</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">Если оба типа подписаны или оба не подписаны,то меньший тип преобразуется в больший.</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">Если оба типа одинаковы,преобразование больше не производится.</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">Если оба аргумента являются диапазонами значений L одного и того же типа, то &lt;code&gt;SetSymmetricDifference&lt;/code&gt; также будет диапазоном значений L этого типа.</target>
        </trans-unit>
        <trans-unit id="f20cc499ea7bfd3b9b5a7bc116d95b44ec6d1e4b" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. For example, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt;, &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;, &lt;code&gt;int.max + 1 == int.min&lt;/code&gt;, and &lt;code&gt;int.min - 1 == int.max&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">Если оба операнда имеют целочисленные типы и в вычислениях возникает переполнение или недостаточное значение, произойдет перенос. То есть &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; и &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">Если оба операнда являются указателями, а оператор &lt;code&gt;+&lt;/code&gt; , то это недопустимо.</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">Если оба операнда являются указателями, а оператор - &lt;code&gt;-&lt;/code&gt; , указатели вычитаются, а результат делится на размер типа, на который указывают операнды. В этом расчете предполагаемый размер &lt;code&gt;void&lt;/code&gt; составляет один байт. Это ошибка, если указатели указывают на разные типы. Тип результата - &lt;code&gt;ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">Если оба диапазона конечны, то один должен быть (как минимум) &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном,&lt;/a&gt; а другой - &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;входным диапазоном&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">Если оба диапазона бесконечны,то оба должны быть прямыми.</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">Если оба диапазона являются наборами (без дублированных элементов), результирующий диапазон будет набором. Если хотя бы один из диапазонов является мультимножеством, число вхождений элемента &lt;code&gt;x&lt;/code&gt; в результирующий диапазон равно &lt;code&gt;abs(a-b)&lt;/code&gt; где &lt;code&gt;a&lt;/code&gt; - это число вхождений &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;r1&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; - количество вхождений &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;r2&lt;/code&gt; . и &lt;code&gt;abs&lt;/code&gt; является абсолютной величиной.</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">Если оба диапазона имеют член длины, эта функция равна &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). В противном случае эта функция равна &amp;Omicron; ( &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">Если и x,и n равны 0,то результат равен 1.Если n равно отрицательному значению,то во время выполнения программы,независимо от значения x,возникнет целочисленная ошибка деления.</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">Если за перерывом следует</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">Если включена проверка инварианта класса,то в конце конструктора вызывается инвариант класса.</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">Если код обнаруживает ошибку типа &amp;laquo;недостаточно памяти&amp;raquo;, выдается ошибка с сообщением &amp;laquo;недостаточно памяти&amp;raquo;. Стек вызова функции разматывается, ищется обработчик для ошибки. &lt;a href=&quot;statement#TryStatement&quot;&gt;Наконец блоки&lt;/a&gt; выполняются, так как стек разматывается. Если обработчик ошибок найден, выполнение возобновляется там. Если нет, то запускается обработчик ошибок по умолчанию, который отображает сообщение и завершает работу программы.</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">Если за продолжением следует</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">Если определена и &lt;code&gt;hookOpCast&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">Если определено, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; используется как инициализатор полезной нагрузки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">Если определено, &lt;code&gt;Hook.max!T&lt;/code&gt; используется в качестве максимального значения полезной нагрузки.</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">Если определено, &lt;code&gt;Hook.min!T&lt;/code&gt; используется в качестве минимального значения полезной нагрузки.</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора, а &lt;code&gt;rhs&lt;/code&gt; - правый операнд) перенаправляется безоговорочно для бинарных операторов &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора, а &lt;code&gt;lhs&lt;/code&gt; - левый операнд) безоговорочно перенаправляется в двоичные операторы &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; направляется безусловно , когда полезная нагрузка должна быть преобразованный к типу &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; перенаправляется безоговорочно при сравнении полезной нагрузки для упорядочения со значением &lt;code&gt;rhs&lt;/code&gt; целого, с плавающей запятой или логического типа.</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; перенаправляется безоговорочно при сравнении полезной нагрузки на равенство со значением &lt;code&gt;rhs&lt;/code&gt; целого, с плавающей запятой или логического типа.</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора, а &lt;code&gt;rhs&lt;/code&gt; - правый операнд) перенаправляется в безусловно для бинарных операторов &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора) пересылается для унарных операторов &lt;code&gt;-&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; . Кроме того, для одинарных операторов &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; Называется, где &lt;code&gt;payload&lt;/code&gt; представляет собой ссылку на значение обернуто &lt;code&gt;Checked&lt;/code&gt; так крюк может изменить его.</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (где &lt;code&gt;payload&lt;/code&gt; является ссылкой на значение, заключенное в Checked) пересылается при &lt;code&gt;toHash&lt;/code&gt; для типа Checked. Пользовательское хеширование может быть реализовано в &lt;code&gt;Hook&lt;/code&gt; , в противном случае используется встроенное хеширование.</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (где &lt;code&gt;value&lt;/code&gt; - это присваиваемое значение) пересылается, когда результат двоичных операторов &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; меньше , чем наименьшее значение , представимых &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; перенаправляется для унарных операторов, которые переполняются, но только если не определено &lt;code&gt;hookOpUnary&lt;/code&gt; . Унарный &lt;code&gt;~&lt;/code&gt; не переполняется; unary &lt;code&gt;-&lt;/code&gt; переполняется только тогда, когда отрицательное значение самого отрицательного типа отрицается, и возвращается результат вызова ловушки. Когда операторы увеличения или уменьшения переполняются, полезная нагрузка присваивается результат &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; . Когда двоичный оператор переполняется, &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; результат hook.onOverflow! Op (get, rhs) , но только если &lt;code&gt;Hook&lt;/code&gt; не определяет &lt;code&gt;hookOpBinary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (где &lt;code&gt;value&lt;/code&gt; - это присваиваемое значение) пересылается, когда результат двоичных операторов &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; больше , чем наибольшее значение , представимых &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">Если e-это SliceExp,постоянно складывайте его.</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">Если e1 является функцией свойств (шаблоном),разрешите его.</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">Если один из них равен нулю =&amp;gt; не равен</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">Если один из операндов &lt;code&gt;real&lt;/code&gt; , другой операнд преобразуется в &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Если один из операндов является типом с плавающей запятой, другой неявно преобразуется в тип с плавающей запятой, и они приводятся к общему типу с помощью обычных &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;арифметических преобразований&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">Если второе или третье выражение имеет тип &lt;code&gt;void&lt;/code&gt; , то результирующий тип будет &lt;code&gt;void&lt;/code&gt; . В противном случае второе и третье выражения неявно преобразуются в общий тип, который становится типом результата условного выражения.</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">Если выражение может быть проверено на истинность или ложь,возвращает измененное выражение.В противном случае возвращает ErrorExp.</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">Если выражение является общим,проверьте,что мы можем получить к нему доступ.Если нет,то дайте сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">Если флаг &lt;code&gt;KeepTerminator&lt;/code&gt; установлен в &lt;code&gt;KeepTerminator.yes&lt;/code&gt; , то разделитель включается в возвращаемые строки.</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">Если найдено,верните запись в списке,что она есть,иначе-ноль.</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Если func когда-либо генерирует точку времени, большую или равную текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">Если func когда-либо генерирует точку времени, большую или равную текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; . Диапазон будет пуст и итерация будет завершена, когда func сгенерирует момент времени, равный или меньший, чем &lt;code&gt;begin&lt;/code&gt; интервала.</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Если func когда-либо генерирует момент времени, меньший или равный текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">Если func когда-либо генерирует момент времени, меньший или равный текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; . Диапазон будет пустым, и итерация будет завершена, когда func сгенерирует момент времени, равный или превышающий &lt;code&gt;end&lt;/code&gt; интервала.</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">Если func сохраняет состояние, которое изменяется, как он называется, то некоторые алгоритмы не будут работать правильно, потому что при &lt;code&gt;save&lt;/code&gt; диапазона не удалось реально сохранить состояние диапазона. Чтобы избежать таких ошибок, не передавайте делегату, который не является логически чистым, &lt;code&gt;fwdRange&lt;/code&gt; . Если func задан один и тот же момент времени с двумя разными вызовами, он должен возвращать один и тот же результат оба раза. Конечно, ни одна из функций в этом модуле не имеет этой проблемы, так что это относится только к пользовательским делегатам.</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">Если func сохраняет состояние, которое изменяется, как он называется, то некоторые алгоритмы не будут работать правильно, потому что при &lt;code&gt;save&lt;/code&gt; диапазона не удалось реально сохранить состояние диапазона. Чтобы избежать таких ошибок, не передавайте делегату, который не является логически чистым, &lt;code&gt;fwdRange&lt;/code&gt; . Если func задан один и тот же момент времени с двумя разными вызовами, он должен возвращать один и тот же результат оба раза. Конечно, ни одна из функций в этом модуле не имеет этой проблемы, поэтому это актуально только при создании пользовательского делегата.</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">Если функция выполняется в базовом классе,верните этот базовый класс.</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">Если в цитируемом поле какая-либо цитата сама по себе,а не в конце поля,то обработка для этого поля закончится.</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">Если &lt;code&gt;No.multiblock&lt;/code&gt; экземпляр No.multiblock , он выполняет поиск первого нулевого бита в битовой карте и устанавливает его.</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">Если isNested()возвращает true,то isThis()должна возвращать false,если только функции не нужен указатель двойного контекста.</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Если оно &lt;code&gt;false&lt;/code&gt; , то вычисляется третье выражение, и его результат является результатом условного выражения.</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Если оно &lt;code&gt;true&lt;/code&gt; , то вычисляется второе выражение, а его результат является результатом условного выражения.</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">Если желательно сохранить &lt;code&gt;Unique!T&lt;/code&gt; за пределами его первоначального объема, его можно перенести. Передача может быть явной при вызове &lt;code&gt;release&lt;/code&gt; или неявной при возврате Unique из функции. Ресурс &lt;code&gt;T&lt;/code&gt; может быть полиморфным объектом класса или экземпляром интерфейса, и в этом случае Unique также ведет себя полиморфно.</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">Если задан только тип T и переменной v нет,то выражение catch все равно выполняется.</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">Если несколько шаблонов с одним и тем же</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">Если &lt;code&gt;delimiter&lt;/code&gt; не указан, то один завершающий символ &lt;code&gt;'\r'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; , &lt;code&gt;'\f'&lt;/code&gt; , &lt;code&gt;'\v'&lt;/code&gt; , &lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt; удаляется с конца &lt;code&gt;str&lt;/code&gt; . Если &lt;code&gt;str&lt;/code&gt; не заканчивается ни одним из этих символов, он возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">Если &lt;code&gt;needle&lt;/code&gt; не указана , &lt;code&gt;pred(haystack.front)&lt;/code&gt; будет оцениваться для каждого элемента входного диапазона.</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">Если в конструкторе нет вызова конструкторов с помощью &lt;code&gt;this&lt;/code&gt; или &lt;code&gt;super&lt;/code&gt; , и в базовом классе есть конструктор, вызов &lt;code&gt;super()&lt;/code&gt; вставляется в начало конструктора.</target>
        </trans-unit>
        <trans-unit id="a6ba6c3c787fc12e247d6c67731ac7ae3ae18393" translate="yes" xml:space="preserve">
          <source>If no calls to a delegating constructor or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a nullary constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor. If that base class has a constructor that requires arguments and no nullary constructor, a matching call to &lt;code&gt;super&lt;/code&gt; is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">Если для ошибок нет обработчиков catch,то программа изящно завершает свою работу через обработчик ошибок по умолчанию с соответствующим сообщением.</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">Если циклы не найдены,то для сохранения старого некорректного поведения при упорядочивании,ctors и tlsctors заменяются на сгенерированные этим алгоритмом.</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Если данные недоступны и основной поток обращается к диапазону, он блокируется, пока данные не станут доступными. Исключением является метод &lt;code&gt;wait(Duration)&lt;/code&gt; в &lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; &lt;/a&gt; . Этот метод будет ожидать максимум в течение указанной продолжительности и вернет true, если данные доступны.</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Если данные недоступны и основной поток обращается к диапазону, который он блокирует, пока данные не станут доступными. Исключением является метод &lt;code&gt;wait(Duration)&lt;/code&gt; в &lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; &lt;/a&gt; . Этот метод будет ожидать максимум в течение указанной продолжительности и вернет true, если данные доступны.</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">При отсутствии явного посевного материала в качестве посевного материала используется первый элемент каждой рабочей единицы.Для окончательного уменьшения,в качестве посевного материала используется результат первого рабочего элемента.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">Если не указана функция для вызова, &lt;code&gt;each&lt;/code&gt; умолчанию не делает ничего, кроме использования всего диапазона. Будет оценен &lt;code&gt;r.front&lt;/code&gt; , но этого можно избежать, указав лямбду с параметром &lt;code&gt;lazy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">Если иглы не предусмотрено, &lt;code&gt;haystack&lt;/code&gt; продвигается до тех пор, пока &lt;code&gt;pred&lt;/code&gt; оценивается как &lt;code&gt;true&lt;/code&gt; . Точно так же стог сена позиционируется так, что &lt;code&gt;pred&lt;/code&gt; оценивается как &lt;code&gt;false&lt;/code&gt; для &lt;code&gt;haystack.front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">Если генератор случайных чисел не передается в &lt;code&gt;randomCover&lt;/code&gt; , то глобальный поток RNG rndGen будет использоваться внутри.</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Если разделитель не передан, предикат &lt;code&gt;isTerminator&lt;/code&gt; решает, принимать ли элемент &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f27eb4bbcd5d830894d40b205272557d1b8c1c3" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">Если никакие пользовательские обработчики юнит-тестов не зарегистрированы, выполняется следующий алгоритм (на поведение может повлиять переключатель ниже &lt;code&gt;--DRT-testmode&lt;/code&gt; ): 1. Запустите все юнит-тесты, отслеживание выполненных тестов и прохождение. Для каждого сбоя выведите трассировку стека и продолжите. 2. Если сбоев нет, установите флаг суммирования в значение false, а флаг runMain в значение true. 3. Если есть ошибки, установите флаг суммирования на true, а флаг runMain на false.</target>
        </trans-unit>
        <trans-unit id="8e742609c87c27dd7441a0c05820a232e71bfca1" translate="yes" xml:space="preserve">
          <source>If no unittests were present, set summarize to false, and runMain to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">Если результат не нулевой,префикс с 0x (0X).</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">Если ни одно из регистровых выражений не совпадает,а есть оператор по умолчанию,то оператор по умолчанию передается.</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">Если ни один из вариантов не совпадает, &lt;code&gt;SwitchError&lt;/code&gt; . &lt;code&gt;SwitchError&lt;/code&gt; также будет сгенерирован , если не все варианты являются недействительными и выбор void был выполнен, не выдавая ничего.</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">Если не указано,то</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">Если один из них лучше другого,или один компилируется,а другой нет,выбирается первый.</target>
        </trans-unit>
        <trans-unit id="6dedca9993144f5a2bfb52216f61891e811d98ea" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a &lt;code&gt;NaN&lt;/code&gt;, the other is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">Если один из аргументов-NaN,возвращается другой.</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">Если одно из чисел является целым числом, а другое - числом с плавающей запятой, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; тогда и только тогда, когда интеграл может быть точно (без аппроксимации) преобразован в число с плавающей запятой. Это делается для того, чтобы сохранить транзитивность равенства: если &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; и &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; то &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; , если &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; - это сочетание целых чисел и чисел с плавающей точкой ,</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Если одно из чисел является целым числом, а другое - числом с плавающей запятой, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; возвращает число с плавающей запятой, равное &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;x &amp;lt; y&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , если &lt;code&gt;x == y&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , если &lt;code&gt;x &amp;gt; y&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; , если число с плавающей запятой равно &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">Если один операнд является перечислением,а другой-базовым типом этого перечисления,то в результате получается базовый тип.</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">Если один или оба типа операндов являются перечислением после прохождения вышеописанных преобразований,то типом результата является тип результата:</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">Если один или оба операнда имеют плавающую точку,то выполняется сравнение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">Если один диапазон бесконечен,а другой конечный,то конечный диапазон должен быть прямым,а бесконечный диапазон может быть входным.</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">Если для &lt;code&gt;Chain&lt;/code&gt; или &lt;code&gt;chain&lt;/code&gt; предлагается только один диапазон , то тип &lt;code&gt;Chain&lt;/code&gt; выходит за пределы изображения, совмещая себя непосредственно с типом этого диапазона.</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Если передан только один тип, то массив этого типа. В противном случае массив &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">Если операнды являются интегральными типами</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если требуется перекрытие, используйте &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Если переопределить &lt;code&gt;Object.opEquals()&lt;/code&gt; для классов, подпись функции-члена класса должна выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Если переопределить &lt;code&gt;Object.opCmp()&lt;/code&gt; для классов, подпись функции-члена класса должна выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">Если p равен нулю,операция не выполняется.</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">Если paramsym равен нулю,вместо paramsym используется новый ScopeDsymbol.</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">Если передается в диапазоне кодовых точек,возвращает диапазон с эквивалентными возможностями.</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">Если указатели на выделенную память мусорщика D передаются в функции С,то крайне важно убедиться,что память не будет собрана мусорщиком до того,как функция С будет с ней закончена.Этого можно добиться:</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">Если указатели на память,выделенную на куче мусора в сборщике мусора D,передаются в функции С++,то крайне важно,чтобы эта память не была собрана сборщиком мусора в D до того,как с ней будет закончена работа функции С++.Этого можно добиться:</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">Если возможно,преобразовать инициализатор массива в инициализатор ассоциативного массива.</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">Если присутствует,то</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">Если диапазон - это диапазон байтов, &lt;code&gt;Encoder&lt;/code&gt; который перебирает байты соответствующей кодировки Base64. Если диапазон - это диапазон диапазонов байтов, &lt;code&gt;Encoder&lt;/code&gt; который выполняет итерацию по кодированным в Base64 строкам каждого элемента диапазона. В обоих случаях возвращаемый &lt;code&gt;Encoder&lt;/code&gt; будет &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном,&lt;/a&gt; если данный &lt;code&gt;range&lt;/code&gt; является по крайней мере прямым диапазоном, в противном случае это будет только входной диапазон.</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">Если диапазон - это диапазон символов, то &lt;code&gt;Decoder&lt;/code&gt; выполняет итерации по байтам соответствующего декодирования Base64. Если диапазон - это диапазон диапазонов символов, то &lt;code&gt;Decoder&lt;/code&gt; выполняет итерацию по декодированным строкам, соответствующим каждому элементу диапазона. В этом случае длина каждого поддиапазона должна быть кратна 4; возвращенный декодер не отслеживает состояние декодирования Base64 через границы поддиапазона. В обоих случаях возвращенный &lt;code&gt;Decoder&lt;/code&gt; будет &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном,&lt;/a&gt; если данный &lt;code&gt;range&lt;/code&gt; является, по крайней мере, прямым диапазоном, в противном случае это будет только входной диапазон. Если входные данные содержат символы, которых нет в базовом алфавите текущей схемы кодирования Base64, возвращаемый диапазон может выдать &lt;code&gt;Base64Exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">Если точно такой же тип =&amp;gt; один вызов метода opEquals</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">Если установлено во время выполнения, &lt;code&gt;min&lt;/code&gt; и / или &lt;code&gt;max&lt;/code&gt; должны быть соответственно инициализированы.</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">Если установлено во время выполнения, &lt;code&gt;min&lt;/code&gt; и / или &lt;code&gt;max&lt;/code&gt; должны быть соответственно инициализированы. Блок должен быть выделен с помощью этого списка, и между распределением и освобождением не должно происходить динамического изменения &lt;code&gt;min&lt;/code&gt; или &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">Если установлено значение &lt;code&gt;AllowDayOverflow.no&lt;/code&gt; , переполнение дня не допускается.</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">Если установлено значение &lt;code&gt;AutoStart.no&lt;/code&gt; , то StopWatch не запускается при его создании.</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">Если установлено &lt;code&gt;AutoStart.no&lt;/code&gt; , то секундомер не запускается при его создании.</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">Если установлено значение &lt;code&gt;CheckDns.no&lt;/code&gt; , isEmail не выполняет проверку DNS.</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">Если установлено значение &lt;code&gt;OpenRight.yes&lt;/code&gt; , то интервал открывается справа (последний элемент не включен).</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">Если установлено значение &lt;code&gt;PopFirst.no&lt;/code&gt; , то popFront не вызывается перед возвратом диапазона.</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">Если установлено значение &lt;code&gt;SortOutput.no&lt;/code&gt; , выходные данные не должны быть отсортированы.</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">Если установлено, 0 является единственным допустимым &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;денормализованным&lt;/a&gt; числом IEEE754 . Требуются allowDenorm и storeNormalized.</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">Если установлено, выберите смещение экспоненты так, чтобы max_exp = 1., т.е. чтобы максимальное значение было&amp;gt; = 1.0 и &amp;lt;2.0. Игнорируется, если смещение показателя указано вручную.</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">Если установлено,то беззнаковые пользовательские поплавки считаются отрицательными.</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">Если зависимости размера неизбежны, поместите в код &lt;code&gt;static assert&lt;/code&gt; чтобы проверить это:</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">Если некоторые из этих полей не NULL,то это указатель на b_data.</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Если у источника есть внутренние указатели,указывающие на себя и не определяющие opPostMove,его нельзя перемещать,и он вызовет сбой утверждения.</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Если у источника есть внутренние указатели,указывающие на него самого,то его нельзя перемещать,и это вызовет сбой в утверждении.</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">Если необходимо разбить строку на пустое пространство и сжать токены, рассмотрите возможность использования &lt;code&gt;splitter&lt;/code&gt; без указания разделителя.</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">Если разрешено разделение передачи данных,то этот обратный вызов вызывается после завершения загрузки отдельного фрагмента.Примечание! После установки этого обратного вызова,он должен быть вызван для ВСЕХ блоков.Даже если загрузка этого фрагмента была пропущена в CHUNK_BGN_FUNC.По этой причине нам не нужен параметр &quot;transfer_info&quot; в этом обратном вызове,и нам не интересен параметр &quot;remains&quot;.</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">Если операторы обеспечивают простое условное выполнение операторов.</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">Если конструктор структуры аннотирован &lt;code&gt;@disable&lt;/code&gt; и имеет пустой &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; , структура отключила конструкцию по умолчанию. Единственный способ, которым он может быть построен, - это вызов другого конструктора с непустым</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">Если включена проверка инварианта структуры,то инвариант структуры вызывается в конце конструктора.</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">Если структуры объявляют &lt;code&gt;opCmp&lt;/code&gt; член opCmp , она должна иметь следующую форму:</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">Если структуры объявляют &lt;code&gt;opEquals&lt;/code&gt; член opEquals для сравнения идентификаторов, она может иметь несколько форм, таких как:</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">Если такое совпадение имеет место,то аут считается общим классификатором совпавших классификаторов.Если существует более двух параметров,то вычисление общего классификатора применяется рекурсивно.</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">Если такой</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">Если параметры шаблонного типа совпадают с литеральными выражениями на аргументах функции,то выведенные типы могут рассмотреть возможность их сужения.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">Если исходный файл .d начинается со строки &quot;Ddoc&quot;,то он рассматривается как документация общего назначения,а не как файл исходного кода D.Сразу после строки &quot;Ddoc&quot; до конца файла или любой секции &quot;Macros:&quot; формируется документ.Никакая автоматическая подсветка этого текста не производится,кроме подсветки кода D,встроенного между строками,очерченными строками ---.Осуществляется только обработка макросов.</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">Если &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Условие&lt;/i&gt;&lt;/a&gt; выполнено, то следующее</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">Если в &lt;code&gt;config&lt;/code&gt; установлен флаг &lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; &lt;/a&gt; , дочерний процесс будет</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">Если &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; имеет длину одного токена, круглые скобки могут быть опущены:</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">Если &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; пуст, экземпляр структуры инициализируется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="91aa0bb3a56c8d252e49de956e4900b6178db3ed" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Если объект &lt;code&gt;BitmappedBlock&lt;/code&gt; пуст (не имеет активного выделения), выделяет всю память внутри и возвращает ему фрагмент. В противном случае возвращает &lt;code&gt;null&lt;/code&gt; (т. Е. Не делается попытка выделить самый большой доступный блок).</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">Если &lt;code&gt;FileLogger&lt;/code&gt; управляет &lt;code&gt;File&lt;/code&gt; он входит, этот метод возвращает ссылку на этот файл.</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;FileLogger&lt;/code&gt; был создан с именем файла, этот метод возвращает это имя файла. В противном случае возвращается пустая &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Если объект &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; пуст (не имеет активного выделения), выделяет всю память внутри и возвращает ему фрагмент. В противном случае возвращает &lt;code&gt;null&lt;/code&gt; (т. Е. Не делается попытка выделить самый большой доступный блок).</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Если &lt;code&gt;Task&lt;/code&gt; еще не запущена, выполните ее в текущем потоке. Если это сделано, вернуть его возвращаемое значение, если таковое имеется. Если он выполняется, вращение занято до тех пор, пока оно не будет выполнено, а затем верните возвращаемое значение. Если это вызвало исключение, сбросьте это исключение.</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Если &lt;code&gt;Task&lt;/code&gt; еще не запущена, выполните ее в текущем потоке. Если это сделано, вернуть его возвращаемое значение, если таковое имеется. Если это происходит, дождитесь условной переменной. Если это вызвало исключение, сбросьте это исключение.</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">Если &lt;code&gt;VariantN&lt;/code&gt; содержит (ассоциативный) массив, возвращает длину этого массива. В противном случае выдает исключение.</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">Если &lt;code&gt;VariantN&lt;/code&gt; содержит массив, по очереди применяет &lt;code&gt;dg&lt;/code&gt; к каждому элементу массива. В противном случае выдает исключение.</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">Если объект &lt;code&gt;VariantN&lt;/code&gt; содержит значение</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">Если используется форма &lt;code&gt;[ ]&lt;/code&gt; , срез занимает весь массив.</target>
        </trans-unit>
        <trans-unit id="5bc0d1d6fc33510ec1a8451afec85b978d105f76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;format&lt;/code&gt; argument is a string literal, it is verified to be a valid format string per the C99 Standard. If the &lt;code&gt;format&lt;/code&gt; parameter is followed by &lt;code&gt;...&lt;/code&gt;, the number and types of the variadic arguments are checked against the format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">Если используется CURLOPT_INFILE,то это может быть использовано для информирования libcurl о том,насколько большой на самом деле отправляемый файл.Это позволяет лучше проверять ошибки и лучше проверять,что загрузка прошла успешно.-1 означает неизвестный размер.</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">Если UDA является типом,то любые UDA того же типа на символе будут совпадать.Если UDA является шаблоном для типа,то любая UDA,которая является инстанцией этого шаблона,будет соответствовать.А если UDA-это значение,то будут совпадать любые UDA на символе,которые равны этому значению.</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">Если [EBP] опущен, он предполагается для локальных переменных. Если используется &lt;code&gt;naked&lt;/code&gt; , это больше не имеет места.</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">Если агрегированное выражение является последовательностью,то могут быть объявлены один или два итерационных символа.Если один,то символ является</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">Если агрегатное выражение является статическим или динамическим массивом &lt;code&gt;char&lt;/code&gt; s, &lt;code&gt;wchar&lt;/code&gt; s или &lt;code&gt;dchar&lt;/code&gt; s, то</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">Если агрегатное выражение является объектом структуры или класса, но &lt;code&gt;opApply&lt;/code&gt; для &lt;code&gt;foreach&lt;/code&gt; или &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;code&gt;foreach_reverse&lt;/code&gt; не существует, то итерация по объектам структуры и класса может выполняться с помощью примитивов диапазона. Для &lt;code&gt;foreach&lt;/code&gt; это означает, что должны быть определены следующие свойства и методы:</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">Если статистическое выражение является объектом структуры или класса, &lt;code&gt;foreach&lt;/code&gt; определяется специальной &lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt; членом &lt;span id=&quot;opApply&quot;&gt;opApply&lt;/span&gt; , а поведение &lt;code&gt;foreach_reverse&lt;/code&gt; определяется специальной &lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt; членом &lt;span id=&quot;opApplyReverse&quot;&gt;opApplyReverse&lt;/span&gt; . Эти функции имеют тип:</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Если агрегированное выражение является ассоциативным массивом,то могут быть объявлены одна или две переменные.Если одна,то переменная объявляется как</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Если агрегат является статическим или динамическим массивом,то могут быть объявлены одна или две переменные.Если одна,то переменная объявляется как</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">Если аргументом является CommaExp,установите флаг,чтобы предотвратить сообщения об обесценивании</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">Если аргумент опущен,это означает,что по умолчанию построен скалярный тип:</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Если все аргументы являются либо типами, являющимися абстрактными классами, либо выражениями, которые типизированы как абстрактные классы, возвращается значение &lt;code&gt;true&lt;/code&gt; . В противном случае возвращается &lt;code&gt;false&lt;/code&gt; . Если аргументов нет, возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Если все аргументы являются либо типами, являющимися арифметическими типами, либо выражениями, которые типизируются как арифметические типы, возвращается значение &lt;code&gt;true&lt;/code&gt; . В противном случае возвращается &lt;code&gt;false&lt;/code&gt; . Если аргументов нет, возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">Если назначенный тип значения &lt;b&gt;не&lt;/b&gt; эквивалентен типу элемента AA, выражение может вызвать перегрузку оператора с обычным доступом к индексированию:</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">Если присвоенный тип значения эквивалентен типу элемента AA:</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">Если проверка границ в &lt;code&gt;@system&lt;/code&gt; или &lt;code&gt;@trusted&lt;/code&gt; отключена, правильность кода все равно должна быть гарантирована автором кода.</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">Если обратный вызов не принимает никаких аргументов,то он вызывается всякий раз,когда появляется опция.</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">Если обратный вызов принимает один строковый аргумент,то строка опций (без ведущего тире (тире))передается обратному вызову.После этого строка опций считается обработанной и удаляется из массива опций.</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">Если обратный вызов принимает два строковых аргумента,то строка-опция обрабатывается как опция с одним аргументом и разбирается соответственно.Опция и ее значение передаются обратному вызову.После этого,все,что было передано обратному вызову,считается обработанным и удаляется из списка.</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">Если вызывающий абонент является Fiber и не является Generator,то эта функция будет вызывать scheduler.yield()или Fiber.yield(),соответственно.</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">Если вызывающий абонент является абонентом по расписанию,это приводит к выполнению другого абонента по расписанию.</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">Если емкость увеличена,следует предположить,что все итераторы к элементам недействительны.</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">Если объем управляемой памяти велик, может быть желательно переключить управление на свободный список с самого начала. Таким образом, память может использоваться более компактно, чем режим области. Чтобы &lt;code&gt;switchToFreeList&lt;/code&gt; режим свободного списка, вызовите switchToFreeList вскоре после создания или, когда это будет сочтено целесообразным.</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">Если соединение идет слишком быстро,то нужно его замедлить.</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">Если конструктор может создать уникальный объект (например, если он &lt;code&gt;pure&lt;/code&gt; ), объект может быть неявно преобразован в любые квалификаторы.</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">Если конструктор может создать уникальный объект (т. Е. Если он &lt;code&gt;pure&lt;/code&gt; ), этот объект неявно преобразуется в любые квалификаторы.</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">Если текущий счет равен нулю,вернитесь.В противном случае,атоматически уменьшайте счет на единицу и возвращайте true.</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">Если объявление отключено, но внутри отключенной функции, возвращает &lt;code&gt;true&lt;/code&gt; , но не выдает сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">Если задано значение по умолчанию для какого-либо параметра,то все следующие параметры также должны иметь значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">Если разделитель-это идентификатор,то за ним должна немедленно следовать новая строка,а совпадающий разделитель-это тот же самый идентификатор,начинающийся в начале строки:</target>
        </trans-unit>
        <trans-unit id="76a3cf7d70aa80e5130f9aadda4aeef632729f66" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter must be the same identifier starting at the beginning of the line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">Если документация функции-члена контейнера принимает параметр типа &lt;code&gt;Range&lt;/code&gt; , то он ссылается на основной тип диапазона этого контейнера. Часто будет использоваться &lt;code&gt;Take!Range&lt;/code&gt; , и в этом случае диапазон относится к диапазону элементов в контейнере. Аргументы этих параметров &lt;b&gt;должны&lt;/b&gt; быть получены из того же экземпляра контейнера, с которым вы работаете. Важно отметить, что многие универсальные алгоритмы диапазона возвращают тот же тип диапазона, что и их входной диапазон.</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">Если в течение &quot;времени низкой скорости&quot; секунд загрузка получает меньше &quot;нижнего предела скорости&quot; байт/секунду,то операции прерываются.Т.е.если у вас довольно высокоскоростное соединение,то вы можете прервать его,если в течение 20 секунд оно составляет менее 2000 байт/сек.</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">Если адрес электронной почты действителен или нет.</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">Если перечислить</target>
        </trans-unit>
        <trans-unit id="c1aaeeb72f410c4e6aff61a784ecba88ce60daf3" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to false the functions are never inlined, otherwise they are always inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">Если выражение является &lt;a href=&quot;function#property-functions&quot;&gt;функцией свойства&lt;/a&gt; , &lt;code&gt;typeof&lt;/code&gt; возвращает тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">Если зарегистрирован расширенный обработчик юниттеста,то эта функция возвращает результат от этого обработчика напрямую.</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если расширение пусто, эта функция эквивалентна &lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">Если поле инициализируется на одном пути,то оно должно быть инициализировано на всех путях.</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">Если тип поля имеет метод &lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt; , он не будет использоваться для инициализации.</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">Если тип поля не изменяется,множественная инициализация будет отклонена.</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">Если файл не открыт, возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае возвращает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">Если файл не открыт, происходит безуспешно. В противном случае возвращает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">Если имя файла модуля является недопустимым именем модуля (например, &lt;code&gt;foo-bar.d&lt;/code&gt; ), вы можете использовать объявление модуля для установки действительного имени модуля:</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">Если файл не был открыт, выполняется безуспешно. В противном случае закрывает файл (вызывая &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt; ), выдавая ошибку. Даже если выдается исключение, после этого объект &lt;code&gt;File&lt;/code&gt; остается пустым. Это отличается от &lt;code&gt;detach&lt;/code&gt; тем, что он всегда закрывает файл; следовательно, все другие объекты &lt;code&gt;File&lt;/code&gt; , ссылающиеся на тот же дескриптор, отныне будут видеть закрытый файл.</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">Если имя файла уже имеет расширение, оно заменяется. Если нет, расширение просто добавляется к имени файла. Включение ведущей точки в &lt;code&gt;ext&lt;/code&gt; необязательно.</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">Если первый</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">Если первая строка начинается с &quot;#!&quot;,то эта строка игнорируется.</target>
        </trans-unit>
        <trans-unit id="0759e4efe42fd76d83650d76ffb9cbdc81cfccae" translate="yes" xml:space="preserve">
          <source>If the first lookup isn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes the scope of base classes and interfaces (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Если первый поиск не был успешным, второй выполняется для импорта. На втором этапе поиска унаследованные области игнорируются. Это включает в себя область действия базовых классов и интерфейса (в этом примере импорт &lt;code&gt;BaseClass&lt;/code&gt; будет игнорироваться), а также импорт в смешанном &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">Если режим округления с плавающей запятой изменяется внутри функции,то он должен быть восстановлен до ее выхода.Если это правило нарушается (например,при использовании inline asm),то режим округления,используемый для последующих вычислений,не определен.</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">Если строка формата зафиксирована,то при ее передаче в качестве параметра шаблона проверяется корректность типа параметров на этапе компиляции.Это также может привести к повышению производительности.</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">Если дробная часть x точно равна 0,5,возвращаемое значение округляется от нуля.</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">Если функция передается в виде строки, состояние имеет имя &lt;code&gt;&quot;a&quot;&lt;/code&gt; а индекс с нулем в повторении имеет имя &lt;code&gt;&quot;n&quot;&lt;/code&gt; . Данная строка должна возвращать желаемое значение для &lt;code&gt;a[n]&lt;/code&gt; учетом &lt;code&gt;a[n - 1]&lt;/code&gt; , &lt;code&gt;a[n - 2]&lt;/code&gt; , &lt;code&gt;a[n - 3]&lt;/code&gt; , ..., &lt;code&gt;a[n - stateSize]&lt;/code&gt; . Размер состояния определяется количеством аргументов, переданных при вызове &lt;code&gt;recurrence&lt;/code&gt; . Структура &lt;code&gt;Recurrence&lt;/code&gt; сама заботится об управлении состоянием повторения и его соответствующем смещении.</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">Если функция возвращает &lt;code&gt;void&lt;/code&gt; , а первый параметр - &lt;code&gt;ref&lt;/code&gt; или &lt;code&gt;out&lt;/code&gt; , то все последующие параметры &lt;code&gt;return ref&lt;/code&gt; рассматриваются как назначенные первому параметру для проверки срока службы. &lt;code&gt;this&lt;/code&gt; опорный параметр на структуру нестатических функций члена считаются первым параметром.</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">Если сгенерированный конструктор копирования не сможет проверить тип, он получит атрибут &lt;code&gt;@disable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">Если сгенерированный момент времени когда-либо проходит границу диапазона в правильном направлении, тогда вместо этого будет использоваться край этого диапазона. Итак, если итерация вперед и сгенерированный момент времени находятся за &lt;code&gt;end&lt;/code&gt; интервала , то &lt;code&gt;front&lt;/code&gt; становится &lt;code&gt;end&lt;/code&gt; . Если выполняется итерация в обратном направлении, а сгенерированный момент времени находится перед &lt;code&gt;begin&lt;/code&gt; , то &lt;code&gt;front&lt;/code&gt; становится &lt;code&gt;begin&lt;/code&gt; . В любом случае диапазон будет пустым.</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">Если данный файл является символической ссылкой,то это возвращает атрибуты самой символической ссылки,а не файла,на который она указывает.Если данный файл</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">Если данный заголовок содержит колонки,не найденные во входных данных,то они будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">Если заданный заголовок не совпадает с порядком во входных данных,содержимое вернется в том виде,в котором оно найдено во входных данных.</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">Если куча имеет пространство для роста, вставляет &lt;code&gt;value&lt;/code&gt; в хранилище и возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае, если &lt;code&gt;less(value, front)&lt;/code&gt; , вызывает &lt;code&gt;replaceFront(value)&lt;/code&gt; и возвращает снова значение &lt;code&gt;true&lt;/code&gt; . В противном случае оставляет кучу без изменений и возвращает &lt;code&gt;false&lt;/code&gt; . Этот метод полезен в сценариях, где должны быть собраны наименьшие &lt;code&gt;k&lt;/code&gt; элементов из набора кандидатов.</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">Если клавиша индексирования уже существует в AA,установка выполняет обычное назначение.</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">Если ключ индексирования еще не существует в AA,то будет выделена новая запись AA,и она будет инициализирована присвоенным значением.</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">Если результат с бесконечной точностью соответствует типу результата, верните его и не трогайте &lt;code&gt;overflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">Если инициализатор отсутствует,то неизменяемый может быть инициализирован из соответствующего конструктора:</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">Если входной массив уже действителен,то функция возвращает оригинал,в противном случае она строит новый массив,заменяя все незаконные последовательности на последовательность замены схемы кодирования.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">Если входная строка уже действительна,то эта функция возвращает оригинал,в противном случае она строит новую строку,заменяя все недопустимые последовательности единиц кода на символ замены кодировки,недопустимые последовательности будут заменены на символ замены Юникода (U+FFFD),если в репертуаре символов он содержится,в противном случае недопустимые последовательности будут заменены на символ '?'.</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">Если экземпляр &lt;code&gt;toString&lt;/code&gt; переопределил &lt;code&gt;Object.toString&lt;/code&gt; , он используется.</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">Если инвариант не держится,то программа переходит в недействительное состояние.</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">Если последний параметр шаблона в</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">Если для последнего параметра шаблона установлено значение &lt;code&gt;No.multiblock&lt;/code&gt; , распределитель будет обслуживать только те выделения, которые требуют не более &lt;code&gt;theBlockSize&lt;/code&gt; . &lt;code&gt;BitmappedBlock&lt;/code&gt; имеет специализированную реализацию для моноблочного распределения , что позволяет для выполнения большего, по стоимости не в состоянии выделить более одного блок в то время.</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">Если левый и правый операнды имеют одинаковый тип структуры, а тип структуры имеет &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt; , то операция копирования выполняется так же, как описано в &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">Если левая сторона</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Если левая часть присваивания является операцией среза в экземпляре структуры или класса, ее можно перегрузить, реализовав &lt;code&gt;opIndexAssign&lt;/code&gt; член opIndexAssign, которая принимает возвращаемое значение функции &lt;code&gt;opSlice&lt;/code&gt; в качестве параметра (ов). Выражения вида &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Если левая часть присваивания является индексной операцией над экземпляром структуры или класса, ее можно перегрузить, предоставив &lt;code&gt;opIndexAssign&lt;/code&gt; член opIndexAssign . Выражения вида &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд является &lt;code&gt;false&lt;/code&gt; , то правый операнд оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд имеет значение &lt;code&gt;true&lt;/code&gt; , то правый операнд оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд, преобразованный в тип &lt;code&gt;bool&lt;/code&gt; , оценивается как &lt;code&gt;false&lt;/code&gt; , то правый операнд не оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд, преобразованный в тип &lt;code&gt;bool&lt;/code&gt; , оценивается как &lt;code&gt;true&lt;/code&gt; , то правый операнд не оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">Если блокировка удерживается другим вызывающим абонентом,метод возвращается.В противном случае блокировка приобретается,если она еще не удерживается,а внутренний счетчик увеличивается на единицу.</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">Если именующее статический массив или срез, поведение , как описано в &lt;a href=&quot;array#array-copying&quot;&gt;Array , Копирование&lt;/a&gt; и &lt;a href=&quot;array#array-setting&quot;&gt;массива Setting&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">Если lvalue является определяемым пользователем свойством, поведение будет таким, как описано в &lt;a href=&quot;function#property-functions&quot;&gt;функциях свойств&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">Если lvalue является свойством &lt;code&gt;.length&lt;/code&gt; динамического массива, поведение будет таким, как описано в разделе &lt;a href=&quot;array#resize&quot;&gt;Установка длины динамического массива&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">Если член является классом или структурой,то неопределенный поиск будет перенаправлен на</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">Если модификатор &lt;code&gt;'d'&lt;/code&gt; присутствует, то число символов в , &lt;code&gt;to&lt;/code&gt; может быть только &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; . Если модификатор &lt;code&gt;'d'&lt;/code&gt; есть</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">Если нужно удалить некоторые элементы в диапазоне, но не нужно сохранять порядок остальных элементов, вы можете передать &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; для &lt;code&gt;remove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">Если новая длина массива больше,то остаток заполняется инициализатором по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">Если единственный указатель на объект удерживается за пределами этих областей,то коллектор пропустит его и освободит память.</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">Если операнды являются целочисленными значениями, применяются &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычные арифметические преобразования&lt;/a&gt; , чтобы привести их к общему типу перед сравнением. Равенство определяется как совпадение битовых комбинаций общего типа.</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Если операнды имеют целочисленные типы, они подвергаются &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычным арифметическим преобразованиям&lt;/a&gt; , а затем приводятся к общему типу с использованием обычных &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;арифметических преобразований&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">Если операнды являются указателями,то равенство определяется так,как точно совпадают битовые паттерны операндов.</target>
        </trans-unit>
        <trans-unit id="d6d2f3784c99d4e2535bc4e5ff87e942828bc905" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">Если операнды одного типа,результатом будет этот тип.</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">Если операнды ассоциативного оператора+или*являются значениями с плавающей точкой,то выражение не переупорядочивается.</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Если операция приведет к переполнению / переполнению, эта функция вернет &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">Если оператор равен &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , и первый операнд является указателем, а второй является целочисленным типом, результирующий тип является типом первого операнда, а результирующее значение является указателем плюс (или минус) второй операнд умножается на размер типа, на который указывает первый операнд.</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">Если оператор &lt;code&gt;=&lt;/code&gt; , то это простое присваивание. Правый операнд неявно преобразуется в тип левого операнда и присваивается ему.</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">Если опциональный второй</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">Если родительский распределитель &lt;code&gt;Allocator&lt;/code&gt; находится в состоянии, его экземпляр сохраняется как член. В противном случае &lt;code&gt;AffixAllocator&lt;/code&gt; использует &lt;code&gt;Allocator.instance&lt;/code&gt; . В любом случае имя &lt;code&gt;_parent&lt;/code&gt; равномерно используется для доступа к родительскому распределителю.</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">Если переданный буфер не является последним распределением, то &lt;code&gt;delta&lt;/code&gt; может составлять самое большее количество байтов, оставшихся на последней странице. В противном случае мы можем расширить последнее выделение до конца диапазона виртуальных адресов.</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">Если процесс, связанный с &lt;code&gt;pid&lt;/code&gt; , уже завершен, &lt;code&gt;tryWait&lt;/code&gt; имеет тот же эффект, что и &lt;code&gt;wait&lt;/code&gt; . В этом случае он возвращает кортеж, в котором для &lt;code&gt;terminated&lt;/code&gt; поля установлено значение &lt;code&gt;true&lt;/code&gt; , а поле &lt;code&gt;status&lt;/code&gt; имеет ту же интерпретацию, что и возвращаемое значение &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">Если процесс</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">Если процесс уже завершен, эта функция возвращается напрямую. Код выхода кэшируется, поэтому, если wait () вызывается несколько раз на одном и том же &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; ,&lt;/a&gt; он всегда будет возвращать одно и то же значение.</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Если процесс завершается с помощью сигнала, то &lt;code&gt;status&lt;/code&gt; поля возвращаемого значения будет содержать отрицательное число, абсолютное значение которого номер сигнала. (Подробнее см. &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">Если процесс завершается сигналом, эта функция возвращает отрицательное число, абсолютным значением которого является номер сигнала. Поскольку POSIX ограничивает нормальные коды выхода диапазоном 0-255, отрицательное возвращаемое значение всегда будет указывать завершение по сигналу. Сигнальные коды определены в модуле &lt;code&gt;core.sys.posix.signal&lt;/code&gt; (который соответствует заголовку POSIX &lt;code&gt;signal.h&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">Если диапазон уже является лексикографически наибольшей четной перестановкой,то он возвращается к наименьшей четной перестановке и возвращается false.В противном случае возвращается true,а диапазон изменяется на лексикографически следующую четную перестановку.</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">Если диапазон в настоящее время является лексикографически наибольшей перестановкой, он переставляется обратно к наименьшей перестановке, и возвращается ложное значение. В противном случае возвращается true. Таким образом, можно сгенерировать все перестановки диапазона, отсортировав его в соответствии с &lt;code&gt;less&lt;/code&gt; , что приводит к лексикографически наименьшей перестановке, а затем вызывая nextPermutation, пока он не вернет false. Это гарантированно генерирует все различные перестановки диапазона ровно один раз. Если есть</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">Если диапазон заканчивается до &lt;code&gt;n&lt;/code&gt; элементов, &lt;code&gt;take&lt;/code&gt; просто возвращает весь диапазон (в отличие от &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; , что приведет к ошибке подтверждения, если диапазон преждевременно заканчивается):</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">Если диапазоны являются строками, &lt;code&gt;cmp&lt;/code&gt; выполняет UTF-декодирование соответствующим образом и сравнивает диапазоны по одной кодовой точке за раз.</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">При соблюдении вышеперечисленных ограничений генерируется следующий конструктор копирования:</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">Если тип возвращаемого значения - int, а результат не может поместиться в int, то будет использовано ближайшее значение, которое может храниться в 32 битах (например, &lt;code&gt;int.max&lt;/code&gt; , если оно переходит, и &lt;code&gt;int.min&lt;/code&gt; , если оно переходит) , Однако не предпринимается никаких попыток справиться с целочисленным переполнением, если тип возвращаемого значения длинный.</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">Если возвращаемое значение не равно x,то повышается исключение FE_INEXACT.</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">Если правая сторона также является Проверенной,но с другим типом крюка или подложки,крюк и подложка этого Проверенного имеют приоритет.</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">Если длина второго аргумента меньше длины индексируемого диапазона,то бросается исключение.</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">Если вторым символом &lt;code&gt;path&lt;/code&gt; является двоеточие ( &lt;code&gt;':'&lt;/code&gt; ), первый символ интерпретируется как буква диска и должен находиться в диапазоне AZ (без учета регистра).</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">Если второй операнд является указателем, а первый - целочисленным, а оператор - &lt;code&gt;+&lt;/code&gt; , операнды меняются местами и применяется только что описанная арифметика указателя.</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">Если последовательность, заканчивающаяся на &lt;code&gt;startIdx&lt;/code&gt; , не представляет правильно сформированную &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; может быть выдано исключение std.utf.UTFException . &lt;code&gt;cs&lt;/code&gt; указывает, являются ли сравнения чувствительными к регистру.</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">Если последовательность представляет собой</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">Если последовательность, начинающаяся с &lt;code&gt;startIdx&lt;/code&gt; , не представляет правильно сформированную &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; может быть выдано исключение std.utf.UTFException .</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">Если бит знака установлен (то есть &quot;отрицательный&quot;),NAN меньше любого числа;если бит знака не установлен (он &quot;положительный&quot;),NAN больше любого числа;</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">Если подписанный тип больше,чем беззнаковый,то беззнаковый тип преобразуется в подписанный.</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">Если границы среза могут быть известны во время компиляции,то выражение среза неявно преобразуется в l-значение статического массива.Например:</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">Если исходный файл не начинается с BOM,то первый символ должен быть меньше или равен U+0000007F.</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">Если строковые данные имеют кодировку UTF-8 и к ним можно получить прямой доступ,верните указатель на них.Не принимайте прерывание 0.</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">Если строка не содержит амперсанда,будет возвращен оригинал.</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">Если строка не является допустимым адресом IPv4, возвращается &lt;code&gt;ADDR_NONE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">Если строка не будет изменена,будет возвращен оригинал.</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">Если структура определяет метод &lt;b&gt;toString (),&lt;/b&gt; результатом является строка, возвращаемая этой функцией. В противном случае результатом является StructName (поле &lt;sub&gt;0&lt;/sub&gt; , поле &lt;sub&gt;1&lt;/sub&gt; , ...), где поле &lt;sub&gt;n&lt;/sub&gt; - это n-й элемент, отформатированный в формате по умолчанию.</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">Если &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Выражение-&lt;/i&gt;&lt;/a&gt; переключатель имеет тип enum, все элементы enum должны появляться в &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="392ee3a5c086f39b17e3a3bb06e7ae5f17a147b6" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">Если переключатель &lt;code&gt;--DRT-testmode&lt;/code&gt; передается в исполняемый файл, он может иметь одно из 3 значений: 1. &amp;laquo;run-main&amp;raquo;: даже если модульные тесты запущены (и все пройдены), main все еще выполняется. Это в настоящее время по умолчанию. 2. &amp;laquo;test-or-main&amp;raquo;: любые присутствующие модульные тесты приведут к тому, что программа суммирует результаты и завершит работу независимо от результата. Это будет по умолчанию в 2.080. 3. &amp;laquo;только для тестирования&amp;raquo;, среда выполнения всегда суммирует и никогда не запускает main, даже если тесты отсутствуют.</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">Если поток еще не был запущен, возвращает &lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; . В противном случае возвращает результат &lt;code&gt;GetCurrentThreadId&lt;/code&gt; в Windows и &lt;code&gt;pthread_self&lt;/code&gt; в POSIX. Значение уникально для текущего процесса.</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если часовой пояс &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (или считаются эквивалентными &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; разделом 4.3 спецификации), A &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; с UTC смещение &lt;code&gt;0&lt;/code&gt; используется вместо &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; , тогда как &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; использует &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">Если оба аргумента являются лямбда-функциями (или псевдонимами лямбда-функций),то они сравниваются для равенства.Для того,чтобы сравнение было вычислено правильно,для обеих лямбда-функций должны быть выполнены следующие условия:</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">Если два аргумента являются выражениями,состоящими из литералов или перечислений,которые оцениваются до одного и того же значения,то возвращается true.</target>
        </trans-unit>
        <trans-unit id="de4732a957b75ea4620f562388e09ef879657bc9" translate="yes" xml:space="preserve">
          <source>If the two arguments are tuples then &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the two tuples, after expansion, have the same length and if each pair of nth argument respects the constraints previously specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">Если два операнда разные перечисления,то в результате получается ближайший тип базы,общий для обоих.Ближайший базовый тип означает более короткую последовательность приведений к базовому типу,чтобы получить его от исходного типа.</target>
        </trans-unit>
        <trans-unit id="7903bedffa68e879ccc58bd5af9a496c7c800c23" translate="yes" xml:space="preserve">
          <source>If the two ranges are different kinds of UTF code unit (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;), then the arrays are compared using UTF decoding to avoid accidentally integer-promoting units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">Если тип является классом или структурой,возвращает символ для него,иначе-ноль.</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">Если тип литерала функции может быть однозначно определен из ее контекста,то возможен вывод типа параметра.</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">Если специализация по типу зависит от параметра типа,то тип этого параметра устанавливается в качестве соответствующей части аргумента типа.</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">Если union определяет метод &lt;b&gt;toString (),&lt;/b&gt; результатом является строка, возвращаемая из этой функции. В противном случае результатом является имя объединения без его содержимого.</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">Если соединение больше первого поля,остальные биты устанавливаются на 0.</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">Если соединение больше инициализированного поля,остальные биты устанавливаются на 0.</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">Если предоставленный пользователем размер равен нулю или предоставленный пользователем буфер пуст, выдается &lt;code&gt;Exception&lt;/code&gt; . В случае ошибки ввода / вывода выдает &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">Если переменная не существует,она будет создана.Если она уже существует,она будет перезаписана.</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">Если переменной нет в окружении,то функция возвращается успешно,ничего не делая.</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">Если параметр variadic представляет собой массив делегатов без параметров:</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">Если в</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">Если их несколько</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">Если имеется несколько &lt;code&gt;return ref&lt;/code&gt; параметров ref , время жизни возвращаемого значения является наименьшим временем жизни соответствующих аргументов.</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">Если существует несколько UDA в области действия декларации,то они объединяются:</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">Если в функции присутствует несколько прагматических строк,то лексически последняя вступает в силу.</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если аргументов нет, результат &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">Если для символа отсутствуют определяемые пользователем атрибуты,возвращается пустой кортеж.Выражение кортеж может быть превращено в управляемый кортеж:</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">Если объявлены два символа,то первый-это</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">Если есть &lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; , то эти аргументы передаются классу или структуре специфической &lt;a href=&quot;class#allocators&quot;&gt;функции распределителя&lt;/a&gt; после аргумента размера.</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">Если для класса определен конструктор,то вызывается конструктор,соответствующий списку аргументов.</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">Если для структуры определен конструктор,то вызывается конструктор,соответствующий списку аргументов.</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">Если есть &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражение&lt;/i&gt;&lt;/a&gt; , оно должно оцениваться как объект или экземпляр</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">Если существует выходное постусловие (см. &lt;a href=&quot;contracts&quot;&gt;Программирование контракта&lt;/a&gt; ), это постусловие выполняется после вычисления &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражения&lt;/i&gt;&lt;/a&gt; и до фактического возврата из функции.</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">Если существует более чем одна &lt;code&gt;scope&lt;/code&gt; переменная выходит из области видимости в той же точке, то деструкторы вызываются в обратном порядке , что переменные были построены.</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">Если &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; отсутствует и он не первый</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">Если для класса нет конструктора,но есть конструктор для базового класса,то конструктор по умолчанию неявно генерируется с формой:</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">Если нет никакого выражения возврата по умолчанию, и предикат не дает true с любым тестовым выражением - &lt;code&gt;SwitchError&lt;/code&gt; бросается. &lt;code&gt;SwitchError&lt;/code&gt; также генерируется , если выражение возврата void было выполнено, ничего не выбрасывая.</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">Если в документации к декларации нет комментариев,то эта декларация может не появиться на выходе.Чтобы убедиться в том,что она действительно появляется в выводе,поместите для нее пустой комментарий к декларации.</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">Если в строке нет часового пояса, используется &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; . Если часовой пояс &quot;Z&quot;, то используется &lt;code&gt;UTC&lt;/code&gt; . В противном случае используется &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; ,&lt;/a&gt; который соответствует данному смещению от UTC. Чтобы возвращаемый &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; был определенным часовым поясом, передайте этот часовой пояс, и &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; будет преобразован в этот часовой пояс (хотя он все равно будет считываться как любой часовой пояс в его строке).</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">Если для параметра нет типовой специализации,то тип параметра устанавливается в качестве аргумента шаблона.</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Если в анонимном перечислении есть только один член, &lt;code&gt;{ }&lt;/code&gt; можно опустить. Грамматически говоря, это &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">Если нет обработчика для конкретной ошибки,то он обрабатывается обработчиком по умолчанию библиотеки runtime.Если ошибка игнорируется,то это происходит из-за того,что программист специально добавил код,чтобы проигнорировать ошибку,что предположительно означает,что она была преднамеренной.</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если эти ограничения не выполняются, функция считается несопоставимой и &lt;code&gt;isSame&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">Если они оба нулевые,то они равны.Если один из них нулевой,а другой нет,то они не равны.Если они оба ненулевые,то они равны,если их значения равны.</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">Если они сравнивают равное значение,возвращаем значение 0,возвращаемое fp.</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">Если у них есть интерфейс диапазона,отформатированный как диапазон ввода.</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">Если у них одинаковые ptrs,верните еще 1 0.</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">Если часовой пояс этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; является &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , то TZ пуст. Если его часовой пояс &lt;code&gt;UTC&lt;/code&gt; , то это &amp;laquo;Z&amp;raquo;. В противном случае это смещение от UTC (например, +0100 или -0700). Обратите внимание, что смещение от UTC составляет</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">Если часовой пояс этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; является &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , то TZ пуст. Если его часовой пояс &lt;code&gt;UTC&lt;/code&gt; , то это &amp;laquo;Z&amp;raquo;. В противном случае это смещение от UTC (например, +01: 00 или -07: 00). Обратите внимание, что смещение от UTC составляет</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">Если этот &lt;code&gt;Nullable&lt;/code&gt; переносит тип, который уже имеет нулевое значение (например, указатель), и это нулевое значение не задано для &lt;code&gt;nullValue&lt;/code&gt; , то присвоение нулевого значения этому &lt;code&gt;Nullable&lt;/code&gt; ничем не отличается от назначения любого другого значения типа &lt;code&gt;T&lt;/code&gt; , и результирующий код будет выглядеть очень странно. Настоятельно рекомендуется , чтобы этого избежать, используя &lt;code&gt;T&lt;/code&gt; &amp;laquo;s&amp;bdquo;построен в&amp;ldquo;нулевое значение для &lt;code&gt;nullValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">Если этот &lt;code&gt;Nullable&lt;/code&gt; переносит тип, который уже имеет нулевое значение (например, указатель), то присвоение нулевого значения этому &lt;code&gt;Nullable&lt;/code&gt; ничем не отличается от назначения любого другого значения типа &lt;code&gt;T&lt;/code&gt; , и результирующий код будет выглядеть очень странно. Настоятельно рекомендуется избегать этого, используя вместо этого версию &lt;code&gt;Nullable&lt;/code&gt; , которая принимает дополнительный &lt;code&gt;nullValue&lt;/code&gt; шаблона nullValue .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
