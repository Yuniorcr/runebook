<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">Перегрузка при присвоении идентификационных данных</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">Выражения идентичности</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">Идеографическое описание Символы</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">Идиоматическое использование &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">Если !равен нулю,элементы[]могут быть разрежены,и для значения элемента &quot;по умолчанию&quot; используется основа.Другими словами,ненулевые элементы[i]переопределяют это &quot;базовое&quot; значение.</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">Если 'e'-дерево запятых,возвращает крайнее правое выражение,удаляя его из дерева.Оставшаяся часть дерева возвращается через e0.В противном случае 'e' возвращается напрямую и e0 устанавливается в NULL.</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Если &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt; ! R - это тип с плавающей запятой, а &lt;code&gt;R&lt;/code&gt; - &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;диапазон произвольного доступа&lt;/a&gt; с длиной и срезом, то для &lt;code&gt;sum&lt;/code&gt; используется алгоритм &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;попарного суммирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">Если &lt;code&gt;!!value&lt;/code&gt; истинно, &lt;code&gt;value&lt;/code&gt; возвращается. В противном случае &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; . &lt;code&gt;WindowsException&lt;/code&gt; предполагает, что последняя операция установила &lt;code&gt;GetLastError()&lt;/code&gt; соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">Если &lt;code&gt;!isInfinite!Source&lt;/code&gt; и &lt;code&gt;source.walkLength&lt;/code&gt; не делятся поровну на &lt;code&gt;chunkSize&lt;/code&gt; , то задний элемент этого диапазона будет содержать меньше элементов &lt;code&gt;chunkSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">Если &lt;code&gt;!value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; возвращается. В противном случае генерируется &lt;code&gt;new E(msg, file, line)&lt;/code&gt; . Или, если &lt;code&gt;E&lt;/code&gt; не принимает сообщение и может быть сконструировано с &lt;code&gt;new E(file, line)&lt;/code&gt; , тогда будет выброшено &lt;code&gt;new E(file, line)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; не имеет состояния, результирующий объект размещается в статическом общем хранилище.</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; имеет состояние и является копируемым, результатом будет &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; предоставленного распределителя &lt;code&gt;A a&lt;/code&gt; внутри. Сам результат размещается в собственном статически распределенном распределителе.</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; имеет состояние и не подлежит копированию, результат переместит переданный аргумент в результат. Сам результат размещается в собственном статически распределенном распределителе.</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; имеет состояние, результатом будет &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; предоставленного распределителя &lt;code&gt;A a&lt;/code&gt; внутри. Сам результат размещается в собственном статически распределенном распределителе.</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Allocator&lt;/code&gt; реализует &lt;code&gt;owns&lt;/code&gt; , пересылает к нему. В противном случае возвращает &lt;code&gt;Ternary.unknown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">Если &lt;code&gt;BookkeepingAllocator&lt;/code&gt; не &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;bkalloc&lt;/code&gt; определяется и доступным.</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Если &lt;code&gt;ElementType!R&lt;/code&gt; является типом с плавающей запятой, а &lt;code&gt;R&lt;/code&gt; - конечным входным диапазоном (но не диапазоном произвольного доступа со срезами), то для &lt;code&gt;sum&lt;/code&gt; используется алгоритм &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;суммирования Кахана&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Если &lt;code&gt;FreeList&lt;/code&gt; был &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; с maxSize == chooseAtRuntime , то свойство &lt;code&gt;max&lt;/code&gt; доступно для записи. Установка должна предшествовать любому распределению.</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Если &lt;code&gt;FreeList&lt;/code&gt; был создан с помощью &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; , тогда свойство &lt;code&gt;min&lt;/code&gt; доступно для записи. Установка должна предшествовать любому распределению.</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">Если &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;hookOpOpAssign&lt;/code&gt; , &lt;code&gt;opOpAssign&lt;/code&gt; пересылается на &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; , где &lt;code&gt;payload&lt;/code&gt; является ссылкой на данные , хранящиеся внутри, так что ловушка может их изменить.</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">Если &lt;code&gt;Hook&lt;/code&gt; не определяет &lt;code&gt;hookOpBinary&lt;/code&gt; , но определяет &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opBinary&lt;/code&gt; переадресует к &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; в случае переполнения.</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Hook&lt;/code&gt; не определяет &lt;code&gt;hookOpUnary&lt;/code&gt; , но определяет &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opUnary&lt;/code&gt; пересылает &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; в случае переполнения. Для &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; полезная нагрузка назначается из результата вызова &lt;code&gt;onOverflow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; содержит состояние, &lt;code&gt;parent&lt;/code&gt; является открытым членом типа &lt;code&gt;KRRegion&lt;/code&gt; . В противном случае &lt;code&gt;parent&lt;/code&gt; является &lt;code&gt;alias&lt;/code&gt; для &lt;code&gt;ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; равен &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , определяется только конструктор, принимающий &lt;code&gt;data&lt;/code&gt; и пользователь отвечает за освобождение &lt;code&gt;data&lt;/code&gt; если это необходимо.</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; отличается от &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Region&lt;/code&gt; освобождает часть памяти во время уничтожения.</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ParentAllocator&lt;/code&gt; с состоянием, &lt;code&gt;parent&lt;/code&gt; - это свойство, предоставляющее доступ к &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; . В противном случае &lt;code&gt;parent&lt;/code&gt; является псевдонимом &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">Если &lt;code&gt;Prefix&lt;/code&gt; является &lt;code&gt;void&lt;/code&gt; , выравниванием является то , что родитель. В противном случае выравнивание совпадает с выравниванием &lt;code&gt;Prefix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Prefix&lt;/code&gt; не является &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;Allocator&lt;/code&gt; должен гарантировать выравнивание, по крайней мере, &lt;code&gt;Prefix.alignof&lt;/code&gt; как Prefix.alignof .</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">Если &lt;code&gt;S&lt;/code&gt; определяет деструктор, сгенерированный код для &lt;code&gt;opAssign&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">Если &lt;code&gt;S&lt;/code&gt; не имеет постблита или деструктора, но содержит хотя бы одно поле, которое определяет функцию &lt;code&gt;opAssign&lt;/code&gt; (которая не отключена), то тело выполнит назначения для членов:</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;S&lt;/code&gt; имеет отключенный деструктор или хотя бы одно поле с отключенным &lt;code&gt;opAssign&lt;/code&gt; , &lt;code&gt;S.opAssign&lt;/code&gt; будет сгенерирован, но помечен &lt;code&gt;@disable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">Если &lt;code&gt;Source&lt;/code&gt; имеет структурное соответствие с &lt;code&gt;interface&lt;/code&gt; &lt;code&gt;Targets&lt;/code&gt; , wrap создает внутренний класс-обертку, который наследует &lt;code&gt;Targets&lt;/code&gt; и оборачивает объект &lt;code&gt;src&lt;/code&gt; , а затем возвращает его.</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Source&lt;/code&gt; является прямой диапазон, результирующий диапазон также будет прямым диапазоном. В противном случае полученные чанки будут входными диапазонами, потребляющими один и тот же ввод: итерация &lt;code&gt;front&lt;/code&gt; сократит чанк так, что последующие вызовы &lt;code&gt;front&lt;/code&gt; больше не будут возвращать полный чанк, а вызов &lt;code&gt;popFront&lt;/code&gt; во внешнем диапазоне лишит законной силы любые ссылки на предыдущие значения из &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">Если используется &lt;code&gt;StopWatch.init&lt;/code&gt; , то созданный StopWatch не работает (и не может быть, так как не работал ни один конструктор).</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">Если &lt;code&gt;Store&lt;/code&gt; является диапазоном, &lt;code&gt;BinaryHeap&lt;/code&gt; не может расти за пределами этого диапазона. Если &lt;code&gt;Store&lt;/code&gt; является контейнером, который поддерживает &lt;code&gt;insertBack&lt;/code&gt; , &lt;code&gt;BinaryHeap&lt;/code&gt; может расти, добавляя элементы в контейнер.</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса, возвращает ссылку на созданный объект &lt;code&gt;T&lt;/code&gt; .В противном случае возвращает символ &lt;code&gt;T*&lt;/code&gt; указывающий на созданный объект. Во всех случаях возвращает &lt;code&gt;null&lt;/code&gt; если выделение не удалось.</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является вложенной структурой, указатель контекста в &lt;code&gt;T.init&lt;/code&gt; является &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является структурой, которая имеет &lt;code&gt;@disable this();&lt;/code&gt; , &lt;code&gt;T.init&lt;/code&gt; может возвращать логически неправильный объект.</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является структурой с определенным деструктором или постблитом, источник возвращается к своему значению &lt;code&gt;.init&lt;/code&gt; после перемещения в цель, в противном случае он остается неизменным.</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом значения, то &lt;code&gt;Unique!T&lt;/code&gt; будет реализован в виде ссылки на &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является внутренним классом, &lt;code&gt;outer&lt;/code&gt; поле которого можно использовать для доступа к экземпляру включающего класса, то &lt;code&gt;Args&lt;/code&gt; не должен быть пустым, и первый его член должен быть допустимым инициализатором для этого &lt;code&gt;outer&lt;/code&gt; поля. Правильная инициализация этого поля необходима для доступа к членам внешнего класса внутри методов &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">Если конструктор &lt;code&gt;T&lt;/code&gt; выбрасывает, освобождает выделенную память и распространяет исключение.</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Если &lt;code&gt;U&lt;/code&gt; также является экземпляром &lt;code&gt;Checked&lt;/code&gt; , для метода &lt;code&gt;hookOpCmp&lt;/code&gt; интроспективно рассматриваются оба хука (левый и правый) . Если оба определяют его, приоритет отдается левой стороне.</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Если &lt;code&gt;U&lt;/code&gt; также является экземпляром &lt;code&gt;Checked&lt;/code&gt; , оба хука (левая и правая сторона) являются &lt;code&gt;hookOpEquals&lt;/code&gt; для метода hookOpEquals . Если оба определяют его, приоритет отдается левой стороне.</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">Если &lt;code&gt;Yes.checkDns&lt;/code&gt; , тогда будет сделана проверка DNS для записей MX</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; , просто итерация диапазона никогда не вызывая &lt;code&gt;front&lt;/code&gt; достаточно иметь &lt;code&gt;tee&lt;/code&gt; зеркальных элементов &lt;code&gt;outputRange&lt;/code&gt; (или, соответственно, &lt;code&gt;fun&lt;/code&gt; ). Если &lt;code&gt;No.pipeOnPop&lt;/code&gt; , то только те элементы, для которых вызывается &lt;code&gt;front&lt;/code&gt; , также будут отправлены в &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; , то &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; и листья без изменений, тогда как &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; продвигает к &lt;code&gt;&quot;de&quot;&lt;/code&gt; , и возвращает &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; и &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; , &lt;code&gt;bringToFront(a, b)&lt;/code&gt; оставляет &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; и &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; , &lt;code&gt;reverse(a)&lt;/code&gt; меняет его на &lt;code&gt;[3, 2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; , то &lt;code&gt;initializeAll(a)&lt;/code&gt; оставляет &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">Если &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; , и &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; , а затем &lt;code&gt;completeSort(a, b)&lt;/code&gt; оставляет &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; , и &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; . Диапазон &lt;code&gt;a&lt;/code&gt; должен быть отсортирован до вызова, и в результате &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; комбинация std.range.chain (a, b) .</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">Если &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; , то &lt;code&gt;partialSort(a, 3)&lt;/code&gt; оставляет &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; . Другие элементы &lt;code&gt;a&lt;/code&gt; оставлены в неуказанном порядке.</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">Если для &lt;code&gt;allowDuplicates&lt;/code&gt; задано значение &lt;code&gt;true&lt;/code&gt; , то вставка одного и того же элемента более одного раза продолжает добавлять больше элементов. Если это &lt;code&gt;false&lt;/code&gt; , дубликаты элементов игнорируются при вставке. Если дубликаты разрешены, новые элементы вставляются после всех существующих дубликатов.</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Если &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; , ничего не делает и возвращает &lt;code&gt;false&lt;/code&gt; . В противном случае уничтожает последние &lt;code&gt;arr.length - delta&lt;/code&gt; элементы arr.length в массиве, а затем перераспределяет буфер массива. В случае сбоя перераспределения заполняет массив инициализированными по умолчанию данными.</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Если &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; , ничего не делает и возвращает &lt;code&gt;false&lt;/code&gt; . В противном случае уничтожает последние &lt;code&gt;array.length - delta&lt;/code&gt; в массиве, а затем перераспределяет буфер массива. В случае сбоя перераспределения заполняет массив инициализированными по умолчанию данными.</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">Если &lt;code&gt;b is null&lt;/code&gt; , ничего не делает и возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае освобождает память, ранее выделенную этим распределителем, и возвращает &lt;code&gt;true&lt;/code&gt; в случае успеха, иначе &lt;code&gt;false&lt;/code&gt; . Реализация, которая не будет поддерживать освобождение (то есть всегда будет возвращать &lt;code&gt;false&lt;/code&gt; , вообще не должна определять этот примитив.)</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">Если &lt;code&gt;ba&lt;/code&gt; равно нулю (по умолчанию), атрибуты существующей памяти будут использоваться для выделения. Если &lt;code&gt;ba&lt;/code&gt; не равно нулю и новая память не выделена, биты в ba заменят биты текущего блока памяти.</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">Если &lt;code&gt;block.length&lt;/code&gt; находится в пределах &lt;code&gt;[min, max]&lt;/code&gt; или если свободный список не проверен ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ), тогда вставляется блок в начало свободного списка. Для всех остальных пересылается в &lt;code&gt; parent.deallocate&lt;/code&gt; , если определен &lt;code&gt;Parent.deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Если &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;BitmappedBlock&lt;/code&gt; предлагает свойство чтения / записи &lt;code&gt;blockSize&lt;/code&gt; . Он должен быть установлен перед любым использованием распределителя. В противном случае (то есть &lt;code&gt;theBlockSize&lt;/code&gt; является допустимой константой), &lt;code&gt;blockSize&lt;/code&gt; является псевдонимом для &lt;code&gt;theBlockSize&lt;/code&gt; . Независимо от того, является ли она постоянной или переменной, она также должна быть кратна &lt;code&gt;alignment&lt;/code&gt; . Это ограничение &lt;code&gt;assert&lt;/code&gt; статически и динамически.</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Если &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; предлагает свойство чтения / записи &lt;code&gt;blockSize&lt;/code&gt; . Он должен быть установлен перед любым использованием распределителя. В противном случае (то есть &lt;code&gt;theBlockSize&lt;/code&gt; является допустимой константой), &lt;code&gt;blockSize&lt;/code&gt; является псевдонимом для &lt;code&gt;theBlockSize&lt;/code&gt; . Независимо от того, является ли она постоянной или переменной, она также должна быть кратна &lt;code&gt;alignment&lt;/code&gt; . Это ограничение &lt;code&gt;assert&lt;/code&gt; статически и динамически.</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; является &lt;a href=&quot;#Character&quot;&gt;символом&lt;/a&gt; нижнего регистра Unicode , тогда возвращается его заглавный эквивалент. В противном случае возвращается &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; является заглавным &lt;a href=&quot;#Character&quot;&gt;символом&lt;/a&gt; Unicode , то возвращается его строчный эквивалент. В противном случае возвращается &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">Если &lt;code&gt;dir == Direction.fwd&lt;/code&gt; , то диапазон повторяется вперед во времени, тогда как если &lt;code&gt;dir == Direction.bwd&lt;/code&gt; , то он повторяется назад во времени. Итак, если &lt;code&gt;dir == Direction.fwd&lt;/code&gt; то &lt;code&gt;front == interval.begin&lt;/code&gt; , тогда как если &lt;code&gt;dir == Direction.bwd&lt;/code&gt; то &lt;code&gt;front == interval.end&lt;/code&gt; . &lt;code&gt;func&lt;/code&gt; должен сгенерировать момент времени, идущий в правильном направлении итерации, &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; будет сгенерировано исключение std.datetime.date.DateTimeException . Таким образом, чтобы выполнить итерацию во времени, момент времени, который генерирует &lt;code&gt;func&lt;/code&gt; , должен быть позже, чем тот, который был передан ему. Если оно идентично или ранее, то &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;будет брошен. Чтобы выполнить итерацию в обратном направлении, сгенерированный момент времени должен предшествовать моменту времени, который был передан.</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">Если &lt;code&gt;filler&lt;/code&gt; пуст.</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;fun&lt;/code&gt; это &lt;code&gt;string&lt;/code&gt; , новая функция с одним параметром. Если &lt;code&gt;fun&lt;/code&gt; не &lt;code&gt;string&lt;/code&gt; , это псевдоним &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;fun&lt;/code&gt; не является строкой, &lt;code&gt;binaryFun&lt;/code&gt; объединяет себя с &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">Если &lt;code&gt;hasLength!Range&lt;/code&gt; , просто возвращает &lt;code&gt;range.length&lt;/code&gt; без проверки &lt;code&gt;upTo&lt;/code&gt; (если указано).</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;haystack&lt;/code&gt; является диапазоном произвольного доступа, все три компонента кортежа имеют тот же тип, что и &lt;code&gt;haystack&lt;/code&gt; . В противном случае &lt;code&gt;haystack&lt;/code&gt; должен иметь &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямой диапазон,&lt;/a&gt; а тип &lt;code&gt;result[0]&lt;/code&gt; и &lt;code&gt;result[1]&lt;/code&gt; совпадает с &lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;impl.alignedAllocate&lt;/code&gt; существует, вызывает его и возвращает результат. В противном случае всегда возвращает &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">Если &lt;code&gt;impl.deallocate&lt;/code&gt; не определен, возвращает &lt;code&gt;false&lt;/code&gt; . В противном случае он перенаправляет вызов.</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">Если &lt;code&gt;input&lt;/code&gt; - &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямой диапазон&lt;/a&gt; , &lt;code&gt;needle&lt;/code&gt; может быть &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;передним диапазоном&lt;/a&gt; . В этом случае &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; оцениваются при каждой оценке.</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">Если &lt;code&gt;less&lt;/code&gt; - оператор меньше чем, что является опцией по умолчанию, тогда &lt;code&gt;BinaryHeap&lt;/code&gt; определяет так называемую max-heap, которая оптимизирует извлечение</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; и оператор не переполняется, функция возвращает тот же результат, что и встроенный оператор. Во всех остальных случаях возвращает &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">Если &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , возвращает &lt;code&gt;double.init&lt;/code&gt; . В противном случае, имеет ту же семантику, что и сравнение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">Если &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; ссылаются на один и тот же экземпляр, то ничего не делается.</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; , &lt;code&gt;dchar[]&lt;/code&gt; , содержимое строки будет повторно использовано (перезаписано) при чтении.</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; , поведение аналогично case (1), за исключением того, что проверка UTF не выполняется при вводе.</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;wstring&lt;/code&gt; или &lt;code&gt;dstring&lt;/code&gt; , новая строка соответствующего типа выделяется при каждом чтении.</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Если &lt;code&gt;line&lt;/code&gt; имеет тип &lt;code&gt;ubyte[]&lt;/code&gt; , поведение аналогично случаю (2), за исключением того, что при вводе не выполняется проверка UTF.</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">Если &lt;code&gt;main()&lt;/code&gt; или поток возвращается нормально (не выдает исключение), статический деструктор добавляется в список функций, вызываемых при завершении потока.</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">Если &lt;code&gt;maxSize == unbounded&lt;/code&gt; , возвращает &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; . В противном случае возвращает &lt;code&gt;max&lt;/code&gt; для размеров в интервале &lt;code&gt;[min, max]&lt;/code&gt; и &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; , алгоритм не имеет эффекта и возвращает &lt;code&gt;r[0 .. r.length]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; имеет право на фриланс, возвращает &lt;code&gt;max&lt;/code&gt; . В противном случае возвращает &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; не определено, бесконечный диапазон произвольного доступа с нарезкой. Если &lt;code&gt;n&lt;/code&gt; определено, диапазон произвольного доступа с нарезкой.</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">Если &lt;code&gt;opCall&lt;/code&gt; переопределен для структуры, и структура инициализируется значением другого типа, то &lt;code&gt;opCall&lt;/code&gt; оператор opCall :</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">Если &lt;code&gt;opIndex&lt;/code&gt; объявлен только с одним аргументом, аргумент времени компиляции для &lt;code&gt;opDollar&lt;/code&gt; может быть опущен. В этом случае недопустимо использовать &lt;code&gt;$&lt;/code&gt; внутри выражения индексации массива с более чем одним аргументом.</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; является указателем где-то внутри блока, выделенного этим распределителем, &lt;code&gt;result&lt;/code&gt; содержит указатель на начало выделенного блока и возвращает &lt;code&gt;Ternary.yes&lt;/code&gt; . В противном случае &lt;code&gt;result&lt;/code&gt; имеет значение &lt;code&gt;null&lt;/code&gt; и возвращает &lt;code&gt;Ternary.no&lt;/code&gt; . Если указатель указывает сразу после выделенного блока, результат определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является относительным каталогом, верните его без изменений.</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; уже абсолютен, верните его.</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; пуст, вернуть &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; в форме &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), isValidFilename применяется к</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; начинается с &lt;code&gt;\\.\&lt;/code&gt; (Пространство имен устройства Win32), эта функция возвращает &lt;code&gt;false&lt;/code&gt; ; такие пути выходят за рамки этого модуля.</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; начинается с &lt;code&gt;\\?\&lt;/code&gt; (Длинный UNC-путь), единственным условием для остальной части строки является то, что она не содержит нулевой символ.</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">Если &lt;code&gt;postData&lt;/code&gt; не равен NULL, метод будет установлен на &lt;code&gt;post&lt;/code&gt; HTTP-запросов.</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">Если &lt;code&gt;pretty&lt;/code&gt; - false, пробелы не генерируются. Если &lt;code&gt;pretty&lt;/code&gt; is true, сериализованная строка форматируется так, чтобы она была удобочитаемой. Установите флаг &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; ,&lt;/a&gt; установленный в &lt;code&gt;options&lt;/code&gt; для кодирования NaN / Infinity в виде строк.</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;primary&lt;/code&gt; не принадлежит &lt;code&gt;b&lt;/code&gt; , то попытка &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; . Если это не удается, делается попытка переместить выделение с &lt;code&gt;fallback&lt;/code&gt; на &lt;code&gt;primary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">Если требуется регистрация в стиле &lt;code&gt;printf&lt;/code&gt; , добавьте &lt;b&gt;f&lt;/b&gt; к вызову регистрации, например &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; или &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; . Дополнительный &lt;b&gt;е&lt;/b&gt; добавляется к имени функции позволяет &lt;code&gt;printf&lt;/code&gt; -style ведения журнала для всех комбинаций явного &lt;code&gt;LogLevel&lt;/code&gt; и условных функций и методов регистрации.</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; содержит эквивалентные элементы, множественные перестановки &lt;code&gt;r&lt;/code&gt; удовлетворяют этим ограничениям. В таких случаях &lt;code&gt;pivotPartition&lt;/code&gt; пытается распределить эквивалентные элементы влево и вправо от &lt;code&gt;k&lt;/code&gt; так , чтобы &lt;code&gt;k&lt;/code&gt; оставалось близко к &lt;code&gt;r.length / 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; имеет длину, то это &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). В противном случае это &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; является строкой с символами Unicode в ней, &lt;code&gt;padLeft&lt;/code&gt; следует правилам D о длине для строк, которая является не количеством символов или графем, а числом кодирующих единиц. Если вы хотите обрабатывать каждую графему как только одну единицу кодирования, то вызовите &lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt; перед вызовом этой функции.</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; не является автоматически декодируемой строкой (то есть узкой строкой или пользовательским типом, который подразумевает преобразование в строковый тип), тогда возвращается &lt;code&gt;r&lt;/code&gt; . В противном случае, &lt;code&gt;r&lt;/code&gt; преобразуется в соответствующий ему тип строки (если это еще не строка) и переносится в диапазон произвольного доступа, где тип кодирования элемента строки (ее кодовая единица) является типом элемента диапазона, и этот диапазон вернулся. В ассортименте есть нарезка. Если &lt;code&gt;r&lt;/code&gt; достаточно причудливый, чтобы быть структурой или классом, который сам по себе является входным диапазоном символов (т.е. он имеет API входного диапазона в качестве функций-членов),</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;range&lt;/code&gt; не имеет длины, и &lt;code&gt;popFront&lt;/code&gt; вызывается, когда &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; , индекс будет переполнен и продолжится из &lt;code&gt;Enumerator.min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">Если &lt;code&gt;range&lt;/code&gt; имеет длину, то ошибочно передавать значение для &lt;code&gt;start&lt;/code&gt; так что &lt;code&gt;start + range.length&lt;/code&gt; больше, чем &lt;code&gt;Enumerator.max&lt;/code&gt; , таким образом гарантируется, что переполнение не может произойти.</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; и оператор не переполняется, функция возвращает тот же результат, что и встроенный оператор. Во всех остальных случаях возвращает &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rhs&lt;/code&gt; - &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; , возвращает &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; . В противном случае возвращает &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">Если &lt;code&gt;s == 0&lt;/code&gt; , вызов может вернуть любой пустой фрагмент (включая &lt;code&gt;null&lt;/code&gt; ). В противном случае вызов выделяет &lt;code&gt;s&lt;/code&gt; байтов памяти и возвращает выделенный блок, или &lt;code&gt;null&lt;/code&gt; если запрос не может быть удовлетворен.</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">Если &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; , то элементы перемещаются из конца диапазона в слоты для заполнения. В этом случае выполняется абсолютный минимум ходов.</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является шаблоном функции, то есть единственным членом шаблона, и этот элемент является функцией, вернуть этот шаблон.</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Если &lt;code&gt;str&lt;/code&gt; заканчивается &lt;code&gt;delimiter&lt;/code&gt; , то возвращается &lt;code&gt;str&lt;/code&gt; без &lt;code&gt;delimiter&lt;/code&gt; на его конце. Если это делает &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Если &lt;code&gt;str&lt;/code&gt; начинается с &lt;code&gt;delimiter&lt;/code&gt; , возвращается часть &lt;code&gt;str&lt;/code&gt; , следующая за &lt;code&gt;delimiter&lt;/code&gt; . Если &lt;code&gt;str&lt;/code&gt; делает</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">Если &lt;code&gt;sz&lt;/code&gt; равно нулю, память, на которую ссылается p, будет освобождена, как если бы это был вызов &lt;code&gt;free&lt;/code&gt; . Если &lt;code&gt;p&lt;/code&gt; равно &lt;code&gt;null&lt;/code&gt; , новая память будет выделяться через &lt;code&gt;malloc&lt;/code&gt; . Если &lt;code&gt;p&lt;/code&gt; указывает на память, не выделенную из ГХ, или на внутреннюю часть выделенного блока памяти, никакая операция не выполняется, и возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">Если &lt;code&gt;ticksPerSec&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; , то &lt;code&gt;TickDuration&lt;/code&gt; не удалось получить значение &lt;code&gt;ticksPerSec&lt;/code&gt; в текущей системе, и &lt;code&gt;TickDuration&lt;/code&gt; не будет работать. Это было бы очень ненормально, хотя.</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">Если &lt;code&gt;timeval.tv_sec&lt;/code&gt; - это int, а результат не может поместиться в int, то для &lt;code&gt;tv_sec&lt;/code&gt; будет использовано самое близкое значение, которое может храниться в 32 битах . (поэтому &lt;code&gt;int.max&lt;/code&gt; , если он переходит, и &lt;code&gt;int.min&lt;/code&gt; , если он переходит).</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Если &lt;code&gt;toHash&lt;/code&gt; должен постоянно иметь одинаковое значение, когда &lt;code&gt;opEquals&lt;/code&gt; возвращает true. Другими словами, два объекта, которые считаются равными, всегда должны иметь одинаковое значение хеш-функции. В противном случае произойдет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Если &lt;code&gt;toHash&lt;/code&gt; должен постоянно иметь одинаковое значение, когда &lt;code&gt;opEquals&lt;/code&gt; возвращает true. Другими словами, две структуры, которые считаются равными, всегда должны иметь одинаковое значение хеш-функции. В противном случае произойдет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">Если преобразование B в A является конверсионным,требующим корректировки смещения,то все возвращаемые выражения должны быть скорректированы на возвращаемые выражения,набранные A.</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">Если значение JSON равно нулю, то оператор инициализирует его объектом, а затем устанавливает для него &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Если Source является &lt;code&gt;struct&lt;/code&gt; то упаковка / развертывание создаст копию; невозможно повлиять на исходную &lt;code&gt;struct&lt;/code&gt; через оболочку.</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">Если заявление</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Если у Targets есть только одна запись, а Source является классом, который явно ее реализует, wrap просто возвращает src, переданный в &lt;code&gt;Targets[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">Если предоставляется &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; , поля инициализируются синтаксисом &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">Если a и b являются объектами обоих классов,то выражение переписывается как:</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Если запрашивается приведение к типу с плавающей точкой, и &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;onBadCast&lt;/code&gt; , приведение проверяется, проверяя &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; . Если это не &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Если запрашивается приведение к целочисленному типу, и &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;onBadCast&lt;/code&gt; , приведение проверяется, проверяя, чтобы &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;cast(U) get&lt;/code&gt; были одним и тем же арифметическим числом. (Обратите внимание , что &lt;code&gt;int(-1)&lt;/code&gt; и &lt;code&gt;uint(1)&lt;/code&gt; разные значения арифметически , хотя они имеют такое же представление побитовое и сравнение равных по правилам языка.) Если числа не равны арифметически, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; возвращается ,</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">Если тип возврата выбора является недействительным,то выбор должен бросить исключение,если только все варианты не являются недействительными.В этом случае сам переключатель castSwitch вернет пустоту.</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">Если код конструктора содержит вызов конструктора делегата,то все возможные пути выполнения через конструктор должны выполнить ровно один вызов конструктора делегата:</target>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">Если определен конструктор копирования,то неявные обращения к нему будут вставляться в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">Если за объявлением следует документированный юнит-тест, код в юнит-тесте будет вставлен в &lt;b&gt;пример&lt;/b&gt; раздела объявления:</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">Если декларация начинается с</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">Если делегат пропущен, безопасность и чистота этой функции выводятся из безопасности и чистоты &lt;code&gt;Dg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">Если делегат, который принимает &lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt; , включен в качестве последнего &lt;code&gt;receive&lt;/code&gt; аргумента , он будет соответствовать любому сообщению, которое не было сопоставлено более ранним делегатом. Если отправлено более одного аргумента, &lt;code&gt;Variant&lt;/code&gt; будет содержать &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; всех отправленных значений.</target>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">Если делегирующий конструктор не вызывается,то происходит вызов конструктора базового класса по умолчанию.</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">Если производный класс переопределяет функцию-член базового класса с помощью различных &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt; , недостающие атрибуты будут автоматически компенсированы компилятором.</target>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">Если комментарий к документации для объявления состоит только из идентификатора &lt;code&gt;ditto&lt;/code&gt; , то к этой декларации также применяется комментарий к документации для предыдущего объявления в той же области действия объявления.</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">Если тип поля имеет отключенную конструкцию по умолчанию,то он должен быть инициализирован в конструкторе.</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">Если плавающий литерал имеет &lt;b&gt;. &lt;/b&gt;и суффикс типа, между ними должна быть хотя бы одна цифра:</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">Если за плавающим литералом следует &lt;b&gt;i&lt;/b&gt; , то это</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">Если функция пытается проверить себя на наличие этих атрибутов,то предполагается,что она не имеет этих атрибутов.</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">Если вызов функции не передает явного аргумента, т. Е. Он синтаксически использует &lt;code&gt;()&lt;/code&gt; , то эти скобки могут быть опущены, аналогично вызову метода получения &lt;a href=&quot;#property-functions&quot;&gt;функции свойства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">Если функция в производном классе отменяет функцию из своего суперкласса, то только один из &lt;code&gt;in&lt;/code&gt; договорах функции и ее базовые функции должны быть удовлетворено. Переопределение функций становится процессом</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">Если функция возвращает делегата или указатель функции,то для вызова возвращаемого значения требуются парантезы.</target>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">Если указана функция с нетиповым параметром,то эта функция вызывается,когда вариант содержит тип,не совпадающий ни с какой другой функцией.Это может быть использовано для применения одной и той же функции к нескольким возможным типам.Допускается только одна общая функция.</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">Если указана функция без параметров, эта функция вызывается, когда &lt;code&gt;variant&lt;/code&gt; не содержит значения. Допускается только одна функция без параметров.</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">Если используется устаревший логический возвращающий пользовательский обработчик, &lt;code&gt;false&lt;/code&gt; отображается на &lt;code&gt;UnitTestResult.fail&lt;/code&gt; , а &lt;code&gt;true&lt;/code&gt; отображается на &lt;code&gt;UnitTestResult.pass&lt;/code&gt; . Это было оригинальное поведение системы модульного тестирования.</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">Если библиотечная подпрограмма не может обработать тип &lt;code&gt;TypedefType&lt;/code&gt; , вы можете использовать шаблон TypedefType для извлечения типа, который упаковывает Typedef .</target>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">Если смесь имеет</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">Если модуль C импортирует модули A и B,любые изменения в B не будут беззвучно изменять код в C,который зависит от A.</target>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Если вложенный класс имеет &lt;code&gt;static&lt;/code&gt; атрибут, он не может получить доступ к переменным окружения, которые являются локальными для стека или нуждаются в &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">Если опция необходима,то если ее не передать,то это приведет к ошибке</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">Если указана функция без параметров, она вызывается, когда любой из &lt;code&gt;variant&lt;/code&gt; не содержит значения или содержит тип, который не обрабатывается посещающими функциями.</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">Если указатель содержит</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">Если функция свойств не имеет параметров,она работает как геттер.Если имеет ровно один параметр,то работает как сеттер.</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">Если имя протокола опущено,то любой протокол будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Если диапазон, возвращаемый &lt;code&gt;map&lt;/code&gt; или &lt;code&gt;asyncBuf&lt;/code&gt; , используется в качестве входных данных для &lt;code&gt;map&lt;/code&gt; , то в качестве оптимизации исключается копирование из выходного буфера первого диапазона во входной буфер второго диапазона, даже если диапазоны возвращаются &lt;code&gt;map&lt;/code&gt; и &lt;code&gt;asyncBuf&lt;/code&gt; . являются диапазонами неслучайного доступа. Это означает, что параметр &lt;code&gt;bufSize&lt;/code&gt; , передаваемый текущему вызову &lt;code&gt;map&lt;/code&gt; , будет игнорироваться, а размер буфера будет равен размеру буфера &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">Если в качестве левой стороны выражения присваивания появляется оператор среза,а тип правой стороны совпадает с типом элемента левой стороны,то содержимое массива левой стороны устанавливается на правую сторону.</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">Если сильно чистая функция бросает исключение или ошибку,предположения,связанные с запоминанием и ссылками,не несут в себе бросаемое исключение.</target>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">Если подвыражение выражения вызывает исключение,то все временные промежутки,созданные до оценки этого подвыражения,будут уничтожены в соответствии с правилами,приведенными выше.Для еще не построенных временных объектов вызовы деструкторов не будут производиться.</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">Если аргумент шаблона соответствует специализированный параметр шаблона, аргумент подогнаны с префиксом &lt;b&gt;H&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">Если шаблон содержит членов,имя которых совпадает с идентификатором шаблона,и если тип или тип параметров этих членов включает,по крайней мере,все параметры шаблона,то предполагается,что на этих членов ссылаются в конкретизации шаблона:</target>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">Если шаблон объявляет ровно один член,а этот член является классом с тем же именем,что и шаблон:</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Если шаблон объявляет ровно один член, и этот член является функцией с тем же именем, что и шаблон, это объявление шаблона функции. В качестве альтернативы, объявление шаблона функции - это объявление функции с &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList,&lt;/i&gt;&lt;/a&gt; непосредственно предшествующим &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;параметрам&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">Если шаблон имеет &lt;a href=&quot;#aliasparameters&quot;&gt;параметр псевдонима шаблона&lt;/a&gt; и создается с локальным символом, созданная функция неявно становится вложенной для доступа к данным времени выполнения данного локального символа.</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">Если шаблон объявлен в совокупности или в локальной области видимости функции,то инстанцированные функции будут неявно захватывать контекст охватывающей области видимости.</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">Если переменная имеет вызов деструктора области видимости,вернитесь к его вызову.В противном случае верните NULL.</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">Если после рассмотрения всех аргументов типов остаются какие-либо параметры типа без присваивания типа,то им присваиваются типы,соответствующие аргументу шаблона,в той же позиции в параметре</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">Если псевдоним одного и того же объекта или оба null =&amp;gt; равны</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;enum&lt;/code&gt; используется в качестве типа, случайная случайная величина обращается с равной вероятностью из любого из возможных значений перечисления &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">Если &lt;code&gt;opCmp&lt;/code&gt; объявление определяет метод opCmp или &lt;code&gt;opEquals&lt;/code&gt; , он будет иметь приоритет перед псевдонимом этого члена. Обратите внимание, что, в отличие от метода &lt;code&gt;opCmp&lt;/code&gt; , метод &lt;code&gt;opEquals&lt;/code&gt; неявно определяется для объявления &lt;code&gt;struct&lt;/code&gt; если пользовательский не указан; это означает, что если псевдоним этот член &lt;code&gt;opEquals&lt;/code&gt; является предпочтительным, он должен быть явно определен:</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">Если приложение должно перераспределить срез без возможности расширения, то возвращается &lt;code&gt;0&lt;/code&gt; . Это происходит, когда слайс ссылается на статический массив, или если другой слайс ссылается на элементы после конца текущего слайса.</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">Если приложению необходимо выполнить собственную обработку любых аргументов, которые &lt;code&gt;getopt&lt;/code&gt; не понял, оно может передать директиву &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; в &lt;code&gt;getopt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">Если перечисление имеет в качестве базового типа один из типов в левом столбце,то оно преобразуется в тип в правом столбце.</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">Если при компиляции программы возникает ошибка,то использование перегрузок и перезагрузок должно быть пересмотрено в соответствующих классах.</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">Если в</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;emptyExceptionMsg&lt;/code&gt; исключение, но оно содержит пустое сообщение, то возвращается emptyExceptionMsg .</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">Если идентичный типа к &lt;code&gt;type&lt;/code&gt; в &lt;code&gt;type.stringtable&lt;/code&gt; , вернуть последнюю. В противном случае добавьте его в &lt;code&gt;type.stringtable&lt;/code&gt; . Некоторые типы не объединяются и возвращаются как есть.</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">Если перегрузка присвоения идентификатора требуется и не существует, автоматически генерируется функция перегрузки присвоения идентификатора типа &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">Если неявное преобразование запрещено таблицей, &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражение&lt;/i&gt;&lt;/a&gt; может быть преобразовано, если:</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">Если индексное выражение может быть переписано с использованием &lt;code&gt;opIndexAssign&lt;/code&gt; или &lt;code&gt;opIndexOpAssign&lt;/code&gt; , они предпочтительнее, чем &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">Если интерфейс имеет &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; класс памяти, то все члены интерфейса являются &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; . Этот класс хранения не наследуется.</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опция привязана к числовому типу,то номер ожидается как следующий опцион,или прямо внутри опции,разделенной знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опцион привязан к строке,то строка ожидается как следующий опцион,или прямо внутри опциона,разделенного знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">Если опция привязана к массиву,то каждый раз при установке опции к массиву добавляется новый элемент:</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опция привязана к ассоциативному массиву,то в качестве следующего варианта ожидается строка вида &quot;name=value&quot;,либо прямо внутри опции,разделенной знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Если опцион привязан к перечислению,символ перечисления в виде строки ожидается как следующий опцион,или прямо внутри опциона,разделенного знаком &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">Если имя опции имеет суффикс &quot;+&quot; и привязано к числовому типу,то значение опции отслеживает количество раз,которое произошло в командной строке:</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">Если за строкой параметра следует другая строка, эта строка служит описанием этой опции. Функция &lt;code&gt;getopt&lt;/code&gt; возвращает структуру типа &lt;code&gt;GetoptResult&lt;/code&gt; . Это возвращаемое значение содержит информацию обо всех переданных параметрах, а также флаг &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; , указывающий, запрашивалась ли информация об этих параметрах. Функция &lt;code&gt;getopt&lt;/code&gt; всегда добавляет опцию &lt;code&gt;--help|-h&lt;/code&gt; чтобы установить флаг, если эта опция видна в командной строке.</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">Если &lt;code&gt;TaskPool&lt;/code&gt; какой-либо TaskPool с потоками, не являющимися демонами, для его &lt;code&gt;finish&lt;/code&gt; необходимо вызвать &lt;code&gt;stop&lt;/code&gt; или finish .</target>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">Если какие-либо поля имеют отключенную конструкцию по умолчанию,то конструкция по умолчанию также отключена.</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">Если какой-либо из &lt;code&gt;lead&lt;/code&gt; и &lt;code&gt;vowel&lt;/code&gt; не является допустимым хангул джамо соответствующего класса &lt;a href=&quot;#Character&quot;&gt;символов,&lt;/a&gt; возвращается dchar.init.</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">Если какой-либо из аргументов в &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; является</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">Если какая-либо из проверок окажется неудачной,произойдет ошибка компиляции.</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">Если какая-либо из клавиш или значений в</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">Если применение вышеуказанных правил не приводит к одному типу для каждого параметра шаблона,то это является ошибкой.</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">Если утверждения включены и &lt;code&gt;toRange&lt;/code&gt; , то этот экземпляр WorkerLocalStorage больше не является локальным для рабочих, и при вызове этого метода возникнет ошибка подтверждения. Это не проверяется, когда утверждения отключены по соображениям производительности.</target>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">Если хотя бы один из диапазонов является мультимножеством, то учитываются все вхождения дублирующего элемента. Результат эквивалентен объединению всех входных диапазонов и выбору самых высоких &lt;code&gt;tgt.length&lt;/code&gt; элементов ранжирования на основе веса.</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">Если аутентификация или переадресация выполнена,то статус будет присвоен последнему полученному ответу.</target>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">Если аргумент блокировки имеет значение true, дождитесь завершения всех рабочих потоков перед возвратом. Эта опция может использоваться в приложениях, где результаты задач никогда не используются - например, когда &lt;code&gt;TaskPool&lt;/code&gt; используется в качестве элементарного планировщика для задач, которые взаимодействуют с помощью средств, отличных от возвращаемых значений.</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Primary&lt;/code&gt; и &lt;code&gt;Fallback&lt;/code&gt; не имеют состояния, &lt;code&gt;FallbackAllocator&lt;/code&gt; определяет статический экземпляр с именем &lt;code&gt;instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">Если и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; являются целыми числами (могут быть сложены в константу), выражение среза можно преобразовать в тип статического массива &lt;code&gt;T[b - a]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">Если и шаблон с параметром последовательности,и шаблон без параметра последовательности точно совпадают по инстанцированности с шаблоном,то шаблон без параметра</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">Если оба распределители являются &lt;code&gt;shared&lt;/code&gt; , тем &lt;code&gt;Segregator&lt;/code&gt; также будет предлагать &lt;code&gt;shared&lt;/code&gt; методы.</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">Если оба типа подписаны или оба не подписаны,то меньший тип преобразуется в больший.</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">Если оба типа одинаковы,преобразование больше не производится.</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">Если оба аргумента являются диапазонами значений L одного и того же типа, то &lt;code&gt;SetSymmetricDifference&lt;/code&gt; также будет диапазоном значений L этого типа.</target>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">Если оба операнда имеют целочисленные типы и в вычислениях возникает переполнение или недостаточное значение, произойдет перенос. То есть &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; и &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">Если оба операнда являются указателями, а оператор &lt;code&gt;+&lt;/code&gt; , то это недопустимо.</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">Если оба операнда являются указателями, а оператор - &lt;code&gt;-&lt;/code&gt; , указатели вычитаются, а результат делится на размер типа, на который указывают операнды. В этом расчете предполагаемый размер &lt;code&gt;void&lt;/code&gt; составляет один байт. Это ошибка, если указатели указывают на разные типы. Тип результата - &lt;code&gt;ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">Если оба диапазона конечны, то один должен быть (как минимум) &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном,&lt;/a&gt; а другой - &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;входным диапазоном&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">Если оба диапазона бесконечны,то оба должны быть прямыми.</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">Если оба диапазона являются наборами (без дублированных элементов), результирующий диапазон будет набором. Если хотя бы один из диапазонов является мультимножеством, число вхождений элемента &lt;code&gt;x&lt;/code&gt; в результирующий диапазон равно &lt;code&gt;abs(a-b)&lt;/code&gt; где &lt;code&gt;a&lt;/code&gt; - это число вхождений &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;r1&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; - количество вхождений &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;r2&lt;/code&gt; . и &lt;code&gt;abs&lt;/code&gt; является абсолютной величиной.</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">Если оба диапазона имеют член длины, эта функция равна &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). В противном случае эта функция равна &amp;Omicron; ( &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">Если и x,и n равны 0,то результат равен 1.Если n равно отрицательному значению,то во время выполнения программы,независимо от значения x,возникнет целочисленная ошибка деления.</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">Если за перерывом следует</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">Если включена проверка инварианта класса,то в конце конструктора вызывается инвариант класса.</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">Если код обнаруживает ошибку типа &amp;laquo;недостаточно памяти&amp;raquo;, выдается ошибка с сообщением &amp;laquo;недостаточно памяти&amp;raquo;. Стек вызова функции разматывается, ищется обработчик для ошибки. &lt;a href=&quot;statement#TryStatement&quot;&gt;Наконец блоки&lt;/a&gt; выполняются, так как стек разматывается. Если обработчик ошибок найден, выполнение возобновляется там. Если нет, то запускается обработчик ошибок по умолчанию, который отображает сообщение и завершает работу программы.</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">Если за продолжением следует</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">Если определена и &lt;code&gt;hookOpCast&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">Если определено, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; используется как инициализатор полезной нагрузки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">Если определено, &lt;code&gt;Hook.max!T&lt;/code&gt; используется в качестве максимального значения полезной нагрузки.</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">Если определено, &lt;code&gt;Hook.min!T&lt;/code&gt; используется в качестве минимального значения полезной нагрузки.</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора, а &lt;code&gt;rhs&lt;/code&gt; - правый операнд) перенаправляется безоговорочно для бинарных операторов &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора, а &lt;code&gt;lhs&lt;/code&gt; - левый операнд) безоговорочно перенаправляется в двоичные операторы &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; направляется безусловно , когда полезная нагрузка должна быть преобразованный к типу &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; перенаправляется безоговорочно при сравнении полезной нагрузки для упорядочения со значением &lt;code&gt;rhs&lt;/code&gt; целого, с плавающей запятой или логического типа.</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; перенаправляется безоговорочно при сравнении полезной нагрузки на равенство со значением &lt;code&gt;rhs&lt;/code&gt; целого, с плавающей запятой или логического типа.</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора, а &lt;code&gt;rhs&lt;/code&gt; - правый операнд) перенаправляется в безусловно для бинарных операторов &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (где &lt;code&gt;op&lt;/code&gt; - символ оператора) пересылается для унарных операторов &lt;code&gt;-&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; . Кроме того, для одинарных операторов &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; Называется, где &lt;code&gt;payload&lt;/code&gt; представляет собой ссылку на значение обернуто &lt;code&gt;Checked&lt;/code&gt; так крюк может изменить его.</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (где &lt;code&gt;payload&lt;/code&gt; является ссылкой на значение, заключенное в Checked) пересылается при &lt;code&gt;toHash&lt;/code&gt; для типа Checked. Пользовательское хеширование может быть реализовано в &lt;code&gt;Hook&lt;/code&gt; , в противном случае используется встроенное хеширование.</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (где &lt;code&gt;value&lt;/code&gt; - это присваиваемое значение) пересылается, когда результат двоичных операторов &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; меньше , чем наименьшее значение , представимых &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; перенаправляется для унарных операторов, которые переполняются, но только если не определено &lt;code&gt;hookOpUnary&lt;/code&gt; . Унарный &lt;code&gt;~&lt;/code&gt; не переполняется; unary &lt;code&gt;-&lt;/code&gt; переполняется только тогда, когда отрицательное значение самого отрицательного типа отрицается, и возвращается результат вызова ловушки. Когда операторы увеличения или уменьшения переполняются, полезная нагрузка присваивается результат &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; . Когда двоичный оператор переполняется, &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; результат hook.onOverflow! Op (get, rhs) , но только если &lt;code&gt;Hook&lt;/code&gt; не определяет &lt;code&gt;hookOpBinary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если определено, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (где &lt;code&gt;value&lt;/code&gt; - это присваиваемое значение) пересылается, когда результат двоичных операторов &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; больше , чем наибольшее значение , представимых &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">Если e-это SliceExp,постоянно складывайте его.</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">Если e1 является функцией свойств (шаблоном),разрешите его.</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">Если один из них равен нулю =&amp;gt; не равен</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">Если один из операндов &lt;code&gt;real&lt;/code&gt; , другой операнд преобразуется в &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Если один из операндов является типом с плавающей запятой, другой неявно преобразуется в тип с плавающей запятой, и они приводятся к общему типу с помощью обычных &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;арифметических преобразований&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">Если второе или третье выражение имеет тип &lt;code&gt;void&lt;/code&gt; , то результирующий тип будет &lt;code&gt;void&lt;/code&gt; . В противном случае второе и третье выражения неявно преобразуются в общий тип, который становится типом результата условного выражения.</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">Если выражение может быть проверено на истинность или ложь,возвращает измененное выражение.В противном случае возвращает ErrorExp.</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">Если выражение является общим,проверьте,что мы можем получить к нему доступ.Если нет,то дайте сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">Если флаг &lt;code&gt;KeepTerminator&lt;/code&gt; установлен в &lt;code&gt;KeepTerminator.yes&lt;/code&gt; , то разделитель включается в возвращаемые строки.</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">Если найдено,верните запись в списке,что она есть,иначе-ноль.</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Если func когда-либо генерирует точку времени, большую или равную текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">Если func когда-либо генерирует точку времени, большую или равную текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; . Диапазон будет пуст и итерация будет завершена, когда func сгенерирует момент времени, равный или меньший, чем &lt;code&gt;begin&lt;/code&gt; интервала.</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Если func когда-либо генерирует момент времени, меньший или равный текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">Если func когда-либо генерирует момент времени, меньший или равный текущему &lt;code&gt;front&lt;/code&gt; диапазона, то будет выброшено &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; . Диапазон будет пустым, и итерация будет завершена, когда func сгенерирует момент времени, равный или превышающий &lt;code&gt;end&lt;/code&gt; интервала.</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">Если func сохраняет состояние, которое изменяется, как он называется, то некоторые алгоритмы не будут работать правильно, потому что при &lt;code&gt;save&lt;/code&gt; диапазона не удалось реально сохранить состояние диапазона. Чтобы избежать таких ошибок, не передавайте делегату, который не является логически чистым, &lt;code&gt;fwdRange&lt;/code&gt; . Если func задан один и тот же момент времени с двумя разными вызовами, он должен возвращать один и тот же результат оба раза. Конечно, ни одна из функций в этом модуле не имеет этой проблемы, так что это относится только к пользовательским делегатам.</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">Если func сохраняет состояние, которое изменяется, как он называется, то некоторые алгоритмы не будут работать правильно, потому что при &lt;code&gt;save&lt;/code&gt; диапазона не удалось реально сохранить состояние диапазона. Чтобы избежать таких ошибок, не передавайте делегату, который не является логически чистым, &lt;code&gt;fwdRange&lt;/code&gt; . Если func задан один и тот же момент времени с двумя разными вызовами, он должен возвращать один и тот же результат оба раза. Конечно, ни одна из функций в этом модуле не имеет этой проблемы, поэтому это актуально только при создании пользовательского делегата.</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">Если функция выполняется в базовом классе,верните этот базовый класс.</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">Если в цитируемом поле какая-либо цитата сама по себе,а не в конце поля,то обработка для этого поля закончится.</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">Если &lt;code&gt;No.multiblock&lt;/code&gt; экземпляр No.multiblock , он выполняет поиск первого нулевого бита в битовой карте и устанавливает его.</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">Если isNested()возвращает true,то isThis()должна возвращать false,если только функции не нужен указатель двойного контекста.</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Если оно &lt;code&gt;false&lt;/code&gt; , то вычисляется третье выражение, и его результат является результатом условного выражения.</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Если оно &lt;code&gt;true&lt;/code&gt; , то вычисляется второе выражение, а его результат является результатом условного выражения.</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">Если желательно сохранить &lt;code&gt;Unique!T&lt;/code&gt; за пределами его первоначального объема, его можно перенести. Передача может быть явной при вызове &lt;code&gt;release&lt;/code&gt; или неявной при возврате Unique из функции. Ресурс &lt;code&gt;T&lt;/code&gt; может быть полиморфным объектом класса или экземпляром интерфейса, и в этом случае Unique также ведет себя полиморфно.</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">Если задан только тип T и переменной v нет,то выражение catch все равно выполняется.</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">Если несколько шаблонов с одним и тем же</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">Если &lt;code&gt;delimiter&lt;/code&gt; не указан, то один завершающий символ &lt;code&gt;'\r'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; , &lt;code&gt;'\f'&lt;/code&gt; , &lt;code&gt;'\v'&lt;/code&gt; , &lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt; удаляется с конца &lt;code&gt;str&lt;/code&gt; . Если &lt;code&gt;str&lt;/code&gt; не заканчивается ни одним из этих символов, он возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">Если &lt;code&gt;needle&lt;/code&gt; не указана , &lt;code&gt;pred(haystack.front)&lt;/code&gt; будет оцениваться для каждого элемента входного диапазона.</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">Если в конструкторе нет вызова конструкторов с помощью &lt;code&gt;this&lt;/code&gt; или &lt;code&gt;super&lt;/code&gt; , и в базовом классе есть конструктор, вызов &lt;code&gt;super()&lt;/code&gt; вставляется в начало конструктора.</target>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">Если для ошибок нет обработчиков catch,то программа изящно завершает свою работу через обработчик ошибок по умолчанию с соответствующим сообщением.</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">Если циклы не найдены,то для сохранения старого некорректного поведения при упорядочивании,ctors и tlsctors заменяются на сгенерированные этим алгоритмом.</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Если данные недоступны и основной поток обращается к диапазону, он блокируется, пока данные не станут доступными. Исключением является метод &lt;code&gt;wait(Duration)&lt;/code&gt; в &lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; &lt;/a&gt; . Этот метод будет ожидать максимум в течение указанной продолжительности и вернет true, если данные доступны.</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Если данные недоступны и основной поток обращается к диапазону, который он блокирует, пока данные не станут доступными. Исключением является метод &lt;code&gt;wait(Duration)&lt;/code&gt; в &lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; &lt;/a&gt; . Этот метод будет ожидать максимум в течение указанной продолжительности и вернет true, если данные доступны.</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">При отсутствии явного посевного материала в качестве посевного материала используется первый элемент каждой рабочей единицы.Для окончательного уменьшения,в качестве посевного материала используется результат первого рабочего элемента.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">Если не указана функция для вызова, &lt;code&gt;each&lt;/code&gt; умолчанию не делает ничего, кроме использования всего диапазона. Будет оценен &lt;code&gt;r.front&lt;/code&gt; , но этого можно избежать, указав лямбду с параметром &lt;code&gt;lazy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">Если иглы не предусмотрено, &lt;code&gt;haystack&lt;/code&gt; продвигается до тех пор, пока &lt;code&gt;pred&lt;/code&gt; оценивается как &lt;code&gt;true&lt;/code&gt; . Точно так же стог сена позиционируется так, что &lt;code&gt;pred&lt;/code&gt; оценивается как &lt;code&gt;false&lt;/code&gt; для &lt;code&gt;haystack.front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">Если генератор случайных чисел не передается в &lt;code&gt;randomCover&lt;/code&gt; , то глобальный поток RNG rndGen будет использоваться внутри.</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Если разделитель не передан, предикат &lt;code&gt;isTerminator&lt;/code&gt; решает, принимать ли элемент &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">Если никакие пользовательские обработчики юнит-тестов не зарегистрированы, выполняется следующий алгоритм (на поведение может повлиять переключатель ниже &lt;code&gt;--DRT-testmode&lt;/code&gt; ): 1. Запустите все юнит-тесты, отслеживание выполненных тестов и прохождение. Для каждого сбоя выведите трассировку стека и продолжите. 2. Если сбоев нет, установите флаг суммирования в значение false, а флаг runMain в значение true. 3. Если есть ошибки, установите флаг суммирования на true, а флаг runMain на false.</target>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">Если результат не нулевой,префикс с 0x (0X).</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">Если ни одно из регистровых выражений не совпадает,а есть оператор по умолчанию,то оператор по умолчанию передается.</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">Если ни один из вариантов не совпадает, &lt;code&gt;SwitchError&lt;/code&gt; . &lt;code&gt;SwitchError&lt;/code&gt; также будет сгенерирован , если не все варианты являются недействительными и выбор void был выполнен, не выдавая ничего.</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">Если не указано,то</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">Если один из них лучше другого,или один компилируется,а другой нет,выбирается первый.</target>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">Если один из аргументов-NaN,возвращается другой.</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">Если одно из чисел является целым числом, а другое - числом с плавающей запятой, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; тогда и только тогда, когда интеграл может быть точно (без аппроксимации) преобразован в число с плавающей запятой. Это делается для того, чтобы сохранить транзитивность равенства: если &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; и &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; то &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; , если &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; - это сочетание целых чисел и чисел с плавающей точкой ,</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Если одно из чисел является целым числом, а другое - числом с плавающей запятой, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; возвращает число с плавающей запятой, равное &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;x &amp;lt; y&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , если &lt;code&gt;x == y&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , если &lt;code&gt;x &amp;gt; y&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; , если число с плавающей запятой равно &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">Если один операнд является перечислением,а другой-базовым типом этого перечисления,то в результате получается базовый тип.</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">Если один или оба типа операндов являются перечислением после прохождения вышеописанных преобразований,то типом результата является тип результата:</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">Если один или оба операнда имеют плавающую точку,то выполняется сравнение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">Если один диапазон бесконечен,а другой конечный,то конечный диапазон должен быть прямым,а бесконечный диапазон может быть входным.</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">Если для &lt;code&gt;Chain&lt;/code&gt; или &lt;code&gt;chain&lt;/code&gt; предлагается только один диапазон , то тип &lt;code&gt;Chain&lt;/code&gt; выходит за пределы изображения, совмещая себя непосредственно с типом этого диапазона.</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Если передан только один тип, то массив этого типа. В противном случае массив &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">Если операнды являются интегральными типами</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если требуется перекрытие, используйте &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Если переопределить &lt;code&gt;Object.opEquals()&lt;/code&gt; для классов, подпись функции-члена класса должна выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Если переопределить &lt;code&gt;Object.opCmp()&lt;/code&gt; для классов, подпись функции-члена класса должна выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">Если p равен нулю,операция не выполняется.</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">Если paramsym равен нулю,вместо paramsym используется новый ScopeDsymbol.</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">Если передается в диапазоне кодовых точек,возвращает диапазон с эквивалентными возможностями.</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">Если указатели на выделенную память мусорщика D передаются в функции С,то крайне важно убедиться,что память не будет собрана мусорщиком до того,как функция С будет с ней закончена.Этого можно добиться:</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">Если указатели на память,выделенную на куче мусора в сборщике мусора D,передаются в функции С++,то крайне важно,чтобы эта память не была собрана сборщиком мусора в D до того,как с ней будет закончена работа функции С++.Этого можно добиться:</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">Если возможно,преобразовать инициализатор массива в инициализатор ассоциативного массива.</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">Если присутствует,то</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">Если диапазон - это диапазон байтов, &lt;code&gt;Encoder&lt;/code&gt; который перебирает байты соответствующей кодировки Base64. Если диапазон - это диапазон диапазонов байтов, &lt;code&gt;Encoder&lt;/code&gt; который выполняет итерацию по кодированным в Base64 строкам каждого элемента диапазона. В обоих случаях возвращаемый &lt;code&gt;Encoder&lt;/code&gt; будет &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном,&lt;/a&gt; если данный &lt;code&gt;range&lt;/code&gt; является по крайней мере прямым диапазоном, в противном случае это будет только входной диапазон.</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">Если диапазон - это диапазон символов, то &lt;code&gt;Decoder&lt;/code&gt; выполняет итерации по байтам соответствующего декодирования Base64. Если диапазон - это диапазон диапазонов символов, то &lt;code&gt;Decoder&lt;/code&gt; выполняет итерацию по декодированным строкам, соответствующим каждому элементу диапазона. В этом случае длина каждого поддиапазона должна быть кратна 4; возвращенный декодер не отслеживает состояние декодирования Base64 через границы поддиапазона. В обоих случаях возвращенный &lt;code&gt;Decoder&lt;/code&gt; будет &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном,&lt;/a&gt; если данный &lt;code&gt;range&lt;/code&gt; является, по крайней мере, прямым диапазоном, в противном случае это будет только входной диапазон. Если входные данные содержат символы, которых нет в базовом алфавите текущей схемы кодирования Base64, возвращаемый диапазон может выдать &lt;code&gt;Base64Exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">Если точно такой же тип =&amp;gt; один вызов метода opEquals</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">Если установлено во время выполнения, &lt;code&gt;min&lt;/code&gt; и / или &lt;code&gt;max&lt;/code&gt; должны быть соответственно инициализированы.</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">Если установлено во время выполнения, &lt;code&gt;min&lt;/code&gt; и / или &lt;code&gt;max&lt;/code&gt; должны быть соответственно инициализированы. Блок должен быть выделен с помощью этого списка, и между распределением и освобождением не должно происходить динамического изменения &lt;code&gt;min&lt;/code&gt; или &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">Если установлено значение &lt;code&gt;AllowDayOverflow.no&lt;/code&gt; , переполнение дня не допускается.</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">Если установлено значение &lt;code&gt;AutoStart.no&lt;/code&gt; , то StopWatch не запускается при его создании.</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">Если установлено &lt;code&gt;AutoStart.no&lt;/code&gt; , то секундомер не запускается при его создании.</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">Если установлено значение &lt;code&gt;CheckDns.no&lt;/code&gt; , isEmail не выполняет проверку DNS.</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">Если установлено значение &lt;code&gt;OpenRight.yes&lt;/code&gt; , то интервал открывается справа (последний элемент не включен).</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">Если установлено значение &lt;code&gt;PopFirst.no&lt;/code&gt; , то popFront не вызывается перед возвратом диапазона.</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">Если установлено значение &lt;code&gt;SortOutput.no&lt;/code&gt; , выходные данные не должны быть отсортированы.</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">Если установлено, 0 является единственным допустимым &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;денормализованным&lt;/a&gt; числом IEEE754 . Требуются allowDenorm и storeNormalized.</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">Если установлено, выберите смещение экспоненты так, чтобы max_exp = 1., т.е. чтобы максимальное значение было&amp;gt; = 1.0 и &amp;lt;2.0. Игнорируется, если смещение показателя указано вручную.</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">Если установлено,то беззнаковые пользовательские поплавки считаются отрицательными.</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">Если зависимости размера неизбежны, поместите в код &lt;code&gt;static assert&lt;/code&gt; чтобы проверить это:</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">Если некоторые из этих полей не NULL,то это указатель на b_data.</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Если у источника есть внутренние указатели,указывающие на себя и не определяющие opPostMove,его нельзя перемещать,и он вызовет сбой утверждения.</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Если у источника есть внутренние указатели,указывающие на него самого,то его нельзя перемещать,и это вызовет сбой в утверждении.</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">Если необходимо разбить строку на пустое пространство и сжать токены, рассмотрите возможность использования &lt;code&gt;splitter&lt;/code&gt; без указания разделителя.</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">Если разрешено разделение передачи данных,то этот обратный вызов вызывается после завершения загрузки отдельного фрагмента.Примечание! После установки этого обратного вызова,он должен быть вызван для ВСЕХ блоков.Даже если загрузка этого фрагмента была пропущена в CHUNK_BGN_FUNC.По этой причине нам не нужен параметр &quot;transfer_info&quot; в этом обратном вызове,и нам не интересен параметр &quot;remains&quot;.</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">Если операторы обеспечивают простое условное выполнение операторов.</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">Если конструктор структуры аннотирован &lt;code&gt;@disable&lt;/code&gt; и имеет пустой &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; , структура отключила конструкцию по умолчанию. Единственный способ, которым он может быть построен, - это вызов другого конструктора с непустым</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">Если включена проверка инварианта структуры,то инвариант структуры вызывается в конце конструктора.</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">Если структуры объявляют &lt;code&gt;opCmp&lt;/code&gt; член opCmp , она должна иметь следующую форму:</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">Если структуры объявляют &lt;code&gt;opEquals&lt;/code&gt; член opEquals для сравнения идентификаторов, она может иметь несколько форм, таких как:</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">Если такое совпадение имеет место,то аут считается общим классификатором совпавших классификаторов.Если существует более двух параметров,то вычисление общего классификатора применяется рекурсивно.</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">Если такой</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">Если параметры шаблонного типа совпадают с литеральными выражениями на аргументах функции,то выведенные типы могут рассмотреть возможность их сужения.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">Если исходный файл .d начинается со строки &quot;Ddoc&quot;,то он рассматривается как документация общего назначения,а не как файл исходного кода D.Сразу после строки &quot;Ddoc&quot; до конца файла или любой секции &quot;Macros:&quot; формируется документ.Никакая автоматическая подсветка этого текста не производится,кроме подсветки кода D,встроенного между строками,очерченными строками ---.Осуществляется только обработка макросов.</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">Если &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Условие&lt;/i&gt;&lt;/a&gt; выполнено, то следующее</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">Если в &lt;code&gt;config&lt;/code&gt; установлен флаг &lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; &lt;/a&gt; , дочерний процесс будет</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">Если &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; имеет длину одного токена, круглые скобки могут быть опущены:</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">Если &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; пуст, экземпляр структуры инициализируется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Если объект &lt;code&gt;BitmappedBlock&lt;/code&gt; пуст (не имеет активного выделения), выделяет всю память внутри и возвращает ему фрагмент. В противном случае возвращает &lt;code&gt;null&lt;/code&gt; (т. Е. Не делается попытка выделить самый большой доступный блок).</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">Если &lt;code&gt;FileLogger&lt;/code&gt; управляет &lt;code&gt;File&lt;/code&gt; он входит, этот метод возвращает ссылку на этот файл.</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;FileLogger&lt;/code&gt; был создан с именем файла, этот метод возвращает это имя файла. В противном случае возвращается пустая &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Если объект &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; пуст (не имеет активного выделения), выделяет всю память внутри и возвращает ему фрагмент. В противном случае возвращает &lt;code&gt;null&lt;/code&gt; (т. Е. Не делается попытка выделить самый большой доступный блок).</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Если &lt;code&gt;Task&lt;/code&gt; еще не запущена, выполните ее в текущем потоке. Если это сделано, вернуть его возвращаемое значение, если таковое имеется. Если он выполняется, вращение занято до тех пор, пока оно не будет выполнено, а затем верните возвращаемое значение. Если это вызвало исключение, сбросьте это исключение.</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Если &lt;code&gt;Task&lt;/code&gt; еще не запущена, выполните ее в текущем потоке. Если это сделано, вернуть его возвращаемое значение, если таковое имеется. Если это происходит, дождитесь условной переменной. Если это вызвало исключение, сбросьте это исключение.</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">Если &lt;code&gt;VariantN&lt;/code&gt; содержит (ассоциативный) массив, возвращает длину этого массива. В противном случае выдает исключение.</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">Если &lt;code&gt;VariantN&lt;/code&gt; содержит массив, по очереди применяет &lt;code&gt;dg&lt;/code&gt; к каждому элементу массива. В противном случае выдает исключение.</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">Если объект &lt;code&gt;VariantN&lt;/code&gt; содержит значение</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">Если используется форма &lt;code&gt;[ ]&lt;/code&gt; , срез занимает весь массив.</target>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">Если используется CURLOPT_INFILE,то это может быть использовано для информирования libcurl о том,насколько большой на самом деле отправляемый файл.Это позволяет лучше проверять ошибки и лучше проверять,что загрузка прошла успешно.-1 означает неизвестный размер.</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">Если UDA является типом,то любые UDA того же типа на символе будут совпадать.Если UDA является шаблоном для типа,то любая UDA,которая является инстанцией этого шаблона,будет соответствовать.А если UDA-это значение,то будут совпадать любые UDA на символе,которые равны этому значению.</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">Если [EBP] опущен, он предполагается для локальных переменных. Если используется &lt;code&gt;naked&lt;/code&gt; , это больше не имеет места.</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">Если агрегированное выражение является последовательностью,то могут быть объявлены один или два итерационных символа.Если один,то символ является</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">Если агрегатное выражение является статическим или динамическим массивом &lt;code&gt;char&lt;/code&gt; s, &lt;code&gt;wchar&lt;/code&gt; s или &lt;code&gt;dchar&lt;/code&gt; s, то</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">Если агрегатное выражение является объектом структуры или класса, но &lt;code&gt;opApply&lt;/code&gt; для &lt;code&gt;foreach&lt;/code&gt; или &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;code&gt;foreach_reverse&lt;/code&gt; не существует, то итерация по объектам структуры и класса может выполняться с помощью примитивов диапазона. Для &lt;code&gt;foreach&lt;/code&gt; это означает, что должны быть определены следующие свойства и методы:</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">Если статистическое выражение является объектом структуры или класса, &lt;code&gt;foreach&lt;/code&gt; определяется специальной &lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt; членом &lt;span id=&quot;opApply&quot;&gt;opApply&lt;/span&gt; , а поведение &lt;code&gt;foreach_reverse&lt;/code&gt; определяется специальной &lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt; членом &lt;span id=&quot;opApplyReverse&quot;&gt;opApplyReverse&lt;/span&gt; . Эти функции имеют тип:</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Если агрегированное выражение является ассоциативным массивом,то могут быть объявлены одна или две переменные.Если одна,то переменная объявляется как</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Если агрегат является статическим или динамическим массивом,то могут быть объявлены одна или две переменные.Если одна,то переменная объявляется как</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">Если аргументом является CommaExp,установите флаг,чтобы предотвратить сообщения об обесценивании</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">Если аргумент опущен,это означает,что по умолчанию построен скалярный тип:</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Если все аргументы являются либо типами, являющимися абстрактными классами, либо выражениями, которые типизированы как абстрактные классы, возвращается значение &lt;code&gt;true&lt;/code&gt; . В противном случае возвращается &lt;code&gt;false&lt;/code&gt; . Если аргументов нет, возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Если все аргументы являются либо типами, являющимися арифметическими типами, либо выражениями, которые типизируются как арифметические типы, возвращается значение &lt;code&gt;true&lt;/code&gt; . В противном случае возвращается &lt;code&gt;false&lt;/code&gt; . Если аргументов нет, возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">Если назначенный тип значения &lt;b&gt;не&lt;/b&gt; эквивалентен типу элемента AA, выражение может вызвать перегрузку оператора с обычным доступом к индексированию:</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">Если присвоенный тип значения эквивалентен типу элемента AA:</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">Если проверка границ в &lt;code&gt;@system&lt;/code&gt; или &lt;code&gt;@trusted&lt;/code&gt; отключена, правильность кода все равно должна быть гарантирована автором кода.</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">Если обратный вызов не принимает никаких аргументов,то он вызывается всякий раз,когда появляется опция.</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">Если обратный вызов принимает один строковый аргумент,то строка опций (без ведущего тире (тире))передается обратному вызову.После этого строка опций считается обработанной и удаляется из массива опций.</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">Если обратный вызов принимает два строковых аргумента,то строка-опция обрабатывается как опция с одним аргументом и разбирается соответственно.Опция и ее значение передаются обратному вызову.После этого,все,что было передано обратному вызову,считается обработанным и удаляется из списка.</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">Если вызывающий абонент является Fiber и не является Generator,то эта функция будет вызывать scheduler.yield()или Fiber.yield(),соответственно.</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">Если вызывающий абонент является абонентом по расписанию,это приводит к выполнению другого абонента по расписанию.</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">Если емкость увеличена,следует предположить,что все итераторы к элементам недействительны.</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">Если объем управляемой памяти велик, может быть желательно переключить управление на свободный список с самого начала. Таким образом, память может использоваться более компактно, чем режим области. Чтобы &lt;code&gt;switchToFreeList&lt;/code&gt; режим свободного списка, вызовите switchToFreeList вскоре после создания или, когда это будет сочтено целесообразным.</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">Если соединение идет слишком быстро,то нужно его замедлить.</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">Если конструктор может создать уникальный объект (например, если он &lt;code&gt;pure&lt;/code&gt; ), объект может быть неявно преобразован в любые квалификаторы.</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">Если конструктор может создать уникальный объект (т. Е. Если он &lt;code&gt;pure&lt;/code&gt; ), этот объект неявно преобразуется в любые квалификаторы.</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">Если текущий счет равен нулю,вернитесь.В противном случае,атоматически уменьшайте счет на единицу и возвращайте true.</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">Если объявление отключено, но внутри отключенной функции, возвращает &lt;code&gt;true&lt;/code&gt; , но не выдает сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">Если задано значение по умолчанию для какого-либо параметра,то все следующие параметры также должны иметь значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">Если разделитель-это идентификатор,то за ним должна немедленно следовать новая строка,а совпадающий разделитель-это тот же самый идентификатор,начинающийся в начале строки:</target>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">Если документация функции-члена контейнера принимает параметр типа &lt;code&gt;Range&lt;/code&gt; , то он ссылается на основной тип диапазона этого контейнера. Часто будет использоваться &lt;code&gt;Take!Range&lt;/code&gt; , и в этом случае диапазон относится к диапазону элементов в контейнере. Аргументы этих параметров &lt;b&gt;должны&lt;/b&gt; быть получены из того же экземпляра контейнера, с которым вы работаете. Важно отметить, что многие универсальные алгоритмы диапазона возвращают тот же тип диапазона, что и их входной диапазон.</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">Если в течение &quot;времени низкой скорости&quot; секунд загрузка получает меньше &quot;нижнего предела скорости&quot; байт/секунду,то операции прерываются.Т.е.если у вас довольно высокоскоростное соединение,то вы можете прервать его,если в течение 20 секунд оно составляет менее 2000 байт/сек.</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">Если адрес электронной почты действителен или нет.</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">Если перечислить</target>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">Если выражение является &lt;a href=&quot;function#property-functions&quot;&gt;функцией свойства&lt;/a&gt; , &lt;code&gt;typeof&lt;/code&gt; возвращает тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">Если зарегистрирован расширенный обработчик юниттеста,то эта функция возвращает результат от этого обработчика напрямую.</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если расширение пусто, эта функция эквивалентна &lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">Если поле инициализируется на одном пути,то оно должно быть инициализировано на всех путях.</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">Если тип поля имеет метод &lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt; , он не будет использоваться для инициализации.</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">Если тип поля не изменяется,множественная инициализация будет отклонена.</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">Если файл не открыт, возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае возвращает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">Если файл не открыт, происходит безуспешно. В противном случае возвращает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">Если имя файла модуля является недопустимым именем модуля (например, &lt;code&gt;foo-bar.d&lt;/code&gt; ), вы можете использовать объявление модуля для установки действительного имени модуля:</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">Если файл не был открыт, выполняется безуспешно. В противном случае закрывает файл (вызывая &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt; ), выдавая ошибку. Даже если выдается исключение, после этого объект &lt;code&gt;File&lt;/code&gt; остается пустым. Это отличается от &lt;code&gt;detach&lt;/code&gt; тем, что он всегда закрывает файл; следовательно, все другие объекты &lt;code&gt;File&lt;/code&gt; , ссылающиеся на тот же дескриптор, отныне будут видеть закрытый файл.</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">Если имя файла уже имеет расширение, оно заменяется. Если нет, расширение просто добавляется к имени файла. Включение ведущей точки в &lt;code&gt;ext&lt;/code&gt; необязательно.</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">Если первый</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">Если первая строка начинается с &quot;#!&quot;,то эта строка игнорируется.</target>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Если первый поиск не был успешным, второй выполняется для импорта. На втором этапе поиска унаследованные области игнорируются. Это включает в себя область действия базовых классов и интерфейса (в этом примере импорт &lt;code&gt;BaseClass&lt;/code&gt; будет игнорироваться), а также импорт в смешанном &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">Если режим округления с плавающей запятой изменяется внутри функции,то он должен быть восстановлен до ее выхода.Если это правило нарушается (например,при использовании inline asm),то режим округления,используемый для последующих вычислений,не определен.</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">Если строка формата зафиксирована,то при ее передаче в качестве параметра шаблона проверяется корректность типа параметров на этапе компиляции.Это также может привести к повышению производительности.</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">Если дробная часть x точно равна 0,5,возвращаемое значение округляется от нуля.</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">Если функция передается в виде строки, состояние имеет имя &lt;code&gt;&quot;a&quot;&lt;/code&gt; а индекс с нулем в повторении имеет имя &lt;code&gt;&quot;n&quot;&lt;/code&gt; . Данная строка должна возвращать желаемое значение для &lt;code&gt;a[n]&lt;/code&gt; учетом &lt;code&gt;a[n - 1]&lt;/code&gt; , &lt;code&gt;a[n - 2]&lt;/code&gt; , &lt;code&gt;a[n - 3]&lt;/code&gt; , ..., &lt;code&gt;a[n - stateSize]&lt;/code&gt; . Размер состояния определяется количеством аргументов, переданных при вызове &lt;code&gt;recurrence&lt;/code&gt; . Структура &lt;code&gt;Recurrence&lt;/code&gt; сама заботится об управлении состоянием повторения и его соответствующем смещении.</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">Если функция возвращает &lt;code&gt;void&lt;/code&gt; , а первый параметр - &lt;code&gt;ref&lt;/code&gt; или &lt;code&gt;out&lt;/code&gt; , то все последующие параметры &lt;code&gt;return ref&lt;/code&gt; рассматриваются как назначенные первому параметру для проверки срока службы. &lt;code&gt;this&lt;/code&gt; опорный параметр на структуру нестатических функций члена считаются первым параметром.</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">Если сгенерированный конструктор копирования не сможет проверить тип, он получит атрибут &lt;code&gt;@disable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">Если сгенерированный момент времени когда-либо проходит границу диапазона в правильном направлении, тогда вместо этого будет использоваться край этого диапазона. Итак, если итерация вперед и сгенерированный момент времени находятся за &lt;code&gt;end&lt;/code&gt; интервала , то &lt;code&gt;front&lt;/code&gt; становится &lt;code&gt;end&lt;/code&gt; . Если выполняется итерация в обратном направлении, а сгенерированный момент времени находится перед &lt;code&gt;begin&lt;/code&gt; , то &lt;code&gt;front&lt;/code&gt; становится &lt;code&gt;begin&lt;/code&gt; . В любом случае диапазон будет пустым.</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">Если данный файл является символической ссылкой,то это возвращает атрибуты самой символической ссылки,а не файла,на который она указывает.Если данный файл</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">Если данный заголовок содержит колонки,не найденные во входных данных,то они будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">Если заданный заголовок не совпадает с порядком во входных данных,содержимое вернется в том виде,в котором оно найдено во входных данных.</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">Если куча имеет пространство для роста, вставляет &lt;code&gt;value&lt;/code&gt; в хранилище и возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае, если &lt;code&gt;less(value, front)&lt;/code&gt; , вызывает &lt;code&gt;replaceFront(value)&lt;/code&gt; и возвращает снова значение &lt;code&gt;true&lt;/code&gt; . В противном случае оставляет кучу без изменений и возвращает &lt;code&gt;false&lt;/code&gt; . Этот метод полезен в сценариях, где должны быть собраны наименьшие &lt;code&gt;k&lt;/code&gt; элементов из набора кандидатов.</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">Если клавиша индексирования уже существует в AA,установка выполняет обычное назначение.</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">Если ключ индексирования еще не существует в AA,то будет выделена новая запись AA,и она будет инициализирована присвоенным значением.</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">Если результат с бесконечной точностью соответствует типу результата, верните его и не трогайте &lt;code&gt;overflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">Если инициализатор отсутствует,то неизменяемый может быть инициализирован из соответствующего конструктора:</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">Если входной массив уже действителен,то функция возвращает оригинал,в противном случае она строит новый массив,заменяя все незаконные последовательности на последовательность замены схемы кодирования.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">Если входная строка уже действительна,то эта функция возвращает оригинал,в противном случае она строит новую строку,заменяя все недопустимые последовательности единиц кода на символ замены кодировки,недопустимые последовательности будут заменены на символ замены Юникода (U+FFFD),если в репертуаре символов он содержится,в противном случае недопустимые последовательности будут заменены на символ '?'.</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">Если экземпляр &lt;code&gt;toString&lt;/code&gt; переопределил &lt;code&gt;Object.toString&lt;/code&gt; , он используется.</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">Если инвариант не держится,то программа переходит в недействительное состояние.</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">Если последний параметр шаблона в</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">Если для последнего параметра шаблона установлено значение &lt;code&gt;No.multiblock&lt;/code&gt; , распределитель будет обслуживать только те выделения, которые требуют не более &lt;code&gt;theBlockSize&lt;/code&gt; . &lt;code&gt;BitmappedBlock&lt;/code&gt; имеет специализированную реализацию для моноблочного распределения , что позволяет для выполнения большего, по стоимости не в состоянии выделить более одного блок в то время.</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">Если левый и правый операнды имеют одинаковый тип структуры, а тип структуры имеет &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt; , то операция копирования выполняется так же, как описано в &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">Если левая сторона</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Если левая часть присваивания является операцией среза в экземпляре структуры или класса, ее можно перегрузить, реализовав &lt;code&gt;opIndexAssign&lt;/code&gt; член opIndexAssign, которая принимает возвращаемое значение функции &lt;code&gt;opSlice&lt;/code&gt; в качестве параметра (ов). Выражения вида &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Если левая часть присваивания является индексной операцией над экземпляром структуры или класса, ее можно перегрузить, предоставив &lt;code&gt;opIndexAssign&lt;/code&gt; член opIndexAssign . Выражения вида &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд является &lt;code&gt;false&lt;/code&gt; , то правый операнд оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд имеет значение &lt;code&gt;true&lt;/code&gt; , то правый операнд оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд, преобразованный в тип &lt;code&gt;bool&lt;/code&gt; , оценивается как &lt;code&gt;false&lt;/code&gt; , то правый операнд не оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Если левый операнд, преобразованный в тип &lt;code&gt;bool&lt;/code&gt; , оценивается как &lt;code&gt;true&lt;/code&gt; , то правый операнд не оценивается. Если тип результата</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">Если блокировка удерживается другим вызывающим абонентом,метод возвращается.В противном случае блокировка приобретается,если она еще не удерживается,а внутренний счетчик увеличивается на единицу.</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">Если именующее статический массив или срез, поведение , как описано в &lt;a href=&quot;array#array-copying&quot;&gt;Array , Копирование&lt;/a&gt; и &lt;a href=&quot;array#array-setting&quot;&gt;массива Setting&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">Если lvalue является определяемым пользователем свойством, поведение будет таким, как описано в &lt;a href=&quot;function#property-functions&quot;&gt;функциях свойств&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">Если lvalue является свойством &lt;code&gt;.length&lt;/code&gt; динамического массива, поведение будет таким, как описано в разделе &lt;a href=&quot;array#resize&quot;&gt;Установка длины динамического массива&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">Если член является классом или структурой,то неопределенный поиск будет перенаправлен на</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">Если модификатор &lt;code&gt;'d'&lt;/code&gt; присутствует, то число символов в , &lt;code&gt;to&lt;/code&gt; может быть только &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; . Если модификатор &lt;code&gt;'d'&lt;/code&gt; есть</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">Если нужно удалить некоторые элементы в диапазоне, но не нужно сохранять порядок остальных элементов, вы можете передать &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; для &lt;code&gt;remove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">Если новая длина массива больше,то остаток заполняется инициализатором по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">Если единственный указатель на объект удерживается за пределами этих областей,то коллектор пропустит его и освободит память.</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">Если операнды являются целочисленными значениями, применяются &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычные арифметические преобразования&lt;/a&gt; , чтобы привести их к общему типу перед сравнением. Равенство определяется как совпадение битовых комбинаций общего типа.</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Если операнды имеют целочисленные типы, они подвергаются &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычным арифметическим преобразованиям&lt;/a&gt; , а затем приводятся к общему типу с использованием обычных &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;арифметических преобразований&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">Если операнды являются указателями,то равенство определяется так,как точно совпадают битовые паттерны операндов.</target>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">Если операнды одного типа,результатом будет этот тип.</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">Если операнды ассоциативного оператора+или*являются значениями с плавающей точкой,то выражение не переупорядочивается.</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Если операция приведет к переполнению / переполнению, эта функция вернет &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">Если оператор равен &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , и первый операнд является указателем, а второй является целочисленным типом, результирующий тип является типом первого операнда, а результирующее значение является указателем плюс (или минус) второй операнд умножается на размер типа, на который указывает первый операнд.</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">Если оператор &lt;code&gt;=&lt;/code&gt; , то это простое присваивание. Правый операнд неявно преобразуется в тип левого операнда и присваивается ему.</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">Если опциональный второй</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">Если родительский распределитель &lt;code&gt;Allocator&lt;/code&gt; находится в состоянии, его экземпляр сохраняется как член. В противном случае &lt;code&gt;AffixAllocator&lt;/code&gt; использует &lt;code&gt;Allocator.instance&lt;/code&gt; . В любом случае имя &lt;code&gt;_parent&lt;/code&gt; равномерно используется для доступа к родительскому распределителю.</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">Если переданный буфер не является последним распределением, то &lt;code&gt;delta&lt;/code&gt; может составлять самое большее количество байтов, оставшихся на последней странице. В противном случае мы можем расширить последнее выделение до конца диапазона виртуальных адресов.</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">Если процесс, связанный с &lt;code&gt;pid&lt;/code&gt; , уже завершен, &lt;code&gt;tryWait&lt;/code&gt; имеет тот же эффект, что и &lt;code&gt;wait&lt;/code&gt; . В этом случае он возвращает кортеж, в котором для &lt;code&gt;terminated&lt;/code&gt; поля установлено значение &lt;code&gt;true&lt;/code&gt; , а поле &lt;code&gt;status&lt;/code&gt; имеет ту же интерпретацию, что и возвращаемое значение &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">Если процесс</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">Если процесс уже завершен, эта функция возвращается напрямую. Код выхода кэшируется, поэтому, если wait () вызывается несколько раз на одном и том же &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; ,&lt;/a&gt; он всегда будет возвращать одно и то же значение.</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Если процесс завершается с помощью сигнала, то &lt;code&gt;status&lt;/code&gt; поля возвращаемого значения будет содержать отрицательное число, абсолютное значение которого номер сигнала. (Подробнее см. &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">Если процесс завершается сигналом, эта функция возвращает отрицательное число, абсолютным значением которого является номер сигнала. Поскольку POSIX ограничивает нормальные коды выхода диапазоном 0-255, отрицательное возвращаемое значение всегда будет указывать завершение по сигналу. Сигнальные коды определены в модуле &lt;code&gt;core.sys.posix.signal&lt;/code&gt; (который соответствует заголовку POSIX &lt;code&gt;signal.h&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">Если диапазон уже является лексикографически наибольшей четной перестановкой,то он возвращается к наименьшей четной перестановке и возвращается false.В противном случае возвращается true,а диапазон изменяется на лексикографически следующую четную перестановку.</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">Если диапазон в настоящее время является лексикографически наибольшей перестановкой, он переставляется обратно к наименьшей перестановке, и возвращается ложное значение. В противном случае возвращается true. Таким образом, можно сгенерировать все перестановки диапазона, отсортировав его в соответствии с &lt;code&gt;less&lt;/code&gt; , что приводит к лексикографически наименьшей перестановке, а затем вызывая nextPermutation, пока он не вернет false. Это гарантированно генерирует все различные перестановки диапазона ровно один раз. Если есть</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">Если диапазон заканчивается до &lt;code&gt;n&lt;/code&gt; элементов, &lt;code&gt;take&lt;/code&gt; просто возвращает весь диапазон (в отличие от &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; , что приведет к ошибке подтверждения, если диапазон преждевременно заканчивается):</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">Если диапазоны являются строками, &lt;code&gt;cmp&lt;/code&gt; выполняет UTF-декодирование соответствующим образом и сравнивает диапазоны по одной кодовой точке за раз.</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">При соблюдении вышеперечисленных ограничений генерируется следующий конструктор копирования:</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">Если тип возвращаемого значения - int, а результат не может поместиться в int, то будет использовано ближайшее значение, которое может храниться в 32 битах (например, &lt;code&gt;int.max&lt;/code&gt; , если оно переходит, и &lt;code&gt;int.min&lt;/code&gt; , если оно переходит) , Однако не предпринимается никаких попыток справиться с целочисленным переполнением, если тип возвращаемого значения длинный.</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">Если возвращаемое значение не равно x,то повышается исключение FE_INEXACT.</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">Если правая сторона также является Проверенной,но с другим типом крюка или подложки,крюк и подложка этого Проверенного имеют приоритет.</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">Если длина второго аргумента меньше длины индексируемого диапазона,то бросается исключение.</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">Если вторым символом &lt;code&gt;path&lt;/code&gt; является двоеточие ( &lt;code&gt;':'&lt;/code&gt; ), первый символ интерпретируется как буква диска и должен находиться в диапазоне AZ (без учета регистра).</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">Если второй операнд является указателем, а первый - целочисленным, а оператор - &lt;code&gt;+&lt;/code&gt; , операнды меняются местами и применяется только что описанная арифметика указателя.</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">Если последовательность, заканчивающаяся на &lt;code&gt;startIdx&lt;/code&gt; , не представляет правильно сформированную &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; может быть выдано исключение std.utf.UTFException . &lt;code&gt;cs&lt;/code&gt; указывает, являются ли сравнения чувствительными к регистру.</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">Если последовательность представляет собой</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">Если последовательность, начинающаяся с &lt;code&gt;startIdx&lt;/code&gt; , не представляет правильно сформированную &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; может быть выдано исключение std.utf.UTFException .</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">Если бит знака установлен (то есть &quot;отрицательный&quot;),NAN меньше любого числа;если бит знака не установлен (он &quot;положительный&quot;),NAN больше любого числа;</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">Если подписанный тип больше,чем беззнаковый,то беззнаковый тип преобразуется в подписанный.</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">Если границы среза могут быть известны во время компиляции,то выражение среза неявно преобразуется в l-значение статического массива.Например:</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">Если исходный файл не начинается с BOM,то первый символ должен быть меньше или равен U+0000007F.</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">Если строковые данные имеют кодировку UTF-8 и к ним можно получить прямой доступ,верните указатель на них.Не принимайте прерывание 0.</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">Если строка не содержит амперсанда,будет возвращен оригинал.</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">Если строка не является допустимым адресом IPv4, возвращается &lt;code&gt;ADDR_NONE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">Если строка не будет изменена,будет возвращен оригинал.</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">Если структура определяет метод &lt;b&gt;toString (),&lt;/b&gt; результатом является строка, возвращаемая этой функцией. В противном случае результатом является StructName (поле &lt;sub&gt;0&lt;/sub&gt; , поле &lt;sub&gt;1&lt;/sub&gt; , ...), где поле &lt;sub&gt;n&lt;/sub&gt; - это n-й элемент, отформатированный в формате по умолчанию.</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">Если &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Выражение-&lt;/i&gt;&lt;/a&gt; переключатель имеет тип enum, все элементы enum должны появляться в &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">Если переключатель &lt;code&gt;--DRT-testmode&lt;/code&gt; передается в исполняемый файл, он может иметь одно из 3 значений: 1. &amp;laquo;run-main&amp;raquo;: даже если модульные тесты запущены (и все пройдены), main все еще выполняется. Это в настоящее время по умолчанию. 2. &amp;laquo;test-or-main&amp;raquo;: любые присутствующие модульные тесты приведут к тому, что программа суммирует результаты и завершит работу независимо от результата. Это будет по умолчанию в 2.080. 3. &amp;laquo;только для тестирования&amp;raquo;, среда выполнения всегда суммирует и никогда не запускает main, даже если тесты отсутствуют.</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">Если поток еще не был запущен, возвращает &lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; . В противном случае возвращает результат &lt;code&gt;GetCurrentThreadId&lt;/code&gt; в Windows и &lt;code&gt;pthread_self&lt;/code&gt; в POSIX. Значение уникально для текущего процесса.</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если часовой пояс &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (или считаются эквивалентными &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; разделом 4.3 спецификации), A &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; с UTC смещение &lt;code&gt;0&lt;/code&gt; используется вместо &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; , тогда как &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; использует &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">Если оба аргумента являются лямбда-функциями (или псевдонимами лямбда-функций),то они сравниваются для равенства.Для того,чтобы сравнение было вычислено правильно,для обеих лямбда-функций должны быть выполнены следующие условия:</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">Если два аргумента являются выражениями,состоящими из литералов или перечислений,которые оцениваются до одного и того же значения,то возвращается true.</target>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">Если два операнда разные перечисления,то в результате получается ближайший тип базы,общий для обоих.Ближайший базовый тип означает более короткую последовательность приведений к базовому типу,чтобы получить его от исходного типа.</target>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">Если тип является классом или структурой,возвращает символ для него,иначе-ноль.</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">Если тип литерала функции может быть однозначно определен из ее контекста,то возможен вывод типа параметра.</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">Если специализация по типу зависит от параметра типа,то тип этого параметра устанавливается в качестве соответствующей части аргумента типа.</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">Если union определяет метод &lt;b&gt;toString (),&lt;/b&gt; результатом является строка, возвращаемая из этой функции. В противном случае результатом является имя объединения без его содержимого.</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">Если соединение больше первого поля,остальные биты устанавливаются на 0.</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">Если соединение больше инициализированного поля,остальные биты устанавливаются на 0.</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">Если предоставленный пользователем размер равен нулю или предоставленный пользователем буфер пуст, выдается &lt;code&gt;Exception&lt;/code&gt; . В случае ошибки ввода / вывода выдает &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">Если переменная не существует,она будет создана.Если она уже существует,она будет перезаписана.</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">Если переменной нет в окружении,то функция возвращается успешно,ничего не делая.</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">Если параметр variadic представляет собой массив делегатов без параметров:</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">Если в</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">Если их несколько</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">Если имеется несколько &lt;code&gt;return ref&lt;/code&gt; параметров ref , время жизни возвращаемого значения является наименьшим временем жизни соответствующих аргументов.</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">Если существует несколько UDA в области действия декларации,то они объединяются:</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">Если в функции присутствует несколько прагматических строк,то лексически последняя вступает в силу.</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если аргументов нет, результат &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">Если для символа отсутствуют определяемые пользователем атрибуты,возвращается пустой кортеж.Выражение кортеж может быть превращено в управляемый кортеж:</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">Если объявлены два символа,то первый-это</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">Если есть &lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; , то эти аргументы передаются классу или структуре специфической &lt;a href=&quot;class#allocators&quot;&gt;функции распределителя&lt;/a&gt; после аргумента размера.</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">Если для класса определен конструктор,то вызывается конструктор,соответствующий списку аргументов.</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">Если для структуры определен конструктор,то вызывается конструктор,соответствующий списку аргументов.</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">Если есть &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражение&lt;/i&gt;&lt;/a&gt; , оно должно оцениваться как объект или экземпляр</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">Если существует выходное постусловие (см. &lt;a href=&quot;contracts&quot;&gt;Программирование контракта&lt;/a&gt; ), это постусловие выполняется после вычисления &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражения&lt;/i&gt;&lt;/a&gt; и до фактического возврата из функции.</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">Если существует более чем одна &lt;code&gt;scope&lt;/code&gt; переменная выходит из области видимости в той же точке, то деструкторы вызываются в обратном порядке , что переменные были построены.</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">Если &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; отсутствует и он не первый</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">Если для класса нет конструктора,но есть конструктор для базового класса,то конструктор по умолчанию неявно генерируется с формой:</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">Если нет никакого выражения возврата по умолчанию, и предикат не дает true с любым тестовым выражением - &lt;code&gt;SwitchError&lt;/code&gt; бросается. &lt;code&gt;SwitchError&lt;/code&gt; также генерируется , если выражение возврата void было выполнено, ничего не выбрасывая.</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">Если в документации к декларации нет комментариев,то эта декларация может не появиться на выходе.Чтобы убедиться в том,что она действительно появляется в выводе,поместите для нее пустой комментарий к декларации.</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">Если в строке нет часового пояса, используется &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; . Если часовой пояс &quot;Z&quot;, то используется &lt;code&gt;UTC&lt;/code&gt; . В противном случае используется &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; ,&lt;/a&gt; который соответствует данному смещению от UTC. Чтобы возвращаемый &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; был определенным часовым поясом, передайте этот часовой пояс, и &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; будет преобразован в этот часовой пояс (хотя он все равно будет считываться как любой часовой пояс в его строке).</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">Если для параметра нет типовой специализации,то тип параметра устанавливается в качестве аргумента шаблона.</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Если в анонимном перечислении есть только один член, &lt;code&gt;{ }&lt;/code&gt; можно опустить. Грамматически говоря, это &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">Если нет обработчика для конкретной ошибки,то он обрабатывается обработчиком по умолчанию библиотеки runtime.Если ошибка игнорируется,то это происходит из-за того,что программист специально добавил код,чтобы проигнорировать ошибку,что предположительно означает,что она была преднамеренной.</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если эти ограничения не выполняются, функция считается несопоставимой и &lt;code&gt;isSame&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">Если они оба нулевые,то они равны.Если один из них нулевой,а другой нет,то они не равны.Если они оба ненулевые,то они равны,если их значения равны.</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">Если они сравнивают равное значение,возвращаем значение 0,возвращаемое fp.</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">Если у них есть интерфейс диапазона,отформатированный как диапазон ввода.</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">Если у них одинаковые ptrs,верните еще 1 0.</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">Если часовой пояс этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; является &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , то TZ пуст. Если его часовой пояс &lt;code&gt;UTC&lt;/code&gt; , то это &amp;laquo;Z&amp;raquo;. В противном случае это смещение от UTC (например, +0100 или -0700). Обратите внимание, что смещение от UTC составляет</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">Если часовой пояс этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; является &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , то TZ пуст. Если его часовой пояс &lt;code&gt;UTC&lt;/code&gt; , то это &amp;laquo;Z&amp;raquo;. В противном случае это смещение от UTC (например, +01: 00 или -07: 00). Обратите внимание, что смещение от UTC составляет</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">Если этот &lt;code&gt;Nullable&lt;/code&gt; переносит тип, который уже имеет нулевое значение (например, указатель), и это нулевое значение не задано для &lt;code&gt;nullValue&lt;/code&gt; , то присвоение нулевого значения этому &lt;code&gt;Nullable&lt;/code&gt; ничем не отличается от назначения любого другого значения типа &lt;code&gt;T&lt;/code&gt; , и результирующий код будет выглядеть очень странно. Настоятельно рекомендуется , чтобы этого избежать, используя &lt;code&gt;T&lt;/code&gt; &amp;laquo;s&amp;bdquo;построен в&amp;ldquo;нулевое значение для &lt;code&gt;nullValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">Если этот &lt;code&gt;Nullable&lt;/code&gt; переносит тип, который уже имеет нулевое значение (например, указатель), то присвоение нулевого значения этому &lt;code&gt;Nullable&lt;/code&gt; ничем не отличается от назначения любого другого значения типа &lt;code&gt;T&lt;/code&gt; , и результирующий код будет выглядеть очень странно. Настоятельно рекомендуется избегать этого, используя вместо этого версию &lt;code&gt;Nullable&lt;/code&gt; , которая принимает дополнительный &lt;code&gt;nullValue&lt;/code&gt; шаблона nullValue .</target>
        </trans-unit>
        <trans-unit id="7febe77abd33adf57e913bf0a4a63eb358541f75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Task&lt;/code&gt; was not started yet, execute it in the current thread. If it is finished, return its result. If it is in progress, execute any other &lt;code&gt;Task&lt;/code&gt; from the &lt;code&gt;TaskPool&lt;/code&gt; instance that this &lt;code&gt;Task&lt;/code&gt; was submitted to until this one is finished. If it threw an exception, rethrow that exception. If no other tasks are available or this &lt;code&gt;Task&lt;/code&gt; was executed using &lt;code&gt;executeInNewThread&lt;/code&gt;, wait on a condition variable.</source>
          <target state="translated">Если эта &lt;code&gt;Task&lt;/code&gt; не была запущена, выполните ее в текущем потоке. Если он закончен, верните его результат. Если это выполняется, выполните любую другую &lt;code&gt;Task&lt;/code&gt; из экземпляра &lt;code&gt;TaskPool&lt;/code&gt; ,в которую была отправлена эта &lt;code&gt;Task&lt;/code&gt; пока эта задача не будет завершена. Если это вызвало исключение, сбросьте это исключение. Если другие задачи недоступны или эта &lt;code&gt;Task&lt;/code&gt; была выполнена с помощью &lt;code&gt;executeInNewThread&lt;/code&gt; , дождитесь условной переменной.</target>
        </trans-unit>
        <trans-unit id="02c1e520b882980c80752c1365bf55b4375ba858" translate="yes" xml:space="preserve">
          <source>If this declaration is compliant with any particular standard, the description of it goes here.</source>
          <target state="translated">Если эта декларация соответствует какому-либо конкретному стандарту,ее описание приведено здесь.</target>
        </trans-unit>
        <trans-unit id="13a2f9d3fe709668a2bc4c5dc3f8ab6e710fca1e" translate="yes" xml:space="preserve">
          <source>If this is a reference, dereference it.</source>
          <target state="translated">Если это ссылка,убрать ее.</target>
        </trans-unit>
        <trans-unit id="4f2c995ebc62fdd08dead47122c9bc13fad7a76d" translate="yes" xml:space="preserve">
          <source>If this is a shell around another type, get that other type.</source>
          <target state="translated">Если это оболочка вокруг другого типа,получите этот другой тип.</target>
        </trans-unit>
        <trans-unit id="b5dc509f5b8b27fb2d7cf6170c77f1c20cada7e8" translate="yes" xml:space="preserve">
          <source>If this is a type of something, return that something.</source>
          <target state="translated">Если это что-то вроде того,верни это что-то.</target>
        </trans-unit>
        <trans-unit id="78983652ba5d9285bc5419929ba9f7e7d2014654" translate="yes" xml:space="preserve">
          <source>If this is a type of static array, return its base element type.</source>
          <target state="translated">Если это тип статического массива,верните ему тип базового элемента.</target>
        </trans-unit>
        <trans-unit id="11053146fa2d89a0863002bf2113f6a22908ad90" translate="yes" xml:space="preserve">
          <source>If this lock is not already held by the caller, the lock is acquired, then the internal counter is incremented by one.</source>
          <target state="translated">Если эта блокировка еще не удерживается вызывающим абонентом,то блокировка приобретается,а внутренний счетчик инкрементируется на единицу.</target>
        </trans-unit>
        <trans-unit id="7f2c76fc93c2cea506533b01d671704af3859af8" translate="yes" xml:space="preserve">
          <source>If this statement has code that needs to run in a finally clause at the end of the current scope, return that code in the form of a Statement.</source>
          <target state="translated">Если в этом утверждении есть код,который должен быть запущен в конечном пункте в конце текущего диапазона,верните этот код в виде утверждения.</target>
        </trans-unit>
        <trans-unit id="0515fd6aa93cc22acea186af17b617bb6900cccc" translate="yes" xml:space="preserve">
          <source>If this symbol is really an alias for another, return that other. If needed, semantic() is invoked due to resolve forward reference.</source>
          <target state="translated">Если этот символ действительно является псевдонимом для другого,верните этот другой.При необходимости,семантическая()вызывается из-за разрешения прямой ссылки.</target>
        </trans-unit>
        <trans-unit id="0d671d5e8525a56282bf3d43e4b2c8ef0fff443b" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Checked&lt;/code&gt; instances are involved in a binary operation and both define &lt;code&gt;hookOpBinary&lt;/code&gt;, the left-hand side hook has priority. If both define &lt;code&gt;onOverflow&lt;/code&gt;, a compile-time error occurs.</source>
          <target state="translated">Если два &lt;code&gt;Checked&lt;/code&gt; экземпляра участвуют в бинарной операции и оба определяют &lt;code&gt;hookOpBinary&lt;/code&gt; , левый хук имеет приоритет. Если оба определяют &lt;code&gt;onOverflow&lt;/code&gt; , происходит ошибка времени компиляции.</target>
        </trans-unit>
        <trans-unit id="000877fa3e86af7fe8754c0a2ea9639fca32104e" translate="yes" xml:space="preserve">
          <source>If two different mixins are put in the same scope, and each define a declaration with the same name, there is an ambiguity error when the declaration is referenced:</source>
          <target state="translated">Если в одной и той же области применения поставить две различные смеси,и каждая из них определит декларацию с одним и тем же именем,то при обращении к декларации будет допущена ошибка двусмысленности:</target>
        </trans-unit>
        <trans-unit id="a3bad367e89a048e204fc75a01e068c90ffc4712" translate="yes" xml:space="preserve">
          <source>If two or more functions have the same match level, then</source>
          <target state="translated">Если две или более функций имеют один и тот же уровень соответствия,тогда</target>
        </trans-unit>
        <trans-unit id="329ee511107dbe6e7abc063f46dd137916ba7624" translate="yes" xml:space="preserve">
          <source>If unit tests are not enabled, the implementation is not required to check the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; for syntactic or semantic correctness. This is to reduce the compile time impact of larger unit test sections. The tokens must still be valid, and the implementation can merely count &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens to find the end of the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;'s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Если модульные тесты не включены, реализация не обязана проверять &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; на синтаксическую или семантическую правильность. Это должно уменьшить влияние времени компиляции больших разделов модульного теста. Маркеры должны все еще быть в силе, а реализация может просто рассчитывать &lt;code&gt;{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; жетоны , чтобы найти конец &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; &amp;laquo;s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9627f657eafec4f6faa68074956b9ef2912cb7d7" translate="yes" xml:space="preserve">
          <source>If variable has a const initializer, return that initializer.</source>
          <target state="translated">Если переменная имеет инициализатор const,верните этот инициализатор.</target>
        </trans-unit>
        <trans-unit id="efa87bbfad2d81b3124f9c28a0c2e92ac37d7e01" translate="yes" xml:space="preserve">
          <source>If variable has a constant expression initializer, get it. Otherwise, return null.</source>
          <target state="translated">Если переменная имеет инициализатор константного выражения,получите его.В противном случае верните ноль.</target>
        </trans-unit>
        <trans-unit id="129f6b693e38ba5e18679007098a9df7fc61bc3f" translate="yes" xml:space="preserve">
          <source>If vector extensions are implemented, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;D_SIMD&lt;/code&gt; is set.</source>
          <target state="translated">Если реализованы векторные расширения, устанавливается &lt;a href=&quot;version#PredefinedVersions&quot;&gt;идентификатор версии &lt;/a&gt; &lt;code&gt;D_SIMD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adbc7bef2337da263c5a713fbb0e840af6633adb" translate="yes" xml:space="preserve">
          <source>If we want the value of this expression, but do not want to call the destructor on it.</source>
          <target state="translated">Если нам нужно значение этого выражения,но мы не хотим вызывать на него деструктор.</target>
        </trans-unit>
        <trans-unit id="79988e7c16e0dced67dee802d9bdb6de78ec6132" translate="yes" xml:space="preserve">
          <source>If x is not a special value, the result is the same as &lt;code&gt;cast(int) logb(x)&lt;/code&gt;.</source>
          <target state="translated">Если x не является специальным значением, результат совпадает с &lt;code&gt;cast(int) logb(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bffad47163601102b19e67fa92a8c3feda0166ec" translate="yes" xml:space="preserve">
          <source>If x is subnormal, it is treated as if it were normalized. For a positive, finite x:</source>
          <target state="translated">Если х является субнормальным,то к нему относятся так,как если бы он был нормализован.Для положительного,конечного икса:</target>
        </trans-unit>
        <trans-unit id="92c403e0084ea037260c41da9c4c7e544a7d2d08" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y.</source>
          <target state="translated">Если y&amp;gt; x, результатом будет следующее наибольшее значение с плавающей точкой; если y &amp;lt;x, результатом будет следующее наименьшее значение. Если x == y, результатом будет y.</target>
        </trans-unit>
        <trans-unit id="51868f820cebc5e3c544468e6d407c4bd6b45485" translate="yes" xml:space="preserve">
          <source>If you have a small buffer you can use &lt;a href=&quot;#compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#uncompress&quot;&gt;&lt;code&gt;uncompress&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">Если у вас небольшой буфер, вы можете использовать &lt;a href=&quot;#compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#uncompress&quot;&gt; &lt;code&gt;uncompress&lt;/code&gt; &lt;/a&gt; напрямую.</target>
        </trans-unit>
        <trans-unit id="b65e14bf08e45286eb114c69d33e8aa407bf4bbd" translate="yes" xml:space="preserve">
          <source>If you omit &lt;code&gt;Rhs&lt;/code&gt;, &lt;code&gt;isAssignable&lt;/code&gt; will check identity assignable of &lt;code&gt;Lhs&lt;/code&gt;.</source>
          <target state="translated">Если вы опустите &lt;code&gt;Rhs&lt;/code&gt; , &lt;code&gt;isAssignable&lt;/code&gt; проверит идентичность, &lt;code&gt;Lhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14961e1fccbf1736d47a52df390592d594e9109a" translate="yes" xml:space="preserve">
          <source>If you select &lt;code&gt;precise&lt;/code&gt; as the garbage collector via the options above, type information will be used to identify actual or possible pointers or references within heap allocated data objects. Non-pointer data will not be interpreted as a reference to other memory as a &quot;false pointer&quot;. The collector has to make pessimistic assumptions if a memory slot can contain both a pointer or an integer value, it will still be scanned (e.g. in a &lt;code&gt;union&lt;/code&gt;).</source>
          <target state="translated">Если вы выберете &lt;code&gt;precise&lt;/code&gt; в качестве сборщика мусора с помощью указанных выше параметров, информация о типе будет использоваться для идентификации фактических или возможных указателей или ссылок в выделенных объектах данных кучи. Данные без указателя не будут интерпретироваться как ссылка на другую память как &amp;laquo;ложный указатель&amp;raquo;. Сборщик должен делать пессимистические предположения, если слот памяти может содержать как указатель, так и целочисленное значение, он все равно будет сканироваться (например, в &lt;code&gt;union&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbade680aa6ce4b2eee3b550013b504b2359a76c" translate="yes" xml:space="preserve">
          <source>If you use the GC memory functions from &lt;code&gt;core.memory&lt;/code&gt;, and plan to use it for data with a mixture of pointers and non-pointer data you should pass the TypeInfo of your allocated struct, class or type as the optional parameter. The default &lt;code&gt;null&lt;/code&gt; is interpreted as memory that might contain pointers everywhere.</source>
          <target state="translated">Если вы используете функции памяти GC из &lt;code&gt;core.memory&lt;/code&gt; и планируете использовать их для данных со смесью указателей и данных без указателей, вы должны передать TypeInfo вашей выделенной структуры, класса или типа в качестве необязательного параметра. Значение по умолчанию &lt;code&gt;null&lt;/code&gt; интерпретируется как память, которая может содержать указатели повсюду.</target>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="b2403005179997fdecfad41d075986e0dccac0e9" translate="yes" xml:space="preserve">
          <source>IfStatement</source>
          <target state="translated">IfStatement</target>
        </trans-unit>
        <trans-unit id="859704f6d767666630d7b805196cab9e15bc787d" translate="yes" xml:space="preserve">
          <source>IgnoreXXXX</source>
          <target state="translated">IgnoreXXXX</target>
        </trans-unit>
        <trans-unit id="ba5ba167a98858b40c030856aa4aacb94b020392" translate="yes" xml:space="preserve">
          <source>Ignores C-style / D-style variadic arguments.</source>
          <target state="translated">Игнорирует вариадические аргументы в стиле C/D.</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="ed701420e7f5e55b19ea82ee452968a59b8615ea" translate="yes" xml:space="preserve">
          <source>Images have the same form as reference or inline links, but add an exclamation point &lt;code&gt;!&lt;/code&gt; before the initial square bracket. What would be the link text in a normal link is used as the image's alt text.</source>
          <target state="translated">Изображения имеют ту же форму, что и ссылочные или встроенные ссылки, но добавьте восклицательный знак &lt;code&gt;!&lt;/code&gt; перед начальной квадратной скобкой. Что бы текст ссылки в обычной ссылке использовался как альтернативный текст изображения.</target>
        </trans-unit>
        <trans-unit id="da8a47e84bd95dd590801199a512c81712152ddc" translate="yes" xml:space="preserve">
          <source>Immediately after the range argument, an optional work unit size argument may be provided. Work units as used by &lt;code&gt;amap&lt;/code&gt; are identical to those defined for parallel foreach. If no work unit size is provided, the default work unit size is used.</source>
          <target state="translated">Сразу после аргумента диапазона может быть указан необязательный аргумент размера рабочей единицы. Рабочие единицы, используемые в &lt;code&gt;amap&lt;/code&gt; , идентичны тем, которые определены для параллельного foreach. Если размер рабочего блока не указан, используется размер рабочего блока по умолчанию.</target>
        </trans-unit>
        <trans-unit id="79fa62caeafe3bd4c17315583aef1c8a23c5d46e" translate="yes" xml:space="preserve">
          <source>Immediately drop any connections and release socket resources. The &lt;code&gt;Socket&lt;/code&gt; object is no longer usable after &lt;code&gt;close&lt;/code&gt;. Calling &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; is recommended for connection-oriented sockets.</source>
          <target state="translated">Немедленно отбросьте все соединения и освободите ресурсы сокета. Объект &lt;code&gt;Socket&lt;/code&gt; больше не может использоваться после &lt;code&gt;close&lt;/code&gt; . Вызов &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; рекомендуется для сокетов, ориентированных на соединение.</target>
        </trans-unit>
        <trans-unit id="1473effc3e4965950f77d9acee523d95bdbf4b42" translate="yes" xml:space="preserve">
          <source>Immutability is transitive, meaning it applies to anything that can be referenced from the immutable type:</source>
          <target state="translated">Неизменяемость является переходной,то есть применима ко всему,на что можно ссылаться,начиная с неизменяемого типа:</target>
        </trans-unit>
        <trans-unit id="a3901c3fc3cbd4dda7d4b5cdbdfb146ab629c087" translate="yes" xml:space="preserve">
          <source>Immutable Member Functions</source>
          <target state="translated">Непреложные функции члена</target>
        </trans-unit>
        <trans-unit id="31b83cfa7707372a1c66b40c2bffbc19a9e85eb7" translate="yes" xml:space="preserve">
          <source>Immutable Storage Class</source>
          <target state="translated">Неизменный класс хранения</target>
        </trans-unit>
        <trans-unit id="bad427b56d48a9c0418ac178e3b7e5501dbeffb2" translate="yes" xml:space="preserve">
          <source>Immutable Type</source>
          <target state="translated">Неизменяемый тип</target>
        </trans-unit>
        <trans-unit id="7a41b36410af31e02780ae8ef8f795b4c7e5c218" translate="yes" xml:space="preserve">
          <source>Immutable associative arrays are often desirable, but sometimes initialization must be done at runtime. This can be achieved with a constructor (static constructor depending on scope), a buffer associative array and &lt;code&gt;assumeUnique&lt;/code&gt;:</source>
          <target state="translated">Неизменяемые ассоциативные массивы часто желательны, но иногда инициализация должна выполняться во время выполнения. Это может быть достигнуто с помощью конструктора (статический конструктор в зависимости от области видимости), ассоциативного массива буфера и &lt;code&gt;assumeUnique&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1060492cd68308e42ab0d863274ead4d94e73c72" translate="yes" xml:space="preserve">
          <source>Immutable declarations can appear as lvalues, i.e. they can have their address taken, and occupy storage.</source>
          <target state="translated">Неизменяемые декларации могут появляться в виде значений,т.е.у них может быть взят адрес,и они могут занимать место хранения.</target>
        </trans-unit>
        <trans-unit id="97deddbfb05296e5d5f6c89e8255f2cf73fed0f1" translate="yes" xml:space="preserve">
          <source>Immutable member functions are guaranteed that the object and anything referred to by the &lt;code&gt;this&lt;/code&gt; reference is immutable. They are declared as:</source>
          <target state="translated">Неизменные функции - члены гарантируют , что объект и все , на которые ссылается &lt;code&gt;this&lt;/code&gt; ссылка неизменна. Они объявлены как:</target>
        </trans-unit>
        <trans-unit id="7ca47511da5cd25a571e0550ee9181f060e3ad8e" translate="yes" xml:space="preserve">
          <source>Immutable used as a storage class is equivalent to using immutable as a type qualifier for the entire type of a declaration:</source>
          <target state="translated">Неизменяемость,используемая в качестве класса хранения,эквивалентна использованию неизменяемого в качестве классификатора типа для всего типа декларации:</target>
        </trans-unit>
        <trans-unit id="8cc79f379fb076727af30671cff8e81a7a78ac8f" translate="yes" xml:space="preserve">
          <source>Imperial Aramaic</source>
          <target state="translated">императорский арамейский</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="015f00e67a839cb58bb4f25641353bc270b1dc50" translate="yes" xml:space="preserve">
          <source>Impl* &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);</source>
          <target state="translated">&lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;Impl&lt;/strong&gt; * &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt; (const TypeInfo_AssociativeArray ti, ключи void [], значения void []);</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="4bd31434dd702d78584ad36682fd4ce02cbe35f9" translate="yes" xml:space="preserve">
          <source>Implementation helpers</source>
          <target state="translated">Помощники по внедрению</target>
        </trans-unit>
        <trans-unit id="cdc8095e33689a7350a694bb991dc5449ed4cc80" translate="yes" xml:space="preserve">
          <source>Implementation note: Many vector operations are expected to take advantage of any vector math instructions available on the target computer.</source>
          <target state="translated">Примечание по реализации:Многие векторные операции,как ожидается,будут использовать преимущества любых векторных математических инструкций,доступных на целевом компьютере.</target>
        </trans-unit>
        <trans-unit id="4f7fc9a2d05fa0c5c4b7879d385797376ea8299d" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;IAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built allocator type to &lt;code&gt;IAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">Реализация &lt;code&gt;IAllocator&lt;/code&gt; с использованием &lt;code&gt;Allocator&lt;/code&gt; . Это адаптирует статически построенный тип распределителя к &lt;code&gt;IAllocator&lt;/code&gt; , который может непосредственно использоваться без шаблонного кода.</target>
        </trans-unit>
        <trans-unit id="fafacd0c4afbb4ff4bf1edadf17fafe457e3c87e" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;ISharedAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built, shareable across threads, allocator type to &lt;code&gt;ISharedAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">Реализация &lt;code&gt;ISharedAllocator&lt;/code&gt; с использованием &lt;code&gt;Allocator&lt;/code&gt; . Это адаптирует статически построенный, разделяемый между потоками тип распределителя к &lt;code&gt;ISharedAllocator&lt;/code&gt; , который непосредственно может использоваться не шаблонным кодом.</target>
        </trans-unit>
        <trans-unit id="bcbaffe82dd8f12aeaf4d1ff9d3011fef84404a6" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendT&lt;/code&gt; and &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</source>
          <target state="translated">Реализация &lt;code&gt;_d_arrayappendT&lt;/code&gt; и &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10e497f26133fe54aedbc1b0186f76a3533b685" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; and &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</source>
          <target state="translated">Реализация &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; и &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7db4a8478e7cad025fd1104c777c36390076d0e1" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraycatnTX&lt;/code&gt; and &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</source>
          <target state="translated">Реализация &lt;code&gt;_d_arraycatnTX&lt;/code&gt; и &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abbaa69f0e232671973ab5e6491f136e6a29871" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; and &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</source>
          <target state="translated">Реализация &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; и &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f9ad487b035fc97c0af04b8b66abb8578971a5f" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt; red-black tree&lt;/a&gt; container.</source>
          <target state="translated">Реализация контейнера &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;красно-черного дерева&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7df8ae1e56f997a5b65b6b6877c23f0d64f3a3" translate="yes" xml:space="preserve">
          <source>Implementation of alloca() standard C routine.</source>
          <target state="translated">Реализация аллока()стандартной рутины С.</target>
        </trans-unit>
        <trans-unit id="1784dc78d2b897ccf07f36701bfc5665f7a4b791" translate="yes" xml:space="preserve">
          <source>Implementation of array assignment support routines.</source>
          <target state="translated">Реализация процедур поддержки назначения массивов.</target>
        </trans-unit>
        <trans-unit id="a39c70c382be4565515493d462dbbec04eaf7781" translate="yes" xml:space="preserve">
          <source>Implementation of array copy support routines.</source>
          <target state="translated">Реализация процедур поддержки копирования массивов.</target>
        </trans-unit>
        <trans-unit id="0bdc6417eff40a113a2fe81fc65ab41a4dcaba32" translate="yes" xml:space="preserve">
          <source>Implementation of associative arrays.</source>
          <target state="translated">Реализация ассоциативных массивов.</target>
        </trans-unit>
        <trans-unit id="07784c9ff6fc80ea8be9db66531869c595761785" translate="yes" xml:space="preserve">
          <source>Implementation of code coverage analyzer.</source>
          <target state="translated">Реализация анализатора покрытия кода.</target>
        </trans-unit>
        <trans-unit id="fad1778f18239a1620ff2a279ed8dce89c92aba4" translate="yes" xml:space="preserve">
          <source>Implementation of dynamic array property support routines.</source>
          <target state="translated">Реализация процедур поддержки свойств динамических массивов.</target>
        </trans-unit>
        <trans-unit id="1c44b949de0c9066379af30ba926638e5089c3a0" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines for Win32.</source>
          <target state="translated">Реализация процедур поддержки обработки исключений для Win32.</target>
        </trans-unit>
        <trans-unit id="7d3ce3a8f354f9946b2098d37781419df42c1fa9" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines.</source>
          <target state="translated">Внедрение процедур поддержки обработки исключений.</target>
        </trans-unit>
        <trans-unit id="4262710c1f4443ad04091f6eaee82248c8735a23" translate="yes" xml:space="preserve">
          <source>Implementation of invariant support routines.</source>
          <target state="translated">Внедрение инвариантных процедур поддержки.</target>
        </trans-unit>
        <trans-unit id="3dad8ae42692f0a5067da5335623cc0faae36caa" translate="yes" xml:space="preserve">
          <source>Implementation of standard Base64 encoding.</source>
          <target state="translated">Реализация стандартной кодировки Base64.</target>
        </trans-unit>
        <trans-unit id="8bb4407a3328a42063117ac1cd37abce98147582" translate="yes" xml:space="preserve">
          <source>Implementation of support routines for synchronized blocks.</source>
          <target state="translated">Реализация процедур поддержки синхронизированных блоков.</target>
        </trans-unit>
        <trans-unit id="36a7e10f19e92847926357311b55d0e017f473ef" translate="yes" xml:space="preserve">
          <source>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</source>
          <target state="translated">Введение свободно предполагает,что указатели GC хранятся только на границах слов.Не выровненные указатели могут быть полностью проигнорированы.</target>
        </trans-unit>
        <trans-unit id="a8c2ed8c7bf790ca62a6ccc79e874d26201eb456" translate="yes" xml:space="preserve">
          <source>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</source>
          <target state="translated">Воплощения свободны для запуска коллекций в любой момент.Однако,это рекомендуется делать только в том случае,если попытка выделения коллекций происходит при недостаточном количестве доступной памяти.</target>
        </trans-unit>
        <trans-unit id="7bedeb01a44e9992494ae61fc2e61ab874f0844b" translate="yes" xml:space="preserve">
          <source>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like &lt;code&gt;float&lt;/code&gt; will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. &lt;code&gt;size_t&lt;/code&gt;) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">Реализации могут сканировать кучу без полномочий root точным способом, поэтому поля типов, таких как &lt;code&gt;float&lt;/code&gt; , не будут считаться релевантными при сканировании кучи. Таким образом, приведение указателя GC к целочисленному типу (например, &lt;code&gt;size_t&lt;/code&gt; ) и сохранение его в поле этого типа внутри кучи GC может означать, что он не будет распознан, если блок памяти был выделен с точной информацией о типе или с &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fe2d13e1a38447a1ccf3bcf63459da389a3bd8d" translate="yes" xml:space="preserve">
          <source>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name.</source>
          <target state="translated">Введение может ограничить имя файла,чтобы избежать уязвимостей безопасности при обходе каталогов.Возможным ограничением может быть запрещение любых компонентов пути в имени файла.</target>
        </trans-unit>
        <trans-unit id="41da860cb79fe7312e55548bf43ef9ac07ff278f" translate="yes" xml:space="preserve">
          <source>Implementations must diagnose an error for unrecognized</source>
          <target state="translated">Внедрения должны диагностировать ошибку для непризнанных</target>
        </trans-unit>
        <trans-unit id="007c721ddd0f22de039d1ec5d207cce979d8d6f0" translate="yes" xml:space="preserve">
          <source>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</source>
          <target state="translated">Реализации должны поддерживать внутренние указатели. То есть, если единственная ссылка на блок памяти, управляемый GC, указывает на середину блока, а не на начало (например), GC должен считать блок памяти активным. Исключение из этого правила - когда блок памяти выделяется с помощью &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; ; пользователь должен убедиться, что такие блоки памяти имеют правильный указатель на них, когда они должны рассматриваться как живые.</target>
        </trans-unit>
        <trans-unit id="db108dbc2de097787f6ddeb0832f02909642f907" translate="yes" xml:space="preserve">
          <source>Implementations of D on different architectures, however, are free to innovate upon the memory model, function call/return conventions, argument passing conventions, etc.</source>
          <target state="translated">Тем не менее,применение D на различных архитектурах свободно для нововведений в модели памяти,соглашениях по вызову/возвращению функций,соглашениях по передаче аргументов и т.д.</target>
        </trans-unit>
        <trans-unit id="d7a03fc44da9f306060241398ee57db5f3a7d7aa" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; and &lt;code&gt;pthread_condition&lt;/code&gt; on Posix and &lt;code&gt;CreateEvent&lt;/code&gt; and &lt;code&gt;SetEvent&lt;/code&gt; on Windows.</source>
          <target state="translated">Реализовано с использованием &lt;code&gt;pthread_mutex&lt;/code&gt; и &lt;code&gt;pthread_condition&lt;/code&gt; для Posix, &lt;code&gt;CreateEvent&lt;/code&gt; и &lt;code&gt;SetEvent&lt;/code&gt; для Windows.</target>
        </trans-unit>
        <trans-unit id="9e4c63b7ecbb7ff73a2154a224607de77b4347f8" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; on Posix and &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; on Windows.</source>
          <target state="translated">Реализовано с помощью &lt;code&gt;pthread_mutex&lt;/code&gt; в Posix и &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="cf9e08c7271694a3ffd216903295953184c6b554" translate="yes" xml:space="preserve">
          <source>Implementing a Scheduler allows the concurrency mechanism used by this module to be customized according to different needs. By default, a call to spawn will create a new kernel thread that executes the supplied routine and terminates when finished. But it is possible to create Schedulers that reuse threads, that multiplex Fibers (coroutines) across a single thread, or any number of other approaches. By making the choice of Scheduler a user-level option, std.concurrency may be used for far more types of application than if this behavior were predefined.</source>
          <target state="translated">Реализация Планировщика позволяет настроить механизм параллелизма,используемый этим модулем,в соответствии с различными потребностями.По умолчанию,вызов порождения создаст новый поток ядра,который выполнит поставляемую рутину и завершит ее по окончании.Однако можно создать Планировщики,которые повторно используют потоки,которые мультиплексируют Волокна (корутины)в одном потоке,или любое количество других подходов.Сделав выбор Планировщика опцией пользовательского уровня,std.concurrency может быть использован для гораздо большего количества типов приложений,чем если бы такое поведение было предопределено.</target>
        </trans-unit>
        <trans-unit id="b264d3336b750c35148a8818568f62fa13927441" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in integers.</source>
          <target state="translated">Реализует 3-х стороннее сравнение &lt;code&gt;BigInt&lt;/code&gt; с &lt;code&gt;BigInt&lt;/code&gt; или &lt;code&gt;BigInt&lt;/code&gt; со встроенными целыми числами.</target>
        </trans-unit>
        <trans-unit id="ff4e8dcbc761da7358b8c9aa098a3c08bb0a396c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integer types.</source>
          <target state="translated">Реализует &lt;code&gt;BigInt&lt;/code&gt; равенство BigInt с другими встроенными целочисленными типами &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca26966771a4b63b83cfa749d58cb4c74bd1074" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; unary operators.</source>
          <target state="translated">Реализует &lt;code&gt;BigInt&lt;/code&gt; унарные операторы.</target>
        </trans-unit>
        <trans-unit id="6a3cb51c99d7f39233c1830869fb1b564b310297" translate="yes" xml:space="preserve">
          <source>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt; as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to &lt;code&gt;front&lt;/code&gt; or &lt;code&gt;popFront&lt;/code&gt;, or diverting the elements of a range into an auxiliary &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реализует трубу в стиле &amp;laquo;тройник&amp;raquo;, оборачивая входной диапазон, чтобы элементы диапазона могли быть переданы в предоставленную функцию или &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt; при их итерации. Это полезно для распечатки промежуточных значений в длинной цепочке кода диапазона, выполнения некоторой операции с побочными эффектами при каждом вызове &lt;code&gt;front&lt;/code&gt; или &lt;code&gt;popFront&lt;/code&gt; или перенаправления элементов диапазона во вспомогательный &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edd807624e1eff53b60fc0fdcb84a1a01a914908" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="translated">Реализует &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;двоичный&lt;/a&gt; контейнер кучи поверх заданного типа диапазона произвольного доступа (обычно &lt;code&gt;T[]&lt;/code&gt; ) или типа контейнера произвольного доступа (обычно &lt;code&gt;Array!T&lt;/code&gt; ). Документация &lt;code&gt;BinaryHeap&lt;/code&gt; будет ссылаться на базовый диапазон или контейнер как</target>
        </trans-unit>
        <trans-unit id="826e19cc42c27271edbc14035290489f9b886abe" translate="yes" xml:space="preserve">
          <source>Implements a doubly-linked list.</source>
          <target state="translated">Вводит двойной список.</target>
        </trans-unit>
        <trans-unit id="6c4a9e8241b5f111ea434df2fe96c036c8c94979" translate="yes" xml:space="preserve">
          <source>Implements a narrowing remainder operation with built-in integer types.</source>
          <target state="translated">Вводит операцию сужения остатка со встроенными целочисленными типами.</target>
        </trans-unit>
        <trans-unit id="27ed74a2d7c34a4b3c0b18b681929b4fe9236374" translate="yes" xml:space="preserve">
          <source>Implements a parallel foreach loop over a range. This works by implicitly creating and submitting one &lt;code&gt;Task&lt;/code&gt; to the &lt;code&gt;TaskPool&lt;/code&gt; for each worker thread. A work unit is a set of consecutive elements of &lt;code&gt;range&lt;/code&gt; to be processed by a worker thread between communication with any other thread. The number of elements processed per work unit is controlled by the &lt;code&gt;workUnitSize&lt;/code&gt; parameter. Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit. Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger &lt;code&gt;workUnitSize&lt;/code&gt; should be. For very expensive loop bodies, &lt;code&gt;workUnitSize&lt;/code&gt; should be 1. An overload that chooses a default work unit size is also available.</source>
          <target state="translated">Реализует параллельный цикл foreach в диапазоне. Это работает путем неявного создания и отправки одной &lt;code&gt;Task&lt;/code&gt; в &lt;code&gt;TaskPool&lt;/code&gt; для каждого рабочего потока. Рабочий блок - это набор последовательных элементов &lt;code&gt;range&lt;/code&gt; которые должны обрабатываться рабочим потоком между связями с любым другим потоком. Количество элементов, обрабатываемых на единицу работы, контролируется параметром &lt;code&gt;workUnitSize&lt;/code&gt; . Меньшие рабочие блоки обеспечивают лучшую балансировку нагрузки, но большие рабочие блоки избегают лишних затрат на частую связь с другими потоками для получения следующей рабочей единицы. Большие рабочие блоки также позволяют избежать ложного разделения в тех случаях, когда диапазон изменяется. Чем меньше времени занимает одна итерация цикла, тем больше &lt;code&gt;workUnitSize&lt;/code&gt; должно быть. Для очень дорогих тел циклов &lt;code&gt;workUnitSize&lt;/code&gt; должно быть равно 1. Перегрузка, которая выбирает размер рабочего модуля по умолчанию, также доступна.</target>
        </trans-unit>
        <trans-unit id="826fe4a31de6fc5bfd32223112c616b546ef30ea" translate="yes" xml:space="preserve">
          <source>Implements a simple and fast singly-linked list. It can be used as a stack.</source>
          <target state="translated">Вводит простой и быстрый односвязный список.Может использоваться в качестве стека.</target>
        </trans-unit>
        <trans-unit id="1e7f8a9f41236aa959250c83a21042416cfb7001" translate="yes" xml:space="preserve">
          <source>Implements an output range that appends data to an array. This is recommended over &lt;code&gt;array ~= data&lt;/code&gt; when appending many elements because it is more efficient. &lt;code&gt;Appender&lt;/code&gt; maintains its own array metadata locally, so it can avoid global locking for each append where &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; is non-zero.</source>
          <target state="translated">Реализует выходной диапазон, который добавляет данные в массив. Это рекомендуется для &lt;code&gt;array ~= data&lt;/code&gt; при добавлении многих элементов, потому что это более эффективно. &lt;code&gt;Appender&lt;/code&gt; поддерживает свои собственные метаданные массива локально, поэтому он может избежать глобальной блокировки для каждого добавления, где &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; не равна нулю.</target>
        </trans-unit>
        <trans-unit id="eb1006ae1765bc7db00ba2578ee369f0e577a7bc" translate="yes" xml:space="preserve">
          <source>Implements assignment operators from built-in integers of the form &lt;code&gt;BigInt op= integer&lt;/code&gt;.</source>
          <target state="translated">Реализует операторы присваивания из встроенных целых чисел вида &lt;code&gt;BigInt op= integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bf741a9ca55b772fcf287918db9b994810ba0a" translate="yes" xml:space="preserve">
          <source>Implements assignment operators of the form &lt;code&gt;BigInt op= BigInt&lt;/code&gt;.</source>
          <target state="translated">Реализует операторы присваивания вида &lt;code&gt;BigInt op= BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ea709e7bbd408cd7bf94a6f215f7f14ae10aa2" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integers.</source>
          <target state="translated">Реализует бинарные операторы между &lt;code&gt;BigInt&lt;/code&gt; и встроенными целыми числами.</target>
        </trans-unit>
        <trans-unit id="df47e55b92aed2a9c5b877779b4fc9382af7ea1f" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">Реализует бинарные операторы между &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c38b2eea1063f17593adb5371b20a04e888bc589" translate="yes" xml:space="preserve">
          <source>Implements casting to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Осуществляет приведение к &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="612c7a1e4ee8aa3a5eb36e62f5d1886edb7c32a6" translate="yes" xml:space="preserve">
          <source>Implements casting to integer types.</source>
          <target state="translated">Приведение к целочисленным типам.</target>
        </trans-unit>
        <trans-unit id="d027822363fbfc370a577e3a5cc7b4b903013cad" translate="yes" xml:space="preserve">
          <source>Implements casting to/from qualified &lt;code&gt;BigInt&lt;/code&gt;'s.</source>
          <target state="translated">Осуществляет приведение в / из квалифицированных &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff4cc4fdb32d0e79c9536f6d66d8396bbf61c41a" translate="yes" xml:space="preserve">
          <source>Implements common functionality for StaticForeachDeclaration and StaticForeachStatement This performs the necessary lowerings before dmd.statementsem.makeTupleForeach can be used to expand the corresponding &lt;code&gt;static foreach&lt;/code&gt; declaration or statement.</source>
          <target state="translated">Реализует общую функциональность для StaticForeachDeclaration и StaticForeachStatement. Выполняет необходимые понижения, прежде чем dmd.statementsem.makeTupleForeach можно будет использовать для раскрытия соответствующего объявления или оператора &lt;code&gt;static foreach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33e291a05be91fd5868ef9b486e72f36172b61e4" translate="yes" xml:space="preserve">
          <source>Implements functionality to read Comma Separated Values and its variants from an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">Реализует функциональность для чтения значений , разделенных запятыми и его варианты от &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;входного диапазона&lt;/a&gt; от &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78fb12359a92b10736f7ddffd604a688feb1037" translate="yes" xml:space="preserve">
          <source>Implements logging facilities.</source>
          <target state="translated">Вводит лесозаготовительное оборудование.</target>
        </trans-unit>
        <trans-unit id="1c9526ff0c5c9d17f08ea2d94e25202e075b8278" translate="yes" xml:space="preserve">
          <source>Implements low-level time primitives.</source>
          <target state="translated">Использует низкоуровневые примитивы времени.</target>
        </trans-unit>
        <trans-unit id="f10aa3fdc814d436934036f8b3d2932b2c1a116c" translate="yes" xml:space="preserve">
          <source>Implements mixin types.</source>
          <target state="translated">Элементы смешанного типа.</target>
        </trans-unit>
        <trans-unit id="5720cf3a68f9171f96627020e4e3f8a88a48971a" translate="yes" xml:space="preserve">
          <source>Implements operators with built-in integers on the left-hand side and &lt;code&gt;BigInt&lt;/code&gt; on the right-hand side.</source>
          <target state="translated">Реализует операторы со встроенными целыми числами с левой стороны и &lt;code&gt;BigInt&lt;/code&gt; с правой стороны.</target>
        </trans-unit>
        <trans-unit id="7e5de803b2338c86b3532da481b13f228f6a981e" translate="yes" xml:space="preserve">
          <source>Implements routines related to exceptions.</source>
          <target state="translated">Вводит процедуры,связанные с исключениями.</target>
        </trans-unit>
        <trans-unit id="f320bc582113b4cafa3cdb495549c72756dd174e" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; (unary and binary), &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Реализует насыщенность для операторов &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; (унарный и двоичный), &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12ddcd2c7713838aaff094e0d8442224022b567f" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This hook is called if the result of the binary operation does not fit in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or a change in sign.</source>
          <target state="translated">Реализует насыщенность для операторов &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; . Этот хук вызывается, если результат двоичной операции не помещается в &lt;code&gt;Lhs&lt;/code&gt; без потери информации или изменения знака.</target>
        </trans-unit>
        <trans-unit id="be45676fa18a18d1d8737b834959d03a5f13376c" translate="yes" xml:space="preserve">
          <source>Implements the 'common' IEEE CRC32 variant (LSB-first order, Initial value uint.max, complement result)</source>
          <target state="translated">Дополняет &quot;общий&quot; вариант IEEE CRC32 (LSB первого порядка,Начальное значение uint.max,результат дополнения).</target>
        </trans-unit>
        <trans-unit id="c54fb55bf997400be69c40f0614b3e9b7db9616f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">Реализует &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;секущий метод&lt;/a&gt; для нахождения корня функции &lt;code&gt;fun&lt;/code&gt; , начиная с точек &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (идеально близко к корню). &lt;code&gt;Num&lt;/code&gt; может быть &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; или &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b80a316e588d021f8c65a6036707b88ad521159" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;OutputRange&lt;/code&gt; interface for all types E and wraps the &lt;code&gt;put&lt;/code&gt; method for each type &lt;code&gt;E&lt;/code&gt; in a virtual function.</source>
          <target state="translated">Реализует интерфейс &lt;code&gt;OutputRange&lt;/code&gt; для всех типов E и &lt;code&gt;put&lt;/code&gt; метод put для каждого типа &lt;code&gt;E&lt;/code&gt; в виртуальную функцию.</target>
        </trans-unit>
        <trans-unit id="09d37307ce6ae6ae1585ab5db7a54050805cc742" translate="yes" xml:space="preserve">
          <source>Implements the MurmurHash3 functions. You can specify the &lt;code&gt;size&lt;/code&gt; of the hash in bit. For 128 bit hashes you can specify whether to optimize for 32 or 64 bit architectures. If you don't specify the &lt;code&gt;opt&lt;/code&gt; value it will select the fastest version of the host platform.</source>
          <target state="translated">Реализует функции MurmurHash3. Вы можете указать &lt;code&gt;size&lt;/code&gt; хеша в битах. Для 128-битных хэшей вы можете указать, следует ли оптимизировать для 32- или 64-битных архитектур. Если вы не укажете значение &lt;code&gt;opt&lt;/code&gt; , будет выбрана самая быстрая версия платформы хоста.</target>
        </trans-unit>
        <trans-unit id="7ab18d84fa65349ea46fc1a23e6ee0555763f6a9" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json arrays.</source>
          <target state="translated">Реализует интерфейс &lt;code&gt;opApply&lt;/code&gt; для массивов json.</target>
        </trans-unit>
        <trans-unit id="45e448d8088d50f1f95bb79e479da8d5a8f8521b" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json objects.</source>
          <target state="translated">Реализует интерфейс &lt;code&gt;opApply&lt;/code&gt; foreach для объектов json.</target>
        </trans-unit>
        <trans-unit id="c7b156318387d032d75e77a645f93fbb91cfe8d1" translate="yes" xml:space="preserve">
          <source>Implements the higher order filter function. The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">Реализует функцию фильтра высшего порядка. Предикат передается в &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt; и может принимать строку или любой вызываемый объект, который может быть выполнен с помощью &lt;code&gt;pred(element)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="881b721a1385bc8ef11d90c4f0aac7e1c9f98dea" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor.</source>
          <target state="translated">Реализует функцию омонима (также известную как &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; или &lt;code&gt;foldl&lt;/code&gt; ), присутствующую в различных языках программирования функционального разнообразия.</target>
        </trans-unit>
        <trans-unit id="2de496f11d0a61e3ec35b13526a647a0eda0aa53" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. The call &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;fold!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">Реализует функцию омонима (также известную как &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; или &lt;code&gt;foldl&lt;/code&gt; ), присутствующую в различных языках программирования функционального разнообразия. Вызов &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; первые ЦЕССИОНАРИИ &lt;code&gt;seed&lt;/code&gt; к внутренней переменной &lt;code&gt;result&lt;/code&gt; , называемым также аккумулятором. Тогда для каждого элемента &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;result = fun(result, x)&lt;/code&gt; получает оценку. Наконец, &lt;code&gt;result&lt;/code&gt; возвращается. Версия с одним аргументом &lt;code&gt;fold!(fun)(range)&lt;/code&gt; работает аналогично, но в качестве начального числа используется первый элемент диапазона (диапазон должен быть не пустым).</target>
        </trans-unit>
        <trans-unit id="3a102abac10f402f998c7a93f6d1ecbc38ae5d29" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. There is also &lt;a href=&quot;#fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; which does the same thing but with the opposite parameter order. The call &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">Реализует функцию омонима (также известную как &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; или &lt;code&gt;foldl&lt;/code&gt; ), присутствующую в различных языках программирования функционального разнообразия. Существует также &lt;a href=&quot;#fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; которая делает то же самое, но с противоположным порядком параметров. Вызов &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; сначала присваивает &lt;code&gt;seed&lt;/code&gt; внутренней переменной &lt;code&gt;result&lt;/code&gt; , также называемой аккумулятором. Тогда для каждого элемента &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;result = fun(result, x)&lt;/code&gt; получает оценку. Наконец, &lt;code&gt;result&lt;/code&gt; возвращается. Версия с одним аргументом &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; работает аналогично, но в качестве начального числа используется первый элемент диапазона (диапазон должен быть не пустым).</target>
        </trans-unit>
        <trans-unit id="d222f5f35083b3fe479ec859b88f2b5c2d29bc99" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;transform&lt;/code&gt;) present in many languages of functional flavor. The call &lt;code&gt;map!(fun)(range)&lt;/code&gt; returns a range of which elements are obtained by applying &lt;code&gt;fun(a)&lt;/code&gt; left to right for all elements &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. The original ranges are not changed. Evaluation is done lazily.</source>
          <target state="translated">Реализует функцию омонима (также известную как &lt;code&gt;transform&lt;/code&gt; ), присутствующую во многих языках функционального разнообразия. Карта вызовов &lt;code&gt;map!(fun)(range)&lt;/code&gt; возвращает диапазон, элементы которого получаются путем применения &lt;code&gt;fun(a)&lt;/code&gt; слева направо для всех элементов &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; . Исходные диапазоны не изменены. Оценка делается лениво.</target>
        </trans-unit>
        <trans-unit id="38aa73eed2ebaa6990e6725195bf642f0bb7894e" translate="yes" xml:space="preserve">
          <source>Implements the most derived interface that &lt;code&gt;R&lt;/code&gt; works with and wraps all relevant range primitives in virtual functions. If &lt;code&gt;R&lt;/code&gt; is already derived from the &lt;code&gt;InputRange&lt;/code&gt; interface, aliases itself away.</source>
          <target state="translated">Реализует наиболее производный интерфейс, с которым работает &lt;code&gt;R&lt;/code&gt; , и упаковывает все соответствующие примитивы диапазона в виртуальные функции. Если &lt;code&gt;R&lt;/code&gt; уже получен из интерфейса &lt;code&gt;InputRange&lt;/code&gt; , псевдонимы удаляются.</target>
        </trans-unit>
        <trans-unit id="0aed3bb7204f0f1333835ef5bde3ef0b25325996" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">Реализует примитив интерфейса диапазона &lt;code&gt;back&lt;/code&gt; для встроенных массивов. В связи с тем, что функции, не &lt;code&gt;array.back&lt;/code&gt; членами, могут вызываться с первым аргументом с использованием точечной нотации, array.back эквивалентен &lt;code&gt;back(array)&lt;/code&gt; . Для &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;узких строк&lt;/a&gt; , &lt;code&gt;back&lt;/code&gt; автоматически возвращает последнюю &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;точку коды&lt;/a&gt; в качестве &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b532541671d15b35cef77598c086f1da87e05be3" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;empty&lt;/code&gt; for types that obey &lt;a href=&quot;#hasLength&quot;&gt;&lt;code&gt;hasLength&lt;/code&gt;&lt;/a&gt; property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;a.empty&lt;/code&gt; is equivalent to &lt;code&gt;empty(a)&lt;/code&gt;.</source>
          <target state="translated">Реализует &lt;code&gt;empty&lt;/code&gt; примитив интерфейса диапазона для типов, которые подчиняются свойству &lt;a href=&quot;#hasLength&quot;&gt; &lt;code&gt;hasLength&lt;/code&gt; ,&lt;/a&gt; и для узких строк. В связи с тем, что функции, не &lt;code&gt;a.empty&lt;/code&gt; членами, могут вызываться с первым аргументом с использованием точечной нотации, a.empty эквивалентно &lt;code&gt;empty(a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d00f3658d0160b41b82721ed86515030421a62" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">Реализует интерфейс диапазона примитивные &lt;code&gt;front&lt;/code&gt; для встроенных массивов. В связи с тем, что функции, не &lt;code&gt;array.front&lt;/code&gt; членами, могут вызываться с первым аргументом с использованием точечной нотации, array.front эквивалентен &lt;code&gt;front(array)&lt;/code&gt; . Для &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;узких строк&lt;/a&gt; , &lt;code&gt;front&lt;/code&gt; автоматически возвращает первую &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;кодовую точку&lt;/a&gt; как &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1778775edc47d955b8410b9303b511a8ed36740" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="translated">Реализует примитив &lt;code&gt;popBack&lt;/code&gt; интерфейса диапазона для встроенных массивов. В связи с тем, что функции, не &lt;code&gt;array.popBack&lt;/code&gt; членами, могут вызываться с первым аргументом с использованием точечной нотации, array.popBack эквивалентен &lt;code&gt;popBack(array)&lt;/code&gt; . Для &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;узких строк&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; автоматически устраняет последнюю &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;точку коды&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32e1749a7e79cab97db7229f8dfe1c2b12d27951" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="translated">Реализует примитив интерфейса диапазона &lt;code&gt;popFront&lt;/code&gt; для встроенных массивов. В связи с тем, что функции, не &lt;code&gt;array.popFront&lt;/code&gt; членами, могут вызываться с первым аргументом с использованием точечной нотации, array.popFront эквивалентна &lt;code&gt;popFront(array)&lt;/code&gt; . Для &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;узких строк&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; автоматически переходит к следующему пункту кода.</target>
        </trans-unit>
        <trans-unit id="75f6fe2cdac67a27b3428234729f0d9dae7b1837" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;save&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.save&lt;/code&gt; is equivalent to &lt;code&gt;save(array)&lt;/code&gt;. The function does not duplicate the content of the array, it simply returns its argument.</source>
          <target state="translated">Реализует &lt;code&gt;save&lt;/code&gt; примитива интерфейса диапазона для встроенных массивов. В связи с тем, что функции, не &lt;code&gt;array.save&lt;/code&gt; членами, могут вызываться с первым аргументом с использованием точечной нотации, array.save эквивалентен &lt;code&gt;save(array)&lt;/code&gt; . Функция не дублирует содержимое массива, она просто возвращает свой аргумент.</target>
        </trans-unit>
        <trans-unit id="03be7c6392b5500acdd65ba4a7628363c1860d1b" translate="yes" xml:space="preserve">
          <source>Implicit Conversion of Reference Types</source>
          <target state="translated">Неявное преобразование эталонных типов</target>
        </trans-unit>
        <trans-unit id="65a63aa075b83c2fd9eb74a28a95e05ff02e65a6" translate="yes" xml:space="preserve">
          <source>Implicit Conversions</source>
          <target state="translated">Неявные преобразования</target>
        </trans-unit>
        <trans-unit id="625a5d30e95ccd8e77f05af4dd624ce180fd702c" translate="yes" xml:space="preserve">
          <source>Implicit Nesting</source>
          <target state="translated">Неявное вложение</target>
        </trans-unit>
        <trans-unit id="341437e8c6d229adb9641f4f980b4bd232dec666" translate="yes" xml:space="preserve">
          <source>Implicit Qualifier Conversions</source>
          <target state="translated">Неявные преобразования квалификаторов</target>
        </trans-unit>
        <trans-unit id="e71105f02c13309129677ece5605a0283f9f1fad" translate="yes" xml:space="preserve">
          <source>Implicit Type Inference</source>
          <target state="translated">Неявный вывод типа</target>
        </trans-unit>
        <trans-unit id="849cfc1637b33ec7b03284c956943ea3a6ee1ec6" translate="yes" xml:space="preserve">
          <source>Implicit conversions are used to automatically convert types as required.</source>
          <target state="translated">Неявные преобразования используются для автоматического преобразования типов по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="16ca50dfa8d5e344f045161409c8efa6033ef01d" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue, like &lt;code&gt;toString&lt;/code&gt;, but also passes</source>
          <target state="translated">Неявно вызывает &lt;code&gt;toJSON&lt;/code&gt; для этого JSONValue, как &lt;code&gt;toString&lt;/code&gt; , но также передает</target>
        </trans-unit>
        <trans-unit id="61b604cd0d4af75ee155d0f29fe03ab209cdf393" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue.</source>
          <target state="translated">Неявно вызывает &lt;code&gt;toJSON&lt;/code&gt; для этого JSONValue.</target>
        </trans-unit>
        <trans-unit id="fe09202f421258205fc0af0f7cc90ba8af70d44d" translate="yes" xml:space="preserve">
          <source>Import Declaration</source>
          <target state="translated">импортная декларация</target>
        </trans-unit>
        <trans-unit id="07b4de4b6291e3b54e69fe2f2020c76048ffb706" translate="yes" xml:space="preserve">
          <source>Import Expressions</source>
          <target state="translated">Импортные экспрессии</target>
        </trans-unit>
        <trans-unit id="9633d9e6ebf62f84de8d5fc4824a9ee44e1f1708" translate="yes" xml:space="preserve">
          <source>Import declarations may be used at any scope. For example:</source>
          <target state="translated">Импортные декларации могут использоваться в любой сфере применения.Например:</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="015ce9a6eb4a1d7698028975a16c0fe2ee6d7aa2" translate="yes" xml:space="preserve">
          <source>Improve behavior of allocators sensitive to allocation sizes, such as &lt;code&gt;FreeList&lt;/code&gt; and &lt;code&gt;FreeTree&lt;/code&gt;. Rounding allocation requests up makes for smaller free lists/trees at the cost of slack memory (internal fragmentation).</source>
          <target state="translated">Улучшение поведения распределителей, чувствительных к размерам размещения, таких как &lt;code&gt;FreeList&lt;/code&gt; и &lt;code&gt;FreeTree&lt;/code&gt; . Округление запросов на выделение ресурсов приводит к уменьшению свободных списков / деревьев за счет нехватки памяти (внутренняя фрагментация)</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="dcd96af0868ef4c663e6ad3dcef261c5095893f1" translate="yes" xml:space="preserve">
          <source>In C, arrays are passed to functions as pointers even if the function prototype says its an array. In D, static arrays are passed by value, not by reference. Thus, the function prototype must be adjusted to match what C expects.</source>
          <target state="translated">В языке Си массивы передаются в функции в качестве указателей,даже если прототип функции говорит,что это массив.В D статические массивы передаются не по ссылке,а по значению.Таким образом,прототип функции должен быть настроен в соответствии с ожиданиями С.</target>
        </trans-unit>
        <trans-unit id="fb107b811fc18be0d73632390771a7270ede12ef" translate="yes" xml:space="preserve">
          <source>In Expressions</source>
          <target state="translated">Выражениями</target>
        </trans-unit>
        <trans-unit id="98ab2686a50e4805c42c072cadd55e7f182ad96a" translate="yes" xml:space="preserve">
          <source>In a Windows DLL, if this function is called via DllMain with argument DLL_PROCESS_DETACH, the thread is terminated forcefully without proper cleanup as a deadlock would happen otherwise.</source>
          <target state="translated">В Windows DLL,если эта функция вызывается через DllMain с аргументом DLL_PROCESS_DETACH,поток завершается принудительно без соответствующей очистки,так как в противном случае возникнет тупик.</target>
        </trans-unit>
        <trans-unit id="31b5ad319495b8bf3a1c002a8507f2abf1208f6d" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegate constructor.</source>
          <target state="translated">В теле конструктора, если вызывается конструктор делегата, все назначения полей считаются назначениями. В противном случае первым экземпляром назначения поля является его инициализация, а назначения формы &lt;code&gt;field = expression&lt;/code&gt; обрабатываются как эквивалентные &lt;code&gt;typeof(field)(expression)&lt;/code&gt; . Значения полей могут быть прочитаны перед инициализацией или построением с помощью конструктора делегата.</target>
        </trans-unit>
        <trans-unit id="58b4b4504d8850da0fbabfc52a3239ec3b0e0a33" translate="yes" xml:space="preserve">
          <source>In a constructor body, the first instance of field assignment is its initialization.</source>
          <target state="translated">В теле конструктора первой инстанцией назначения полей является его инициализация.</target>
        </trans-unit>
        <trans-unit id="3c66c503e379c4155d015b11fbc1dc5940286649" translate="yes" xml:space="preserve">
          <source>In a declaration declaring multiple symbols, all the declarations must be of the same type:</source>
          <target state="translated">В декларации,декларирующей несколько символов,все декларации должны быть одного типа:</target>
        </trans-unit>
        <trans-unit id="9e9fe9946b014b42fb5205022b5c12ede51b25c5" translate="yes" xml:space="preserve">
          <source>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one.</source>
          <target state="translated">В типичном приложении вы можете также подумать об использовании неблокирующего сокета вместо установки тайм-аута на блокирующем.</target>
        </trans-unit>
        <trans-unit id="190918005b49f5fd22012e2b51e50c26bb8bb06b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#Variant&quot;&gt;&lt;code&gt;Variant&lt;/code&gt;&lt;/a&gt;, this module also defines the &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; type constructor. Unlike &lt;code&gt;Variant&lt;/code&gt;, &lt;code&gt;Algebraic&lt;/code&gt; only allows a finite set of types, which are specified in the instantiation (e.g. &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; may only hold an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;).</source>
          <target state="translated">В дополнение к &lt;a href=&quot;#Variant&quot;&gt; &lt;code&gt;Variant&lt;/code&gt; &lt;/a&gt; этот модуль также определяет конструктор &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt; типов. В отличие от &lt;code&gt;Variant&lt;/code&gt; , &lt;code&gt;Algebraic&lt;/code&gt; допускает только конечный набор типов, которые указаны в экземпляре (например, &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; может содержать только &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;string&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd56298f652baf17103962e16813e3a6aed52cf4" translate="yes" xml:space="preserve">
          <source>In addition to convenience, these functions are slightly more efficient than manually creating an Fft object for a single use, as the Fft object is deterministically destroyed before these functions return.</source>
          <target state="translated">Помимо удобства,эти функции несколько более эффективны,чем ручное создание объекта Fft для однократного использования,так как объект Fft разрушается детерминированно до того,как эти функции вернутся.</target>
        </trans-unit>
        <trans-unit id="570c956c4c6e2dbde87f61ff5e2c49153a8df2e6" translate="yes" xml:space="preserve">
          <source>In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.</source>
          <target state="translated">В дополнение к генераторам случайных чисел в данном модуле имеются распределения,которые по-разному искажают статистическое распределение генератора на выходе.До сих пор реализовано равномерное распределение для целых и вещественных чисел.</target>
        </trans-unit>
        <trans-unit id="5295840dbe23153fe2e689d001aa6ebadfba5f26" translate="yes" xml:space="preserve">
          <source>In addition, --DRT-gcopt=help will show the list of options and their current settings.</source>
          <target state="translated">Кроме того,--DRT-gcopt=help покажет список опций и их текущие настройки.</target>
        </trans-unit>
        <trans-unit id="b2fcea4fb949d2ee554c72114c12b58084a4d18d" translate="yes" xml:space="preserve">
          <source>In addition, the data &lt;code&gt;callerSize&lt;/code&gt;, &lt;code&gt;callerModule&lt;/code&gt;, &lt;code&gt;callerFile&lt;/code&gt;, &lt;code&gt;callerLine&lt;/code&gt;, and &lt;code&gt;callerTime&lt;/code&gt; is associated with each specific allocation. This data prefixes each allocation.</source>
          <target state="translated">Кроме того, данные &lt;code&gt;callerSize&lt;/code&gt; , &lt;code&gt;callerModule&lt;/code&gt; , &lt;code&gt;callerFile&lt;/code&gt; , &lt;code&gt;callerLine&lt;/code&gt; и &lt;code&gt;callerTime&lt;/code&gt; связаны с каждым конкретным распределением. Эти данные префикс каждого распределения.</target>
        </trans-unit>
        <trans-unit id="8bb9d27fa1cfa7a17c0f438e8ee45a8ac856bdb5" translate="yes" xml:space="preserve">
          <source>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</source>
          <target state="translated">В алгоритмах разбиения на две части сохраните относительную последовательность элементов только слева от точки разбиения.</target>
        </trans-unit>
        <trans-unit id="a4c7a53fdd584b663429b65ac4f17edc28d07354" translate="yes" xml:space="preserve">
          <source>In all cases the function returns the built-in result of &lt;code&gt;lhs == rhs&lt;/code&gt;.</source>
          <target state="translated">Во всех случаях функция возвращает встроенный результат &lt;code&gt;lhs == rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a66898347b51f7c1d0527a1edb8a6b3cf367a27a" translate="yes" xml:space="preserve">
          <source>In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. &lt;code&gt;ulong&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt;) tracks the zero-based number of the current line.</source>
          <target state="translated">Во всех случаях также принимаются двухсимвольные версии, и в этом случае первый символ (целочисленного типа, например, &lt;code&gt;ulong&lt;/code&gt; или &lt;code&gt;uint&lt;/code&gt; ) отслеживает номер текущей строки , начинающийся с нуля.</target>
        </trans-unit>
        <trans-unit id="fb219f6585d8061af3f052a290762bb948e1e8d6" translate="yes" xml:space="preserve">
          <source>In all cases, returns &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt;. The result is not autocorrected in case of an erroneous comparison.</source>
          <target state="translated">Во всех случаях возвращает &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt; . Результат не исправляется автоматически в случае ошибочного сравнения.</target>
        </trans-unit>
        <trans-unit id="cb4bca7a9dd4559557c8f7c4ee56255838258c7f" translate="yes" xml:space="preserve">
          <source>In all cases, the concatenation of the returned ranges spans the entire &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">Во всех случаях конкатенация возвращаемых диапазонов охватывает весь &lt;code&gt;haystack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac8533d039fb2ca10f37bea36476dc0de1df00b" translate="yes" xml:space="preserve">
          <source>In all other cases, a simple element by element addition is done.</source>
          <target state="translated">Во всех остальных случаях выполняется простое добавление элементов за элементами.</target>
        </trans-unit>
        <trans-unit id="394148797f50691adb9a270f990a5eaca722863e" translate="yes" xml:space="preserve">
          <source>In all other cases, the built-in behavior is carried out.</source>
          <target state="translated">Во всех остальных случаях осуществляется встроенное поведение.</target>
        </trans-unit>
        <trans-unit id="b68e1d58907e07140ccd3efadbc43c332f170e2d" translate="yes" xml:space="preserve">
          <source>In all other respects this function works just like &lt;code&gt;spawnProcess&lt;/code&gt;. Please refer to the &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown.</source>
          <target state="translated">Во всех остальных отношениях эта функция работает так же, как &lt;code&gt;spawnProcess&lt;/code&gt; . Пожалуйста, обратитесь к документации &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; для описания других параметров функции, возвращаемого значения и любых исключений, которые могут быть выброшены.</target>
        </trans-unit>
        <trans-unit id="1cc108da5c2c3788f98a6edf95e1a63a36afb311" translate="yes" xml:space="preserve">
          <source>In all string literal forms, an &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; is regarded as a single &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">Во всех строковых литеральных формах &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; рассматривается как один символ &lt;code&gt;\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60b9a383afd7a0fd8bdda37a3d66b0a2bbb686e7" translate="yes" xml:space="preserve">
          <source>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc.</source>
          <target state="translated">Во всех остальных отношениях эти методы похожи на любые другие.Они могут быть статическими,иметь различные связи,иметь свой адрес и т.д.</target>
        </trans-unit>
        <trans-unit id="4560285d4cfc645e0ef24ee3db5890ff1443ed09" translate="yes" xml:space="preserve">
          <source>In both C++ and D, if a struct has zero fields, the struct still has a size of 1 byte. But, in C++ if the struct with zero fields is used as a base struct, its size is zero (called the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt;). There are two methods for emulating this behavior in D. The first forwards references to a function returning a faked reference to the base:</source>
          <target state="translated">И в C ++, и в D, если структура имеет нулевые поля, структура по-прежнему имеет размер 1 байт. Но в C ++, если структура с нулевыми полями используется в качестве базовой структуры, ее размер равен нулю (так называемая &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;пустая базовая оптимизация&lt;/a&gt; ). Есть два метода для эмуляции этого поведения в D. Первый перенаправляет ссылки на функцию, возвращающую поддельную ссылку на базу:</target>
        </trans-unit>
        <trans-unit id="b076421b0fbcae191c5dc3ef2368683aca391393" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier starting with &lt;code&gt; &quot;%(&quot;&lt;/code&gt; and ending with &lt;code&gt;&quot;%)&quot;&lt;/code&gt;, &lt;code&gt;_nested&lt;/code&gt; contains the string contained within the two separators.</source>
          <target state="translated">В случае составного спецификатора формата, начинающегося с &lt;code&gt; &quot;%(&quot;&lt;/code&gt; и заканчивающегося &lt;code&gt;&quot;%)&quot;&lt;/code&gt; , &lt;code&gt;_nested&lt;/code&gt; содержит строку, содержащуюся в двух разделителях.</target>
        </trans-unit>
        <trans-unit id="b3a4dc18e455dc36e9fd73a88e062b9df8c0d722" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier, &lt;code&gt;_sep&lt;/code&gt; contains the string positioning after &lt;code&gt;&quot;%|&quot;&lt;/code&gt;. &lt;code&gt;sep is null&lt;/code&gt; means no separator else &lt;code&gt;sep.empty&lt;/code&gt; means 0 length separator.</source>
          <target state="translated">В случае составного спецификатора формата &lt;code&gt;_sep&lt;/code&gt; содержит позиционирование строки после &lt;code&gt;&quot;%|&quot;&lt;/code&gt; , &lt;code&gt;sep is null&lt;/code&gt; означает отсутствие разделителя, иначе &lt;code&gt;sep.empty&lt;/code&gt; означает разделитель 0 длины.</target>
        </trans-unit>
        <trans-unit id="c172129354e9ba73756e23e6e1f6e0e605a52cb9" translate="yes" xml:space="preserve">
          <source>In case of a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; nothing will happen.</source>
          <target state="translated">В случае сообщения журнала с &lt;code&gt;LogLevel.fatal&lt;/code&gt; ничего не произойдет.</target>
        </trans-unit>
        <trans-unit id="3ebef375cea9cd0eca25afb26b6d5c11eab7f3f0" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">В случае ошибки ввода-вывода &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39a07628e75ba54420c0ee35d2d7947fae3e6e95" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;a href=&quot;#StdioException&quot;&gt;&lt;code&gt;StdioException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В случае ошибки ввода-вывода выдает &lt;a href=&quot;#StdioException&quot;&gt; &lt;code&gt;StdioException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c94ce1719c011e5c08b47d8a880eaa8ed1ab504" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">В случае ошибки ввода-вывода выдает &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="072442afd2ab0da30ef9131acbdaeefa3c16749b" translate="yes" xml:space="preserve">
          <source>In case you want to only enable bundling for some of the parameters, bundling can be turned off with &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите включить связывание только для некоторых параметров, связывание можно отключить с помощью &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d85046192eeac78a5da365dc7670fdea8d6e86" translate="yes" xml:space="preserve">
          <source>In cases where producing the replacement is the ultimate goal &lt;a href=&quot;#replaceFirstInto&quot;&gt;&lt;code&gt;replaceFirstInto&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAllInto&quot;&gt;&lt;code&gt;replaceAllInto&lt;/code&gt;&lt;/a&gt; could come in handy as functions that avoid allocations even for replacement.</source>
          <target state="translated">В тех случаях, когда создание замены является конечной целью, &lt;a href=&quot;#replaceFirstInto&quot;&gt; &lt;code&gt;replaceFirstInto&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#replaceAllInto&quot;&gt; &lt;code&gt;replaceAllInto&lt;/code&gt; &lt;/a&gt; могут пригодиться в качестве функций, которые избегают выделения даже для замены.</target>
        </trans-unit>
        <trans-unit id="e6177e81e2c8557108ce3bebc0ad228b2a46f372" translate="yes" xml:space="preserve">
          <source>In cases where the operand size is ambiguous, as in:</source>
          <target state="translated">В случаях,когда размер операнда неоднозначен,как,например:</target>
        </trans-unit>
        <trans-unit id="a7faf0c1f2db2bcd1f30944e523bc6e5d4329044" translate="yes" xml:space="preserve">
          <source>In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</source>
          <target state="translated">В тех случаях,когда рассматриваемая строка уже нормализована,она возвращается немодифицированной и выделения памяти не происходит.</target>
        </trans-unit>
        <trans-unit id="7c2d083ad99e82982be1c8520585485c563982d6" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;__delete(x)&lt;/code&gt; returns with no effect if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. Otherwise, it performs the following actions in sequence:</source>
          <target state="translated">Подробно, &lt;code&gt;__delete(x)&lt;/code&gt; возвращается без эффекта, если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;null&lt;/code&gt; . В противном случае он последовательно выполняет следующие действия:</target>
        </trans-unit>
        <trans-unit id="1a253df89cf875b96f6b0b99a704c14478bd5687" translate="yes" xml:space="preserve">
          <source>In effect &lt;code&gt;takeOne(r)&lt;/code&gt; is somewhat equivalent to &lt;code&gt;take(r, 1)&lt;/code&gt; but in certain interfaces it is important to know statically that the range may only have at most one element.</source>
          <target state="translated">По сути, &lt;code&gt;takeOne(r)&lt;/code&gt; в некоторой степени эквивалентен &lt;code&gt;take(r, 1)&lt;/code&gt; но в определенных интерфейсах важно знать статически, что диапазон может содержать не более одного элемента.</target>
        </trans-unit>
        <trans-unit id="c7e90e95cc2e5d025786e563cb98d86e57f261c9" translate="yes" xml:space="preserve">
          <source>In either case, the content of the buffer is reused across calls. That means &lt;code&gt;front&lt;/code&gt; will not persist after &lt;code&gt;popFront&lt;/code&gt; is called, so if retention is needed, the caller must copy its contents (e.g. by calling &lt;code&gt;buffer.dup&lt;/code&gt;).  In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  With the mentioned limitations, &lt;code&gt;byChunk&lt;/code&gt; works with any algorithm compatible with input ranges.</source>
          <target state="translated">В любом случае содержимое буфера повторно используется в вызовах. Это означает, что &lt;code&gt;front&lt;/code&gt; не будет сохраняться после &lt;code&gt;popFront&lt;/code&gt; , поэтому, если требуется сохранение, вызывающая &lt;code&gt;buffer.dup&lt;/code&gt; должна скопировать его содержимое (например, вызвав buffer.dup ). В приведенном выше примере параметр &lt;code&gt;buffer.length&lt;/code&gt; равен 4096 для всех итераций, кроме последней, в этом случае значение &lt;code&gt;buffer.length&lt;/code&gt; может быть меньше 4096 (но всегда больше нуля). С упомянутыми ограничениями &lt;code&gt;byChunk&lt;/code&gt; работает с любым алгоритмом, совместимым с диапазонами ввода.</target>
        </trans-unit>
        <trans-unit id="8ec7633257f9bdb307965ba1607259244c489e1d" translate="yes" xml:space="preserve">
          <source>In free list mode, &lt;code&gt;KRRegion&lt;/code&gt; embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</source>
          <target state="translated">В режиме свободного списка &lt;code&gt;KRRegion&lt;/code&gt; встраивает список свободных блоков в кусок памяти. Свободный список является круглым, объединенным и сортируется по адресу в любое время. Распределение и освобождение занимают время, пропорциональное количеству ранее освобожденных блоков. (На практике стоимость может быть ниже, например, если память освобождается в обратном порядке выделения, все операции занимают постоянное время.) Использование памяти хорошее (небольшая структура управления и никаких накладных расходов на распределение). Недостатки режима freelist включают предрасположенность к фрагментации, минимальный размер выделения в два слова и линейное время выделения и освобождения в худшем случае.</target>
        </trans-unit>
        <trans-unit id="cdf7807c516e1443dffb3bd59e60f6a917c9df07" translate="yes" xml:space="preserve">
          <source>In function scopes, imported symbols only become visible after the import declaration lexically appears in the function body. In other words, imported symbols at function scope cannot be forward referenced.</source>
          <target state="translated">В функциональных диапазонах импортируемые символы становятся видимыми только после того,как в теле функции лексически появляется импортная декларация.Другими словами,на импортируемые символы в области действия функции нельзя ссылаться напрямую.</target>
        </trans-unit>
        <trans-unit id="c0383119e4652a168035af7434f3705bce886b19" translate="yes" xml:space="preserve">
          <source>In functional programming languages this is typically called &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanl&lt;/code&gt;, &lt;code&gt;scanLeft&lt;/code&gt; or &lt;code&gt;reductions&lt;/code&gt;.</source>
          <target state="translated">В функциональных языках программирования это обычно называется &lt;code&gt;scan&lt;/code&gt; , &lt;code&gt;scanl&lt;/code&gt; , &lt;code&gt;scanLeft&lt;/code&gt; или &lt;code&gt;reductions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb398e80e5a7daebe5fe79cc756231990bf0b4c" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="translated">В общем случае следует всегда ждать завершения дочерних процессов, прежде чем выходить из родительского процесса, если только процесс не был порожден как отсоединенный (который был порожден флагом &lt;code&gt;Config.detached&lt;/code&gt; ). В противном случае они могут стать &amp;laquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;зомби&lt;/a&gt; &amp;raquo; - процессами, которые больше не существуют, но все еще занимают место в таблице процессов ОС. Вы не должны и не должны ждать отдельных процессов, поскольку вы не являетесь их владельцем.</target>
        </trans-unit>
        <trans-unit id="2a9fd3d1c20814161b33ee0afa7c06fcf185414e" translate="yes" xml:space="preserve">
          <source>In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; distinct states but after &lt;code&gt;seed(uint)&lt;/code&gt; is called it can only be in one of &lt;code&gt;2 ^^ 32&lt;/code&gt; distinct states regardless of how excellent the source of entropy is.</source>
          <target state="translated">В целом, периодический &amp;laquo;повторный посев&amp;raquo; ГСЧП не улучшает его качество и в некоторых случаях может нанести ему вред. Для крайнего примера Twister Mersenne имеет &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; отличное состояние, но после вызова &lt;code&gt;seed(uint)&lt;/code&gt; он может находиться только в одном из &lt;code&gt;2 ^^ 32&lt;/code&gt; различных состояний независимо от того, насколько превосходен источник энтропии.</target>
        </trans-unit>
        <trans-unit id="fc32a5290aa168583cf02dd9b13039ee5589d851" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#isValidPath&quot;&gt;&lt;code&gt;isValidPath&lt;/code&gt;&lt;/a&gt; functions to check this.</source>
          <target state="translated">В общем, функции в этом модуле предполагают, что входные пути правильно сформированы. (То есть они не должны содержать недопустимых символов, они должны соответствовать формату пути файловой системы и т. Д.) Результат вызова функции по неверно сформированному пути не определен. Когда существует вероятность того, что путь или имя файла недопустимы (например, когда он был &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; пользователем), иногда может быть желательно использовать функции isValidFilename и &lt;a href=&quot;#isValidPath&quot;&gt; &lt;code&gt;isValidPath&lt;/code&gt; &lt;/a&gt; для проверки этого.</target>
        </trans-unit>
        <trans-unit id="7566506eebd3c530fd7b49f9458b9e3829cd9289" translate="yes" xml:space="preserve">
          <source>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</source>
          <target state="translated">Во многих случаях вызовы sizeof()не могут быть использованы непосредственно для получения размеров типов данных,так как поддерживается кросс-компиляция,и в конечном итоге используются размеры хостов,а не целевые размеры.</target>
        </trans-unit>
        <trans-unit id="35dd64591779170e8008d349dad053c6fa8f2446" translate="yes" xml:space="preserve">
          <source>In nested</source>
          <target state="translated">В гнезде</target>
        </trans-unit>
        <trans-unit id="8575ac5b58d78f8ffa7cfeed41b65f5b48950967" translate="yes" xml:space="preserve">
          <source>In older versions of Phobos, it used to be possible to write:</source>
          <target state="translated">В старых версиях Phobos было возможно писать:</target>
        </trans-unit>
        <trans-unit id="2e095fc6159a0d37540c3fe665eef32c69ad9690" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;Logger&lt;/code&gt; must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы данные , которые будут обработан &lt;code&gt;LogLevel&lt;/code&gt; из &lt;code&gt;Logger&lt;/code&gt; должно быть больше или равно глобальной &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60952b4bdab4bfb5f5a8d1d83bb07430530eeffe" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; add the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы данные , которые будут обрабатывается &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;sharedLog&lt;/code&gt; должно быть больше или равно &lt;code&gt;defaultLogLevel&lt;/code&gt; добавить условие прошло должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e11fddcd19d6f16f616c57c6e260430b0f9d9a4" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы данные , которые будут обработана &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;sharedLog&lt;/code&gt; должно быть больше или равно &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8c65e46c163f6fc77fddc2b9a77d78f4961ef7" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы данные, подлежащие обработке в &lt;code&gt;LogLevel&lt;/code&gt; лог вызова должно быть больше или равно &lt;code&gt;LogLevel&lt;/code&gt; из &lt;code&gt;sharedLog&lt;/code&gt; и &lt;code&gt;defaultLogLevel&lt;/code&gt; дополнительно условие прошло должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed49a17d9874b268342f0db2f71435916af05001" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы данные, подлежащие обработке в &lt;code&gt;LogLevel&lt;/code&gt; лог вызова должно быть больше или равно &lt;code&gt;LogLevel&lt;/code&gt; из &lt;code&gt;sharedLog&lt;/code&gt; и &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c93e7b85e99ec02f5d168562dae2b831dda8259" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы данные, подлежащие обработке в &lt;code&gt;LogLevel&lt;/code&gt; лог вызова должно быть больше или равно &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;sharedLog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f87139f757185970527b89c7ad28046b560c58f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Чтобы данные обрабатывались, &lt;code&gt;LogLevel&lt;/code&gt; вызова журнала должен быть больше или равен &lt;code&gt;defaultLogLevel&lt;/code&gt; . Кроме того, переданное условие должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a54f9edb0000f15c332443c24f6eb668c55c8501" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">Для обработки данных &lt;code&gt;LogLevel&lt;/code&gt; вызова журнала должен быть больше или равен &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14b107fabc6c81ab2222b96dfa0c1ecd6dfba19f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed, the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Чтобы данные были обработаны, &lt;code&gt;LogLevel&lt;/code&gt; вызова журнала должен быть больше или равен &lt;code&gt;LogLevel&lt;/code&gt; для &lt;code&gt;sharedLog&lt;/code&gt; и &lt;code&gt;defaultLogLevel&lt;/code&gt; ; кроме того , состояние должно находиться в &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb3ac7d5c9d6c962a9241e9025396626aa9beb6" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы в результате сообщения журнала , которые будут перенесены на &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;sharedLog&lt;/code&gt; и должно быть больше или равно , чем глобальная &lt;code&gt;LogLevel&lt;/code&gt; . Дополнительно &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79abe30476f4ca10a8c01c609e3f868cb8a10f27" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;. If a condition is given, it must evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для того , чтобы в результате сообщения журнала , которые будут перенесены на &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;stdThreadLocalLog&lt;/code&gt; и должно быть больше или равно , чем глобальная &lt;code&gt;LogLevel&lt;/code&gt; . Дополнительно &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;stdSharedLogger&lt;/code&gt; . Если задано условие, оно должно оцениваться как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18e494163438a3079c18b40fa80b56a34c4d5c22" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Чтобы полученное в результате сообщение журнала было зарегистрировано, &lt;code&gt;LogLevel&lt;/code&gt; должен быть больше или равен &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; и должен быть больше или равен глобальному &lt;code&gt;LogLevel&lt;/code&gt; . Кроме того, переданное условие должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b84c1fc96a4a1e141069ab63dfce487512e519" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the passed condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Чтобы полученное в результате сообщение журнала было зарегистрировано, &lt;code&gt;LogLevel&lt;/code&gt; должен быть больше или равен &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; и должен быть больше или равен глобальному &lt;code&gt;LogLevel&lt;/code&gt; . Кроме того, переданное условие должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8530a345a9b66847038330015135156125389c" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Чтобы полученное сообщение журнала было зарегистрировано, &lt;code&gt;LogLevel&lt;/code&gt; должен быть больше или равен &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; и должен быть больше или равен глобальному &lt;code&gt;LogLevel&lt;/code&gt; , и условие должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b9f3f3bdcf58be250caee88b15a55353fecc84" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Чтобы полученное сообщение журнала было зарегистрировано, &lt;code&gt;LogLevel&lt;/code&gt; должен быть больше или равен &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; и должен быть больше или равен глобальному &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41a290703568517f05854f40487a48abaf094d9a" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Чтобы полученное в результате сообщение журнала было зарегистрировано, &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; должен быть больше или равен глобальному &lt;code&gt;LogLevel&lt;/code&gt; , и условие должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61c93a13b86326686a55e702c7620856cee5be12" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Чтобы полученное сообщение журнала было зарегистрировано, &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; должен быть больше или равен глобальному &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9091984c8dee40a3793a920b8fc726ff3fb2b605" translate="yes" xml:space="preserve">
          <source>In order to be usable as an allocator, a type should implement the following methods with their respective semantics. Only &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;allocate&lt;/code&gt; are required. If any of the other methods is missing, the allocator is assumed to not have that capability (for example some allocators do not offer manual deallocation of memory). Allocators should NOT implement unsupported methods to always fail. For example, an allocator that lacks the capability to implement &lt;code&gt;alignedAllocate&lt;/code&gt; should not define it at all (as opposed to defining it to always return &lt;code&gt;null&lt;/code&gt; or throw an exception). The missing implementation statically informs other components about the allocator's capabilities and allows them to make design decisions accordingly.</source>
          <target state="translated">Чтобы использовать его в качестве распределителя, тип должен реализовывать следующие методы с соответствующей семантикой. Требуется только &lt;code&gt;alignment&lt;/code&gt; и &lt;code&gt;allocate&lt;/code&gt; . Если какой-либо из других методов отсутствует, предполагается, что распределитель не имеет такой возможности (например, некоторые распределители не предлагают ручное освобождение памяти). Распределители НЕ должны реализовывать неподдерживаемые методы, чтобы всегда терпеть неудачу. Например, распределитель, который не имеет возможности реализовать &lt;code&gt;alignedAllocate&lt;/code&gt; не должен определять его вообще (в отличие от определения, чтобы он всегда возвращал &lt;code&gt;null&lt;/code&gt; или выбрасывал исключение). Отсутствующая реализация статически информирует другие компоненты о возможностях распределителя и позволяет им соответствующим образом принимать проектные решения.</target>
        </trans-unit>
        <trans-unit id="6dda110f1f25b5663505eb11f44cd82e44a8c31d" translate="yes" xml:space="preserve">
          <source>In order to determine if an object &lt;code&gt;o&lt;/code&gt; is an instance of a class &lt;code&gt;B&lt;/code&gt; use a cast:</source>
          <target state="translated">Чтобы определить, является ли объект &lt;code&gt;o&lt;/code&gt; экземпляром класса &lt;code&gt;B&lt;/code&gt; , используйте приведение:</target>
        </trans-unit>
        <trans-unit id="1e18ff30e3740b378cdaf28cc4934f896ccbee30" translate="yes" xml:space="preserve">
          <source>In order to disable logging at compile time, pass &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; as a version argument to the &lt;code&gt;D&lt;/code&gt; compiler when compiling your program code. This will disable all logging functionality. Specific &lt;code&gt;LogLevel&lt;/code&gt; can be disabled at compile time as well. In order to disable logging with the &lt;code&gt;trace&lt;/code&gt;&lt;code&gt;LogLevel&lt;/code&gt; pass &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; as a version. The following table shows which version statement disables which &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Чтобы отключить ведение журнала во время компиляции, передайте &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; в качестве аргумента версии компилятору &lt;code&gt;D&lt;/code&gt; при компиляции программного кода. Это отключит все функции ведения журнала. Определенный &lt;code&gt;LogLevel&lt;/code&gt; также может быть отключен во время компиляции. Чтобы отключить ведение журнала с помощью &lt;code&gt;trace&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; , передайте &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; в качестве версии. В следующей таблице показано, какой оператор версии отключает какой &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a77a52d87761074b435f02e38ba4ed22e517df1c" translate="yes" xml:space="preserve">
          <source>In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size.</source>
          <target state="translated">Для того,чтобы сделать длину спереди,мы должны предоставить 16 байт буферного пространства на случай,если блок должен быть выровнен правильно.В x86 некоторые SSE-инструкции будут работать только в том случае,если данные выровнены на 16 байт.Кроме того,нам нужен сторожевой байт,чтобы предотвратить случайные указатели на следующий блок.Из-за дополнительных накладных расходов мы делаем это только для размера страницы и выше,где накладные расходы минимальны по сравнению с размером блока.</target>
        </trans-unit>
        <trans-unit id="0cc93ffa6b67fa20835799cad3635970d48f4206" translate="yes" xml:space="preserve">
          <source>In order to work, &lt;code&gt;FallbackAllocator&lt;/code&gt; requires that &lt;code&gt;Primary&lt;/code&gt; defines the &lt;code&gt;owns&lt;/code&gt; method. This is needed in order to decide which allocator was responsible for a given allocation.</source>
          <target state="translated">Для работы &lt;code&gt;FallbackAllocator&lt;/code&gt; требуется, чтобы &lt;code&gt;Primary&lt;/code&gt; определял метод &lt;code&gt;owns&lt;/code&gt; . Это необходимо для того, чтобы решить, какой распределитель был ответственным за данное распределение.</target>
        </trans-unit>
        <trans-unit id="3cb2dd17fb05bd389b6b34ea2ea85ffe8dc6328a" translate="yes" xml:space="preserve">
          <source>In other words, casting literal expression will change the literal type.</source>
          <target state="translated">Другими словами,приведение буквенного выражения изменит тип буквы.</target>
        </trans-unit>
        <trans-unit id="675933f346891ba4fb04a779eea3dd5e21b2c0bb" translate="yes" xml:space="preserve">
          <source>In previous versions of Phobos, this was known as &lt;code&gt;TypeTuple&lt;/code&gt;.</source>
          <target state="translated">В предыдущих версиях Фобоса это было известно как &lt;code&gt;TypeTuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26154800831f1a5ff6a19e1167b2ddcacfdb1c76" translate="yes" xml:space="preserve">
          <source>In principle, only thrown objects derived from this class are safe to catch inside a &lt;code&gt;catch&lt;/code&gt; block. Thrown objects not derived from Exception represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</source>
          <target state="translated">В принципе, только брошенные объекты, полученные из этого класса, безопасны для захвата внутри блока &lt;code&gt;catch&lt;/code&gt; . Брошенные объекты, не производные от Exception, представляют ошибки времени выполнения, которые не должны быть перехвачены, поскольку некоторые гарантии времени выполнения могут не сохраняться, что делает небезопасным продолжение выполнения программы.</target>
        </trans-unit>
        <trans-unit id="0b93464d0fbabeded10a475db02ab91f9147bd5b" translate="yes" xml:space="preserve">
          <source>In principle, this is the name of the local time zone. However, this always returns the empty string. This is because time zones cannot be uniquely identified by the attributes given by the OS (such as the &lt;code&gt;stdName&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt;), and neither Posix systems nor Windows systems provide an easy way to get the TZ Database name of the local time zone.</source>
          <target state="translated">В принципе, это название местного часового пояса. Однако это всегда возвращает пустую строку. Это связано с тем, что часовые пояса не могут быть однозначно идентифицированы атрибутами, заданными ОС (такими как &lt;code&gt;stdName&lt;/code&gt; и &lt;code&gt;dstName&lt;/code&gt; ), и ни системы Posix , ни системы Windows не обеспечивают простой способ получить имя базы данных TZ для местного часового пояса.</target>
        </trans-unit>
        <trans-unit id="0b9fb0301ede6ae1f71c55d50ab376078de554f8" translate="yes" xml:space="preserve">
          <source>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'.</source>
          <target state="translated">В режиме одной строки соответствует любому символу.В противном случае он совпадает с любым символом,кроме '\n' и '\r'.</target>
        </trans-unit>
        <trans-unit id="77c1db69e3f99eb322088fa8127b36e0134ab790" translate="yes" xml:space="preserve">
          <source>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000).</source>
          <target state="translated">При некоторых вычислениях даты,добавление месяцев или лет может привести к тому,что дата выпадает на день месяца,который не является действительным (например,29 февраля 2001 г.или 31 июня 2000 г.).Если переполнение разрешено (как по умолчанию),то месяц будет соответственно увеличен (так,29 февраля 2001 года стало бы 1 марта 2001 года,а 31 июня 2000 года-1 июля 2000 года).Если переполнение не разрешено,то день будет скорректирован до последнего действительного дня в этом месяце (таким образом,29 февраля 2001 года стало бы 28 февраля 2001 года,а 31 июня 2000 года-30 июня 2000 года).</target>
        </trans-unit>
        <trans-unit id="0f7765db47c238a56000c8a0537e8a769de4649d" translate="yes" xml:space="preserve">
          <source>In std.datetime, it is also used as the result of various arithmetic operations on time points.</source>
          <target state="translated">В std.datetime он также используется в результате различных арифметических операций над временными точками.</target>
        </trans-unit>
        <trans-unit id="9d8f072b0ee81fd114d71e25f9472d419503fd30" translate="yes" xml:space="preserve">
          <source>In the above situations the errors do not contain line numbers because the errors are regarding generated code.</source>
          <target state="translated">В описанных выше ситуациях ошибки не содержат номеров строк,так как ошибки касаются сгенерированного кода.</target>
        </trans-unit>
        <trans-unit id="83c0d2545855dad1e2136f8a2d0797213523dbd3" translate="yes" xml:space="preserve">
          <source>In the case above, the element at slot &lt;code&gt;1&lt;/code&gt; is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, &lt;code&gt;remove&lt;/code&gt; moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function.</source>
          <target state="translated">В случае выше, элемент в слоте &lt;code&gt;1&lt;/code&gt; удаляется, но заменяется последним элементом диапазона. Воспользовавшись ослаблением требования стабильности, &lt;code&gt;remove&lt;/code&gt; перемещенные элементы с конца массива над пазами, которые необходимо удалить. Таким образом, требуется меньше перемещения данных, что сокращает время выполнения функции.</target>
        </trans-unit>
        <trans-unit id="d1310273f42b4567d006ba733761bffcc94a7323" translate="yes" xml:space="preserve">
          <source>In the case of multisets, considering that element &lt;code&gt;a&lt;/code&gt; appears &lt;code&gt;x&lt;/code&gt; times in &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; times and &lt;code&gt;r2&lt;/code&gt;, the number of occurences of &lt;code&gt;a&lt;/code&gt; in the resulting range is going to be &lt;code&gt;x-y&lt;/code&gt; if x &amp;gt; y or 0 otherwise.</source>
          <target state="translated">В случае мультимножеств, учитывая, что элемент &lt;code&gt;a&lt;/code&gt; появляется &lt;code&gt;x&lt;/code&gt; раз в &lt;code&gt;r1&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; раз и &lt;code&gt;r2&lt;/code&gt; , число вхождений &lt;code&gt;a&lt;/code&gt; в результирующий диапазон будет равно &lt;code&gt;x-y&lt;/code&gt; если x&amp;gt; y или 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="574341dd05f59907247dd44e449ed7bd5386146b" translate="yes" xml:space="preserve">
          <source>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range.</source>
          <target state="translated">В случае мультисетов диапазон с минимальным количеством случаев данного элемента переносит количество случаев этого элемента в результирующий диапазон.</target>
        </trans-unit>
        <trans-unit id="c31bb38a42ef0f5a89fce05942de3e9a5d76ab7c" translate="yes" xml:space="preserve">
          <source>In the case of the monotonic time, &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; is templatized on &lt;code&gt;ClockType&lt;/code&gt;, whereas with &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; object, whereas with &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;, its resolution is always hecto-nanoseconds regardless of the source of the time.</source>
          <target state="translated">В случае монотонного времени &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; шаблонизируется в &lt;code&gt;ClockType&lt;/code&gt; , тогда как &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; является аргументом времени выполнения, поскольку в случае монотонного времени тип часов влияет на разрешение объекта &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; .&lt;/a&gt; тогда как с &lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; &lt;/a&gt; его разрешение всегда составляет гектаносекунды независимо от источника времени.</target>
        </trans-unit>
        <trans-unit id="48d19d43ba624ca8d4f15f601b46da39df170632" translate="yes" xml:space="preserve">
          <source>In the corresponding D code, &lt;code&gt;foo&lt;/code&gt; is declared as having C++ linkage and function calling conventions:</source>
          <target state="translated">В соответствующем D-коде &lt;code&gt;foo&lt;/code&gt; объявлен как имеющий соглашения о связывании C ++ и вызове функций:</target>
        </trans-unit>
        <trans-unit id="c2859b376d9322070e57e0df9e0b545f1ad11ef9" translate="yes" xml:space="preserve">
          <source>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</source>
          <target state="translated">В текущей функции мы вызываем функцию &quot;this&quot;.1.Проверяем,может ли текущая функция вызывать функцию 'this',если нет,то выдавать ошибку.2.Если текущая функция не является родительской для функции 'this',то добавляем текущую функцию в список братьев и сестер функции 'this'.3.Если текущая функция является литералом,и она обращается к области видимости uplevel,то пометьте ее как делегата.Возвращает true в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="27341e1e33d3f1a9c524981309a60954fc820a69" translate="yes" xml:space="preserve">
          <source>In the example above, &quot;--foo&quot; and &quot;--bar&quot; are recognized, but &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. are rejected. The directive is active until the end of &lt;code&gt;getopt&lt;/code&gt;, or until the converse directive &lt;code&gt;caseInsensitive&lt;/code&gt; is encountered:</source>
          <target state="translated">В приведенном выше примере &amp;laquo;--foo&amp;raquo; и &amp;laquo;--bar&amp;raquo; распознаются, но &amp;laquo;--Foo&amp;raquo;, &amp;laquo;--Bar&amp;raquo;, &amp;laquo;--FOo&amp;raquo;, &amp;laquo;--bAr&amp;raquo; и т. Д. Отклоняются. Директива активна до конца &lt;code&gt;getopt&lt;/code&gt; или до тех &lt;code&gt;caseInsensitive&lt;/code&gt; пока не встретится обратная директива caseInsensitive :</target>
        </trans-unit>
        <trans-unit id="4dfbc2e24539434e62842bac389911ff9852ba28" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="translated">На приведенном выше графике любой направленный путь является допустимым неявным преобразованием. Никакие другие комбинации квалификаторов, кроме указанных, не действительны. Если между двумя наборами квалификаторов существует направленный путь, то квалифицированные типы называются &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;преобразуемыми квалификаторами&lt;/a&gt; . Та же информация показана ниже в табличном формате:</target>
        </trans-unit>
        <trans-unit id="02f036d56e5b0f17d6cada283807ab6e4a45c16d" translate="yes" xml:space="preserve">
          <source>In the second step, path components are compared using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">На втором шаге компоненты пути сравниваются с помощью &lt;code&gt;filenameCmp!cs&lt;/code&gt; , где &lt;code&gt;cs&lt;/code&gt; - необязательный параметр шаблона, определяющий, является ли сравнение чувствительным к регистру. Смотрите документацию &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="e25b68a7396b82d8e5f58fe981088b3bb4f8c195" translate="yes" xml:space="preserve">
          <source>In the special case where only a single function is provided (&lt;code&gt;F.length == 1&lt;/code&gt;), adjoin simply aliases to the single passed function (&lt;code&gt;F[0]&lt;/code&gt;).</source>
          <target state="translated">В особом случае, когда предоставляется только одна функция ( &lt;code&gt;F.length == 1&lt;/code&gt; ), просто добавьте псевдонимы к одной переданной функции ( &lt;code&gt;F[0]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d9fe9a61d26a09ceb6b95fd6ad82498884dadd5" translate="yes" xml:space="preserve">
          <source>In the table below, the &lt;b&gt;exact alias&lt;/b&gt;es are types of exactly the specified number of bits. The &lt;b&gt;at least alias&lt;/b&gt;es are at least the specified number of bits large, and can be larger. The &lt;b&gt;fast alias&lt;/b&gt;es are the fastest integral type supported by the processor that is at least as wide as the specified number of bits.</source>
          <target state="translated">В приведенной ниже таблице &lt;b&gt;точные псевдонимы&lt;/b&gt; - это типы с точно указанным количеством битов. По &lt;b&gt;меньшей мере, псевдонимы&lt;/b&gt; es, по меньшей мере, имеют указанное количество битов и могут быть больше. Этот &lt;b&gt;быстрый псевдоним&lt;/b&gt; ы самый быстрые интегральный тип поддерживается процессор , который является по меньшей мере , такой же шириной, заданным числа бит.</target>
        </trans-unit>
        <trans-unit id="2b57bd98576c6b47e51f692ed2880671dfdcaf21" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;myAllocator&lt;/code&gt; does not obey the &lt;code&gt;IAllocator&lt;/code&gt; interface, but implements its primitives so it can work with &lt;code&gt;makeArray&lt;/code&gt; by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through &lt;code&gt;IAllocator&lt;/code&gt;. An important rule of thumb is: &quot;assemble allocator first, adapt to &lt;code&gt;IAllocator&lt;/code&gt; after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with &lt;code&gt;IAllocator&lt;/code&gt; (usually by means of &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt;) only once, at client level.</source>
          <target state="translated">В этом случае &lt;code&gt;myAllocator&lt;/code&gt; не подчиняется интерфейсу &lt;code&gt;IAllocator&lt;/code&gt; , но реализует его примитивы, чтобы он мог работать с &lt;code&gt;makeArray&lt;/code&gt; посредством утилитарной типизации. Одна важная вещь, которую следует отметить в этой настройке, - это то, что статически типизированные ассемблеры распределителя почти всегда быстрее, чем распределители, которые проходят через &lt;code&gt;IAllocator&lt;/code&gt; . Важное практическое правило &lt;code&gt;IAllocator&lt;/code&gt; : &amp;laquo;Сначала собери распределитель, потом адаптируйся к IAllocator &amp;raquo;. Хороший распределитель реализует сложную логику посредством сборки шаблона и оборачивается с помощью &lt;code&gt;IAllocator&lt;/code&gt; (обычно с помощью &lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; &lt;/a&gt; ) только один раз, на уровне клиента.</target>
        </trans-unit>
        <trans-unit id="0dbb9df98ee1772b091a23269b418c611c6689cc" translate="yes" xml:space="preserve">
          <source>In this case, the slots at positions 1, 3, 4, and 9 are removed from the array.</source>
          <target state="translated">В этом случае слоты в позициях 1,3,4 и 9 удаляются из массива.</target>
        </trans-unit>
        <trans-unit id="5961fb400c229a03dfc935fa996c5fe8fc78fdb9" translate="yes" xml:space="preserve">
          <source>In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</source>
          <target state="translated">В этой реализации оба аргумента должны быть положительными.Интеграл оценивается либо последовательностью мощности,либо непрерывным дробным разложением,в зависимости от относительных значений a и x.</target>
        </trans-unit>
        <trans-unit id="bd2e85eebf3596f12832975a35b8c3545510433f" translate="yes" xml:space="preserve">
          <source>In this situation, the assignemnts are actual assign expressions (&lt;code&gt;opAssign&lt;/code&gt; is used if defined).</source>
          <target state="translated">В этой ситуации assignemnts являются фактическими выражениями присваивания ( &lt;code&gt;opAssign&lt;/code&gt; используется, если он определен).</target>
        </trans-unit>
        <trans-unit id="cecc30a8b51b4071bb5efaef87b2c1dec1a96284" translate="yes" xml:space="preserve">
          <source>In this table &quot;doPut&quot; is a method that places &lt;code&gt;e&lt;/code&gt; into &lt;code&gt;r&lt;/code&gt;, using the correct primitive: &lt;code&gt;r.put(e)&lt;/code&gt; if &lt;code&gt;R&lt;/code&gt; defines &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;r.front = e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is an input range (followed by &lt;code&gt;r.popFront()&lt;/code&gt;), or &lt;code&gt;r(e)&lt;/code&gt; otherwise.</source>
          <target state="translated">В этой таблице &amp;laquo;doPut&amp;raquo; - это метод, который помещает &lt;code&gt;e&lt;/code&gt; в &lt;code&gt;r&lt;/code&gt; , используя правильный примитив: &lt;code&gt;r.put(e)&lt;/code&gt; если &lt;code&gt;R&lt;/code&gt; определяет &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;r.front = e&lt;/code&gt; если &lt;code&gt;r&lt;/code&gt; - диапазон ввода (за которым следует &lt;code&gt;r.popFront()&lt;/code&gt; ) или &lt;code&gt;r(e)&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="02a8b5c14dc9548c1a490e9d5960a9feca99259a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were a function.</source>
          <target state="translated">Таким образом,структура или объект класса может вести себя как функция.</target>
        </trans-unit>
        <trans-unit id="17982ced0afda199d35d40c9d0672932dd55162a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were an array.</source>
          <target state="translated">Таким образом,структура или объект класса может вести себя как массив.</target>
        </trans-unit>
        <trans-unit id="86f8f90c18dbc0f9d343ef02fb0a4cd117e4553c" translate="yes" xml:space="preserve">
          <source>In user code. This class also provides means to add version identifier to the list of global (cross module) identifiers.</source>
          <target state="translated">В коде пользователя.Данный класс также предоставляет средства для добавления идентификатора версии в список глобальных (кросс-модульных)идентификаторов.</target>
        </trans-unit>
        <trans-unit id="bdee4d1acbdd89d7f24aebad7aeee092188b3727" translate="yes" xml:space="preserve">
          <source>In, Out and Inheritance</source>
          <target state="translated">Вход,выход и наследование</target>
        </trans-unit>
        <trans-unit id="783253f63cea9c514d69689860a1ae050327457b" translate="yes" xml:space="preserve">
          <source>In-order Pentium (Pentium1, PMMX, Atom)</source>
          <target state="translated">Пентиум (Pentium1,PMMX,Atom)в порядке заказа</target>
        </trans-unit>
        <trans-unit id="7d5a97d89ad4a3be9582069b3310a6d0aee11430" translate="yes" xml:space="preserve">
          <source>InExpression</source>
          <target state="translated">InExpression</target>
        </trans-unit>
        <trans-unit id="6b952134a590c37c3cd245f783f0cab0b35e154b" translate="yes" xml:space="preserve">
          <source>Include all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; options.</source>
          <target state="translated">Включите все опции &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21d63116a735028b1065c53175a7201eb75a690c" translate="yes" xml:space="preserve">
          <source>Include none of the above options.</source>
          <target state="translated">Не включайте ни один из вышеперечисленных вариантов.</target>
        </trans-unit>
        <trans-unit id="7fb47f835a97695060fa50d3d9efcf9e0fff9c84" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microseconds), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;months&quot;&lt;/code&gt;, and &lt;code&gt;&quot;years&quot;&lt;/code&gt;</source>
          <target state="translated">Включает &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (гекто-наносекунды (100 нс)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (микросекунды), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (миллисекунды), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; , &lt;code&gt;&quot;months&quot;&lt;/code&gt; и &lt;code&gt;&quot;years&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660485a4ef4f2ea299a5049e5e7f68faa3ac9dd9" translate="yes" xml:space="preserve">
          <source>Includes characters a, b, c, ..., z.</source>
          <target state="translated">Включает символы a,b,c,...,z.</target>
        </trans-unit>
        <trans-unit id="e622b4457bdf3ceb03f6cf725fab2a67de905818" translate="yes" xml:space="preserve">
          <source>Incomplete beta integral</source>
          <target state="translated">Незавершенная бета-интеграл</target>
        </trans-unit>
        <trans-unit id="861a53fcf5c388edd7cf46ce6d95a43e95f0e787" translate="yes" xml:space="preserve">
          <source>Incomplete gamma integral and its complement</source>
          <target state="translated">Неполный гамма-интеграл и его дополнение</target>
        </trans-unit>
        <trans-unit id="2f08d5bb658237cd92aa5a4432cb1cfef1a4c7b1" translate="yes" xml:space="preserve">
          <source>Incorporate &lt;code&gt;element_count&lt;/code&gt; and finalizes the hash.</source>
          <target state="translated">Включите &lt;code&gt;element_count&lt;/code&gt; и завершите хэш.</target>
        </trans-unit>
        <trans-unit id="d8c996a9761aab171974108da093507dfd302c9b" translate="yes" xml:space="preserve">
          <source>Increases the reference count of the concrete class that implements this interface.</source>
          <target state="translated">Увеличивает счетчик ссылок конкретного класса,реализующего этот интерфейс.</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="6179063ceb022e0b005a77ad50121ce42a8f12e0" translate="yes" xml:space="preserve">
          <source>Incremental options.</source>
          <target state="translated">Инкрементальные опционы.</target>
        </trans-unit>
        <trans-unit id="84205e80c2673222d26cbdde35ee1f4333d1b71b" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;numOwns&lt;/code&gt; (per instance and and per call) and forwards to &lt;code&gt; parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">Увеличивает &lt;code&gt;numOwns&lt;/code&gt; (за экземпляр и и за вызов) и пересылает &lt;code&gt; parent.owns(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddaf57d4b4048098b5dfe8043020c47a13b32e0a" translate="yes" xml:space="preserve">
          <source>Independent of the parameter this Logger will never log a message.</source>
          <target state="translated">Независимо от параметра этот Журнал никогда не будет регистрировать сообщения.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="699dc9f4598bf2c18561d09ccbeb25728c70494b" translate="yes" xml:space="preserve">
          <source>Index Assignment Operator Overloading</source>
          <target state="translated">Назначение индекса Перегрузка оператора</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">Выражения индексов</target>
        </trans-unit>
        <trans-unit id="d1893a899240a1b591d897768bc60814a476fa87" translate="yes" xml:space="preserve">
          <source>Index Name NULL</source>
          <target state="translated">Наименование индекса NULL</target>
        </trans-unit>
        <trans-unit id="e71ed4c87a94b38c5cecf345cf992053ca3a47d3" translate="yes" xml:space="preserve">
          <source>Index Name Table Name</source>
          <target state="translated">Наименование индекса Наименование таблицы Наименование</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">Индекс параметра с заданным именем</target>
        </trans-unit>
        <trans-unit id="bfb09c98cfaf2d55de0462489f758021e1b3f471" translate="yes" xml:space="preserve">
          <source>Index Op Assignment Operator Overloading</source>
          <target state="translated">Индекс Оп Назначение оператора Перегрузка оператора</target>
        </trans-unit>
        <trans-unit id="49fe544cd53fba1ec8f72994e8cce9d496cf27f3" translate="yes" xml:space="preserve">
          <source>Index Operator Overloading</source>
          <target state="translated">Перегрузка оператора</target>
        </trans-unit>
        <trans-unit id="a3b9e1c8a8784dafb7f4615ab228a307d1e4a762" translate="yes" xml:space="preserve">
          <source>Index of the argument for positional parameters, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">Индекс аргумента для позиционных параметров, от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;ubyte.max&lt;/code&gt; . ( &lt;code&gt;0&lt;/code&gt; означает, что не используется).</target>
        </trans-unit>
        <trans-unit id="c34e327ac8e45e062b5805d3beb7a3e4caec8300" translate="yes" xml:space="preserve">
          <source>Index of the last argument for positional parameter range, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">Индекс последнего аргумента для диапазона позиционных параметров, от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;ubyte.max&lt;/code&gt; . ( &lt;code&gt;0&lt;/code&gt; означает, что не используется).</target>
        </trans-unit>
        <trans-unit id="235d469a267eec1b21cb41bd835ec761b3be5b4a" translate="yes" xml:space="preserve">
          <source>Index of the maximal element of a range. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Индекс максимального элемента диапазона. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; возвращает &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25975946b5389d6cd4927c54b6079d61210dbf05" translate="yes" xml:space="preserve">
          <source>Index of the minimal element of a range. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Индекс минимального элемента диапазона. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; возвращает &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a04ef38d2ddc39bb1db51cbf56276c8f962441c1" translate="yes" xml:space="preserve">
          <source>IndexExpression</source>
          <target state="translated">IndexExpression</target>
        </trans-unit>
        <trans-unit id="3b15c071f8f2a9b03d20f13f4ee4fa47f96aaf8d" translate="yes" xml:space="preserve">
          <source>Indexed!(Source, Indices) &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt;(Source, Indices)(Source source, Indices indices);</source>
          <target state="translated">Индексируется (Источник, Индексы) &lt;strong id=&quot;indexed&quot;&gt;Индексируется&lt;/strong&gt; (Источник, Индексы) (Источник, Индексы, индексы);</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="76508adf7decca48f64672d4079c15326fbc39f8" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Индексирование и нарезка операций. Предоставляется, только если &lt;code&gt;hasSlicing!Source&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74036ccb3b85a0419f22323e1fac3915c3caf378" translate="yes" xml:space="preserve">
          <source>Indexing operators yielding or modifyng the value at the specified index.</source>
          <target state="translated">Операторы индексирования получают или изменяют значение по указанному индексу.</target>
        </trans-unit>
        <trans-unit id="6d2692938b71d76efadfb2cea1bb4a83352f988a" translate="yes" xml:space="preserve">
          <source>Indexing, slicing and bidirectional operations and range primitives. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Индексирование, нарезка и двунаправленные операции и диапазон примитивов. Предоставляется, только если &lt;code&gt;hasSlicing!Source&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f85958353bf4bfb31d66cc4f95a9358b5bedf1c3" translate="yes" xml:space="preserve">
          <source>Indicates a direction in time. One example of its use is &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#expand&quot;&gt;&lt;code&gt;expand&lt;/code&gt;&lt;/a&gt; function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</source>
          <target state="translated">Указывает направление во времени. Одним из примеров его использования &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; &amp;laquo;s &lt;a href=&quot;#expand&quot;&gt; &lt;code&gt;expand&lt;/code&gt; &lt;/a&gt; функцию , которая использует его , чтобы указать , должен ли интервал быть расширен в обратном направлении (в прошлом), вперед (в будущее), или оба.</target>
        </trans-unit>
        <trans-unit id="89b0fbd07a7b5dbf8da4ba701f1805d8565d86bb" translate="yes" xml:space="preserve">
          <source>Indicates if a nested aggregate prevents or not a function to be inlined. It's used to compute the cost but also to avoid a copy of the aggregate while the inliner processes.</source>
          <target state="translated">Указывает на то,что вложенный агрегат предотвращает или не предотвращает функцию,которая должна быть вложена.Используется для вычисления стоимости,но также и для того,чтобы избежать копирования агрегата во время обработки вложенности.</target>
        </trans-unit>
        <trans-unit id="a10ebf2fd0a4ff0f019e4879f48fae2f4e5a0b0d" translate="yes" xml:space="preserve">
          <source>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</source>
          <target state="translated">Указывает на минимизацию объема управляемой памяти за счет возврата свободной физической памяти в операционную систему.Объем возвращаемой свободной памяти зависит от конструкции аллокатора и поведения программы.</target>
        </trans-unit>
        <trans-unit id="4ec109e112fc6bfd6a9d0109f56e7e7967df8488" translate="yes" xml:space="preserve">
          <source>Indicates the checking state of various contracts.</source>
          <target state="translated">Указывает на состояние проверки различных контрактов.</target>
        </trans-unit>
        <trans-unit id="cb18c8046fd7efef0dda1d752fd5c6ff22b02f5d" translate="yes" xml:space="preserve">
          <source>Indicates the kind of scan being performed by &lt;code&gt;thread_scanAllType&lt;/code&gt;.</source>
          <target state="translated">Указывает тип сканирования, выполняемого &lt;code&gt;thread_scanAllType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f13413a46338bc9d77efe386dd1970d9c61578f" translate="yes" xml:space="preserve">
          <source>Indicates the type of a &lt;code&gt;JSONValue&lt;/code&gt;.</source>
          <target state="translated">Указывает тип &lt;code&gt;JSONValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee35c8aada8a6aa7b7217bd768effeae4d28769f" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;T&lt;/code&gt; is a file handle, i.e. the type is implicitly convertable to &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; or a pointer to a &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt;&lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Указывает, является ли &lt;code&gt;T&lt;/code&gt; дескриптором файла, т.е. тип неявно конвертируется в &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; или указатель на &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt; &lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16f0af9200309c4bcede9c6bd76aa0d14467a310" translate="yes" xml:space="preserve">
          <source>Indicates whether an address has been marked by the GC.</source>
          <target state="translated">Указывает,был ли адрес отмечен ГК.</target>
        </trans-unit>
        <trans-unit id="c7fabc24fed84961bce8996fe0ecd1e5cdad5e83" translate="yes" xml:space="preserve">
          <source>Indicates whether the comparisons are case sensitive.</source>
          <target state="translated">Показывает,чувствительны ли сравнения к регистру.</target>
        </trans-unit>
        <trans-unit id="f7d28431fd9c9c5871085a5497dc7e6e1e0cf415" translate="yes" xml:space="preserve">
          <source>Indicates which contracts should be checked or not.</source>
          <target state="translated">Указывает,какие контракты следует проверять или нет.</target>
        </trans-unit>
        <trans-unit id="4243a1f947d3219fb4149e60971ece346868e5f0" translate="yes" xml:space="preserve">
          <source>Individual characters (&lt;code&gt;char, &lt;/code&gt;wchar&lt;code&gt;, or &lt;/code&gt;dchar`) are formatted as Unicode characters with &lt;code&gt;%s&lt;/code&gt; and as integers with integral-specific format specs.</source>
          <target state="translated">Отдельные символы ( &lt;code&gt;char, &lt;/code&gt; wchar &lt;code&gt;, or &lt;/code&gt; dchar`) форматируются как символы Юникода с &lt;code&gt;%s&lt;/code&gt; и как целые числа со спецификациями формата, специфичными для интеграла.</target>
        </trans-unit>
        <trans-unit id="29597351771a3ef19075a67f20ee90c6ad63bea0" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not.</source>
          <target state="translated">Отдельные символы сравниваются с помощью &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; , где &lt;code&gt;cs&lt;/code&gt; - необязательный параметр шаблона, определяющий, является ли сравнение чувствительным к регистру.</target>
        </trans-unit>
        <trans-unit id="49226687980b9cd956057b7a38e24b4e2409b256" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCharCmp&quot;&gt;&lt;code&gt;filenameCharCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">Отдельные символы сравниваются с помощью &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; , где &lt;code&gt;cs&lt;/code&gt; - необязательный параметр шаблона, определяющий, является ли сравнение чувствительным к регистру. Подробности смотрите в документации к &lt;a href=&quot;#filenameCharCmp&quot;&gt; &lt;code&gt;filenameCharCmp&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1f361f1f9ae5992659047882bc5221a903aebb0" translate="yes" xml:space="preserve">
          <source>Individual field in the Ctor with information about its callees and location.</source>
          <target state="translated">Индивидуальное поле в Ctor с информацией о его каллах и местоположении.</target>
        </trans-unit>
        <trans-unit id="2112ae8639e7801d8cfbbdd81cd2583bb2a4a9cd" translate="yes" xml:space="preserve">
          <source>Individual tests are specified in the unit test using &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;. Unlike</source>
          <target state="translated">Индивидуальные тесты указываются в модульном тесте с использованием &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt; . в отличие</target>
        </trans-unit>
        <trans-unit id="a1c45f8b0cd8cbcf6f1e93b6a635fb2a38dc40f6" translate="yes" xml:space="preserve">
          <source>Inequality is defined as the logical negation of equality.</source>
          <target state="translated">Неравенство определяется как логическое отрицание равенства.</target>
        </trans-unit>
        <trans-unit id="65b109f015e153776d80b153da2023fd8d163d9f" translate="yes" xml:space="preserve">
          <source>Infinite ranges are compatible, provided the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, in which case the implementation simply returns upTo.</source>
          <target state="translated">Бесконечные диапазоны совместимы при условии, что &lt;code&gt;upTo&lt;/code&gt; параметр upTo , и в этом случае реализация просто возвращает upTo.</target>
        </trans-unit>
        <trans-unit id="cc80f798db63ecb0ec11198be5af2b60c15e0345" translate="yes" xml:space="preserve">
          <source>Infinite ranges with slicing support must return an instance of &lt;a href=&quot;std_range#Take&quot;&gt;&lt;code&gt;std.range.Take&lt;/code&gt;&lt;/a&gt; when sliced with a specific lower and upper bound (see &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt;); &lt;code&gt;handle&lt;/code&gt; deals with this by &lt;code&gt;take&lt;/code&gt;ing 0 from the return value of the handler function and returning that when an exception is caught.</source>
          <target state="translated">Бесконечные диапазоны с поддержкой нарезки должны возвращать экземпляр &lt;a href=&quot;std_range#Take&quot;&gt; &lt;code&gt;std.range.Take&lt;/code&gt; &lt;/a&gt; при нарезке с определенной нижней и верхней границей (см. &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt; ); &lt;code&gt;handle&lt;/code&gt; сделки с этим путем &lt;code&gt;take&lt;/code&gt; ИНГ 0 из возвращаемого значения функции обработчика и возвращения , что , когда исключение ловится.</target>
        </trans-unit>
        <trans-unit id="27d9e5c1d05febee114a9f9e51dbec3780887c9a" translate="yes" xml:space="preserve">
          <source>Infiniteness of the wrapped range is not propagated.  Length is not propagated in the case of non-random access ranges.</source>
          <target state="translated">Бесконечность обернутого диапазона не распространяется.Длина не распространяется в случае неслучайных диапазонов доступа.</target>
        </trans-unit>
        <trans-unit id="266086404e3edd52081be68722aa77ff6a65cf70" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a Posix system.</source>
          <target state="translated">Информация о файле,похожая на ту,которую можно получить из статистики системы Posix.</target>
        </trans-unit>
        <trans-unit id="cd1b541e2d202e9ed7863df5d539d80a14d92db1" translate="yes" xml:space="preserve">
          <source>Information about an interface. When an object is accessed via an interface, an Interface* appears as the first entry in its vtbl.</source>
          <target state="translated">Информация об интерфейсе.При доступе к объекту через интерфейс в качестве первой записи в его vtbl появляется сообщение Interface*.</target>
        </trans-unit>
        <trans-unit id="cea2e687310e3b71b249c28a49288e9fd3bfa210" translate="yes" xml:space="preserve">
          <source>Information about an option.</source>
          <target state="translated">Информация об опции.</target>
        </trans-unit>
        <trans-unit id="e073c50eee2c368b573895c98fb35595e9133239" translate="yes" xml:space="preserve">
          <source>Information about errors should be logged with this level.</source>
          <target state="translated">Информация об ошибках должна регистрироваться на этом уровне.</target>
        </trans-unit>
        <trans-unit id="928345681d20aa3d2b01bea36a816d52c33a48de" translate="yes" xml:space="preserve">
          <source>Information about the dynamic type of the class</source>
          <target state="translated">Информация о динамическом типе класса</target>
        </trans-unit>
        <trans-unit id="dc5ebb2696c4fafd1bdd1b19b9d403757258f4ad" translate="yes" xml:space="preserve">
          <source>Information about the error.</source>
          <target state="translated">Информация об ошибке.</target>
        </trans-unit>
        <trans-unit id="b7329bd16608fcee8af0c9e3dcd5b29f7f17343f" translate="yes" xml:space="preserve">
          <source>Information about the target operating system, environment, and CPU.</source>
          <target state="translated">Информация о целевой операционной системе,окружающей среде и процессоре.</target>
        </trans-unit>
        <trans-unit id="ceccba3653730142ed262183682108d6a4b114f3" translate="yes" xml:space="preserve">
          <source>Information gathered about externally defined template member functions, member data, and member classes.</source>
          <target state="translated">Информация,собранная о внешних функциях членов шаблона,данных членов и классов членов.</target>
        </trans-unit>
        <trans-unit id="908b94b8c3e2309d82de3bc12b0083b2f0550dd4" translate="yes" xml:space="preserve">
          <source>Information gathered about nested class friends.</source>
          <target state="translated">Собранная информация о вложенных друзьях класса.</target>
        </trans-unit>
        <trans-unit id="7a43d043ba9567583c6e384e6e0ac879da254eab" translate="yes" xml:space="preserve">
          <source>Information gathered about nested explicit specializations.</source>
          <target state="translated">Собранная информация о вложенных явных специализациях.</target>
        </trans-unit>
        <trans-unit id="464dcc7e55ca0baa3461154f3221489d53fa204b" translate="yes" xml:space="preserve">
          <source>Information gathered about primary member template explicit specialization.</source>
          <target state="translated">Собранная информация о явной специализации первичных членов шаблона.</target>
        </trans-unit>
        <trans-unit id="8bc70f913f6ebe36fcb59b26b1c9b07d1f380466" translate="yes" xml:space="preserve">
          <source>Information regarding the allocated memory block or BlkInfo.init on error.</source>
          <target state="translated">Информация об ошибке относительно выделенного блока памяти или BlkInfo.init.</target>
        </trans-unit>
        <trans-unit id="1675fcfc1cf455d10d63328190309be0fe262d03" translate="yes" xml:space="preserve">
          <source>Information regarding the memory block referenced by p or BlkInfo.init on error.</source>
          <target state="translated">Информация о блоке памяти,на который ссылается p или BlkInfo.init при ошибке.</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">Начальное значение</target>
        </trans-unit>
        <trans-unit id="97e0f0f5459c7f9a8a0eadb6d21739e1c19dd524" translate="yes" xml:space="preserve">
          <source>Initial_Punctuation</source>
          <target state="translated">Initial_Punctuation</target>
        </trans-unit>
        <trans-unit id="e3e40f7638a489f11f1de06365e82209954d82d0" translate="yes" xml:space="preserve">
          <source>Initialization hook, called FROM each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">Инициализационный крюк,называемый FROM каждой нити.Никаких предположений о состоянии инициализации модуля делать не следует.</target>
        </trans-unit>
        <trans-unit id="a459dff3012da591453989e5860a6fd825f63ce3" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="translated">Initialize</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">Инициализировать библиотеку SQLite</target>
        </trans-unit>
        <trans-unit id="748256c78e345ebbc504f121b03e80be2a80bbca" translate="yes" xml:space="preserve">
          <source>Initialize a TOK.cantExpression Expression.</source>
          <target state="translated">Инициализируйте выражение TOK.cantExpression.</target>
        </trans-unit>
        <trans-unit id="27911a1150c0c1d2144b25e270682254f6dac63a" translate="yes" xml:space="preserve">
          <source>Initialize config variables.</source>
          <target state="translated">Инициализируйте переменные конфигурации.</target>
        </trans-unit>
        <trans-unit id="cbe2f6d3df93f8e15ce05f5a1f98cda2b20db74a" translate="yes" xml:space="preserve">
          <source>Initialize druntime. If a C program wishes to call D code, and there's no D main(), then it must call rt_init() and rt_term().</source>
          <target state="translated">Инициализируй пьянство.Если программа на Си хочет вызвать D код,а D main()нет,то она должна вызвать rt_init()и rt_term().</target>
        </trans-unit>
        <trans-unit id="8eb8be79e89fc0c011f24c39ee8771af00f563f7" translate="yes" xml:space="preserve">
          <source>Initialize for inferring the attributes of this function.</source>
          <target state="translated">Инициализируйте для вывода атрибутов этой функции.</target>
        </trans-unit>
        <trans-unit id="f721b948f9c83247c02645e5eb12893bfb899d86" translate="yes" xml:space="preserve">
          <source>Initialize list package.</source>
          <target state="translated">Инициализировать пакет списка.</target>
        </trans-unit>
        <trans-unit id="de4ea7df574920c39fb3c6bd0386ce6a9cd8fd5d" translate="yes" xml:space="preserve">
          <source>Initialize the Objective-C string using a C string.</source>
          <target state="translated">Инициализируйте строку Объект-С с помощью строки C.</target>
        </trans-unit>
        <trans-unit id="ef4109d3528796628f6b2a0029715405248a578e" translate="yes" xml:space="preserve">
          <source>Initialize the Target</source>
          <target state="translated">Инициализировать цель</target>
        </trans-unit>
        <trans-unit id="0980ce942938201d58c731edfd7b47e45dd9efe7" translate="yes" xml:space="preserve">
          <source>Initialize the dual-context array with the context pointers.</source>
          <target state="translated">Инициализируйте двухконтекстный массив с помощью контекстных указателей.</target>
        </trans-unit>
        <trans-unit id="8e023ffe90e1164684f46dc5edc97859a5680a5f" translate="yes" xml:space="preserve">
          <source>Initialize the hidden aggregate member, vthis, with the context pointer.</source>
          <target state="translated">Инициализируйте скрытый член агрегата,vthis,с помощью контекстного указателя.</target>
        </trans-unit>
        <trans-unit id="59c6a3b95f9730ad20a9c9db67ee73fd2a6949c4" translate="yes" xml:space="preserve">
          <source>Initialize the instance by creating a working curl handle.</source>
          <target state="translated">Инициализируйте экземпляр,создав рабочий манипулятор скручивания.</target>
        </trans-unit>
        <trans-unit id="1a30f56d1770a9dcc7fd0bb681a1c06b14ad9d91" translate="yes" xml:space="preserve">
          <source>Initialize the memory allocator</source>
          <target state="translated">Инициализация аллокатора памяти</target>
        </trans-unit>
        <trans-unit id="494a02556f310d47be7c5338d8f5523416a42a2e" translate="yes" xml:space="preserve">
          <source>Initialize with a message and an error code.</source>
          <target state="translated">Инициализируйте сообщение и код ошибки.</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="51bf015ae2898049c8dda3ee0d3b48d0b0503aac" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">Инициализатор &lt;code&gt;init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b1d1b30aa70eb127392afc002aaf56ef13eddf1" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;inx&lt;/code&gt;</source>
          <target state="translated">Инициализатор &lt;code&gt;inx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376a8ae3746f3bef7e7c198b9b11401e24b7d25c" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Initializer init, Scope* sc);</source>
          <target state="translated">Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt; (Инициализатор init, Область * sc);</target>
        </trans-unit>
        <trans-unit id="d8d2abfa30e5c4556b8e2c9d2dc62e742af966eb" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;(Initializer init, Scope* sc, Type t, NeedInterpret needInterpret);</source>
          <target state="translated">Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt; (Инициализатор init, Область действия * sc, Тип t, NeedInterpret needInterpret);</target>
        </trans-unit>
        <trans-unit id="88abdada1a9385d97517a707f4ab8a5f5a3e696d" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt;(Initializer inx);</source>
          <target state="translated">Инициализатор &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt; (инициализатор inx);</target>
        </trans-unit>
        <trans-unit id="c33131a57d387e740aae854652440535c3dd0652" translate="yes" xml:space="preserve">
          <source>Initializer AST node</source>
          <target state="translated">Узел инициализатора АСТ</target>
        </trans-unit>
        <trans-unit id="14b021ae9bb3f976f77030248590d743674ec1b8" translate="yes" xml:space="preserve">
          <source>Initializer AST to copy</source>
          <target state="translated">Инициализатор AST для копирования</target>
        </trans-unit>
        <trans-unit id="3121cafc28fbd2cff06107236c3142ae39ff3c9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RefCounted&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;. The template parameter &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;RefCounted&lt;/code&gt; is inferred from &lt;code&gt;val&lt;/code&gt;. This function can be used to move non-copyable values to the heap. It also disables the &lt;code&gt;autoInit&lt;/code&gt; option of &lt;code&gt;RefCounted&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;RefCounted&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt; . Параметр шаблона &lt;code&gt;T&lt;/code&gt; &lt;code&gt;RefCounted&lt;/code&gt; определяется по значению &lt;code&gt;val&lt;/code&gt; . Эта функция может использоваться для перемещения не копируемых значений в кучу. Он также отключает &lt;code&gt;autoInit&lt;/code&gt; вариант &lt;code&gt;RefCounted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5840e1604b436855e9916e7392a48763951eabf0" translate="yes" xml:space="preserve">
          <source>Initializes a barrier object which releases threads in groups of limit in size.</source>
          <target state="translated">Инициализирует объект барьера,который освобождает потоки в группах ограничения по размеру.</target>
        </trans-unit>
        <trans-unit id="e7d8f005a4914e6f92d821d5b224a6bd9e5c292c" translate="yes" xml:space="preserve">
          <source>Initializes a condition object which is associated with the supplied mutex object.</source>
          <target state="translated">Инициализирует объект состояния,связанный с поставляемым объектом мьютекса.</target>
        </trans-unit>
        <trans-unit id="2e831c2f248c0c0989af9f49fabed81c26839fd7" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a dynamic D function.</source>
          <target state="translated">Инициализирует объект волокна,связанный с динамической функцией D.</target>
        </trans-unit>
        <trans-unit id="af50363b8f7b4155835b77141de6a5c61fdd71a0" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a static D function.</source>
          <target state="translated">Инициализирует объект волокна,связанный со статической функцией D.</target>
        </trans-unit>
        <trans-unit id="45f928a2b81b560a0de6c9239785399cedf0251c" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a dynamic D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">Инициализирует объект генератора,связанный с динамической функцией D.Функция будет вызвана один раз для подготовки диапазона к итерации.</target>
        </trans-unit>
        <trans-unit id="d0a92e3c77360cd0a21c46127be86aca1b90b608" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a static D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">Инициализирует объект генератора,связанный со статической функцией D.Функция будет вызвана один раз для подготовки диапазона к итерации.</target>
        </trans-unit>
        <trans-unit id="d3728c381d3549c70b43d294cf94f34b914968b0" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object and sets it as the monitor for &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Инициализирует объект взаимного исключения и устанавливает его в качестве монитора для объекта &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a70c8975cc02255930db5c1532e070f13d983d9" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object.</source>
          <target state="translated">Инициализирует объект мьютекса.</target>
        </trans-unit>
        <trans-unit id="dc21cd96d7c298b730677d5fadf1f39d6fcdc2a3" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex object with the supplied policy.</source>
          <target state="translated">Инициализирует объект чтения/записи мьютекса с помощью прилагаемой политики.</target>
        </trans-unit>
        <trans-unit id="1bf7bde2d0e1b4605f5fcc7cecf50b8041c0ee33" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex reader proxy object.</source>
          <target state="translated">Инициализирует прокси-объект чтения/записи мьютекса.</target>
        </trans-unit>
        <trans-unit id="cac251d6ab6ce4228fd76b8f664aca1fdce466aa" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex writer proxy object.</source>
          <target state="translated">Инициализирует прокси-объект read/write mutex writeer.</target>
        </trans-unit>
        <trans-unit id="e9c3d0e482ee4665047c01099490677dcee2bdf1" translate="yes" xml:space="preserve">
          <source>Initializes a semaphore object with the specified initial count.</source>
          <target state="translated">Инициализирует семафорный объект с заданным начальным счётом.</target>
        </trans-unit>
        <trans-unit id="b08f976531720c8d331b9fd2fe472f259a01f7f8" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a dynamic D function.</source>
          <target state="translated">Инициализирует объект потока,связанный с динамической функцией D.</target>
        </trans-unit>
        <trans-unit id="6feddfb754d931f52971603d63763097e08f646e" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a static D function.</source>
          <target state="translated">Инициализирует объект потока,связанный со статической функцией D.</target>
        </trans-unit>
        <trans-unit id="02e85d0a8c0d02c068e1d5736a1954b12b36920b" translate="yes" xml:space="preserve">
          <source>Initializes all elements of &lt;code&gt;range&lt;/code&gt; with their &lt;code&gt;.init&lt;/code&gt; value. Assumes that the elements of the range are uninitialized.</source>
          <target state="translated">Инициализирует все элементы &lt;code&gt;range&lt;/code&gt; с их значением &lt;code&gt;.init&lt;/code&gt; . Предполагается, что элементы диапазона неинициализированы.</target>
        </trans-unit>
        <trans-unit id="472c952e25298d18516b57e8e37279e00d61a5fe" translate="yes" xml:space="preserve">
          <source>Initializes an event object. Does nothing if the event is already initialized.</source>
          <target state="translated">Инициализирует объект события.Ничего не делает,если событие уже инициализировано.</target>
        </trans-unit>
        <trans-unit id="eaf4287ba6b011331efecfcdf502db022ed8e9d5" translate="yes" xml:space="preserve">
          <source>Initializes each element of &lt;code&gt;range&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, &lt;a href=&quot;#fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt; and uninitializedFill are equivalent).</source>
          <target state="translated">Инициализация каждого элемента &lt;code&gt;range&lt;/code&gt; с &lt;code&gt;value&lt;/code&gt; . Предполагается, что элементы диапазона неинициализированы. Это представляет интерес для структур, которые определяют конструкторы копирования (для всех других типов, &lt;a href=&quot;#fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; и uninitializedFill эквивалентны).</target>
        </trans-unit>
        <trans-unit id="fc7f0006265d50c993eca80b0dee1e88b813e83a" translate="yes" xml:space="preserve">
          <source>Initializes the Symbol s with the contents of the exception handler table.</source>
          <target state="translated">Инициализирует символ s содержимым таблицы обработчиков исключений.</target>
        </trans-unit>
        <trans-unit id="ce7db86ae90730cf95765268d14c3efeca306d1a" translate="yes" xml:space="preserve">
          <source>Initializes the digest.</source>
          <target state="translated">Инициализирует дайджест.</target>
        </trans-unit>
        <trans-unit id="7cc4cbbc423778a9b3a1d152d6911455078c9956" translate="yes" xml:space="preserve">
          <source>Initializes the runtime. This call is to be used in instances where the standard program initialization process is not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was already successfully initialized this returns true. Each call to initialize must be paired by a call to &lt;a href=&quot;#terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Инициализирует среду выполнения. Этот вызов должен использоваться в тех случаях, когда стандартный процесс инициализации программы не выполняется. Чаще всего это происходит в общих библиотеках или в библиотеках, связанных с C-программой. Если среда выполнения уже была успешно инициализирована, это возвращает true. Каждый вызов для инициализации должен быть связан с вызовом для &lt;a href=&quot;#terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd011618a7d780c02099be5bb857d574a889ced4" translate="yes" xml:space="preserve">
          <source>Initializes the thread module. This function must be called by the garbage collector on startup and before any other thread routines are called.</source>
          <target state="translated">Инициализирует модуль резьбы.Эта функция должна быть вызвана сборщиком мусора при запуске и перед вызовом любых других рутинных потоков.</target>
        </trans-unit>
        <trans-unit id="f7bf172cc09f5d408e5dbadd459ffc810fa40735" translate="yes" xml:space="preserve">
          <source>Initializes this object.</source>
          <target state="translated">Инициализирует этот объект.</target>
        </trans-unit>
        <trans-unit id="330d0782e4b98319bc9e2fabb58b097370cccd48" translate="yes" xml:space="preserve">
          <source>Initializes var with the lazy init value in a thread-safe manner.</source>
          <target state="translated">Инициализирует вариацию с ленивым значением в нитевидной манере.</target>
        </trans-unit>
        <trans-unit id="357baf1e97067fcd6c5956ff04a8aafd59f2e20c" translate="yes" xml:space="preserve">
          <source>Initializing a field more than once is an error:</source>
          <target state="translated">Инициализация поля более одного раза является ошибкой:</target>
        </trans-unit>
        <trans-unit id="7b6a85ba00f40263892051680251fc88efc22b1f" translate="yes" xml:space="preserve">
          <source>Initially, &lt;code&gt;KRRegion&lt;/code&gt; starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, &lt;code&gt;KRRegion.allocate&lt;/code&gt; has the performance profile of a region allocator. Deallocation inserts (in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</source>
          <target state="translated">Первоначально &lt;code&gt;KRRegion&lt;/code&gt; запускается в режиме &amp;laquo;регион&amp;raquo;: выделения обслуживаются из фрагмента памяти по регионам. Таким образом, до тех пор, пока остается достаточно памяти, &lt;code&gt;KRRegion.allocate&lt;/code&gt; имеет профиль производительности распределителя области. Deallocation вставляет (за &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) раз) освобожденные блоки в неструктурированный список фриланса, который не читается в режиме региона.</target>
        </trans-unit>
        <trans-unit id="6bcf5b308aa4ed1bdc1fe48856a7ba75e0842648" translate="yes" xml:space="preserve">
          <source>Initiate a search for all non-overlapping matches to the pattern &lt;code&gt;re&lt;/code&gt; in the given &lt;code&gt;input&lt;/code&gt;. The result is a lazy range of matches generated as they are encountered in the input going left to right.</source>
          <target state="translated">Инициируйте поиск всех неперекрывающихся совпадений с шаблоном &lt;code&gt;re&lt;/code&gt; в заданном &lt;code&gt;input&lt;/code&gt; . Результатом является ленивый диапазон совпадений, сгенерированных по мере того, как они встречаются на входе слева направо.</target>
        </trans-unit>
        <trans-unit id="39a92c1c48ec637efb7a0a17e58b57967f5754ea" translate="yes" xml:space="preserve">
          <source>Initiate the shutdown</source>
          <target state="translated">Инициировать выключение</target>
        </trans-unit>
        <trans-unit id="505f260038380736b5ec292da3beb645bc7a02ab" translate="yes" xml:space="preserve">
          <source>Inline Assembler</source>
          <target state="translated">Онлайн-ассемблер</target>
        </trans-unit>
        <trans-unit id="e8c0903b87db76a205d27b465bff8acf36d3a3fc" translate="yes" xml:space="preserve">
          <source>Inline Code</source>
          <target state="translated">Интернет-код</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">Онлайн-функции</target>
        </trans-unit>
        <trans-unit id="0e581275df3e295be9dbef35d1d241b50ed09352" translate="yes" xml:space="preserve">
          <source>Inline Links</source>
          <target state="translated">Ссылки на Интернет</target>
        </trans-unit>
        <trans-unit id="e928c83ba27af9a3e30934913f4f5025c9156467" translate="yes" xml:space="preserve">
          <source>Inline Status</source>
          <target state="translated">Статус онлайн</target>
        </trans-unit>
        <trans-unit id="2a9bcb6f0852ea225d7f231f321da701f1352c4f" translate="yes" xml:space="preserve">
          <source>Inline assembler can be used to access hardware directly:</source>
          <target state="translated">Inline ассемблер может быть использован для прямого доступа к оборудованию:</target>
        </trans-unit>
        <trans-unit id="79759f20677d34f63a3ad16ca748c0357029c9ef" translate="yes" xml:space="preserve">
          <source>Inline assembler implementation for DMD.</source>
          <target state="translated">Внедрение онлайн ассемблера для DMD.</target>
        </trans-unit>
        <trans-unit id="8bb9331db9f6ba0e169e23c73a72b91ef379fcfb" translate="yes" xml:space="preserve">
          <source>Inline assembler is supported with the asm statement:</source>
          <target state="translated">Ассемблер онлайн поддерживается заявлением asm:</target>
        </trans-unit>
        <trans-unit id="30bd67072a99e7f0e67136dac69a9f97d8fe06e6" translate="yes" xml:space="preserve">
          <source>Inline code can be written between backtick characters (`), similarly to the syntax used on GitHub, Reddit, Stack Overflow, and other websites. Both the opening and closing ` character must appear on the same line to trigger this behavior.</source>
          <target state="translated">Встроенный код может быть написан между символами бэктика (`),аналогично синтаксису,используемому на GitHub,Reddit,Stack Overflow и других сайтах.Как символ открытия,так и символ закрытия ` должен появляться в одной строке,чтобы вызвать такое поведение.</target>
        </trans-unit>
        <trans-unit id="3a0d3f2169904e16efc469dbb314be7e91a83d62" translate="yes" xml:space="preserve">
          <source>Inline-style links enclose link text in square brackets and the link URL in parentheses. Like reference links, the URL may optionally be followed by title text wrapped in single or double quotes, or in parentheses:</source>
          <target state="translated">Ссылки в стиле Inline заключены в квадратные скобки,а URL ссылки-в круглые скобки.Как и ссылка,за URL может дополнительно следовать заглавный текст,заключенный в одинарные или двойные кавычки,или в круглые скобки:</target>
        </trans-unit>
        <trans-unit id="59987901b798d3774e680b1f2e942cf43901da46" translate="yes" xml:space="preserve">
          <source>InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78d80e54409073effd7ab616e62a68493fee350d" translate="yes" xml:space="preserve">
          <source>Inout Functions</source>
          <target state="translated">Неиспользуемые функции</target>
        </trans-unit>
        <trans-unit id="e8e7165f5b963e02cdaf54a8eb17befc2421e96a" translate="yes" xml:space="preserve">
          <source>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions.</source>
          <target state="translated">Inout-типы могут быть неявно преобразованы в const или inout const,но ни в какие другие.Другие типы не могут быть неявно приведены к inout.В функциях @safe не допускается приведение к или из inout.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">Входной массив.</target>
        </trans-unit>
        <trans-unit id="805a8fb36fe255b6fb65ad6afc87bb5c87d77739" translate="yes" xml:space="preserve">
          <source>Input range primitives.</source>
          <target state="translated">Примитивы входного диапазона.</target>
        </trans-unit>
        <trans-unit id="2b5a3aca97f7c0ee924c45da0b642efd3933bcec" translate="yes" xml:space="preserve">
          <source>Input range primitives. Always present.</source>
          <target state="translated">Примитивы входного диапазона.Всегда присутствуют.</target>
        </trans-unit>
        <trans-unit id="3ea0015c09b13077d49706cf98824e19781f5a6d" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;front&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;front&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea0417fdf24ea467e5d4948e4d2f763b6a7eef2b" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="263a897da5a7d45d98fac35624cdf4deb7cf4411" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8a5a20feb07807120b419370d56d0cc41af44e6" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;seq&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;seq&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ac91ede8a06926e9fd7701df246ece786ebf98" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, Element)(InputRange haystack, scope Element needle)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;найти&lt;/strong&gt; (псевдоним = пред &quot;A == B&quot;, InputRange, элемент) (InputRange стог, область применения Элемент иглы)</target>
        </trans-unit>
        <trans-unit id="62294650ad3440bbcc9dfa642f50ca9b106dfc41" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred, InputRange)(InputRange haystack)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;находка&lt;/strong&gt; (псевдоним пред, InputRange) (InputRange стог)</target>
        </trans-unit>
        <trans-unit id="cd55b74bf8e8c901c82e7777b6c9deb713ab8571" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, ForwardRange)(InputRange seq, ForwardRange choices)</source>
          <target state="translated">InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt; (псевдоним &lt;strong id=&quot;findAmong&quot;&gt;pred&lt;/strong&gt; = &quot;a == b&quot;, InputRange, ForwardRange) (InputRange seq, выбор ForwardRange)</target>
        </trans-unit>
        <trans-unit id="215e5e329de1e54df130b5fa8c6b834e564f901b" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249ee449e0f4478b44dc1191e22438bd70e851a5" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;src&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c677621d3536f932357d78e1812f103084e329df" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71bdacf44f1217f068320302c2f0ee3826890d58" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;tgt&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;tgt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26853b5826e342866783ec6125630078fcc1a0ef" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 src, InputRange2 tgt)</target>
        </trans-unit>
        <trans-unit id="a6d9a6e40c7583de17b5334cea373d1a6f012a01" translate="yes" xml:space="preserve">
          <source>InputRangeObject!R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;(R)(R range)</source>
          <target state="translated">InputRangeObject! R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt; (R) (диапазон R)</target>
        </trans-unit>
        <trans-unit id="54690a68ec01cec2015c43085af22e3b7ee1fd11" translate="yes" xml:space="preserve">
          <source>Inscriptional Pahlavi</source>
          <target state="translated">Надписи Пехлеви</target>
        </trans-unit>
        <trans-unit id="fef5264f6a30e6dcae96d08ee848ad4b86a2a3a3" translate="yes" xml:space="preserve">
          <source>Inscriptional Parthian</source>
          <target state="translated">Надписной парфянин</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="3c215b42cade3b7a8b98554cb505256252393b54" translate="yes" xml:space="preserve">
          <source>Insert a backtick</source>
          <target state="translated">Вставить подпорку</target>
        </trans-unit>
        <trans-unit id="138a4c6393efa857920b23a60fdca2a6694f91d0" translate="yes" xml:space="preserve">
          <source>Insert a dollar sign</source>
          <target state="translated">Вставить знак доллара</target>
        </trans-unit>
        <trans-unit id="cecb3ad08db064401b3027bd8bdfecfd625474f6" translate="yes" xml:space="preserve">
          <source>Insert a left parenthesis</source>
          <target state="translated">Вставить левую скобку</target>
        </trans-unit>
        <trans-unit id="cbdb76fffabdf5eb3b5ae5b2ff4c5c2a9ba7b666" translate="yes" xml:space="preserve">
          <source>Insert a line feed (newline)</source>
          <target state="translated">Вставьте сетевой канал (новая линия)</target>
        </trans-unit>
        <trans-unit id="c0306b572d5a694e3a6dd42bca0200f018f85238" translate="yes" xml:space="preserve">
          <source>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">Вставить ряд элементов в контейнер.Обратите внимание,что это не делает недействительными никакие диапазоны,которые в настоящее время итерируют контейнер.</target>
        </trans-unit>
        <trans-unit id="1a917cf9fad45f42c5f9d737b6e96f9575d41832" translate="yes" xml:space="preserve">
          <source>Insert a right parenthesis</source>
          <target state="translated">Вставить правую скобку</target>
        </trans-unit>
        <trans-unit id="327083c1ff82497e1f646caa621a2ae2d82389b4" translate="yes" xml:space="preserve">
          <source>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">Вставьте один элемент в контейнер.Обратите внимание,что это не делает недействительными никакие диапазоны,которые в настоящее время итерируют контейнер.</target>
        </trans-unit>
        <trans-unit id="42c8592347a2b25e78dc2c81426ea39331669868" translate="yes" xml:space="preserve">
          <source>Insert current item from the source into the target.</source>
          <target state="translated">Вставить текущий элемент из источника в цель.</target>
        </trans-unit>
        <trans-unit id="d776dcf131b9f5a24feff6fc21b29e6dcf5da88f" translate="yes" xml:space="preserve">
          <source>Insert finally block calls when doing a goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for EH_DWARF exception unwinding.</source>
          <target state="translated">Вставьте,наконец,блокировку вызовов при выполнении goto изнутри пробного блока наружу.Выполняется после того,как блоки сгенерированы,потому что тогда мы знаем все края графа,но до того,как будут вычислены Bpred.Только для размотки исключения EH_DWARF.</target>
        </trans-unit>
        <trans-unit id="5471bf7c7cfa66ea6e595c4758d088cf1cff366e" translate="yes" xml:space="preserve">
          <source>Insert gotos to finally blocks when doing a return or goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for functions with no exception handling. Very similar to insertFinallyBlockCalls().</source>
          <target state="translated">Вставьте готос,чтобы,наконец,блокировать при выполнении возврата или goto изнутри пробного блока наружу.Готово после того,как блоки сгенерированы,потому что тогда мы знаем все края графа,но до того,как вычисляются Bpred.Только для функций без исключений.Очень похоже на функцию insertFinallyBlockCalls().</target>
        </trans-unit>
        <trans-unit id="dac79eb40ab7303630f93c4973c9239f694c7c19" translate="yes" xml:space="preserve">
          <source>Insert item into list at nth position.</source>
          <target state="translated">Вставить пункт в список на n-ой позиции.</target>
        </trans-unit>
        <trans-unit id="e157f7049edabd9484326a29b8f9b52a72eaeb25" translate="yes" xml:space="preserve">
          <source>Inserted in place of invalid UTF sequences.</source>
          <target state="translated">Вставляется вместо недействительных последовательностей UTF.</target>
        </trans-unit>
        <trans-unit id="143f825d20ba520107ed764caaeba3c49e097300" translate="yes" xml:space="preserve">
          <source>Inserting if not present</source>
          <target state="translated">Вставка,если нет</target>
        </trans-unit>
        <trans-unit id="30a6615838d01663d72779532f25d77de2451cfa" translate="yes" xml:space="preserve">
          <source>Insertion failed because database is full</source>
          <target state="translated">Вставка не удалась,потому что база данных заполнена.</target>
        </trans-unit>
        <trans-unit id="20cdd78769ce43b7cb858f988154e98a6f228025" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime may be turned off with a compiler switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;code&gt;-boundscheck&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вставка кода проверки границ массива во время выполнения может быть отключена с помощью ключа &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt; &lt;code&gt;-boundscheck&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bdc47adb0591faa30b8ba1f2040d211a501160c" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime should be turned on and off with a compile time switch.</source>
          <target state="translated">Вставку кода проверки границ массивов во время выполнения следует включать и выключать с помощью переключателя времени компиляции.</target>
        </trans-unit>
        <trans-unit id="0fe401e132558c29c269b7fd6cffd6a1dc02d7db" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; (which must be an input range or any number of implicitly convertible items) in &lt;code&gt;array&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;stuff&lt;/code&gt; (который должен быть входным диапазоном или любым количеством неявно конвертируемых элементов) в &lt;code&gt;array&lt;/code&gt; в позиции &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbf9d19e58cf1e67a852d50890252788f63b174" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a non-empty range previously extracted from this container.</source>
          <target state="translated">Вставляет &lt;code&gt;stuff&lt;/code&gt; после диапазона &lt;code&gt;r&lt;/code&gt; , который должен быть непустым диапазоном, ранее извлеченным из этого контейнера.</target>
        </trans-unit>
        <trans-unit id="bbcf5a5de0747fda77b1e1e1643549b4e06e5bb8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a range previously extracted from this container. Given that all ranges for a list end at the end of the list, this function essentially appends to the list and uses &lt;code&gt;r&lt;/code&gt; as a potentially fast way to reach the last node in the list. Ideally &lt;code&gt;r&lt;/code&gt; is positioned near or at the last element of the list.</source>
          <target state="translated">Вставляет &lt;code&gt;stuff&lt;/code&gt; после диапазона &lt;code&gt;r&lt;/code&gt; , который должен быть диапазоном, ранее извлеченным из этого контейнера. Учитывая, что все диапазоны для конца списка находятся в конце списка, эта функция по существу добавляется в список и использует &lt;code&gt;r&lt;/code&gt; как потенциально быстрый способ достижения последнего узла в списке. В идеале &lt;code&gt;r&lt;/code&gt; располагается рядом или в последнем элементе списка.</target>
        </trans-unit>
        <trans-unit id="6f06bb00c64490bdfd0684d68ce1e50ed8931cf5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">Вставляет &lt;code&gt;stuff&lt;/code&gt; до, после или вместо диапазона &lt;code&gt;r&lt;/code&gt; , который должен быть допустимым диапазоном, ранее извлеченным из этого массива. &lt;code&gt;stuff&lt;/code&gt; может быть значением , конвертируемые в &lt;code&gt;T&lt;/code&gt; или диапазон объектов , конвертируемых в &lt;code&gt;T&lt;/code&gt; . Как стабильная, так и нестабильная версии ведут себя одинаково и гарантируют, что итерации диапазонов по массиву никогда не будут аннулированы.</target>
        </trans-unit>
        <trans-unit id="f08fcf4de04b5d69b89946f0b954703523fa90fc" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">Вставляет &lt;code&gt;stuff&lt;/code&gt; до, после или вместо диапазона &lt;code&gt;r&lt;/code&gt; , который должен быть допустимым диапазоном, ранее извлеченным из этого массива. &lt;code&gt;stuff&lt;/code&gt; могут быть значением, конвертируемым в &lt;code&gt;bool&lt;/code&gt; , или диапазоном объектов, конвертируемых в &lt;code&gt;bool&lt;/code&gt; . Как стабильная, так и нестабильная версии ведут себя одинаково и гарантируют, что итерации диапазонов по массиву никогда не будут аннулированы.</target>
        </trans-unit>
        <trans-unit id="dcb7963cdc25fdee24c788729e6be8dd4f7e3c27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">Вставляет &lt;code&gt;stuff&lt;/code&gt; в переднюю часть контейнера. &lt;code&gt;stuff&lt;/code&gt; может быть значением , конвертируемые в &lt;code&gt;T&lt;/code&gt; или диапазон объектов , конвертируемых в &lt;code&gt;T&lt;/code&gt; . Стабильная версия ведет себя так же, но гарантирует, что итерации диапазонов по контейнеру никогда не будут аннулированы.</target>
        </trans-unit>
        <trans-unit id="70b0bd082af545b88841219b95946def84b1bde5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front/back of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">Вставляет &lt;code&gt;stuff&lt;/code&gt; в переднюю / заднюю часть контейнера. &lt;code&gt;stuff&lt;/code&gt; может быть значением , конвертируемые в &lt;code&gt;T&lt;/code&gt; или диапазон объектов , конвертируемых в &lt;code&gt;T&lt;/code&gt; . Стабильная версия ведет себя так же, но гарантирует, что итерации диапазонов по контейнеру никогда не будут аннулированы.</target>
        </trans-unit>
        <trans-unit id="98d4bdcdc44b42cf7f92f1b1fa3789c2aceb532f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the back of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;v&lt;/code&gt; в конце &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="314547f0dd75063020e998c66bb1c080e7cc353d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the front of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;v&lt;/code&gt; в начале &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b4118de001ef07d96ca9dc875bb736525602b3c" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the store. If the underlying store is a range and &lt;code&gt;length == capacity&lt;/code&gt;, throws an exception.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в магазин. Если базовое хранилище имеет диапазон и &lt;code&gt;length == capacity&lt;/code&gt; , выдается исключение.</target>
        </trans-unit>
        <trans-unit id="7a861229c3ddec4f67c4aba3fc949701aaf45a21" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;c&lt;/code&gt; at a position (or positions) chosen by &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;c&lt;/code&gt; в позицию (или позиции), выбранную &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804f9143c06ffa0aedcfc5172722337eadf6df16" translate="yes" xml:space="preserve">
          <source>Inserts a blank line.</source>
          <target state="translated">Вставляет пустую строку.</target>
        </trans-unit>
        <trans-unit id="7a0447d3d52b9161fad5aa788df5312d0c9f70f2" translate="yes" xml:space="preserve">
          <source>Inserts a comment in the output.</source>
          <target state="translated">Вставляет комментарий в вывод.</target>
        </trans-unit>
        <trans-unit id="7a683c9546bcec22da2c836a994b3f342b2d3aa0" translate="yes" xml:space="preserve">
          <source>Inserts a full load/store memory fence (on platforms that need it). This ensures that all loads and stores before a call to this function are executed before any loads and stores after the call.</source>
          <target state="translated">Вставляет полный забор загрузки/хранения памяти (на платформах,которые в этом нуждаются).Это гарантирует,что все загрузки и хранения до вызова этой функции будут выполнены до любых загрузок и хранения после вызова.</target>
        </trans-unit>
        <trans-unit id="a94c7ccab5212d83d09585607543df4cd0d7b0e8" translate="yes" xml:space="preserve">
          <source>Inserts a separator between overloads of a given name.</source>
          <target state="translated">Вставляет разделитель между перегрузками заданного имени.</target>
        </trans-unit>
        <trans-unit id="aa15c23194538bcbb65217c20c49d6e178298d1b" translate="yes" xml:space="preserve">
          <source>Inserts inline code.</source>
          <target state="translated">Вставляет строчный код.</target>
        </trans-unit>
        <trans-unit id="be7c29e597d6483bb5cc792a0734c8430284107e" translate="yes" xml:space="preserve">
          <source>Inserts into an existing array at a given position.</source>
          <target state="translated">Вставляется в существующий массив в заданной позиции.</target>
        </trans-unit>
        <trans-unit id="b2e6a38a54ba983c83824eb96e11fa99e1fb236e" translate="yes" xml:space="preserve">
          <source>Inserts the separator symbols ',' every</source>
          <target state="translated">Вставляет символы сепаратора &quot;,&quot; каждый</target>
        </trans-unit>
        <trans-unit id="801258f3c2858353c18f16295039e48c4b8fb913" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Вставляет указанные элементы в конец массива. &lt;code&gt;stuff&lt;/code&gt; может быть значением , конвертируемые в &lt;code&gt;T&lt;/code&gt; или диапазон объектов , конвертируемых в &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14cde1bdd1549aef1d369341e6d66efc2807a4bc" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Вставляет указанные элементы в конец массива. &lt;code&gt;stuff&lt;/code&gt; могут быть значением, конвертируемым в &lt;code&gt;bool&lt;/code&gt; , или диапазоном объектов, конвертируемых в &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d605a6236091ada3048879c73c926d0efb2298d" translate="yes" xml:space="preserve">
          <source>Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add &lt;b&gt;'-'&lt;/b&gt; flag to &lt;code&gt;&quot;%(&quot;&lt;/code&gt;.</source>
          <target state="translated">Внутри составного спецификатора формата строки и символы экранируются автоматически. Чтобы избежать такого поведения, добавьте флаг &lt;b&gt;&amp;laquo;-&amp;raquo;&lt;/b&gt; в &lt;code&gt;&quot;%(&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">Переменные инстанции</target>
        </trans-unit>
        <trans-unit id="6dcf70f56aa9632f46bb219a5e2ab80717bd81f1" translate="yes" xml:space="preserve">
          <source>Instance shared by all callers.</source>
          <target state="translated">Экземпляр разделен между всеми звонящими.</target>
        </trans-unit>
        <trans-unit id="1d560aaea91ff74c40b9ba925224eb2e9cab5714" translate="yes" xml:space="preserve">
          <source>Instances of class objects are created with a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">Экземпляры объектов класса создаются с помощью &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;выражения NewExpression&lt;/i&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0e15b22639879009392385cbbbd0e07778e511d1" translate="yes" xml:space="preserve">
          <source>Instances of this object are constructed via calls to &lt;code&gt;regex&lt;/code&gt;. This is an intended form for caching and storage of frequently used regular expressions.</source>
          <target state="translated">Экземпляры этого объекта создаются через вызовы &lt;code&gt;regex&lt;/code&gt; . Это предназначенная форма для кэширования и хранения часто используемых регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="9c373dca3c1b04cc6629e642fffbe62b3a9fe4e5" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;DebugCondition&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DebugCondition&lt;/code&gt; нового условия отладки</target>
        </trans-unit>
        <trans-unit id="3822674a7468f752517c5bf52d226dd0137e7bff" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;VersionCondition&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VersionCondition&lt;/code&gt; новую версию</target>
        </trans-unit>
        <trans-unit id="152f1a2b9d65da1e9f82b24f153f213ef690987a" translate="yes" xml:space="preserve">
          <source>Instantiates the given template with the given parameters.</source>
          <target state="translated">Автоматически инстанцирует данный шаблон с заданными параметрами.</target>
        </trans-unit>
        <trans-unit id="4a327f215e80d73f8ee4464a28c7b7c009445a31" translate="yes" xml:space="preserve">
          <source>Instantiation Scope</source>
          <target state="translated">Область применения</target>
        </trans-unit>
        <trans-unit id="93486e626687f1b1676b1b49e1fd6518a0b454b0" translate="yes" xml:space="preserve">
          <source>Instantiation information</source>
          <target state="translated">Информация по инстанцированию</target>
        </trans-unit>
        <trans-unit id="dac2b060e0095872817c2470eb8b53d6b6180adb" translate="yes" xml:space="preserve">
          <source>Instatiates a new function call expression</source>
          <target state="translated">Устанавливает выражение вызова новой функции</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="a0905dbb5b366516614f7115449ef89eac51f289" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to not use any signal/alarm handlers, even when using timeouts. This option is useful for multi-threaded applications. See libcurl-the-guide for more background information.</source>
          <target state="translated">Инструктируйте libcurl не использовать никаких обработчиков сигналов/тревог,даже при использовании таймаутов.Эта опция полезна для многопоточных приложений.Дополнительную информацию см.в руководстве libcurl.</target>
        </trans-unit>
        <trans-unit id="93df39339f21a04f493609200c104dc46ba84fa9" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to use a smaller receive buffer</source>
          <target state="translated">Инструктировать libcurl использовать меньший буфер приема</target>
        </trans-unit>
        <trans-unit id="4e856d175354403c672463be1daf8914ce0f2b64" translate="yes" xml:space="preserve">
          <source>Instruct the thread module, when initialized, to use a different set of signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads. This function should be called at most once, prior to thread_init(). This function is Posix-only.</source>
          <target state="translated">Инструктировать модуль потока при инициализации использовать другой набор сигналов,помимо SIGUSR1 и SIGUSR2,для приостановки и возобновления потоков.Эту функцию следует вызывать максимум один раз перед функцией thread_init().Эта функция предназначена только для Posix.</target>
        </trans-unit>
        <trans-unit id="ea729c0363a2bc9c76992c1a2e2bf3e5220ecc9e" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file, suitable for input to a linker.</source>
          <target state="translated">Инструкции выбираются из целевой архитектуры для реализации семантики программы.Типичным результатом будет объектный файл,пригодный для ввода в компоновщик.</target>
        </trans-unit>
        <trans-unit id="492ad7a25e9093c89a88ab9eae0481a3d6d480b5" translate="yes" xml:space="preserve">
          <source>IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;(Expression e);</source>
          <target state="translated">IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt; (Выражение e);</target>
        </trans-unit>
        <trans-unit id="562d27265f4183bba6926e62be0c6ce57f7e2097" translate="yes" xml:space="preserve">
          <source>Integer Literals</source>
          <target state="translated">целые буквы</target>
        </trans-unit>
        <trans-unit id="bd777b837ba4f419f4b02435e27128be81023ef2" translate="yes" xml:space="preserve">
          <source>Integer Promotions</source>
          <target state="translated">Интегральные Промоушн</target>
        </trans-unit>
        <trans-unit id="9568ecb6786424f8ca136701942b4f686fc642d2" translate="yes" xml:space="preserve">
          <source>Integer Promotions are conversions of the following types:</source>
          <target state="translated">Целочисленные акции-это преобразования следующих типов:</target>
        </trans-unit>
        <trans-unit id="db47076f1ac16cea001c1edc5817f57fa5127f93" translate="yes" xml:space="preserve">
          <source>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL]</source>
          <target state="translated">Целое целое число:(байт,убайт,короткий,ушорт,int,uint,long и ulong)['+'|'-']цифра(ы)[U|L|UL].</target>
        </trans-unit>
        <trans-unit id="2c1da0fff670105eb87d89c45a8168527ceeec25" translate="yes" xml:space="preserve">
          <source>Integer comparison operators</source>
          <target state="translated">Операторы интегрального сравнения</target>
        </trans-unit>
        <trans-unit id="b5ccca1ae24a500cd1c22e7e4ca7606c1848c22a" translate="yes" xml:space="preserve">
          <source>Integer comparisons</source>
          <target state="translated">Целочисленные сравнения</target>
        </trans-unit>
        <trans-unit id="343b406e188c4782bf6c33cf9f047756fbc9ecb9" translate="yes" xml:space="preserve">
          <source>Integer comparisons happen when both operands are integral types.</source>
          <target state="translated">Целочисленные сравнения происходят,когда оба операнда являются интегральными типами.</target>
        </trans-unit>
        <trans-unit id="adcbb9dbe2818c1f42e7e40cd4eb69ffc2847624" translate="yes" xml:space="preserve">
          <source>Integer values cannot be implicitly converted to another type that cannot represent the integer bit pattern after integral promotion. For example:</source>
          <target state="translated">Целые значения не могут быть неявно приведены к другому типу,который не может представлять собой целочисленный битовый паттерн после интегрального продвижения.Например:</target>
        </trans-unit>
        <trans-unit id="2745c9287a60962527a82479b71c8fcdcdfee9b5" translate="yes" xml:space="preserve">
          <source>IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt;(int v)();</source>
          <target state="translated">IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt; (int v) ();</target>
        </trans-unit>
        <trans-unit id="9ef2cfdc220f6cdcf3fe63e63ff8a17f54977fca" translate="yes" xml:space="preserve">
          <source>IntegerExpression</source>
          <target state="translated">IntegerExpression</target>
        </trans-unit>
        <trans-unit id="17c52e79fc66bb6ecd61f1fe24bcec43e30c42c1" translate="yes" xml:space="preserve">
          <source>IntegerLiteral</source>
          <target state="translated">IntegerLiteral</target>
        </trans-unit>
        <trans-unit id="36d10f6bb46fb8657ec9f18b1e3a960789ae3c76" translate="yes" xml:space="preserve">
          <source>Integers (that may be constant-folded).</source>
          <target state="translated">Целочисленные (которые могут быть непрерывно сложены).</target>
        </trans-unit>
        <trans-unit id="f69d4a47975b227c4173e0f25508229d914b2ec7" translate="yes" xml:space="preserve">
          <source>Integers and floating point values can be implicitly converted to their vector equivalents:</source>
          <target state="translated">Целые числа и значения с плавающей точкой могут быть неявно преобразованы в их векторные эквиваленты:</target>
        </trans-unit>
        <trans-unit id="85eae330c4b91b44cc2722cee1dc4a35c6511dee" translate="yes" xml:space="preserve">
          <source>Integers can be immediately followed by one &amp;lsquo;L&amp;rsquo; or one of &amp;lsquo;u&amp;rsquo; or &amp;lsquo;U&amp;rsquo; or both. Note that there is no &amp;lsquo;l&amp;rsquo; suffix.</source>
          <target state="translated">За целыми числами могут сразу следовать один &amp;laquo;L&amp;raquo; или один из &amp;laquo;u&amp;raquo; или &amp;laquo;U&amp;raquo; или оба. Обратите внимание, что суффикса 'l' нет.</target>
        </trans-unit>
        <trans-unit id="78c49e8c1cc448a9049ab277bc8754ecd4237b78" translate="yes" xml:space="preserve">
          <source>Integers can be specified in decimal, binary, or hexadecimal.</source>
          <target state="translated">Целочисленные могут быть указаны в десятичной,двоичной или шестнадцатеричной форме.</target>
        </trans-unit>
        <trans-unit id="2f0a498505f60eef0691bff5f687040cecb8e8a2" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">Целые числа могут иметь встроенные символы &amp;laquo;_&amp;raquo;, которые игнорируются.</target>
        </trans-unit>
        <trans-unit id="e97fd09a5e159320944c7a6e53ff8dac7ae91693" translate="yes" xml:space="preserve">
          <source>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types.</source>
          <target state="translated">Встроенные арифметические операторы работают с фиксированными типами ширины.Результаты,не отображаемые в этих фиксированных ширинах,бесшумно усекаются по размеру.В данном модуле предлагаются интегральные арифметические примитивы,которые дают те же результаты,но при этом устанавливают флаг &quot;переполнение&quot; при таком усечении.Установка является липкой,что означает,что многочисленные операции могут быть каскадированы,а затем флаг должен быть проверен только в конце.Подписанная или неподписанная операция обозначается суффиксом 's' или 'u' соответственно.Хотя этого можно добиться и без таких суффиксов,используя перегрузку по знаковой принадлежности типов,суффикс дает понять,что происходит без необходимости проверять типы.</target>
        </trans-unit>
        <trans-unit id="6c054c378c65fd28ca92392142534a3f43340caf" translate="yes" xml:space="preserve">
          <source>Integral ranges</source>
          <target state="translated">Интегральные диапазоны</target>
        </trans-unit>
        <trans-unit id="3c327fe3bc8ca1ef616b394085c0f88695904ee8" translate="yes" xml:space="preserve">
          <source>Integral types will remain the same sizes between 32 and 64 bit code.</source>
          <target state="translated">Интегральные типы останутся одинаковыми по размеру между 32 и 64 битным кодом.</target>
        </trans-unit>
        <trans-unit id="58ee21eb085c257d8a08439c9aa7bd9d6570255b" translate="yes" xml:space="preserve">
          <source>Integrals</source>
          <target state="translated">Integrals</target>
        </trans-unit>
        <trans-unit id="304d073445766b9e99ba6213d6788d69fbbe285d" translate="yes" xml:space="preserve">
          <source>Integrals are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Интегралы отформатированы как &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20aeee70fc77c214f263c77b05117e3b20686b33" translate="yes" xml:space="preserve">
          <source>Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.</source>
          <target state="translated">Intel Atom 230/330 (семейство 6,модель 0x1C)-ядро под заказ.</target>
        </trans-unit>
        <trans-unit id="25a734a01cad152ff48222d53e7362444f3ac6cd" translate="yes" xml:space="preserve">
          <source>Intel NetBurst (Pentium 4, Pentium D).</source>
          <target state="translated">Intel NetBurst (Pentium 4,Pentium D).</target>
        </trans-unit>
        <trans-unit id="40d218fe001ffffff82fbf964a99f28c6e816245" translate="yes" xml:space="preserve">
          <source>Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</source>
          <target state="translated">Intel P6 (PentiumPro,PII,PIII,PM,Core,Core2).</target>
        </trans-unit>
        <trans-unit id="ffc1549d5dca52e99aa4ab17a1e6e08f96cd5245" translate="yes" xml:space="preserve">
          <source>Intel and AMD 32-bit processors</source>
          <target state="translated">32-битные процессоры Intel и AMD</target>
        </trans-unit>
        <trans-unit id="3eaebee622e08211c80a68d4d6c79b54e2adb573" translate="yes" xml:space="preserve">
          <source>Intel and AMD 64-bit processors</source>
          <target state="translated">64-битные процессоры Intel и AMD</target>
        </trans-unit>
        <trans-unit id="d9d20cde548a0781b6cf33434f83eb6eb5ef95f8" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="translated">Предназначен как эквивалент диапазона утилит &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;хвоста&lt;/a&gt; Unix . Когда длина &lt;code&gt;range&lt;/code&gt; меньше или равна &lt;code&gt;_n&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; возвращается как есть.</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="d88c1e8acf6c80eddca147502d3048d176708e8b" translate="yes" xml:space="preserve">
          <source>Interface for a bidirectional range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Интерфейс для двунаправленного диапазона типа &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e1da15b0eee348c354776c7e919fb0b891bd0d" translate="yes" xml:space="preserve">
          <source>Interface for a finite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Интерфейс для конечного случайного диапазона доступа типа &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a634a284850ac6bc64c6899e29c994e3e0d76a1" translate="yes" xml:space="preserve">
          <source>Interface for a forward range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Интерфейс для прямого диапазона типа &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a821a67cbe42a25dc97be41d2bf278fa2b3f8d9" translate="yes" xml:space="preserve">
          <source>Interface for an infinite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Интерфейс для бесконечного случайного диапазона доступа типа &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d0cf57e850156d9f049479c7169bad62b9af52" translate="yes" xml:space="preserve">
          <source>Interface for an output range of type &lt;code&gt;E&lt;/code&gt;. Usage is similar to the &lt;code&gt;InputRange&lt;/code&gt; interface and descendants.</source>
          <target state="translated">Интерфейс для выходного диапазона типа &lt;code&gt;E&lt;/code&gt; . Использование аналогично интерфейсу &lt;code&gt;InputRange&lt;/code&gt; и его потомкам.</target>
        </trans-unit>
        <trans-unit id="9460943add2d33f93432076ae984835cefe527f7" translate="yes" xml:space="preserve">
          <source>Interface for diagnostic reporting.</source>
          <target state="translated">Интерфейс для диагностической отчетности.</target>
        </trans-unit>
        <trans-unit id="3a1df4ab19b1c423cdf62882763fa74c4af37e82" translate="yes" xml:space="preserve">
          <source>Interface member functions can have contracts even though there is no body for the function. The contracts are inherited by any class member function that implements that interface member function.</source>
          <target state="translated">Функции членов интерфейса могут иметь контракты,даже если для этой функции нет тела.Контракты наследуются любой функцией-членом класса,реализующей эту интерфейсную функцию-член.</target>
        </trans-unit>
        <trans-unit id="f3be3896196c198c957ce4d700b0918b399182de" translate="yes" xml:space="preserve">
          <source>Interface to C++</source>
          <target state="translated">Интерфейс на C++</target>
        </trans-unit>
        <trans-unit id="d7b35a8578bedf4b2033b8a1d3efb36b51c26426" translate="yes" xml:space="preserve">
          <source>Interface to ODBC C library.</source>
          <target state="translated">Интерфейс к библиотеке ODBC C.</target>
        </trans-unit>
        <trans-unit id="621522c8d929097b62eb853aff27378218dcc932" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">Интерфейс для специфических для ОС распределителей, которые поддерживают указание выравнивания: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt; в Posix и &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_xxx&lt;/code&gt; &lt;/a&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="da8580df0429b0473e5e3791367530334b73829e" translate="yes" xml:space="preserve">
          <source>Interface to SQLite C library.</source>
          <target state="translated">Интерфейс к библиотеке SQLite C.</target>
        </trans-unit>
        <trans-unit id="7de306419630810feb8071066cf5e31bb55e01fb" translate="yes" xml:space="preserve">
          <source>Interface to libcurl C library.</source>
          <target state="translated">Интерфейс к библиотеке libcurl C.</target>
        </trans-unit>
        <trans-unit id="f42fa13806030306bbca72d2c1d02ced3c60299a" translate="yes" xml:space="preserve">
          <source>Interface to the C linked list type.</source>
          <target state="translated">Интерфейс к типу связанного списка C.</target>
        </trans-unit>
        <trans-unit id="e3744c2b6a83f2ded743b60e48109853d6af0029" translate="yes" xml:space="preserve">
          <source>Interface to zlib C library.</source>
          <target state="translated">Интерфейс к библиотеке zlib C.</target>
        </trans-unit>
        <trans-unit id="0e4b1bcf55c79cee225ecf64df995188b37f85a9" translate="yes" xml:space="preserve">
          <source>Interface[] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt;;</source>
          <target state="translated">Интерфейс [] &lt;strong id=&quot;interfaces&quot;&gt;интерфейсы&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="87ef706c8b2c0856ee57ff234b67b63ee3440c74" translate="yes" xml:space="preserve">
          <source>Interfaces can be inherited and functions overridden:</source>
          <target state="translated">Интерфейсы могут наследоваться,а функции переопределяться:</target>
        </trans-unit>
        <trans-unit id="5c38dbc7db84c5be19893f9ea37a5e4e03b244d7" translate="yes" xml:space="preserve">
          <source>Interfaces can be reimplemented in derived classes:</source>
          <target state="translated">Интерфейсы могут быть повторно реализованы в производных классах:</target>
        </trans-unit>
        <trans-unit id="5c369ab8b0d4a9f58e24c8d22b04e27527c78058" translate="yes" xml:space="preserve">
          <source>Interfaces can have function templates in the members. All instantiated functions are implicitly &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">Интерфейсы могут иметь шаблоны функций в элементах. Все созданные функции неявно являются &lt;code&gt;final&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdf123e52e487e317a85601aa2c062c8ae21bd83" translate="yes" xml:space="preserve">
          <source>Interfaces cannot derive from classes; only from other interfaces. Classes cannot derive from an interface multiple times.</source>
          <target state="translated">Интерфейсы не могут быть получены из классов;только из других интерфейсов.Классы не могут быть получены из интерфейса несколько раз.</target>
        </trans-unit>
        <trans-unit id="233b20e42a18eec431d3cd18cbd18fa45bf5e124" translate="yes" xml:space="preserve">
          <source>Interfaces describe a list of functions that a class that inherits from the interface must implement. A class that implements an interface can be converted to a reference to that interface.</source>
          <target state="translated">Интерфейсы описывают список функций,которые должен реализовать класс,наследуемый от интерфейса.Класс,реализующий интерфейс,может быть преобразован в ссылку на этот интерфейс.</target>
        </trans-unit>
        <trans-unit id="c99b66b1687d267b80c156d483b9207e87aa2612" translate="yes" xml:space="preserve">
          <source>Interfaces to extend FTS5.</source>
          <target state="translated">Интерфейсы для расширения FTS5.</target>
        </trans-unit>
        <trans-unit id="737865cc9d40029ada2522214f2743a9901cb1cf" translate="yes" xml:space="preserve">
          <source>Interfaces with Contracts</source>
          <target state="translated">Интерфейсы с договорами</target>
        </trans-unit>
        <trans-unit id="772a604c8c3d9a084a30e26beb308940804e19fb" translate="yes" xml:space="preserve">
          <source>Interfacing Garbage Collected Objects With Foreign Code</source>
          <target state="translated">Взаимосвязь между собранным мусором и инородным кодом</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
