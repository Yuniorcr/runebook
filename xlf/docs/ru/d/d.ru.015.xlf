<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="be4757e5f7ed594d353a3c4ce7de74c4983ee1bc" translate="yes" xml:space="preserve">
          <source>A custom logger must implement this method in order to work in a &lt;code&gt;MultiLogger&lt;/code&gt; and &lt;code&gt;ArrayLogger&lt;/code&gt;.</source>
          <target state="translated">Пользовательский регистратор должен реализовать этот метод для работы в &lt;code&gt;MultiLogger&lt;/code&gt; и &lt;code&gt;ArrayLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799797c474eb4f64da708eeb1b0ae0ce2ca98b4f" translate="yes" xml:space="preserve">
          <source>A custom predicate may be specified, in which case &lt;code&gt;cmp&lt;/code&gt; performs a three-way lexicographical comparison using &lt;code&gt;pred&lt;/code&gt;. Otherwise the elements are compared using &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">Можно указать пользовательский предикат, и в этом случае &lt;code&gt;cmp&lt;/code&gt; выполняет трехстороннее лексикографическое сравнение с использованием &lt;code&gt;pred&lt;/code&gt; . В противном случае элементы сравниваются с помощью &lt;code&gt;opCmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd5f14f91830e3b180587500ec130f97919c3090" translate="yes" xml:space="preserve">
          <source>A data structure that describes a back-end compiler and implements compiler-specific actions.</source>
          <target state="translated">Структура данных,описывающая внутренний компилятор и реализующая действия,специфичные для компилятора.</target>
        </trans-unit>
        <trans-unit id="8b24734792d48aaa55d8beb949d2173660883a4f" translate="yes" xml:space="preserve">
          <source>A decoded UTF character.</source>
          <target state="translated">Расшифрованный символ UTF.</target>
        </trans-unit>
        <trans-unit id="dc144ed1205402bc32e7140dccebc230d0cffdf8" translate="yes" xml:space="preserve">
          <source>A default constructed BitFlags has no value set</source>
          <target state="translated">Построенный по умолчанию BitFlags не имеет установленного значения.</target>
        </trans-unit>
        <trans-unit id="7241125a45123adb97fae3dc4d79e639b542dd27" translate="yes" xml:space="preserve">
          <source>A delegate can be set to a non-static nested function:</source>
          <target state="translated">Делегат может быть настроен на нестатическую вложенную функцию:</target>
        </trans-unit>
        <trans-unit id="d165603cc434a66cb4b67c233b63030eb28be9e8" translate="yes" xml:space="preserve">
          <source>A delegate for accepting possibly piecewise segments of the formatted string.</source>
          <target state="translated">Делегат для принятия,возможно,кусочно-сегментарных сегментов отформатированной строки.</target>
        </trans-unit>
        <trans-unit id="d8451320bfb14fe03d6a64f1077a5de8e98790a3" translate="yes" xml:space="preserve">
          <source>A delegate is initialized analogously to function pointers:</source>
          <target state="translated">Делегат инициализируется аналогично указателям на функции:</target>
        </trans-unit>
        <trans-unit id="3107da21260042db04bf812a226e586a93ae22ae" translate="yes" xml:space="preserve">
          <source>A delegate literal</source>
          <target state="translated">Делегат буквально</target>
        </trans-unit>
        <trans-unit id="b63c50f651ca90cd0155830bc27dcdbf4106b121" translate="yes" xml:space="preserve">
          <source>A delegate with the context pointer pointing to nothing.</source>
          <target state="translated">Делегат с контекстным указателем ни на что не указывает.</target>
        </trans-unit>
        <trans-unit id="e76ab300621498b9abbf6dd2c63acc55f60be015" translate="yes" xml:space="preserve">
          <source>A derived class can be implicitly converted to its base class, but going the other way requires an explicit cast. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95991bd69e5da0db53d674c525b393473c76b97c" translate="yes" xml:space="preserve">
          <source>A describing string of the status code</source>
          <target state="translated">Строка описания кода статуса</target>
        </trans-unit>
        <trans-unit id="b485b880cb7c20357d55aa1666ab5002c33f7f71" translate="yes" xml:space="preserve">
          <source>A destructor of an object must not access object references within the object. This means that an implementation is free to optimize based on this rule.</source>
          <target state="translated">Деструктор объекта не должен иметь доступ к ссылкам на объект внутри объекта.Это означает,что реализация свободна для оптимизации на основе этого правила.</target>
        </trans-unit>
        <trans-unit id="8f2e130bf28fec18f76c5350c6830f3d384e9b8e" translate="yes" xml:space="preserve">
          <source>A detailed description of the flag</source>
          <target state="translated">Подробное описание флага</target>
        </trans-unit>
        <trans-unit id="64e621fdf33353cafd7bb5f388b648c67a616cd2" translate="yes" xml:space="preserve">
          <source>A detailed string describing the given status code</source>
          <target state="translated">Подробная строка,описывающая данный код статуса</target>
        </trans-unit>
        <trans-unit id="49d3e178f25fa306f883ebaa019762236385876f" translate="yes" xml:space="preserve">
          <source>A digest must be a struct (value type) to pass the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test.</source>
          <target state="translated">Дайджест должен быть структурой (типом значения) для прохождения теста &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9365344124be29b4c5ed190c2b837f534d7b14ed" translate="yes" xml:space="preserve">
          <source>A digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test is always an &lt;code&gt;OutputRange&lt;/code&gt;</source>
          <target state="translated">Дайджест, проходящий тест &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; ,&lt;/a&gt; всегда является &lt;code&gt;OutputRange&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c1878a38d32ea2675597a3c9b9460fc661094f" translate="yes" xml:space="preserve">
          <source>A digest representation</source>
          <target state="translated">Представление дайджеста</target>
        </trans-unit>
        <trans-unit id="dc5b8b46429d9769b6b9b3e709cbca2c3e001a8f" translate="yes" xml:space="preserve">
          <source>A disabled default constructor may not have a &lt;a href=&quot;function#FunctionBody&quot;&gt;&lt;i&gt;FunctionBody&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function#FunctionBody&quot;&gt;&lt;i&gt;Отключенный&lt;/i&gt;&lt;/a&gt; конструктор по умолчанию может не иметь &lt;i&gt;FunctionBody&lt;/i&gt; .</target>
        </trans-unit>
        <trans-unit id="267e0978240615ba77986e09fef1791e0fbe71ef" translate="yes" xml:space="preserve">
          <source>A domain literal contains a character that is not allowed</source>
          <target state="translated">Буквальный домен содержит символ,который не разрешен</target>
        </trans-unit>
        <trans-unit id="ba76d09dbfa5d3c9aca7c8c1b7293cc30ad9aee1" translate="yes" xml:space="preserve">
          <source>A domain or subdomain cannot begin with a hyphen</source>
          <target state="translated">Домен или субдомен не может начинаться с дефиса</target>
        </trans-unit>
        <trans-unit id="472b7768887bd46b5b6c5d8a32dbebea7be62447" translate="yes" xml:space="preserve">
          <source>A domain or subdomain cannot end with a hyphen</source>
          <target state="translated">Домен или субдомен не может заканчиваться дефисом</target>
        </trans-unit>
        <trans-unit id="d3a8a4725317af5767f7fd5f563f6da497b72b8b" translate="yes" xml:space="preserve">
          <source>A dotted expression is evaluated during the compilation and then must either give a constant or indicate a higher level variable that fits in the target register or variable.</source>
          <target state="translated">Пунктирное выражение вычисляется во время компиляции и затем должно либо дать константу,либо указать переменную более высокого уровня,которая помещается в целевой регистр или переменную.</target>
        </trans-unit>
        <trans-unit id="9353d5e0ce9a867f8dd22b89582a4ae92f0c877c" translate="yes" xml:space="preserve">
          <source>A duplicate of the array.</source>
          <target state="translated">Дубликат массива.</target>
        </trans-unit>
        <trans-unit id="48379b3f4c92aa4ecbe22826de3141967da52b7c" translate="yes" xml:space="preserve">
          <source>A dynamic array &lt;code&gt;T[]&lt;/code&gt; can be implicitly converted to one of the following (&lt;code&gt;U&lt;/code&gt; is a base class of &lt;code&gt;T&lt;/code&gt;):</source>
          <target state="translated">Динамический массив &lt;code&gt;T[]&lt;/code&gt; может быть неявно преобразован в одно из следующего ( &lt;code&gt;U&lt;/code&gt; является базовым классом &lt;code&gt;T&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f557446cd339782ac911dc86e31dba9820fb2b0f" translate="yes" xml:space="preserve">
          <source>A dynamic array consists of:</source>
          <target state="translated">Динамический массив состоит из:</target>
        </trans-unit>
        <trans-unit id="769645abad5552d5c7ebff94542af817087119b6" translate="yes" xml:space="preserve">
          <source>A dynamic array is declared as:</source>
          <target state="translated">Динамический массив объявлен как:</target>
        </trans-unit>
        <trans-unit id="04c7f71668d3f1ebb6df6a9217407ba6b0471d81" translate="yes" xml:space="preserve">
          <source>A dynamic array is safe when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad5fadfec136ac1c906cd770e62df908403c57a" translate="yes" xml:space="preserve">
          <source>A dynamic array of bits. Each bit in a &lt;code&gt;BitArray&lt;/code&gt; can be manipulated individually or by the standard bitwise operators &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and also by other effective member functions; most of them work relative to the &lt;code&gt;BitArray&lt;/code&gt;'s dimension (see &lt;a href=&quot;#dim&quot;&gt;&lt;code&gt;dim&lt;/code&gt;&lt;/a&gt;), instead of its &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Динамический массив битов. Каждый бит в &lt;code&gt;BitArray&lt;/code&gt; может управляться индивидуально или стандартными побитовыми операторами &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , а также другими эффективными функциями-членами; большинство из них работают относительно &lt;code&gt;BitArray&lt;/code&gt; (см. &lt;a href=&quot;#dim&quot;&gt; &lt;code&gt;dim&lt;/code&gt; &lt;/a&gt; ), а не его &lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5519eb07d8a7fa9fdb9767cb387a2288cf9b1718" translate="yes" xml:space="preserve">
          <source>A dynamic array, say &lt;code&gt;x&lt;/code&gt;, of a derived class can be implicitly converted to a dynamic array, say &lt;code&gt;y&lt;/code&gt;, of a base class iff elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are qualified as being either both &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;both&lt;/code&gt;&lt;code&gt;immutable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a823701b6e24504fe5de92693bf0712360f7176" translate="yes" xml:space="preserve">
          <source>A dynamic array.</source>
          <target state="translated">Динамический массив.</target>
        </trans-unit>
        <trans-unit id="8d1f86e731d6d3f255aae8cc21f6ea7bd9977c40" translate="yes" xml:space="preserve">
          <source>A factorial number is constructed as: &lt;code&gt;fac[0] * 0! + fac[1] * 1! + ... fac[20] * 20!&lt;/code&gt;</source>
          <target state="translated">Факториальное число строится как: &lt;code&gt;fac[0] * 0! + fac[1] * 1! + ... fac[20] * 20!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c360c4983c5304316b38ca5a7f80351574611f4d" translate="yes" xml:space="preserve">
          <source>A factory function that instantiates an implementation of the GC interface. In case the instance was allocated on the C heap, it is supposed to free itself upon calling it's destructor.</source>
          <target state="translated">Заводская функция,которая воплощает в жизнь реализацию интерфейса GC.В случае,если экземпляр был выделен на куче С,он должен освободить себя при вызове деструктора.</target>
        </trans-unit>
        <trans-unit id="38b8c02930d83071f30dd3df81a96653346d17eb" translate="yes" xml:space="preserve">
          <source>A fiber may occupy one of three states: HOLD, EXEC, and TERM.</source>
          <target state="translated">Волокно может занимать один из трех штатов:ДЕРЖАТЬ,ВЫДВИЖАТЬ и ТЕРМ.</target>
        </trans-unit>
        <trans-unit id="66c6071116b4d2fdb4f7a179bb8e8819e8128bfa" translate="yes" xml:space="preserve">
          <source>A field containing new lines, commas, or double quotes should be enclosed in double quotes (customizable)</source>
          <target state="translated">Поле,содержащее новые строки,запятые или двойные кавычки,должно быть заключено в двойные кавычки (настраиваемые).</target>
        </trans-unit>
        <trans-unit id="13dba716c7be91345b2e8e05ae52fa557a401474" translate="yes" xml:space="preserve">
          <source>A field initialization may not appear in a loop or after a label.</source>
          <target state="translated">Инициализация поля может не отображаться в петле или после метки.</target>
        </trans-unit>
        <trans-unit id="cb5b8dc7f0df24926cf254a0bfbbc182f8c26034" translate="yes" xml:space="preserve">
          <source>A file may contain only one module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d09baad5ebafd14b8ebc685e119e0305eb8b677" translate="yes" xml:space="preserve">
          <source>A filename character.</source>
          <target state="translated">Персонаж с фамилией.</target>
        </trans-unit>
        <trans-unit id="13c45baabf68f0db140e55a83843cebb9e0d0ee6" translate="yes" xml:space="preserve">
          <source>A final record may end with a new line</source>
          <target state="translated">Окончательный рекорд может закончиться новой строкой</target>
        </trans-unit>
        <trans-unit id="691790452cc69aa06a18a55e65d68f00b9dfac22" translate="yes" xml:space="preserve">
          <source>A final switch statement is just like a switch statement, except that:</source>
          <target state="translated">Последнее заявление о переключении похоже на заявление о переключении,за исключением этого:</target>
        </trans-unit>
        <trans-unit id="f2171adbbabe0f5fba4dad2832bc25b6310bc844" translate="yes" xml:space="preserve">
          <source>A finite &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;</source>
          <target state="translated">Конечный &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;диапазон вперед&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da5d20251067de5102646dc808372484964be135" translate="yes" xml:space="preserve">
          <source>A fixed-sized sliding window iteration of size &lt;code&gt;windowSize&lt;/code&gt; over a &lt;code&gt;source&lt;/code&gt; range by a custom &lt;code&gt;stepSize&lt;/code&gt;.</source>
          <target state="translated">Скользящее окно фиксированного размера итерации размера &lt;code&gt;windowSize&lt;/code&gt; по &lt;code&gt;source&lt;/code&gt; диапазону с помощью пользовательского &lt;code&gt;stepSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ee3853d383c295b0b469963a93bdeac7a047ad1" translate="yes" xml:space="preserve">
          <source>A floating point number is formatted as one digit before the decimal point,</source>
          <target state="translated">Число с плавающей точкой форматируется как одна цифра перед десятичной точкой,</target>
        </trans-unit>
        <trans-unit id="0fcb6a4bc54f11ec79b0e537d26abd92626762ff" translate="yes" xml:space="preserve">
          <source>A floating point number is formatted in decimal notation. The</source>
          <target state="translated">Число с плавающей точкой форматируется в десятичной системе счисления.</target>
        </trans-unit>
        <trans-unit id="f6219fd3d71d3de6df27296e5476840f4df22efc" translate="yes" xml:space="preserve">
          <source>A floating point number is formatted in either &lt;b&gt;e&lt;/b&gt; or &lt;b&gt;f&lt;/b&gt; format for &lt;b&gt;g&lt;/b&gt;; &lt;b&gt;E&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; format for &lt;b&gt;G&lt;/b&gt;. The &lt;b&gt;f&lt;/b&gt; format is used if the exponent for an &lt;b&gt;e&lt;/b&gt; format is greater than -5 and less than the</source>
          <target state="translated">Число с плавающей запятой форматируется в формате &lt;b&gt;e&lt;/b&gt; или &lt;b&gt;f&lt;/b&gt; для &lt;b&gt;g&lt;/b&gt; ; &lt;b&gt;E&lt;/b&gt; или &lt;b&gt;F&lt;/b&gt; формат &lt;b&gt;G&lt;/b&gt; . Формат &lt;b&gt;f&lt;/b&gt; используется, если показатель степени для формата &lt;b&gt;e&lt;/b&gt; больше -5 и меньше, чем</target>
        </trans-unit>
        <trans-unit id="26a231f9b44b90d5cc01f2a042dd13e9e8f17322" translate="yes" xml:space="preserve">
          <source>A floating point number is formatted in hexadecimal exponential notation 0x</source>
          <target state="translated">Число с плавающей точкой форматируется в шестнадцатеричной экспоненциальной нотации 0x</target>
        </trans-unit>
        <trans-unit id="062fc16d5db2ce6c8599ac4365db441cb37d0350" translate="yes" xml:space="preserve">
          <source>A floating point number of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">Число с плавающей запятой типа &lt;code&gt;Target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="901ff63f0a480b571dc07ef5543f235f0f1f0bd3" translate="yes" xml:space="preserve">
          <source>A foreach range statement loops over the specified range.</source>
          <target state="translated">Петля оператора диапазона форач-диапазона в заданном диапазоне.</target>
        </trans-unit>
        <trans-unit id="e7b91358e238d4fe82d317197a4cd35e24ce70af" translate="yes" xml:space="preserve">
          <source>A format specifier.</source>
          <target state="translated">Спецификатор формата.</target>
        </trans-unit>
        <trans-unit id="8a84c26f1cb79a86b121cd3e356672ea932f998e" translate="yes" xml:space="preserve">
          <source>A format string specifying the output format.</source>
          <target state="translated">Строка формата,определяющая выходной формат.</target>
        </trans-unit>
        <trans-unit id="7b57d3b4c75d69aaf821093e631e86c701265934" translate="yes" xml:space="preserve">
          <source>A forward range if &lt;code&gt;R&lt;/code&gt; is a range and not auto-decodable, as defined by &lt;a href=&quot;std_traits#isAutodecodableString&quot;&gt;&lt;code&gt;std.traits.isAutodecodableString&lt;/code&gt;&lt;/a&gt;, and if the base range is also a forward range.  Or, if &lt;code&gt;R&lt;/code&gt; is a range and it is auto-decodable and &lt;code&gt;is(ElementEncodingType!typeof(r) == C)&lt;/code&gt;, then the range is passed to &lt;a href=&quot;#byCodeUnit&quot;&gt;&lt;code&gt;byCodeUnit&lt;/code&gt;&lt;/a&gt;.  Otherwise, an input range of characters.</source>
          <target state="translated">&lt;a href=&quot;std_traits#isAutodecodableString&quot;&gt; &lt;code&gt;std.traits.isAutodecodableString&lt;/code&gt; &lt;/a&gt; диапазон, если &lt;code&gt;R&lt;/code&gt; является диапазоном и не может быть автоматически декодирован, как определено в std.traits.isAutodecodableString , и если базовый диапазон также является прямым диапазоном. Или, если &lt;code&gt;R&lt;/code&gt; является диапазоном, и он автоматически декодируется и &lt;code&gt;is(ElementEncodingType!typeof(r) == C)&lt;/code&gt; , тогда диапазон передается &lt;a href=&quot;#byCodeUnit&quot;&gt; &lt;code&gt;byCodeUnit&lt;/code&gt; &lt;/a&gt; . В противном случае введите диапазон символов.</target>
        </trans-unit>
        <trans-unit id="8d5c4110b87b6e1790814c919c68f884e6275dff" translate="yes" xml:space="preserve">
          <source>A forward range of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; representing elements of the cartesian product of the given ranges.</source>
          <target state="translated">&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; диапазон std.typecons.Tuple, представляющий элементы декартового произведения указанных диапазонов.</target>
        </trans-unit>
        <trans-unit id="a731c9bb046e9313dba3f0fb16b94dd2c654875f" translate="yes" xml:space="preserve">
          <source>A forward range of normalized import paths.</source>
          <target state="translated">Прямой диапазон нормализованных путей импорта.</target>
        </trans-unit>
        <trans-unit id="117c498681e013c2fb7838228fefa0b3eae46314" translate="yes" xml:space="preserve">
          <source>A forward range with length</source>
          <target state="translated">Дальность действия вперёд с длиной</target>
        </trans-unit>
        <trans-unit id="47d88e62a4db7de8d2e3578482fcf85fc5780a85" translate="yes" xml:space="preserve">
          <source>A forward range.</source>
          <target state="translated">Передний диапазон.</target>
        </trans-unit>
        <trans-unit id="07f884d1e3c1a36cba2e5097837570b878e4d182" translate="yes" xml:space="preserve">
          <source>A free function can be called with a syntax that looks as if the function were a member function of its first parameter type.</source>
          <target state="translated">Свободная функция может быть вызвана с синтаксисом,который выглядит так,как будто функция является членом функции с первым типом параметра.</target>
        </trans-unit>
        <trans-unit id="c359cd492ba9cf953d5897730484240a34a6f50a" translate="yes" xml:space="preserve">
          <source>A frequent usage pattern occurs in build automation tools such as &lt;a href=&quot;http://gnu.org/software/make&quot;&gt;make&lt;/a&gt; or &lt;a href=&quot;http://%20%20%20%20en.wikipedia.org/wiki/Apache_Ant&quot;&gt;ant&lt;/a&gt;. To check whether file &lt;code&gt; target&lt;/code&gt; must be rebuilt from file &lt;code&gt;source&lt;/code&gt; (i.e., &lt;code&gt;target&lt;/code&gt; is older than &lt;code&gt;source&lt;/code&gt; or does not exist), use the comparison below. The code throws a &lt;a href=&quot;#FileException&quot;&gt;&lt;code&gt;FileException&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;source&lt;/code&gt; does not exist (as it should). On the other hand, the &lt;code&gt;SysTime.min&lt;/code&gt; default makes a non-existing &lt;code&gt;target&lt;/code&gt; seem infinitely old so the test correctly prompts building it.</source>
          <target state="translated">Шаблон частого использования встречается в инструментах автоматизации сборки, таких как &lt;a href=&quot;http://gnu.org/software/make&quot;&gt;make&lt;/a&gt; или &lt;a href=&quot;http://%20%20%20%20en.wikipedia.org/wiki/Apache_Ant&quot;&gt;ant&lt;/a&gt; . Чтобы проверить, нужно ли перестраивать &lt;code&gt; target&lt;/code&gt; файла из &lt;code&gt;source&lt;/code&gt; файла (т. &lt;code&gt;target&lt;/code&gt; старше &lt;code&gt;source&lt;/code&gt; или не существует), используйте сравнение ниже. Код &lt;a href=&quot;#FileException&quot;&gt; &lt;code&gt;FileException&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;source&lt;/code&gt; не существует (как и должно быть). С другой стороны, по умолчанию &lt;code&gt;SysTime.min&lt;/code&gt; несуществующая &lt;code&gt;target&lt;/code&gt; кажется бесконечно старой, поэтому тест корректно предлагает ее построить.</target>
        </trans-unit>
        <trans-unit id="053e4fcbf054d3263a7fae4e776cf2902753e975" translate="yes" xml:space="preserve">
          <source>A function in a derived class with the same name and parameter types as a function in a base class overrides that function:</source>
          <target state="translated">Функция в производном классе с тем же именем и типами параметров,что и функция в базовом классе,переопределяет эту функцию:</target>
        </trans-unit>
        <trans-unit id="3ccb42bb3e1d42426a86b0e82c04b1f624112e9b" translate="yes" xml:space="preserve">
          <source>A function literal that accesses variables in an outer scope</source>
          <target state="translated">Буквальная функция,которая обращается к переменным во внешней области действия.</target>
        </trans-unit>
        <trans-unit id="8c83eeb90caf7607d29f499fd7f03aa7947f2985" translate="yes" xml:space="preserve">
          <source>A function or template function (including function literals). New allocators are created by calling &lt;code&gt;factoryFunction(n)&lt;/code&gt; with strictly positive numbers &lt;code&gt;n&lt;/code&gt;. Delegates that capture their enviroment are not created amid concerns regarding garbage creation for the environment. When the factory needs state, a &lt;code&gt;Factory&lt;/code&gt; object should be used.</source>
          <target state="translated">Функция или шаблонная функция (включая функциональные литералы). Новые распределители создаются путем вызова &lt;code&gt;factoryFunction(n)&lt;/code&gt; со строго положительными числами &lt;code&gt;n&lt;/code&gt; . Делегаты, которые захватывают свою среду, не создаются на фоне опасений, связанных с созданием мусора для окружающей среды. Когда фабрике нужно состояние, должен использоваться объект &lt;code&gt;Factory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8f5ab777b478051e69157f24d0dbd61527c2d2" translate="yes" xml:space="preserve">
          <source>A function parameter's default value is not inherited:</source>
          <target state="translated">Значение параметра функции по умолчанию не наследуется:</target>
        </trans-unit>
        <trans-unit id="deb5c0bb10643e400b9fb7b5a35e143fdd758a44" translate="yes" xml:space="preserve">
          <source>A function pointer can point to a static nested function:</source>
          <target state="translated">Указатель функции может указывать на статическую вложенную функцию:</target>
        </trans-unit>
        <trans-unit id="dea991823934c1b1bf0e685fa1b0b65a6d495057" translate="yes" xml:space="preserve">
          <source>A function pointer is safe when it is &lt;code&gt;null&lt;/code&gt; or it refers to a valid function that has the same or a covariant signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a093e881de626962fffef8fdd8f64ab7dd9375e5" translate="yes" xml:space="preserve">
          <source>A function template to compute the square of type</source>
          <target state="translated">Шаблон функции для вычисления квадрата типа</target>
        </trans-unit>
        <trans-unit id="61bf2496142474d131fe4b95ef3aecc3b755f8ad" translate="yes" xml:space="preserve">
          <source>A function which calls &lt;code&gt;pred&lt;/code&gt; after reversing the given parameters</source>
          <target state="translated">Функция, которая вызывает &lt;code&gt;pred&lt;/code&gt; после изменения заданных параметров</target>
        </trans-unit>
        <trans-unit id="6d30a8cd44c324808434a45e76f76d6c7b7c032f" translate="yes" xml:space="preserve">
          <source>A function which calls &lt;code&gt;pred&lt;/code&gt; and returns the logical negation of its return value.</source>
          <target state="translated">Функция, которая вызывает &lt;code&gt;pred&lt;/code&gt; и возвращает логическое отрицание своего возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="7867264ad952f6a53a8255bd79dd0b456b5ab3e3" translate="yes" xml:space="preserve">
          <source>A function with a variadic argument is considered less specialized than a function without.</source>
          <target state="translated">Функция с вариантным аргументом считается менее специализированной,чем функция без него.</target>
        </trans-unit>
        <trans-unit id="0783cd86ad223c78326ce1677f0c3ebd4740e94f" translate="yes" xml:space="preserve">
          <source>A function without an &lt;code&gt;in&lt;/code&gt; contract means that any values of the function parameters are allowed. This implies that if any function in an inheritance hierarchy has no &lt;code&gt;in&lt;/code&gt; contract, then any &lt;code&gt;in&lt;/code&gt; contracts on functions overriding it have no useful effect.</source>
          <target state="translated">Функция без &lt;code&gt;in&lt;/code&gt; контрактных означает , что любые значения параметров функции разрешены. Это подразумевает, что если какая-либо функция в иерархии наследования не имеет &lt;code&gt;in&lt;/code&gt; контракте, то любая &lt;code&gt;in&lt;/code&gt; контрактов на функции, переопределяющие ее, не имеет полезного эффекта.</target>
        </trans-unit>
        <trans-unit id="5dcc227a0434c16224da46cefa6b9d0c04511c33" translate="yes" xml:space="preserve">
          <source>A function() dg = (){ return new B(); } // OK if is(B : A) == true</source>
          <target state="translated">Функция()dg =(){возвращает новую B();}//OK if is(B:A)==true</target>
        </trans-unit>
        <trans-unit id="3a930e72e95731438d93e00189652867b0504b0a" translate="yes" xml:space="preserve">
          <source>A generic function &lt;code&gt;rank(v)&lt;/code&gt; in the following example uses this template for finding a member &lt;code&gt;e&lt;/code&gt; in an enumerated type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Обобщенная функция &lt;code&gt;rank(v)&lt;/code&gt; в следующем примере использует этот шаблон для нахождения члена &lt;code&gt;e&lt;/code&gt; в перечисленном типе &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="039eab0dd8d373801833af2f7527af3b2c405678" translate="yes" xml:space="preserve">
          <source>A generous interpretation of what is a match between the argument and format specifier is taken, for example, an unsigned type can be printed with a signed format specifier. Diagnosed incompatibilites are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e17613e86754acf295eeb4ccc8b783f06cdc022" translate="yes" xml:space="preserve">
          <source>A grapheme cluster typically starts with a grapheme base and then extends across any subsequent sequence of nonspacing marks. A grapheme cluster is most directly relevant to text rendering and processes such as cursor placement and text selection in editing, but may also be relevant to comparison and searching.</source>
          <target state="translated">Графемный кластер обычно начинается с базы графем,а затем простирается на любую последующую последовательность нерассеянных меток.Графемный кластер наиболее непосредственно связан с рендерингом текста и такими процессами,как размещение курсора и выделение текста при редактировании,но может также иметь отношение к сопоставлению и поиску.</target>
        </trans-unit>
        <trans-unit id="2cdf5ed23bd7b348665b7817bbf320049b481dbf" translate="yes" xml:space="preserve">
          <source>A handle that corresponds to a spawned process.</source>
          <target state="translated">Ручка,которая соответствует порожденному процессу.</target>
        </trans-unit>
        <trans-unit id="26ae9c727fe1703ac77a626a740de8a752d48a6b" translate="yes" xml:space="preserve">
          <source>A hash of the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Хеш &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d811c80289b5aca85dc23dcd5078a5644d6da5" translate="yes" xml:space="preserve">
          <source>A header may be provided as the first record in input</source>
          <target state="translated">В качестве первой записи на входе может быть предоставлен заголовок</target>
        </trans-unit>
        <trans-unit id="40407ac5248f258a00141e636d2fabf321c8677e" translate="yes" xml:space="preserve">
          <source>A high-level, dynamically-typed layer (described further down in this module). It consists of an interface called &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt;, which concrete allocators need to implement. The interface primitives themselves are oblivious to the type of the objects being allocated; they only deal in &lt;code&gt;void[]&lt;/code&gt;, by necessity of the interface being dynamic (as opposed to type-parameterized). Each thread has a current allocator it uses by default, which is a thread-local variable &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt; of type &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt;. The process has a global allocator called &lt;a href=&quot;#processAllocator&quot;&gt;&lt;code&gt;processAllocator&lt;/code&gt;&lt;/a&gt;, also of type &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt;. When a new thread is created, &lt;a href=&quot;#processAllocator&quot;&gt;&lt;code&gt;processAllocator&lt;/code&gt;&lt;/a&gt; is copied into &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt;. An application can change the objects to which these references point. By default, at application startup, &lt;a href=&quot;#processAllocator&quot;&gt;&lt;code&gt;processAllocator&lt;/code&gt;&lt;/a&gt; refers to an object that uses D's garbage collected heap. This layer also include high-level functions such as &lt;a href=&quot;#make&quot;&gt;&lt;code&gt;make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#dispose&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; that comfortably allocate/create and respectively destroy/deallocate objects. This layer is all needed for most casual uses of allocation primitives.</source>
          <target state="translated">Высокоуровневый динамически типизированный слой (описанный ниже в этом модуле). Он состоит из интерфейса под названием &lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt; , который нужно реализовать конкретным распределителям. Сами примитивы интерфейса не обращают внимания на тип выделяемых объектов; они имеют дело только с &lt;code&gt;void[]&lt;/code&gt; , из-за необходимости динамического интерфейса (в отличие от параметризованного типа). Каждый поток имеет текущий распределитель, который он использует по умолчанию, который является локальной переменной &lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; &lt;/a&gt; типа &lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt; . У процесса есть глобальный распределитель, называемый &lt;a href=&quot;#processAllocator&quot;&gt; &lt;code&gt;processAllocator&lt;/code&gt; &lt;/a&gt; , также типа &lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt; . Когда создается новый поток, &lt;a href=&quot;#processAllocator&quot;&gt; &lt;code&gt;processAllocator&lt;/code&gt; &lt;/a&gt; копируется в &lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; &lt;/a&gt;, Приложение может изменить объекты, на которые указывают эти ссылки. По умолчанию при запуске приложения &lt;a href=&quot;#processAllocator&quot;&gt; &lt;code&gt;processAllocator&lt;/code&gt; &lt;/a&gt; ссылается на объект, который использует кучу D, собираемую мусором. Этот уровень также включает высокоуровневые функции, такие как &lt;a href=&quot;#make&quot;&gt; &lt;code&gt;make&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#dispose&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; ,&lt;/a&gt; которые удобно размещают / создают и, соответственно, уничтожают / освобождают объекты. Этот слой необходим для большинства случайных применений примитивов выделения.</target>
        </trans-unit>
        <trans-unit id="5d2bf1ea51e80c4aac6f3473b7f887fdc740c35e" translate="yes" xml:space="preserve">
          <source>A hook for compatibility with original std.regex.</source>
          <target state="translated">Крючок для совместимости с оригинальным std.regex.</target>
        </trans-unit>
        <trans-unit id="653718671cc4db542d90157efcbee7612ef4f130" translate="yes" xml:space="preserve">
          <source>A hook point to supply scope for members. addMember, setScope, importAll, semantic, semantic2 and semantic3 will use this.</source>
          <target state="translated">Точка крючка,чтобы снабдить членов диапазоном.addMember,setScope,importAll,semantic,semantic2 и semantic3 будет использовать это.</target>
        </trans-unit>
        <trans-unit id="328879720920d5ae634a17552898a3a2c1a84c70" translate="yes" xml:space="preserve">
          <source>A label can appear without a following statement at the end of a block.</source>
          <target state="translated">В конце блока может появиться наклейка без следующего утверждения.</target>
        </trans-unit>
        <trans-unit id="7b5372fe2a868be3a8291b8259a3add376d70db6" translate="yes" xml:space="preserve">
          <source>A lazy range of strings</source>
          <target state="translated">Ленивый диапазон струн</target>
        </trans-unit>
        <trans-unit id="71bf427d84b61d24a8b8a67278a8ab4a8f8f93cb" translate="yes" xml:space="preserve">
          <source>A leading &lt;code&gt;.&lt;/code&gt; causes the identifer to be looked up in the module scope.</source>
          <target state="translated">Ведущий &lt;code&gt;.&lt;/code&gt; вызывает поиск идентификатора в области видимости модуля.</target>
        </trans-unit>
        <trans-unit id="78a3635ca139ef9c87ed13b1879a916f250d065a" translate="yes" xml:space="preserve">
          <source>A leading &lt;code&gt;.&lt;/code&gt; causes the identifier to be looked up in the module scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd618290eeed633444e33da1bdeaf8d34c427135" translate="yes" xml:space="preserve">
          <source>A line-by-line representation of a &lt;a href=&quot;dmd_root_file#File&quot;&gt;&lt;code&gt;dmd.root.file.File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dmd_root_file#File&quot;&gt; &lt;code&gt;dmd.root.file.File&lt;/code&gt; &lt;/a&gt; представление файла dmd.root.file.File .</target>
        </trans-unit>
        <trans-unit id="dc4aec564d06cb4498ed70d9f1e28eb70a8ce833" translate="yes" xml:space="preserve">
          <source>A list of current D documentation generators which use Ddoc can be found on our &lt;a href=&quot;https://wiki.dlang.org/Open_Source_Projects#Documentation_Generators&quot;&gt;wiki page&lt;/a&gt;.</source>
          <target state="translated">Список текущих генераторов документации D, которые используют Ddoc, можно найти на нашей &lt;a href=&quot;https://wiki.dlang.org/Open_Source_Projects#Documentation_Generators&quot;&gt;вики-странице&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba885a6110bdc794b2075278e4f226a6913b7076" translate="yes" xml:space="preserve">
          <source>A list of currently supported attributes are:</source>
          <target state="translated">Список поддерживаемых в настоящее время атрибутов:</target>
        </trans-unit>
        <trans-unit id="f00b55c4fe43d41a3c524a8b0bb069f6e70306ac" translate="yes" xml:space="preserve">
          <source>A list of supported opcodes is at the end.</source>
          <target state="translated">Список поддерживаемых опкодов находится в конце.</target>
        </trans-unit>
        <trans-unit id="ca2feebae713824761039107facad4dbea83ba74" translate="yes" xml:space="preserve">
          <source>A list of the types to be aligned, representing fields of an aggregate such as a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">Список типов для выравнивания, представляющих поля агрегата, такие как &lt;code&gt;struct&lt;/code&gt; или &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ef2b927f7e203105a01e238fa3da38d93cba2b3" translate="yes" xml:space="preserve">
          <source>A list of types (and optionally, member names) that the &lt;code&gt;Tuple&lt;/code&gt; contains.</source>
          <target state="translated">Список типов (и, возможно, имен членов), которые содержит &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1e04a938052cd01677b42324cc47786cb20be16" translate="yes" xml:space="preserve">
          <source>A list of values that are either the same types as those given by the &lt;code&gt;Types&lt;/code&gt; field of this &lt;code&gt;Tuple&lt;/code&gt;, or can implicitly convert to those types. They must be in the same order as they appear in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Список значений, которые относятся к типам, указанным в поле &amp;laquo; &lt;code&gt;Types&lt;/code&gt; этого &lt;code&gt;Tuple&lt;/code&gt; , или могут неявно преобразовываться в эти типы. Они должны быть в том же порядке, что и в &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d482941d3ca4453ce50fb97e64179b8d6b13c34a" translate="yes" xml:space="preserve">
          <source>A literal backtick character can be output either as a non-paired ` on a single line or by using the &lt;code&gt;&amp;amp;dollar;(BACKTICK)&lt;/code&gt; macro.</source>
          <target state="translated">Буквальный символ &lt;code&gt;&amp;amp;dollar;(BACKTICK)&lt;/code&gt; может быть выведен либо в виде непарного `в одной строке, либо с помощью макроса &amp;amp; dollar; (BACKTICK) .</target>
        </trans-unit>
        <trans-unit id="6aed558d39191518507dbd6d399ad58fe0c07785" translate="yes" xml:space="preserve">
          <source>A local name for an import can be given, through which all references to the module's symbols must be qualified with:</source>
          <target state="translated">Для импорта может быть дано локальное имя,через которое должны пройти все ссылки на символы модуля:</target>
        </trans-unit>
        <trans-unit id="7f88015250ab3c4000e837f6d91e8ce7469e5233" translate="yes" xml:space="preserve">
          <source>A logical thread is an execution context that has its own stack and which runs asynchronously to other logical threads. These may be preemptively scheduled kernel threads, fibers (cooperative user-space threads), or some other concept with similar behavior.</source>
          <target state="translated">Логический поток-это контекст выполнения,имеющий свой собственный стек и выполняющийся асинхронно с другими логическими потоками.Это могут быть заранее запланированные потоки ядра,волокна (кооперативные потоки пользовательского пространства),или какая-либо другая концепция с аналогичным поведением.</target>
        </trans-unit>
        <trans-unit id="d23190506c8632f2a85dd8e50fb58e02e2aafcff" translate="yes" xml:space="preserve">
          <source>A lone double-dash terminates &lt;code&gt;getopt&lt;/code&gt; gathering. It is used to separate program options from other parameters (e.g., options to be passed to another program). Invoking the example above with &lt;code&gt;&quot;--foo -- --bar&quot;&lt;/code&gt; parses foo but leaves &quot;--bar&quot; in &lt;code&gt;args&lt;/code&gt;. The double-dash itself is removed from the argument array unless the &lt;code&gt;std.getopt.config.keepEndOfOptions&lt;/code&gt; directive is given.</source>
          <target state="translated">Одинокая двойная черта завершает сбор &lt;code&gt;getopt&lt;/code&gt; . Он используется для отделения параметров программы от других параметров (например, параметров, передаваемых другой программе). Вызов приведенного выше примера с &lt;code&gt;&quot;--foo -- --bar&quot;&lt;/code&gt; анализирует foo, но оставляет &quot;--bar&quot; в &lt;code&gt;args&lt;/code&gt; . Сама двойная черта удаляется из массива аргументов, если не &lt;code&gt;std.getopt.config.keepEndOfOptions&lt;/code&gt; директива std.getopt.config.keepEndOfOptions .</target>
        </trans-unit>
        <trans-unit id="458ac700d9aa844741122c6aab2d0b7ccd8355ca" translate="yes" xml:space="preserve">
          <source>A long documentation section can be subdivided by adding headings. A heading is a line of text that starts with one to six &lt;code&gt;#&lt;/code&gt; characters followed by whitespace and then the heading text. The number of &lt;code&gt;#&lt;/code&gt; characters determines the heading level. Headings may optionally end with any number of trailing &lt;code&gt;#&lt;/code&gt; characters.</source>
          <target state="translated">Длинный раздел документации можно подразделить, добавив заголовки. Заголовок - это строка текста, которая начинается от одного до шести символов &lt;code&gt;#&lt;/code&gt; , за которыми следует пробел, а затем текст заголовка. Количество символов &lt;code&gt;#&lt;/code&gt; определяет уровень заголовка. Заголовки могут произвольно заканчиваться любым количеством завершающих &lt;code&gt;#&lt;/code&gt; символов.</target>
        </trans-unit>
        <trans-unit id="806ce325a4f1521812e9d9272c0bf953ac163955" translate="yes" xml:space="preserve">
          <source>A low-level collection of highly generic</source>
          <target state="translated">Низкоуровневая коллекция высокородных</target>
        </trans-unit>
        <trans-unit id="fd10b8251464e1741a850e03d93a6d8cccce965d" translate="yes" xml:space="preserve">
          <source>A machine NaN was generated.</source>
          <target state="translated">Была сгенерирована машина NaN.</target>
        </trans-unit>
        <trans-unit id="48bb9311ba54487dcfa6b8a8d2a2646a08b874fd" translate="yes" xml:space="preserve">
          <source>A malloc() failed</source>
          <target state="translated">Malloc()не справилась</target>
        </trans-unit>
        <trans-unit id="010a078544787f12778cc94373a480b09ea7d03c" translate="yes" xml:space="preserve">
          <source>A member of the ZipArchive.</source>
          <target state="translated">Член ЗипАрхива.</target>
        </trans-unit>
        <trans-unit id="5dc35df4527a6fb4d8c143ba6a6bbe25d63cf41d" translate="yes" xml:space="preserve">
          <source>A memory barrier is guaranteed to be executed after all results are written but before returning so that results produced by all threads are visible in the calling thread.</source>
          <target state="translated">Барьер памяти гарантированно выполняется после записи всех результатов,но до их возврата,чтобы результаты,полученные всеми потоками,были видны в вызывающем потоке.</target>
        </trans-unit>
        <trans-unit id="b99d9090a52d28bb0bb7cf5590c4227b3be984ea" translate="yes" xml:space="preserve">
          <source>A memory location can be temporarily transferred from shared to local if synchronization is used to prevent any other threads from accessing the memory location during the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79180a978998fb8fc11add776be5adf66604dcbb" translate="yes" xml:space="preserve">
          <source>A memory location can be transferred from shared to immutable or thread-local if there is only one reference to the location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20951c051d2c0f727490d1f013b8b1bedb4089a" translate="yes" xml:space="preserve">
          <source>A memory location can be transferred from thread-local to immutable or shared if there is only one reference to the location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48424e7c6638180fc8d589333477c4a060668223" translate="yes" xml:space="preserve">
          <source>A memory safe allocator where sizes are rounded to a multiple of the page size and allocations are satisfied at increasing addresses.</source>
          <target state="translated">Безопасный аллокатор памяти,где размеры округляются до кратного размера страницы,а распределения удовлетворяются при увеличении адресов.</target>
        </trans-unit>
        <trans-unit id="495055d44ce18ab5dee6edd4039253feb8fc0078" translate="yes" xml:space="preserve">
          <source>A message describing the error.</source>
          <target state="translated">Сообщение с описанием ошибки.</target>
        </trans-unit>
        <trans-unit id="fd5218a2e4798262008234d0bc405db13e8f3ee4" translate="yes" xml:space="preserve">
          <source>A mid-level, statically-typed layer for assembling several allocators into one. It uses properties of the type of the objects being created to route allocation requests to possibly specialized allocators. This layer is relatively thin and implemented and documented in the &lt;a href=&quot;std_experimental_allocator_typed&quot;&gt;&lt;code&gt;std.experimental.allocator.typed&lt;/code&gt;&lt;/a&gt; module. It allows an interested user to e.g. use different allocators for arrays versus fixed-sized objects, to the end of better overall performance.</source>
          <target state="translated">Уровень статического типа среднего уровня для объединения нескольких распределителей в один. Он использует свойства типа создаваемых объектов для направления запросов на выделение, возможно, специализированным распределителям. Этот слой относительно тонкий и реализован и задокументирован в модуле &lt;a href=&quot;std_experimental_allocator_typed&quot;&gt; &lt;code&gt;std.experimental.allocator.typed&lt;/code&gt; &lt;/a&gt; . Это позволяет заинтересованному пользователю, например, использовать различные распределители для массивов по сравнению с объектами фиксированного размера, что приводит к повышению общей производительности.</target>
        </trans-unit>
        <trans-unit id="d32e0f2daf8ea6fe77b14840a0abd42c3bdc8827" translate="yes" xml:space="preserve">
          <source>A minimal &lt;code&gt;LogLevel&lt;/code&gt; can be defined on a per module basis. In order to define a module &lt;code&gt;LogLevel&lt;/code&gt; a file with a modulename &quot;MODULENAME_loggerconfig&quot; must be found. If no such module exists and the module is a nested module, it is checked if there exists a &quot;PARENT_MODULE_loggerconfig&quot; module with such a symbol. If this module exists and it contains a &lt;code&gt;LogLevel&lt;/code&gt; called logLevel this &lt;code&gt;LogLevel&lt;/code&gt; will be used. This parent lookup is continued until there is no parent module. Then the moduleLogLevel is &lt;code&gt;LogLevel.all&lt;/code&gt;.</source>
          <target state="translated">Минимальный &lt;code&gt;LogLevel&lt;/code&gt; может быть определен для каждого модуля. Чтобы определить модуль &lt;code&gt;LogLevel&lt;/code&gt; ,необходимо найти файл с именем по модулю &amp;laquo;MODULENAME_loggerconfig&amp;raquo;. Если такого модуля не существует и модуль является вложенным модулем, проверяется, существует ли модуль &amp;laquo;PARENT_MODULE_loggerconfig&amp;raquo; с таким символом. Если этот модуль существует, и он содержит &lt;code&gt;LogLevel&lt;/code&gt; с именем logLevel, этот &lt;code&gt;LogLevel&lt;/code&gt; будет использоваться. Этот родительский поиск продолжается, пока нет родительского модуля. Тогда moduleLogLevel - это &lt;code&gt;LogLevel.all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d827e0f949b1a248de908def5cd32ff394bdf9" translate="yes" xml:space="preserve">
          <source>A mixin has its own scope, even if a declaration is overridden by the enclosing one:</source>
          <target state="translated">Смесь имеет свою собственную сферу применения,даже если декларация перекрывается прилагаемой:</target>
        </trans-unit>
        <trans-unit id="f4c00bae4b7dc7ecb086f6d819ea6ceb53a7ae30" translate="yes" xml:space="preserve">
          <source>A module may contain any number of functions annotated with &lt;code&gt;crt_constructor&lt;/code&gt;. The order in which functions are called is undefined and shouldn't be relied upon. A function can be annotated as both &lt;code&gt;crt_constructor&lt;/code&gt; and &lt;code&gt;crt_destructor&lt;/code&gt; (see below). The runtime is not initialized when the function is called. This pragma does not take any argument and can only be applied to a single declaration, so using them in an &lt;a href=&quot;grammar#AttributeSpecifier&quot;&gt;&lt;i&gt;AttributeSpecifier&lt;/i&gt;&lt;/a&gt; is disallowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ebee3433d158bd90ab55b8f3d9d3abeffc2f30" translate="yes" xml:space="preserve">
          <source>A module may have multiple static constructors and static destructors. The static constructors are run in lexical order, the static destructors are run in reverse lexical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d1d41b889cc5f0d75263bc9c12e3c332a8897e" translate="yes" xml:space="preserve">
          <source>A monotonic clock is one which always goes forward and never moves backwards, unlike the system's wall clock time (as represented by &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;). The system's wall clock time can be adjusted by the user or by the system itself via services such as NTP, so it is unreliable to use the wall clock time for timing. Timers which use the wall clock time could easily end up never going off due to changes made to the wall clock time or otherwise waiting for a different period of time than that specified by the programmer. However, because the monotonic clock always increases at a fixed rate and is not affected by adjustments to the wall clock time, it is ideal for use with timers or anything which requires high precision timing.</source>
          <target state="translated">Монотонные часы - это часы, которые всегда идут вперед и никогда не движутся назад, в отличие от настенных часов системы (как представлено &lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; &lt;/a&gt; ). Время настенных часов системы может быть отрегулировано пользователем или самой системой через такие службы, как NTP, поэтому ненадежно использовать время настенных часов для синхронизации. Таймеры, которые используют время настенных часов, могут легко закончить тем, что никогда не сработают из-за изменений, внесенных во время настенных часов или иным образом ожидающих другой период времени, чем тот, который задан программистом. Однако, поскольку монотонные часы всегда увеличиваются с фиксированной частотой и не зависят от настроек времени настенных часов, они идеально подходят для использования с таймерами или чем-то, что требует высокой точности синхронизации.</target>
        </trans-unit>
        <trans-unit id="229b7dd82c71ab19c4cf75da24484b9963a42fff" translate="yes" xml:space="preserve">
          <source>A mutable, const or immutable argument type can be matched against each corresponding parameter inout type.</source>
          <target state="translated">С каждым соответствующим типом inout параметра может быть сопоставлен тип мутируемого,константного или неизменяемого аргумента.</target>
        </trans-unit>
        <trans-unit id="9064ba2eae9e9b47bb158682a4264e615bd9c834" translate="yes" xml:space="preserve">
          <source>A mutex to prevent race conditions</source>
          <target state="translated">Мьютекс для предотвращения гоночных условий</target>
        </trans-unit>
        <trans-unit id="00f2bad5530d3d28c7c68863d26800de4d656057" translate="yes" xml:space="preserve">
          <source>A named enum member can be implicitly cast to its &lt;a href=&quot;#EnumBaseType&quot;&gt;&lt;i&gt;EnumBaseType&lt;/i&gt;&lt;/a&gt;, but</source>
          <target state="translated">Именованный член enum может быть неявно приведен к его &lt;a href=&quot;#EnumBaseType&quot;&gt;&lt;i&gt;EnumBaseType&lt;/i&gt;&lt;/a&gt; , но</target>
        </trans-unit>
        <trans-unit id="f6623d0b1fbb72d5c2e17e47cb1578c616457fe2" translate="yes" xml:space="preserve">
          <source>A namespace corresponding to a C++ namespace. Implies extern(C++).</source>
          <target state="translated">Пространство имён,соответствующее пространству имён C++.Подразумевает extern(C++).</target>
        </trans-unit>
        <trans-unit id="346700632471b767cd12c634cfc15ff2fa145c55" translate="yes" xml:space="preserve">
          <source>A negative integer if the expression &lt;code&gt;v1 &amp;lt; v2&lt;/code&gt; is true.</source>
          <target state="translated">Отрицательное целое число, если выражение &lt;code&gt;v1 &amp;lt; v2&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="5db8fed5619f8de0bf708303f486b9261288d5ff" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;Tuple&lt;/code&gt; that is a slice from &lt;code&gt;[from, to)&lt;/code&gt; of the original. It has the same types and values as the range &lt;code&gt;[from, to)&lt;/code&gt; in the original.</source>
          <target state="translated">Новый &lt;code&gt;Tuple&lt;/code&gt; , представляющий собой фрагмент из &lt;code&gt;[from, to)&lt;/code&gt; оригинала. Он имеет те же типы и значения, что и диапазон &lt;code&gt;[from, to)&lt;/code&gt; в оригинале.</target>
        </trans-unit>
        <trans-unit id="1198461e27aeae97f26fc44ed1d24bbd1f1e6dd2" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;Tuple&lt;/code&gt; with its type inferred from the arguments given.</source>
          <target state="translated">Новый &lt;code&gt;Tuple&lt;/code&gt; с его типом, выведенным из приведенных аргументов.</target>
        </trans-unit>
        <trans-unit id="3f8c22ba5c90fb1ed325dc174a8efa22e43e2077" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">Новый &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e22c32dd01bb77a6a126af2efc4f6cd32b779b72" translate="yes" xml:space="preserve">
          <source>A new array that is &lt;code&gt;s&lt;/code&gt; with &lt;code&gt;slice&lt;/code&gt; replaced by &lt;code&gt;replacement[]&lt;/code&gt;.</source>
          <target state="translated">Новый массив , который &lt;code&gt;s&lt;/code&gt; с &lt;code&gt;slice&lt;/code&gt; заменен &lt;code&gt;replacement[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a9401b7a768f52b435c2f4f39154c0cf2acebbd" translate="yes" xml:space="preserve">
          <source>A new array which is a concatenation of &lt;code&gt;this&lt;/code&gt; and its argument.</source>
          <target state="translated">Новый массив, который является объединением &lt;code&gt;this&lt;/code&gt; и его аргумента.</target>
        </trans-unit>
        <trans-unit id="d9bd6f8da807c91afda455d4fa6a0f2656f1b54a" translate="yes" xml:space="preserve">
          <source>A new array without changing the contents of &lt;code&gt;subject&lt;/code&gt;, or the original array if no match is found.</source>
          <target state="translated">Новый массив без изменения содержимого &lt;code&gt;subject&lt;/code&gt; или исходный массив, если совпадений не найдено.</target>
        </trans-unit>
        <trans-unit id="630ceb2509e7f76ede6d40cdaf6bcd61d0261a1e" translate="yes" xml:space="preserve">
          <source>A new array without changing the contents of &lt;code&gt;subject&lt;/code&gt;.</source>
          <target state="translated">Новый массив без изменения содержимого &lt;code&gt;subject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43ecc65f9a715237080eeb0fb40d3f9446e7b025" translate="yes" xml:space="preserve">
          <source>A new function &lt;code&gt;f(x)&lt;/code&gt; that in turn returns &lt;code&gt;fun[$-1](...fun[1](fun[0](x)))...&lt;/code&gt;.</source>
          <target state="translated">Новая функция &lt;code&gt;f(x)&lt;/code&gt; , что в свою очередь возвращает &lt;code&gt;fun[$-1](...fun[1](fun[0](x)))...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a8b5130321872fbcd4e37985f08ceb7bb696040" translate="yes" xml:space="preserve">
          <source>A new function &lt;code&gt;f(x)&lt;/code&gt; that in turn returns &lt;code&gt;fun[0](fun[1](...(x)))...&lt;/code&gt;.</source>
          <target state="translated">Новая функция &lt;code&gt;f(x)&lt;/code&gt; , что в свою очередь возвращает &lt;code&gt;fun[0](fun[1](...(x)))...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef82e65d23cc49a814d58985830203c495a58ce" translate="yes" xml:space="preserve">
          <source>A new function which calls &lt;code&gt;fun&lt;/code&gt; and caches its return values.</source>
          <target state="translated">Новая функция, которая вызывает &lt;code&gt;fun&lt;/code&gt; и кеширует свои возвращаемые значения.</target>
        </trans-unit>
        <trans-unit id="4d63ef8b0e85bb89b9c6145db9006821ac2a97c5" translate="yes" xml:space="preserve">
          <source>A new function which calls &lt;code&gt;fun&lt;/code&gt; with &lt;code&gt;arg&lt;/code&gt; plus the passed parameters.</source>
          <target state="translated">Новая функция, которая вызывает &lt;code&gt;fun&lt;/code&gt; с &lt;code&gt;arg&lt;/code&gt; плюс переданные параметры.</target>
        </trans-unit>
        <trans-unit id="f7ba0f0828fd745d5bc435a766f220e78eb9e813" translate="yes" xml:space="preserve">
          <source>A new function which returns a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;. Each of the elements of the tuple will be the return values of &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">Новая функция, которая возвращает &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; . Каждый из элементов кортежа будут возвращаемые значения &lt;code&gt;F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b4a992b5e6a1e4ed4714d0daf1cc2c2530fd6bf" translate="yes" xml:space="preserve">
          <source>A new scope for local symbols is introduced for the</source>
          <target state="translated">Введена новая сфера применения локальных символов для обозначения</target>
        </trans-unit>
        <trans-unit id="90ba492e24974c1e57773164b5a346f710dfb153" translate="yes" xml:space="preserve">
          <source>A new string of the same type as &lt;code&gt;input&lt;/code&gt; with all matches replaced by return values of &lt;code&gt;fun&lt;/code&gt;. If no matches found returns the &lt;code&gt;input&lt;/code&gt; itself.</source>
          <target state="translated">Новая строка одного и того же типа, что и &lt;code&gt;input&lt;/code&gt; со всеми матчами заменены возвращаемых значений &lt;code&gt;fun&lt;/code&gt; . Если совпадений не найдено, возвращается сам &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f903382e43710d4720f573e5ab317741737619f" translate="yes" xml:space="preserve">
          <source>A newly allocated array that contains all the elements from all the arrays in &lt;code&gt;arrs&lt;/code&gt;.</source>
          <target state="translated">Вновь выделенный массив, который содержит все элементы из всех массивов в &lt;code&gt;arrs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bfc83d5aaa441cc17d963bee4285cbd7132ae42" translate="yes" xml:space="preserve">
          <source>A newly allocated associative array out of elements of the input range, which must be a range of tuples (Key, Value) or a range of keys and a range of values. If given two ranges of unequal lengths after the elements of the shorter are exhausted the remaining elements of the longer will not be considered. Returns a null associative array reference when given an empty range.</source>
          <target state="translated">Вновь выделенный ассоциативный массив из элементов входного диапазона,которым должен быть диапазон кортежей (Key,Value)или диапазон ключей и диапазон значений.Если задать два диапазона неравной длины после того,как элементы меньшей длины будут исчерпаны,остальные элементы большей длины не будут учитываться.Возвращает нулевую ассоциативную ссылку на массив при задании пустого диапазона.</target>
        </trans-unit>
        <trans-unit id="a74b61d6fbaa2ac33e4952e729ce5349769dee81" translate="yes" xml:space="preserve">
          <source>A newly allocated string (free with &lt;code&gt;FileName.free&lt;/code&gt;)</source>
          <target state="translated">Недавно выделенная строка (бесплатно с &lt;code&gt;FileName.free&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="09ea837e65593964e2e726763fa3715afa1b1dc5" translate="yes" xml:space="preserve">
          <source>A newly constructed &lt;code&gt;Rebindable&lt;/code&gt; initialized with the given reference.</source>
          <target state="translated">Вновь сконструированный &lt;code&gt;Rebindable&lt;/code&gt; инициализируется с заданной ссылкой.</target>
        </trans-unit>
        <trans-unit id="6f9d4939fae75b47bf842ea4be909ef69a850fab" translate="yes" xml:space="preserve">
          <source>A newly-allocated &lt;code&gt;char[]&lt;/code&gt; buffer containing the encoded string.</source>
          <target state="translated">Вновь выделенный буфер &lt;code&gt;char[]&lt;/code&gt; содержащий закодированную строку.</target>
        </trans-unit>
        <trans-unit id="6737f545d418f5fab0a8cd98756af22ad2345de6" translate="yes" xml:space="preserve">
          <source>A newly-allocated &lt;code&gt;ubyte[]&lt;/code&gt; buffer containing the decoded string.</source>
          <target state="translated">Вновь выделенный &lt;code&gt;ubyte[]&lt;/code&gt; содержащий декодированную строку.</target>
        </trans-unit>
        <trans-unit id="6cbeaad57c76e13779ce6ac08c1501f2baa2becd" translate="yes" xml:space="preserve">
          <source>A newly-allocated string with '/' turned into backslashes</source>
          <target state="translated">Вновь выделенная строка с '/' превратилась в обратный слеш.</target>
        </trans-unit>
        <trans-unit id="b60fe472d4a4f1a026b03539226ba0ee218ca83f" translate="yes" xml:space="preserve">
          <source>A node to represent an &lt;code&gt;extern(C++)&lt;/code&gt; namespace attribute</source>
          <target state="translated">Узел для представления атрибута пространства имен &lt;code&gt;extern(C++)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e55243265f23a9ee10b4e314b3e4a0f4faac55c" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Неблокирующая версия &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9fd214a621f3383db2974c087d288e90199fcc2" translate="yes" xml:space="preserve">
          <source>A non-final class for &lt;code&gt;BlackHole&lt;/code&gt; to inherit from.</source>
          <target state="translated">Не финальный класс, от которого &lt;code&gt;BlackHole&lt;/code&gt; наследуется.</target>
        </trans-unit>
        <trans-unit id="ab020c90d21a0f96c89bcc047365339b80928561" translate="yes" xml:space="preserve">
          <source>A non-final class for &lt;code&gt;WhiteHole&lt;/code&gt; to inherit from.</source>
          <target state="translated">Не финальный класс для &lt;code&gt;WhiteHole&lt;/code&gt; для наследования.</target>
        </trans-unit>
        <trans-unit id="031bc4c9658e80ad8a2cb3ec7b1be591d812424d" translate="yes" xml:space="preserve">
          <source>A non-zero value if the bit was set, and a zero if it was clear.</source>
          <target state="translated">Ненулевое значение,если бит установлен,и ноль,если бит чист.</target>
        </trans-unit>
        <trans-unit id="72542befd9bcdc3c2168bab3212670c01fa60845" translate="yes" xml:space="preserve">
          <source>A normalized number must not be zero, subnormal, infinite nor NAN.</source>
          <target state="translated">Нормализованное число не должно быть ни нулевым,ни субнормальным,ни бесконечным,ни NAN.</target>
        </trans-unit>
        <trans-unit id="5986225a8c14dd2904ed8727a8c36b4b4ab91e70" translate="yes" xml:space="preserve">
          <source>A null-terminated c-style string.</source>
          <target state="translated">Нуль-терминированная строка в стиле c.</target>
        </trans-unit>
        <trans-unit id="959a6643638b0fd28db46ce451674eab7bd7dc8f" translate="yes" xml:space="preserve">
          <source>A null-terminated copy of the input array.</source>
          <target state="translated">Нулевая копия входного массива.</target>
        </trans-unit>
        <trans-unit id="536bb1120b98fa3166cc23ac5b91ca0fa688e0f6" translate="yes" xml:space="preserve">
          <source>A number of macros are predefined Ddoc, and represent the minimal definitions needed by Ddoc to format and highlight the presentation. The definitions are for simple HTML.</source>
          <target state="translated">Ряд макросов являются предопределенными Ddoc и представляют собой минимальные определения,необходимые Ddoc для форматирования и выделения презентации.Эти определения предназначены для простого HTML.</target>
        </trans-unit>
        <trans-unit id="b643020affd22d977cdabc7eb97ef1a9351a628e" translate="yes" xml:space="preserve">
          <source>A number of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">Ряд типа &lt;code&gt;Target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="795b3a9cd51161270d51dd9a6e760416f686b603" translate="yes" xml:space="preserve">
          <source>A one-stop shop for converting values from one type to another.</source>
          <target state="translated">Универсальный магазин для преобразования значений из одного типа в другой.</target>
        </trans-unit>
        <trans-unit id="0f8e16281009488f6e1da73c602696b0e3667c90" translate="yes" xml:space="preserve">
          <source>A package module can be nested inside of a sub-package:</source>
          <target state="translated">Пакетный модуль может быть вложен в подпакет:</target>
        </trans-unit>
        <trans-unit id="58e7943122b890bc3f288bacc424746b3292890b" translate="yes" xml:space="preserve">
          <source>A package module can be used to publicly import other modules, while enabling a simpler import syntax. It enables converting a module into a package of modules, without breaking existing code which uses that module. Example of a set of library modules:</source>
          <target state="translated">Пакетный модуль может быть использован для публичного импорта других модулей,при одновременном включении более простого синтаксиса импорта.Это позволяет преобразовать модуль в пакет модулей,не нарушая при этом существующий код,который использует этот модуль.Пример набора модулей библиотек:</target>
        </trans-unit>
        <trans-unit id="a04e110bb022b03d3b922e3695d3e7adc2200bf9" translate="yes" xml:space="preserve">
          <source>A package module can be used to publicly import other modules, while providing a simpler import syntax. This enables the conversion of a module into a package of modules, without breaking existing code which uses that module. Example of a set of library modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a28f151234dbd8ab64e1c506c2ebc992d6b671b" translate="yes" xml:space="preserve">
          <source>A path name</source>
          <target state="translated">Имя пути</target>
        </trans-unit>
        <trans-unit id="5f78f753fbaef569a30512bea53d9843ed7dc5c5" translate="yes" xml:space="preserve">
          <source>A path name.</source>
          <target state="translated">Имя пути.</target>
        </trans-unit>
        <trans-unit id="ffc7c009898fd927436a7ec2ecfc0bfcdb246d3b" translate="yes" xml:space="preserve">
          <source>A path name. It can be a string, or any random-access range of characters.</source>
          <target state="translated">Имя пути.Это может быть строка или произвольный диапазон символов.</target>
        </trans-unit>
        <trans-unit id="f18094cf1074f7588c613d5faf886aceb62d1fe0" translate="yes" xml:space="preserve">
          <source>A pathname</source>
          <target state="translated">Отчество</target>
        </trans-unit>
        <trans-unit id="78a6c683923dd0a32e26b92d91ef3c5d7cf1c473" translate="yes" xml:space="preserve">
          <source>A pointer &lt;code&gt;T*&lt;/code&gt; can be implicitly converted to one of the following:</source>
          <target state="translated">Указатель &lt;code&gt;T*&lt;/code&gt; может быть неявно преобразован в одно из следующих:</target>
        </trans-unit>
        <trans-unit id="5fac494e378a0d59414ddbf809746f093e4eb4e5" translate="yes" xml:space="preserve">
          <source>A pointer changes its state when one of these operations is done to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f369556afeda28679fa10016a23a737d2fde07" translate="yes" xml:space="preserve">
          <source>A pointer into a GC-managed memory block or null.</source>
          <target state="translated">Указатель на GC-управляемый блок памяти или ноль.</target>
        </trans-unit>
        <trans-unit id="d914867fb3ca905d3a50656cdb991f09109768b8" translate="yes" xml:space="preserve">
          <source>A pointer is safe when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31247a2ada8205f8fca84735018b60a719fc5ab8" translate="yes" xml:space="preserve">
          <source>A pointer to a char can be generated:</source>
          <target state="translated">Может быть сгенерирован указатель на символ:</target>
        </trans-unit>
        <trans-unit id="055c3763e1071d2e75c0c47a34263897e4004558" translate="yes" xml:space="preserve">
          <source>A pointer to a filled-in struct, or NULL if it failed or ran out of structs. It also writes the number of messages left in the queue (after this read) in the integer the second argument points to.</source>
          <target state="translated">Указатель на заполненную структуру,или NULL,если она провалилась или закончилась.Он также записывает количество сообщений,оставленных в очереди (после этого чтения)в целое число,на которое указывает второй аргумент.</target>
        </trans-unit>
        <trans-unit id="5c572e2c9272f135a5ecf08d2e312fd017c2e5f0" translate="yes" xml:space="preserve">
          <source>A pointer to a structure of the following type is passed as the first argument to callbacks registered using rtree_geometry_callback().</source>
          <target state="translated">Указатель на структуру следующего типа передается в качестве первого аргумента обратным вызовам,зарегистрированным с помощью rtree_geometry_callback().</target>
        </trans-unit>
        <trans-unit id="2b69f01bcd79a9fcae2a82c0144723f65dc4fff6" translate="yes" xml:space="preserve">
          <source>A pointer to a valid memory address or to null.</source>
          <target state="translated">Указатель на действительный адрес памяти или на ноль.</target>
        </trans-unit>
        <trans-unit id="27d73edcee54b9f472f0424d434a1057ab09307f" translate="yes" xml:space="preserve">
          <source>A pointer to a value of type &lt;code&gt;T&lt;/code&gt; to bind this &lt;code&gt;NullableRef&lt;/code&gt; to.</source>
          <target state="translated">Указатель на значение типа &lt;code&gt;T&lt;/code&gt; для привязки этого &lt;code&gt;NullableRef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="123e3b7f1cada7f7a6b3145330dd24f1a9512379" translate="yes" xml:space="preserve">
          <source>A pointer to a zero-terminated error message.</source>
          <target state="translated">Указатель на сообщение об ошибке с нулевым значением.</target>
        </trans-unit>
        <trans-unit id="585ec4946d7250f1b7959b57a161ea59abc62007" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;Task&lt;/code&gt;.</source>
          <target state="translated">Указатель на &lt;code&gt;Task&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e347f97045f86b61abf98fd576817c4ebecc8590" translate="yes" xml:space="preserve">
          <source>A pointer to the base of a valid memory block or to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Указатель на базу действительного блока памяти или на &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2faece91f379997cc677ac01b800bed5a3226cd8" translate="yes" xml:space="preserve">
          <source>A pointer to the location from which to generate the trace, or null if the trace should be generated from within the trace handler itself.</source>
          <target state="translated">Указатель на место,из которого должна быть сгенерирована трасса,или ноль,если трасса должна быть сгенерирована изнутри самого обработчика трассы.</target>
        </trans-unit>
        <trans-unit id="00efafd626de55989df896279388bf417be22e67" translate="yes" xml:space="preserve">
          <source>A pointer to the newly constructed object (which is the same as &lt;code&gt;chunk&lt;/code&gt;).</source>
          <target state="translated">Указатель на вновь созданный объект (который совпадает с &lt;code&gt;chunk&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="04e3085788d4355827288e109ddfff2d36415f8d" translate="yes" xml:space="preserve">
          <source>A pointer to the newly constructed object.</source>
          <target state="translated">Указатель на только что построенный объект.</target>
        </trans-unit>
        <trans-unit id="d3438af629c85e364e264f2d61b1dc6f0cb93d08" translate="yes" xml:space="preserve">
          <source>A pointer to the root of a valid memory block or to null.</source>
          <target state="translated">Указатель на корень действительного блока памяти или на ноль.</target>
        </trans-unit>
        <trans-unit id="2f9c4397a0e60ae3c610cf4ea9c79c376db9a273" translate="yes" xml:space="preserve">
          <source>A pointer to the root or the interior of a valid memory block or to null.</source>
          <target state="translated">Указатель на корень или внутреннюю часть действительного блока памяти или на ноль.</target>
        </trans-unit>
        <trans-unit id="d4f30c23443333be11c3939d5add3300db185c1f" translate="yes" xml:space="preserve">
          <source>A pointer to the start of a garbage collected object need not be maintained if a pointer to the interior of the object exists.</source>
          <target state="translated">Указатель на начало мусорного объекта не требуется,если существует указатель на внутреннюю часть объекта.</target>
        </trans-unit>
        <trans-unit id="937ad04bc8d27b425122f4ff0e28fe2a6b34aa67" translate="yes" xml:space="preserve">
          <source>A pointer to the wrapped range.</source>
          <target state="translated">Указатель на завернутый диапазон.</target>
        </trans-unit>
        <trans-unit id="de10b9d1ba8cc9971077f18b65a847c5f66cabd1" translate="yes" xml:space="preserve">
          <source>A pointer to type</source>
          <target state="translated">Указатель на ввод</target>
        </trans-unit>
        <trans-unit id="d42c56ec52222e94adff47ed32fddef163a6c3ac" translate="yes" xml:space="preserve">
          <source>A positive integer if the expression &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; is true.</source>
          <target state="translated">Целое положительное число, если выражение &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="555ba288df251c36b028c8f723b06d00e8e1a934" translate="yes" xml:space="preserve">
          <source>A properly-aligned buffer of size &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if request could not be satisfied.</source>
          <target state="translated">Правильно выровненный буфер размера &lt;code&gt;n&lt;/code&gt; или &lt;code&gt;null&lt;/code&gt; если запрос не может быть удовлетворен.</target>
        </trans-unit>
        <trans-unit id="40173a27a21f77300ecbd5eb9b58efd83c3743be" translate="yes" xml:space="preserve">
          <source>A properly-aligned buffer of size &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if request could not be satisfied.</source>
          <target state="translated">Правильно выровненный буфер размера &lt;code&gt;n&lt;/code&gt; или &lt;code&gt;null&lt;/code&gt; если запрос не может быть выполнен.</target>
        </trans-unit>
        <trans-unit id="5cd1a3a44f65d015ec06c617a48022629efc0f36" translate="yes" xml:space="preserve">
          <source>A pure function can throw exceptions.</source>
          <target state="translated">Чистая функция может бросать исключения.</target>
        </trans-unit>
        <trans-unit id="6e6fdf29b67b71fed1a68f3cfc1cd97f5768fd48" translate="yes" xml:space="preserve">
          <source>A pure function that accepts only parameters without mutable indirections and returns a result that has mutable indirections is called a</source>
          <target state="translated">Чистая функция,которая принимает только параметры без изменяемых индендикаций и возвращает результат с изменяемыми индендикциями,называется a</target>
        </trans-unit>
        <trans-unit id="1d7d0a98b06912a5378cb6a8be77b4b02de5f3f8" translate="yes" xml:space="preserve">
          <source>A quote can appear in a field if the field was not quoted.</source>
          <target state="translated">Цитата может появиться в поле,если поле не было процитировано.</target>
        </trans-unit>
        <trans-unit id="dab172d9342291d883cccb31c1f54125707f8122" translate="yes" xml:space="preserve">
          <source>A quoted pair contains a deprecated character</source>
          <target state="translated">Цитируемая пара содержит недопустимый символ</target>
        </trans-unit>
        <trans-unit id="3f8b2a78083063455683a768a44d03d55ad12cf1" translate="yes" xml:space="preserve">
          <source>A quoted string contains a character that is not allowed</source>
          <target state="translated">Цитируемая строка содержит символ,который не разрешен</target>
        </trans-unit>
        <trans-unit id="27a6d12250519ad8403433313356e264b21e4238" translate="yes" xml:space="preserve">
          <source>A quoted string contains a deprecated character</source>
          <target state="translated">Цитируемая строка содержит недопустимый символ</target>
        </trans-unit>
        <trans-unit id="8ce910ff6b6ea039902607e039d976386a6c2bcb" translate="yes" xml:space="preserve">
          <source>A random-access range with length and slicing.</source>
          <target state="translated">Диапазон произвольного доступа с длиной и нарезкой.</target>
        </trans-unit>
        <trans-unit id="5ab13239b15c05c8a18c866acd5ff508c10f0785" translate="yes" xml:space="preserve">
          <source>A random-number generator has at least the following features:</source>
          <target state="translated">Генератор случайных чисел обладает,по крайней мере,следующими характеристиками:</target>
        </trans-unit>
        <trans-unit id="2369c4e0bd127f36f89cb0d18babe9bdf36717a3" translate="yes" xml:space="preserve">
          <source>A range can be obtained from an &lt;code&gt;Interval&lt;/code&gt;, allowing iteration over that interval, with the exact time points which are iterated over depending on the function which generates the range.</source>
          <target state="translated">Диапазон может быть получен из &lt;code&gt;Interval&lt;/code&gt; , что позволяет выполнять итерацию по этому интервалу с точными точками времени, которые повторяются в зависимости от функции, которая генерирует диапазон.</target>
        </trans-unit>
        <trans-unit id="b639cb4a48b0556049879b0e35d4220ae50b6838" translate="yes" xml:space="preserve">
          <source>A range comprehending the elements after the removed range.</source>
          <target state="translated">Диапазон понимания элементов после удаленного диапазона.</target>
        </trans-unit>
        <trans-unit id="62ecf5f43eeb5ae065f43af3ab053cc44e507e8a" translate="yes" xml:space="preserve">
          <source>A range containing all of the elements of range with offset removed.</source>
          <target state="translated">Диапазон,содержащий все элементы диапазона со снятым смещением.</target>
        </trans-unit>
        <trans-unit id="36203d4512a91c0a9012250f98599f6059425b15" translate="yes" xml:space="preserve">
          <source>A range containing all of the elements that were after the given range.</source>
          <target state="translated">Диапазон,содержащий все элементы,которые были после данного диапазона.</target>
        </trans-unit>
        <trans-unit id="35fa81f22f65879e22267db3d96f05f95183e05a" translate="yes" xml:space="preserve">
          <source>A range containing only elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; for which &lt;code&gt;predicate(x)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Диапазон, содержащий только элементы &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; для которого &lt;code&gt;predicate(x)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="705afd0dac091e12edaa52a3a62a3d89d56bfb83" translate="yes" xml:space="preserve">
          <source>A range containing only the elements in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Диапазон, содержащий только элементы в &lt;code&gt;r&lt;/code&gt; , для которых &lt;code&gt;pred&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d664b52e0ecc777b7a166cb1e02830ee1347b8c8" translate="yes" xml:space="preserve">
          <source>A range containing the elements of the original range with the extra padding  See Also: &lt;a href=&quot;std_string#leftJustifier&quot;&gt;&lt;code&gt;std.string.leftJustifier&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Диапазон, содержащий элементы исходного диапазона с дополнительным заполнением См. Также: &lt;a href=&quot;std_string#leftJustifier&quot;&gt; &lt;code&gt;std.string.leftJustifier&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62492856e552ba212ecf4efe925331778586bd9c" translate="yes" xml:space="preserve">
          <source>A range containing the elements of the original range with the extra padding  See Also: &lt;a href=&quot;std_string#rightJustifier&quot;&gt;&lt;code&gt;std.string.rightJustifier&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Диапазон, содержащий элементы исходного диапазона с дополнительным заполнением См. Также: &lt;a href=&quot;std_string#rightJustifier&quot;&gt; &lt;code&gt;std.string.rightJustifier&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1af0f8498eec4df1ba0a6407021b24920e00cb16" translate="yes" xml:space="preserve">
          <source>A range containing the intersection of the given ranges.</source>
          <target state="translated">Диапазон,содержащий пересечение заданных диапазонов.</target>
        </trans-unit>
        <trans-unit id="d6eab95de89ff8f3fe4b41997798b90e98a67ead" translate="yes" xml:space="preserve">
          <source>A range containing the union of the given ranges.</source>
          <target state="translated">Диапазон,содержащий соединение данных диапазонов.</target>
        </trans-unit>
        <trans-unit id="a8928733aac77a4c880de32d0da1f4f597bcc621" translate="yes" xml:space="preserve">
          <source>A range of &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward ranges&lt;/a&gt; sorted by &lt;code&gt;less&lt;/code&gt;.</source>
          <target state="translated">Диапазон &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямых диапазонов&lt;/a&gt; отсортирован по &lt;code&gt;less&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="676b20d5eb4486b25e2a3fced3da160eb1954590" translate="yes" xml:space="preserve">
          <source>A range of Char[] with the content of the resource pointer to by the URL</source>
          <target state="translated">Диапазон Char[]с содержимым указателя ресурса по URL</target>
        </trans-unit>
        <trans-unit id="3edcc4322a1c5c6d6faec72af3c489a46046e7da" translate="yes" xml:space="preserve">
          <source>A range of Char[] with the content of the resource pointer to by the URL.</source>
          <target state="translated">Диапазон Char[]с содержимым указателя ресурса по URL.</target>
        </trans-unit>
        <trans-unit id="b3dd828e007455ab645ab3d293799ecfb401e928" translate="yes" xml:space="preserve">
          <source>A range of chunks is returned immediately and the request that fetches the chunks is performed in another thread. If the method or other request properties is to be customized then set the &lt;code&gt;conn&lt;/code&gt; parameter with a HTTP/FTP instance that has these properties set.</source>
          <target state="translated">Диапазон чанков возвращается немедленно, и запрос, который выбирает чанки, выполняется в другом потоке. Если необходимо настроить метод или другие свойства запроса, установите для параметра &lt;code&gt;conn&lt;/code&gt; экземпляр HTTP / FTP, для которого установлены эти свойства.</target>
        </trans-unit>
        <trans-unit id="5fe31de01d893564f16647e8c82cd0093cdb8a50" translate="yes" xml:space="preserve">
          <source>A range of chunks is returned when the request is complete. If the method or other request properties is to be customized then set the &lt;code&gt;conn&lt;/code&gt; parameter with a HTTP/FTP instance that has these properties set.</source>
          <target state="translated">Диапазон чанков возвращается, когда запрос завершен. Если необходимо настроить метод или другие свойства запроса, установите для параметра &lt;code&gt;conn&lt;/code&gt; экземпляр HTTP / FTP, для которого установлены эти свойства.</target>
        </trans-unit>
        <trans-unit id="19065c01493532a48f8f0e2835b9e9b99cef94fc" translate="yes" xml:space="preserve">
          <source>A range of elements in the joined range. This will be a forward range if both outer and inner ranges of &lt;code&gt;RoR&lt;/code&gt; are forward ranges; otherwise it will be only an input range. The &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;range bidirectionality&lt;/a&gt; is propagated if no separator is specified.</source>
          <target state="translated">Диапазон элементов в объединенном диапазоне. Это будет прямой диапазон, если как внешние, так и внутренние диапазоны &lt;code&gt;RoR&lt;/code&gt; являются прямыми диапазонами; в противном случае это будет только входной диапазон. &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;Диапазон двунаправленность&lt;/a&gt; распространяется , если не указан сепаратор.</target>
        </trans-unit>
        <trans-unit id="0c7fbb83b5b6db95c035ecdd5415d5d39a2b82b8" translate="yes" xml:space="preserve">
          <source>A range of elements of type &lt;code&gt;Tuple!(ElementType!R, uint)&lt;/code&gt;, representing each consecutively unique element and its respective number of occurrences in that run. This will be an input range if &lt;code&gt;R&lt;/code&gt; is an input range, and a forward range in all other cases.</source>
          <target state="translated">Диапазон элементов типа &lt;code&gt;Tuple!(ElementType!R, uint)&lt;/code&gt; , представляющих каждый последовательно уникальный элемент и соответствующее ему число вхождений в этом прогоне. Это будет входной диапазон, если &lt;code&gt;R&lt;/code&gt; - входной диапазон, и прямой диапазон во всех других случаях.</target>
        </trans-unit>
        <trans-unit id="7041641edd4f22e58a1aabcd40e8d1b80ea0a610" translate="yes" xml:space="preserve">
          <source>A range of forward ranges sorted by &lt;code&gt;less&lt;/code&gt;.</source>
          <target state="translated">Диапазон прямых диапазонов отсортирован по &lt;code&gt;less&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="354db039469e45ae2b597be319b44776f92adc6e" translate="yes" xml:space="preserve">
          <source>A range of lines is returned immediately and the request that fetches the lines is performed in another thread. If the method or other request properties is to be customized then set the &lt;code&gt;conn&lt;/code&gt; parameter with a HTTP/FTP instance that has these properties set.</source>
          <target state="translated">Диапазон строк возвращается немедленно, и запрос, извлекающий строки, выполняется в другом потоке. Если необходимо настроить метод или другие свойства запроса, установите для параметра &lt;code&gt;conn&lt;/code&gt; экземпляр HTTP / FTP, для которого установлены эти свойства.</target>
        </trans-unit>
        <trans-unit id="d9865bd96c9df41311c369964e6070a859743ab6" translate="yes" xml:space="preserve">
          <source>A range of lines is returned when the request is complete. If the method or other request properties is to be customized then set the &lt;code&gt;conn&lt;/code&gt; parameter with a HTTP/FTP instance that has these properties set.</source>
          <target state="translated">Диапазон строк возвращается, когда запрос завершен. Если необходимо настроить метод или другие свойства запроса, установите для параметра &lt;code&gt;conn&lt;/code&gt; экземпляр HTTP / FTP, для которого установлены эти свойства.</target>
        </trans-unit>
        <trans-unit id="497f1a2a9dd3a36e535388f9ccb222ab636fe2a5" translate="yes" xml:space="preserve">
          <source>A range of ranges sorted by &lt;code&gt;less&lt;/code&gt; to compute the intersection for.</source>
          <target state="translated">Диапазон диапазонов, отсортированных по &lt;code&gt;less&lt;/code&gt; для вычисления пересечения.</target>
        </trans-unit>
        <trans-unit id="aa6f78e48001ea4e73b84dd8184f722313a3c338" translate="yes" xml:space="preserve">
          <source>A range of ranges sorted by &lt;code&gt;less&lt;/code&gt; to compute the union for.</source>
          <target state="translated">Диапазон диапазонов, отсортированных по &lt;code&gt;less&lt;/code&gt; для вычисления объединения.</target>
        </trans-unit>
        <trans-unit id="2f822277f0b8cece8291209a0e727b0089f7fe59" translate="yes" xml:space="preserve">
          <source>A range of the difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;.</source>
          <target state="translated">Диапазон разности &lt;code&gt;r1&lt;/code&gt; и &lt;code&gt;r2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4c1f1bb179a505b7946948972d2dfe2af89e9bf" translate="yes" xml:space="preserve">
          <source>A range of the symmetric difference between &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;.</source>
          <target state="translated">Диапазон симметричной разности между &lt;code&gt;r1&lt;/code&gt; и &lt;code&gt;r2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198ede3c7dd9ac9f559cf09844fe07660dbdcfad" translate="yes" xml:space="preserve">
          <source>A range of the union of the ranges in &lt;code&gt;ror&lt;/code&gt;.</source>
          <target state="translated">Диапазон объединения диапазонов в &lt;code&gt;ror&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1c814838fd8af6caf599d08b7f42e5c1c54006c" translate="yes" xml:space="preserve">
          <source>A range of the union of the ranges in &lt;code&gt;ror&lt;/code&gt;.  See also: &lt;a href=&quot;#multiwayMerge&quot;&gt;&lt;code&gt;multiwayMerge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Диапазон объединения диапазонов в &lt;code&gt;ror&lt;/code&gt; . Смотрите также: &lt;a href=&quot;#multiwayMerge&quot;&gt; &lt;code&gt;multiwayMerge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0fd8837e93d6f61035bcdc59926749ad6b1feb5c" translate="yes" xml:space="preserve">
          <source>A range of ubyte[chunkSize] with the content of the resource pointer to by the URL</source>
          <target state="translated">Диапазон ubyte[chunkSize]с содержимым указателя ресурса по URL-адресу</target>
        </trans-unit>
        <trans-unit id="ac378f9d08628fb197b154924f854d8dbc3d5f7b" translate="yes" xml:space="preserve">
          <source>A range of ubyte[chunkSize] with the content of the resource pointer to by the URL.</source>
          <target state="translated">Диапазон ubyte[chunkSize]с содержимым указателя ресурса по URL.</target>
        </trans-unit>
        <trans-unit id="fa7af0ae297a566e4c920200a8bf4a77c133310b" translate="yes" xml:space="preserve">
          <source>A range over a &lt;code&gt;NegInfInterval&lt;/code&gt;. It is an infinite range.</source>
          <target state="translated">Диапазон за &lt;code&gt;NegInfInterval&lt;/code&gt; . Это бесконечный диапазон.</target>
        </trans-unit>
        <trans-unit id="6c95b6229f5539227d791beda356e4068ac7ef0b" translate="yes" xml:space="preserve">
          <source>A range over a &lt;code&gt;PosInfInterval&lt;/code&gt;. It is an infinite range.</source>
          <target state="translated">Диапазон за &lt;code&gt;PosInfInterval&lt;/code&gt; . Это бесконечный диапазон.</target>
        </trans-unit>
        <trans-unit id="986a6601092a6f8391a77770c02fc14a503a32e1" translate="yes" xml:space="preserve">
          <source>A range over an &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Диапазон за &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c25d66b23660641ba1f4311784dca353a985d38" translate="yes" xml:space="preserve">
          <source>A range spanning the remaining elements in the array that initially were right after &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Диапазон, охватывающий оставшиеся элементы в массиве, которые изначально были сразу после &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09405d484cc6a28f47f7c4b04722cc19549c0d0b" translate="yes" xml:space="preserve">
          <source>A range spanning the remaining elements in the container that initially were right after &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Диапазон, охватывающий оставшиеся элементы в контейнере, которые изначально были сразу после &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a936c25da463fa2d2374fd1fe45e3701451d69a" translate="yes" xml:space="preserve">
          <source>A range that goes through the numbers &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;begin + step&lt;/code&gt;, &lt;code&gt;begin + 2 * step&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, up to and excluding &lt;code&gt;end&lt;/code&gt;.  The two-argument overloads have &lt;code&gt;step = 1&lt;/code&gt;. If &lt;code&gt;begin &amp;lt; end &amp;amp;&amp;amp; step &amp;lt; 0&lt;/code&gt; or &lt;code&gt;begin &amp;gt; end &amp;amp;&amp;amp; step &amp;gt; 0&lt;/code&gt; or &lt;code&gt;begin == end&lt;/code&gt;, then an empty range is returned. If &lt;code&gt;step == 0&lt;/code&gt; then &lt;code&gt;begin == end&lt;/code&gt; is an error.  For built-in types, the range returned is a random access range. For user-defined types that support &lt;code&gt;++&lt;/code&gt;, the range is an input range.  An integral iota also supports &lt;code&gt;in&lt;/code&gt; operator from the right. It takes the stepping into account, the integral won't be considered contained if it falls between two consecutive values of the range. &lt;code&gt;contains&lt;/code&gt; does the same as in, but from lefthand side.</source>
          <target state="translated">Диапазон, который проходит через числа &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;begin + step&lt;/code&gt; , &lt;code&gt;begin + 2 * step&lt;/code&gt; , &lt;code&gt;...&lt;/code&gt; , до и без &lt;code&gt;end&lt;/code&gt; . Перегрузки с двумя аргументами имеют &lt;code&gt;step = 1&lt;/code&gt; . Если &lt;code&gt;begin &amp;lt; end &amp;amp;&amp;amp; step &amp;lt; 0&lt;/code&gt; или &lt;code&gt;begin &amp;gt; end &amp;amp;&amp;amp; step &amp;gt; 0&lt;/code&gt; или &lt;code&gt;begin == end&lt;/code&gt; , возвращается пустой диапазон. Если &lt;code&gt;step == 0&lt;/code&gt; тогда &lt;code&gt;begin == end&lt;/code&gt; является ошибкой. Для встроенных типов возвращаемый диапазон является диапазоном произвольного доступа. Для пользовательских типов, которые поддерживают &lt;code&gt;++&lt;/code&gt; , диапазон является диапазоном ввода. Интегральная йота также поддерживает &lt;code&gt;in&lt;/code&gt; оператор справа. При этом учитывается шаг, интеграл не будет считаться содержащимся, если он находится между двумя последовательными значениями диапазона. &lt;code&gt;contains&lt;/code&gt; то же, что и в, но с левой стороны.</target>
        </trans-unit>
        <trans-unit id="22775f9c0f0725180dca7b39cc29c837bae61c2d" translate="yes" xml:space="preserve">
          <source>A range that iterates over all elements of the array in forward order.</source>
          <target state="translated">Диапазон,который итерирует все элементы массива в прямом порядке.</target>
        </trans-unit>
        <trans-unit id="0d6042f7ea5471bc7a85b309dc875f808da5fdb9" translate="yes" xml:space="preserve">
          <source>A range that iterates over elements of the array from index &lt;code&gt;i&lt;/code&gt; up to (excluding) index &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">Диапазон, который перебирает элементы массива от индекса &lt;code&gt;i&lt;/code&gt; до (исключая) индекса &lt;code&gt;j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a58ddeaba79d28f8baa264b490e01438d0a73c" translate="yes" xml:space="preserve">
          <source>A range that iterates over elements of the array in forward order.</source>
          <target state="translated">Диапазон,который итературирует над элементами массива в прямом порядке.</target>
        </trans-unit>
        <trans-unit id="472a84c8abdaf0f66905bcefc155697e1962974e" translate="yes" xml:space="preserve">
          <source>A range that iterates the array between two specified positions.</source>
          <target state="translated">Диапазон,который итерирует массив между двумя указанными позициями.</target>
        </trans-unit>
        <trans-unit id="465bdfce8c19fb509380450e3c61584e8279fc41" translate="yes" xml:space="preserve">
          <source>A range that lazily produces a string output escaped to be used inside of a regular expression.</source>
          <target state="translated">Диапазон,который лениво производит вывод строки,уклоняющийся для использования внутри регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="7a843c526c08e5282b2d40ffeb53a32f20073820" translate="yes" xml:space="preserve">
          <source>A range that spans each &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; in this set.</source>
          <target state="translated">Диапазон, который охватывает каждую &lt;a href=&quot;#Code%20point&quot;&gt;кодовую точку&lt;/a&gt; в этом наборе.</target>
        </trans-unit>
        <trans-unit id="d13659d418fd5667a2a45e0c6e1f23ef28169af7" translate="yes" xml:space="preserve">
          <source>A range type dependent on &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="translated">Тип диапазона зависит от &lt;code&gt;R1&lt;/code&gt; и &lt;code&gt;R2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aca5fa10af5948aacb0618dcc7659c011b96c280" translate="yes" xml:space="preserve">
          <source>A range with each fun applied to all the elements. If there is more than one fun, the element type will be &lt;code&gt;Tuple&lt;/code&gt; containing one element for each fun.</source>
          <target state="translated">Диапазон с каждым забавным, примененным ко всем элементам. Если имеется более одного веселья, тип элемента будет &lt;code&gt;Tuple&lt;/code&gt; , содержащий один элемент для каждого веселья.</target>
        </trans-unit>
        <trans-unit id="a647974a789216b78223c54f30ddb7dbc6f42bec" translate="yes" xml:space="preserve">
          <source>A reader sub-mutex.</source>
          <target state="translated">Читательский суб-мутекс.</target>
        </trans-unit>
        <trans-unit id="78aacc289e57898ba520714d51228a88f7785c8a" translate="yes" xml:space="preserve">
          <source>A real number.</source>
          <target state="translated">Настоящее число.</target>
        </trans-unit>
        <trans-unit id="e5279da871ece6d65446e8b83a539f4a46cf9e5b" translate="yes" xml:space="preserve">
          <source>A record has fields separated by a comma (customizable)</source>
          <target state="translated">Запись имеет поля,разделенные запятой (настраиваемые).</target>
        </trans-unit>
        <trans-unit id="8d0f9f69bb9f8022d38780e473a8ed97e90abb3f" translate="yes" xml:space="preserve">
          <source>A record is separated by a new line (CRLF,LF,CR)</source>
          <target state="translated">Запись отделяется новой строкой (CRLF,LF,CR).</target>
        </trans-unit>
        <trans-unit id="6df43b7e98ec239b05b80ec724f5f279a0b314fe" translate="yes" xml:space="preserve">
          <source>A ref parameter can also be returned by reference - see: &lt;a href=&quot;#return-ref-parameters&quot;&gt;&lt;code&gt;return ref&lt;/code&gt; parameters.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5838b1b8195e7908693ea69a0ccd678dde645bf2" translate="yes" xml:space="preserve">
          <source>A reference counted struct that wraps the dynamic allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</source>
          <target state="translated">Ссылочная подсчитанная структура,которая обертывает интерфейс динамического аллокатора.Он должен использоваться везде,где требуется единый тип для инкапсуляции различных реализаций аллокатора.</target>
        </trans-unit>
        <trans-unit id="073ff9e700584023c7f918b3c35ddc44ddc93350" translate="yes" xml:space="preserve">
          <source>A reference counted struct that wraps the dynamic shared allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</source>
          <target state="translated">Ссылка на подсчитанную структуру,которая обертывает динамический интерфейс общего аллокатора.Он должен использоваться везде,где требуется единый тип для инкапсуляции различных реализаций аллокатора.</target>
        </trans-unit>
        <trans-unit id="42e7f065a5d8231c47d820792cd468e9083d8ea9" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Ссылка на &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eeb6dd68fac30b5064fbb6c8083f183c09787e7" translate="yes" xml:space="preserve">
          <source>A reference to a class, or an interface. We need this when we point to a base class (we must record what the type is).</source>
          <target state="translated">Ссылка на класс или интерфейс.Нам это нужно,когда мы указываем на базовый класс (мы должны записать,что это за тип).</target>
        </trans-unit>
        <trans-unit id="30938b6d6a99ea62f4185cf08673d2059303fed2" translate="yes" xml:space="preserve">
          <source>A reference to a declaration marked with the &lt;code&gt;@disable&lt;/code&gt; attribute causes a compile time error. This can be used to explicitly disallow certain operations or overloads at compile time rather than relying on generating a runtime error.</source>
          <target state="translated">Ссылка на объявление, помеченное атрибутом &lt;code&gt;@disable&lt;/code&gt; , вызывает ошибку времени компиляции. Это можно использовать для явного запрета определенных операций или перегрузок во время компиляции, а не для создания ошибки времени выполнения.</target>
        </trans-unit>
        <trans-unit id="68e9ca0fa77d6187ddb37422879e54ea57fecf2e" translate="yes" xml:space="preserve">
          <source>A reference to an object, interface, associative array, or an array slice to initialize the &lt;code&gt;Rebindable&lt;/code&gt; with.</source>
          <target state="translated">Ссылка на объект, интерфейс, ассоциативный массив или фрагмент массива для инициализации &lt;code&gt;Rebindable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c12cdfe35d9669562e6c6517387b415345dc5100" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Date&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">Ссылка на &lt;code&gt;Date&lt;/code&gt; ( &lt;code&gt;this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e807fe0dbc26276ecc9263d30854a040d1f0bceb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;DateTime&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">Ссылка на &lt;code&gt;DateTime&lt;/code&gt; ( &lt;code&gt;this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ecb5758110283986b0f628f0dee35b28e439047" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;TimeOfDay&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">Ссылка на &lt;code&gt;TimeOfDay&lt;/code&gt; ( &lt;code&gt;this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3643ec80e8e77b31f829b56e6385e6b5fae1a8bb" translate="yes" xml:space="preserve">
          <source>A reference to the allocated memory on success or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;sz&lt;/code&gt; is zero or the pointer does not point to the base of an GC allocated memory block.</source>
          <target state="translated">Ссылка на выделенную память на успех или &lt;code&gt;null&lt;/code&gt; , если &lt;code&gt;sz&lt;/code&gt; равно нулю или указатель не указывает на основание с GC выделяется блок памяти.</target>
        </trans-unit>
        <trans-unit id="0d5352d81e29a32196c5f56f2bb9ed97b987c1d7" translate="yes" xml:space="preserve">
          <source>A reference to the allocated memory or null if insufficient memory is available.</source>
          <target state="translated">Ссылка на выделенную память или ноль,если памяти недостаточно.</target>
        </trans-unit>
        <trans-unit id="e37e582469e7c67872dafc3589a5e25b3c66b5ab" translate="yes" xml:space="preserve">
          <source>A reference to the current thread. May be null.</source>
          <target state="translated">Ссылка на текущий поток.Может быть нулевой.</target>
        </trans-unit>
        <trans-unit id="a61f330905217e37d6323303c34b226425d66b17" translate="yes" xml:space="preserve">
          <source>A reference to the digest for convenient chaining.</source>
          <target state="translated">Ссылка на дайджест для удобства приковывания.</target>
        </trans-unit>
        <trans-unit id="20e52674df62aed2822a9ce68fb98c50fe7dd734" translate="yes" xml:space="preserve">
          <source>A reference to the initialized variable</source>
          <target state="translated">Ссылка на инициализированную переменную</target>
        </trans-unit>
        <trans-unit id="1a73c900947644b46c70f39971b466339325ec9c" translate="yes" xml:space="preserve">
          <source>A reference to the library or null on error.</source>
          <target state="translated">Ссылка на библиотеку или ноль по ошибке.</target>
        </trans-unit>
        <trans-unit id="75039d96df258122331865dd56bd4d83100ff798" translate="yes" xml:space="preserve">
          <source>A reference to the library to unload.</source>
          <target state="translated">Ссылка на библиотеку для выгрузки.</target>
        </trans-unit>
        <trans-unit id="d686f93504e54ee14861d429718fa839597a8cdf" translate="yes" xml:space="preserve">
          <source>A reference to the newly created thread.</source>
          <target state="translated">Ссылка на вновь созданный поток.</target>
        </trans-unit>
        <trans-unit id="c9756cbec24ff837e6d02b449d53fc6cb5a1e5f3" translate="yes" xml:space="preserve">
          <source>A reference to the next error in the list. This is used when a new &lt;code&gt;Throwable&lt;/code&gt; is thrown from inside a &lt;code&gt;catch&lt;/code&gt; block. The originally caught &lt;code&gt;Exception&lt;/code&gt; will be chained to the new &lt;code&gt;Throwable&lt;/code&gt; via this field.</source>
          <target state="translated">Ссылка на следующую ошибку в списке. Это используется, когда новый &lt;code&gt;Throwable&lt;/code&gt; выбрасывается изнутри блока &lt;code&gt;catch&lt;/code&gt; . Изначально полученное &lt;code&gt;Exception&lt;/code&gt; будет &lt;code&gt;Throwable&lt;/code&gt; с новым Throwable через это поле.</target>
        </trans-unit>
        <trans-unit id="ff58948889bb0a36a8abceb97a8a3c148dcf9671" translate="yes" xml:space="preserve">
          <source>A refernce to the &lt;code&gt;Logger&lt;/code&gt; used to create this &lt;code&gt;LogEntry&lt;/code&gt;</source>
          <target state="translated">Ссылка на &lt;code&gt;Logger&lt;/code&gt; , использованный для создания этого &lt;code&gt;LogEntry&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91e4b10e829acb93ce7cd86702882a460a9c1e50" translate="yes" xml:space="preserve">
          <source>A regex engine state, as returned by &lt;code&gt;match&lt;/code&gt; family of functions.</source>
          <target state="translated">Состояние обработчика регулярных выражений, возвращаемое семейством функций &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2539e853fd15604cb6a934d48bc2528e82ab9538" translate="yes" xml:space="preserve">
          <source>A reimplemented interface must implement all the interface functions, it does not inherit them from a super class:</source>
          <target state="translated">Перереализованный интерфейс должен реализовывать все интерфейсные функции,он не наследует их от супер-класса:</target>
        </trans-unit>
        <trans-unit id="306cb18355cd21a0060bd8023086f1a746ecc542" translate="yes" xml:space="preserve">
          <source>A relational operator can have &lt;code&gt;NaN&lt;/code&gt; operands. If either or both operands is &lt;code&gt;NaN&lt;/code&gt;, the floating point comparison operation returns as follows:</source>
          <target state="translated">Реляционный оператор может иметь операнды &lt;code&gt;NaN&lt;/code&gt; . Если один или оба операнда имеют значение &lt;code&gt;NaN&lt;/code&gt; , операция сравнения с плавающей запятой возвращается следующим образом:</target>
        </trans-unit>
        <trans-unit id="2fbb01cbf6b15e85576d1bc8dafb5f686611418c" translate="yes" xml:space="preserve">
          <source>A root module is one that will be compiled all the way to object code. This field holds the root module that caused this module to be loaded. If this module is a root module, then it will be set to &lt;code&gt;this&lt;/code&gt;. This is used to determine ownership of template instantiation.</source>
          <target state="translated">Корневой модуль - это тот, который будет компилироваться вплоть до объектного кода. Это поле содержит корневой модуль, который вызвал загрузку этого модуля. Если этот модуль является корневым, то он будет установлен на &lt;code&gt;this&lt;/code&gt; . Это используется для определения принадлежности экземпляра шаблона.</target>
        </trans-unit>
        <trans-unit id="bfb6ac8ef8ee222f7c87138ddd6e6d11dddde966" translate="yes" xml:space="preserve">
          <source>A scope block statement introduces a new scope for the &lt;a href=&quot;#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Оператор блока области действия вводит новую область действия для &lt;a href=&quot;#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4eca2516e751338cb4cea2d3632121becc1dcc07" translate="yes" xml:space="preserve">
          <source>A scope class is a class with the &lt;code&gt;scope&lt;/code&gt; attribute, as in:</source>
          <target state="translated">Класс области действия - это класс с атрибутом &lt;code&gt;scope&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="1726fb56d87e8ffffee60a1adced14592e54f844" translate="yes" xml:space="preserve">
          <source>A scope class reference can only appear as a function local variable. It must be declared as being &lt;code&gt;scope&lt;/code&gt;:</source>
          <target state="translated">Ссылка на класс области видимости может появляться только как локальная переменная функции. Он должен быть объявлен как &lt;code&gt;scope&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c0af4522df69cbecf3e1a90ca6686769a3cc8194" translate="yes" xml:space="preserve">
          <source>A seed may be passed to &lt;code&gt;sum&lt;/code&gt;. Not only will this seed be used as an initial value, but its type will override all the above, and determine the algorithm and precision used for summation.</source>
          <target state="translated">Семя может быть передано на &lt;code&gt;sum&lt;/code&gt; . Мало того, что это начальное число будет использоваться в качестве начального значения, но и его тип переопределит все вышеперечисленное и определит алгоритм и точность, используемые для суммирования.</target>
        </trans-unit>
        <trans-unit id="2f9fca3d6e02409b85bf8f849854c6284ce6f9bb" translate="yes" xml:space="preserve">
          <source>A seed may be passed to &lt;code&gt;sum&lt;/code&gt;. Not only will this seed be used as an initial value, but its type will override all the above, and determine the algorithm and precision used for summation. If a seed is not passed, one is created with the value of &lt;code&gt;typeof(r.front + r.front)(0)&lt;/code&gt;, or &lt;code&gt;typeof(r.front + r.front).zero&lt;/code&gt; if no constructor exists that takes an int.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ed8bfa97374dda35f3e6d60a27183df8e3dd7b" translate="yes" xml:space="preserve">
          <source>A seedable random-number generator has the following additional features:</source>
          <target state="translated">Посевной генератор случайных чисел имеет следующие дополнительные функции:</target>
        </trans-unit>
        <trans-unit id="62eef04deeedb61ec809031e320e402553bde037" translate="yes" xml:space="preserve">
          <source>A semi-lazy parallel map that can be used for pipelining. The map functions are evaluated for the first &lt;code&gt;bufSize&lt;/code&gt; elements and stored in a buffer and made available to &lt;code&gt;popFront&lt;/code&gt;. Meanwhile, in the background a second buffer of the same size is filled. When the first buffer is exhausted, it is swapped with the second buffer and filled while the values from what was originally the second buffer are read. This implementation allows for elements to be written to the buffer without the need for atomic operations or synchronization for each write, and enables the mapping function to be evaluated efficiently in parallel.</source>
          <target state="translated">Полуленивая параллельная карта, которую можно использовать для конвейерной обработки. Функции карты оцениваются для первых элементов &lt;code&gt;bufSize&lt;/code&gt; и сохраняются в буфере и &lt;code&gt;popFront&lt;/code&gt; доступными для popFront . Между тем, на заднем плане заполняется второй буфер того же размера. Когда первый буфер исчерпан, он заменяется вторым буфером и заполняется, пока считываются значения из того, что изначально было вторым буфером. Эта реализация позволяет записывать элементы в буфер без необходимости атомарных операций или синхронизации для каждой записи и позволяет эффективно оценивать функцию отображения параллельно.</target>
        </trans-unit>
        <trans-unit id="a25d6360214ab107cc5a2690ac6934209de0713e" translate="yes" xml:space="preserve">
          <source>A set of arguments to a function with inout parameters is considered a match if any inout argument types match exactly, or:</source>
          <target state="translated">Набор аргументов для функции с параметрами inout считается совпадающим,если точно совпадают какие-либо типы аргументов inout,или:</target>
        </trans-unit>
        <trans-unit id="51c642f510697a8d846cbe239c05d6e7f4bd433c" translate="yes" xml:space="preserve">
          <source>A set of functions in this module that do the substitution rely on a simple format to guide the process. In particular the table below applies to the &lt;code&gt;format&lt;/code&gt; argument of &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Набор функций в этом модуле, которые выполняют замену, основаны на простом формате для управления процессом. В частности, приведенная ниже таблица относится к аргументу &lt;code&gt;format&lt;/code&gt; &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8a9cfe24fb306eb618c433658da1dfff7fbe905" translate="yes" xml:space="preserve">
          <source>A shell command which is passed verbatim to the command interpreter. (See &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Команда оболочки, которая дословно передается интерпретатору команд. (Подробности смотрите в &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="e6e6e41467f1af8066889b7eb3e8cd2ba5db578e" translate="yes" xml:space="preserve">
          <source>A shorthand for creating a custom multi-level fixed Trie from a &lt;code&gt;CodepointSet&lt;/code&gt;. &lt;code&gt;sizes&lt;/code&gt; are numbers of bits per level, with the most significant bits used first.</source>
          <target state="translated">Сокращение для создания пользовательского многоуровневого фиксированного Trie из &lt;code&gt;CodepointSet&lt;/code&gt; . &lt;code&gt;sizes&lt;/code&gt; - это количество бит на уровень, причем наиболее значимые биты используются первыми.</target>
        </trans-unit>
        <trans-unit id="872a8839a08b7a547700d02979804255ca5dda79" translate="yes" xml:space="preserve">
          <source>A signed integer representing the unix time which is equivalent to the given std time.</source>
          <target state="translated">Подписанное целое число,представляющее unix-время,эквивалентное заданному std-времени.</target>
        </trans-unit>
        <trans-unit id="f860d4a0b4e17f8f9f5a52ee6fbbcb2156c9580b" translate="yes" xml:space="preserve">
          <source>A signed integer representing the unix time which is equivalent to this SysTime.</source>
          <target state="translated">Подписанное целое число,представляющее unix-время,эквивалентное данному SysTime.</target>
        </trans-unit>
        <trans-unit id="3616b970c3c6ad571e4bcd0ec81882f1b115ec64" translate="yes" xml:space="preserve">
          <source>A simple file cache that can be used to avoid reading the same file multiple times. It stores its cached files as &lt;a href=&quot;#FileAndLines&quot;&gt;&lt;code&gt;FileAndLines&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Простой файловый кеш, который можно использовать, чтобы избежать чтения одного и того же файла несколько раз. Он хранит свои кэшированные файлы как &lt;a href=&quot;#FileAndLines&quot;&gt; &lt;code&gt;FileAndLines&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="baa475621014a28514997e0b8ab31fb33db431d4" translate="yes" xml:space="preserve">
          <source>A simple generic copy template would be:</source>
          <target state="translated">Простой общий шаблон для копирования:</target>
        </trans-unit>
        <trans-unit id="20b05a6cb1c672b9ef624b2ff448b0500b9047e8" translate="yes" xml:space="preserve">
          <source>A simple property would be:</source>
          <target state="translated">Простым свойством было бы:</target>
        </trans-unit>
        <trans-unit id="ba136270dcb78a01ac01f425897459708ac2204d" translate="yes" xml:space="preserve">
          <source>A simple wrapper around core.demangle.</source>
          <target state="translated">Простая обертка вокруг сердечника.Разворота.</target>
        </trans-unit>
        <trans-unit id="be6731f2a1c9e7c94bf4c940a35e7396dbfee3d9" translate="yes" xml:space="preserve">
          <source>A single entry point to lookup Unicode &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; sets by name or alias of a block, script or general category.</source>
          <target state="translated">Одна точка входа для поиска &lt;a href=&quot;#Code%20point&quot;&gt;кодовой точки&lt;/a&gt; Unicode устанавливается по имени или псевдониму блока, сценария или общей категории.</target>
        </trans-unit>
        <trans-unit id="76e7dd95e4c66490806ddffd8fa0a91f032d99f2" translate="yes" xml:space="preserve">
          <source>A single file or directory inside the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf119b60a03b0cf9e7805eb2d90dcc3f4a2c95dd" translate="yes" xml:space="preserve">
          <source>A single parameter callable object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c7939d70d47eaa74b95a0d35217792acd405a3" translate="yes" xml:space="preserve">
          <source>A single random element drawn from the &lt;code&gt;range&lt;/code&gt;. If it can, it will return a &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;range element&lt;/code&gt;, otherwise it will return a copy.</source>
          <target state="translated">Один случайный элемент взят из &lt;code&gt;range&lt;/code&gt; . Если это возможно, он вернет &lt;code&gt;ref&lt;/code&gt; на &lt;code&gt;range element&lt;/code&gt; , в противном случае он вернет копию.</target>
        </trans-unit>
        <trans-unit id="660d1f6310c0c87621e9a54e4b08dfcdf5729188" translate="yes" xml:space="preserve">
          <source>A single random variate drawn from the uniform distribution between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, whose type is the common type of these parameters</source>
          <target state="translated">Одна случайная переменная, взятая из равномерного распределения между &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , тип которой является общим типом этих параметров</target>
        </trans-unit>
        <trans-unit id="0634725ae5a0e7183bfefc294b400ab01233d7f2" translate="yes" xml:space="preserve">
          <source>A single regular expression to match.</source>
          <target state="translated">Одно регулярное выражение,чтобы соответствовать.</target>
        </trans-unit>
        <trans-unit id="ec5a41e95c545f5b9ca17c3cce34db77407a6c8d" translate="yes" xml:space="preserve">
          <source>A single unsigned integer seed value, different on each successive call</source>
          <target state="translated">Одно беззнаковое целое значение семян,различное при каждом последующем вызове.</target>
        </trans-unit>
        <trans-unit id="ae4b3bcc6e1cb3e9d2d9a6f88f30cf7fd585afe6" translate="yes" xml:space="preserve">
          <source>A singleton instance of the default random number generator</source>
          <target state="translated">Однокнопочный экземпляр генератора случайных чисел по умолчанию</target>
        </trans-unit>
        <trans-unit id="0ef9bc9017937bc2cb5ef8d012679f4242838bf7" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt; or &quot;.&quot;.</source>
          <target state="translated">Кусочек &lt;code&gt;path&lt;/code&gt; или &quot;.&quot;</target>
        </trans-unit>
        <trans-unit id="3a9ec084aa800e4c6f173bd5a1b32479212bf70d" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt; or &lt;code&gt;&quot;.&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211be94b802431a091e4438f74d6d8da155125ad" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt; that is the drive, or an empty range if the drive is not specified. In the case of UNC paths, the network share is returned.  Always returns an empty range on POSIX.</source>
          <target state="translated">Кусочек &lt;code&gt;path&lt;/code&gt; которым является диск, или пустой диапазон, если диск не указан. В случае путей UNC возвращается сетевой ресурс. Всегда возвращает пустой диапазон в POSIX.</target>
        </trans-unit>
        <trans-unit id="beac62a1b583a4886c9c1be497e5c0b0348e7cd1" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Ломтик &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a44a0058f9c93fc07954a765d5c3b256792c20e" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;r1&lt;/code&gt; which contains the characters that both ranges start with, if the first argument is a string; otherwise, the same as the result of &lt;code&gt;takeExactly(r1, n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of elements in the common prefix of both ranges.</source>
          <target state="translated">Срез &lt;code&gt;r1&lt;/code&gt; , который содержит символы, с которых начинаются оба диапазона, если первый аргумент является строкой; в противном случае совпадает с результатом выполнения &lt;code&gt;takeExactly(r1, n)&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - количество элементов в общем префиксе обоих диапазонов.</target>
        </trans-unit>
        <trans-unit id="0ffe788b4fb95a6848324f21f66531a09b889ad4" translate="yes" xml:space="preserve">
          <source>A slice of path without the drive component.</source>
          <target state="translated">Кусок пути без компонента привода.</target>
        </trans-unit>
        <trans-unit id="581b3b4f0e3112a50b079afa9d9199402f78b5ce" translate="yes" xml:space="preserve">
          <source>A slightly more general tool for building fixed &lt;code&gt;Trie&lt;/code&gt; for the Unicode data.</source>
          <target state="translated">Немного более общий инструмент для построения фиксированного &lt;code&gt;Trie&lt;/code&gt; для данных Unicode.</target>
        </trans-unit>
        <trans-unit id="4cd1ce7d77a0e891a7fba5fd7dfff37943999a7f" translate="yes" xml:space="preserve">
          <source>A slot is implemented as a delegate. The slot_t is the type of the delegate. The delegate must be to an instance of a class or an interface to a class instance. Delegates to struct instances or nested functions must not be used as slots.</source>
          <target state="translated">Слот реализуется в качестве делегата.Слот_t является типом делегата.Делегат должен быть на экземпляр класса или на интерфейс к экземпляру класса.Делегаты для структурирования экземпляров или вложенных функций не должны использоваться в качестве слотов.</target>
        </trans-unit>
        <trans-unit id="d89edff631bacdade5c431ac87b9ac60108881dd" translate="yes" xml:space="preserve">
          <source>A sockaddr_in as obtained from lower-level API calls such as getifaddrs.</source>
          <target state="translated">Sockaddr_in,полученный из вызовов API нижнего уровня,таких как getifaddrs.</target>
        </trans-unit>
        <trans-unit id="7d42edca23e3ad2a39e5d64109da0bfd2ccec746" translate="yes" xml:space="preserve">
          <source>A sockaddr_in6 as obtained from lower-level API calls such as getifaddrs.</source>
          <target state="translated">Sockaddr_in6,полученный из вызовов API нижнего уровня,таких как getifaddrs.</target>
        </trans-unit>
        <trans-unit id="6ea4d279c0d7e6e01846c33d4b612f74d42c15cf" translate="yes" xml:space="preserve">
          <source>A sockaddr_un as obtained from lower-level API calls.</source>
          <target state="translated">Sockaddr_un,полученный из вызовов API нижнего уровня.</target>
        </trans-unit>
        <trans-unit id="ebed80eb86233fab6e2b5379562de9775ffe2e21" translate="yes" xml:space="preserve">
          <source>A span of text wrapped in asterisks (&lt;code&gt;*&lt;/code&gt;) is emphasized, and text wrapped in two asterisks (&lt;code&gt;**&lt;/code&gt;) is strongly emphasized:</source>
          <target state="translated">Подчеркнута область текста, заключенная в звездочки ( &lt;code&gt;*&lt;/code&gt; ), и текст, завернутый в две звездочки ( &lt;code&gt;**&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="4762ac489724656b1a0c7c273b89622b35dd42e5" translate="yes" xml:space="preserve">
          <source>A static array &lt;code&gt;T[dim]&lt;/code&gt; can be implicitly converted to one of the following:</source>
          <target state="translated">Статический массив &lt;code&gt;T[dim]&lt;/code&gt; может быть неявно преобразован в одно из следующих:</target>
        </trans-unit>
        <trans-unit id="503b1cd5041c9f832a5dfa476e07423ac07fe21d" translate="yes" xml:space="preserve">
          <source>A static array constructed from &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Статический массив строится из . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0814137d88654413926aef08cf4c06c48470220f" translate="yes" xml:space="preserve">
          <source>A static array is safe when all its elements are safe. Regardless of the element type, a static array with length zero is always safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a546994264658c0bb6793fa47d07dceb84796aa" translate="yes" xml:space="preserve">
          <source>A static array with a dimension of 0 is allowed, but no space is allocated for it.</source>
          <target state="translated">Допускается статический массив с размером 0,но для него не выделяется место.</target>
        </trans-unit>
        <trans-unit id="de32ec56a437a2e8fee8b3e9fa249fed676ffd41" translate="yes" xml:space="preserve">
          <source>A static array, say &lt;code&gt;x&lt;/code&gt;, of a derived class can be implicitly converted to a static array, say &lt;code&gt;y&lt;/code&gt;, of a base class iff elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are qualified as being either both &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;both&lt;/code&gt;&lt;code&gt;immutable&lt;/code&gt; or both mutable (neither &lt;code&gt;const&lt;/code&gt; nor &lt;code&gt;immutable&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba99ac5c994db50a264f1a8103a1072e41e4bd6" translate="yes" xml:space="preserve">
          <source>A static constructor is a function that performs initializations of thread local data before the &lt;code&gt;main()&lt;/code&gt; function gets control for the main thread, and upon thread startup.</source>
          <target state="translated">Статический конструктор - это функция, которая выполняет инициализацию локальных данных потока до того, как функция &lt;code&gt;main()&lt;/code&gt; получит контроль над основным потоком, и при запуске потока.</target>
        </trans-unit>
        <trans-unit id="55ddf0925f26b59946dae28233d6fdfaaa7329f1" translate="yes" xml:space="preserve">
          <source>A static destructor gets called on thread termination, but only if the static constructor completed successfully. Static destructors have empty parameter lists. Static destructors get called in the reverse order that the static constructors were called in.</source>
          <target state="translated">Статический деструктор вызывается при завершении потока,но только в случае успешного завершения работы статического конструктора.В статических деструкторах пустые списки параметров.Статические деструкторы вызываются в обратном порядке,в котором вызывались статические конструкторы.</target>
        </trans-unit>
        <trans-unit id="ff247e4fd411c5dd8e2c32f15b27c31dc37dd89a" translate="yes" xml:space="preserve">
          <source>A static destructor is defined as a special static function with the syntax &lt;code&gt;static ~this()&lt;/code&gt;.</source>
          <target state="translated">Статический деструктор определяется как специальная статическая функция с синтаксисом &lt;code&gt;static ~this()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ecc434d7bb77f5309d3cbf4ac6a185cf614e319" translate="yes" xml:space="preserve">
          <source>A static import requires the use of a fully qualified name to reference the module's names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e2d43ef4615d3925e034bec4d4921e1e6d6425" translate="yes" xml:space="preserve">
          <source>A static instance of the expression, typed as &lt;code&gt;Tint32&lt;/code&gt;.</source>
          <target state="translated">Статический экземпляр выражения, типизированный как &lt;code&gt;Tint32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="623eb6b1870318f1b282239673061459e9ddf2ed" translate="yes" xml:space="preserve">
          <source>A string cannot be printed directly. But &lt;code&gt;%.*s&lt;/code&gt; can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b826ff3a676670f0d088e1cd9b512a0238306126" translate="yes" xml:space="preserve">
          <source>A string containing the path given by &lt;code&gt;path&lt;/code&gt;, but where the extension has been set to &lt;code&gt;ext&lt;/code&gt;.</source>
          <target state="translated">Строка, содержащая путь, заданный &lt;code&gt;path&lt;/code&gt; , но в котором расширение было установлено как &lt;code&gt;ext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69c56f08ab57e676746d4e01be6a9cc3952f4ae4" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for dates and times.</source>
          <target state="translated">Строка,отформатированная в расширенном формате ISO для дат и времени.</target>
        </trans-unit>
        <trans-unit id="ef701934bf57ae45596601643b85ee15d3f2485e" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for dates.</source>
          <target state="translated">Строка,отформатированная в расширенном формате ISO для дат.</target>
        </trans-unit>
        <trans-unit id="2da20ec434f95bb8d5443fe8e314ce1623955145" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for times.</source>
          <target state="translated">Строка,отформатированная в расширенном формате ISO для времен.</target>
        </trans-unit>
        <trans-unit id="a00e008e78aea96cbfa32fcdb23e6a8b450b797c" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for dates and times.</source>
          <target state="translated">Строка,отформатированная в формате ISO для дат и времени.</target>
        </trans-unit>
        <trans-unit id="2a3df60399b45643cd31eb34963073f7812833b6" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for dates.</source>
          <target state="translated">Строка,отформатированная в формате ISO для дат.</target>
        </trans-unit>
        <trans-unit id="04939a3353d03734d347b05e3ca2729bd9a9341a" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for times.</source>
          <target state="translated">Строка,отформатированная в формате ISO для времен.</target>
        </trans-unit>
        <trans-unit id="0643f1e9bd52d0a8a25555e18edbd5da7b51bdf5" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that &lt;code&gt;toSimpleString&lt;/code&gt; formats dates and times.</source>
          <target state="translated">Строка, отформатированная таким образом, что &lt;code&gt;toSimpleString&lt;/code&gt; форматирует даты и время.</target>
        </trans-unit>
        <trans-unit id="f962ea73f49b39339b4922f88a0c238e4ba1325d" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that toSimpleString formats dates and times.</source>
          <target state="translated">Строка,отформатированная таким образом,чтобы форматировать даты и время в формате toSimpleString.</target>
        </trans-unit>
        <trans-unit id="632ab3df5f88419d1e31f1d1cee5760bbb59e7a9" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that toSimpleString formats dates.</source>
          <target state="translated">Строка,отформатированная так,чтобы даты форматов toSimpleString.</target>
        </trans-unit>
        <trans-unit id="bd3280dc41aa99bf0618b972c678e1b7727cbc29" translate="yes" xml:space="preserve">
          <source>A string is an array of characters. String literals are just an easy way to write character arrays. String literals are immutable (read only).</source>
          <target state="translated">Строка-это массив символов.Строковые литералы-это простой способ записи массивов символов.Строковые литералы неизменны (только для чтения).</target>
        </trans-unit>
        <trans-unit id="4693492ea4f8cc4f79d65fb1c5fff8fc71f5424c" translate="yes" xml:space="preserve">
          <source>A string listing the name of each JSON field. Useful for errors messages.</source>
          <target state="translated">Строка с именем каждого JSON-поля.Полезно для сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="2dfa7f97ca7b310eefa5e44ed45cbd5a9d6fba44" translate="yes" xml:space="preserve">
          <source>A string literal is either a double quoted string, a wysiwyg quoted string, a delimited string, a token string, or a hex string.</source>
          <target state="translated">Строковый литерал-это либо строка в двойных кавычках,либо wysiwyg в кавычках,либо делимитированная строка,токеновая строка,либо шестнадцатеричная строка.</target>
        </trans-unit>
        <trans-unit id="91c359df16c8f1e8cc04e86239901e547e4069a7" translate="yes" xml:space="preserve">
          <source>A string of the same type as &lt;code&gt;input&lt;/code&gt; with the all of the matches (if any) replaced. If no match is found returns the input string itself.</source>
          <target state="translated">Строка того же типа, что и &lt;code&gt;input&lt;/code&gt; , с заменой всех совпадений (если есть). Если совпадение не найдено, возвращает саму входную строку.</target>
        </trans-unit>
        <trans-unit id="e2e9744762303d84756cc38d0bb797a1dfb35ea5" translate="yes" xml:space="preserve">
          <source>A string of the same type with the first match (if any) replaced. If no match is found returns the input string itself.</source>
          <target state="translated">Строка того же типа с заменой первого совпадения (если таковое имеется).Если совпадение не найдено,возвращается сама входная строка.</target>
        </trans-unit>
        <trans-unit id="e3572bd9c75fcb62fc2a06156321d1044ce974ae" translate="yes" xml:space="preserve">
          <source>A string or a callable</source>
          <target state="translated">Строка или вызываемый</target>
        </trans-unit>
        <trans-unit id="ade01e08f23d876345b07c46538697febd10cde1" translate="yes" xml:space="preserve">
          <source>A string to be mixed in to an aggregate, such as a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">Строка, которая будет смешана с агрегатом, таким как &lt;code&gt;struct&lt;/code&gt; или &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d73e7649de9a0fce40f5dced1b091b66c878d3f" translate="yes" xml:space="preserve">
          <source>A struct can be prevented from being nested by using the static attribute, but then of course it will not be able to access variables from its enclosing scope.</source>
          <target state="translated">Можно предотвратить вложение структуры с помощью статического атрибута,но тогда,конечно,она не сможет получить доступ к переменным из своей вложенной области видимости.</target>
        </trans-unit>
        <trans-unit id="1f09ef100c2ee69f17128a0533548f020c5d9e4c" translate="yes" xml:space="preserve">
          <source>A struct constructor is called by the name of the struct followed by &lt;a href=&quot;class#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Конструктор структуры вызывается именем структуры, за которой следуют &lt;a href=&quot;class#Parameters&quot;&gt;&lt;i&gt;параметры&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b3db8fb5df89c3340030fb9089c4116c935599b" translate="yes" xml:space="preserve">
          <source>A struct constructor is called by the name of the struct followed by &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e185de50d62e9d91d5d52f4d70129a74a374a6" translate="yes" xml:space="preserve">
          <source>A struct declaration can have a storage class of &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;shared&lt;/code&gt;. It has an equivalent effect as declaring each member of the struct as &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">Объявление структуры может иметь класс хранения &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; или &lt;code&gt;shared&lt;/code&gt; . Это имеет эквивалентный эффект, поскольку объявление каждого члена структуры &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; или &lt;code&gt;shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e4f169c05b38809d1d31f76423e59d52a2b4315" translate="yes" xml:space="preserve">
          <source>A struct is defined to not have an identity; that is, the implementation is free to make bit copies of the struct as convenient.</source>
          <target state="translated">Структура определяется как не имеющая идентичности,т.е.реализация свободна для того,чтобы сделать битовые копии структуры как удобные.</target>
        </trans-unit>
        <trans-unit id="9bc9847f25ea362b6740a9b93ab804ef00434940" translate="yes" xml:space="preserve">
          <source>A struct literal. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt; is repeated &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times.</source>
          <target state="translated">Структурный литерал. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Значение&lt;/i&gt;&lt;/a&gt; повторяется &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Количество&lt;/i&gt;&lt;/a&gt; раз.</target>
        </trans-unit>
        <trans-unit id="286be268efaafbe7332e602d9baab19f8148f3ca" translate="yes" xml:space="preserve">
          <source>A struct or union is</source>
          <target state="translated">Структура или союз</target>
        </trans-unit>
        <trans-unit id="306c597a82d5ab4af2135e10c7b985f1b617d325" translate="yes" xml:space="preserve">
          <source>A struct representing an arbitrary precision integer.</source>
          <target state="translated">Структура,представляющая собой произвольное целое число точности.</target>
        </trans-unit>
        <trans-unit id="526765a5620c1404cef412a5aba1cb550dfea2fe" translate="yes" xml:space="preserve">
          <source>A struct with a disabled default constructor, and no other constructors, cannot be instantiated other than via a &lt;a href=&quot;declaration#VoidInitializer&quot;&gt;&lt;i&gt;VoidInitializer&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Структуру с отключенным конструктором по умолчанию и без других конструкторов нельзя создать, кроме как через &lt;a href=&quot;declaration#VoidInitializer&quot;&gt;&lt;i&gt;VoidInitializer&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d49622ffefc7c0f82f7205f52dcf576517ae460" translate="yes" xml:space="preserve">
          <source>A struct/union instance is safe when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cac3ef6b0f178c3af52d9fad3a48b33c922f31" translate="yes" xml:space="preserve">
          <source>A structure designed to effectively pack &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; of a &lt;a href=&quot;#Grapheme%20cluster&quot;&gt;grapheme cluster&lt;/a&gt;.</source>
          <target state="translated">Структура предназначена для эффективной упаковки &lt;a href=&quot;#Character&quot;&gt;символов&lt;/a&gt; из более &lt;a href=&quot;#Grapheme%20cluster&quot;&gt;графем кластера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dee43ab463ff81471969585aaeb25d27e17a8d5" translate="yes" xml:space="preserve">
          <source>A sub-type of &lt;code&gt;Tuple!()&lt;/code&gt; of the split portions of &lt;code&gt;haystack&lt;/code&gt; (see above for details). This sub-type of &lt;code&gt;Tuple!()&lt;/code&gt; has &lt;code&gt;opCast&lt;/code&gt; defined for &lt;code&gt;bool&lt;/code&gt;. This &lt;code&gt;opCast&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when the separating &lt;code&gt;needle&lt;/code&gt; was found and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Суб-тип &lt;code&gt;Tuple!()&lt;/code&gt; Из расщепленных участков &lt;code&gt;haystack&lt;/code&gt; (см выше для деталей). Этот подтип &lt;code&gt;Tuple!()&lt;/code&gt; Имеет &lt;code&gt;opCast&lt;/code&gt; , определенный для &lt;code&gt;bool&lt;/code&gt; . Этот &lt;code&gt;opCast&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , когда разделительная &lt;code&gt;needle&lt;/code&gt; была найдена, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="8ceb760806d127d92222223abf19d6e9a9a642d1" translate="yes" xml:space="preserve">
          <source>A subset of flags supported on all platforms with getaddrinfo. Specifies option flags for &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">Подмножество флагов поддерживается на всех платформах с помощью getaddrinfo. Определяет флажки параметров для &lt;code&gt;getAddressInfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fdcf48534cbb5ac5ca95f825a7e9b13b6291b8b" translate="yes" xml:space="preserve">
          <source>A switch statement goes to one of a collection of case statements depending on the value of the switch expression.</source>
          <target state="translated">Оператор переключателя переходит в один из сборников операторов регистра в зависимости от значения выражения переключателя.</target>
        </trans-unit>
        <trans-unit id="8d52ce29a153bfcaed221e76bcfa3b8652e6334d" translate="yes" xml:space="preserve">
          <source>A switch statement must have a default statement.</source>
          <target state="translated">Оператор переключения должен иметь оператор по умолчанию.</target>
        </trans-unit>
        <trans-unit id="243f938b3c97b4e1d8eadd9d338c92b666235144" translate="yes" xml:space="preserve">
          <source>A symbol can be declared as an</source>
          <target state="translated">Символ может быть объявлен как</target>
        </trans-unit>
        <trans-unit id="84b715dd42cb515250f3406c66517dd9d7115450" translate="yes" xml:space="preserve">
          <source>A table in the database is locked</source>
          <target state="translated">Таблица в БД заблокирована</target>
        </trans-unit>
        <trans-unit id="34955ed2643e3acedc24870a54a36ec54c1a46f3" translate="yes" xml:space="preserve">
          <source>A tagged class reference uses the bits known to be zero in a normal class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there.</source>
          <target state="translated">Ссылка на класс с меткой использует биты,известные как ноль в обычной ссылке на класс для хранения дополнительной информации.Например,указатель на целое число должен быть выровнен на 4 байта,так что есть 2 бита,которые всегда известны как ноль.Там можно хранить 2-битное целое число.</target>
        </trans-unit>
        <trans-unit id="bec6ca0b9e854ba9b4dc6eeb575b3e2cf1fbdc8a" translate="yes" xml:space="preserve">
          <source>A tagged pointer uses the bits known to be zero in a normal pointer or class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there.</source>
          <target state="translated">Указатель с меткой использует биты,известные как ноль в обычном указателе или ссылке на класс для хранения дополнительной информации.Например,указатель на целое число должен быть выровнен на 4 байта,так что есть 2 бита,которые всегда известны как ноль.Там можно хранить 2-битное целое число.</target>
        </trans-unit>
        <trans-unit id="71dbdba1f186a3e3df4f62b2ce30433dcfeb9ff8" translate="yes" xml:space="preserve">
          <source>A template instance that requires IFTI: foo!tiargs(fargs) // foo!tiargs is left until CallExp::semantic() or resolveProperties()</source>
          <target state="translated">Экземпляр шаблона,который требует IFTI:foo!tiargs(fargs)//foo!tiargs остаётся до CallExp::semantic()или resolveProperties().</target>
        </trans-unit>
        <trans-unit id="c487a2a162f74902ff60920af22e2df0fcc4fd2b" translate="yes" xml:space="preserve">
          <source>A template instantiation can be aliased:</source>
          <target state="translated">Шаблон может иметь псевдонимы:</target>
        </trans-unit>
        <trans-unit id="5ec9a1a961c15a72835c9d805bb9f5cb8a6a13d6" translate="yes" xml:space="preserve">
          <source>A templated &lt;code&gt;struct&lt;/code&gt; can become a nested &lt;code&gt;struct&lt;/code&gt; if it is instantiated with a local symbol passed as an aliased argument:</source>
          <target state="translated">Шаблонная &lt;code&gt;struct&lt;/code&gt; может стать вложенной &lt;code&gt;struct&lt;/code&gt; если она создается с помощью локального символа, передаваемого в качестве аргумента с псевдонимом:</target>
        </trans-unit>
        <trans-unit id="286beb1ed5435d657d4bd322969e6d1bee678996" translate="yes" xml:space="preserve">
          <source>A text file of macro definitions can be created, and specified in &lt;code&gt;sc.ini&lt;/code&gt;:</source>
          <target state="translated">Текстовый файл с определениями макросов может быть создан и указан в &lt;code&gt;sc.ini&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a2c74bdd28417e72ddc700c54f50c8aefa1946fb" translate="yes" xml:space="preserve">
          <source>A textual representation of the email status</source>
          <target state="translated">Текстовое представление статуса электронной почты</target>
        </trans-unit>
        <trans-unit id="635a851773d8480d1d8ecc449412eec073d321df" translate="yes" xml:space="preserve">
          <source>A tuple consisting of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y = f(x)&lt;/code&gt; and &lt;code&gt;error = 3 * (absTolerance * fabs(x) + relTolerance)&lt;/code&gt;.  The method used is a combination of golden section search and successive parabolic interpolation. Convergence is never much slower than that for a Fibonacci search.</source>
          <target state="translated">Кортеж, состоящий из &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y = f(x)&lt;/code&gt; и &lt;code&gt;error = 3 * (absTolerance * fabs(x) + relTolerance)&lt;/code&gt; . Используемый метод представляет собой комбинацию поиска золотого сечения и последовательной параболической интерполяции. Конвергенция никогда не бывает намного медленнее, чем для поиска Фибоначчи.</target>
        </trans-unit>
        <trans-unit id="4ef0df844df69a5568d48b91fa199dcc9de56bc7" translate="yes" xml:space="preserve">
          <source>A tuple consisting of two ranges. The first two elements are the range (in &lt;code&gt;x&lt;/code&gt;) of the root, while the second pair of elements are the corresponding function values at those points. If an exact root was found, both of the first two elements will contain the root, and the second pair of elements will be 0.</source>
          <target state="translated">Кортеж, состоящий из двух диапазонов. Первые два элемента - это диапазон (в &lt;code&gt;x&lt;/code&gt; ) корня, а вторая пара элементов - это соответствующие значения функций в этих точках. Если точный корень был найден, оба из первых двух элементов будут содержать корень, а вторая пара элементов будет 0.</target>
        </trans-unit>
        <trans-unit id="6012f9e438732b6c8c1f1bc9808a6995a46a0ce0" translate="yes" xml:space="preserve">
          <source>A tuple containing &lt;code&gt;haystack&lt;/code&gt; positioned to match one of the needles and also the 1-based index of the matching element in &lt;code&gt;needles&lt;/code&gt; (0 if none of &lt;code&gt;needles&lt;/code&gt; matched, 1 if &lt;code&gt;needles[0]&lt;/code&gt; matched, 2 if &lt;code&gt;needles[1]&lt;/code&gt; matched...). The first needle to be found will be the one that matches. If multiple needles are found at the same spot in the range, then the shortest one is the one which matches (if multiple needles of the same length are found at the same spot (e.g &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;'a'&lt;/code&gt;), then the left-most of them in the argument list matches).  The relationship between &lt;code&gt;haystack&lt;/code&gt; and &lt;code&gt;needles&lt;/code&gt; simply means that one can e.g. search for individual &lt;code&gt;int&lt;/code&gt;s or arrays of &lt;code&gt;int&lt;/code&gt;s in an array of &lt;code&gt;int&lt;/code&gt;s. In addition, if elements are individually comparable, searches of heterogeneous types are allowed as well: a &lt;code&gt;double[]&lt;/code&gt; can be searched for an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;short[]&lt;/code&gt;, and conversely a &lt;code&gt;long&lt;/code&gt; can be searched for a &lt;code&gt;float&lt;/code&gt; or a &lt;code&gt;double[]&lt;/code&gt;. This makes for efficient searches without the need to coerce one side of the comparison into the other's side type.  The complexity of the search is &amp;Omicron;(&lt;code&gt;haystack.length * max(needles.length)&lt;/code&gt;). (For needles that are individual items, length is considered to be 1.) The strategy used in searching several subranges at once maximizes cache usage by moving in &lt;code&gt;haystack&lt;/code&gt; as few times as possible.</source>
          <target state="translated">Кортеж, содержащий &lt;code&gt;haystack&lt;/code&gt; расположенный в соответствии с одной из игл, а также индекс на основе 1 соответствующего элемента в &lt;code&gt;needles&lt;/code&gt; (0, если ни одна из &lt;code&gt;needles&lt;/code&gt; соответствует, 1, если &lt;code&gt;needles[0]&lt;/code&gt; , 2, если &lt;code&gt;needles[1]&lt;/code&gt; соответствуют ... ). Первая найденная игла будет той, которая соответствует. Если в одной и той же точке диапазона находятся несколько игл, то самая короткая совпадает (если в одной и той же точке находятся несколько игл одинаковой длины (например, &lt;code&gt;&quot;a&quot;&lt;/code&gt; и &lt;code&gt;'a'&lt;/code&gt; ), то слева большинство из них в списке аргументов совпадают). Отношения между &lt;code&gt;haystack&lt;/code&gt; и &lt;code&gt;needles&lt;/code&gt; просто означает, что можно, например, искать отдельные &lt;code&gt;int&lt;/code&gt; или массивы &lt;code&gt;int&lt;/code&gt; s в массиве &lt;code&gt;int&lt;/code&gt; s. Кроме того, если элементы сопоставимы по отдельности, поиск гетерогенных типов также возможен: для &lt;code&gt;double[]&lt;/code&gt; можно искать &lt;code&gt;int&lt;/code&gt; или для &lt;code&gt;short[]&lt;/code&gt; , и наоборот, для &lt;code&gt;long&lt;/code&gt; можно искать &lt;code&gt;float&lt;/code&gt; или &lt;code&gt;double[]&lt;/code&gt; . Это обеспечивает эффективный поиск без необходимости приводить одну сторону сравнения к типу другой стороны. Сложность поиска составляет &amp;Omicron; ( &lt;code&gt;haystack.length * max(needles.length)&lt;/code&gt; ). (Для игл, которые являются отдельными предметами, длина считается равной 1.) Стратегия, используемая при поиске сразу нескольких поддиапазонов, максимизирует использование кэша, перемещая &lt;code&gt;haystack&lt;/code&gt; как можно меньше раз.</target>
        </trans-unit>
        <trans-unit id="ded0856f6fc1b75ce8ecf0a9f7b88274ab801b0f" translate="yes" xml:space="preserve">
          <source>A tuple of ParameterStorageClass bits</source>
          <target state="translated">Кортеж битов ParameterStorageClass</target>
        </trans-unit>
        <trans-unit id="fd35c428724dd8619e23fbf0f2a7e57058b4f08d" translate="yes" xml:space="preserve">
          <source>A tuple with &lt;code&gt;isMutable&lt;/code&gt; and &lt;code&gt;isNotShared&lt;/code&gt; set if the &lt;code&gt;lhsMod&lt;/code&gt; is missing those modifiers (compared to rhs).</source>
          <target state="translated">Кортеж с &lt;code&gt;isMutable&lt;/code&gt; и &lt;code&gt;isNotShared&lt;/code&gt; установлен, если в &lt;code&gt;lhsMod&lt;/code&gt; отсутствуют эти модификаторы (по сравнению с rhs).</target>
        </trans-unit>
        <trans-unit id="925ba630a3a1ee356b2d095a9d23d602a9a88f92" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;S&lt;/code&gt; gets compiler-generated &lt;code&gt;opAssign&lt;/code&gt; if it has an elaborate destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f68985da3ea589273931016f24036b553a5f0d" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;S&lt;/code&gt; gets compiler-generated &lt;code&gt;opAssign&lt;/code&gt; in case it has an elaborate copy constructor or elaborate destructor.</source>
          <target state="translated">Тип &lt;code&gt;S&lt;/code&gt; получает сгенерированный компилятором &lt;code&gt;opAssign&lt;/code&gt; в случае, если он имеет сложный конструктор копирования или сложный деструктор.</target>
        </trans-unit>
        <trans-unit id="c2925ba28f3ef4457063b11b5313b546bc942531" translate="yes" xml:space="preserve">
          <source>A type called StaticClassXXXX which defines all the static members.</source>
          <target state="translated">Тип под названием StaticClassXXXX,который определяет все статические члены.</target>
        </trans-unit>
        <trans-unit id="4bafd715c2d842fc48782a23197830301ac6594f" translate="yes" xml:space="preserve">
          <source>A typesafe structure for storing combinations of enum values.</source>
          <target state="translated">Типовая безопасная структура для хранения комбинаций значений перечисления.</target>
        </trans-unit>
        <trans-unit id="19bbabc23db1d89e38664a27a9f383fa929906e5" translate="yes" xml:space="preserve">
          <source>A typical use-case is to perform lazy but thread-safe initialization.</source>
          <target state="translated">Типичным случаем использования является выполнение ленивой,но потокобезопасной инициализации.</target>
        </trans-unit>
        <trans-unit id="1108e01a71348662d4697940c03ca612a789d5db" translate="yes" xml:space="preserve">
          <source>A typical workaround would be to use array vector operations instead:</source>
          <target state="translated">Типичным обходным решением было бы использование векторных операций с массивами:</target>
        </trans-unit>
        <trans-unit id="622333820bdb5ef06fbb318f56dcf3f6445745f2" translate="yes" xml:space="preserve">
          <source>A unique hash of the &lt;code&gt;BigInt&lt;/code&gt;'s value suitable for use in a hash table.</source>
          <target state="translated">Уникальный хеш значения &lt;code&gt;BigInt&lt;/code&gt; , подходящий для использования в хеш-таблице.</target>
        </trans-unit>
        <trans-unit id="2198d4c146bec18fd1ce6760a109cc4921cdd05d" translate="yes" xml:space="preserve">
          <source>A unit test for a function should appear immediately following it.</source>
          <target state="translated">Сразу после этого должна появиться единичная проверка функции.</target>
        </trans-unit>
        <trans-unit id="8a517fa6a3c0c868fd6ae7e933059bd47b7df17a" translate="yes" xml:space="preserve">
          <source>A unittest may be attributed with any of the global function attributes. Such unittests are useful in verifying the given attribute(s) on a template function:</source>
          <target state="translated">Юниттест может быть присвоен любому из атрибутов глобальной функции.Такие юниттесты полезны при проверке данного атрибута(ов)на шаблонной функции:</target>
        </trans-unit>
        <trans-unit id="7ae21aa22fe7948e4c729f1540b79f8cd693afe8" translate="yes" xml:space="preserve">
          <source>A unittest which is not documented, or is marked as private will not be used to generate code samples.</source>
          <target state="translated">Юниттест,который не документирован или помечен как приватный,не будет использоваться для генерации примеров кода.</target>
        </trans-unit>
        <trans-unit id="9c1c04f676b35796be10ffb3edecc8f6268e7b22" translate="yes" xml:space="preserve">
          <source>A useful and popular use of algebraic data structures is for defining &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=self-referential%20data%20structures&quot;&gt;self-referential data structures&lt;/a&gt;, i.e. structures that embed references to values of their own type within.  This is achieved with &lt;code&gt;Algebraic&lt;/code&gt; by using &lt;code&gt;This&lt;/code&gt; as a placeholder whenever a reference to the type being defined is needed. The &lt;code&gt;Algebraic&lt;/code&gt; instantiation will perform &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_resolution_(programming_languages)#Alpha_renaming_to_make_name_resolution_trivial&quot;&gt;alpha renaming&lt;/a&gt; on its constituent types, replacing &lt;code&gt;This&lt;/code&gt; with the self-referenced type. The structure of the type involving &lt;code&gt;This&lt;/code&gt; may be arbitrarily complex.</source>
          <target state="translated">Полезное и популярное использование алгебраических структур данных - для определения &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=self-referential%20data%20structures&quot;&gt;структур данных со&lt;/a&gt; ссылками на себя, то есть структур, которые встраивают ссылки на значения своего собственного типа внутри. Это достигается с помощью &lt;code&gt;Algebraic&lt;/code&gt; алгоритма с использованием &lt;code&gt;This&lt;/code&gt; в качестве заполнителя всякий раз, когда требуется ссылка на определяемый тип. &lt;code&gt;Algebraic&lt;/code&gt; Инстанциация будет выполнять &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_resolution_(programming_languages)#Alpha_renaming_to_make_name_resolution_trivial&quot;&gt;альфа - переименование&lt;/a&gt; на его типах составляющие, заменив &lt;code&gt;This&lt;/code&gt; с самостоятельной привязкой типа. Структура типа с участием &lt;code&gt;This&lt;/code&gt; может быть сколь угодно сложным.</target>
        </trans-unit>
        <trans-unit id="5cd31092f50e6668ec7962d66b14d97f0b254db8" translate="yes" xml:space="preserve">
          <source>A useful technique for Unicode-aware parsers that perform character classification of encoded &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; is to avoid unnecassary decoding at all costs. &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; provides an improvement over the usual workflow of decode-classify-process, combining the decoding and classification steps. By extracting necessary bits directly from encoded &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt; matchers achieve significant performance improvements. See &lt;a href=&quot;#MatcherConcept&quot;&gt;&lt;code&gt;MatcherConcept&lt;/code&gt;&lt;/a&gt; for the common interface of UTF matchers.</source>
          <target state="translated">Полезный метод для анализаторов с поддержкой Unicode, которые выполняют классификацию символов кодированных &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек,&lt;/a&gt; состоит в том, чтобы любой ценой избежать ненужного декодирования. &lt;a href=&quot;#utfMatcher&quot;&gt; &lt;code&gt;utfMatcher&lt;/code&gt; &lt;/a&gt; обеспечивает улучшение по сравнению с обычным рабочим процессом decode-classify-process, объединяя шаги декодирования и классификации. Извлекая необходимые биты непосредственно из кодированных &lt;a href=&quot;#Code%20unit&quot;&gt;единиц кода,&lt;/a&gt; сопоставители достигают значительного улучшения производительности. Смотрите &lt;a href=&quot;#MatcherConcept&quot;&gt; &lt;code&gt;MatcherConcept&lt;/code&gt; &lt;/a&gt; для общего интерфейса UTF-сопоставителей.</target>
        </trans-unit>
        <trans-unit id="9e9a2a2de1ba1fef47986aeaad29546ee2f0c629" translate="yes" xml:space="preserve">
          <source>A user-defined attribute looks like:</source>
          <target state="translated">Похоже на пользовательский атрибут:</target>
        </trans-unit>
        <trans-unit id="6ec4f05c1da31924f6c46c6e8eceeade66257fb8" translate="yes" xml:space="preserve">
          <source>A user-defined one can implement the equivalent semantics, but can be more efficient.</source>
          <target state="translated">Пользователь может реализовать эквивалентную семантику,но может быть более эффективным.</target>
        </trans-unit>
        <trans-unit id="24ccdd70677c403ccb2a313c4c9c32fa6f8c9c76" translate="yes" xml:space="preserve">
          <source>A user:password in the URL will be ignored. Unless one is set programmatically, the .netrc will be queried.</source>
          <target state="translated">Пользователь:пароль в URL будет проигнорирован.Если он не установлен программно,будет опрашиваться .netrc.</target>
        </trans-unit>
        <trans-unit id="2c2902f73aa9094938733525713baf7d27f4d32d" translate="yes" xml:space="preserve">
          <source>A user:password in the URL will be preferred to one in the .netrc.</source>
          <target state="translated">Пользователь:пароль в URL будет предпочтительнее пароля в .netrc.</target>
        </trans-unit>
        <trans-unit id="bfd68567162b198b169e63ff6f9ce0abafc592a1" translate="yes" xml:space="preserve">
          <source>A value from &lt;code&gt;input&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Значение из &lt;code&gt;input&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fab34a840eca5f0af3a6adfab162743b8b96ab0f" translate="yes" xml:space="preserve">
          <source>A value of 1 means that no alignment is done; fields are packed together.</source>
          <target state="translated">Значение 1 означает,что выравнивание не выполняется;поля упаковываются вместе.</target>
        </trans-unit>
        <trans-unit id="0f087658ff6dd881c1c276fc1abe86c63c82fce4" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;T&lt;/code&gt; для присвоения этому &lt;code&gt;Nullable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92fc64d8ff9ab394a43cf1989c0c0f6d5f276117" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;Nullable&lt;/code&gt;. If it is &lt;code&gt;nullvalue&lt;/code&gt;, then the internal state of this &lt;code&gt;Nullable&lt;/code&gt; will be set to null.</source>
          <target state="translated">Значение типа &lt;code&gt;T&lt;/code&gt; для присвоения этому &lt;code&gt;Nullable&lt;/code&gt; . Если это &lt;code&gt;nullvalue&lt;/code&gt; , то внутреннее состояние этого &lt;code&gt;Nullable&lt;/code&gt; будет установлено в нуль.</target>
        </trans-unit>
        <trans-unit id="595ffc8e3de776e07c75f9495e539287bfe40f7d" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;NullableRef&lt;/code&gt;. If the internal state of this &lt;code&gt;NullableRef&lt;/code&gt; has not been initialized, an error will be thrown in non-release mode.</source>
          <target state="translated">Значение типа &lt;code&gt;T&lt;/code&gt; для присвоения этому &lt;code&gt;NullableRef&lt;/code&gt; . Если внутреннее состояние этого &lt;code&gt;NullableRef&lt;/code&gt; не было инициализировано, в режиме не выпуска будет сгенерирована ошибка.</target>
        </trans-unit>
        <trans-unit id="0312bacf411c0359c567722d8da661969980e011" translate="yes" xml:space="preserve">
          <source>A variable storing the number of digits of the factorial number stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="translated">Переменная, хранящая количество цифр факториального номера, хранящегося в &lt;code&gt;fac&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1288e9434e2f0aa83f354b220fc3320a00da2bf3" translate="yes" xml:space="preserve">
          <source>A variadic array of &lt;code&gt;Statement&lt;/code&gt;s, that will copied in this class The entries themselves will not be copied.</source>
          <target state="translated">VARIADIC массив &lt;code&gt;Statement&lt;/code&gt; s, который будет скопирован в этом классе записи сами по себе не будет скопирована.</target>
        </trans-unit>
        <trans-unit id="f46908d75fb188ea17f0c418cfb5fce0d59b00a5" translate="yes" xml:space="preserve">
          <source>A variant on interfaces is the COM interface. A COM interface is designed to map directly onto a Windows COM object. Any COM object can be represented by a COM interface, and any D object with a COM interface can be used by external COM clients.</source>
          <target state="translated">Вариантом на интерфейсах является COM-интерфейс.СОМ-интерфейс предназначен для нанесения карты непосредственно на COM-объект Windows.Любой COM-объект может быть представлен COM-интерфейсом,а любой D-объект с COM-интерфейсом может быть использован внешними COM-клиентами.</target>
        </trans-unit>
        <trans-unit id="74bc7034954daf05645c8bdf69b200a66acd5b8d" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; that instead of allocating a new string on each call outputs the result piece-wise to the &lt;code&gt;sink&lt;/code&gt;. In particular this enables efficient construction of a final output incrementally.</source>
          <target state="translated">Вариант &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; ,&lt;/a&gt; который вместо выделения новой строки при каждом вызове выводит результат по частям в &lt;code&gt;sink&lt;/code&gt; . В частности, это позволяет эффективно создавать конечный результат постепенно.</target>
        </trans-unit>
        <trans-unit id="558bf167836891063033473ff39e29c40f76a6ae" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; that instead of allocating a new string on each call outputs the result piece-wise to the &lt;code&gt;sink&lt;/code&gt;. In particular this enables efficient construction of a final output incrementally.</source>
          <target state="translated">Вариант &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; ,&lt;/a&gt; который вместо выделения новой строки при каждом вызове выводит результат по частям в &lt;code&gt;sink&lt;/code&gt; . В частности, это позволяет эффективно создавать конечный результат постепенно.</target>
        </trans-unit>
        <trans-unit id="fd2627bfee6415d1e46fb27e196853613a72b036" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; that runs the given command through the current user's preferred command interpreter (aka. shell).</source>
          <target state="translated">Вариант &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; ,&lt;/a&gt; который запускает данную команду через предпочтительный интерпретатор команд текущего пользователя (он же оболочка).</target>
        </trans-unit>
        <trans-unit id="06c25ac99fc939d88ae07ec02cd1e2eaea8adf25" translate="yes" xml:space="preserve">
          <source>A vector operation is indicated by the slice operator appearing as the left-hand side of an assignment or an op-assignment expression. The right-hand side can be an expression consisting either of an array slice of the same length and type as the left-hand side or a scalar expression of the element type of the left-hand side, in any combination.</source>
          <target state="translated">Векторная операция обозначается оператором среза,который появляется в левой части выражения присваивания или оп-назначения.Правая сторона может быть выражением,состоящим либо из среза массива той же длины и типа,что и левая сторона,либо из скалярного выражения типа элемента левой стороны,в любой комбинации.</target>
        </trans-unit>
        <trans-unit id="0201e0884279f412eec70152c95bca634cabe90f" translate="yes" xml:space="preserve">
          <source>A version condition is of the form:</source>
          <target state="translated">Условие версии-форма:</target>
        </trans-unit>
        <trans-unit id="036b91c045d7afd669b86e632efdeb65cf70fbe8" translate="yes" xml:space="preserve">
          <source>A version of &lt;a href=&quot;#Appender&quot;&gt;&lt;code&gt;Appender&lt;/code&gt;&lt;/a&gt; that can update an array in-place. It forwards all calls to an underlying appender implementation. Any calls made to the appender also update the pointer to the original array passed in.</source>
          <target state="translated">Версия &lt;a href=&quot;#Appender&quot;&gt; &lt;code&gt;Appender&lt;/code&gt; ,&lt;/a&gt; которая может обновлять массив на месте. Он перенаправляет все вызовы в базовую реализацию приложения. Любые вызовы, сделанные к appender, также обновляют указатель на переданный исходный массив.</target>
        </trans-unit>
        <trans-unit id="0f69ae09b687c0f70931e5d637c3720fd96bc47f" translate="yes" xml:space="preserve">
          <source>A very important attribute of the Unicode Normalization Forms is that they must remain stable between versions of the Unicode Standard. A Unicode string normalized to a particular Unicode Normalization Form in one version of the standard is guaranteed to remain in that Normalization Form for implementations of future versions of the standard.</source>
          <target state="translated">Очень важным атрибутом форм нормализации Юникода является то,что они должны оставаться стабильными между версиями стандарта Юникод.Строка Юникода,нормализованная к определённой Форме Нормализации Юникода в одной из версий стандарта,гарантированно останется в этой Форме Нормализации для реализации будущих версий стандарта.</target>
        </trans-unit>
        <trans-unit id="204a1d9da8aeb4ccbb41074798c36ae598e785cb" translate="yes" xml:space="preserve">
          <source>A visitor to walk entire statements and provides ability to replace any sub-statements.</source>
          <target state="translated">Посетитель может выгуливать целые высказывания и предоставляет возможность заменить любые подзадания.</target>
        </trans-unit>
        <trans-unit id="ecda6fbd787080a0c71eaf580a2379d0a84fd558" translate="yes" xml:space="preserve">
          <source>A way to construct optimal packed multi-stage tables also known as a special case of &lt;a href=&quot;https://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;. The functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; construct custom tries that map dchar to value. The end result is a fast and predictable &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) lookup that powers functions like &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt;, but for user-defined data sets.</source>
          <target state="translated">Способ построения оптимально упакованных многоступенчатых таблиц, также известный как особый случай &lt;a href=&quot;https://en.wikipedia.org/wiki/Trie&quot;&gt;Три&lt;/a&gt; . Функции &lt;a href=&quot;#codepointTrie&quot;&gt; &lt;code&gt;codepointTrie&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#codepointSetTrie&quot;&gt; &lt;code&gt;codepointSetTrie&lt;/code&gt; создают&lt;/a&gt; пользовательские попытки, которые сопоставляют значение dchar со значением. Конечный результат - быстрый и предсказуемый поиск ( &lt;code&gt;1&lt;/code&gt; ), который обеспечивает функции, такие как &lt;a href=&quot;#isAlpha&quot;&gt; &lt;code&gt;isAlpha&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#combiningClass&quot;&gt; &lt;code&gt;combiningClass&lt;/code&gt; &lt;/a&gt; , но для пользовательских наборов данных.</target>
        </trans-unit>
        <trans-unit id="179d3c78fdb472871d26dca4bbdeaf8b134c8648" translate="yes" xml:space="preserve">
          <source>A word-aligned buffer of &lt;code&gt;n&lt;/code&gt; bytes, or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Выровненный по словам буфер из &lt;code&gt;n&lt;/code&gt; байтов или &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5bda91bd2eb64cc9ebd789e00ffee28462db953" translate="yes" xml:space="preserve">
          <source>A wrapper &lt;code&gt;struct&lt;/code&gt; that preserves the range interface of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; оболочки, которая сохраняет интерфейс диапазона &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d29ec600e62a50d3d9eec98dae8f8d3e051f7de3" translate="yes" xml:space="preserve">
          <source>A wrapper around a list of allocators which allow for very fast deallocations.</source>
          <target state="translated">Обертка вокруг списка распределителей,которые позволяют очень быстро разобраться.</target>
        </trans-unit>
        <trans-unit id="15c2c153bb71919b5cdec457823f4fd9f8d71bf9" translate="yes" xml:space="preserve">
          <source>A wrapper for whatever the main thread would have done in the absence of a custom scheduler. It will be automatically executed via a call to spawn by the Scheduler.</source>
          <target state="translated">Обертка для всего,что основной поток сделал бы при отсутствии пользовательского планировщика.Она будет автоматически выполнена по вызову планировщика.</target>
        </trans-unit>
        <trans-unit id="66b2f8e9850db5c9a0ef26a091089e2397efa6e8" translate="yes" xml:space="preserve">
          <source>A wrapper on top of the built-in cast operator that allows one to restrict casting of the original type of the value.</source>
          <target state="translated">Обертка поверх встроенного оператора литья,которая позволяет ограничить литье исходного типа значения.</target>
        </trans-unit>
        <trans-unit id="d26b628f187d45bc4e12de9cc9385d4c6d2e0a9b" translate="yes" xml:space="preserve">
          <source>A writer sub-mutex.</source>
          <target state="translated">Писательский суб-мутекс.</target>
        </trans-unit>
        <trans-unit id="74f058625ae51d7f9a4f0234f03e7d2e3133d478" translate="yes" xml:space="preserve">
          <source>A zero was generated by underflow</source>
          <target state="translated">Ноль был сгенерирован недопотоком</target>
        </trans-unit>
        <trans-unit id="ce3098487e1cd9f75cd7cad95483a4b4deb5588e" translate="yes" xml:space="preserve">
          <source>A* &lt;code&gt;arr&lt;/code&gt;</source>
          <target state="translated">A * &lt;code&gt;arr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a30240d9b1407524e8eee853f1720d4610565ce4" translate="yes" xml:space="preserve">
          <source>AA &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="translated">AA &lt;code&gt;aa&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c631f781a8d0368d8a6ea89a0fbce4e43bfbaa" translate="yes" xml:space="preserve">
          <source>AA version for debuggers, bump whenever changing the layout</source>
          <target state="translated">AA версия для отладчиков,удар при изменении макета</target>
        </trans-unit>
        <trans-unit id="3e563eabeb4bf3cec4d1e28f9fcc377ee1ff90bd" translate="yes" xml:space="preserve">
          <source>AA* &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="translated">АА * &lt;code&gt;aa&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="feebbf826eefee82f4e7df8a0dfb7c29775241f0" translate="yes" xml:space="preserve">
          <source>ABI tag is an attribute introduced by the GNU C++ compiler. It modifies the mangled name of the symbol to incorporate the tag name, in order to distinguish from an earlier version with a different ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ab529de7da6070afe29cdd8345d68a47ee6fbe" translate="yes" xml:space="preserve">
          <source>AMD Athlon (K7, K8, K10).</source>
          <target state="translated">AMD Athlon (K7,K8,K10).</target>
        </trans-unit>
        <trans-unit id="624f7573dca9fe5ebe0a6858283e1c5d9432014a" translate="yes" xml:space="preserve">
          <source>AMD Opcodes</source>
          <target state="translated">AMD Опкоды</target>
        </trans-unit>
        <trans-unit id="039721a06435401a74bdd364a8f46ca9309e70c2" translate="yes" xml:space="preserve">
          <source>AMD Opcodes Supported</source>
          <target state="translated">Поддерживаемые опкоды AMD</target>
        </trans-unit>
        <trans-unit id="4ca0a1dafaea5e84f002eb1c3a7a92dd033b7a8c" translate="yes" xml:space="preserve">
          <source>APIs</source>
          <target state="translated">APIs</target>
        </trans-unit>
        <trans-unit id="6b6bf129e90e87f19aebb266c7797207c07f48fe" translate="yes" xml:space="preserve">
          <source>ARM in Thumb mode; use &lt;code&gt;ARM_Thumb&lt;/code&gt; instead</source>
          <target state="translated">ARM в режиме большого пальца; используйте вместо этого &lt;code&gt;ARM_Thumb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb1fdcfffd40402c89d0d4bb3b0d681220235dda" translate="yes" xml:space="preserve">
          <source>ARM in any Thumb mode</source>
          <target state="translated">ARM в любом режиме большого пальца</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="d63aa0860f8ef36562ad0b514274ba63a3eacd6b" translate="yes" xml:space="preserve">
          <source>ASCII (strictly, 7-bit ASCII)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89174118a4a495c66300fbe7239a480764509b25" translate="yes" xml:space="preserve">
          <source>ASCII i string to capitalize</source>
          <target state="translated">ASCII i строка для капитализации</target>
        </trans-unit>
        <trans-unit id="0f7fc546df38aeee4d77978d5dcfbe350f0e2747" translate="yes" xml:space="preserve">
          <source>ASCII whitespace</source>
          <target state="translated">ASCII пробел</target>
        </trans-unit>
        <trans-unit id="9ef82a5dc44fd8e8e212aabe32c11cac57294938" translate="yes" xml:space="preserve">
          <source>ASCII-only</source>
          <target state="translated">ASCII-only</target>
        </trans-unit>
        <trans-unit id="6fc55697bc9a0a7e365add2e6ecfcd149e10701c" translate="yes" xml:space="preserve">
          <source>ASCII_Hex_Digit</source>
          <target state="translated">ASCII_Hex_Digit</target>
        </trans-unit>
        <trans-unit id="a579237e1f01010812c214ab27a5b3beb489ff76" translate="yes" xml:space="preserve">
          <source>AST node for &lt;code&gt;EnumDeclaration&lt;/code&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#EnumDeclaration&quot;&gt;https://dlang.org/spec/enum.html#EnumDeclaration&lt;/a&gt;</source>
          <target state="translated">Узел AST для &lt;code&gt;EnumDeclaration&lt;/code&gt; &lt;a href=&quot;https://dlang.org/spec/enum.html#EnumDeclaration&quot;&gt;https://dlang.org/spec/enum.html#EnumDeclaration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2e1a886f972c32fded02bd26e8e6b865f2eb255" translate="yes" xml:space="preserve">
          <source>AST node representing a member of an enum. &lt;a href=&quot;https://dlang.org/spec/enum.html#EnumMember&quot;&gt;https://dlang.org/spec/enum.html#EnumMember&lt;/a&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#AnonymousEnumMember&quot;&gt;https://dlang.org/spec/enum.html#AnonymousEnumMember&lt;/a&gt;</source>
          <target state="translated">Узел AST, представляющий член перечисления. &lt;a href=&quot;https://dlang.org/spec/enum.html#EnumMember&quot;&gt;https://dlang.org/spec/enum.html#EnumMember &lt;/a&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#AnonymousEnumMember&quot;&gt;https://dlang.org/spec/enum.html#AnonymousEnumMember&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4856a925a6f71d775d2a2dd67176ae2d0a9e9f77" translate="yes" xml:space="preserve">
          <source>AST.Expression &lt;strong id=&quot;parsePrimaryExp&quot;&gt;parsePrimaryExp&lt;/strong&gt;();</source>
          <target state="translated">AST.Expression &lt;strong id=&quot;parsePrimaryExp&quot;&gt;parsePrimaryExp&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="c3fec866346bd5e2dcb25d972f5a97367df05503" translate="yes" xml:space="preserve">
          <source>AST.Statement &lt;strong id=&quot;parseStatement&quot;&gt;parseStatement&lt;/strong&gt;(int flags, const(char)** endPtr = null, Loc* pEndloc = null);</source>
          <target state="translated">AST.Statement &lt;strong id=&quot;parseStatement&quot;&gt;parseStatement&lt;/strong&gt; (int flags, const (char) ** endPtr = null, Loc * pEndloc = null);</target>
        </trans-unit>
        <trans-unit id="debca9f07fb54076426713e9f9bdcd3e1e056b0e" translate="yes" xml:space="preserve">
          <source>AVX Vector instructions are supported</source>
          <target state="translated">Поддерживаются инструкции AVX Vector</target>
        </trans-unit>
        <trans-unit id="44a916ba2993444e910670ef65cccc667bfc068f" translate="yes" xml:space="preserve">
          <source>AVX2 Vector instructions are supported</source>
          <target state="translated">Поддерживаются векторные инструкции AVX2</target>
        </trans-unit>
        <trans-unit id="fc32691eed408bcffd208331061395fcb95f2539" translate="yes" xml:space="preserve">
          <source>Abb.</source>
          <target state="translated">Abb.</target>
        </trans-unit>
        <trans-unit id="d87c8562414047004383cefab06dde994ab29260" translate="yes" xml:space="preserve">
          <source>Abort due to constraint violation</source>
          <target state="translated">Отмена из-за нарушения ограничений</target>
        </trans-unit>
        <trans-unit id="28ef1e43dd92ae02027dd18a6bebb7e635d80224" translate="yes" xml:space="preserve">
          <source>Abort the SQL statement with an error</source>
          <target state="translated">Прервать SQL-оператор с ошибкой</target>
        </trans-unit>
        <trans-unit id="14230c93975c238bf7c790d700013262220823e1" translate="yes" xml:space="preserve">
          <source>Abort the send and return.</source>
          <target state="translated">Отмените отправку и возвращайтесь.</target>
        </trans-unit>
        <trans-unit id="aa41dd8e948e2dab26d97077811c4859daf44a19" translate="yes" xml:space="preserve">
          <source>Above, &lt;code&gt;Foo!().foo&lt;/code&gt; will work just the same as a member function of class &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;Bar!().bar&lt;/code&gt; will work just the same as a nested function within function &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">Выше &lt;code&gt;Foo!().foo&lt;/code&gt; будет работать точно так же, как функция-член класса &lt;code&gt;C&lt;/code&gt; , а &lt;code&gt;Bar!().bar&lt;/code&gt; будет работать так же, как вложенная функция внутри функции &lt;code&gt;main()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72be1abc9c41f18cb036851d094c7e5ee1691674" translate="yes" xml:space="preserve">
          <source>Absolute tolerance.</source>
          <target state="translated">Абсолютная терпимость.</target>
        </trans-unit>
        <trans-unit id="5065cb3ac6b52ca94db622cc45ddec46996ff941" translate="yes" xml:space="preserve">
          <source>Abstract base class for XML items</source>
          <target state="translated">Абстрактный базовый класс для элементов XML</target>
        </trans-unit>
        <trans-unit id="fa5896f602b41f6e737833e94bdb9dfbf32d9f47" translate="yes" xml:space="preserve">
          <source>Abstract base class of all encoding schemes</source>
          <target state="translated">Абстрактный базовый класс всех схем кодирования</target>
        </trans-unit>
        <trans-unit id="fd71c6586a6fb20a005525c1ab9479acf96f2316" translate="yes" xml:space="preserve">
          <source>Abstract characters not directly encoded by the Unicode Standard can often be represented by the use of combining character sequences.</source>
          <target state="translated">Абстрактные символы,непосредственно не закодированные стандартом Юникод,часто могут быть представлены с использованием комбинации последовательностей символов.</target>
        </trans-unit>
        <trans-unit id="c9ce51b5c3d269c08cea6f74d4b2f5fd2e587775" translate="yes" xml:space="preserve">
          <source>Accept an incoming connection. If the socket is blocking, &lt;code&gt;accept&lt;/code&gt; waits for a connection request. Throws &lt;code&gt;SocketAcceptException&lt;/code&gt; if unable to accept. See &lt;code&gt;accepting&lt;/code&gt; for use with derived classes.</source>
          <target state="translated">Принять входящее соединение. Если сокет блокируется, &lt;code&gt;accept&lt;/code&gt; ожидает запроса на соединение. Выдает &lt;code&gt;SocketAcceptException&lt;/code&gt; если не удается принять. Смотрите &lt;code&gt;accepting&lt;/code&gt; для использования с производными классами.</target>
        </trans-unit>
        <trans-unit id="3697222ce3b5ee0c832014446956a71a9e3f9768" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;, &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, and &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">Допустимые единицы измерения: &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; , &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; и &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4354a6713d7ad0caea954c67b888e32cf0474a8" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">Допустимые единицы измерения: &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; и &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fe93e8eee53666f950c9ca80808bfeb7d041149" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">Допустимые единицы измерения: &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; и &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2757cba57a7420e39d1261498e6488dd5ac45155" translate="yes" xml:space="preserve">
          <source>Accepts a path to either a file or a directory. In the former case, the basepath (path to the containing directory) will be checked for existence, and created if it does not exists. In the later case, the directory pointed to will be checked for existence and created if needed.</source>
          <target state="translated">Принимает путь к файлу или каталогу.В первом случае базовый путь (путь к содержащемуся каталогу)будет проверен на существование и создан,если его нет.В последнем случае указанная директория будет проверена на существование и при необходимости создана.</target>
        </trans-unit>
        <trans-unit id="baa49dd84c2f97d1400c5b886e7457901cafa944" translate="yes" xml:space="preserve">
          <source>Access C++ std::type_info's virtual functions from D, being careful to not require linking with libstd++ or interfere with core.stdcpp.typeinfo. So, give it a different name.</source>
          <target state="translated">Обращайтесь к виртуальным функциям C++std::type_info из D,не требуя линковки с libstd++и не вмешиваясь в работу core.stdcpp.typeinfo.Поэтому дайте ему другое имя.</target>
        </trans-unit>
        <trans-unit id="8cee105dc9286540eb8273e1a66712fc79c398e3" translate="yes" xml:space="preserve">
          <source>Access Control</source>
          <target state="translated">Контроль доступа</target>
        </trans-unit>
        <trans-unit id="c1777ced1e09bfb3a20d75e96ad2f4ce23f4f24f" translate="yes" xml:space="preserve">
          <source>Access labels AA from C++ code.</source>
          <target state="translated">Метки доступа AA из C++кода.</target>
        </trans-unit>
        <trans-unit id="cf0ad5ada4db8ecde7f83bac072e7c784cdc3f1f" translate="yes" xml:space="preserve">
          <source>Access permission denied</source>
          <target state="translated">Разрешение на доступ запрещено</target>
        </trans-unit>
        <trans-unit id="bee6f9fa537ba79f8b898add7fb4d8af609c3d99" translate="yes" xml:space="preserve">
          <source>Access the members of the object e. This type is same as e.type.</source>
          <target state="translated">Доступ к членам объекта e.Этот тип такой же,как и e.type.</target>
        </trans-unit>
        <trans-unit id="dd91024887ec34e3b4d4c550ead58d4e228f98e0" translate="yes" xml:space="preserve">
          <source>Access to a large selection of commonly used sets of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. &lt;a href=&quot;#Unicode%20properties&quot;&gt;Supported sets&lt;/a&gt; include Script, Block and General Category. The exact contents of a set can be observed in the CLDR utility, on the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;property index&lt;/a&gt; page of the Unicode website. See &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; for easy and (optionally) compile-time checked set queries.</source>
          <target state="translated">Доступ к большому выбору часто используемых наборов &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек&lt;/a&gt; . &lt;a href=&quot;#Unicode%20properties&quot;&gt;Поддерживаемые наборы&lt;/a&gt; включают Script, Block и General Category. Точное содержание набора можно увидеть в утилите CLDR на странице &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;индекса свойств&lt;/a&gt; веб-сайта Unicode. См. &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; для простых и (опционально) проверенных наборов запросов во время компиляции.</target>
        </trans-unit>
        <trans-unit id="7f2d0eae88d66a5fc766687a84f6f7f91d5ae27d" translate="yes" xml:space="preserve">
          <source>Access to class members is controlled using &lt;a href=&quot;attribute#visibility_attributes&quot;&gt; visibility attributes&lt;/a&gt;. The default visibility attribute is &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">Доступ к членам класса контролируется с помощью &lt;a href=&quot;attribute#visibility_attributes&quot;&gt;атрибутов видимости&lt;/a&gt; . Атрибут видимости по умолчанию является &lt;code&gt;public&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="307fc632b58de82a174b55210d8d42a94693e17a" translate="yes" xml:space="preserve">
          <source>Access to variadic arguments is done using the standard library module &lt;code&gt;core.stdc.stdarg&lt;/code&gt;.</source>
          <target state="translated">Доступ к переменным аргументам осуществляется с помощью стандартного библиотечного модуля &lt;code&gt;core.stdc.stdarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f1467ab57ce45967443e18135c914da7e45a13" translate="yes" xml:space="preserve">
          <source>Accessing C Globals</source>
          <target state="translated">Доступ к C Шаров</target>
        </trans-unit>
        <trans-unit id="beb23fe078814adbeacefa1f1f2dfb764f4b3413" translate="yes" xml:space="preserve">
          <source>Accessing Individual Vector Elements</source>
          <target state="translated">Доступ к отдельным векторным элементам</target>
        </trans-unit>
        <trans-unit id="db7fc46962b3e4858cae12b974315033c117901c" translate="yes" xml:space="preserve">
          <source>Accessing variable v. Check for purity and safety violations. Returns true if error occurs.</source>
          <target state="translated">Доступ к переменной v.Проверка чистоты и безопасности.Возвращает true в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="9beb96dac88f56752e0ce800d691ef1a92595d9b" translate="yes" xml:space="preserve">
          <source>Acknowledge</source>
          <target state="translated">Acknowledge</target>
        </trans-unit>
        <trans-unit id="36258baa389d65025807ea4f13eda18ad0dd4bd8" translate="yes" xml:space="preserve">
          <source>Acquire + release barrier. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;LLVM AtomicOrdering.AcquireRelease&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_acq_rel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d47f537dcb350bf669800548ceb300b34426ee2" translate="yes" xml:space="preserve">
          <source>Acquires a read lock on the enclosing mutex.</source>
          <target state="translated">Приобретает считывающий замок на мутексном ограждении.</target>
        </trans-unit>
        <trans-unit id="99ed81fec0ff177b818b848aa967a2dc6a60b509" translate="yes" xml:space="preserve">
          <source>Acquires a write lock on the enclosing mutex.</source>
          <target state="translated">Приобретает замок для записи на вложенный мьютекс.</target>
        </trans-unit>
        <trans-unit id="34be5c3351b113f2cad4cc4a8602e9f1303b4543" translate="yes" xml:space="preserve">
          <source>Adam D. Ruppe</source>
          <target state="translated">Адам Д.Руппе</target>
        </trans-unit>
        <trans-unit id="6e9e257be9ac18996821b962c7a49ec73c7aba38" translate="yes" xml:space="preserve">
          <source>Adapted with minimal changes from the work of David L. Davis (refer to the &lt;a href=&quot;http://forum.dlang.org/post/cfk7ql&amp;amp;dollar;1p4n&amp;amp;dollar;1@digitaldaemon.com&quot;&gt;original announcement&lt;/a&gt;).</source>
          <target state="translated">Адаптировано с минимальными изменениями от работы Дэвида Л. Дэвиса (см. &lt;a href=&quot;http://forum.dlang.org/post/cfk7ql&amp;amp;dollar;1p4n&amp;amp;dollar;1@digitaldaemon.com&quot;&gt;Оригинальное объявление&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c5a3264f3bad4a3d08e2dbdc79dc6adf56d9043" translate="yes" xml:space="preserve">
          <source>Add Content To A Dynamic String</source>
          <target state="translated">Добавить содержимое к динамической строке</target>
        </trans-unit>
        <trans-unit id="783f29b92ccf3cb30aa2e12d525b1971eef1ba41" translate="yes" xml:space="preserve">
          <source>Add Expressions</source>
          <target state="translated">Добавить выражения</target>
        </trans-unit>
        <trans-unit id="1a1ad0f8b610189b63e4cb0f7b4aed4a9b1d3a61" translate="yes" xml:space="preserve">
          <source>Add MODxxxx bits to existing type. We're adding, not replacing, so adding const to a shared type =&amp;gt; &quot;shared const&quot;</source>
          <target state="translated">Добавьте биты MODxxxx к существующему типу. Мы добавляем, а не заменяем, поэтому добавляем const к общему типу =&amp;gt; &quot;shared const&quot;</target>
        </trans-unit>
        <trans-unit id="2f6598ae97b68f3c9b2eca03bcb16039c37701f3" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Socket&lt;/code&gt; to the collection. The socket must not already be in the collection.</source>
          <target state="translated">Добавьте &lt;code&gt;Socket&lt;/code&gt; в коллекцию. Сокет не должен быть уже в коллекции.</target>
        </trans-unit>
        <trans-unit id="cf47751bc3702034406ec509e784f3ea1eb6200d" translate="yes" xml:space="preserve">
          <source>Add a command to send to ftp server.</source>
          <target state="translated">Добавить команду для отправки на ftp-сервер.</target>
        </trans-unit>
        <trans-unit id="e665ffb3cdd40a1e58b3bf5dfd0804b5aaf86432" translate="yes" xml:space="preserve">
          <source>Add a header e.g. &quot;X-CustomField: Something is fishy&quot;.</source>
          <target state="translated">Добавьте заголовок,например,&quot;X-CustomField&quot;:Что-то рыбное&quot;.</target>
        </trans-unit>
        <trans-unit id="9dca982f55af4b03415ddfb96425312211cac1c4" translate="yes" xml:space="preserve">
          <source>Add a member to the archive. The file is compressed on the fly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b93c9a5ae048bb45d10d62122638eca633993f" translate="yes" xml:space="preserve">
          <source>Add a slot to the list of slots to be called when emit() is called.</source>
          <target state="translated">Добавьте слот в список слотов,которые будут вызываться при вызове функции emit().</target>
        </trans-unit>
        <trans-unit id="58e96b8b192b5161f00d42ec478ec85a678ec3b1" translate="yes" xml:space="preserve">
          <source>Add an IP group membership</source>
          <target state="translated">Добавить членство в IP-группе</target>
        </trans-unit>
        <trans-unit id="eaee2d4a639caa6d286ce081d0fec7d81fdd68aa" translate="yes" xml:space="preserve">
          <source>Add an interval [a, b) to this set.</source>
          <target state="translated">Добавьте к этому набору интервал [a,b].</target>
        </trans-unit>
        <trans-unit id="d58f391b6636a37e4ed4aadaddc8bc0a051e9638" translate="yes" xml:space="preserve">
          <source>Add an user-supplied global identifier to the list</source>
          <target state="translated">Добавить пользовательский глобальный идентификатор в список</target>
        </trans-unit>
        <trans-unit id="68f594a7d8331d79aa134583b826df0691870790" translate="yes" xml:space="preserve">
          <source>Add an user-supplied identifier to the list of global debug identifiers</source>
          <target state="translated">Добавить пользовательский идентификатор в список глобальных идентификаторов отладки</target>
        </trans-unit>
        <trans-unit id="ff5f9ed6a9198f29682b6e2fdc1784d631624385" translate="yes" xml:space="preserve">
          <source>Add any global identifier to the list, without checking if it's predefined</source>
          <target state="translated">Добавить любой глобальный идентификатор в список,не проверяя,предопределен ли он.</target>
        </trans-unit>
        <trans-unit id="180269a30ba169b4ad5b7a1b7661b30529e56f3a" translate="yes" xml:space="preserve">
          <source>Add de to the archive. The file is compressed on the fly.</source>
          <target state="translated">Добавить де в архив.Файл сжимается на лету.</target>
        </trans-unit>
        <trans-unit id="0795781eaf01631d4376c4aabb0efd2f797184aa" translate="yes" xml:space="preserve">
          <source>Add default &lt;code&gt;version&lt;/code&gt; identifier for dmd, and set the target platform in &lt;code&gt;params&lt;/code&gt;. &lt;a href=&quot;https://dlang.org/spec/version.html#predefined-versions&quot;&gt;https://dlang.org/spec/version.html#predefined-versions&lt;/a&gt;</source>
          <target state="translated">Добавьте идентификатор &lt;code&gt;version&lt;/code&gt; умолчанию для dmd и установите целевую платформу в &lt;code&gt;params&lt;/code&gt; . &lt;a href=&quot;https://dlang.org/spec/version.html#predefined-versions&quot;&gt;https://dlang.org/spec/version.html#predefined-versions&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c84400b54e58a4517104843b16d7336ce756b1a0" translate="yes" xml:space="preserve">
          <source>Add documentation comment to Dsymbol. Ignore NULL comments.</source>
          <target state="translated">Добавить комментарий к документации в Dsymbol.Игнорировать NULL комментарии.</target>
        </trans-unit>
        <trans-unit id="b821ad6b597b9aa864b5401ed9295cf33f19f5bb" translate="yes" xml:space="preserve">
          <source>Add empty fields for padding to have a total bit length of 8, 16, 32, or 64</source>
          <target state="translated">Добавить пустые поля для подкладки,чтобы общая длина битов 8,16,32 или 64</target>
        </trans-unit>
        <trans-unit id="27e8affa9a2779909d012a0a9e565d5d9c4930bc" translate="yes" xml:space="preserve">
          <source>Add expressions for floating point operands are not associative.</source>
          <target state="translated">Выражения добавления для операндов с плавающей точкой не являются ассоциативными.</target>
        </trans-unit>
        <trans-unit id="39654cee35d80be4140c48c2f4acb0a4d3eddad1" translate="yes" xml:space="preserve">
          <source>Add import path to the &lt;code&gt;global.path&lt;/code&gt;.</source>
          <target state="translated">Добавьте путь импорта в &lt;code&gt;global.path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca0c9e82595b2ff7d12c349025925ae8755eaf0" translate="yes" xml:space="preserve">
          <source>Add import to sd's symbol table.</source>
          <target state="translated">Добавить импорт в таблицу символов sd.</target>
        </trans-unit>
        <trans-unit id="da23c7c2b4b6933ac5908203dac9c52485b7b4dd" translate="yes" xml:space="preserve">
          <source>Add instance ti to TemplateDeclaration's table of instances. Return a handle we can use to later remove it if it fails instantiation.</source>
          <target state="translated">Добавьте экземпляр ti в таблицу экземпляров TemplateDeclaration.Возвращает дескриптор,который мы можем использовать для последующего удаления в случае неудачи инстанцирования.</target>
        </trans-unit>
        <trans-unit id="4d414082ffd854e8335dc0549b71c84435addf66" translate="yes" xml:space="preserve">
          <source>Add or get a file from the file cache. If the file isn't part of the cache, it will be read from the filesystem. If the file has been read before, the cached file object will be returned</source>
          <target state="translated">Добавить или получить файл из файлового кэша.Если файл не является частью кэша,он будет считан из файловой системы.Если файл был прочитан ранее,то кэшированный объект файла будет возвращен</target>
        </trans-unit>
        <trans-unit id="a520040bdffe08f3eefdcecf7998ef8840dd4783" translate="yes" xml:space="preserve">
          <source>Add storage class modifiers to type.</source>
          <target state="translated">Добавить модификаторы класса хранения к типу.</target>
        </trans-unit>
        <trans-unit id="0dc5179d5d1626885bf2c954280bebcdbc0811f9" translate="yes" xml:space="preserve">
          <source>Add string import path to &lt;code&gt;global.filePath&lt;/code&gt;.</source>
          <target state="translated">Добавить путь импорта строки в &lt;code&gt;global.filePath&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37089788442ff881d462af2da489fd68f0412cb3" translate="yes" xml:space="preserve">
          <source>Add t to the list of tracked threads if it is not already being tracked.</source>
          <target state="translated">Добавьте t в список отслеживаемых потоков,если он еще не отслеживается.</target>
        </trans-unit>
        <trans-unit id="a88d5dd379a53bc3a2adc9fd4af43267e851bf42" translate="yes" xml:space="preserve">
          <source>Add the extension &lt;code&gt;ext&lt;/code&gt; to &lt;code&gt;name&lt;/code&gt;, regardless of the content of &lt;code&gt;name&lt;/code&gt;</source>
          <target state="translated">Добавьте расширение &lt;code&gt;ext&lt;/code&gt; к &lt;code&gt;name&lt;/code&gt; , независимо от содержимого &lt;code&gt;name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52a02a5e1fb93d0d15ea7fa0332d56723a1247a4" translate="yes" xml:space="preserve">
          <source>Add to precision as necessary so that the first digit of the octal formatting is a '0', even if both the argument and the</source>
          <target state="translated">При необходимости добавьте к точности так,чтобы первая цифра восьмеричного форматирования была '0',даже если и аргумент и</target>
        </trans-unit>
        <trans-unit id="66d00d03ee0d2653e725dd73702a2661d7a02c6b" translate="yes" xml:space="preserve">
          <source>Add two signed integers, checking for overflow.</source>
          <target state="translated">Добавьте два подписанных целых числа,проверяя на переполнение.</target>
        </trans-unit>
        <trans-unit id="66fdaf8b303799ed2eb7e0bf44cbe2a7bcbf9b7d" translate="yes" xml:space="preserve">
          <source>Add two unsigned integers, checking for overflow (aka carry).</source>
          <target state="translated">Добавьте два беззнаковых числа,проверяя на переполнение (aka carry).</target>
        </trans-unit>
        <trans-unit id="edb4a17762e7e7667165a329429cbc010d27e3c1" translate="yes" xml:space="preserve">
          <source>Add variable to maybes[]. When a maybescope variable &lt;code&gt;v&lt;/code&gt; is assigned to a maybescope variable &lt;code&gt;this&lt;/code&gt;, we cannot determine if &lt;code&gt;this&lt;/code&gt; is actually scope until the semantic analysis for the function is completed. Thus, we save the data until then.</source>
          <target state="translated">Добавьте переменную в maybes []. Когда переменная maybescope &lt;code&gt;v&lt;/code&gt; назначается переменной maybescope &lt;code&gt;this&lt;/code&gt; , мы не можем определить , действительно ли &lt;code&gt;this&lt;/code&gt; является областью действия, пока не будет завершен семантический анализ для функции. Таким образом, мы сохраняем данные до тех пор.</target>
        </trans-unit>
        <trans-unit id="3aaf26753f5eadebbc6849954cfee254c2f15e1d" translate="yes" xml:space="preserve">
          <source>Added Since CV4</source>
          <target state="translated">Добавлено с CV4</target>
        </trans-unit>
        <trans-unit id="a4990b86487a33fe06b07471000a0e208027a17e" translate="yes" xml:space="preserve">
          <source>Added to Bionic since Lollipop.</source>
          <target state="translated">Добавлен в Бионик после Леденцов.</target>
        </trans-unit>
        <trans-unit id="86922b5391f09bc921f8e0e85beb11adcc142c71" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;deallocate&lt;/code&gt; capability to an allocator that lacks it (such as simple regions).</source>
          <target state="translated">Добавление возможности &lt;code&gt;deallocate&lt;/code&gt; для распределителя, в котором он отсутствует (например, для простых областей).</target>
        </trans-unit>
        <trans-unit id="1667d04dd978ce8b93994c5e6826422d13b6b5b0" translate="yes" xml:space="preserve">
          <source>Adding Contracts to Java</source>
          <target state="translated">Добавление контрактов в Java</target>
        </trans-unit>
        <trans-unit id="5d4e406e41eeda4c6401647b660b3cce1ffbd218" translate="yes" xml:space="preserve">
          <source>Adding or subtracting a &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; to/from a MonoTime results in a MonoTime which is adjusted by that amount.</source>
          <target state="translated">Добавление или вычитание &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; к / из MonoTime приводит к MonoTime, который корректируется на эту величину.</target>
        </trans-unit>
        <trans-unit id="5b8df2ffa33c3a92e63907cf222e7bd23c2fa650" translate="yes" xml:space="preserve">
          <source>Adding your own Garbage Collector</source>
          <target state="translated">Добавление собственного сборщика мусора</target>
        </trans-unit>
        <trans-unit id="5d6556acb18b8662a066437c99c4df78f7b12865" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Logger&lt;/code&gt; can be created by creating a new instance of the required &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Дополнительный &lt;code&gt;Logger&lt;/code&gt; можно создать, создав новый экземпляр требуемого &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d317f4f1de7128a0d4cd8fd921eb8e06ea7ebc6" translate="yes" xml:space="preserve">
          <source>Additional environment variables for the child process.</source>
          <target state="translated">Дополнительные переменные окружения для дочернего процесса.</target>
        </trans-unit>
        <trans-unit id="168245e7982df504f3251c14992ea04ceb75d2cc" translate="yes" xml:space="preserve">
          <source>Additional environment variables for the child process. (See &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Дополнительные переменные среды для дочернего процесса. (Подробнее см. &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="e835350d1c68a871d44080439d13025d3be377ee" translate="yes" xml:space="preserve">
          <source>Additionally the following attributes are only valid for non-static member functions:</source>
          <target state="translated">Кроме того,следующие атрибуты действительны только для нестатических функций:</target>
        </trans-unit>
        <trans-unit id="2b561281f4194e9ab383d247564b6fb48d3b460e" translate="yes" xml:space="preserve">
          <source>Additionally, archives are checked for malware attacks and rejected if detected. This includes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f1260010cd19b58b440bfbe6492df580b2aeb8" translate="yes" xml:space="preserve">
          <source>Additionally, this example shows how a new &lt;code&gt;FileLogger&lt;/code&gt; is created. Individual &lt;code&gt;Logger&lt;/code&gt; and the global log functions share commonly named functions to log data.  The names of the functions are as follows:</source>
          <target state="translated">Кроме того, этот пример показывает, как создается новый &lt;code&gt;FileLogger&lt;/code&gt; . Индивидуальный &lt;code&gt;Logger&lt;/code&gt; и глобальные функции журнала совместно используют общие имена для регистрации данных. Имена функций следующие:</target>
        </trans-unit>
        <trans-unit id="5396764fbaed2adc06323b93051d13670b4bd118" translate="yes" xml:space="preserve">
          <source>Address &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a136ff61f84c9c4a7228e88b27550819c0abee84" translate="yes" xml:space="preserve">
          <source>Address &lt;strong id=&quot;address&quot;&gt;address&lt;/strong&gt;;</source>
          <target state="translated">Адресный &lt;strong id=&quot;address&quot;&gt;адрес&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b544b7ba62b9aa270da33d07d9f1852fc51631a7" translate="yes" xml:space="preserve">
          <source>Address containing warnings is considered valid, that is, any status code below 16 is considered valid.</source>
          <target state="translated">Адрес,содержащий предупреждения,считается действительным,т.е.любой код статуса ниже 16 считается действительным.</target>
        </trans-unit>
        <trans-unit id="5a1be6fc1f7f9662fc7c2b17d5434e70a4a8f2ab" translate="yes" xml:space="preserve">
          <source>Address contains Folding White Space</source>
          <target state="translated">Адрес содержит складное белое пространство</target>
        </trans-unit>
        <trans-unit id="887781f145aaaf658d75f1517b0fb398589f6ee9" translate="yes" xml:space="preserve">
          <source>Address contains a carriage return that is not followed by a line feed</source>
          <target state="translated">Адрес содержит возврат каретки,за которым не следует подача строки.</target>
        </trans-unit>
        <trans-unit id="62b80eb5466f5d5ffa1ab6d5b43626ec70a85c2d" translate="yes" xml:space="preserve">
          <source>Address contains a character that is not allowed</source>
          <target state="translated">Адрес содержит недопустимый символ</target>
        </trans-unit>
        <trans-unit id="92528dcc41ae0f2a64e93d533de3ccfed0b942e5" translate="yes" xml:space="preserve">
          <source>Address contains a comment in a position that is deprecated</source>
          <target state="translated">Адрес содержит комментарий в устаревшей позиции</target>
        </trans-unit>
        <trans-unit id="9c918d7b9e49563c6cbad6a857c4705bf794b76c" translate="yes" xml:space="preserve">
          <source>Address contains a comment or Folding White Space around the @ sign</source>
          <target state="translated">Адрес содержит комментарий или складывание белого пространства вокруг знака @.</target>
        </trans-unit>
        <trans-unit id="65380a42fab34c0f4121362666fdd9910ff2d19a" translate="yes" xml:space="preserve">
          <source>Address contains an obsolete form of Folding White Space</source>
          <target state="translated">Адрес содержит устаревшую форму складывания Белого Пространства</target>
        </trans-unit>
        <trans-unit id="381c317957b5ee7582e73884cd558cdbc223631b" translate="yes" xml:space="preserve">
          <source>Address contains comments</source>
          <target state="translated">Адрес содержит комментарии</target>
        </trans-unit>
        <trans-unit id="a5e2d3cb1fcbce606eb8ccac93ab49310a74b07e" translate="yes" xml:space="preserve">
          <source>Address contains deprecated elements but may still be valid in restricted contexts</source>
          <target state="translated">Адрес содержит устаревшие элементы,но все же может быть действителен в ограниченном контексте</target>
        </trans-unit>
        <trans-unit id="88121f59a17918138d3a99669a4d019180020a55" translate="yes" xml:space="preserve">
          <source>Address contains text after a comment or Folding White Space</source>
          <target state="translated">Адрес содержит текст после комментария или складывания пробела.</target>
        </trans-unit>
        <trans-unit id="b7efe220560e0d5cd3e5e7d43e3e3fd9aca69e6a" translate="yes" xml:space="preserve">
          <source>Address contains text after a quoted string</source>
          <target state="translated">Адрес содержит текст после цитируемой строки</target>
        </trans-unit>
        <trans-unit id="ee43b6fd8e15e2b41602e256006bcdb0082b3ca4" translate="yes" xml:space="preserve">
          <source>Address family</source>
          <target state="translated">Адресная семья</target>
        </trans-unit>
        <trans-unit id="b8ef22713afbe995add506093e861ef3d18ab313" translate="yes" xml:space="preserve">
          <source>Address has no domain part</source>
          <target state="translated">Адрес не имеет доменной части</target>
        </trans-unit>
        <trans-unit id="71bff518935e72def54800521f7700ba45be35d6" translate="yes" xml:space="preserve">
          <source>Address has no local part</source>
          <target state="translated">Адрес не имеет локальной части</target>
        </trans-unit>
        <trans-unit id="e0517bb692824017669287d8571ea86907ce7eb9" translate="yes" xml:space="preserve">
          <source>Address is RFC 5322 compliant but contains domain characters that are not allowed by DNS</source>
          <target state="translated">Адрес соответствует RFC 5322,но содержит символы домена,которые не разрешены DNS</target>
        </trans-unit>
        <trans-unit id="d576c3642c5b3b413429d68ea79dca4c6c19abca" translate="yes" xml:space="preserve">
          <source>Address is either considered valid or not, no finer grained error checking is performed. Returned email status code will be either Error or Valid.</source>
          <target state="translated">Адрес считается действительным или нет,более точная проверка на наличие ошибок не производится.Возвращаемый код статуса электронной почты будет либо Ошибкой,либо Достоверным.</target>
        </trans-unit>
        <trans-unit id="fbe50a7d373fa45401392dba0d4f4263b57fb794" translate="yes" xml:space="preserve">
          <source>Address is invalid for any purpose</source>
          <target state="translated">Адрес недействителен для любых целей</target>
        </trans-unit>
        <trans-unit id="1f1d8cab19a432244d5e438db730dcd5d7cfc3c1" translate="yes" xml:space="preserve">
          <source>Address is marked.</source>
          <target state="translated">Адрес отмечен.</target>
        </trans-unit>
        <trans-unit id="056f415145809cf554f197edff3a6210c2a3c84c" translate="yes" xml:space="preserve">
          <source>Address is not managed by the GC.</source>
          <target state="translated">Адрес не управляется ГК.</target>
        </trans-unit>
        <trans-unit id="b276a2a7b3b8082b5205d4f36c48fdb75ab436d5" translate="yes" xml:space="preserve">
          <source>Address is not marked.</source>
          <target state="translated">Адрес не отмечен.</target>
        </trans-unit>
        <trans-unit id="00d60928d09249fd5121c82ffadb486ff2af7cda" translate="yes" xml:space="preserve">
          <source>Address is too long</source>
          <target state="translated">Адрес слишком длинный</target>
        </trans-unit>
        <trans-unit id="7114aec6ccd6343782971decf3ba885ed8926cea" translate="yes" xml:space="preserve">
          <source>Address is valid</source>
          <target state="translated">Адрес действителен</target>
        </trans-unit>
        <trans-unit id="8684bf895369a504a173494b46ce79f3bfbff7cd" translate="yes" xml:space="preserve">
          <source>Address is valid but a DNS check was not successful</source>
          <target state="translated">Адрес действителен,но проверка DNS не прошла успешно.</target>
        </trans-unit>
        <trans-unit id="910b30a1f7f08850b97f7aabdcb68e08a1bc037b" translate="yes" xml:space="preserve">
          <source>Address is valid but at a Top Level Domain</source>
          <target state="translated">Адрес действителен,но в домене верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="8be421532761d6177a79b25f6bf4e24d2aa48096" translate="yes" xml:space="preserve">
          <source>Address is valid but at a literal address not a domain</source>
          <target state="translated">Адрес действителен,но по буквальному адресу не является доменом.</target>
        </trans-unit>
        <trans-unit id="b2a0d6b7ee4c32f5a2b735044ea5126f1011eba5" translate="yes" xml:space="preserve">
          <source>Address is valid but contains a :: that only elides one zero group</source>
          <target state="translated">Адрес действителен,но содержит :::что только элидирует одну нулевую группу</target>
        </trans-unit>
        <trans-unit id="510622562d2c0218e53097ea6e32ac7b80cf235c" translate="yes" xml:space="preserve">
          <source>Address is valid but contains a quoted string</source>
          <target state="translated">Адрес действителен,но содержит цитируемую строку</target>
        </trans-unit>
        <trans-unit id="8c451ae2b8582f3467ec31948cc6b1b82ba98f9e" translate="yes" xml:space="preserve">
          <source>Address is valid but the Top Level Domain begins with a number</source>
          <target state="translated">Адрес действителен,но домен верхнего уровня начинается с цифры</target>
        </trans-unit>
        <trans-unit id="5ca2422e194aa478738b3920d49b1d72b4a04751" translate="yes" xml:space="preserve">
          <source>Address is valid for SMTP but has unusual elements</source>
          <target state="translated">Адрес действителен для SMTP,но имеет необычные элементы</target>
        </trans-unit>
        <trans-unit id="069a8b8d9763d9ed6d488c79b3db6100b19c762d" translate="yes" xml:space="preserve">
          <source>Address is valid within the message but cannot be used unmodified for the envelope</source>
          <target state="translated">Адрес действителен внутри сообщения,но не может быть использован немодифицированным для конверта.</target>
        </trans-unit>
        <trans-unit id="265f5be727c33a8a13245b57c78d571329630167" translate="yes" xml:space="preserve">
          <source>AddressFamily &lt;strong id=&quot;family&quot;&gt;family&lt;/strong&gt;;</source>
          <target state="translated">Адрес &lt;strong id=&quot;family&quot;&gt;семьи семьи&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9da00639bb3965aa70738e6a575e509275598a8a" translate="yes" xml:space="preserve">
          <source>AddressInfo[] &lt;strong id=&quot;getAddressInfo&quot;&gt;getAddressInfo&lt;/strong&gt;(T...)(scope const(char)[] node, scope T options);</source>
          <target state="translated">AddressInfo [] &lt;strong id=&quot;getAddressInfo&quot;&gt;getAddressInfo&lt;/strong&gt; (T ...) (узел контекста const (char) [], опции области видимости T);</target>
        </trans-unit>
        <trans-unit id="dffa5b087a5bb8dd265fd7a6cbbd1e0d1d41f678" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;p[0 .. sz]&lt;/code&gt; to the list of memory ranges to be scanned for pointers during a collection. If p is null, no operation is performed.</source>
          <target state="translated">Добавляет &lt;code&gt;p[0 .. sz]&lt;/code&gt; в список диапазонов памяти, которые будут сканироваться для поиска указателей во время сбора. Если p равно нулю, никакая операция не выполняется.</target>
        </trans-unit>
        <trans-unit id="672314e29bcc5e362e383fbd999c4b5b4410b405" translate="yes" xml:space="preserve">
          <source>Adds a sign bit to allow for signed numbers.</source>
          <target state="translated">Добавляет бит знака,позволяющий вводить подписанные номера.</target>
        </trans-unit>
        <trans-unit id="ee9a206f63997b29125ee641371481b30dee8462" translate="yes" xml:space="preserve">
          <source>Adds a single Element of data without increasing &lt;code&gt;element_count&lt;/code&gt;. Make sure to increase &lt;code&gt;element_count&lt;/code&gt; by &lt;code&gt;Element.sizeof&lt;/code&gt; for each call to &lt;code&gt;putElement&lt;/code&gt;.</source>
          <target state="translated">Добавляет один элемент данных без увеличения &lt;code&gt;element_count&lt;/code&gt; . Обязательно увеличивайте &lt;code&gt;element_count&lt;/code&gt; на &lt;code&gt;Element.sizeof&lt;/code&gt; для каждого вызова &lt;code&gt;putElement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf698b9f6e73db894b28808fd5abdeb21c41a83" translate="yes" xml:space="preserve">
          <source>Adds an internal root pointing to the GC memory block referenced by p. As a result, the block referenced by p itself and any blocks accessible via it will be considered live until the root is removed again.</source>
          <target state="translated">Добавляет внутренний корень,указывающий на блок GC-памяти,на который ссылается p.В результате,блок,на который ссылается p,и любые блоки,доступные через него,будут считаться живыми до тех пор,пока корень не будет снова удален.</target>
        </trans-unit>
        <trans-unit id="ff12c7ce51172ee3fa78ed53b57f7c8617e36d66" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to BidirectionalRange.</source>
          <target state="translated">Добавляет присваиваемые элементы в BidirectionalRange.</target>
        </trans-unit>
        <trans-unit id="af63794bdee98164b7dedba21a8ddcd815487b81" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to ForwardRange.</source>
          <target state="translated">Добавляет присваиваемые элементы в ForwardRange.</target>
        </trans-unit>
        <trans-unit id="d86b2ad49209ff010a91b4e8020be86eef38434b" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to InputRange.</source>
          <target state="translated">Добавляет присваиваемые элементы в InputRange.</target>
        </trans-unit>
        <trans-unit id="2111dba4f281687d624b61c6aeeecb551c0b910b" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to RandomAccessFinite.</source>
          <target state="translated">Добавляет присваиваемые элементы в RandomAccessFinite.</target>
        </trans-unit>
        <trans-unit id="cea0f0bf07e47c7fb0a04a4c50f0f8d4341a2b7e" translate="yes" xml:space="preserve">
          <source>Adds data to the digester. This function can be called many times in a row after start but before finish.</source>
          <target state="translated">Добавляет данные в метантенк.Эту функцию можно вызывать много раз подряд после старта,но до конца.</target>
        </trans-unit>
        <trans-unit id="f9a3cbb838535843105d2dbd716177d37c6dc90e" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two &lt;code&gt;TickDuration&lt;/code&gt;s as well as assigning the result to this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">Добавляет или вычитает два значения &lt;code&gt;TickDuration&lt;/code&gt; , а также присваивает результат этому &lt;code&gt;TickDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c16f4ce03396768dfa95982d340781a78324241" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two &lt;code&gt;TickDuration&lt;/code&gt;s.</source>
          <target state="translated">Добавляет или вычитает два значения &lt;code&gt;TickDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c737e93d31255b859d9ebe8158a9fb5eee5ea8ae" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two durations.</source>
          <target state="translated">Добавляет или вычитает две длительности.</target>
        </trans-unit>
        <trans-unit id="e87760afd0099199ebc5a0eb76c281d30e85cec5" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">Добавляет указанное число единиц к этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , изменяя его. Отрицательное число вычтет.</target>
        </trans-unit>
        <trans-unit id="0f80ac2d800f8ee490ca058f4b673564daf01236" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">Добавляет указанное число единиц к этому &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; , изменяя его. Отрицательное число вычтет.</target>
        </trans-unit>
        <trans-unit id="00a26d0cef5a8a591d36a0308e58ee4701a2e0f7" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. A negative number will subtract.</source>
          <target state="translated">Добавляет указанное количество единиц к этому &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; . Отрицательное число вычтет.</target>
        </trans-unit>
        <trans-unit id="25d7fd9970d15ef947135e621f6d15c4231ff9c0" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">Добавляет указанное количество единиц к этому &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; , изменяя его. Отрицательное число вычтет.</target>
        </trans-unit>
        <trans-unit id="abb4bf42c71674b6c0e872462683cd4dd3560370" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">Добавляет указанное число лет или месяцев к этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , изменяя ее. Отрицательное число вычтет.</target>
        </trans-unit>
        <trans-unit id="17c8fc904e2c9da1e769c06f6205227d30331e48" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="translated">Добавляет указанное число лет или месяцев к этому &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; , изменяя его. Отрицательное число вычтет.</target>
        </trans-unit>
        <trans-unit id="cb5ca95f30def8b12993088b8d76ab1dd37d553c" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. A negative number will subtract.</source>
          <target state="translated">Добавляет указанное количество лет или месяцев к этому &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; . Отрицательное число вычтет.</target>
        </trans-unit>
        <trans-unit id="ae45ff9fb528c8b811a4a8b39bb46f4d2af30e79" translate="yes" xml:space="preserve">
          <source>Adds, subtracts or calculates the modulo of two durations as well as assigning the result to this &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Добавляет, вычитает или вычисляет по модулю две длительности, а также присваивает результат этой &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7217c4f38fb4c88be899accd3f3c8388ee115acb" translate="yes" xml:space="preserve">
          <source>Adds, subtracts or calculates the modulo of two durations.</source>
          <target state="translated">Добавляет,вычитает или вычисляет модуль двух длительностей.</target>
        </trans-unit>
        <trans-unit id="190513d30ca7a3e2a999758bba5d14849013dae0" translate="yes" xml:space="preserve">
          <source>Adheres to &lt;a href=&quot;http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf&quot;&gt;Unicode 7.0&lt;/a&gt;.</source>
          <target state="translated">Придерживается &lt;a href=&quot;http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf&quot;&gt;Unicode 7.0&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e6c5c313ae1124d50c20408776fe80d4c2f9549" translate="yes" xml:space="preserve">
          <source>Adjacent separators.</source>
          <target state="translated">Соседние сепараторы.</target>
        </trans-unit>
        <trans-unit id="722ed5201dde06aad85b7457e551331fed6fc5eb" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;n&lt;/code&gt; to a size suitable for allocation (two words or larger, word-aligned).</source>
          <target state="translated">Настраивает &lt;code&gt;n&lt;/code&gt; до размера, подходящего для размещения (два слова или больше, выравнивание по словам).</target>
        </trans-unit>
        <trans-unit id="25ad3e5c0dbbba69ec8c4772c55f2582037c6136" translate="yes" xml:space="preserve">
          <source>Advance the range to the next chunk of encoded data.</source>
          <target state="translated">Продвигайте диапазон до следующей порции закодированных данных.</target>
        </trans-unit>
        <trans-unit id="53489cea9eb74ca25d0c733e6598d5384d852067" translate="yes" xml:space="preserve">
          <source>Advance to the next decoded byte.</source>
          <target state="translated">Переходим к следующему расшифрованному байту.</target>
        </trans-unit>
        <trans-unit id="3a3cd74a73d6f0a26c42392d915705fa7dae1cf8" translate="yes" xml:space="preserve">
          <source>Advance to the next element in the input to be decoded.</source>
          <target state="translated">Переход к следующему элементу на входе,который необходимо декодировать.</target>
        </trans-unit>
        <trans-unit id="6d3634150cc1196e50397ef062eee34b37152811" translate="yes" xml:space="preserve">
          <source>Advance to the next encoded character.</source>
          <target state="translated">Переходим к следующему закодированному символу.</target>
        </trans-unit>
        <trans-unit id="b1dffc8e495ab0f0b08bad1e3f10f588c91ee072" translate="yes" xml:space="preserve">
          <source>Advanced feature - provide direct access to a subset of matcher based a set of known encoding lengths. Lengths are provided in &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt;. The sub-matcher then may do less operations per any &lt;code&gt;test&lt;/code&gt;/&lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">Расширенная функция - обеспечивает прямой доступ к подмножеству сопоставителей на основе набора известных длин кодирования. Длина указана в &lt;a href=&quot;#Code%20unit&quot;&gt;единицах кода&lt;/a&gt; . В этом случае суб-сопоставитель может выполнять меньше операций за любой &lt;code&gt;test&lt;/code&gt; / &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eeb58f4b086c0412e02e6890890553e6dd38d672" translate="yes" xml:space="preserve">
          <source>Advanced updating</source>
          <target state="translated">Расширенное обновление</target>
        </trans-unit>
        <trans-unit id="cf881b5c6e7f1c3b9a2c00554a2646c41d876526" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;r&lt;/code&gt; until it finds the first two adjacent elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; that satisfy &lt;code&gt;pred(a, b)&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Прогресс &lt;code&gt;r&lt;/code&gt; до тех пор, пока не найдет первые два соседних элемента , &lt;code&gt;b&lt;/code&gt; , которые удовлетворяют условию &lt;code&gt;pred(a, b)&lt;/code&gt; . Выполняет &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; ) оценки &lt;code&gt;pred&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="facf585ea759be8e47863eaecb960e98185ac802" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;seq&lt;/code&gt; by calling &lt;code&gt;seq.popFront&lt;/code&gt; until either &lt;code&gt;find!(pred)(choices, seq.front)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;seq&lt;/code&gt; becomes empty. Performs &amp;Omicron;(&lt;code&gt;seq.length * choices.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Авансы &lt;code&gt;seq&lt;/code&gt; по называя &lt;code&gt;seq.popFront&lt;/code&gt; до любой &lt;code&gt;find!(pred)(choices, seq.front)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , или &lt;code&gt;seq&lt;/code&gt; становятся пустыми. Выполняет &amp;Omicron; ( &lt;code&gt;seq.length * choices.length&lt;/code&gt; ) оценки &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f69d337edd3755f38c1707e24fc5346d4e2d44c" translate="yes" xml:space="preserve">
          <source>Advances a given bidirectional range from the right by exactly</source>
          <target state="translated">Сдвигает заданный двунаправленный диапазон с правой стороны точно на</target>
        </trans-unit>
        <trans-unit id="19d2eb30ee8dd8c5d7afbff2f9bd7ea8bb2642e3" translate="yes" xml:space="preserve">
          <source>Advances a given bidirectional range from the right by up to</source>
          <target state="translated">Сдвиги заданного двунаправленного диапазона от права до</target>
        </trans-unit>
        <trans-unit id="a1e75744b3b444139cd4f0a58b334b9edf66d830" translate="yes" xml:space="preserve">
          <source>Advances a given range by up exactly</source>
          <target state="translated">Достижения в заданном диапазоне наверх точно</target>
        </trans-unit>
        <trans-unit id="1a622ec23b3321ab3e350f048523f7084cf595eb" translate="yes" xml:space="preserve">
          <source>Advances a given range by up to</source>
          <target state="translated">Авансы в заданном диапазоне до</target>
        </trans-unit>
        <trans-unit id="78bc54605619ccfaa022076c05ce4d0d5ecf8d2e" translate="yes" xml:space="preserve">
          <source>Advances the generator.</source>
          <target state="translated">Увеличивает мощность генератора.</target>
        </trans-unit>
        <trans-unit id="e7c9ed0ebcf630bc583e7903a2b6d29b7aca3fc7" translate="yes" xml:space="preserve">
          <source>Advances the random sequence.</source>
          <target state="translated">Продвигается случайная последовательность.</target>
        </trans-unit>
        <trans-unit id="841e5d06644019901743e66d69de7d1976b71c5b" translate="yes" xml:space="preserve">
          <source>Advances to the next element in all controlled ranges.</source>
          <target state="translated">Переход к следующему элементу во всех контролируемых диапазонах.</target>
        </trans-unit>
        <trans-unit id="cbe9dcb57596ffec1913e83a16abf147d32611b9" translate="yes" xml:space="preserve">
          <source>Aegean Numbers</source>
          <target state="translated">Эгейские Числа</target>
        </trans-unit>
        <trans-unit id="931eed4d96571bfeae93ef9dcf8c3202ff20b1ad" translate="yes" xml:space="preserve">
          <source>Affects whether functions are inlined or not. If at the declaration level, it affects the functions declared in the block it controls. If inside a function, it affects the function it is enclosed by.</source>
          <target state="translated">Влияет на то,являются ли функции вложенными или нет.Если на уровне объявления,то влияет на функции,объявленные в управляемом им блоке.Если внутри функции,то влияет на функцию,которой она является закрытой.</target>
        </trans-unit>
        <trans-unit id="442683da146742a25947515455e712ba78a50694" translate="yes" xml:space="preserve">
          <source>Affix access functions offering references to the affixes of a block &lt;code&gt;b&lt;/code&gt; previously allocated with this allocator. &lt;code&gt;b&lt;/code&gt; may not be null. They are defined if and only if the corresponding affix is not &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Аффиксные функции доступа, предлагающие ссылки на аффиксы блока &lt;code&gt;b&lt;/code&gt; , ранее выделенного этим распределителем. &lt;code&gt;b&lt;/code&gt; не может быть нулевым. Они определяются тогда и только тогда, когда соответствующий аффикс не является &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c23381a58dcf83131fe33f75a01b801175e69bea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;typeSemantic&lt;/code&gt; the symbol when &lt;code&gt;exp&lt;/code&gt; doesn't represent a type.</source>
          <target state="translated">После &lt;code&gt;typeSemantic&lt;/code&gt; символ, когда &lt;code&gt;exp&lt;/code&gt; не представляет тип.</target>
        </trans-unit>
        <trans-unit id="f58f4b720491f08a3e184b4d93384253d667e81c" translate="yes" xml:space="preserve">
          <source>After a FTP client has been setup and possibly assigned callbacks the &lt;code&gt; perform()&lt;/code&gt; method will start performing the actual communication with the server.</source>
          <target state="translated">После того, как FTP-клиент настроен и, возможно, ему назначены обратные вызовы, метод &lt;code&gt; perform()&lt;/code&gt; начнет осуществлять фактическую связь с сервером.</target>
        </trans-unit>
        <trans-unit id="40877a01f3d2d2683d82a5ea2b798c56a293359c" translate="yes" xml:space="preserve">
          <source>After creation, a &lt;code&gt;Task&lt;/code&gt; may be executed in a new thread, or submitted to a &lt;code&gt;TaskPool&lt;/code&gt; for execution. A &lt;code&gt;TaskPool&lt;/code&gt; encapsulates a task queue and its worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that is associated with exactly one task queue. It executes the &lt;code&gt;Task&lt;/code&gt; at the front of its queue when the queue has work available, or sleeps when no work is available. Each task queue is associated with zero or more worker threads. If the result of a &lt;code&gt;Task&lt;/code&gt; is needed before execution by a worker thread has begun, the &lt;code&gt;Task&lt;/code&gt; can be removed from the task queue and executed immediately in the thread where the result is needed.</source>
          <target state="translated">После создания &lt;code&gt;Task&lt;/code&gt; может быть выполнена в новом потоке или передана в &lt;code&gt;TaskPool&lt;/code&gt; для выполнения. &lt;code&gt;TaskPool&lt;/code&gt; инкапсулирует очереди задач и ее рабочие потоки. Его цель - эффективно отобразить большое количество &lt;code&gt;Task&lt;/code&gt; на меньшее количество потоков. Очередь задач - это очередь FIFO объектов &lt;code&gt;Task&lt;/code&gt; , которые были отправлены в &lt;code&gt;TaskPool&lt;/code&gt; и ожидают выполнения. Рабочий поток - это поток, связанный ровно с одной очередью задач. Он выполняет &lt;code&gt;Task&lt;/code&gt; в начале своей очереди, когда в очереди есть доступная работа, или бездействует, когда работа недоступна. Каждая очередь задач связана с нулем или более рабочих потоков. Если результат &lt;code&gt;Task&lt;/code&gt; Требуется до начала выполнения рабочим потоком. &lt;code&gt;Task&lt;/code&gt; может быть удалена из очереди и немедленно выполнена в потоке, где требуется результат.</target>
        </trans-unit>
        <trans-unit id="fac78fef792ce790d176c70684c125385e59b69f" translate="yes" xml:space="preserve">
          <source>After the HTTP client has been setup and possibly assigned callbacks the &lt;code&gt;perform()&lt;/code&gt; method will start performing the request towards the specified server.</source>
          <target state="translated">После того, как HTTP-клиент настроен и, возможно, ему назначены обратные вызовы, метод &lt;code&gt;perform()&lt;/code&gt; начнет выполнять запрос к указанному серверу.</target>
        </trans-unit>
        <trans-unit id="3be61943c5e6beb762f765e4ebc8da159c5a9299" translate="yes" xml:space="preserve">
          <source>After this function is finished executing, any exceptions thrown are chained together via &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The chaining order is non-deterministic.</source>
          <target state="translated">После завершения выполнения этой функции любые &lt;code&gt;Throwable.next&lt;/code&gt; исключения объединяются в цепочку через Throwable.next и перебрасываются. Порядок сцепления недетерминирован.</target>
        </trans-unit>
        <trans-unit id="2423ca21e96dd2f33c30a0a22ba75c7e9a97460a" translate="yes" xml:space="preserve">
          <source>Aggregate Templates</source>
          <target state="translated">Совокупность шаблонов</target>
        </trans-unit>
        <trans-unit id="422fc1d404645ddf0fe8822054c49c2df47da791" translate="yes" xml:space="preserve">
          <source>Aggregate Type traits</source>
          <target state="translated">Совокупность признаков типа</target>
        </trans-unit>
        <trans-unit id="5a49d2a80d7f18d6b1f678d37a80f429dee0945d" translate="yes" xml:space="preserve">
          <source>Aggregate literals (AA/string/array/struct)</source>
          <target state="translated">Совокупность букв (AA/string/array/struct)</target>
        </trans-unit>
        <trans-unit id="0a01f2f266bf28f3c82d33549ab6734f725b8328" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;code&gt;ad&lt;/code&gt;</source>
          <target state="translated">AggregateDeclaration &lt;code&gt;ad&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65711c59e3f2ecd6ab45c5a271a40aff4bf044a7" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;strong id=&quot;isAggregate&quot;&gt;isAggregate&lt;/strong&gt;(Type t);</source>
          <target state="translated">AggregateDeclaration &lt;strong id=&quot;isAggregate&quot;&gt;isAggregate&lt;/strong&gt; (Тип t);</target>
        </trans-unit>
        <trans-unit id="b026ca73b3ee9e08b16268eb5969c7649a6ada2c" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;strong id=&quot;isInlinableNestedAggregate&quot;&gt;isInlinableNestedAggregate&lt;/strong&gt;(DeclarationExp e);</source>
          <target state="translated">AggregateDeclaration &lt;strong id=&quot;isInlinableNestedAggregate&quot;&gt;isInlinableNestedAggregate&lt;/strong&gt; ( &lt;strong id=&quot;isInlinableNestedAggregate&quot;&gt;DeclaExp&lt;/strong&gt; e);</target>
        </trans-unit>
        <trans-unit id="deb507c2bab5b6df1dfb7a527622531bee5bbcae" translate="yes" xml:space="preserve">
          <source>Aggregates</source>
          <target state="translated">Aggregates</target>
        </trans-unit>
        <trans-unit id="039a4d9ad09b94c49e1256fa36bbd7145bd6a873" translate="yes" xml:space="preserve">
          <source>Aggregates can be string literals, which can be accessed as char, wchar, or dchar arrays:</source>
          <target state="translated">Агрегаты могут быть строковыми литералами,доступными в виде массивов char,wchar или dchar:</target>
        </trans-unit>
        <trans-unit id="64215ea928af9a868c37adc98435f865c066cad0" translate="yes" xml:space="preserve">
          <source>Aggregation of GC stats to be exposed via public API</source>
          <target state="translated">Агрегирование статистики ГХ,которые будут выставлены через публичный API.</target>
        </trans-unit>
        <trans-unit id="95739c27a4231a1ab1768db7918200a659985986" translate="yes" xml:space="preserve">
          <source>Aggregation of current profile information</source>
          <target state="translated">Агрегирование текущей информации профиля</target>
        </trans-unit>
        <trans-unit id="960ed8592125f2bc50d2c8d3a223103bb8eab0ce" translate="yes" xml:space="preserve">
          <source>Alchemical Symbols</source>
          <target state="translated">Алхимические символы</target>
        </trans-unit>
        <trans-unit id="d5ba6c3d74529cf2db06f24108dd96d14e3a3bf5" translate="yes" xml:space="preserve">
          <source>Algebraic data type restricted to a closed set of possible types. It's an alias for &lt;a href=&quot;#VariantN&quot;&gt;&lt;code&gt;VariantN&lt;/code&gt;&lt;/a&gt; with an appropriately-constructed maximum size. &lt;code&gt;Algebraic&lt;/code&gt; is useful when it is desirable to restrict what a discriminated type could hold to the end of defining simpler and more efficient manipulation.</source>
          <target state="translated">Алгебраический тип данных ограничен замкнутым набором возможных типов. Это псевдоним для &lt;a href=&quot;#VariantN&quot;&gt; &lt;code&gt;VariantN&lt;/code&gt; &lt;/a&gt; с соответствующим образом созданным максимальным размером. &lt;code&gt;Algebraic&lt;/code&gt; полезен, когда желательно ограничить то, что дискриминируемый тип может содержать до конца определения более простых и эффективных манипуляций.</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="c6f1119d49c8f3cbd3127d86d596eb5ad76abaa0" translate="yes" xml:space="preserve">
          <source>Algorithms are categorized into the following submodules:</source>
          <target state="translated">Алгоритмы подразделяются на следующие субмодули:</target>
        </trans-unit>
        <trans-unit id="9d031d2cc1773d432e8d4e5e3e397ff72d33b73a" translate="yes" xml:space="preserve">
          <source>Algorithms should be written to work based on the minimum precision of the calculation. They should not degrade or fail if the actual precision is greater. Float or double types, as opposed to the real (extended) type, should only be used for:</source>
          <target state="translated">Алгоритмы должны быть написаны для работы на основе минимальной точности расчета.Они не должны ухудшаться или выходить из строя,если фактическая точность выше.Типы float или double,в отличие от реального (расширенного)типа,должны использоваться только для:</target>
        </trans-unit>
        <trans-unit id="6b7d7cc33ac422a7126bf7ca7d4bc41f992588c9" translate="yes" xml:space="preserve">
          <source>Algorithms that work specifically with strings.</source>
          <target state="translated">Алгоритмы,которые работают именно со струнами.</target>
        </trans-unit>
        <trans-unit id="88abf47d65eee8406cedefebf1444bde5b352ec5" translate="yes" xml:space="preserve">
          <source>Ali &amp;Ccedil;ehreli's &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;tutorial on ranges&lt;/a&gt; for the basics of working with and creating range-based code.</source>
          <target state="translated">Учебное &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;пособие&lt;/a&gt; Али Шерели по диапазонам для основ работы с и создания кода на основе диапазонов.</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="2b42e13ed23a87356a09e332c7e6e714e6e09e96" translate="yes" xml:space="preserve">
          <source>Alias Declarations</source>
          <target state="translated">заявления псевдонима</target>
        </trans-unit>
        <trans-unit id="77ef2f52299fed56a50f678635e931b47d8d55bb" translate="yes" xml:space="preserve">
          <source>Alias Templates</source>
          <target state="translated">Шаблоны псевдонимов</target>
        </trans-unit>
        <trans-unit id="8e3462f022e547a8b9b81a59c7d09995c97a1575" translate="yes" xml:space="preserve">
          <source>Alias This</source>
          <target state="translated">Псевдоним Это</target>
        </trans-unit>
        <trans-unit id="a6823ce53aa787875a84b73b489aeaa41fb9203a" translate="yes" xml:space="preserve">
          <source>Alias declarations can be used to overload together functions declared in different mixins:</source>
          <target state="translated">Псевдонимы могут быть использованы для перегрузки вместе функций,объявленных в различных смесях:</target>
        </trans-unit>
        <trans-unit id="9f63972ec70f46c0515cbfc8d099ae2cc95be598" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#VariantN&quot;&gt;&lt;code&gt;VariantN&lt;/code&gt;&lt;/a&gt; instantiated with the largest size of &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;char[]&lt;/code&gt;, and &lt;code&gt;void delegate()&lt;/code&gt;. This ensures that &lt;code&gt;Variant&lt;/code&gt; is large enough to hold all of D's predefined types unboxed, including all numeric types, pointers, delegates, and class references. You may want to use &lt;code&gt;VariantN&lt;/code&gt; directly with a different maximum size either for storing larger types unboxed, or for saving memory.</source>
          <target state="translated">Псевдоним для &lt;a href=&quot;#VariantN&quot;&gt; &lt;code&gt;VariantN&lt;/code&gt; создается&lt;/a&gt; с наибольшим размером &lt;code&gt;creal&lt;/code&gt; , &lt;code&gt;char[]&lt;/code&gt; и &lt;code&gt;void delegate()&lt;/code&gt; Delegate () . Это гарантирует, что &lt;code&gt;Variant&lt;/code&gt; будет достаточно большим, чтобы не распаковывать все предопределенные типы D, включая все числовые типы, указатели, делегаты и ссылки на классы. Возможно, вы захотите использовать &lt;code&gt;VariantN&lt;/code&gt; напрямую с другим максимальным размером либо для хранения больших типов без распаковки, либо для сохранения памяти.</target>
        </trans-unit>
        <trans-unit id="63202ec3a67d85508053325231c6e3a50b705940" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;typeof(Factory()(1))&lt;/code&gt;, i.e. the type of the individual allocators.</source>
          <target state="translated">Псевдоним для &lt;code&gt;typeof(Factory()(1))&lt;/code&gt; , то есть тип отдельных распределителей.</target>
        </trans-unit>
        <trans-unit id="105407ad1c7568b9c649c50759d11c4e192f57b4" translate="yes" xml:space="preserve">
          <source>Alias parameters can accept both literals and user-defined type symbols, but they are less specialized than the matches to type parameters and value parameters:</source>
          <target state="translated">Параметры псевдонима могут принимать как литералы,так и пользовательские символы типа,но они менее специализированы,чем совпадения с параметрами типа и параметрами значения:</target>
        </trans-unit>
        <trans-unit id="d22b74da1f9d782bb61c364a8aadbff84bd13777" translate="yes" xml:space="preserve">
          <source>Alias parameters can also be typed. These parameters will accept symbols of that type:</source>
          <target state="translated">Также могут быть набраны параметры псевдонима.Эти параметры будут принимать символы данного типа:</target>
        </trans-unit>
        <trans-unit id="b917c61ec37f1f84ac7cb387db33687a0c61b1b1" translate="yes" xml:space="preserve">
          <source>Alias parameters enable templates to be parameterized with symbol names or values computed at compile-time. Almost any kind of D symbol can be used, including user-defined type names, global names, local names, module names, template names, and template instance names.</source>
          <target state="translated">Параметры псевдонимов позволяют параметрировать шаблоны с именами символов или значениями,вычисленными во время компиляции.Может использоваться практически любой тип символа D,включая имена типов,определяемые пользователем,глобальные и локальные имена,имена модулей,имена шаблонов и имена экземпляров шаблонов.</target>
        </trans-unit>
        <trans-unit id="8515de354ea5c9130e0c481ca51f1addb44b5d02" translate="yes" xml:space="preserve">
          <source>Alias sequence filtering</source>
          <target state="translated">Фильтрация последовательности псевдонимов</target>
        </trans-unit>
        <trans-unit id="cdba1b60c0b760cd04f385300eb523eb54b00054" translate="yes" xml:space="preserve">
          <source>Alias sequence searching</source>
          <target state="translated">Поиск последовательности псевдонимов</target>
        </trans-unit>
        <trans-unit id="1590720ca74c606d4c9f961020006e51239fec30" translate="yes" xml:space="preserve">
          <source>Alias sequence transformation</source>
          <target state="translated">Преобразование последовательности псевдонимов</target>
        </trans-unit>
        <trans-unit id="5c56d0ae76a47ae72fa8c318d1bfb56034cb27c4" translate="yes" xml:space="preserve">
          <source>Alias sequence type hierarchy</source>
          <target state="translated">Иерархия типов последовательностей псевдонимов</target>
        </trans-unit>
        <trans-unit id="2ba4b28154b9d6a34808cdcb201b98d061c254fa" translate="yes" xml:space="preserve">
          <source>Alias your own enforce function</source>
          <target state="translated">Псевдоним-ваша собственная функция принуждения</target>
        </trans-unit>
        <trans-unit id="3677863f140b997e20f4c765fa070bfcd26df047" translate="yes" xml:space="preserve">
          <source>AliasDeclaration</source>
          <target state="translated">AliasDeclaration</target>
        </trans-unit>
        <trans-unit id="07e1c1a8b4a8503f8648ab57227770c6e32ac2e8" translate="yes" xml:space="preserve">
          <source>AliasSeq</source>
          <target state="translated">AliasSeq</target>
        </trans-unit>
        <trans-unit id="a75c4e940b98b3f296d4a0d45ef3c78158d01f9b" translate="yes" xml:space="preserve">
          <source>AliasThis</source>
          <target state="translated">AliasThis</target>
        </trans-unit>
        <trans-unit id="f45e3de29f946da184942d83246da3931f3381ce" translate="yes" xml:space="preserve">
          <source>AliasThis &lt;code&gt;at&lt;/code&gt;</source>
          <target state="translated">AliasThis &lt;code&gt;at&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6b07ef377e1a1cca3873fdac3f4b419d63ed5c" translate="yes" xml:space="preserve">
          <source>Aliased symbols are useful as a shorthand for a long qualified symbol name, or as a way to redirect references from one symbol to another:</source>
          <target state="translated">Символы с псевдонимом полезны как сокращение для длинного квалифицированного имени символа,или как способ перенаправления ссылок с одного символа на другой:</target>
        </trans-unit>
        <trans-unit id="7f8884a25f8de2f7a75d30d9ae86bb0f1f09187b" translate="yes" xml:space="preserve">
          <source>Aliased types are semantically identical to the types they are aliased to. The debugger cannot distinguish between them, and there is no difference as far as function overloading is concerned. For example:</source>
          <target state="translated">Типы псевдонимов семантически идентичны типам,которым они присвоены.Отладчик не может отличить их,и нет никакой разницы в том,что касается перегрузки функций.Например:</target>
        </trans-unit>
        <trans-unit id="181e7f0a478bed4e18de65212b24a50ae36262a7" translate="yes" xml:space="preserve">
          <source>Aliases can also &lt;code&gt;import&lt;/code&gt; a set of overloaded functions, that can be overloaded with functions in the current scope:</source>
          <target state="translated">Псевдонимы также могут &lt;code&gt;import&lt;/code&gt; набор перегруженных функций, которые могут быть перегружены функциями из текущей области:</target>
        </trans-unit>
        <trans-unit id="daf33e541d4cc1a3ec6daef4974e2cc623107069" translate="yes" xml:space="preserve">
          <source>Aliases cannot be used for expressions:</source>
          <target state="translated">Псевдонимы не могут быть использованы для выражений:</target>
        </trans-unit>
        <trans-unit id="ebc45702486814ba8ea503fc9c806c260e1435cb" translate="yes" xml:space="preserve">
          <source>Aliases itself to &lt;code&gt;T[0]&lt;/code&gt; if the boolean &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and to &lt;code&gt;T[1]&lt;/code&gt; otherwise.</source>
          <target state="translated">Псевдонимы себе , чтобы &lt;code&gt;T[0]&lt;/code&gt; , если логическое &lt;code&gt;condition&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , и &lt;code&gt;T[1]&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="e3937b5ce30f890ad3772d735fbf89d86613c889" translate="yes" xml:space="preserve">
          <source>Aliases the operating-system-specific semaphore type.</source>
          <target state="translated">Псевдонимы семафорного типа,специфичные для операционной системы.</target>
        </trans-unit>
        <trans-unit id="ca83555e7a077f50fe3fcacdc4d3433397f6d741" translate="yes" xml:space="preserve">
          <source>Aliasing can be used to &lt;code&gt;import&lt;/code&gt; a symbol from an import into the current scope:</source>
          <target state="translated">Псевдоним можно использовать для &lt;code&gt;import&lt;/code&gt; символа из импорта в текущую область:</target>
        </trans-unit>
        <trans-unit id="3880da17e1bb86f5003addaa85926c1d8378f606" translate="yes" xml:space="preserve">
          <source>AlignAttribute</source>
          <target state="translated">AlignAttribute</target>
        </trans-unit>
        <trans-unit id="c33b72e35015aa610f1d135fb91888616c7312da" translate="yes" xml:space="preserve">
          <source>Aligned allocator using OS-specific primitives, under a uniform API.</source>
          <target state="translated">Выровненный аллокатор,использующий специфические для ОС примитивы,под единым API.</target>
        </trans-unit>
        <trans-unit id="33c63fc9fbd39c59d281cefd5cb568321a27de38" translate="yes" xml:space="preserve">
          <source>Aligning the start of a loop body can sometimes have a dramatic effect on the execution speed.</source>
          <target state="translated">Выравнивание начала тела петли иногда может оказать драматическое влияние на скорость исполнения.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="631fafc1c69d316d9d50c570d786f73ce03ceecb" translate="yes" xml:space="preserve">
          <source>Alignment is identical to that of the parent.</source>
          <target state="translated">Выравнивание идентично выравниванию родителя.</target>
        </trans-unit>
        <trans-unit id="628683da3626c98088bdb745580ccfdd6195c8e9" translate="yes" xml:space="preserve">
          <source>Alignment is page-size and hardcoded to 4096 (even though on certain systems it could be larger).</source>
          <target state="translated">Выравнивание имеет размер страницы и жесткий код 4096 (хотя на некоторых системах оно может быть и больше).</target>
        </trans-unit>
        <trans-unit id="ee7a5f296fba571ed109f22fb62cee377810a13b" translate="yes" xml:space="preserve">
          <source>Alignment offered</source>
          <target state="translated">Предлагаемое выравнивание</target>
        </trans-unit>
        <trans-unit id="da6f06da696bc1f912e995a3736dfda61d958504" translate="yes" xml:space="preserve">
          <source>Alignment offered is equal to &lt;code&gt;Allocator.alignment&lt;/code&gt;.</source>
          <target state="translated">Предлагаемое выравнивание равно &lt;code&gt;Allocator.alignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fda3b8d79c5ba0e4cb6a973462e579762d4731" translate="yes" xml:space="preserve">
          <source>Alignment offered.</source>
          <target state="translated">Предложено выравнивание.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="abe24b72722605e6cdd91fc4259456dcc124fc52" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;struct&lt;/code&gt; declarations are an instance of this.</source>
          <target state="translated">Все объявления &lt;code&gt;struct&lt;/code&gt; являются примером этого.</target>
        </trans-unit>
        <trans-unit id="a15215d4acb70177c3fa907103d5e4082e2c6ca5" translate="yes" xml:space="preserve">
          <source>All D class objects inherit from Object.</source>
          <target state="translated">Все объекты класса D наследуются от Object.</target>
        </trans-unit>
        <trans-unit id="4b8af670ebee67e47b1547dfb583c8778c294941" translate="yes" xml:space="preserve">
          <source>All Linux Systems, except for Android</source>
          <target state="translated">Все системы Linux,кроме Android</target>
        </trans-unit>
        <trans-unit id="80accc5a7a3759a25495613b953505c2d3f752d2" translate="yes" xml:space="preserve">
          <source>All Linux systems</source>
          <target state="translated">Все системы Linux</target>
        </trans-unit>
        <trans-unit id="4d974fefbe10142c06ce86c531753f630c736767" translate="yes" xml:space="preserve">
          <source>All Objective-C classes that should be accessible from within D need to be declared with the &lt;a href=&quot;#objc-linkage&quot;&gt;Objective-C linkage&lt;/a&gt;. If the class is declared as &lt;code&gt;extern&lt;/code&gt; (in addition to &lt;code&gt;extern (Objective-C)&lt;/code&gt;) it is expected to be defined externally.</source>
          <target state="translated">Все классы Objective-C, которые должны быть доступны изнутри D, должны быть объявлены с помощью связи &lt;a href=&quot;#objc-linkage&quot;&gt;Objective-C&lt;/a&gt; . Если класс объявлен как &lt;code&gt;extern&lt;/code&gt; (в дополнение к &lt;code&gt;extern (Objective-C)&lt;/code&gt; ), ожидается, что он будет определен извне.</target>
        </trans-unit>
        <trans-unit id="1cad9880f94b0d69e64ab7ba48ed53970ed3c806" translate="yes" xml:space="preserve">
          <source>All POSIX systems (includes Linux, FreeBSD, OS X, Solaris, etc.)</source>
          <target state="translated">Все POSIX системы (включая Linux,FreeBSD,OS X,Solaris и т.д.).</target>
        </trans-unit>
        <trans-unit id="573bedde18f09596640b473ee57afdc92f81ce77" translate="yes" xml:space="preserve">
          <source>All algorithms are generalized to accept as input not only sets but also &lt;a href=&quot;http://https//en.wikipedia.org/wiki/Multiset&quot;&gt;multisets&lt;/a&gt;. Each algorithm documents behaviour in the presence of duplicated inputs.</source>
          <target state="translated">Все алгоритмы обобщены, чтобы принимать в качестве входных данных не только множества, но и &lt;a href=&quot;http://https//en.wikipedia.org/wiki/Multiset&quot;&gt;мультимножества&lt;/a&gt; . Каждый алгоритм документирует поведение при наличии дублированных входных данных.</target>
        </trans-unit>
        <trans-unit id="deb71250ab180a43538a473f83e6182c437126a3" translate="yes" xml:space="preserve">
          <source>All allocators in this module accept and return &lt;code&gt;void[]&lt;/code&gt; (as opposed to &lt;code&gt;shared void[]&lt;/code&gt;). This is because at the time of allocation, deallocation, or reallocation, the memory is effectively not &lt;code&gt;shared&lt;/code&gt; (if it were, it would reveal a bug at the application level).</source>
          <target state="translated">Все распределители в этом модуле принимают и возвращают &lt;code&gt;void[]&lt;/code&gt; (в отличие от &lt;code&gt;shared void[]&lt;/code&gt; ). Это связано с тем, что во время выделения, освобождения или перераспределения память фактически не &lt;code&gt;shared&lt;/code&gt; (если бы это было так, это выявило бы ошибку на уровне приложения).</target>
        </trans-unit>
        <trans-unit id="5de9c469f53cd882bbe9f78f7b9c7bd22b28c0ee" translate="yes" xml:space="preserve">
          <source>All arithmetic operations are supported, except unsigned shift right (&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;). Bitwise operations (&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) are supported, and behave as if BigInt was an infinite length 2's complement number.</source>
          <target state="translated">Поддерживаются все арифметические операции, кроме беззнакового смещения вправо ( &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; ). Побитовые операции ( &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; ) поддерживаются и ведут себя так, как если бы BigInt был числом дополнения бесконечной длины 2.</target>
        </trans-unit>
        <trans-unit id="46dc5bc27e859a39247d5b9a63e991bdb3dcaaa3" translate="yes" xml:space="preserve">
          <source>All arrays that use char, wchar, and their qualified versions are narrow strings. (Those include string and wstring).</source>
          <target state="translated">Все массивы,использующие char,wchar и их квалифицированные версии,являются узкими строками.(К ним относятся строки и строки).</target>
        </trans-unit>
        <trans-unit id="c8a30ad5dcb475c164f90e540d6c2f68890c9e95" translate="yes" xml:space="preserve">
          <source>All changes are temporary. The previous state is restored at the end of the scope.</source>
          <target state="translated">Все изменения временные.Предыдущее состояние восстанавливается в конце диапазона.</target>
        </trans-unit>
        <trans-unit id="21cfae6e750ea0fd4fbc469d1b9c885b7b28182c" translate="yes" xml:space="preserve">
          <source>All character input range conversions using &lt;a href=&quot;#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt; are forwarded to &lt;code&gt;parse&lt;/code&gt; and do not require lvalues.</source>
          <target state="translated">Все преобразования диапазона ввода символов, использующие &lt;a href=&quot;#to&quot;&gt; &lt;code&gt;to&lt;/code&gt; ,&lt;/a&gt; передаются для &lt;code&gt;parse&lt;/code&gt; и не требуют lvalues.</target>
        </trans-unit>
        <trans-unit id="9cfc0aec4bf30e7871d683d9b8ae2997d4838aa1" translate="yes" xml:space="preserve">
          <source>All characters with non-zero canonical combining class are combining characters, but the reverse is not the case: there are combining characters with a zero combining class.</source>
          <target state="translated">Все символы с ненулевым каноническим классом объединения являются комбинациями символов,но обратное не так:есть комбинации символов с нулевым классом объединения.</target>
        </trans-unit>
        <trans-unit id="fa3d4a14790c41d5da46c1de2b8b3d0d867f24e5" translate="yes" xml:space="preserve">
          <source>All classes inherit from a super class. If one is not specified, it inherits from &lt;a href=&quot;https://dlang.org/phobos/object.html#Object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Object&lt;/code&gt; forms the root of the D class inheritance hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb44cae4675a0a5faf9a4d0a4f28a2e8d6e40ac0" translate="yes" xml:space="preserve">
          <source>All classes inherit from a super class. If one is not specified, it inherits from Object. Object forms the root of the D class inheritance hierarchy.</source>
          <target state="translated">Все классы наследуют от супер-класса.Если один из них не указан,то он наследует от Object.Объект формирует корень иерархии наследования классов D.</target>
        </trans-unit>
        <trans-unit id="9bdea0dd8fa982a6717a9259d201dcc03dde23b0" translate="yes" xml:space="preserve">
          <source>All containers have reference semantics, which means that after assignment both variables refer to the same underlying data.</source>
          <target state="translated">Все контейнеры имеют опорную семантику,что означает,что после присваивания обе переменные ссылаются на одни и те же исходные данные.</target>
        </trans-unit>
        <trans-unit id="b52c04d3bf060364790c0c3403f5779dc2a33f11" translate="yes" xml:space="preserve">
          <source>All control characters in the ASCII table (&lt;a href=&quot;https://www.asciitable.com&quot;&gt;source&lt;/a&gt;).</source>
          <target state="translated">Все управляющие символы в таблице ASCII ( &lt;a href=&quot;https://www.asciitable.com&quot;&gt;источник&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c22d531bfa3aab4e678dd7f6e2eb1504810b6d16" translate="yes" xml:space="preserve">
          <source>All elements &lt;code&gt;e&lt;/code&gt; in subrange &lt;code&gt;r[0 .. k]&lt;/code&gt; satisfy &lt;code&gt;!less(r[k], e)&lt;/code&gt; (i.e. &lt;code&gt;r[k]&lt;/code&gt; is greater than or equal to each element to its left according to predicate &lt;code&gt;less&lt;/code&gt;)</source>
          <target state="translated">Все элементы &lt;code&gt;e&lt;/code&gt; в поддиапазоне &lt;code&gt;r[0 .. k]&lt;/code&gt; удовлетворяют &lt;code&gt;!less(r[k], e)&lt;/code&gt; (т. &lt;code&gt;r[k]&lt;/code&gt; больше или равно каждому элементу слева от него согласно предикату &lt;code&gt;less&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4173fedb2ec95e1c7fab071952ccdfb425731d8e" translate="yes" xml:space="preserve">
          <source>All elements &lt;code&gt;e&lt;/code&gt; in subrange &lt;code&gt;r[k .. $]&lt;/code&gt; satisfy &lt;code&gt;!less(e, r[k])&lt;/code&gt; (i.e. &lt;code&gt;r[k]&lt;/code&gt; is less than or equal to each element to its right according to predicate &lt;code&gt;less&lt;/code&gt;)</source>
          <target state="translated">Все элементы &lt;code&gt;e&lt;/code&gt; в поддиапазоне &lt;code&gt;r[k .. $]&lt;/code&gt; удовлетворяют &lt;code&gt;!less(e, r[k])&lt;/code&gt; (т. &lt;code&gt;r[k]&lt;/code&gt; меньше или равно каждому элементу справа от предиката &lt;code&gt;less&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="38e57ca7163a6985d6201556b7ec2361815962f9" translate="yes" xml:space="preserve">
          <source>All elements of the range are checked to be sorted. The check is performed in O(n) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478b4e7b48496f9b1b20465b5132e0e5432d493b" translate="yes" xml:space="preserve">
          <source>All empty nodes which cannot return new memory, are removed from the list.</source>
          <target state="translated">Все пустые узлы,которые не могут вернуть новую память,удаляются из списка.</target>
        </trans-unit>
        <trans-unit id="05c11955f5c3b9e526943e8928fc83cd41d0f45c" translate="yes" xml:space="preserve">
          <source>All errors must be dealt with in some way, either by code explicitly written to handle them, or by some system default handling.</source>
          <target state="translated">Все ошибки должны быть обработаны тем или иным способом,либо кодом,явно написанным для работы с ними,либо обработанным какой-либо системой по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4680cfd395545685306b1b1ceb36045a37266d2f" translate="yes" xml:space="preserve">
          <source>All finer grained error checking is turned on. Address containing errors or warnings is considered invalid. A specific email status code will be returned indicating the error/warning of the address.</source>
          <target state="translated">Включена проверка всех мелкозернистых ошибок.Адрес,содержащий ошибки или предупреждения,считается недействительным.Возвращается специальный код состояния электронной почты с указанием ошибки/предупреждения об адресе.</target>
        </trans-unit>
        <trans-unit id="de02c4a63acb3a5d4f7f587b7e81e74ed2b0de72" translate="yes" xml:space="preserve">
          <source>All floating point types to all string types.</source>
          <target state="translated">Все типы с плавающей точкой для всех типов строк.</target>
        </trans-unit>
        <trans-unit id="79e88b74a9d4c8b35e8dc0b4507253f67ff5fa01" translate="yes" xml:space="preserve">
          <source>All functions, with the exception of &lt;a href=&quot;#expandTilde&quot;&gt;&lt;code&gt;expandTilde&lt;/code&gt;&lt;/a&gt; (and in some cases &lt;a href=&quot;#absolutePath&quot;&gt;&lt;code&gt;absolutePath&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#relativePath&quot;&gt;&lt;code&gt;relativePath&lt;/code&gt;&lt;/a&gt;), are pure string manipulation functions; they don't depend on any state outside the program, nor do they perform any actual file system actions. This has the consequence that the module does not make any distinction between a path that points to a directory and a path that points to a file, and it does not know whether or not the object pointed to by the path actually exists in the file system. To differentiate between these cases, use &lt;a href=&quot;std_file#isDir&quot;&gt;&lt;code&gt;std.file.isDir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_file#exists&quot;&gt;&lt;code&gt;std.file.exists&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Все функции, за исключением &lt;a href=&quot;#expandTilde&quot;&gt; &lt;code&gt;expandTilde&lt;/code&gt; &lt;/a&gt; (а в некоторых случаях &lt;a href=&quot;#absolutePath&quot;&gt; &lt;code&gt;absolutePath&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#relativePath&quot;&gt; &lt;code&gt;relativePath&lt;/code&gt; &lt;/a&gt; ), чистые функции обработки строк; они не зависят от состояния вне программы и не выполняют никаких действий с файловой системой. Это приводит к тому, что модуль не проводит различий между путем, который указывает на каталог, и путем, который указывает на файл, и он не знает, существует ли на самом деле объект, на который указывает путь, в файловой системе. , Чтобы различать эти случаи, используйте &lt;a href=&quot;std_file#isDir&quot;&gt; &lt;code&gt;std.file.isDir&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;std_file#exists&quot;&gt; &lt;code&gt;std.file.exists&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="897231d543ddd436ff3d6ba5df7aae31b8e08c87" translate="yes" xml:space="preserve">
          <source>All hidden parameters bundled.</source>
          <target state="translated">Все скрытые параметры в комплекте.</target>
        </trans-unit>
        <trans-unit id="8f34602fbc14abc9ba9e2e2916d9e6f9be4a8ff7" translate="yes" xml:space="preserve">
          <source>All implementations must support these, even if by just ignoring them:</source>
          <target state="translated">Все реализации должны их поддерживать,даже если они просто игнорируются:</target>
        </trans-unit>
        <trans-unit id="8bbea447a7889fa98476703b1f292c42f34bfb25" translate="yes" xml:space="preserve">
          <source>All information associated with call to log function.</source>
          <target state="translated">Вся информация,связанная с функцией &quot;Вызов в журнал&quot;.</target>
        </trans-unit>
        <trans-unit id="3a29b997591598a8b6cfc336ecadb36fbed66be7" translate="yes" xml:space="preserve">
          <source>All inserts, removes, searches, and any function in general has complexity of &amp;Omicron;(&lt;code&gt;lg(n)&lt;/code&gt;).</source>
          <target state="translated">Все операции вставки, удаления, поиска и любой функции в целом имеют сложность &amp;Omicron; ( &lt;code&gt;lg(n)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dcba16c11981f392657558a8d07f357ce4272a30" translate="yes" xml:space="preserve">
          <source>All interface functions must be defined in a class that inherits from that interface:</source>
          <target state="translated">Все интерфейсные функции должны быть определены в классе,который наследуется от этого интерфейса:</target>
        </trans-unit>
        <trans-unit id="91e8b4ee2b5a17486728589fc5f6cd3d4c03e0e9" translate="yes" xml:space="preserve">
          <source>All keys can be removed by using the method &lt;code&gt;clear&lt;/code&gt;.</source>
          <target state="translated">Все ключи могут быть удалены с помощью метода &lt;code&gt;clear&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd5908b4325dd814d160c014614e871bbfd4828" translate="yes" xml:space="preserve">
          <source>All locks are automatically released when the process terminates.</source>
          <target state="translated">Все блокировки автоматически освобождаются при завершении процесса.</target>
        </trans-unit>
        <trans-unit id="9a9b40a952996bdcd13db98ad39be39296434cf8" translate="yes" xml:space="preserve">
          <source>All matches returned by pattern matching functionality in this library are slices of the original input. The notable exception is the &lt;code&gt;replace&lt;/code&gt; family of functions that generate a new string from the input.</source>
          <target state="translated">Все совпадения, возвращаемые функцией сопоставления с образцом в этой библиотеке, являются фрагментами исходного ввода. Заметным исключением является семейство функций &lt;code&gt;replace&lt;/code&gt; , которое генерирует новую строку из входных данных.</target>
        </trans-unit>
        <trans-unit id="c8490a5c1885e9991535da5cae9171b20351f0f9" translate="yes" xml:space="preserve">
          <source>All member functions of synchronized classes are synchronized. A static member function is synchronized on the</source>
          <target state="translated">Все функции-члены синхронизированных классов синхронизированы.Синхронизация статической функций-членов синхронизируется на</target>
        </trans-unit>
        <trans-unit id="0d2e902a58669b4a70fa2a561fe94c27f74e6b8d" translate="yes" xml:space="preserve">
          <source>All methods inside a class declared as &lt;code&gt;extern (Objective-C)&lt;/code&gt; will get implicit Objective-C linkage.</source>
          <target state="translated">Все методы внутри класса, объявленного как &lt;code&gt;extern (Objective-C)&lt;/code&gt; , получат неявную связь Objective-C.</target>
        </trans-unit>
        <trans-unit id="b366095400babb69322d711aa921d268cfb35ea8" translate="yes" xml:space="preserve">
          <source>All numbers in [-&amp;infin;, +&amp;infin;] are ordered the same way as by built-in comparison, with the exception of -0.0, which is less than +0.0;</source>
          <target state="translated">Все числа в [-&amp;infin;, + &amp;infin;] упорядочены так же, как при встроенном сравнении, за исключением -0.0, что меньше +0.0;</target>
        </trans-unit>
        <trans-unit id="cf2fb5f601f3c7c74aa1d7bc5d26857dd697e304" translate="yes" xml:space="preserve">
          <source>All of its inputs are assumed to be sorted. This can mean that inputs are instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;. Use the result of &lt;a href=&quot;std_algorithm_sorting#sort&quot;&gt;&lt;code&gt; std.algorithm.sorting.sort&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_range#assumeSorted&quot;&gt;&lt;code&gt;std.range.assumeSorted&lt;/code&gt;&lt;/a&gt; to merge ranges known to be sorted (show in the example below). Note that there is currently no way of ensuring that two or more instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt; std.range.SortedRange&lt;/code&gt;&lt;/a&gt; are sorted using a specific comparison function &lt;code&gt;pred&lt;/code&gt;. Therefore no checking is done here to assure that all inputs &lt;code&gt;rs&lt;/code&gt; are instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Предполагается, что все входные данные отсортированы. Это может означать, что входные данные являются экземплярами &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; &lt;/a&gt; . Используйте результат &lt;a href=&quot;std_algorithm_sorting#sort&quot;&gt; &lt;code&gt; std.algorithm.sorting.sort&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;std_range#assumeSorted&quot;&gt; &lt;code&gt;std.range.assumeSorted&lt;/code&gt; &lt;/a&gt; для объединения диапазонов, о которых известно, что они отсортированы (см. Пример ниже). Обратите внимание, что в настоящее время нет способа обеспечить сортировку двух или более экземпляров &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt; std.range.SortedRange&lt;/code&gt; &lt;/a&gt; с использованием определенной функции сравнения &lt;code&gt;pred&lt;/code&gt; . Поэтому проверка не делается здесь , чтобы гарантировать , что все входы &lt;code&gt;rs&lt;/code&gt; являются экземплярами &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7760c023d07d36fdca08004de575b3be6fcb979d" translate="yes" xml:space="preserve">
          <source>All of the functions in std.ascii accept Unicode characters but effectively ignore them if they're not ASCII. All &lt;code&gt;isX&lt;/code&gt; functions return &lt;code&gt;false&lt;/code&gt; for non-ASCII characters, and all &lt;code&gt;toX&lt;/code&gt; functions do nothing to non-ASCII characters.</source>
          <target state="translated">Все функции в std.ascii принимают символы Unicode, но фактически игнорируют их, если они не ASCII. Все функции &lt;code&gt;isX&lt;/code&gt; возвращают &lt;code&gt;false&lt;/code&gt; для символов не ASCII, а все функции &lt;code&gt;toX&lt;/code&gt; ничего не делают для символов не ASCII.</target>
        </trans-unit>
        <trans-unit id="406700e1b4c5b2a9f03e14707a386766e7ff13f4" translate="yes" xml:space="preserve">
          <source>All of the standard numeric operators are defined for the UUID struct.</source>
          <target state="translated">Для структуры UUID определены все стандартные числовые операторы.</target>
        </trans-unit>
        <trans-unit id="3100bf25a966348766069acc9d7aec1ceec953c8" translate="yes" xml:space="preserve">
          <source>All of these UUID versions can be read and processed by &lt;code&gt;std.uuid&lt;/code&gt;, but only version 3, 4 and 5 UUIDs can be generated.</source>
          <target state="translated">Все эти версии UUID могут быть прочитаны и обработаны &lt;code&gt;std.uuid&lt;/code&gt; , но могут быть сгенерированы только UUID версии 3, 4 и 5.</target>
        </trans-unit>
        <trans-unit id="502d87114b09889db456bdf9177fc6f3f3031b7f" translate="yes" xml:space="preserve">
          <source>All of these functions come in two varieties: one takes a target element, where the range will be stripped as long as this element can be found. The other takes a lambda predicate, where the range will be stripped as long as the predicate returns true.</source>
          <target state="translated">Все эти функции поставляются в двух вариантах:один берет целевой элемент,где диапазон будет сниматься до тех пор,пока этот элемент может быть найден.Другая принимает предикат лямбда,где диапазон будет отсекаться до тех пор,пока предикат вернется в истинное состояние.</target>
        </trans-unit>
        <trans-unit id="821e98543b08c50cacab703f8d367d6710ccef75" translate="yes" xml:space="preserve">
          <source>All other BSDs</source>
          <target state="translated">Все остальные BSD</target>
        </trans-unit>
        <trans-unit id="525589d86507196876f47dbab5c78a69ecfdd718" translate="yes" xml:space="preserve">
          <source>All other cases of aliasing are considered unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd68fd410f45079b0d7aa364b641219999200191" translate="yes" xml:space="preserve">
          <source>All possible error codes from all sorts of curl functions. Future versions may return other values, stay prepared.</source>
          <target state="translated">Все возможные коды ошибок от всевозможных фигурных функций.Будущие версии могут возвращать другие значения,оставайтесь наготове.</target>
        </trans-unit>
        <trans-unit id="136fb65faf8ab2a2cf368736fd6aeb99f8c344fd" translate="yes" xml:space="preserve">
          <source>All possible options</source>
          <target state="translated">Все возможные варианты</target>
        </trans-unit>
        <trans-unit id="b813b3d5035d2aa3a990bcb3215de8f25be6e30e" translate="yes" xml:space="preserve">
          <source>All primitives listed operate on Unicode characters and sets of characters. For functions which operate on ASCII characters and ignore Unicode &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;, see &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;. For definitions of Unicode &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; and other terms used throughout this module see the &lt;a href=&quot;#Terminology&quot;&gt;terminology&lt;/a&gt; section below.</source>
          <target state="translated">Все перечисленные примитивы работают с символами Unicode и наборами символов. Для функций , которые действуют на ASCII символов и игнорировать Unicode &lt;a href=&quot;#Character&quot;&gt;символы&lt;/a&gt; , см &lt;a href=&quot;std_ascii&quot;&gt; &lt;code&gt;std.ascii&lt;/code&gt; &lt;/a&gt; . Для определения Unicode &lt;a href=&quot;#Character&quot;&gt;символа&lt;/a&gt; , &lt;a href=&quot;#Code%20point&quot;&gt;код точки&lt;/a&gt; и другие термины , используемые в этом модуле см &lt;a href=&quot;#Terminology&quot;&gt;терминологической&lt;/a&gt; раздел ниже.</target>
        </trans-unit>
        <trans-unit id="6c8a2e2c452533012af5af53a5f2117564ba54d2" translate="yes" xml:space="preserve">
          <source>All programs have to deal with errors. Errors are unexpected conditions that are not part of the normal operation of a program. Examples of common errors are:</source>
          <target state="translated">Все программы должны справляться с ошибками.Ошибки-это неожиданные условия,которые не являются частью нормальной работы программы.Примеры распространенных ошибок:</target>
        </trans-unit>
        <trans-unit id="c20c0313c3654dcf38a230e6a0ac8e51f952d657" translate="yes" xml:space="preserve">
          <source>All reading from &lt;code&gt;stdin&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;read&lt;/code&gt; to wait until the lock is released.</source>
          <target state="translated">Все чтение из &lt;code&gt;stdin&lt;/code&gt; автоматически блокирует файл глобально, и все остальные потоки, вызывающие &lt;code&gt;read&lt;/code&gt; , будут ждать, пока не будет снята блокировка.</target>
        </trans-unit>
        <trans-unit id="f9df267cdc9ad11425ae578a49e8b8411f22249c" translate="yes" xml:space="preserve">
          <source>All sections for the module are combined.</source>
          <target state="translated">Все секции модуля объединены.</target>
        </trans-unit>
        <trans-unit id="4fe809ffea83f91ee87860fb09bce9898a2380b1" translate="yes" xml:space="preserve">
          <source>All static fields in this struct represents a specific predefined symbol.</source>
          <target state="translated">Все статические поля в этой структуре представляют собой определенный предопределенный символ.</target>
        </trans-unit>
        <trans-unit id="9dfd9dd3cf17f876b6f44df68cf586485cbe563b" translate="yes" xml:space="preserve">
          <source>All stats of the form &lt;code&gt;numXxx&lt;/code&gt; record counts of events occurring, such as calls to functions and specific results. The stats of the form &lt;code&gt;bytesXxx&lt;/code&gt; collect cumulative sizes.</source>
          <target state="translated">Вся статистика вида &lt;code&gt;numXxx&lt;/code&gt; записывает количество происходящих событий, таких как вызовы функций и конкретные результаты. Статистика формы &lt;code&gt;bytesXxx&lt;/code&gt; собирает совокупные размеры.</target>
        </trans-unit>
        <trans-unit id="3aeac5247fab94056a2fcd9ae2ebfe7ce2a4741c" translate="yes" xml:space="preserve">
          <source>All steps combined look like this:</source>
          <target state="translated">Все шаги вместе выглядят вот так:</target>
        </trans-unit>
        <trans-unit id="73e1d82508097f721dc5f94481ae54c7c96a5506" translate="yes" xml:space="preserve">
          <source>All symbols from a publicly imported module are also aliased in the importing module. Thus in the above example if C contains the name foo, it will be accessible in A as &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;B.foo&lt;/code&gt; and &lt;code&gt;C.foo&lt;/code&gt;.</source>
          <target state="translated">Все символы из публично импортированного модуля также являются псевдонимами в импортирующем модуле. Таким образом, в приведенном выше примере, если C содержит имя foo, оно будет доступно в A как &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;B.foo&lt;/code&gt; и &lt;code&gt;C.foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a81b5e33e5d9b6fed4225267f1379628464786b1" translate="yes" xml:space="preserve">
          <source>All symbols within &lt;code&gt;symbol&lt;/code&gt; that have the given UDA &lt;code&gt;attribute&lt;/code&gt;.</source>
          <target state="translated">Все символы в &lt;code&gt;symbol&lt;/code&gt; которые имеют данный &lt;code&gt;attribute&lt;/code&gt; UDA .</target>
        </trans-unit>
        <trans-unit id="20ecb571750aace44511ab3cf936eb97eef093c5" translate="yes" xml:space="preserve">
          <source>All the binary operators work in their assignment version</source>
          <target state="translated">Все двоичные операторы работают в своей версии назначения</target>
        </trans-unit>
        <trans-unit id="5c26e98bb72bebc86ceca75d9e5603b6bdd8c8eb" translate="yes" xml:space="preserve">
          <source>All the members of the archive can be accessed with a foreach loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0de63de936b7274b430f7f3c7c61353d4b4b65" translate="yes" xml:space="preserve">
          <source>All the properties of the &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; work.</source>
          <target state="translated">Все свойства &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; работают.</target>
        </trans-unit>
        <trans-unit id="97efa5a26947938bb903257f0409a1c26a039cd2" translate="yes" xml:space="preserve">
          <source>All the static constructors for a module are aggregated into a single function, and a pointer to that function is inserted into the ctor member of the ModuleInfo instance for that module.</source>
          <target state="translated">Все статические конструкторы для модуля объединяются в одну функцию,и указатель на эту функцию вставляется в ctor-член экземпляра ModuleInfo для этого модуля.</target>
        </trans-unit>
        <trans-unit id="2b0681a718887d97ad7ee984aa0510556a949ead" translate="yes" xml:space="preserve">
          <source>All the static denstructors for a module are aggregated into a single function, and a pointer to that function is inserted into the dtor member of the ModuleInfo instance for that module.</source>
          <target state="translated">Все статические денструкторы для модуля объединяются в одну функцию,и указатель на эту функцию вставляется в dtor-член экземпляра ModuleInfo для этого модуля.</target>
        </trans-unit>
        <trans-unit id="15236deff34ae39943ca5f31e8d24cf0e03855cc" translate="yes" xml:space="preserve">
          <source>All the unit tests for a module are aggregated into a single function, and a pointer to that function is inserted into the unitTest member of the ModuleInfo instance for that module.</source>
          <target state="translated">Все юнит-тесты для модуля объединяются в одну функцию,и указатель на эту функцию вставляется в юнит-тест члена экземпляра ModuleInfo для этого модуля.</target>
        </trans-unit>
        <trans-unit id="f949da684991e66b76cb0131b05508ca1cb634cb" translate="yes" xml:space="preserve">
          <source>All those destructors freeing memory can become significant when objects are allocated on the stack. For each one, some mechanism must be established so that if an exception happens, the destructors all get called in each frame to release any memory they hold. If the destructors become irrelevant, then there's no need to set up special stack frames to handle exceptions, and the code runs faster.</source>
          <target state="translated">Все эти деструкторы,освобождающие память,могут стать значительными при выделении объектов на стеке.Для каждого из них должен быть установлен какой-то механизм,чтобы в случае возникновения исключения в каждом кадре вызывались все деструкторы,освобождающие память,которую они содержат.Если деструкторы становятся неактуальными,то нет необходимости устанавливать специальные кадры стека для работы с исключениями,и код выполняется быстрее.</target>
        </trans-unit>
        <trans-unit id="c628520ddca4f269f1a2425393dd896bb6ecd64f" translate="yes" xml:space="preserve">
          <source>All thrown objects must inherit from Throwable. Class &lt;code&gt;Exception&lt;/code&gt;, which derives from this class, represents the category of thrown objects that are safe to catch and handle. In principle, one should not catch Throwable objects that are not derived from &lt;code&gt;Exception&lt;/code&gt;, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</source>
          <target state="translated">Все брошенные объекты должны наследоваться от Throwable. &lt;code&gt;Exception&lt;/code&gt; класса , производное от этого класса, представляет категорию брошенных объектов, которые безопасно перехватывать и обрабатывать. В принципе, не следует перехватывать объекты Throwable, которые не являются производными от &lt;code&gt;Exception&lt;/code&gt; , поскольку они представляют собой неисправимые ошибки времени выполнения. Некоторые гарантии времени выполнения могут не сохраняться при возникновении этих ошибок, что делает небезопасным продолжение выполнения после их перехвата.</target>
        </trans-unit>
        <trans-unit id="d57ed726e64ba51ae7c15a7975e045226435204a" translate="yes" xml:space="preserve">
          <source>All writing to &lt;code&gt;stderr&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;write&lt;/code&gt; to wait until the lock is released.</source>
          <target state="translated">Вся запись в &lt;code&gt;stderr&lt;/code&gt; автоматически блокирует файл глобально, и все другие потоки, вызывающие &lt;code&gt;write&lt;/code&gt; будут ждать, пока не будет снята блокировка.</target>
        </trans-unit>
        <trans-unit id="645f93cabf6576decf07a138ca4abf26edcd1dfb" translate="yes" xml:space="preserve">
          <source>All writing to &lt;code&gt;stdout&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;write&lt;/code&gt; to wait until the lock is released.</source>
          <target state="translated">Вся запись в стандартный &lt;code&gt;stdout&lt;/code&gt; автоматически блокирует файл глобально, и все другие потоки, вызывающие &lt;code&gt;write&lt;/code&gt; будут ждать, пока не будет снята блокировка.</target>
        </trans-unit>
        <trans-unit id="1b093a504d859edb011aa4c10e43272d307e7616" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;n&lt;/code&gt; bytes of memory. If &lt;code&gt;n&lt;/code&gt; is eligible for freelist and the freelist is not empty, pops the memory off the free list. In all other cases, uses the parent allocator.</source>
          <target state="translated">Выделите &lt;code&gt;n&lt;/code&gt; байтов памяти. Если &lt;code&gt;n&lt;/code&gt; имеет право на свободный список, и свободный список не пуст, вынимает память из свободного списка. Во всех остальных случаях используется родительский распределитель.</target>
        </trans-unit>
        <trans-unit id="cb204135b1e21acae9320219240e8e87e6f65b6f" translate="yes" xml:space="preserve">
          <source>Allocate a block of size &lt;code&gt;s&lt;/code&gt; with alignment &lt;code&gt;a&lt;/code&gt;. First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling &lt;code&gt;make(s + a - 1)&lt;/code&gt; and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to &lt;code&gt;alignedAllocate&lt;/code&gt; will not cause more calls to &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">Выделите блок размером &lt;code&gt;s&lt;/code&gt; с выравниванием &lt;code&gt;a&lt;/code&gt; . Сначала пытается выделить из существующего списка уже созданных распределителей. Если ни один из них не может удовлетворить запрос, создает новый распределитель путем вызова &lt;code&gt;make(s + a - 1)&lt;/code&gt; и делегирует запрос ему. Тем не менее, если распределение свежего от вновь созданного распределителя терпит неудачу, последующие вызовы &lt;code&gt;alignedAllocate&lt;/code&gt; не вызовут больше вызовов для &lt;code&gt;make&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b869869fcf623a87d8a6cf55943a9b074f4092" translate="yes" xml:space="preserve">
          <source>Allocate a block of size &lt;code&gt;s&lt;/code&gt;. First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling &lt;code&gt;make(s)&lt;/code&gt; and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to &lt;code&gt;allocate&lt;/code&gt; will not cause more calls to &lt;code&gt; make&lt;/code&gt;.</source>
          <target state="translated">Выделите блок размером &lt;code&gt;s&lt;/code&gt; . Сначала пытается выделить из существующего списка уже созданных распределителей. Если ни один из них не может удовлетворить запрос, создает новый распределитель путем вызова &lt;code&gt;make(s)&lt;/code&gt; и делегирует запрос ему. Тем не менее, если распределение свежего от вновь созданного распределителя не удается, последующие вызовы &lt;code&gt;allocate&lt;/code&gt; не будет вызывать больше звонков , чтобы &lt;code&gt; make&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e3ac4a0a39edc956251dca78db0c555e763550a" translate="yes" xml:space="preserve">
          <source>Allocate a new array of length elements. ti is the type of the resulting array, or pointer to element. (For when the array is initialized to 0)</source>
          <target state="translated">Выделяет новый массив элементов длины.ti-это тип результирующего массива,или указатель на элемент.(Для случая,когда массив инициализирован на 0).</target>
        </trans-unit>
        <trans-unit id="04a5579ec9d9ea7bf8fd9194782b75e61153d45c" translate="yes" xml:space="preserve">
          <source>Allocate a new uninitialized array of length elements. ti is the type of the resulting array, or pointer to element.</source>
          <target state="translated">Выделяет новый неинициализированный массив элементов длины.ti-это тип результирующего массива,или указатель на элемент.</target>
        </trans-unit>
        <trans-unit id="4addc8952362210dbd4d01899c0184f19033db2f" translate="yes" xml:space="preserve">
          <source>Allocate a new variable via xmalloc that can be added to the global environment. The resulting string will be null-terminated immediately after the end of the array.</source>
          <target state="translated">Выделение новой переменной через xmalloc,которая может быть добавлена в глобальное окружение.Полученная строка будет обнулена сразу после окончания массива.</target>
        </trans-unit>
        <trans-unit id="f5ae03eb0a1a6cb0d88d14fb5a3b4d6ad0ebf542" translate="yes" xml:space="preserve">
          <source>Allocate an exception of type &lt;code&gt;ci&lt;/code&gt; from the exception pool. It has the same interface as &lt;code&gt;rt.lifetime._d_newclass()&lt;/code&gt;. The class type must be Throwable or derived from it, and cannot be a COM or C++ class. The compiler must enforce this.</source>
          <target state="translated">Выделите исключение типа &lt;code&gt;ci&lt;/code&gt; из пула исключений. Он имеет тот же интерфейс, что и &lt;code&gt;rt.lifetime._d_newclass()&lt;/code&gt; . Тип класса должен быть Throwable или производным от него и не может быть классом COM или C ++. Компилятор должен обеспечить это.</target>
        </trans-unit>
        <trans-unit id="b15ff176dde037c8eec0c32aab20116e3b618dd6" translate="yes" xml:space="preserve">
          <source>Allocate an instance of the class, &lt;code&gt;NSString&lt;/code&gt;.</source>
          <target state="translated">Выделите экземпляр класса, &lt;code&gt;NSString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74612396c30d0c63cc046cd3b14fa2fd0d0f12bd" translate="yes" xml:space="preserve">
          <source>Allocate an uninitialized non-array item. This is an optimization to avoid things needed for arrays like the _arrayPad(size).</source>
          <target state="translated">Выделите неинициализированный предмет без массива.Это оптимизация,чтобы избежать таких вещей,необходимых для массивов,как _arrayPad(size).</target>
        </trans-unit>
        <trans-unit id="690211495bdf02fe74267eebc1c68112cdf01cf1" translate="yes" xml:space="preserve">
          <source>Allocate and fill in ctors[] and tlsctors[]. Modules are inserted into the arrays in the order in which the constructors need to be run.</source>
          <target state="translated">Распределите и заполните ctors[]и tlsctors[].Модули вставляются в массивы в порядке,в котором необходимо запускать конструкторы.</target>
        </trans-unit>
        <trans-unit id="546305171dde7bde4a1c7bbf4dee4fc391ed9224" translate="yes" xml:space="preserve">
          <source>Allocate and initialize an ExceptionHeader.</source>
          <target state="translated">Назначьте и инициализируйте ExceptionHeader.</target>
        </trans-unit>
        <trans-unit id="152c2032835fcd0df6e709b46cbe62f6b6cd7102" translate="yes" xml:space="preserve">
          <source>Allocate data from the caller's stack frame. This is a 'magic' function that needs help from the compiler to work right, do not change its name, do not call it from other compilers.</source>
          <target state="translated">Распределите данные из стека вызывающего абонента.Это &quot;волшебная&quot; функция,которая нуждается в помощи компилятора,чтобы работать правильно,не менять ее название,не вызывать ее из других компиляторов.</target>
        </trans-unit>
        <trans-unit id="7bcab4c37e278570affa71300f593890c5082f0a" translate="yes" xml:space="preserve">
          <source>Allocate the array, rely on the caller to do the initialization of the array.</source>
          <target state="translated">Выделите массив,положитесь на вызывающего абонента для выполнения инициализации массива.</target>
        </trans-unit>
        <trans-unit id="ae51d44518dcf6c4431053abbfb74d465f5558a1" translate="yes" xml:space="preserve">
          <source>Allocated blocks do not hold a size prefix. This is because in D the size information is available in client code at deallocation time.</source>
          <target state="translated">Распределенные блоки не содержат префикса размера.Это связано с тем,что в D информация о размере доступна в коде клиента во время проведения сделки.</target>
        </trans-unit>
        <trans-unit id="cb1dd4282b618235f704ba742fef6168e8279026" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;bytes&lt;/code&gt; and returns them, or &lt;code&gt;null&lt;/code&gt; if the region cannot accommodate the request. For efficiency reasons, if &lt;code&gt;bytes == 0&lt;/code&gt; the function returns an empty non-null slice.</source>
          <target state="translated">Выделяет &lt;code&gt;bytes&lt;/code&gt; и возвращает их, или &lt;code&gt;null&lt;/code&gt; если область не может удовлетворить запрос. По соображениям эффективности, если &lt;code&gt;bytes == 0&lt;/code&gt; функция возвращает пустой ненулевой срез.</target>
        </trans-unit>
        <trans-unit id="dd1ff9ea9b54d782b4a1fa925149d8ee9eefd67e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory aligned at alignment &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Выделяет &lt;code&gt;n&lt;/code&gt; байтов памяти, выровненных при выравнивании &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a919f47db37669617faab9ea6d5ad732011e85df" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory with specified alignment &lt;code&gt;a&lt;/code&gt;. Implementations that do not support this primitive should always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Выделяет &lt;code&gt;n&lt;/code&gt; байтов памяти с указанным выравниванием &lt;code&gt;a&lt;/code&gt; . Реализации, которые не поддерживают этот примитив, всегда должны возвращать &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3556f444ee3e01e4ff6b4c12964c1a5b8dc14fca" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory.</source>
          <target state="translated">Выделяет &lt;code&gt;n&lt;/code&gt; байтов памяти.</target>
        </trans-unit>
        <trans-unit id="571906ff58f2c345c55fece0c6b4680a0d168821" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. First consults the free tree, and returns from it if a suitably sized block is found. Otherwise, the parent allocator is tried. If allocation from the parent succeeds, the allocated block is returned. Otherwise, the free tree tries an alternate strategy: If &lt;code&gt; ParentAllocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;FreeTree&lt;/code&gt; releases all of its contents and tries again.</source>
          <target state="translated">Выделяет &lt;code&gt;n&lt;/code&gt; байтов памяти. Сначала обращается к свободному дереву и возвращает его, если найден блок подходящего размера. В противном случае родительский распределитель используется. Если выделение от родителя завершается успешно, выделенный блок возвращается. В противном случае свободное дерево пробует альтернативную стратегию: если &lt;code&gt; ParentAllocator&lt;/code&gt; определяет &lt;code&gt;deallocate&lt;/code&gt; , &lt;code&gt;FreeTree&lt;/code&gt; освобождает все свое содержимое и пытается снова.</target>
        </trans-unit>
        <trans-unit id="e2b3a385e46b9ac83e94af9618c4d1619a61f273" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. The allocation is served by atomically incrementing a pointer which keeps track of the current used space.</source>
          <target state="translated">Выделяет &lt;code&gt;n&lt;/code&gt; байтов памяти. Выделение осуществляется путем атомарного увеличения указателя, который отслеживает текущее используемое пространство.</target>
        </trans-unit>
        <trans-unit id="545e4bfeb16f8477990d8181bb9178281843dd98" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. The shortest path involves an alignment adjustment (if &lt;code&gt;alignment &amp;gt; 1&lt;/code&gt;), an increment, and a comparison.</source>
          <target state="translated">Выделяет &lt;code&gt;n&lt;/code&gt; байтов памяти. Кратчайший путь включает в себя настройку выравнивания (если &lt;code&gt;alignment &amp;gt; 1&lt;/code&gt; ), приращение и сравнение.</target>
        </trans-unit>
        <trans-unit id="2936608c36ed9f5713be515def45d248186393f0" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes. Allocation searches the list of available blocks until a free block with &lt;code&gt;n&lt;/code&gt; or more bytes is found (first fit strategy). The block is split (if larger) and returned.</source>
          <target state="translated">Выделяет &lt;code&gt;n&lt;/code&gt; байтов. Распределение ищет список доступных блоков до тех пор, пока не будет найден свободный блок с &lt;code&gt;n&lt;/code&gt; или более байтами (стратегия первого соответствия). Блок разделяется (если больше) и возвращается.</target>
        </trans-unit>
        <trans-unit id="b627f8a5a1e78d575daa227732620caf9398d99d" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated.</source>
          <target state="translated">Выделяет &lt;code&gt;s&lt;/code&gt; байтов памяти и возвращает ее, или &lt;code&gt;null&lt;/code&gt; если память не может быть выделена.</target>
        </trans-unit>
        <trans-unit id="955f82f1f9371d9a1a5f44a9d6884b1bf06878cf" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;class&lt;/code&gt; object right inside the current scope, therefore avoiding the overhead of &lt;code&gt;new&lt;/code&gt;. This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope.</source>
          <target state="translated">Выделяет объект &lt;code&gt;class&lt;/code&gt; прямо внутри текущей области видимости, поэтому избегая накладных расходов &lt;code&gt;new&lt;/code&gt; . Этот объект небезопасен; пользователь несет ответственность за то, чтобы не избежать ссылки на объект вне области видимости.</target>
        </trans-unit>
        <trans-unit id="2d0bc107a98ee07d1d72bbabf6107748dcbf6e02" translate="yes" xml:space="preserve">
          <source>Allocates a block with specified alignment &lt;code&gt;a&lt;/code&gt;. The alignment must be a power of 2. If &lt;code&gt;a &amp;lt;= alignment&lt;/code&gt;, function forwards to &lt;code&gt;allocate&lt;/code&gt;. Otherwise, it attempts to overallocate and then adjust the result for proper alignment. In the worst case the slack memory is around two blocks.</source>
          <target state="translated">Выделяет блок с указанным выравниванием &lt;code&gt;a&lt;/code&gt; . Выравнивание должно быть степенью 2. Если &lt;code&gt;a &amp;lt;= alignment&lt;/code&gt; , функция пересылки для &lt;code&gt;allocate&lt;/code&gt; . В противном случае он пытается перераспределить, а затем скорректировать результат для правильного выравнивания. В худшем случае слабая память составляет около двух блоков.</target>
        </trans-unit>
        <trans-unit id="333f797e4d1750e2dc2dd943bcec484cf81e4464" translate="yes" xml:space="preserve">
          <source>Allocates a multidimensional array of elements of type T.</source>
          <target state="translated">Выделяет многомерный массив элементов типа T.</target>
        </trans-unit>
        <trans-unit id="2ef2526b1e1b8c72e2349064073c5f4e36bc9e05" translate="yes" xml:space="preserve">
          <source>Allocates a new array which is identical to &lt;code&gt;s&lt;/code&gt; except that all of its characters are converted to uppercase (by preforming Unicode uppercase mapping). If none of &lt;code&gt;s&lt;/code&gt; characters were affected, then &lt;code&gt;s&lt;/code&gt; itself is returned if &lt;code&gt;s&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;-like type.</source>
          <target state="translated">Выделяет новый массив, который идентичен &lt;code&gt;s&lt;/code&gt; , за исключением того, что все его символы преобразуются в верхний регистр (путем преобразования в верхний регистр Unicode). Если ни один из символов &lt;code&gt;s&lt;/code&gt; не был затронут, тогда возвращается само &lt;code&gt;s&lt;/code&gt; , если &lt;code&gt;s&lt;/code&gt; является &lt;code&gt;string&lt;/code&gt; типом.</target>
        </trans-unit>
        <trans-unit id="a5aaa9a811057230aa95580332ee9fece9148d7e" translate="yes" xml:space="preserve">
          <source>Allocates all memory available to this allocator. If the allocator is empty, returns the entire available block of memory. Otherwise, it still performs a best-effort allocation: if there is no fragmentation (e.g. &lt;code&gt;allocate&lt;/code&gt; has been used but not &lt;code&gt;deallocate&lt;/code&gt;), allocates and returns the only available block of memory.</source>
          <target state="translated">Выделяет всю память, доступную для этого распределителя. Если распределитель пуст, возвращает весь доступный блок памяти. В противном случае он по-прежнему выполняет распределение с максимальным усилием: если нет фрагментации (например, используется &lt;code&gt;allocate&lt;/code&gt; , но не &lt;code&gt;deallocate&lt;/code&gt; ), выделяет и возвращает единственный доступный блок памяти.</target>
        </trans-unit>
        <trans-unit id="affe2fcdb8093269677afa8f01518ff0ce594273" translate="yes" xml:space="preserve">
          <source>Allocates all memory available with this allocator.</source>
          <target state="translated">Выделяет всю память,доступную с этим аллокатором.</target>
        </trans-unit>
        <trans-unit id="457c8670d7db9f415c2c631b04bc7df87f7a8ce8" translate="yes" xml:space="preserve">
          <source>Allocates an array and initializes it with copies of the elements of range &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Выделяет массив и инициализирует его копиями элементов диапазона &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e31ee88595be1a4376af43d499352d1f95ed61d8" translate="yes" xml:space="preserve">
          <source>Allocates and returns all memory available to this allocator. Implementations that do not support this primitive should always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Выделяет и возвращает всю память, доступную этому распределителю. Реализации, которые не поддерживают этот примитив, всегда должны возвращать &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a3681eb538dd63a79378153545a077147ef7123" translate="yes" xml:space="preserve">
          <source>Allocates and returns all memory available to this region.</source>
          <target state="translated">Выделяет и возвращает всю доступную для этого региона память.</target>
        </trans-unit>
        <trans-unit id="2b750fd7da093b1e747e05812152ef8c3fccbd77" translate="yes" xml:space="preserve">
          <source>Allocates in coarse-grained quantas, thus improving performance of reallocations by often reallocating in place. The drawback is higher memory consumption because of allocated and unused memory.</source>
          <target state="translated">Распределяется в крупнозернистых квантах,улучшая тем самым эффективность перераспределений за счет частого перераспределения на месте.Недостатком является более высокое потребление памяти за счет выделенной и неиспользуемой памяти.</target>
        </trans-unit>
        <trans-unit id="70331dfb1a6e6d60011fcc4d4e71ab51d10775b6" translate="yes" xml:space="preserve">
          <source>Allocates memory either off of the free list or from the parent allocator. If &lt;code&gt;n&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then the free list is consulted first. If not empty (hit), the block at the front of the free list is removed from the list and returned. Otherwise (miss), a new block of &lt;code&gt;max&lt;/code&gt; bytes is allocated, truncated to &lt;code&gt;n&lt;/code&gt; bytes, and returned.</source>
          <target state="translated">Выделяет память либо из свободного списка, либо из родительского распределителя. Если &lt;code&gt;n&lt;/code&gt; находится в пределах &lt;code&gt;[min, max]&lt;/code&gt; или если свободный список не проверен ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ), то сначала проверяется свободный список. Если не пустой (хит), блок в начале списка свободных удаляется из списка и возвращается. В противном случае (промах), новый блок из &lt;code&gt;max&lt;/code&gt; байтов выделяется, усекается до &lt;code&gt;n&lt;/code&gt; байтов и возвращается.</target>
        </trans-unit>
        <trans-unit id="22f9e74278651d99027c27c713ac855e8ed1e715" translate="yes" xml:space="preserve">
          <source>Allocates memory trying the primary allocator first. If it returns &lt;code&gt; null&lt;/code&gt;, the fallback allocator is tried.</source>
          <target state="translated">Выделяет память, пробуя первичный распределитель первым. Если он возвращает &lt;code&gt; null&lt;/code&gt; , используется резервный распределитель.</target>
        </trans-unit>
        <trans-unit id="b925b0b6c371d9f54077bbba76c9a1da1602d6a9" translate="yes" xml:space="preserve">
          <source>Allocates memory. For management it actually allocates extra memory from the parent.</source>
          <target state="translated">Распределяет память.Для управления она фактически выделяет дополнительную память от родителя.</target>
        </trans-unit>
        <trans-unit id="575ca88081327e09f680960a4110bc8ba17a9371" translate="yes" xml:space="preserve">
          <source>Allocates memory; use &lt;a href=&quot;#lineSplitter&quot;&gt;&lt;code&gt;lineSplitter&lt;/code&gt;&lt;/a&gt; for an alternative that does not.</source>
          <target state="translated">Выделяет память; используйте &lt;a href=&quot;#lineSplitter&quot;&gt; &lt;code&gt;lineSplitter&lt;/code&gt; &lt;/a&gt; для альтернативы, которая этого не делает.</target>
        </trans-unit>
        <trans-unit id="ee6c6f7e81d98e5543bf32244a9bf50d0d1defcc" translate="yes" xml:space="preserve">
          <source>Allocates s bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated. &lt;code&gt;allocateFresh&lt;/code&gt; behaves just like allocate, the only difference being that this always returns unused(fresh) memory. Although there may still be available space in the &lt;code&gt;BitmappedBlock&lt;/code&gt;, &lt;code&gt;allocateFresh&lt;/code&gt; could still return null, because all the available blocks have been previously deallocated.</source>
          <target state="translated">Выделяет s байтов памяти и возвращает ее, или &lt;code&gt;null&lt;/code&gt; если память не может быть выделена. &lt;code&gt;allocateFresh&lt;/code&gt; ведет себя так же, как allocate, с той лишь разницей, что он всегда возвращает неиспользованную (свежую) память. Хотя по - прежнему может быть свободным место в &lt;code&gt;BitmappedBlock&lt;/code&gt; , &lt;code&gt;allocateFresh&lt;/code&gt; еще может вернуться нуль, поскольку все доступные блоки были ранее освобожденному.</target>
        </trans-unit>
        <trans-unit id="40d52c59404ae014d74089cf6166317c2d5cca72" translate="yes" xml:space="preserve">
          <source>Allocates s bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated. &lt;code&gt;allocateFresh&lt;/code&gt; behaves just like allocate, the only difference being that this always returns unused(fresh) memory. Although there may still be available space in the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt;, &lt;code&gt;allocateFresh&lt;/code&gt; could still return null, because all the available blocks have been previously deallocated.</source>
          <target state="translated">Выделяет s байтов памяти и возвращает ее, или &lt;code&gt;null&lt;/code&gt; если память не может быть выделена. &lt;code&gt;allocateFresh&lt;/code&gt; ведет себя так же, как allocate, с той лишь разницей, что он всегда возвращает неиспользованную (свежую) память. Хотя по - прежнему может быть свободным место в &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; , &lt;code&gt;allocateFresh&lt;/code&gt; еще может вернуться нуль, поскольку все доступные блоки были ранее освобожденному.</target>
        </trans-unit>
        <trans-unit id="34562b2c1efcd9772eb4d939efa35b8757f6170e" translate="yes" xml:space="preserve">
          <source>Allocates the requested &lt;code&gt;bytes&lt;/code&gt; of memory with specified &lt;code&gt;alignment&lt;/code&gt;. Directs the call to either one of the &lt;code&gt;buckets&lt;/code&gt; allocators. Defined only if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;alignedAllocate&lt;/code&gt;.</source>
          <target state="translated">Выделяет запрошенные &lt;code&gt;bytes&lt;/code&gt; памяти с указанным &lt;code&gt;alignment&lt;/code&gt; . Направляет вызов одному из распределителей &lt;code&gt;buckets&lt;/code&gt; памяти. Определяется только если &lt;code&gt;Allocator&lt;/code&gt; определяет &lt;code&gt;alignedAllocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc90ab9b460af01883735fa719d7075b6f64fedd" translate="yes" xml:space="preserve">
          <source>Allocating memory for sharing across threads</source>
          <target state="translated">Распределение памяти для совместного использования между потоками</target>
        </trans-unit>
        <trans-unit id="a1483392946af2634ec9da37d8a5eacfc7465700" translate="yes" xml:space="preserve">
          <source>Allocation requests are handled on a first-fit basis. Although linear in complexity, allocation is in practice fast because of the compact bookkeeping representation, use of simple and fast bitwise routines, and caching of the first available block position. A known issue with this general approach is fragmentation, partially mitigated by coalescing. Since &lt;code&gt;BitmappedBlock&lt;/code&gt; does not need to maintain the allocated size, freeing memory implicitly coalesces free blocks together. Also, tuning &lt;code&gt;blockSize&lt;/code&gt; has a considerable impact on both internal and external fragmentation.</source>
          <target state="translated">Запросы на распределение обрабатываются в порядке поступления. Несмотря на линейную сложность, распределение на практике происходит быстро из-за компактного бухгалтерского представления, использования простых и быстрых побитовых процедур и кэширования первой доступной позиции блока. Известная проблема с этим общим подходом - фрагментация, частично смягченная объединением. Поскольку &lt;code&gt;BitmappedBlock&lt;/code&gt; не должен поддерживать выделенный размер, освобождение памяти неявно объединяет свободные блоки. Также настройка &lt;code&gt;blockSize&lt;/code&gt; оказывает значительное влияние как на внутреннюю, так и на внешнюю фрагментацию.</target>
        </trans-unit>
        <trans-unit id="cbc962bc5b83a88a16f2713a98847658123e8258" translate="yes" xml:space="preserve">
          <source>Allocation requests first search the tree for a buffer of suitable size deallocated in the past. If a match is found, the node is removed from the tree and the memory is returned. Otherwise, the allocation is directed to &lt;code&gt;ParentAllocator&lt;/code&gt;. If at this point &lt;code&gt;ParentAllocator&lt;/code&gt; also fails to allocate, &lt;code&gt;FreeTree&lt;/code&gt; frees everything and then tries the parent allocator again.</source>
          <target state="translated">Запросы на выделение сначала ищут в дереве буфер подходящего размера, освобожденный в прошлом. Если совпадение найдено, узел удаляется из дерева и возвращается память. В противном случае выделение направляется в &lt;code&gt;ParentAllocator&lt;/code&gt; . Если в этот момент &lt;code&gt;ParentAllocator&lt;/code&gt; также не удается выделить, &lt;code&gt;FreeTree&lt;/code&gt; освобождает все и затем снова пытается использовать родительский распределитель.</target>
        </trans-unit>
        <trans-unit id="af0e205e8505bb23310602de5dd4be9af5c6a6d9" translate="yes" xml:space="preserve">
          <source>Allocation-related flags dictated by type characteristics. &lt;code&gt;TypedAllocator&lt;/code&gt; deduces these flags from the type being allocated and uses the appropriate allocator accordingly.</source>
          <target state="translated">Флаги, связанные с распределением, продиктованы характеристиками типа. &lt;code&gt;TypedAllocator&lt;/code&gt; выводит эти флаги из назначаемого типа и соответственно использует соответствующий распределитель.</target>
        </trans-unit>
        <trans-unit id="fdc44965c2d6c8c8d7c21352e9d968a0c8014291" translate="yes" xml:space="preserve">
          <source>Allocations for sizes smaller than &lt;code&gt;min&lt;/code&gt; or larger than &lt;code&gt;max&lt;/code&gt; are illegal for &lt;code&gt;Bucketizer&lt;/code&gt;. To handle them separately, &lt;code&gt;Segregator&lt;/code&gt; may be of use.</source>
          <target state="translated">Выделения для размеров, меньших чем &lt;code&gt;min&lt;/code&gt; или больше чем &lt;code&gt;max&lt;/code&gt; , являются недопустимыми для &lt;code&gt;Bucketizer&lt;/code&gt; . Чтобы обрабатывать их отдельно, может быть &lt;code&gt;Segregator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="e08b1899abf4a5d12c1969cc846a1ce148364a1f" translate="yes" xml:space="preserve">
          <source>Allocator (currently defined only for Posix and Windows) using &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=munmap&quot;&gt;munmap&lt;/a&gt;&lt;/code&gt; directly (or their Windows equivalents). There is no additional structure: each call to &lt;code&gt;allocate(s)&lt;/code&gt; issues a call to &lt;code&gt;mmap(null, s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)&lt;/code&gt;, and each call to &lt;code&gt;deallocate(b)&lt;/code&gt; issues &lt;code&gt;munmap(b.ptr, b.length)&lt;/code&gt;. So &lt;code&gt;MmapAllocator&lt;/code&gt; is usually intended for allocating large chunks to be managed by fine-granular allocators.</source>
          <target state="translated">Allocator (в настоящее время определяется только для Posix и Windows), использующий &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=munmap&quot;&gt;munmap&lt;/a&gt;&lt;/code&gt; напрямую (или их эквиваленты в Windows). Там нет дополнительной структуры: каждый вызов &lt;code&gt;allocate(s)&lt;/code&gt; выдает вызов на &lt;code&gt;mmap(null, s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)&lt;/code&gt; , и каждый вызов &lt;code&gt;deallocate(b)&lt;/code&gt; вопросы , &lt;code&gt;munmap(b.ptr, b.length)&lt;/code&gt; . Таким образом, &lt;code&gt;MmapAllocator&lt;/code&gt; обычно предназначен для выделения больших чанков, которые должны управляться мелкозернистыми распределителями.</target>
        </trans-unit>
        <trans-unit id="3353234ce0124f8910aaa38caffee20b71a4f80f" translate="yes" xml:space="preserve">
          <source>Allocator &lt;code&gt;alloc&lt;/code&gt;</source>
          <target state="translated">Allocator &lt;code&gt;alloc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1e6a4ec6000f9e0b7f661da3b6a91cb8ae29132" translate="yes" xml:space="preserve">
          <source>Allocator &lt;strong id=&quot;_parent&quot;&gt;_parent&lt;/strong&gt;;</source>
          <target state="translated">Allocator &lt;strong id=&quot;_parent&quot;&gt;_parent&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d69c3c0130d6d25953b8d2d9b80b986133e83dd0" translate="yes" xml:space="preserve">
          <source>Allocator &lt;strong id=&quot;parent&quot;&gt;parent&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;parent&quot;&gt;Родительский&lt;/strong&gt; распределитель ;</target>
        </trans-unit>
        <trans-unit id="cadfd13af30b7dd1dff50bada6dc1d562f201deb" translate="yes" xml:space="preserve">
          <source>Allocator API.</source>
          <target state="translated">API Распределителя.</target>
        </trans-unit>
        <trans-unit id="675049c41d27d311eac5a89bd2e072dfd75d4167" translate="yes" xml:space="preserve">
          <source>Allocator backed by &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sbrk&quot;&gt;sbrk&lt;/a&gt;&lt;/code&gt; for Posix systems. Due to the fact that &lt;code&gt;sbrk&lt;/code&gt; is not thread-safe &lt;a href=&quot;http://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html&quot;&gt;by design&lt;/a&gt;, &lt;code&gt;SbrkRegion&lt;/code&gt; uses a mutex internally. This implies that uncontrolled calls to &lt;code&gt;brk&lt;/code&gt; and &lt;code&gt;sbrk&lt;/code&gt; may affect the workings of &lt;code&gt;SbrkRegion&lt;/code&gt; adversely.</source>
          <target state="translated">Распределитель поддерживается &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sbrk&quot;&gt;sbrk&lt;/a&gt;&lt;/code&gt; для систем Posix. В связи с тем , что &lt;code&gt;sbrk&lt;/code&gt; не поточно- &lt;a href=&quot;http://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html&quot;&gt;дизайн&lt;/a&gt; , &lt;code&gt;SbrkRegion&lt;/code&gt; использует мьютекс внутри. Это подразумевает, что неконтролируемые вызовы &lt;code&gt;brk&lt;/code&gt; и &lt;code&gt;sbrk&lt;/code&gt; могут отрицательно повлиять на работу &lt;code&gt;SbrkRegion&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="513b82ce13f2dc2be45bd311fabfc658467c99b2" translate="yes" xml:space="preserve">
          <source>Allocator primitives.</source>
          <target state="translated">Примитивы аллокатора.</target>
        </trans-unit>
        <trans-unit id="68a0d53209b9f9a4b14c3a76e7ad158b2dca28b9" translate="yes" xml:space="preserve">
          <source>Allocator similar to &lt;code&gt;FreeList&lt;/code&gt; that uses a binary search tree to adaptively store not one, but many free lists.</source>
          <target state="translated">Распределитель похож на &lt;code&gt;FreeList&lt;/code&gt; , который использует двоичное дерево поиска для адаптивного хранения не одного, а множества свободных списков.</target>
        </trans-unit>
        <trans-unit id="d0cc49cc2f10e3277f742185d09b671e886851a2" translate="yes" xml:space="preserve">
          <source>Allocator that adds some extra data before (of type &lt;code&gt;Prefix&lt;/code&gt;) and/or after (of type &lt;code&gt;Suffix&lt;/code&gt;) any allocation made with its parent allocator. This is useful for uses where additional allocation-related information is needed, such as mutexes, reference counts, or walls for debugging memory corruption errors.</source>
          <target state="translated">Распределитель, который добавляет некоторые дополнительные данные до (типа &lt;code&gt;Prefix&lt;/code&gt; ) и / или после (типа &lt;code&gt;Suffix&lt;/code&gt; ) любого выделения, выполненного с его родительским распределителем. Это полезно для случаев, когда требуется дополнительная информация, связанная с распределением, например, мьютексы, счетчики ссылок или стены для отладки ошибок повреждения памяти.</target>
        </trans-unit>
        <trans-unit id="506fd6ecc5980e2993d9b94a51762bcf43b76fb6" translate="yes" xml:space="preserve">
          <source>Allocator that allows and manages allocating extra prefix and/or a suffix bytes for each block allocated.</source>
          <target state="translated">Распределитель,который позволяет и управляет распределением дополнительных префиксов и/или суффиксных байтов для каждого выделенного блока.</target>
        </trans-unit>
        <trans-unit id="bfd65030e4aadae8e36c3b33912522b7bfee3263" translate="yes" xml:space="preserve">
          <source>Allocator that collects extra data about allocations. Since each piece of information adds size and time overhead, statistics can be individually enabled or disabled through compile-time &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">Распределитель, который собирает дополнительные данные о распределениях. Поскольку каждый фрагмент информации увеличивает размер и время, статистические данные могут быть включены или отключены индивидуально с помощью &lt;code&gt;flags&lt;/code&gt; времени компиляции .</target>
        </trans-unit>
        <trans-unit id="bc0af3b6f564e9ca229952d612a3550f66061e3a" translate="yes" xml:space="preserve">
          <source>Allocator that collects useful statistics about allocations, both global and per calling point. The statistics collected can be configured statically by choosing combinations of &lt;code&gt;Options&lt;/code&gt; appropriately.</source>
          <target state="translated">Распределитель, который собирает полезную статистику о распределениях, как глобальных, так и на вызывающую точку. Собранную статистику можно настроить статически, выбрав соответствующие комбинации &lt;code&gt;Options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14e1947892b24d554e92c80dc9a3054c6f2dbace" translate="yes" xml:space="preserve">
          <source>Allocator that combines two other allocators - primary and fallback. Allocation requests are first tried with primary, and upon failure are passed to the fallback. Useful for small and fast allocators fronting general-purpose ones.</source>
          <target state="translated">Распределитель,который объединяет два других распределителя-первичный и запасной.Запросы на распределение сначала пробуются с первичным,а в случае неудачи передаются в резерв.Полезно для малых и быстрых аллокаторов,стоящих впереди аллокаторов общего назначения.</target>
        </trans-unit>
        <trans-unit id="82ae157e1fe07caf7d37c5484581461f1d9f6744" translate="yes" xml:space="preserve">
          <source>Allocator that implements a &lt;a href=&quot;http://wikipedia.org/wiki/Free_list&quot;&gt;free list&lt;/a&gt; on top of any other allocator. The preferred size, tolerance, and maximum elements are configurable at compile- and run time.</source>
          <target state="translated">Распределитель, который реализует &lt;a href=&quot;http://wikipedia.org/wiki/Free_list&quot;&gt;свободный список&lt;/a&gt; поверх любого другого распределителя. Предпочтительный размер, допуск и максимальные элементы настраиваются во время компиляции и выполнения.</target>
        </trans-unit>
        <trans-unit id="92d633faca70f593d2eefae1500ce778644a707a" translate="yes" xml:space="preserve">
          <source>Allocator that uses stack allocation for up to &lt;code&gt;stackSize&lt;/code&gt; bytes and then falls back to &lt;code&gt;Allocator&lt;/code&gt;. Defined as:</source>
          <target state="translated">Распределитель, который использует выделение стека для байтов &lt;code&gt;stackSize&lt;/code&gt; , а затем возвращается к &lt;code&gt;Allocator&lt;/code&gt; . Определяется как:</target>
        </trans-unit>
        <trans-unit id="277f2e388687399a48875d2b4c26cd068e3208fa" translate="yes" xml:space="preserve">
          <source>Allocator used for storing bookkeeping data. The size of bookkeeping data is proportional to the number of allocators. If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;, then &lt;code&gt;AllocatorList&lt;/code&gt; is &quot;ouroboros-style&quot;, i.e. it keeps the bookkeeping data in memory obtained from the allocators themselves. Note that for ouroboros-style management, the size &lt;code&gt;n&lt;/code&gt; passed to &lt;code&gt;make&lt;/code&gt; will be occasionally different from the size requested by client code.</source>
          <target state="translated">Распределитель используется для хранения бухгалтерских данных. Размер бухгалтерских данных пропорционален количеству распределителей. Если &lt;code&gt;BookkeepingAllocator&lt;/code&gt; является &lt;code&gt;NullAllocator&lt;/code&gt; , то &lt;code&gt;AllocatorList&lt;/code&gt; является &amp;laquo;Уроборос стиль&amp;raquo;, т.е. он хранит данные бухгалтерского учета в памяти , полученных от самих распределителей. Обратите внимание, что для управления в стиле Уробороса размер &lt;code&gt;n&lt;/code&gt; , передаваемый для &lt;code&gt;make&lt;/code&gt; , иногда будет отличаться от размера, запрашиваемого клиентским кодом.</target>
        </trans-unit>
        <trans-unit id="08bb4c3deb9ae5f24662a76a349c8811c202d3b8" translate="yes" xml:space="preserve">
          <source>Allocator using &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; directly.</source>
          <target state="translated">Распределитель, используя &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; напрямую.</target>
        </trans-unit>
        <trans-unit id="c8e7b4b37828838d0088cc341f2bd349bdd2e0c6" translate="yes" xml:space="preserve">
          <source>Allocator[(max + 1 - min) / step] &lt;strong id=&quot;buckets&quot;&gt;buckets&lt;/strong&gt;;</source>
          <target state="translated">Распределитель [(max + 1 - min) / шаг] &lt;strong id=&quot;buckets&quot;&gt;ведра&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="244757ffcceddee2188dcae6f52360122e5f32b2" translate="yes" xml:space="preserve">
          <source>Allocators are classes that define memory models to be used by some parts of the C++ Standard Library, and most specifically, by STL containers.</source>
          <target state="translated">Распределители-это классы,определяющие модели памяти,которые будут использоваться некоторыми частями стандартной библиотеки C++,а точнее-контейнерами STL.</target>
        </trans-unit>
        <trans-unit id="cfd42e2cc807e85fba40b31455784b7f9341316f" translate="yes" xml:space="preserve">
          <source>Allocators assembled from the heap building blocks don't need to go through &lt;code&gt;IAllocator&lt;/code&gt; to be usable. They have the same primitives as &lt;code&gt;IAllocator&lt;/code&gt; and they work with &lt;a href=&quot;#make&quot;&gt;&lt;code&gt;make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#makeArray&quot;&gt;&lt;code&gt;makeArray&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#dispose&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; etc. So it suffice to create allocator objects wherever fit and use them appropriately:</source>
          <target state="translated">Распределители, собранные из блоков кучи, не должны проходить через &lt;code&gt;IAllocator&lt;/code&gt; , чтобы их можно было использовать. Они имеют те же примитивы , как &lt;code&gt;IAllocator&lt;/code&gt; и они работают с &lt;a href=&quot;#make&quot;&gt; &lt;code&gt;make&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#makeArray&quot;&gt; &lt;code&gt;makeArray&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#dispose&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; и т.д. Так что достаточно , чтобы создать Allocator объекты , где подходят и использовать их соответствующим образом :</target>
        </trans-unit>
        <trans-unit id="b1a8b8369433cbedfb9cf80b63c1ab01ecb08d5f" translate="yes" xml:space="preserve">
          <source>Allocators customarily allocate memory in discretely-sized chunks. Therefore, a request for &lt;code&gt;n&lt;/code&gt; bytes may result in a larger allocation. The extra memory allocated goes unused and adds to the so-called &lt;a href=&quot;http://goo.gl/YoKffF&quot;&gt;internal fragmentation&lt;/a&gt;. The function &lt;code&gt;goodAllocSize(n)&lt;/code&gt; returns the actual number of bytes that would be allocated upon a request for &lt;code&gt;n&lt;/code&gt; bytes. This module defines a default implementation that returns &lt;code&gt;n&lt;/code&gt; rounded up to a multiple of the allocator's alignment.</source>
          <target state="translated">Распределители обычно выделяют память кусками дискретного размера. Следовательно, запрос на &lt;code&gt;n&lt;/code&gt; байтов может привести к большему выделению. Выделенная дополнительная память не используется и добавляет к так называемой &lt;a href=&quot;http://goo.gl/YoKffF&quot;&gt;внутренней фрагментации&lt;/a&gt; . Функция &lt;code&gt;goodAllocSize(n)&lt;/code&gt; возвращает фактическое количество байтов, которое будет выделено при запросе &lt;code&gt;n&lt;/code&gt; байтов. Этот модуль определяет реализацию по умолчанию, которая возвращает &lt;code&gt;n&lt;/code&gt; , округленное до кратного выравнивания распределителя.</target>
        </trans-unit>
        <trans-unit id="a6e1e46c405b75de5b94f462defa6a8af94b5d44" translate="yes" xml:space="preserve">
          <source>Allow Duration to be used as a boolean.</source>
          <target state="translated">Разрешите использовать &quot;Длительность&quot; в качестве булева.</target>
        </trans-unit>
        <trans-unit id="adac40bfba505bd009304b9376798311375e4e91" translate="yes" xml:space="preserve">
          <source>Allow local reuse of address</source>
          <target state="translated">Разрешить локальное повторное использование адреса</target>
        </trans-unit>
        <trans-unit id="8b6333bf17facce373203c2555dce16e5a1895fb" translate="yes" xml:space="preserve">
          <source>Allow the last slide to have fewer elements than windowSize</source>
          <target state="translated">Позвольте последнему слайду иметь меньше элементов,чем windowSize.</target>
        </trans-unit>
        <trans-unit id="6ed1bcaf99a3846f70cbca3700192d6c980d8840" translate="yes" xml:space="preserve">
          <source>Allow transmission of broadcast messages</source>
          <target state="translated">Разрешить передачу широковещательных сообщений</target>
        </trans-unit>
        <trans-unit id="d8fa57446bade27e54bc705df143acdcdd3b1802" translate="yes" xml:space="preserve">
          <source>AllowDayOverflow &lt;code&gt;allowOverflow&lt;/code&gt;</source>
          <target state="translated">AllowDayOverflow &lt;code&gt;allowOverflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64679db98864f0cda1e9bac90e046d01f23a860d" translate="yes" xml:space="preserve">
          <source>AllowDayOverflow only applies to calculations involving months or years.</source>
          <target state="translated">AllowDayOverflow применяется только к вычислениям,включающим месяцы или годы.</target>
        </trans-unit>
        <trans-unit id="25c6d16035cd63a1ba2d0337d85f0862317f57db" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;alias&lt;/code&gt;ing of any single symbol, type or compile-time expression.</source>
          <target state="translated">Позволяет &lt;code&gt;alias&lt;/code&gt; любого отдельного символа, типа или выражения времени компиляции.</target>
        </trans-unit>
        <trans-unit id="6f4acd20c1f1294f9371d9a6ba2cfbedb8612aac" translate="yes" xml:space="preserve">
          <source>Allows assignment from a subset algebraic type</source>
          <target state="translated">Позволяет назначать из подмножества алгебраических типов</target>
        </trans-unit>
        <trans-unit id="d7cde2e0711d3681c464aaffee0a4276b1a5dd9a" translate="yes" xml:space="preserve">
          <source>Allows constructing a &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; from the given time units with the given length.</source>
          <target state="translated">Позволяет построить &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; из заданных единиц времени с заданной продолжительностью.</target>
        </trans-unit>
        <trans-unit id="ee70bbaa43d45797f5f446c5970672b1c530f1ac" translate="yes" xml:space="preserve">
          <source>Allows creating bit fields inside structs and classes.</source>
          <target state="translated">Позволяет создавать битовые поля внутри структур и классов.</target>
        </trans-unit>
        <trans-unit id="64ee76f10cd6158b74b7abb63361a7dad9dbd646" translate="yes" xml:space="preserve">
          <source>Allows for custom number of worker threads.</source>
          <target state="translated">Позволяет настраивать количество рабочих потоков.</target>
        </trans-unit>
        <trans-unit id="328393fd6489bef674280b2b2127dc7cc02ec9c0" translate="yes" xml:space="preserve">
          <source>Allows freely swapping of elements as long as the output satisfies the algorithm's requirements.</source>
          <target state="translated">Позволяет свободно менять элементы до тех пор,пока выходной сигнал удовлетворяет требованиям алгоритма.</target>
        </trans-unit>
        <trans-unit id="9a9ded70476d5ecbed5df1b409fabc86f2220dab" translate="yes" xml:space="preserve">
          <source>Allows manipulating the fraction, exponent, and sign parts of a double separately. The definition is:</source>
          <target state="translated">Позволяет манипулировать дробью,выражением и знаком частей двойника по отдельности.Определение таково:</target>
        </trans-unit>
        <trans-unit id="334b65d7fe406c8806cd27978db1e757401c70de" translate="yes" xml:space="preserve">
          <source>Allows manipulating the fraction, exponent, and sign parts of a float separately. The definition is:</source>
          <target state="translated">Позволяет отдельно манипулировать дробью,экспонентом и знаковыми частями поплавка.Определение таково:</target>
        </trans-unit>
        <trans-unit id="25a3ad747e7b5e32b1dfdc83fe51e1af4607df0d" translate="yes" xml:space="preserve">
          <source>Allows safe construction of &lt;code&gt;Unique&lt;/code&gt;. It creates the resource and guarantees unique ownership of it (unless &lt;code&gt;T&lt;/code&gt; publishes aliases of &lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">Позволяет безопасное строительство &lt;code&gt;Unique&lt;/code&gt; . Он создает ресурс и гарантирует уникальное владение им (если &lt;code&gt;T&lt;/code&gt; не публикует псевдонимы &lt;code&gt;this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b188cff78ffe93b93118a9afb92a5b0ecf425233" translate="yes" xml:space="preserve">
          <source>Allows the storage of &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Positive_and_negative_infinity&quot;&gt; IEEE754 infinity&lt;/a&gt; values.</source>
          <target state="translated">Позволяет хранить &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Positive_and_negative_infinity&quot;&gt;значения бесконечности IEEE754&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c7e91d01b82633b7ccef70ff930b3cba01954d" translate="yes" xml:space="preserve">
          <source>Allows the storage of &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;IEEE754 Not a Number&lt;/a&gt; values.</source>
          <target state="translated">Позволяет хранить значения &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;IEEE754 Not a Number&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82e4b1439e8421bdc9916fd5cc4940cdec7c35ca" translate="yes" xml:space="preserve">
          <source>Allows user code to define custom floating-point formats. These formats are for storage only; all operations on them are performed by first implicitly extracting them to &lt;code&gt;real&lt;/code&gt; first. After the operation is completed the result can be stored in a custom floating-point value via assignment.</source>
          <target state="translated">Позволяет пользовательскому коду определять собственные форматы с плавающей точкой. Эти форматы предназначены только для хранения; все операции с ними выполняются, сначала неявно извлекая их в &lt;code&gt;real&lt;/code&gt; . После завершения операции результат может быть сохранен в пользовательском значении с плавающей запятой посредством присваивания.</target>
        </trans-unit>
        <trans-unit id="a707a85edc66a653109fa80da8910d24c0d7d6d7" translate="yes" xml:space="preserve">
          <source>Alphabetic</source>
          <target state="translated">Alphabetic</target>
        </trans-unit>
        <trans-unit id="c31b9723b74539a236469f5380dbe298e0356511" translate="yes" xml:space="preserve">
          <source>Alphabetic Presentation Forms</source>
          <target state="translated">Бланк алфавитной презентации</target>
        </trans-unit>
        <trans-unit id="a4f699c324e0e58a96d3bb16953095da737d92fc" translate="yes" xml:space="preserve">
          <source>Also known as trinary, trivalent, or trilean.</source>
          <target state="translated">Также известен как тринарный,тривалентный или триловый.</target>
        </trans-unit>
        <trans-unit id="3cb12cab0f941ad8314fbcab6c21fb7b159e66aa" translate="yes" xml:space="preserve">
          <source>Also note that while normally the &lt;code&gt;begin&lt;/code&gt; of an interval is included in it and its &lt;code&gt;end&lt;/code&gt; is excluded from it, if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then &lt;code&gt;begin&lt;/code&gt; is treated as excluded and &lt;code&gt;end&lt;/code&gt; is treated as included. This allows for the same behavior in both directions. This works because none of &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s functions which care about whether &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; is included or excluded are ever called by &lt;code&gt;IntervalRange&lt;/code&gt;. &lt;code&gt;interval&lt;/code&gt; returns a normal interval, regardless of whether &lt;code&gt;dir == Direction.fwd&lt;/code&gt; or if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, so any &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; functions which are called on it which care about whether &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are included or excluded will treat &lt;code&gt;begin&lt;/code&gt; as included and &lt;code&gt;end&lt;/code&gt; as excluded.</source>
          <target state="translated">Также обратите внимание, что, хотя обычно &lt;code&gt;begin&lt;/code&gt; интервала включено в него и его &lt;code&gt;end&lt;/code&gt; исключен из него, если &lt;code&gt;dir == Direction.bwd&lt;/code&gt; , тогда &lt;code&gt;begin&lt;/code&gt; обрабатывается как исключенное, а &lt;code&gt;end&lt;/code&gt; обрабатывается как включенное. Это допускает одинаковое поведение в обоих направлениях. Это работает, потому что ни одна из функций &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; , которые заботятся о том, включены или нет &lt;code&gt;begin&lt;/code&gt; или &lt;code&gt;end&lt;/code&gt; , никогда не вызывается &lt;code&gt;IntervalRange&lt;/code&gt; . &lt;code&gt;interval&lt;/code&gt; возвращает нормальный интервал, независимо от того, является ли &lt;code&gt;dir == Direction.fwd&lt;/code&gt; или если &lt;code&gt;dir == Direction.bwd&lt;/code&gt; , поэтому любой &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt;функции , которые называются на ней , которые заботятся о том , &lt;code&gt;begin&lt;/code&gt; или &lt;code&gt;end&lt;/code&gt; включены или исключены будут относиться &lt;code&gt;begin&lt;/code&gt; , как включены и &lt;code&gt;end&lt;/code&gt; исключенные.</target>
        </trans-unit>
        <trans-unit id="be0f9f39d5673fb5d350cd6b832b92db8b3eeda0" translate="yes" xml:space="preserve">
          <source>Also note that while normally the &lt;code&gt;end&lt;/code&gt; of an interval is excluded from it, &lt;code&gt;NegInfIntervalRange&lt;/code&gt; treats it as if it were included. This allows for the same behavior as with &lt;code&gt;PosInfIntervalRange&lt;/code&gt;. This works because none of &lt;code&gt;NegInfInterval&lt;/code&gt;'s functions which care about whether &lt;code&gt;end&lt;/code&gt; is included or excluded are ever called by &lt;code&gt;NegInfIntervalRange&lt;/code&gt;. &lt;code&gt;interval&lt;/code&gt; returns a normal interval, so any &lt;code&gt;NegInfInterval&lt;/code&gt; functions which are called on it which care about whether &lt;code&gt;end&lt;/code&gt; is included or excluded will treat &lt;code&gt;end&lt;/code&gt; as excluded.</source>
          <target state="translated">Также обратите внимание, что хотя обычно &lt;code&gt;end&lt;/code&gt; интервала исключается из него, &lt;code&gt;NegInfIntervalRange&lt;/code&gt; обрабатывает его так, как если бы он был включен. Это допускает то же поведение, что и в &lt;code&gt;PosInfIntervalRange&lt;/code&gt; . Это работает, потому что ни одна из &lt;code&gt;NegInfInterval&lt;/code&gt; , которые заботятся о том, включен ли &lt;code&gt;end&lt;/code&gt; , никогда не &lt;code&gt;NegInfIntervalRange&lt;/code&gt; . &lt;code&gt;interval&lt;/code&gt; возвращает нормальный интервал, поэтому любые функции &lt;code&gt;NegInfInterval&lt;/code&gt; , вызываемые для него, которые заботятся о том, включен ли &lt;code&gt;end&lt;/code&gt; или исключен, будут рассматривать &lt;code&gt;end&lt;/code&gt; как исключенный.</target>
        </trans-unit>
        <trans-unit id="238e333d78d3953efe21f4c8dee91a8052bf6044" translate="yes" xml:space="preserve">
          <source>Also please note, that no spaces are allowed within the string anywhere whether it's a leading, trailing, or embedded space(s), thus they too must be stripped from the string before using this function, or any of the conversion functions.</source>
          <target state="translated">Также обратите внимание,что в строке нигде не должно быть пробелов,будь то ведущие,трейлинговые или встроенные пробелы,поэтому они тоже должны быть удалены из строки перед использованием этой функции или любой из функций преобразования.</target>
        </trans-unit>
        <trans-unit id="19b283d04d340872863f50c8bc1177319aa2279b" translate="yes" xml:space="preserve">
          <source>Also see: &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt;</source>
          <target state="translated">Также смотрите: &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ceee206f7bf1c9c9a3b0facedfafb260135ff34" translate="yes" xml:space="preserve">
          <source>Also, because no decoding occurs, it is possible to use this overload to translate ASCII characters within a proper UTF-8 string without altering the other, non-ASCII characters. It's replacing any code unit greater than &lt;code&gt;127&lt;/code&gt; with another code unit or replacing any code unit with another code unit greater than &lt;code&gt;127&lt;/code&gt; which will cause UTF validation issues.</source>
          <target state="translated">Кроме того, поскольку декодирование не происходит, можно использовать эту перегрузку для преобразования символов ASCII в правильной строке UTF-8 без изменения других символов, не входящих в ASCII. Он заменяет любую кодовую единицу больше &lt;code&gt;127&lt;/code&gt; другой кодовой единицей или заменяет любую кодовую единицу другой кодовой единицей больше &lt;code&gt;127&lt;/code&gt; , что вызовет проблемы с проверкой UTF.</target>
        </trans-unit>
        <trans-unit id="cd0ce1c13fb8625991e7b8d7c7f0d7c753bdcd89" translate="yes" xml:space="preserve">
          <source>Also, note that Phobos code assumes that the primitives &lt;code&gt;r.front&lt;/code&gt; and &lt;code&gt;r.empty&lt;/code&gt; are &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time complexity wise or &quot;cheap&quot; in terms of running time. &amp;Omicron;() statements in the documentation of range functions are made with this assumption.</source>
          <target state="translated">Также обратите внимание, что код Phobos предполагает, что примитивы &lt;code&gt;r.front&lt;/code&gt; и &lt;code&gt;r.empty&lt;/code&gt; имеют &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) временную сложность или являются &amp;laquo;дешевыми&amp;raquo; с точки зрения времени выполнения. Операторы &amp;Omicron; () в документации функций диапазона сделаны с этим допущением.</target>
        </trans-unit>
        <trans-unit id="7575757c12c48b07e624443d696165742a7b14f4" translate="yes" xml:space="preserve">
          <source>Also, the IANA time zone database has a lot more time zones than Windows does.</source>
          <target state="translated">Кроме того,в базе данных IANA по часовым поясам гораздо больше часовых поясов,чем в Windows.</target>
        </trans-unit>
        <trans-unit id="4f85c414c696f8d88b637f2931596bd576a74dbf" translate="yes" xml:space="preserve">
          <source>Also, you may wish to utilize the &lt;code&gt;reserve&lt;/code&gt; function to pre-allocate array data to use with the append operator.</source>
          <target state="translated">Также вы можете использовать функцию &lt;code&gt;reserve&lt;/code&gt; для предварительного выделения данных массива для использования с оператором добавления.</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="c3cfd4ccb3c0f4865df49b814eab540d3553f2c1" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#Fields&quot;&gt;&lt;code&gt;Fields&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">Альтернативное имя для &lt;a href=&quot;#Fields&quot;&gt; &lt;code&gt;Fields&lt;/code&gt; &lt;/a&gt; , сохраненное для совместимости с прежними версиями.</target>
        </trans-unit>
        <trans-unit id="5d62f98b8f8caf5989633e5408f0d403968f08f9" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#ParameterDefaults&quot;&gt;&lt;code&gt;ParameterDefaults&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">Альтернативное имя для &lt;a href=&quot;#ParameterDefaults&quot;&gt; &lt;code&gt;ParameterDefaults&lt;/code&gt; &lt;/a&gt; , сохраняемое для совместимости с прежними версиями.</target>
        </trans-unit>
        <trans-unit id="8c96b3e17073941a891d0a738663e82616b91e67" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#Parameters&quot;&gt;&lt;code&gt;Parameters&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">Альтернативное имя для &lt;a href=&quot;#Parameters&quot;&gt; &lt;code&gt;Parameters&lt;/code&gt; &lt;/a&gt; , сохраняемое для совместимости с прежними версиями.</target>
        </trans-unit>
        <trans-unit id="d679f53e7924ba2aa8d486d630ba51ae1a168a21" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#isExpressions&quot;&gt;&lt;code&gt;isExpressions&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="translated">Альтернативное имя для &lt;a href=&quot;#isExpressions&quot;&gt; &lt;code&gt;isExpressions&lt;/code&gt; &lt;/a&gt; , сохраняемое для совместимости с прежними версиями .</target>
        </trans-unit>
        <trans-unit id="88e4f940df16ef30434b16d10b67a7bb93c43df0" translate="yes" xml:space="preserve">
          <source>Alternative sorting method that should be used when comparing keys involves an expensive computation. Instead of using &lt;code&gt;less(a, b)&lt;/code&gt; for comparing elements, &lt;code&gt;schwartzSort&lt;/code&gt; uses &lt;code&gt;less(transform(a), transform(b))&lt;/code&gt;. The values of the &lt;code&gt;transform&lt;/code&gt; function are precomputed in a temporary array, thus saving on repeatedly computing it. Conversely, if the cost of &lt;code&gt;transform&lt;/code&gt; is small compared to the cost of allocating and filling the precomputed array, &lt;code&gt;sort&lt;/code&gt; may be faster and therefore preferable.</source>
          <target state="translated">Альтернативный метод сортировки, который следует использовать при сравнении ключей, требует дорогостоящих вычислений. Вместо того, чтобы использовать &lt;code&gt;less(a, b)&lt;/code&gt; для сравнения элементов, &lt;code&gt;schwartzSort&lt;/code&gt; использует &lt;code&gt;less(transform(a), transform(b))&lt;/code&gt; . Значения функции &lt;code&gt;transform&lt;/code&gt; предварительно вычисляются во временном массиве, что позволяет сэкономить на его повторном вычислении. И наоборот, если стоимость &lt;code&gt;transform&lt;/code&gt; мала по сравнению со стоимостью выделения и заполнения предварительно вычисленного массива, &lt;code&gt;sort&lt;/code&gt; может быть более быстрой и, следовательно, предпочтительной.</target>
        </trans-unit>
        <trans-unit id="1b074433d0046e94a8541abc9c7fb27718d93f11" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;values&lt;/code&gt; can be passed at compile-time, allowing for a more efficient search, but one that only supports matching on equality:</source>
          <target state="translated">В качестве альтернативы, &lt;code&gt;values&lt;/code&gt; могут быть переданы во время компиляции, что обеспечивает более эффективный поиск, но такой, который поддерживает сопоставление только на равенство:</target>
        </trans-unit>
        <trans-unit id="c34214f7bf412f966f5ee7b7c1e43a0611031a85" translate="yes" xml:space="preserve">
          <source>Alternatively, inside the scope of an aggregate, only the member name is needed:</source>
          <target state="translated">В качестве альтернативы,в рамках агрегата требуется только имя члена:</target>
        </trans-unit>
        <trans-unit id="5ab148c62e084629eaeb7919a9c875b4ac608894" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of using a single &lt;code&gt;value&lt;/code&gt; to fill the &lt;code&gt;range&lt;/code&gt;, a &lt;code&gt;filter&lt;/code&gt;&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; can be provided. The length of &lt;code&gt;filler&lt;/code&gt; and &lt;code&gt;range&lt;/code&gt; do not need to match, but &lt;code&gt;filler&lt;/code&gt; must not be empty.</source>
          <target state="translated">В качестве альтернативы, вместо использования единственного &lt;code&gt;value&lt;/code&gt; для заполнения &lt;code&gt;range&lt;/code&gt; , может быть предусмотрен &lt;code&gt;filter&lt;/code&gt; &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямого диапазона&lt;/a&gt; . Длина &lt;code&gt;filler&lt;/code&gt; и &lt;code&gt;range&lt;/code&gt; не должны совпадать, но &lt;code&gt;filler&lt;/code&gt; не должен быть пустым.</target>
        </trans-unit>
        <trans-unit id="3c96dd8d99da646f189f6b06c25b24bb70790d61" translate="yes" xml:space="preserve">
          <source>Alternatively, the non-string form can be used to introduce a scope. Note that the enclosing module already provides a scope for the symbols declared in the namespace. This form does not allow closing and reopening the same namespace with in the same module. That is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73c4549c3e37630a06c8e93619aaef72dfec939" translate="yes" xml:space="preserve">
          <source>Alternatively, wysiwyg strings can be enclosed by backquotes, using the ` character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188d34f7156185437a8f88ec534863d101dd6cd7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can declare a single templated &lt;code&gt;opEquals&lt;/code&gt; function with an &lt;a href=&quot;template#auto-ref-parameters&quot;&gt;auto ref&lt;/a&gt; parameter:</source>
          <target state="translated">Кроме того, вы можете объявить одну шаблонную функцию &lt;code&gt;opEquals&lt;/code&gt; с параметром &lt;a href=&quot;template#auto-ref-parameters&quot;&gt;auto ref&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4d49f83ba69fd5e0ed773bc16674431bab9674cc" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;char[]&lt;/code&gt; and &lt;code&gt;wchar[]&lt;/code&gt; (as well as their qualified versions including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;) are arrays, &lt;code&gt;isRandomAccessRange&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt; for them because they use variable-length encodings (UTF-8 and UTF-16 respectively). These types are bidirectional ranges only.</source>
          <target state="translated">Хотя &lt;code&gt;char[]&lt;/code&gt; и &lt;code&gt;wchar[]&lt;/code&gt; (а также их квалифицированные версии, включая &lt;code&gt;string&lt;/code&gt; и &lt;code&gt;wstring&lt;/code&gt; ) являются массивами, &lt;code&gt;isRandomAccessRange&lt;/code&gt; выдает для них значение &lt;code&gt;false&lt;/code&gt; , поскольку они используют кодировки переменной длины (UTF-8 и UTF-16 соответственно). Эти типы являются только двунаправленными диапазонами.</target>
        </trans-unit>
        <trans-unit id="ce1b50075d06a3525c670dfdee2303781cd59e16" translate="yes" xml:space="preserve">
          <source>Although D does not currently use a moving garbage collector, by following the rules listed above one can be implemented. No special action is required to pin objects. A moving collector will only move objects for which there are no ambiguous references, and for which it can update those references. All other objects will be automatically pinned.</source>
          <target state="translated">Несмотря на то,что в настоящее время D не использует движущийся сборщик мусора,соблюдение вышеперечисленных правил может быть реализовано.Для прикрепления объектов не требуется никаких специальных действий.Движущийся коллектор будет перемещать только те объекты,для которых нет неоднозначных ссылок,и для которых он может обновлять эти ссылки.Все остальные объекты будут автоматически прикрепляться.</target>
        </trans-unit>
        <trans-unit id="1aee14a59e8527fa460ebbbf449880cdcef580e1" translate="yes" xml:space="preserve">
          <source>Although a struct constructor returns a reference to the instance being constructed, it is treated as form (1).</source>
          <target state="translated">Хотя конструктор структуры возвращает ссылку на создаваемый экземпляр,он рассматривается как форма (1).</target>
        </trans-unit>
        <trans-unit id="b2e0f6070914711324b1b22c0acefe2c4d0046f3" translate="yes" xml:space="preserve">
          <source>Although allocations are in theory served in linear searching time, &lt;code&gt;deallocate&lt;/code&gt; calls take &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time, by using aligned allocations. &lt;code&gt;ParentAllocator&lt;/code&gt; must implement &lt;code&gt;alignedAllocate&lt;/code&gt; and it must be able to allocate &lt;code&gt;theAlignment&lt;/code&gt; bytes at the same alignment. Each aligned allocation done by &lt;code&gt;ParentAllocator&lt;/code&gt; will contain metadata for an &lt;code&gt;Allocator&lt;/code&gt;, followed by its payload.</source>
          <target state="translated">Хотя теоретически распределение выполняется во время линейного поиска, вызовы &lt;code&gt;deallocate&lt;/code&gt; занимают &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) времени, используя выровненные распределения. &lt;code&gt;ParentAllocator&lt;/code&gt; должен реализовывать &lt;code&gt;alignedAllocate&lt;/code&gt; и должен иметь возможность выделять байты &lt;code&gt;theAlignment&lt;/code&gt; при одном и том же выравнивании. Каждое выровненное распределение, выполненное &lt;code&gt;ParentAllocator&lt;/code&gt; , будет содержать метаданные для &lt;code&gt;Allocator&lt;/code&gt; , за которыми следует его полезная нагрузка.</target>
        </trans-unit>
        <trans-unit id="ba5576589df037851e2ab68a594e957c64a2217b" translate="yes" xml:space="preserve">
          <source>Although narrow string types (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, and their qualified derivatives) do define a &lt;code&gt;length&lt;/code&gt; property, &lt;code&gt;hasLength&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt; for them. This is because a narrow string's length does not reflect the number of characters, but instead the number of encoding units, and as such is not useful with range-oriented algorithms. To use strings as random-access ranges with length, use &lt;a href=&quot;std_string#representation&quot;&gt;&lt;code&gt;std.string.representation&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_utf#byCodeUnit&quot;&gt;&lt;code&gt;std.utf.byCodeUnit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Хотя узкие строковые типы ( &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; и их квалифицированные производные) действительно определяют свойство &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;hasLength&lt;/code&gt; выдает для них значение &lt;code&gt;false&lt;/code&gt; . Это связано с тем, что узкая длина строки не отражает количество символов, а вместо этого количество единиц кодирования, и, как таковое, бесполезно для алгоритмов, ориентированных на диапазон. Чтобы использовать строки в качестве диапазонов произвольного доступа с длиной, используйте &lt;a href=&quot;std_string#representation&quot;&gt; &lt;code&gt;std.string.representation&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;std_utf#byCodeUnit&quot;&gt; &lt;code&gt;std.utf.byCodeUnit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="751a51b5f3815e4913ea4c1e3d08b8c0587fdc03" translate="yes" xml:space="preserve">
          <source>Although some keywords can be used both as a type qualifier and a storage class, there are some storage classes that cannot be used to construct new types, such as &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">Хотя некоторые ключевые слова могут использоваться как в качестве спецификатора типа, так и в качестве класса хранения, есть некоторые классы хранения, которые нельзя использовать для создания новых типов, например, &lt;code&gt;ref&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dd93adfa24c055484c1d6ac7b1222125e38dd6c6" translate="yes" xml:space="preserve">
          <source>Although static variable name visibility follows the usual scoping rules, the names of them must be unique within a particular function.</source>
          <target state="translated">Хотя статическая видимость имен переменных следует обычным правилам поиска,имена переменных должны быть уникальны внутри конкретной функции.</target>
        </trans-unit>
        <trans-unit id="8d68e23bc937fb1a750f414f57afc9ba51e4f8a9" translate="yes" xml:space="preserve">
          <source>Although the contents of the padding are often zero, do not rely on that.</source>
          <target state="translated">Несмотря на то,что содержание набивки часто равняется нулю,не стоит полагаться на это.</target>
        </trans-unit>
        <trans-unit id="0f6d1d3556d0e4071164ab02759b80b8f87727af" translate="yes" xml:space="preserve">
          <source>Although the data is immutable, the allocator &quot;knows&quot; the underlying memory is mutable, so &lt;code&gt;immutable&lt;/code&gt; is elided for the affix which is independent from the data itself. However, the result is &lt;code&gt;shared&lt;/code&gt; because &lt;code&gt;immutable&lt;/code&gt; is implicitly shareable so multiple threads may access and manipulate the affix for the same data.</source>
          <target state="translated">Несмотря на то, что данные являются неизменяемыми, распределитель &amp;laquo;знает&amp;raquo;, что базовая память является изменяемой, поэтому &lt;code&gt;immutable&lt;/code&gt; исключается для аффикса, который не зависит от самих данных. Тем не менее, результат является &lt;code&gt;shared&lt;/code&gt; потому что &lt;code&gt;immutable&lt;/code&gt; неявно доступен для совместного использования, поэтому несколько потоков могут обращаться к аффиксу и манипулировать им для одних и тех же данных.</target>
        </trans-unit>
        <trans-unit id="4594a211d07176e71f67f04c76263fc9e17f8056" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;false&lt;/code&gt; (random generators are infinite ranges).</source>
          <target state="translated">Всегда &lt;code&gt;false&lt;/code&gt; (случайные генераторы имеют бесконечные диапазоны).</target>
        </trans-unit>
        <trans-unit id="d2317146c4b78429c9fa4a78c82cf701740b74a6" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Всегда &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ed0571bb284ff0022a6b18f52dbb495171fb6f8" translate="yes" xml:space="preserve">
          <source>Always a new scope, to use for this &lt;code&gt;DeprecatedDeclaration&lt;/code&gt;'s members.</source>
          <target state="translated">Всегда новая область действия, используемая для членов этого &lt;code&gt;DeprecatedDeclaration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecdf7d32ac0560522ba0c167fff3b2a8084d9926" translate="yes" xml:space="preserve">
          <source>Always add new return codes last. Never &lt;em&gt;EVER&lt;/em&gt; remove any. The return codes must remain the same!</source>
          <target state="translated">Всегда добавляйте новые коды возврата в последнюю очередь. Никогда &lt;em&gt;НИКОГДА не&lt;/em&gt; удаляйте. Коды возврата должны оставаться прежними!</target>
        </trans-unit>
        <trans-unit id="91aa9903448204ed37d902e02a20b0b8d1775687" translate="yes" xml:space="preserve">
          <source>Always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; to wait for a process to complete, even if &lt;code&gt;kill&lt;/code&gt; has been called on it.</source>
          <target state="translated">Всегда вызывайте &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; ,&lt;/a&gt; чтобы дождаться завершения процесса, даже если для него был вызван &lt;code&gt;kill&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00efb2c1e297670bc7025d03ccb66d306c20b175" translate="yes" xml:space="preserve">
          <source>Always defined; used as the opposite of &lt;code&gt;none&lt;/code&gt;</source>
          <target state="translated">Всегда определен; используется как противоположность &lt;code&gt;none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c125fb83f824d4bd1d2beebad9485aed6b09839a" translate="yes" xml:space="preserve">
          <source>Always do checking</source>
          <target state="translated">Всегда проверяйте</target>
        </trans-unit>
        <trans-unit id="4e048da15ca2bf279cd35e525737612e720e444c" translate="yes" xml:space="preserve">
          <source>Always inline the functions.</source>
          <target state="translated">Всегда встраивайте функции.</target>
        </trans-unit>
        <trans-unit id="756f986f9bcdd129940f4871df381abfdb52d4bb" translate="yes" xml:space="preserve">
          <source>Always insert the decimal point and print trailing zeros.</source>
          <target state="translated">Всегда вставляйте десятичную точку и печатайте трейлинговые нули.</target>
        </trans-unit>
        <trans-unit id="e89bec8fb850573de2289bb9dc31383490faf82d" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Всегда возвращает &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28625924634a090c91d5b21229f6718ca1949c53" translate="yes" xml:space="preserve">
          <source>Always returns false (unless the given interval is empty) because an interval beginning at negative infinity can never be after any other interval.</source>
          <target state="translated">Всегда возвращает false (если только заданный интервал не пуст),потому что интервал,начинающийся с отрицательной бесконечности,никогда не может быть после любого другого интервала.</target>
        </trans-unit>
        <trans-unit id="bdadc4badca1a50ef408f60afbd76636c86734c4" translate="yes" xml:space="preserve">
          <source>Always returns false (unless the given interval is empty) because an interval going to positive infinity can never be before any other interval.</source>
          <target state="translated">Всегда возвращает false (если только заданный интервал не пуст),потому что интервал,переходящий в положительную бесконечность,никогда не может быть раньше любого другого интервала.</target>
        </trans-unit>
        <trans-unit id="94fa66f43e494b57c40dedacad5e8fcc5ed7e45e" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty) because a finite interval can never be after an interval going to positive infinity.</source>
          <target state="translated">Всегда возвращает false (если только этот интервал не пуст),потому что конечный интервал никогда не может быть после интервала,переходящего в положительную бесконечность.</target>
        </trans-unit>
        <trans-unit id="d882cba308665fda178b09f0755ed0e7ac35509a" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty) because a finite interval can never be before an interval beginning at negative infinity.</source>
          <target state="translated">Всегда возвращает false (если только этот интервал не пуст),потому что конечный интервал никогда не может быть до интервала,начинающегося на отрицательной бесконечности.</target>
        </trans-unit>
        <trans-unit id="839ddfcb8311f35aad2fb0b8e24e88538a023202" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty), because an interval beginning at negative infinity can never be contained in a finite interval.</source>
          <target state="translated">Всегда возвращает false (если только этот интервал не пуст),потому что интервал,начинающийся с отрицательной бесконечности,никогда не может содержаться в конечном интервале.</target>
        </trans-unit>
        <trans-unit id="3ed45722000fa0537c28f229adeae463146f4016" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty), because an interval going to positive infinity can never be contained in a finite interval.</source>
          <target state="translated">Всегда возвращает false (если только этот интервал не пуст),потому что интервал,переходящий в положительную бесконечность,никогда не может содержаться в конечном интервале.</target>
        </trans-unit>
        <trans-unit id="a53924ebd00c5459aa871927c9ec67510a96dd54" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be after any other interval.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,начинающийся на отрицательной бесконечности,никогда не может быть после любого другого интервала.</target>
        </trans-unit>
        <trans-unit id="d9bab92525c979c53e601d84248db55d697093d3" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be after any time point.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,начинающийся на отрицательной бесконечности,никогда не может быть после любой временной точки.</target>
        </trans-unit>
        <trans-unit id="829c04d974963809ceb0735be3d487911f2864cf" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be before another interval beginning at negative infinity.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,начинающийся на отрицательной бесконечности,никогда не может быть до другого интервала,начинающегося на отрицательной бесконечности.</target>
        </trans-unit>
        <trans-unit id="48190dd4a715744e9634474743dcbc604a9ca68f" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never contain an interval going to positive infinity.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,начинающийся на отрицательной бесконечности,никогда не может содержать интервал,переходящий в положительную бесконечность.</target>
        </trans-unit>
        <trans-unit id="87f5c7255865a6aa09545519f01b0f602d71f734" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be after another interval going to positive infinity.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,переходящий в положительную бесконечность,никогда не может быть после другого интервала,переходящего в положительную бесконечность.</target>
        </trans-unit>
        <trans-unit id="94b78d489ebc6bd76631339902c007afae618abe" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be before any other interval.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,переходящий в положительную бесконечность,никогда не может быть раньше любого другого интервала.</target>
        </trans-unit>
        <trans-unit id="1b622d5187c151cf5715d74c3640dbb076d4394c" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be before any time point.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,переходящий в положительную бесконечность,никогда не может быть до любой временной точки.</target>
        </trans-unit>
        <trans-unit id="46754795cce31e571fe7c4a3849c49251d755cfd" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never contain an interval beginning at negative infinity.</source>
          <target state="translated">Всегда возвращает false,потому что интервал,идущий на положительную бесконечность,никогда не может содержать интервал,начинающийся на отрицательной бесконечности.</target>
        </trans-unit>
        <trans-unit id="51bcc244bd67d8750a4fdd4fbdf0a387caa703aa" translate="yes" xml:space="preserve">
          <source>Always returns false because two intervals beginning at negative infinity can never be adjacent to one another.</source>
          <target state="translated">Всегда возвращает false,потому что два интервала,начинающиеся на отрицательной бесконечности,никогда не могут быть соседними.</target>
        </trans-unit>
        <trans-unit id="5de1beefc377ac68c64f67a4b951a1494a514eb5" translate="yes" xml:space="preserve">
          <source>Always returns false because two intervals going to positive infinity can never be adjacent to one another.</source>
          <target state="translated">Всегда возвращает false,потому что два интервала,переходящие в положительную бесконечность,никогда не могут быть соседними друг с другом.</target>
        </trans-unit>
        <trans-unit id="2e5c51adf29d169f29f627d0dc8290c18d19524d" translate="yes" xml:space="preserve">
          <source>Always returns false.</source>
          <target state="translated">Всегда возвращает ложь.</target>
        </trans-unit>
        <trans-unit id="9789c7e0f94b9d97c7bb5b256c563654386851c1" translate="yes" xml:space="preserve">
          <source>Always returns true because two intervals beginning at negative infinity always overlap.</source>
          <target state="translated">Всегда возвращает true,потому что два интервала,начинающиеся на отрицательной бесконечности,всегда перекрываются.</target>
        </trans-unit>
        <trans-unit id="6ae3ed1006060103837a55fb96e4df45549bbde7" translate="yes" xml:space="preserve">
          <source>Always returns true because two intervals going to positive infinity always overlap.</source>
          <target state="translated">Всегда возвращается к истине,потому что два интервала,переходящие в положительную бесконечность,всегда перекрываются.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="dcf1c44121ab11079f75ad4f70a75125be5a6a9a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#EmailStatus&quot;&gt;&lt;code&gt;EmailStatus&lt;/code&gt;&lt;/a&gt;, indicating the status of the email address.</source>
          <target state="translated">&lt;a href=&quot;#EmailStatus&quot;&gt; &lt;code&gt;EmailStatus&lt;/code&gt; &lt;/a&gt; , указывающий на статус адреса электронной почты.</target>
        </trans-unit>
        <trans-unit id="ffe9a34aa0d7b745cc8f891bddd4b51b3279fa26" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; is a name preceded by a &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; giving the number of characters in the &lt;a href=&quot;#Name&quot;&gt;&lt;i&gt;Name&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; это имя предшествует &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;номер&lt;/i&gt;&lt;/a&gt; дает количество символов в &lt;a href=&quot;#Name&quot;&gt;&lt;i&gt;имени&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9368e81deb8013394f56e991844ff7d8f9e56b8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;expression#ArrayLiteral&quot;&gt;&lt;i&gt;ArrayLiteral&lt;/i&gt;&lt;/a&gt; is inferred to be a dynamic array type rather than a static array:</source>
          <target state="translated">&lt;a href=&quot;expression#ArrayLiteral&quot;&gt;&lt;i&gt;ArrayLiteral&lt;/i&gt;&lt;/a&gt; выводится как тип динамического массива , а не статический массив:</target>
        </trans-unit>
        <trans-unit id="89d876389132db631f40f8472f475c33763a7de8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; that fails its condition</source>
          <target state="translated">&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; , которая не его состояние</target>
        </trans-unit>
        <trans-unit id="6590283f72c8bc68a61e26f8207b2166720f88ee" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_meta#AliasSeq&quot;&gt;&lt;code&gt;std.meta.AliasSeq&lt;/code&gt;&lt;/a&gt; with all possible target types of an implicit conversion &lt;code&gt;T&lt;/code&gt;.  If &lt;code&gt;T&lt;/code&gt; is a class derived from &lt;code&gt;Object&lt;/code&gt;, the the result of &lt;a href=&quot;#TransitiveBaseTypeTuple&quot;&gt;&lt;code&gt;TransitiveBaseTypeTuple&lt;/code&gt;&lt;/a&gt; is returned.  If the type is not a built-in value type or a class derived from &lt;code&gt;Object&lt;/code&gt;, the an empty &lt;a href=&quot;std_meta#AliasSeq&quot;&gt;&lt;code&gt;std.meta.AliasSeq&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;std_meta#AliasSeq&quot;&gt; &lt;code&gt;std.meta.AliasSeq&lt;/code&gt; &lt;/a&gt; со всеми возможными типами целевых неявного преобразования &lt;code&gt;T&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является классом, производным от &lt;code&gt;Object&lt;/code&gt; , возвращается результат &lt;a href=&quot;#TransitiveBaseTypeTuple&quot;&gt; &lt;code&gt;TransitiveBaseTypeTuple&lt;/code&gt; &lt;/a&gt; . Если тип не является встроенным типом значения или классом, производным от &lt;code&gt;Object&lt;/code&gt; , возвращается пустой &lt;a href=&quot;std_meta#AliasSeq&quot;&gt; &lt;code&gt;std.meta.AliasSeq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5357eeb67edd28cef849aec387209e4ff6da64a3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон входного&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5ae81b9680ce568443b4c970f3bc5dc366146d8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;a href=&quot;#DirEntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; от &lt;a href=&quot;#DirEntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f659b816c177344a9a4b993dd7f1f23fa0444745" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of consecutively unique elements in the original range. If &lt;code&gt;r&lt;/code&gt; is also a forward range or bidirectional range, the returned range will be likewise.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; из последовательно уникальных элементов в исходном диапазоне. Если &lt;code&gt;r&lt;/code&gt; также прямой диапазон или двунаправленный диапазон, возвращенный диапазон будет аналогичным образом.</target>
        </trans-unit>
        <trans-unit id="5a3658d6619aac9bf9bbbb396cba995f2c9f0bb3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; элементов</target>
        </trans-unit>
        <trans-unit id="aeb6a5dabc8ee71a80f9364ee1475c7fc12f32a2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements to filter.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; элементов для фильтрации.</target>
        </trans-unit>
        <trans-unit id="707d66d0f4a293729b9673f780ebae8dbcfcc3c1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="33c6aa39a8169309ace06cecc9bf8cd227418643" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of input ranges</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; входных диапазонов</target>
        </trans-unit>
        <trans-unit id="7e44b358ef6f4995ad58c7e05ef241784818aecf" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of input ranges to be joined.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; входных диапазонов, подлежащие соединению.</target>
        </trans-unit>
        <trans-unit id="db74a7a8ef007cbf994b98f4433445f62a98cc07" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of keys</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; ключей</target>
        </trans-unit>
        <trans-unit id="95280f839dfcc7e6fffaf43a757e145f824a67a0" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of segments to assemble the path from.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; сегментов для сборки пути от.</target>
        </trans-unit>
        <trans-unit id="7b7d7db68f90c0aa95feaeaf3c9f2a490793d047" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of slices of the original range split by whitespace.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; срезов исходного разделения диапазона пробелов.</target>
        </trans-unit>
        <trans-unit id="eb75e1af2690fdd4800075d57086bf1d4208ae4b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of tuples of keys and values.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; кортежей ключей и значений.</target>
        </trans-unit>
        <trans-unit id="97ff10ecbc90564b57494f893fe51dd077880140" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of values</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; значений</target>
        </trans-unit>
        <trans-unit id="133de0070e3c643c203f06c3842a5a65269aacef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; over the data to be decoded.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон входного&lt;/a&gt; над данными, подлежащие декодированию.</target>
        </trans-unit>
        <trans-unit id="05ae651266b6aebe6405ca7d3e9d38d6bbda4a2e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; over the data to be encoded.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон входного&lt;/a&gt; над данными, подлежащие кодированию.</target>
        </trans-unit>
        <trans-unit id="53e90b53eb146e6b34d965149154b8c1b40783a3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that exposes references to its elements and has assignable elements</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон ввода&lt;/a&gt; , который предоставляет ссылки на его элементы и имеет назначаемые элементы</target>
        </trans-unit>
        <trans-unit id="ea7d6814c8da44833511f491c47ceb591d626a8d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the bytes of data decoded from a Base64 encoded string.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон ввода&lt;/a&gt; , который перебирает байты данных , декодированных из Base64 закодированных строк.</target>
        </trans-unit>
        <trans-unit id="f0e959040d1e17340e8751524e2d4256b8691ac7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the decoded data of a range of Base64 encodings.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон входного&lt;/a&gt; , который выполняет итерацию по декодированному данному диапазону Base64 кодирования.</target>
        </trans-unit>
        <trans-unit id="43af4719ff15eb275c1c72c27f3b8376924d9bc1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the encoded bytes of the given source data.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; , который выполняет итерацию по закодированным байтам данных исходных данных.</target>
        </trans-unit>
        <trans-unit id="49c67170189246c824452f09ce0e9b881029c595" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the original range's elements, but ends when the specified predicate becomes true. If the original range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or higher, this range will be a forward range.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; , который перебирает элементы в исходном диапазоне, но заканчивается , когда указанный предикат становится истинным. Если исходный диапазон является &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;передним диапазоном&lt;/a&gt; или выше, этот диапазон будет передовым диапазоном.</target>
        </trans-unit>
        <trans-unit id="f1a22b9c6d64de659aa93282f2a2c09eb16b5f23" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the respective Base64 encodings of a range of data items.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон входного&lt;/a&gt; , перебирающие соответствующие Base64 кодирований диапазона элементов данных.</target>
        </trans-unit>
        <trans-unit id="d7f2d0c17c0405fa6b38c89079adc1903c913cb8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to be chunked.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон входного&lt;/a&gt; быть фрагментированным.</target>
        </trans-unit>
        <trans-unit id="c892ebe289689b74313c775aba7569dc3d96121e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with elements that elements from &lt;code&gt;src&lt;/code&gt; can be moved into.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон ввода&lt;/a&gt; с элементами , что элементы из &lt;code&gt;src&lt;/code&gt; могут быть перемещены в.</target>
        </trans-unit>
        <trans-unit id="b62730011ee93bfeac5690d8a28be51290200dce" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with movable elements.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; с подвижными элементами.</target>
        </trans-unit>
        <trans-unit id="501f3d209c91fc5763279ea66a99a52ae9245f3d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with the cached values of range</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Входной диапазон&lt;/a&gt; с кэшированных значений диапазона</target>
        </trans-unit>
        <trans-unit id="965b67bd175b57783d700b642e30d67633838585" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;, or any number of implicitly convertible items to insert into &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;Диапазон входного&lt;/a&gt; , или любое количество неявно конвертируемых элементов для вставки в &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="568cafc64895197463cb35df36675af55e4422de" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; which accepts string types, &lt;code&gt;ubyte[]&lt;/code&gt;, individual character types, and individual &lt;code&gt;ubyte&lt;/code&gt;s.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;Диапазон выходной мощности&lt;/a&gt; , который принимает тип строк, &lt;code&gt;ubyte[]&lt;/code&gt; , отдельные тип символов, а отдельное &lt;code&gt;ubyte&lt;/code&gt; с.</target>
        </trans-unit>
        <trans-unit id="96659bf0ec2c02c0f163ebb47294be48aeeef57c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows reading from the child process' standard error stream.</source>
          <target state="translated">&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; , что позволяет читать из стандартного потока ошибок дочернего процесса.</target>
        </trans-unit>
        <trans-unit id="20e84e08d65e61dcd687cc1797aa39066181d9c1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows reading from the child process' standard output stream.</source>
          <target state="translated">&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; , что позволяет считывать данные со стандартного потока вывода дочернего процесса.</target>
        </trans-unit>
        <trans-unit id="53e5c6c6f6f60588aedc9a37247bd45dc00707bc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows writing to the child process' standard input stream.</source>
          <target state="translated">&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; , что позволяет записать в стандартный поток ввода дочернего процесса.</target>
        </trans-unit>
        <trans-unit id="3e9533a6a3d9a4d55816c193bc0f53b935c22f6d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template#variadic-templates&quot;&gt;expression sequence&lt;/a&gt; of all struct fields - see &lt;a href=&quot;class#class_properties&quot;&gt;Class Properties&lt;/a&gt; for a class-based example.</source>
          <target state="translated">Последовательность &lt;a href=&quot;template#variadic-templates&quot;&gt;выражений&lt;/a&gt; всех структурных полей - см. &lt;a href=&quot;class#class_properties&quot;&gt;Свойства класса&lt;/a&gt; для примера на основе класса.</target>
        </trans-unit>
        <trans-unit id="f3a6583818c5f8f234b1ec03cdc9d796a3fa7ebe" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Address&lt;/code&gt; instance representing specified address.</source>
          <target state="translated">&lt;code&gt;Address&lt;/code&gt; экземпляр , представляющий указанный адрес.</target>
        </trans-unit>
        <trans-unit id="56e2323d99083365dfdf1e12a30b245e969af361" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; containing the values produced by iterating over &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AliasSeq&lt;/code&gt; , содержащее значение , полученное с помощью перебора &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8cfdc9c8275278162fbcaa5be1463495fde71d3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; filtered by the selected stride.</source>
          <target state="translated">&lt;code&gt;AliasSeq&lt;/code&gt; фильтруется выбранным шагом.</target>
        </trans-unit>
        <trans-unit id="20aff1a9df323b6df7883ad0a1e714a382dae9ef" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; of &lt;code&gt;args&lt;/code&gt; with &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; saved.</source>
          <target state="translated">&lt;code&gt;AliasSeq&lt;/code&gt; из &lt;code&gt;args&lt;/code&gt; с &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; и &lt;code&gt;lazy&lt;/code&gt; сохранено.</target>
        </trans-unit>
        <trans-unit id="94b6f12ba21ae4feae1b40330f4a8aa9e0a73296" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Exception&lt;/code&gt; if all of the ranges are not the same length and &lt;code&gt;sp&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; , если все диапазоны не является такой же длиной и &lt;code&gt;sp&lt;/code&gt; установлен в &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d61cad630058a64dcee11973cf4730e528fa9b3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Interval&lt;/code&gt; has a starting point and an end point. The interval of time is therefore the time starting at the starting point up to, but not including, the end point. e.g.</source>
          <target state="translated">&lt;code&gt;Interval&lt;/code&gt; имеет начальную точку и конечную точку. Следовательно, интервал времени - это время, начинающееся с начальной точки до конечной точки, но не включая ее. например</target>
        </trans-unit>
        <trans-unit id="11231347c4e1b61534c1256649e8160ffb845ccb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; типа &lt;code&gt;Target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f32443fe48d10edfa532d0732e99edf167154d6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;extern&lt;/code&gt; declaration can optionally be followed by an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage attribute&lt;/a&gt;. If there is no linkage attribute it defaults to &lt;code&gt;extern(D)&lt;/code&gt;:</source>
          <target state="translated">За объявлением &lt;code&gt;extern&lt;/code&gt; необязательно может следовать &lt;a href=&quot;attribute#linkage&quot;&gt;атрибут связи &lt;/a&gt; &lt;code&gt;extern&lt;/code&gt; . Если атрибута связи нет, по умолчанию используется &lt;code&gt;extern(D)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb13928ebe13144a8f0cde9175549c7ca8ef3240" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; that is 0 if the strings match, &amp;lt;0 if &lt;code&gt;r1&lt;/code&gt; is lexicographically &quot;less&quot; than &lt;code&gt;r2&lt;/code&gt;, &amp;gt;0 if &lt;code&gt;r1&lt;/code&gt; is lexicographically &quot;greater&quot; than &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; это 0 , если совпадают строки, &amp;lt;0 , если &lt;code&gt;r1&lt;/code&gt; лексикографически &amp;laquo;меньше&amp;raquo; , чем &lt;code&gt;r2&lt;/code&gt; ,&amp;gt; 0 , если &lt;code&gt;r1&lt;/code&gt; лексикографически &amp;laquo;больше&amp;raquo; , чем &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efb2860a0ceaf8160fc6745198e13de4de19934e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; that is 0 if the strings match, &amp;lt;0 if &lt;code&gt;str1&lt;/code&gt; is lexicographically &quot;less&quot; than &lt;code&gt;str2&lt;/code&gt;, &amp;gt;0 if &lt;code&gt;str1&lt;/code&gt; is lexicographically &quot;greater&quot; than &lt;code&gt;str2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; это 0 , если совпадают строки, &amp;lt;0 , если &lt;code&gt;str1&lt;/code&gt; лексикографически &amp;laquo;меньше&amp;raquo; , чем &lt;code&gt;str2&lt;/code&gt; ,&amp;gt; 0 , если &lt;code&gt;str1&lt;/code&gt; лексикографически &amp;laquo;больше&amp;raquo; , чем &lt;code&gt;str2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd2a5ae8ac277d08cffcbd8287934b6c72d5390c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;std.typecons.Tuple!(bool, &quot;terminated&quot;, int, &quot;status&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.typecons.Tuple!(bool, &quot;terminated&quot;, int, &quot;status&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b29fdcb57cf0f2aa50c1917aef7ee2d7326de41" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;std.typecons.Tuple!(int, &quot;status&quot;, string, &quot;output&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.typecons.Tuple!(int, &quot;status&quot;, string, &quot;output&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44325a188ea9f569f00f25fe1293e0a22a6a319a" translate="yes" xml:space="preserve">
          <source>An Associative Array can be iterated in key/value fashion using a &lt;a href=&quot;statement#ForeachStatement&quot;&gt;foreach statement&lt;/a&gt;. As an example, the number of occurrences of all possible substrings of length 2 (aka 2-mers) in a string will be counted:</source>
          <target state="translated">Ассоциативный массив может быть повторен в ключе / значении с помощью &lt;a href=&quot;statement#ForeachStatement&quot;&gt;оператора foreach&lt;/a&gt; . Например, будет подсчитано количество вхождений всех возможных подстрок длины 2 (также 2-мерных) в строку:</target>
        </trans-unit>
        <trans-unit id="a90c85005c067a015cf8ee553e7e07506f3cb661" translate="yes" xml:space="preserve">
          <source>An Associative Array defaults to &lt;code&gt;null&lt;/code&gt;, and is constructed upon assigning the first key/value pair. However, once constructed, an associative array has</source>
          <target state="translated">Ассоциативный массив по умолчанию равен &lt;code&gt;null&lt;/code&gt; и создается после назначения первой пары ключ / значение. Однако после построения ассоциативный массив</target>
        </trans-unit>
        <trans-unit id="20dacc2ff7dcec50b018c97c25042104ca6d5e2d" translate="yes" xml:space="preserve">
          <source>An N-dimensional array with individual elements of type T.</source>
          <target state="translated">N-мерный массив с отдельными элементами типа T.</target>
        </trans-unit>
        <trans-unit id="487b65ed273d46d619268b1cf5574bd84b4db939" translate="yes" xml:space="preserve">
          <source>An OutputRange for accepting possibly piecewise segments of the formatted string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374153a385906e41868a8afe177a5c76f263689c" translate="yes" xml:space="preserve">
          <source>An OutputRange that discards the data it receives.</source>
          <target state="translated">OutputRange,который отбрасывает получаемые данные.</target>
        </trans-unit>
        <trans-unit id="e7013471ca7cfba239c38e91976beb8fce0d63dd" translate="yes" xml:space="preserve">
          <source>An abstract character does not necessarily correspond to what a user thinks of as a &amp;ldquo;character&amp;rdquo; and should not be confused with a &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Абстрактный символ не обязательно соответствует тому, что пользователь считает &amp;laquo;персонажем&amp;raquo;, и его не следует путать с &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdba09e2a7de450eb20cc61c51e59eb62e78cd9a" translate="yes" xml:space="preserve">
          <source>An abstract character has no concrete form and should not be confused with a &lt;a href=&quot;#Glyph&quot;&gt;glyph&lt;/a&gt;.</source>
          <target state="translated">Абстрактный символ не имеет конкретной формы и его не следует путать с &lt;a href=&quot;#Glyph&quot;&gt;глифом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5231e46b8fbe9153560533f1e9c30f8aa007e730" translate="yes" xml:space="preserve">
          <source>An abstract member function must be overridden by a derived class. Only virtual member functions may be declared abstract; non-virtual member functions and free-standing functions cannot be declared abstract.</source>
          <target state="translated">Абстрактная функция-член должна быть переопределена производным классом.Только виртуальные членские функции могут быть объявлены абстрактными;невиртуальные членские функции и свободно стоящие функции не могут быть объявлены абстрактными.</target>
        </trans-unit>
        <trans-unit id="4533566ebe9595ef8c3fb7a85a6b2b8cded96094" translate="yes" xml:space="preserve">
          <source>An additional hidden argument with the name &lt;code&gt;_arguments&lt;/code&gt; and type &lt;code&gt;TypeInfo[]&lt;/code&gt; is passed to the function. &lt;code&gt;_arguments&lt;/code&gt; gives the number of arguments and the type of each, enabling type safety to be checked at run time.</source>
          <target state="translated">Дополнительный скрытый аргумент с именем &lt;code&gt;_arguments&lt;/code&gt; и типом &lt;code&gt;TypeInfo[]&lt;/code&gt; передается функции. &lt;code&gt;_arguments&lt;/code&gt; дает количество аргументов и тип каждого, что позволяет проверять безопасность типов во время выполнения.</target>
        </trans-unit>
        <trans-unit id="3b6d0293666de158be3f12d22968c31c56140ac3" translate="yes" xml:space="preserve">
          <source>An adjustor thunk looks like:</source>
          <target state="translated">Похоже на регулировочный ствол:</target>
        </trans-unit>
        <trans-unit id="0847d49328423d89a734c43cd88e9b79a0544a70" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;minAlign&lt;/code&gt;, which must be a valid alignment (nonzero power of 2). The start of the region and all allocation requests will be rounded up to a multiple of the alignment.</source>
          <target state="translated">Псевдоним для &lt;code&gt;minAlign&lt;/code&gt; , который должен быть действительным выравниванием (ненулевая степень 2). Начало региона и все запросы на выделение будут округлены до кратности выравнивания.</target>
        </trans-unit>
        <trans-unit id="9993ac9ea2f6651d34b1aa2a448a3c14badfcb90" translate="yes" xml:space="preserve">
          <source>An alternate form of wysiwyg strings are enclosed by backquotes, the ` character.</source>
          <target state="translated">Альтернативная форма строк wysiwyg заключена в обратные кавычки,символ `.</target>
        </trans-unit>
        <trans-unit id="ffb2ff8aaa0d0c4fff2997632dac364705c0344c" translate="yes" xml:space="preserve">
          <source>An alternative version of curl_multi_perform() that allows the application to pass in one of the file descriptors that have been detected to have &quot;action&quot; on them and let libcurl perform. See man page for details.</source>
          <target state="translated">Альтернативная версия функции curl_multi_perform(),позволяющая программе передавать в одном из обнаруженных файловых дескрипторов &quot;действие&quot; и позволяющая выполнять libcurl.Подробнее см.страницу man.</target>
        </trans-unit>
        <trans-unit id="67aef8339b904d4fa6032e3895c0a4baeec8d2c9" translate="yes" xml:space="preserve">
          <source>An anonymous nested class is both defined and instantiated with a</source>
          <target state="translated">Анонимный вложенный класс определяется и подкрепляется a</target>
        </trans-unit>
        <trans-unit id="d63365263610e01c1d62435a1eb9cc035af6a065" translate="yes" xml:space="preserve">
          <source>An anonymous struct with the members &lt;code&gt;isoWeekYear&lt;/code&gt; for the resulting year and &lt;code&gt;isoWeek&lt;/code&gt; for the resulting ISO week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6df80b73f182ab7ff7950f3a7e97396adcc2088" translate="yes" xml:space="preserve">
          <source>An arbitrary-precision integer type.</source>
          <target state="translated">Целый тип произвольной точности.</target>
        </trans-unit>
        <trans-unit id="a3c537c68c1280a36448d29d7b84b05b6066936e" translate="yes" xml:space="preserve">
          <source>An argument to a &lt;code&gt;lazy&lt;/code&gt; parameter is not evaluated before the function is called. The argument is only evaluated if/when the parameter is evaluated within the function. Hence, a &lt;code&gt;lazy&lt;/code&gt; argument can be executed 0 or more times.</source>
          <target state="translated">Аргумент &lt;code&gt;lazy&lt;/code&gt; параметра не оценивается до вызова функции. Аргумент оценивается только если / когда параметр вычисляется внутри функции. Следовательно, &lt;code&gt;lazy&lt;/code&gt; аргумент может быть выполнен 0 или более раз.</target>
        </trans-unit>
        <trans-unit id="ea18ca730a0aa21281c1af9096a60b9ecf44e189" translate="yes" xml:space="preserve">
          <source>An array containing references to all threads currently being tracked by the system. The result of deleting any contained objects is undefined.</source>
          <target state="translated">Массив,содержащий ссылки на все потоки,которые в настоящее время отслеживаются системой.Результат удаления любых содержащихся в нем объектов не определен.</target>
        </trans-unit>
        <trans-unit id="77815bde2a83a1011d8ecf1e77f89465ef4b38cb" translate="yes" xml:space="preserve">
          <source>An array containing the divided parts of &lt;code&gt;range&lt;/code&gt; (or the words of &lt;code&gt;s&lt;/code&gt;).</source>
          <target state="translated">Массив, содержащий разделенные части &lt;code&gt;range&lt;/code&gt; (или слова &lt;code&gt;s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="daec8cadf3d6935e405e9c172ddf7e64c36f7c31" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;Statement&lt;/code&gt;s, that will referenced by this class</source>
          <target state="translated">Массив &lt;code&gt;Statement&lt;/code&gt; s, на который будет ссылаться этот класс</target>
        </trans-unit>
        <trans-unit id="29fa536473a8fa6b0ec875c2597efa9dce1d5e34" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;T&lt;/code&gt; with &lt;code&gt;I.length&lt;/code&gt; dimensions.</source>
          <target state="translated">Массив &lt;code&gt;T&lt;/code&gt; с размерами &lt;code&gt;I.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="479c220b9bb5c5c461e1a646be4bf0d486b927a9" translate="yes" xml:space="preserve">
          <source>An array of complex numbers representing the transformed data in the frequency domain.</source>
          <target state="translated">Массив комплексных чисел,представляющих преобразованные данные в частотной области.</target>
        </trans-unit>
        <trans-unit id="f0621e8fe8af51735a47c76956cd2a28911a1a9f" translate="yes" xml:space="preserve">
          <source>An array of elements</source>
          <target state="translated">Массив элементов</target>
        </trans-unit>
        <trans-unit id="7326b4532e3c0a6987d70e29c99a0d57edd13a68" translate="yes" xml:space="preserve">
          <source>An array of path to D modules</source>
          <target state="translated">Массив путей к модулям D</target>
        </trans-unit>
        <trans-unit id="fbfc4f55870a8b45855e77b9502741089e3999c7" translate="yes" xml:space="preserve">
          <source>An array of paths to assemble.</source>
          <target state="translated">Массив путей для сборки.</target>
        </trans-unit>
        <trans-unit id="6eeb3c945dc78c366a34ecd56e6cc4c9081dc7db" translate="yes" xml:space="preserve">
          <source>An array of regular expression strings. The resulting &lt;code&gt;Regex&lt;/code&gt; object will match any expression; use &lt;a href=&quot;#whichPattern&quot;&gt;&lt;code&gt;whichPattern&lt;/code&gt;&lt;/a&gt; to know which.</source>
          <target state="translated">Массив строк регулярных выражений. Полученный объект &lt;code&gt;Regex&lt;/code&gt; будет соответствовать любому выражению; используйте &lt;a href=&quot;#whichPattern&quot;&gt; &lt;code&gt;whichPattern&lt;/code&gt; ,&lt;/a&gt; чтобы узнать, какой.</target>
        </trans-unit>
        <trans-unit id="418fbbabc9dc07ec6379ba1dda3419b4c8dd83da" translate="yes" xml:space="preserve">
          <source>An array of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">Массив типа &lt;code&gt;Target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81574167760f6ba7a1bdd1dc1d384e2cfcd701d9" translate="yes" xml:space="preserve">
          <source>An array or asssociative array literal. &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; is the length of the array. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt; is repeated &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times for a normal array, and 2 * &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times for an associative array.</source>
          <target state="translated">Массив или ассоциативный массив литерал. &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Число&lt;/i&gt;&lt;/a&gt; - это длина массива. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Значение&lt;/i&gt;&lt;/a&gt; повторяется &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Количество&lt;/i&gt;&lt;/a&gt; раз для нормального массива и 2 * &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Количество&lt;/i&gt;&lt;/a&gt; раз для ассоциативного массива.</target>
        </trans-unit>
        <trans-unit id="039c70efd683d3e9b93b4df14d2d6d5c5145b436" translate="yes" xml:space="preserve">
          <source>An array that consists of &lt;code&gt;s&lt;/code&gt; repeated &lt;code&gt;n&lt;/code&gt; times. This function allocates, fills, and returns a new array.</source>
          <target state="translated">Массив, состоящий из &lt;code&gt;s&lt;/code&gt; , повторенных &lt;code&gt;n&lt;/code&gt; раз. Эта функция выделяет, заполняет и возвращает новый массив.</target>
        </trans-unit>
        <trans-unit id="17d3bd6e24229484523be9a3c75e2496e09c2fce" translate="yes" xml:space="preserve">
          <source>An array which contains the program name as the zeroth element and any command-line arguments in the following elements.</source>
          <target state="translated">Массив,содержащий имя программы в качестве нулевого элемента и любые аргументы командной строки в следующих элементах.</target>
        </trans-unit>
        <trans-unit id="1ab896a4e586f016dcbd9051e137d42864250451" translate="yes" xml:space="preserve">
          <source>An array which contains the program name as the zeroth element and any command-line arguments in the following elements. (See &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Массив, который содержит имя программы в качестве нулевого элемента и любые аргументы командной строки в следующих элементах. (Подробнее см. &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="3b92a8e452fa62db1566192e1dffdc9e80610f68" translate="yes" xml:space="preserve">
          <source>An array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Массив с тем же типом элемента, что и &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598dedc2bf0e9cd988bf5a32f1e674f47e9054d4" translate="yes" xml:space="preserve">
          <source>An asm statement enables the direct use of assembly language instructions. This makes it easy to obtain direct access to special CPU features without resorting to an external assembler. The D compiler will take care of the function calling conventions, stack setup, etc.</source>
          <target state="translated">Оператор asm позволяет напрямую использовать инструкции по языку ассемблера.Это позволяет легко получить прямой доступ к специальным функциям процессора,не прибегая к помощи внешнего ассемблера.Компилятор D позаботится о протоколах вызова функций,настройке стека и т.д.</target>
        </trans-unit>
        <trans-unit id="8302b7bfc189e1b4c0ac50685a98310945e13267" translate="yes" xml:space="preserve">
          <source>An associative array can be tested to see if an element is in the array:</source>
          <target state="translated">Ассоциативный массив можно протестировать на наличие элемента в массиве:</target>
        </trans-unit>
        <trans-unit id="49ca254b18c53b1fdc472fc9a630aa9f28626fc3" translate="yes" xml:space="preserve">
          <source>An associative array is safe when all its keys and elements are safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63634bc46188cedd4498192107dab899f5055fcb" translate="yes" xml:space="preserve">
          <source>An associative array mapping elements to weights.</source>
          <target state="translated">Ассоциативный массив,сопоставляющий элементы массива с весами.</target>
        </trans-unit>
        <trans-unit id="ff67502c32274c3ab17b5bd51317488c7f9e8d17" translate="yes" xml:space="preserve">
          <source>An associative array of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="translated">Ассоциативный массив типа &lt;code&gt;Target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="956aeaeb58bfe5aa034cd122a587434b8ac88521" translate="yes" xml:space="preserve">
          <source>An attacker wants to send harmful data to your server, which requires a integrity HMAC SHA1 token signed with a secret.</source>
          <target state="translated">Злоумышленник хочет отправить вредоносные данные на ваш сервер,что требует целостности маркера HMAC SHA1,подписанного секретом.</target>
        </trans-unit>
        <trans-unit id="be28bdcc45d4da897969c562a4da4fd240bfaeb2" translate="yes" xml:space="preserve">
          <source>An attractive feature of UUIDs when compared to alternatives is their relative small size, of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require a centralized authority.</source>
          <target state="translated">Привлекательной особенностью UUID по сравнению с альтернативами является их сравнительно небольшой размер,128 бит,или 16 байт.Другой особенностью является то,что для создания UUIDs не требуется наличие централизованного органа.</target>
        </trans-unit>
        <trans-unit id="7195e6cce01f1fb7dad70c303c1f8649fcd1f03b" translate="yes" xml:space="preserve">
          <source>An auto function is declared without a return type. If it does not already have a storage class, use the auto storage class.</source>
          <target state="translated">Автоматическая функция объявляется без типа возврата.Если она еще не имеет класса хранения,используйте класс автоматического хранения.</target>
        </trans-unit>
        <trans-unit id="03d538bd3cecd7df878dcb400c90734b77cf2b23" translate="yes" xml:space="preserve">
          <source>An auto ref function template parameter becomes a ref parameter if its corresponding argument is an lvalue, otherwise it becomes a value parameter:</source>
          <target state="translated">Автоматический шаблонный параметр функции ref становится параметром ref,если его соответствующим аргументом является lvalue,в противном случае он становится параметром value:</target>
        </trans-unit>
        <trans-unit id="14284ad6c006c28b3ea6130bf5b64152ddb04c86" translate="yes" xml:space="preserve">
          <source>An eager version of &lt;code&gt;splitter&lt;/code&gt; that creates an array with splitted slices of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">Готовая версия &lt;code&gt;splitter&lt;/code&gt; который создает массив с разделенными фрагментами &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d74290ce6e26cbf9d133491fbe882725c8fd224" translate="yes" xml:space="preserve">
          <source>An earlier version of the documentation incorrectly stated that &lt;code&gt;-1&lt;/code&gt; is the only negative value returned and &lt;code&gt;1&lt;/code&gt; is the only positive value returned. Whether that is true depends on the types being compared.</source>
          <target state="translated">В более ранней версии документации неправильно указывалось, что &lt;code&gt;-1&lt;/code&gt; - единственное возвращаемое отрицательное значение, а &lt;code&gt;1&lt;/code&gt; - единственное возвращаемое положительное значение. Верно ли это, зависит от сравниваемых типов.</target>
        </trans-unit>
        <trans-unit id="564af87619e62a538d43ce07aa464a50505648ac" translate="yes" xml:space="preserve">
          <source>An email status code, indicating if an email address is valid or not. If it is invalid it also indicates why.</source>
          <target state="translated">Код статуса электронной почты,указывающий,является ли адрес электронной почты действительным или нет.Если он недействителен,он также указывает,почему.</target>
        </trans-unit>
        <trans-unit id="57821790126b7d9653db7d5ab96220cb8a8449b5" translate="yes" xml:space="preserve">
          <source>An embedded list builds a most-recently-used strategy: the most recent allocators used in calls to either &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt; (successful calls only), or &lt;code&gt;deallocate&lt;/code&gt; are tried for new allocations in order of their most recent use. Thus, although core operations take in theory &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;) time for &lt;code&gt;k&lt;/code&gt; allocators in current use, in many workloads the factor is sublinear. Details of the actual strategy may change in future releases.</source>
          <target state="translated">Встроенный список создает стратегию, которая использовалась в последнее время: самые последние распределители, используемые в вызовах для &lt;code&gt;allocate&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; (только успешные вызовы) или &lt;code&gt;deallocate&lt;/code&gt; , пробуются для новых распределений в порядке их последнего использования. Таким образом, хотя основные операции в теории занимают &amp;Omicron; ( &lt;code&gt;k&lt;/code&gt; ) времени для &lt;code&gt;k&lt;/code&gt; распределителей в текущем использовании, во многих рабочих нагрузках коэффициент является сублинейным. Детали реальной стратегии могут измениться в будущих выпусках.</target>
        </trans-unit>
        <trans-unit id="7e2d7c3c03945c2979ade27d1766c3427f23af71" translate="yes" xml:space="preserve">
          <source>An empty enum body (For example &lt;code&gt;enum E;&lt;/code&gt;) signifies an opaque enum - the enum members are unknown.</source>
          <target state="translated">Пустое тело перечисления (например, &lt;code&gt;enum E;&lt;/code&gt; ) означает непрозрачное перечисление - члены перечисления неизвестны.</target>
        </trans-unit>
        <trans-unit id="182b823f47405fe4bd517067833d2431e24dcb91" translate="yes" xml:space="preserve">
          <source>An empty range.</source>
          <target state="translated">Пустой участок.</target>
        </trans-unit>
        <trans-unit id="1b60e63467d1ead57d7b824f987eda3203e244a7" translate="yes" xml:space="preserve">
          <source>An entire program can be written in &lt;b&gt;BetterC&lt;/b&gt; by supplying a C &lt;code&gt;main()&lt;/code&gt; function:</source>
          <target state="translated">Вся программа может быть написана на &lt;b&gt;BetterC&lt;/b&gt; с помощью функции C &lt;code&gt;main()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42f22d22943ec9876daf38f246747335b3206a97" translate="yes" xml:space="preserve">
          <source>An enum can be implicitly converted to its base type, but going the other way requires an explicit conversion. For example:</source>
          <target state="translated">Перечисление может быть неявно преобразовано в свой базовый тип,но для перехода в другую сторону требуется явное преобразование.Например:</target>
        </trans-unit>
        <trans-unit id="20274664503ab2b78599fa35b2c6976d6732af22" translate="yes" xml:space="preserve">
          <source>An enum can have multiple members which have the same value. If you want to use EnumMembers to e.g. generate switch cases at compile-time, you should use the &lt;a href=&quot;std_meta#NoDuplicates&quot;&gt;&lt;code&gt;std.meta.NoDuplicates&lt;/code&gt;&lt;/a&gt; template to avoid generating duplicate switch cases.</source>
          <target state="translated">Перечисление может иметь несколько членов, имеющих одинаковое значение. Если вы хотите использовать EnumMembers, например, для генерации наблюдений за переключениями во время компиляции, вам следует использовать шаблон &lt;a href=&quot;std_meta#NoDuplicates&quot;&gt; &lt;code&gt;std.meta.NoDuplicates&lt;/code&gt; ,&lt;/a&gt; чтобы избежать генерации повторяющихся наблюдений за переключениями.</target>
        </trans-unit>
        <trans-unit id="9ccb5e54934db47a114cb48c08f87f6a9591ebdc" translate="yes" xml:space="preserve">
          <source>An enumerated type. &lt;code&gt;E&lt;/code&gt; may have duplicated values.</source>
          <target state="translated">Перечисляемый тип. &lt;code&gt;E&lt;/code&gt; может иметь дублированные значения.</target>
        </trans-unit>
        <trans-unit id="1735ccd74a7dfbde9ac3516d787c61e34b65fdd9" translate="yes" xml:space="preserve">
          <source>An environment without an operating system (such as Bare-metal targets)</source>
          <target state="translated">Среда без операционной системы (например,мишени из голого металла).</target>
        </trans-unit>
        <trans-unit id="f809d6288855134dff456bf6ac1c95f894cfd5e3" translate="yes" xml:space="preserve">
          <source>An error message supplied by the user.</source>
          <target state="translated">Сообщение об ошибке,предоставленное пользователем.</target>
        </trans-unit>
        <trans-unit id="22b5aeaf7859c416b77cbb971c1f98412c7e91a6" translate="yes" xml:space="preserve">
          <source>An even permutation is one which is produced by swapping an even number of pairs of elements in the original range. The set of</source>
          <target state="translated">Равномерная перестановка-это такая,которая производится путем замены четного количества пар элементов в исходном диапазоне.Набор</target>
        </trans-unit>
        <trans-unit id="bf3445745f98506a937cbbe828a5f495bdf57758" translate="yes" xml:space="preserve">
          <source>An example Scheduler using Fibers.</source>
          <target state="translated">Пример Планировщика с использованием волокон.</target>
        </trans-unit>
        <trans-unit id="c8895ad0e3d621b831278de48f37930b071bff33" translate="yes" xml:space="preserve">
          <source>An example Scheduler using kernel threads.</source>
          <target state="translated">Пример планировщика с использованием потоков ядра.</target>
        </trans-unit>
        <trans-unit id="26be4513512b7649f788720ecf8495f76d5a5e27" translate="yes" xml:space="preserve">
          <source>An example using this might be:</source>
          <target state="translated">Пример использования этого может быть:</target>
        </trans-unit>
        <trans-unit id="8a9fd3843ecc8c2de2413f35d41e6dffcb1a7e0f" translate="yes" xml:space="preserve">
          <source>An exception that signals a problem with starting or waiting for a process.</source>
          <target state="translated">Исключение,которое сигнализирует о проблеме с запуском или ожиданием процесса.</target>
        </trans-unit>
        <trans-unit id="da1bd43b320d9d6951e218332ce5fe294afbcb16" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;break&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt; label can be used to avoid this limitation. (Note that &lt;code&gt;static foreach&lt;/code&gt; itself cannot be broken nor continued even if it is explicitly labeled.)</source>
          <target state="translated">Явная метка &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; может использоваться, чтобы избежать этого ограничения. (Обратите внимание, что сам &lt;code&gt;static foreach&lt;/code&gt; не может быть нарушен или продолжен, даже если он явно помечен.)</target>
        </trans-unit>
        <trans-unit id="e4c419979ff292482ec7caed76ce12cf20cdff6d" translate="yes" xml:space="preserve">
          <source>An explicit seed may be provided as the first argument. If provided, it is used as the seed for all work units and for the final reduction of results from all work units. Therefore, if it is not the identity value for the operation being performed, results may differ from those generated by &lt;a href=&quot;std_algorithm_iteration#reduce&quot;&gt;&lt;code&gt;std.algorithm.iteration.reduce&lt;/code&gt;&lt;/a&gt; or depending on how many work units are used. The next argument must be the range to be reduced.</source>
          <target state="translated">Явное начальное число может быть предоставлено в качестве первого аргумента. Если предусмотрено, оно используется в качестве начального числа для всех рабочих единиц и для окончательного сокращения результатов всех рабочих единиц. Поэтому, если это не значение идентификации для выполняемой операции, результаты могут отличаться от результатов, генерируемых &lt;a href=&quot;std_algorithm_iteration#reduce&quot;&gt; &lt;code&gt;std.algorithm.iteration.reduce&lt;/code&gt; ,&lt;/a&gt; или в зависимости от того, сколько рабочих единиц используется. Следующим аргументом должен быть диапазон, который нужно уменьшить.</target>
        </trans-unit>
        <trans-unit id="813be4ff1857df0549bcdcfd3e08cf103fc4ef9a" translate="yes" xml:space="preserve">
          <source>An explicit work unit size may be specified as the last argument. Specifying too small a work unit size will effectively serialize the reduction, as the final reduction of the result of each work unit will dominate computation time. If &lt;code&gt;TaskPool.size&lt;/code&gt; for this instance is zero, this parameter is ignored and one work unit is used.</source>
          <target state="translated">Явный размер рабочего блока может быть указан в качестве последнего аргумента. Задание слишком маленького размера рабочего элемента будет эффективно сериализовать сокращение, поскольку окончательное уменьшение результата каждого рабочего элемента будет доминировать во времени вычислений. Если значение &lt;code&gt;TaskPool.size&lt;/code&gt; для этого экземпляра равно нулю, этот параметр игнорируется и используется одна рабочая единица.</target>
        </trans-unit>
        <trans-unit id="a0fd613c26e74a1b3f4e55de4f7a9e820062689a" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of operators and operands that specifies an evaluation. The syntax, order of evaluation, and semantics of expressions are as follows.</source>
          <target state="translated">Выражение-это последовательность операторов и операндов,задающих оценку.Синтаксис,порядок вычислений и семантика выражений следующие.</target>
        </trans-unit>
        <trans-unit id="06fe4315b1fb38b822d67e7c040bc5b1f34c50c5" translate="yes" xml:space="preserve">
          <source>An expression may be converted from immutable to mutable if the expression is unique.</source>
          <target state="translated">Выражение может быть преобразовано из неизменяемого в мутируемое,если оно уникально.</target>
        </trans-unit>
        <trans-unit id="405b72bbf5cd1ecea0f847f041852bc8f1e21267" translate="yes" xml:space="preserve">
          <source>An expression may be converted from mutable or shared to immutable if the expression is unique and all expressions it transitively refers to are either unique or immutable.</source>
          <target state="translated">Выражение может быть преобразовано из мутируемого или совместно используемого в неизменяемое,если оно уникально и все выражения,на которые оно переходно ссылается,являются либо уникальными,либо неизменяемыми.</target>
        </trans-unit>
        <trans-unit id="038c4cfe80a0e1283f840551b0b9c6235c040703" translate="yes" xml:space="preserve">
          <source>An expression may be converted from mutable to shared if the expression is unique and all expressions it transitively refers to are either unique, immutable, or shared.</source>
          <target state="translated">Выражение может быть преобразовано из mutable в shared,если оно уникально и все выражения,на которые оно переходно ссылается,являются либо уникальными,либо неизменными,либо общими.</target>
        </trans-unit>
        <trans-unit id="1316dd74d7c8ddd73ce90ec6a71f0202d5cfedc3" translate="yes" xml:space="preserve">
          <source>An expression may be converted from shared to mutable if the expression is unique.</source>
          <target state="translated">Выражение может быть преобразовано из общего в мутируемое,если оно уникально.</target>
        </trans-unit>
        <trans-unit id="2ed051b5f24cb3bdb14e7ca6dadf808a8182256e" translate="yes" xml:space="preserve">
          <source>An expression that contains no side effects.</source>
          <target state="translated">Выражение,не содержащее побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="14b91d68f1409c403821f7e2395540ae4efe1e65" translate="yes" xml:space="preserve">
          <source>An expression that discards its result. If the argument is null or not a CommaExp, nothing happens.</source>
          <target state="translated">Выражение,отбрасывающее его результат.Если аргумент равен нулю или не является CommaExp,то ничего не происходит.</target>
        </trans-unit>
        <trans-unit id="2da87c9bf77a96f0a7e8a08472638759b2796da0" translate="yes" xml:space="preserve">
          <source>An identifier that corresponds to each static field in this struct will be placed in the identifier pool.</source>
          <target state="translated">В пул идентификаторов будет помещен идентификатор,соответствующий каждому статическому полю в данной структуре.</target>
        </trans-unit>
        <trans-unit id="29be0b87cd939460b9a6e031fd7b9746d13400f2" translate="yes" xml:space="preserve">
          <source>An identity assignment overload is required for a struct if one or more of these conditions hold:</source>
          <target state="translated">Для структуры требуется перегрузка задания идентификации,если одно или несколько из этих условий выполняются:</target>
        </trans-unit>
        <trans-unit id="c62cfceef6921debd60c6c989b8a6621704ef9cf" translate="yes" xml:space="preserve">
          <source>An immutable or const type qualifier can be removed with a cast:</source>
          <target state="translated">Непрерывный или константный классификатор типа может быть удален с помощью литья:</target>
        </trans-unit>
        <trans-unit id="1978b5c17c98e8bf28acd8b0134128096257bb6e" translate="yes" xml:space="preserve">
          <source>An implementation is free to perform heap compaction and copying so long as no valid GC pointers are invalidated in the process. However, memory allocated with &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_MOVE&quot;&gt;NO_MOVE&lt;/a&gt;&lt;/code&gt; must not be moved/copied.</source>
          <target state="translated">Реализация может выполнять сжатие и копирование кучи до тех пор, пока в процессе не будут недействительными действительные указатели GC. Однако память выделяется с помощью &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_MOVE&quot;&gt;NO_MOVE&lt;/a&gt;&lt;/code&gt; нельзя перемещать / копировать.</target>
        </trans-unit>
        <trans-unit id="f4a12d968ae65e1a6afdfd511c35a5dc8f841297" translate="yes" xml:space="preserve">
          <source>An implementation may assume that a &lt;code&gt;pure&lt;/code&gt; function that (a) accepts only parameters without mutable indirections, and (b) returns a result without mutable indirections, will have the same effect for all invocation with equivalent arguments, and is allowed to memoize the result of the function under the assumption that equivalent parameters always produce equivalent results. Such functions are termed</source>
          <target state="translated">Реализация может предполагать, что &lt;code&gt;pure&lt;/code&gt; функция, которая (a) принимает только параметры без изменяемых косвенных указаний и (b) возвращает результат без изменяемых косвенных указателей, будет иметь тот же эффект для всех вызовов с эквивалентными аргументами и может запоминать результат функция в предположении, что эквивалентные параметры всегда дают эквивалентные результаты. Такие функции называются</target>
        </trans-unit>
        <trans-unit id="ebe5dd05444d0198f9f66e793ceca70c1980b807" translate="yes" xml:space="preserve">
          <source>An implementation may construct the object or array instance on the stack. Therefore, it is an error to refer to that instance after the variadic function has returned:</source>
          <target state="translated">Реализация может построить объект или экземпляр массива на стеке.Следовательно,обращение к этому экземпляру после возвращения вариадической функции является ошибкой:</target>
        </trans-unit>
        <trans-unit id="74288b66176460a92a66dcc8ea28e93696886600" translate="yes" xml:space="preserve">
          <source>An implementation may perform transformations on floating point computations in order to reduce their strength, i.e. their runtime computation time. Because floating point math does not precisely follow mathematical rules, some transformations are not valid, even though some other programming languages still allow them.</source>
          <target state="translated">Реализация может выполнять преобразования на вычислениях с плавающей точкой,чтобы уменьшить их силу,т.е.время их выполнения.Так как математика с плавающей запятой не точно следует математическим правилам,некоторые преобразования не действительны,хотя некоторые другие языки программирования все еще позволяют их выполнять.</target>
        </trans-unit>
        <trans-unit id="3ce778a63881d05f0438cdea7125a850f6f3ff60" translate="yes" xml:space="preserve">
          <source>An implementation may provide a means of overriding the cycle detection abort. A typical method uses the D Runtime switch &lt;code&gt;--DRT-oncycle=...&lt;/code&gt; where the following behaviors are supported:</source>
          <target state="translated">Реализация может обеспечить средство отмены прерывания обнаружения цикла. Типичный метод использует переключатель времени выполнения D &lt;code&gt;--DRT-oncycle=...&lt;/code&gt; , где поддерживается следующее поведение:</target>
        </trans-unit>
        <trans-unit id="29f794447dac8202e31e213bb8c23478c8aa558d" translate="yes" xml:space="preserve">
          <source>An implementation may rearrange the evaluation of expressions according to arithmetic associativity and commutativity rules as long as, within that thread of execution, no observable difference is possible.</source>
          <target state="translated">Реализация может перестраивать оценку выражений в соответствии с правилами арифметической ассоциативности и коммутативности до тех пор,пока в рамках этого потока исполнения не будет наблюдаемых различий.</target>
        </trans-unit>
        <trans-unit id="2f7ecd52c6b042334def208ec0513d80f9a2a5ed" translate="yes" xml:space="preserve">
          <source>An import can be explicitly declared</source>
          <target state="translated">Импорт может быть явно декларирован</target>
        </trans-unit>
        <trans-unit id="38f4d49a07266de3b15530c1f9a75863df6ff329" translate="yes" xml:space="preserve">
          <source>An improved D function for formatted output is &lt;code&gt;std.stdio.writef()&lt;/code&gt;.</source>
          <target state="translated">Улучшенная функция D для форматированного вывода - это &lt;code&gt;std.stdio.writef()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9cb97ce4508c3a47fa6274780fa6593ebb6be60" translate="yes" xml:space="preserve">
          <source>An infinity was generated by division by zero</source>
          <target state="translated">Бесконечность была сгенерирована делением на ноль</target>
        </trans-unit>
        <trans-unit id="6890806a1ad6818323e1006abea77b6b3d37709f" translate="yes" xml:space="preserve">
          <source>An infinity was generated by overflow</source>
          <target state="translated">Переполнение породило бесконечность</target>
        </trans-unit>
        <trans-unit id="ae9c3bc7805fd7227432d2eaa0eab014f342aca5" translate="yes" xml:space="preserve">
          <source>An initialized &lt;code&gt;RefCounted&lt;/code&gt; containing &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">Инициализированный &lt;code&gt;RefCounted&lt;/code&gt; содержащий &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87972790a4f1887f61efbff5428d42aa21b25d17" translate="yes" xml:space="preserve">
          <source>An inline comment that is ignored while matching.</source>
          <target state="translated">Встроенный комментарий,который игнорируется при совпадении.</target>
        </trans-unit>
        <trans-unit id="85da1ce1be9cc229a0d38aa534ff7a6f98704992" translate="yes" xml:space="preserve">
          <source>An input range R as defined by &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;Contents&lt;/code&gt; is a struct, class, or an associative array, the element type of R is &lt;code&gt;Contents&lt;/code&gt;, otherwise the element type of R is itself a range with element type &lt;code&gt;Contents&lt;/code&gt;.  If a &lt;code&gt;header&lt;/code&gt; argument is provided, the returned range provides a &lt;code&gt;header&lt;/code&gt; field for accessing the header from the input in array form.</source>
          <target state="translated">Диапазон ввода R, определенный &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt; . Когда &lt;code&gt;Contents&lt;/code&gt; является структурой, классом или ассоциативным массивом, типом элемента R является &lt;code&gt;Contents&lt;/code&gt; , в противном случае тип элемента R сам по себе является диапазоном с типом элемента &lt;code&gt;Contents&lt;/code&gt; . Если &lt;code&gt;header&lt;/code&gt; аргумент заголовка , возвращаемый диапазон предоставляет поле &lt;code&gt;header&lt;/code&gt; для доступа к заголовку из ввода в виде массива.</target>
        </trans-unit>
        <trans-unit id="8233ac502082d5effa82f80dbc2e0cac66b1db40" translate="yes" xml:space="preserve">
          <source>An input range at minimum. If all of the ranges in &lt;code&gt;rs&lt;/code&gt; provide a range primitive, the returned range will also provide that range primitive.</source>
          <target state="translated">Диапазон ввода минимален. Если все диапазоны в &lt;code&gt;rs&lt;/code&gt; предоставляют примитив диапазона, возвращаемый диапазон также предоставит этот примитив диапазона.</target>
        </trans-unit>
        <trans-unit id="e7168e31c32e5919f60149f7ae2d8c075d8657c9" translate="yes" xml:space="preserve">
          <source>An input range of random access ranges</source>
          <target state="translated">Диапазон входных произвольных диапазонов доступа</target>
        </trans-unit>
        <trans-unit id="e8adc363777a6afb1445324ba10df4840c08d231" translate="yes" xml:space="preserve">
          <source>An input range of the subranges of elements between separators. If &lt;code&gt;r&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;, the returned range will be likewise. When a range is used a separator, bidirectionality isn't possible.  If an empty range is given, the result is an empty range. If a range with one separator is given, the result is a range with two empty elements.</source>
          <target state="translated">Диапазон ввода поддиапазонов элементов между разделителями. Если &lt;code&gt;r&lt;/code&gt; - &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямой диапазон&lt;/a&gt; или &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;двунаправленный диапазон&lt;/a&gt; , возвращенный диапазон будет аналогичным образом. Когда в качестве диапазона используется разделитель, двунаправленность невозможна. Если задан пустой диапазон, результатом будет пустой диапазон. Если указан диапазон с одним разделителем, результатом будет диапазон с двумя пустыми элементами.</target>
        </trans-unit>
        <trans-unit id="77fcb0b8936d71a377fcbb398a2e222509a71db3" translate="yes" xml:space="preserve">
          <source>An input range representing the results of the map. This range has a length iff &lt;code&gt;source&lt;/code&gt; has a length.</source>
          <target state="translated">Диапазон ввода, представляющий результаты карты. Этот диапазон имеет длину, если &lt;code&gt;source&lt;/code&gt; имеет длину.</target>
        </trans-unit>
        <trans-unit id="e3ed7a93b1ad11aa4211044600bdb3f20f6462d6" translate="yes" xml:space="preserve">
          <source>An input range that offers the elements of &lt;code&gt;inputRange&lt;/code&gt;. Regardless of whether &lt;code&gt;inputRange&lt;/code&gt; is a more powerful range (forward, bidirectional etc), the result is always an input range. Reading this causes &lt;code&gt;inputRange&lt;/code&gt; to be iterated and returns its elements in turn. In addition, the same elements will be passed to &lt;code&gt;outputRange&lt;/code&gt; or &lt;code&gt;fun&lt;/code&gt; as well.</source>
          <target state="translated">Диапазон ввода, который предлагает элементы &lt;code&gt;inputRange&lt;/code&gt; . Независимо от того, является ли &lt;code&gt;inputRange&lt;/code&gt; более мощным диапазоном (вперед, двунаправленный и т. Д.), Результатом всегда является диапазон ввода. Чтение этого вызывает &lt;code&gt;inputRange&lt;/code&gt; и возвращает его элементы по очереди. Кроме того, те же самые элементы будут также переданы в &lt;code&gt;outputRange&lt;/code&gt; или &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db0e5d660666f379e5bd5033aea5532a4a6d755" translate="yes" xml:space="preserve">
          <source>An input range, or a single element, to join the ranges on</source>
          <target state="translated">Диапазон входа,или один элемент,для объединения диапазонов на</target>
        </trans-unit>
        <trans-unit id="53e41ba736cd23d712f10ab5d4286f8a49bbcc4b" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;BoyerMooreFinder&lt;/code&gt; that can be used with &lt;code&gt;find()&lt;/code&gt; to invoke the Boyer-Moore matching algorithm for finding of &lt;code&gt;needle&lt;/code&gt; in a given haystack.</source>
          <target state="translated">Экземпляр &lt;code&gt;BoyerMooreFinder&lt;/code&gt; , который можно использовать с &lt;code&gt;find()&lt;/code&gt; для вызова алгоритма соответствия Бойера-Мура для поиска &lt;code&gt;needle&lt;/code&gt; в данном стоге сена.</target>
        </trans-unit>
        <trans-unit id="082c7f6d5b0afa12e8dd042a23683a443fd1ed5f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;RefCounted&lt;/code&gt; is a reference to a structure, which is referred to as the</source>
          <target state="translated">Экземпляр &lt;code&gt;RefCounted&lt;/code&gt; представляет собой ссылку на структуру, которая называется</target>
        </trans-unit>
        <trans-unit id="81dfbeaffbeddcdca676ca9f6b1f01a2e767b7b5" translate="yes" xml:space="preserve">
          <source>An instance of Class called ClassXXXX.</source>
          <target state="translated">Экземпляр класса под названием ClassXXXX.</target>
        </trans-unit>
        <trans-unit id="df7f1cf5303035f4982248b96ae7f8dcd8dbd36d" translate="yes" xml:space="preserve">
          <source>An instance of ModuleInfo is generated into the object file for each compiled module.</source>
          <target state="translated">Для каждого скомпилированного модуля в объектном файле генерируется экземпляр ModuleInfo.</target>
        </trans-unit>
        <trans-unit id="0af1d2f763a9f835d30a298bd5512f1a1ecb310d" translate="yes" xml:space="preserve">
          <source>An instance of Rebindable!T.</source>
          <target state="translated">Пример &quot;Rebindable!T&quot;.</target>
        </trans-unit>
        <trans-unit id="f20d76f76289925279727351d584459074c5f577" translate="yes" xml:space="preserve">
          <source>An instance of StaticClassXXXX called StaticXXXX for the static members.</source>
          <target state="translated">Экземпляр StaticClassXXXX называется StaticXXXX для статических членов.</target>
        </trans-unit>
        <trans-unit id="7588661ba7457b5448344cfc895cdb3b665fc0e3" translate="yes" xml:space="preserve">
          <source>An instance of an interface cannot be created.</source>
          <target state="translated">Экземпляр интерфейса не может быть создан.</target>
        </trans-unit>
        <trans-unit id="0019410ce360e69e8b7f1b0e344a14bdf938e6e9" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed these values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fe6552b2cda57271319df5e41efc135feb5083" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed those values.</source>
          <target state="translated">Целый литерал не должен превышать этих значений.</target>
        </trans-unit>
        <trans-unit id="3dd1eb0e6607d6d3937d482192de7ee283f310ab" translate="yes" xml:space="preserve">
          <source>An interface is a pointer to a pointer to a vtbl[]. The vtbl[0] entry is a pointer to the corresponding instance of the object.Interface class. The rest of the &lt;code&gt;vtbl[1..$]&lt;/code&gt; entries are pointers to the virtual functions implemented by that interface, in the order that they were declared.</source>
          <target state="translated">Интерфейс - это указатель на указатель на vtbl []. Запись vtbl [0] является указателем на соответствующий экземпляр класса object.Interface. Остальные записи &lt;code&gt;vtbl[1..$]&lt;/code&gt; являются указателями на виртуальные функции, реализованные этим интерфейсом, в том порядке, в котором они были объявлены.</target>
        </trans-unit>
        <trans-unit id="f535852beda0178c415bc9fa63dbe96b52f5fffb" translate="yes" xml:space="preserve">
          <source>An interface to a pipe created by the &lt;a href=&quot;#pipe&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Интерфейс для канала, созданного функцией &lt;a href=&quot;#pipe&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab4113213830fe7d72486bf84fdb4481ba6c3903" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the</source>
          <target state="translated">Внутреннего указателя на выделенный блок памяти достаточно для того,чтобы ГХ знала,что объект используется,т.е.нет необходимости поддерживать указатель на</target>
        </trans-unit>
        <trans-unit id="e468e9d85b8c7d660b637f4814b9ebc7dd018028" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the beginning of the allocated memory.</source>
          <target state="translated">Внутреннего указателя на выделенный блок памяти достаточно для того,чтобы ГК знала,что объект используется,т.е.нет необходимости поддерживать указатель на начало выделенной памяти.</target>
        </trans-unit>
        <trans-unit id="f380906d548143bc93c92fea41836178dba951d1" translate="yes" xml:space="preserve">
          <source>An invalid IPv4 host address.</source>
          <target state="translated">Недействительный адрес хоста IPv4.</target>
        </trans-unit>
        <trans-unit id="5c151927ff98085446422d3ef9db66acbb3009ff" translate="yes" xml:space="preserve">
          <source>An invalid memory operation error occurs in circumstances when the garbage collector has detected an operation it cannot reliably handle. The default D GC is not re-entrant, so this can happen due to allocations done from within finalizers called during a garbage collection cycle.</source>
          <target state="translated">Ошибка при работе с памятью возникает в том случае,если мусорный коллектор обнаружил операцию,с которой он не может надежно справиться.По умолчанию ГХ по умолчанию не возвращается,поэтому это может произойти из-за распределений,выполняемых изнутри конечных устройств,вызываемых во время цикла уборки мусора.</target>
        </trans-unit>
        <trans-unit id="7e1ca0b5740cb0c049a4626d36738a30cd09bcf8" translate="yes" xml:space="preserve">
          <source>An new array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Новый массив с тем же типом элемента, что и &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9a13417415c3a89c1b29b77e22f2e53079843b6" translate="yes" xml:space="preserve">
          <source>An object consists of:</source>
          <target state="translated">Объект состоит из:</target>
        </trans-unit>
        <trans-unit id="4aafa70d4d827025493d92426cb1881df221dd19" translate="yes" xml:space="preserve">
          <source>An object describing the current calling context or null if no handler is supplied.</source>
          <target state="translated">Объект,описывающий текущий вызывающий контекст или нулевой,если обработчик не поставляется.</target>
        </trans-unit>
        <trans-unit id="3a620a30bdbf13210b0ac45ebfde607dd57f15dd" translate="yes" xml:space="preserve">
          <source>An object spans a sequence of memory locations which may or may not be contiguous. Its lifetime encompasses construction, destruction, and the period in between. Each object has a type which is determined either statically or by runtime type information. The object's memory locations may include any combination of thread-local, immutable, or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad48c285dfb60c4d3c86eb82873ee83b03c3fe1" translate="yes" xml:space="preserve">
          <source>An object's address is the address of the first byte of the first memory location for that object. Object addresses are distinct unless one object is nested within the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2f170166a5ab81d9f7b1c1bbe46754996b242" translate="yes" xml:space="preserve">
          <source>An object, interface, array slice type, or associative array type.</source>
          <target state="translated">Объект,интерфейс,тип среза массива или ассоциативный тип массива.</target>
        </trans-unit>
        <trans-unit id="46658cef8915a535dc984d5da9a05cb48f404327" translate="yes" xml:space="preserve">
          <source>An opaque type used to represent a logical thread.</source>
          <target state="translated">Непрозрачный тип,используемый для представления логического потока.</target>
        </trans-unit>
        <trans-unit id="ac93278e9eecd73148f8d1da8ce3975a03dbd346" translate="yes" xml:space="preserve">
          <source>An operating system handle to the process.</source>
          <target state="translated">Ручка операционной системы к процессу.</target>
        </trans-unit>
        <trans-unit id="6f1bf7d22dd547a7812632d87cd15c2924db734c" translate="yes" xml:space="preserve">
          <source>An option can be bound to a function or delegate with the signature &lt;code&gt;void function()&lt;/code&gt;, &lt;code&gt;void function(string option)&lt;/code&gt;, &lt;code&gt;void function(string option, string value)&lt;/code&gt;, or their delegate equivalents.</source>
          <target state="translated">Опция может быть связана с функцией или делегатом с помощью сигнатуры &lt;code&gt;void function()&lt;/code&gt; , &lt;code&gt;void function(string option)&lt;/code&gt; , &lt;code&gt;void function(string option, string value)&lt;/code&gt; или их эквивалентами-делегатами.</target>
        </trans-unit>
        <trans-unit id="2b5227e5d32ce42de170098574202aa25566b464" translate="yes" xml:space="preserve">
          <source>An option can be marked as required. If that option is not present in the arguments an exception will be thrown.</source>
          <target state="translated">Опция может быть отмечена по мере необходимости.Если эта опция не присутствует в аргументах,будет выброшено исключение.</target>
        </trans-unit>
        <trans-unit id="62587f93049001b563bb61577949d667674822d9" translate="yes" xml:space="preserve">
          <source>An option to create &lt;a href=&quot;#FileLogger&quot;&gt;&lt;code&gt;FileLogger&lt;/code&gt;&lt;/a&gt; directory if it is non-existent.</source>
          <target state="translated">Возможность создать каталог &lt;a href=&quot;#FileLogger&quot;&gt; &lt;code&gt;FileLogger&lt;/code&gt; ,&lt;/a&gt; если он не существует.</target>
        </trans-unit>
        <trans-unit id="64ee06f639f325adeda208d2447a973be665d9e1" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;header&lt;/code&gt; can be provided. The first record will be read in as the header. If &lt;code&gt;Contents&lt;/code&gt; is a struct then the header provided is expected to correspond to the fields in the struct. When &lt;code&gt;Contents&lt;/code&gt; is not a type which can contain the entire record, the &lt;code&gt;header&lt;/code&gt; must be provided in the same order as the input or an exception is thrown.</source>
          <target state="translated">Дополнительный &lt;code&gt;header&lt;/code&gt; может быть предоставлен. Первая запись будет прочитана как заголовок. Если &lt;code&gt;Contents&lt;/code&gt; является структурой, то ожидается, что предоставленный заголовок будет соответствовать полям в структуре. Когда &lt;code&gt;Contents&lt;/code&gt; не является типом, который может содержать всю запись, &lt;code&gt;header&lt;/code&gt; должен предоставляться в том же порядке, что и входные данные, или генерируется исключение.</target>
        </trans-unit>
        <trans-unit id="c541908f1a9f1491cf9b9d292e345a7480fb7a54" translate="yes" xml:space="preserve">
          <source>An optional destination buffer.</source>
          <target state="translated">Дополнительный буфер назначения.</target>
        </trans-unit>
        <trans-unit id="8208436747ee5979d41650c17a37d3a20bbfe83b" translate="yes" xml:space="preserve">
          <source>An optional list of strings naming each successive field of the &lt;code&gt;Tuple&lt;/code&gt; or a list of types that the elements are being casted to. For a list of names, each name matches up with the corresponding field given by &lt;code&gt;Args&lt;/code&gt;. A name does not have to be provided for every field, but as the names must proceed in order, it is not possible to skip one field and name the next after it. For a list of types, there must be exactly as many types as parameters.</source>
          <target state="translated">Необязательный список строк с именами каждого последующего поля &lt;code&gt;Tuple&lt;/code&gt; или список типов, к которым преобразуются элементы. Для списка имен каждое имя совпадает с соответствующим полем, заданным &lt;code&gt;Args&lt;/code&gt; . Имя не обязательно указывать для каждого поля, но, поскольку имена должны действовать по порядку, невозможно пропустить одно поле и назвать следующее после него. Для списка типов должно быть ровно столько типов, сколько параметров.</target>
        </trans-unit>
        <trans-unit id="301d753d609aee359b108ee54a2daf0751f4373a" translate="yes" xml:space="preserve">
          <source>An optional suffix to be removed from the file name.</source>
          <target state="translated">Необязательный суффикс,который должен быть удален из имени файла.</target>
        </trans-unit>
        <trans-unit id="77f5c788c6482dd19248d4d066b4335ce5e940c4" translate="yes" xml:space="preserve">
          <source>An out parameter &lt;code&gt;x&lt;/code&gt; is similar to a ref parameter, except it is initialized with &lt;code&gt;x.init&lt;/code&gt; upon function invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb578323324900d1fe9af43a6b6b06a406772b4" translate="yes" xml:space="preserve">
          <source>An output range for returning the results may be provided as the last argument. If one is not provided, an array of the proper type will be allocated on the garbage collected heap. If one is provided, it must be a random access range with assignable elements, must have reference semantics with respect to assignment to its elements, and must have the same length as the input range. Writing to adjacent elements from different threads must be safe.</source>
          <target state="translated">В качестве последнего аргумента может быть указан выходной диапазон для возврата результатов.Если его не предоставить,то на куче собранного мусора будет выделен массив соответствующего типа.Если он предоставлен,то это должен быть диапазон произвольного доступа с присваиваемыми элементами,должен иметь опорную семантику относительно присваивания его элементов и должен иметь ту же длину,что и входной диапазон.Запись на соседние элементы из разных потоков должна быть безопасной.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
