<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="e8adc363777a6afb1445324ba10df4840c08d231" translate="yes" xml:space="preserve">
          <source>An input range of the subranges of elements between separators. If &lt;code&gt;r&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;, the returned range will be likewise. When a range is used a separator, bidirectionality isn't possible.  If an empty range is given, the result is an empty range. If a range with one separator is given, the result is a range with two empty elements.</source>
          <target state="translated">Диапазон ввода поддиапазонов элементов между разделителями. Если &lt;code&gt;r&lt;/code&gt; - &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямой диапазон&lt;/a&gt; или &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;двунаправленный диапазон&lt;/a&gt; , возвращенный диапазон будет аналогичным образом. Когда в качестве диапазона используется разделитель, двунаправленность невозможна. Если задан пустой диапазон, результатом будет пустой диапазон. Если указан диапазон с одним разделителем, результатом будет диапазон с двумя пустыми элементами.</target>
        </trans-unit>
        <trans-unit id="77fcb0b8936d71a377fcbb398a2e222509a71db3" translate="yes" xml:space="preserve">
          <source>An input range representing the results of the map. This range has a length iff &lt;code&gt;source&lt;/code&gt; has a length.</source>
          <target state="translated">Диапазон ввода, представляющий результаты карты. Этот диапазон имеет длину, если &lt;code&gt;source&lt;/code&gt; имеет длину.</target>
        </trans-unit>
        <trans-unit id="e3ed7a93b1ad11aa4211044600bdb3f20f6462d6" translate="yes" xml:space="preserve">
          <source>An input range that offers the elements of &lt;code&gt;inputRange&lt;/code&gt;. Regardless of whether &lt;code&gt;inputRange&lt;/code&gt; is a more powerful range (forward, bidirectional etc), the result is always an input range. Reading this causes &lt;code&gt;inputRange&lt;/code&gt; to be iterated and returns its elements in turn. In addition, the same elements will be passed to &lt;code&gt;outputRange&lt;/code&gt; or &lt;code&gt;fun&lt;/code&gt; as well.</source>
          <target state="translated">Диапазон ввода, который предлагает элементы &lt;code&gt;inputRange&lt;/code&gt; . Независимо от того, является ли &lt;code&gt;inputRange&lt;/code&gt; более мощным диапазоном (вперед, двунаправленный и т. Д.), Результатом всегда является диапазон ввода. Чтение этого вызывает &lt;code&gt;inputRange&lt;/code&gt; и возвращает его элементы по очереди. Кроме того, те же самые элементы будут также переданы в &lt;code&gt;outputRange&lt;/code&gt; или &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db0e5d660666f379e5bd5033aea5532a4a6d755" translate="yes" xml:space="preserve">
          <source>An input range, or a single element, to join the ranges on</source>
          <target state="translated">Диапазон входа,или один элемент,для объединения диапазонов на</target>
        </trans-unit>
        <trans-unit id="53e41ba736cd23d712f10ab5d4286f8a49bbcc4b" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;BoyerMooreFinder&lt;/code&gt; that can be used with &lt;code&gt;find()&lt;/code&gt; to invoke the Boyer-Moore matching algorithm for finding of &lt;code&gt;needle&lt;/code&gt; in a given haystack.</source>
          <target state="translated">Экземпляр &lt;code&gt;BoyerMooreFinder&lt;/code&gt; , который можно использовать с &lt;code&gt;find()&lt;/code&gt; для вызова алгоритма соответствия Бойера-Мура для поиска &lt;code&gt;needle&lt;/code&gt; в данном стоге сена.</target>
        </trans-unit>
        <trans-unit id="082c7f6d5b0afa12e8dd042a23683a443fd1ed5f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;RefCounted&lt;/code&gt; is a reference to a structure, which is referred to as the</source>
          <target state="translated">Экземпляр &lt;code&gt;RefCounted&lt;/code&gt; представляет собой ссылку на структуру, которая называется</target>
        </trans-unit>
        <trans-unit id="81dfbeaffbeddcdca676ca9f6b1f01a2e767b7b5" translate="yes" xml:space="preserve">
          <source>An instance of Class called ClassXXXX.</source>
          <target state="translated">Экземпляр класса под названием ClassXXXX.</target>
        </trans-unit>
        <trans-unit id="df7f1cf5303035f4982248b96ae7f8dcd8dbd36d" translate="yes" xml:space="preserve">
          <source>An instance of ModuleInfo is generated into the object file for each compiled module.</source>
          <target state="translated">Для каждого скомпилированного модуля в объектном файле генерируется экземпляр ModuleInfo.</target>
        </trans-unit>
        <trans-unit id="0af1d2f763a9f835d30a298bd5512f1a1ecb310d" translate="yes" xml:space="preserve">
          <source>An instance of Rebindable!T.</source>
          <target state="translated">Пример &quot;Rebindable!T&quot;.</target>
        </trans-unit>
        <trans-unit id="f20d76f76289925279727351d584459074c5f577" translate="yes" xml:space="preserve">
          <source>An instance of StaticClassXXXX called StaticXXXX for the static members.</source>
          <target state="translated">Экземпляр StaticClassXXXX называется StaticXXXX для статических членов.</target>
        </trans-unit>
        <trans-unit id="7588661ba7457b5448344cfc895cdb3b665fc0e3" translate="yes" xml:space="preserve">
          <source>An instance of an interface cannot be created.</source>
          <target state="translated">Экземпляр интерфейса не может быть создан.</target>
        </trans-unit>
        <trans-unit id="0019410ce360e69e8b7f1b0e344a14bdf938e6e9" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed these values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fe6552b2cda57271319df5e41efc135feb5083" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed those values.</source>
          <target state="translated">Целый литерал не должен превышать этих значений.</target>
        </trans-unit>
        <trans-unit id="3dd1eb0e6607d6d3937d482192de7ee283f310ab" translate="yes" xml:space="preserve">
          <source>An interface is a pointer to a pointer to a vtbl[]. The vtbl[0] entry is a pointer to the corresponding instance of the object.Interface class. The rest of the &lt;code&gt;vtbl[1..$]&lt;/code&gt; entries are pointers to the virtual functions implemented by that interface, in the order that they were declared.</source>
          <target state="translated">Интерфейс - это указатель на указатель на vtbl []. Запись vtbl [0] является указателем на соответствующий экземпляр класса object.Interface. Остальные записи &lt;code&gt;vtbl[1..$]&lt;/code&gt; являются указателями на виртуальные функции, реализованные этим интерфейсом, в том порядке, в котором они были объявлены.</target>
        </trans-unit>
        <trans-unit id="f535852beda0178c415bc9fa63dbe96b52f5fffb" translate="yes" xml:space="preserve">
          <source>An interface to a pipe created by the &lt;a href=&quot;#pipe&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Интерфейс для канала, созданного функцией &lt;a href=&quot;#pipe&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab4113213830fe7d72486bf84fdb4481ba6c3903" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the</source>
          <target state="translated">Внутреннего указателя на выделенный блок памяти достаточно для того,чтобы ГХ знала,что объект используется,т.е.нет необходимости поддерживать указатель на</target>
        </trans-unit>
        <trans-unit id="e468e9d85b8c7d660b637f4814b9ebc7dd018028" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the beginning of the allocated memory.</source>
          <target state="translated">Внутреннего указателя на выделенный блок памяти достаточно для того,чтобы ГК знала,что объект используется,т.е.нет необходимости поддерживать указатель на начало выделенной памяти.</target>
        </trans-unit>
        <trans-unit id="f380906d548143bc93c92fea41836178dba951d1" translate="yes" xml:space="preserve">
          <source>An invalid IPv4 host address.</source>
          <target state="translated">Недействительный адрес хоста IPv4.</target>
        </trans-unit>
        <trans-unit id="5c151927ff98085446422d3ef9db66acbb3009ff" translate="yes" xml:space="preserve">
          <source>An invalid memory operation error occurs in circumstances when the garbage collector has detected an operation it cannot reliably handle. The default D GC is not re-entrant, so this can happen due to allocations done from within finalizers called during a garbage collection cycle.</source>
          <target state="translated">Ошибка при работе с памятью возникает в том случае,если мусорный коллектор обнаружил операцию,с которой он не может надежно справиться.По умолчанию ГХ по умолчанию не возвращается,поэтому это может произойти из-за распределений,выполняемых изнутри конечных устройств,вызываемых во время цикла уборки мусора.</target>
        </trans-unit>
        <trans-unit id="7e1ca0b5740cb0c049a4626d36738a30cd09bcf8" translate="yes" xml:space="preserve">
          <source>An new array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Новый массив с тем же типом элемента, что и &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9a13417415c3a89c1b29b77e22f2e53079843b6" translate="yes" xml:space="preserve">
          <source>An object consists of:</source>
          <target state="translated">Объект состоит из:</target>
        </trans-unit>
        <trans-unit id="4aafa70d4d827025493d92426cb1881df221dd19" translate="yes" xml:space="preserve">
          <source>An object describing the current calling context or null if no handler is supplied.</source>
          <target state="translated">Объект,описывающий текущий вызывающий контекст или нулевой,если обработчик не поставляется.</target>
        </trans-unit>
        <trans-unit id="3a620a30bdbf13210b0ac45ebfde607dd57f15dd" translate="yes" xml:space="preserve">
          <source>An object spans a sequence of memory locations which may or may not be contiguous. Its lifetime encompasses construction, destruction, and the period in between. Each object has a type which is determined either statically or by runtime type information. The object's memory locations may include any combination of thread-local, immutable, or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad48c285dfb60c4d3c86eb82873ee83b03c3fe1" translate="yes" xml:space="preserve">
          <source>An object's address is the address of the first byte of the first memory location for that object. Object addresses are distinct unless one object is nested within the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2f170166a5ab81d9f7b1c1bbe46754996b242" translate="yes" xml:space="preserve">
          <source>An object, interface, array slice type, or associative array type.</source>
          <target state="translated">Объект,интерфейс,тип среза массива или ассоциативный тип массива.</target>
        </trans-unit>
        <trans-unit id="46658cef8915a535dc984d5da9a05cb48f404327" translate="yes" xml:space="preserve">
          <source>An opaque type used to represent a logical thread.</source>
          <target state="translated">Непрозрачный тип,используемый для представления логического потока.</target>
        </trans-unit>
        <trans-unit id="ac93278e9eecd73148f8d1da8ce3975a03dbd346" translate="yes" xml:space="preserve">
          <source>An operating system handle to the process.</source>
          <target state="translated">Ручка операционной системы к процессу.</target>
        </trans-unit>
        <trans-unit id="6f1bf7d22dd547a7812632d87cd15c2924db734c" translate="yes" xml:space="preserve">
          <source>An option can be bound to a function or delegate with the signature &lt;code&gt;void function()&lt;/code&gt;, &lt;code&gt;void function(string option)&lt;/code&gt;, &lt;code&gt;void function(string option, string value)&lt;/code&gt;, or their delegate equivalents.</source>
          <target state="translated">Опция может быть связана с функцией или делегатом с помощью сигнатуры &lt;code&gt;void function()&lt;/code&gt; , &lt;code&gt;void function(string option)&lt;/code&gt; , &lt;code&gt;void function(string option, string value)&lt;/code&gt; или их эквивалентами-делегатами.</target>
        </trans-unit>
        <trans-unit id="2b5227e5d32ce42de170098574202aa25566b464" translate="yes" xml:space="preserve">
          <source>An option can be marked as required. If that option is not present in the arguments an exception will be thrown.</source>
          <target state="translated">Опция может быть отмечена по мере необходимости.Если эта опция не присутствует в аргументах,будет выброшено исключение.</target>
        </trans-unit>
        <trans-unit id="62587f93049001b563bb61577949d667674822d9" translate="yes" xml:space="preserve">
          <source>An option to create &lt;a href=&quot;#FileLogger&quot;&gt;&lt;code&gt;FileLogger&lt;/code&gt;&lt;/a&gt; directory if it is non-existent.</source>
          <target state="translated">Возможность создать каталог &lt;a href=&quot;#FileLogger&quot;&gt; &lt;code&gt;FileLogger&lt;/code&gt; ,&lt;/a&gt; если он не существует.</target>
        </trans-unit>
        <trans-unit id="64ee06f639f325adeda208d2447a973be665d9e1" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;header&lt;/code&gt; can be provided. The first record will be read in as the header. If &lt;code&gt;Contents&lt;/code&gt; is a struct then the header provided is expected to correspond to the fields in the struct. When &lt;code&gt;Contents&lt;/code&gt; is not a type which can contain the entire record, the &lt;code&gt;header&lt;/code&gt; must be provided in the same order as the input or an exception is thrown.</source>
          <target state="translated">Дополнительный &lt;code&gt;header&lt;/code&gt; может быть предоставлен. Первая запись будет прочитана как заголовок. Если &lt;code&gt;Contents&lt;/code&gt; является структурой, то ожидается, что предоставленный заголовок будет соответствовать полям в структуре. Когда &lt;code&gt;Contents&lt;/code&gt; не является типом, который может содержать всю запись, &lt;code&gt;header&lt;/code&gt; должен предоставляться в том же порядке, что и входные данные, или генерируется исключение.</target>
        </trans-unit>
        <trans-unit id="c541908f1a9f1491cf9b9d292e345a7480fb7a54" translate="yes" xml:space="preserve">
          <source>An optional destination buffer.</source>
          <target state="translated">Дополнительный буфер назначения.</target>
        </trans-unit>
        <trans-unit id="8208436747ee5979d41650c17a37d3a20bbfe83b" translate="yes" xml:space="preserve">
          <source>An optional list of strings naming each successive field of the &lt;code&gt;Tuple&lt;/code&gt; or a list of types that the elements are being casted to. For a list of names, each name matches up with the corresponding field given by &lt;code&gt;Args&lt;/code&gt;. A name does not have to be provided for every field, but as the names must proceed in order, it is not possible to skip one field and name the next after it. For a list of types, there must be exactly as many types as parameters.</source>
          <target state="translated">Необязательный список строк с именами каждого последующего поля &lt;code&gt;Tuple&lt;/code&gt; или список типов, к которым преобразуются элементы. Для списка имен каждое имя совпадает с соответствующим полем, заданным &lt;code&gt;Args&lt;/code&gt; . Имя не обязательно указывать для каждого поля, но, поскольку имена должны действовать по порядку, невозможно пропустить одно поле и назвать следующее после него. Для списка типов должно быть ровно столько типов, сколько параметров.</target>
        </trans-unit>
        <trans-unit id="301d753d609aee359b108ee54a2daf0751f4373a" translate="yes" xml:space="preserve">
          <source>An optional suffix to be removed from the file name.</source>
          <target state="translated">Необязательный суффикс,который должен быть удален из имени файла.</target>
        </trans-unit>
        <trans-unit id="77f5c788c6482dd19248d4d066b4335ce5e940c4" translate="yes" xml:space="preserve">
          <source>An out parameter &lt;code&gt;x&lt;/code&gt; is similar to a ref parameter, except it is initialized with &lt;code&gt;x.init&lt;/code&gt; upon function invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb578323324900d1fe9af43a6b6b06a406772b4" translate="yes" xml:space="preserve">
          <source>An output range for returning the results may be provided as the last argument. If one is not provided, an array of the proper type will be allocated on the garbage collected heap. If one is provided, it must be a random access range with assignable elements, must have reference semantics with respect to assignment to its elements, and must have the same length as the input range. Writing to adjacent elements from different threads must be safe.</source>
          <target state="translated">В качестве последнего аргумента может быть указан выходной диапазон для возврата результатов.Если его не предоставить,то на куче собранного мусора будет выделен массив соответствующего типа.Если он предоставлен,то это должен быть диапазон произвольного доступа с присваиваемыми элементами,должен иметь опорную семантику относительно присваивания его элементов и должен иметь ту же длину,что и входной диапазон.Запись на соседние элементы из разных потоков должна быть безопасной.</target>
        </trans-unit>
        <trans-unit id="481df4f9db6b7c39f75ab8b5d8402946a05557b9" translate="yes" xml:space="preserve">
          <source>An output range that discards the data it receives.</source>
          <target state="translated">Диапазон выхода,который отбрасывает получаемые данные.</target>
        </trans-unit>
        <trans-unit id="01b526186c983c89501e19ff25742faa0abd686c" translate="yes" xml:space="preserve">
          <source>An output range to write the contents to.</source>
          <target state="translated">Диапазон выхода для записи содержимого в.</target>
        </trans-unit>
        <trans-unit id="6ec96a76a1b7b768707aea157270f72d702aae35" translate="yes" xml:space="preserve">
          <source>An uninitialized &lt;code&gt;Variant&lt;/code&gt; is used in any way except assignment and &lt;code&gt;hasValue&lt;/code&gt;;</source>
          <target state="translated">Неинициализированный &lt;code&gt;Variant&lt;/code&gt; используется любым способом, кроме assignment и &lt;code&gt;hasValue&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="017d1765237968f656e289b4e56677bea3baad1b" translate="yes" xml:space="preserve">
          <source>An uninitialized value, generated from void initializers.</source>
          <target state="translated">Неинициализированное значение,генерируемое из пустых инициализаторов.</target>
        </trans-unit>
        <trans-unit id="6d865e1b843ed22f5ad95224465f066dd3bf97cd" translate="yes" xml:space="preserve">
          <source>An unqualified postblit will get called even if the struct is instantiated as &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;, but the compiler issues an error if the struct is instantiated as &lt;code&gt;shared&lt;/code&gt;:</source>
          <target state="translated">Неквалифицированный postblit будет вызван, даже если структура создается как &lt;code&gt;immutable&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; , но компилятор выдает ошибку, если структура создается как &lt;code&gt;shared&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02377b58a34c4a8ec19952d46cd99f893c878ed8" translate="yes" xml:space="preserve">
          <source>An unrecognized command-line argument is passed, and &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; was not present.</source>
          <target state="translated">&lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; нераспознанный аргумент командной строки, а std.getopt.config.passThrough отсутствует.</target>
        </trans-unit>
        <trans-unit id="355743baaf25b39e6a1bf6c9a0897a53f7ca51a0" translate="yes" xml:space="preserve">
          <source>An unrecognized option such as &quot;--baz&quot; will be found untouched in &lt;code&gt;args&lt;/code&gt; after &lt;code&gt;getopt&lt;/code&gt; returns.</source>
          <target state="translated">Нераспознанная опция, такая как &amp;laquo;--baz&amp;raquo;, будет найдена нетронутой в &lt;code&gt;args&lt;/code&gt; после возврата &lt;code&gt;getopt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b75455d22427a9d7061b91a6aa632f59812aa7cb" translate="yes" xml:space="preserve">
          <source>Analogously to class templates, struct, union and interfaces can be transformed into templates by supplying a template parameter list.</source>
          <target state="translated">По аналогии с шаблонами классов,структура,объединение и интерфейсы могут быть преобразованы в шаблоны путем предоставления списка параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="381d6919b76a155cc3d0bed8744ee2e82e29874b" translate="yes" xml:space="preserve">
          <source>Analogously, &lt;code&gt;typeof(super)&lt;/code&gt; will generate the type of what &lt;code&gt;super&lt;/code&gt; would be in a non-static member function.</source>
          <target state="translated">Аналогично, &lt;code&gt;typeof(super)&lt;/code&gt; будет генерировать тип того, что &lt;code&gt;super&lt;/code&gt; будет в нестатической функции-члене.</target>
        </trans-unit>
        <trans-unit id="e760dd880de0f515f576dc77edef82d0231e14ae" translate="yes" xml:space="preserve">
          <source>Ancient Greek Musical Notation</source>
          <target state="translated">Древнегреческая музыкальная нотация</target>
        </trans-unit>
        <trans-unit id="aac24095b26055100b3e137537a2c7e0ad932e04" translate="yes" xml:space="preserve">
          <source>Ancient Greek Numbers</source>
          <target state="translated">Древнегреческие числа</target>
        </trans-unit>
        <trans-unit id="3550f110a8c69b086b7eac12c46c400773c345dc" translate="yes" xml:space="preserve">
          <source>Ancient Symbols</source>
          <target state="translated">Древние символы</target>
        </trans-unit>
        <trans-unit id="29bd442643bea5b50cf62a67104dd1d1aa8f0d1e" translate="yes" xml:space="preserve">
          <source>And Expressions</source>
          <target state="translated">И выражения</target>
        </trans-unit>
        <trans-unit id="955032d49b799cc6cb579cffbe0f243b5d0f3d5f" translate="yes" xml:space="preserve">
          <source>And all the summary sections will now be green.</source>
          <target state="translated">И все разделы резюме теперь будут зеленого цвета.</target>
        </trans-unit>
        <trans-unit id="e67c2d4e000dc2740dc758b29287dd9038d89a6b" translate="yes" xml:space="preserve">
          <source>And an example of D code providing a callback to C code:</source>
          <target state="translated">И пример кода D с обратным вызовом на C:</target>
        </trans-unit>
        <trans-unit id="028627a78221787a21142d8d33379cef0d471467" translate="yes" xml:space="preserve">
          <source>AndAnd Expressions</source>
          <target state="translated">AndAndExpressions</target>
        </trans-unit>
        <trans-unit id="d132739724126beb0a58639e9a6156fdf0949d66" translate="yes" xml:space="preserve">
          <source>AndAndExpression</source>
          <target state="translated">AndAndExpression</target>
        </trans-unit>
        <trans-unit id="b25772e958c7000fd371337d6359418dab3becfa" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu</source>
          <target state="translated">Андрей Александреску</target>
        </trans-unit>
        <trans-unit id="8086e1eeb4770ea0dab8abf60035423c0a58a5b4" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu's article &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt; &lt;i&gt;On Iteration&lt;/i&gt;&lt;/a&gt; for conceptual aspect of ranges and the motivation</source>
          <target state="translated">Статья Андрея Александреску &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt;&lt;i&gt;Об итерации&lt;/i&gt;&lt;/a&gt; для концептуального аспекта диапазонов и мотивации &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="b803b58141bc58845f04cfa8646ac85f1f1a979d" translate="yes" xml:space="preserve">
          <source>Anonymous Enums</source>
          <target state="translated">Анонимные перепонки</target>
        </trans-unit>
        <trans-unit id="7ccd2afbc983959f9583ca7f31cb4e5cf46494d9" translate="yes" xml:space="preserve">
          <source>Anonymous Functions and Anonymous Delegates</source>
          <target state="translated">Анонимные функции и анонимные делегаты</target>
        </trans-unit>
        <trans-unit id="98a2443b6da1909f7a102e64a4964e0f390eb397" translate="yes" xml:space="preserve">
          <source>Anonymous Nested Classes</source>
          <target state="translated">Анонимные гнездовые классы</target>
        </trans-unit>
        <trans-unit id="46249cc944aedcf50eaf15b7e810784027798c68" translate="yes" xml:space="preserve">
          <source>Anonymous delegates can behave like arbitrary statement literals. For example, here an arbitrary statement is executed by a loop:</source>
          <target state="translated">Анонимные делегаты могут вести себя как буквальные произвольные заявления.Например,здесь произвольное утверждение выполняется по циклу:</target>
        </trans-unit>
        <trans-unit id="e1acf88a52df3795f2b20ed6511eee7ceb7ec305" translate="yes" xml:space="preserve">
          <source>Another caveat of using sub-matcher is that skip is not available preciesly because sub-matcher doesn't detect all lengths.</source>
          <target state="translated">Другая оговорка об использовании субматчера заключается в том,что пропуски недоступны прецизионно,потому что субматчера не обнаруживают все длины.</target>
        </trans-unit>
        <trans-unit id="9a60f4e1a9ef014cfadbb26ea290e8c3eb775ed4" translate="yes" xml:space="preserve">
          <source>Another event handling module</source>
          <target state="translated">Другой модуль обработки событий</target>
        </trans-unit>
        <trans-unit id="bae2455d3699406c3641a5d660465c6bf6758fc6" translate="yes" xml:space="preserve">
          <source>Another example of formatting a &lt;code&gt;struct&lt;/code&gt; with a defined &lt;code&gt;toString&lt;/code&gt;, this time using the &lt;code&gt;scope delegate&lt;/code&gt; method.  This method is now discouraged for non-virtual functions. If possible, please use the output range method instead.</source>
          <target state="translated">Другой пример форматирования &lt;code&gt;struct&lt;/code&gt; с определенной &lt;code&gt;toString&lt;/code&gt; , на этот раз с использованием метода &lt;code&gt;scope delegate&lt;/code&gt; . Этот метод теперь не рекомендуется для не виртуальных функций. Если возможно, используйте вместо этого метод выходного диапазона.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="85e6f644dc8e5726c5821532bf00eff211afd4d4" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; or non-basic &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; (i.e. any type that does not encode as a fixed one or two character sequence) that has been emitted to the mangled symbol before will not be emitted again, but is referenced by a special sequence encoding the relative position of the original occurrence in the mangled symbol name.</source>
          <target state="translated">Любой &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; или неосновный &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;тип&lt;/i&gt;&lt;/a&gt; (т. &lt;i&gt;Е.&lt;/i&gt; Любой тип, который не кодируется как фиксированная одно- или двухсимвольная последовательность), который был передан искаженному символу ранее, не будет снова выдан, но на него ссылается специальная последовательность, кодирующая относительную позицию оригинального вхождения в искаженном имени символа.</target>
        </trans-unit>
        <trans-unit id="a4ebed2ed3fe69fdf17bf0f9ea8120a1a0f126ed" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;pure&lt;/code&gt; function that is not strongly pure cannot be assumed to be memoizable, and calls to it may not be elided even if it returns &lt;code&gt;void&lt;/code&gt; (save for compiler optimizations that prove the function has no effect). Function calls may still be elided, or results be memoized, by means of traditional inlining and optimization techniques available for all functions.</source>
          <target state="translated">Любая &lt;code&gt;pure&lt;/code&gt; функция, которая не является строго чистой, не может считаться запоминающейся, и вызовы к ней могут быть не исключены, даже если она возвращает &lt;code&gt;void&lt;/code&gt; (за исключением оптимизации компилятора, которая доказывает, что функция не имеет никакого эффекта). Вызовы функций все еще могут быть исключены или результаты запомнены с помощью традиционных методов вставки и оптимизации, доступных для всех функций.</target>
        </trans-unit>
        <trans-unit id="eb9050538a91f8603d45e66e05f6aeeb1d29c1a1" translate="yes" xml:space="preserve">
          <source>Any CSV input</source>
          <target state="translated">Любой CSV-вход</target>
        </trans-unit>
        <trans-unit id="3dd20dd36e01004b82e2eb3d1b7678c47e9521c9" translate="yes" xml:space="preserve">
          <source>Any IPv4 host address.</source>
          <target state="translated">Любой адрес хоста IPv4.</target>
        </trans-unit>
        <trans-unit id="8aed77784e6588d748089e680321e31de462e28c" translate="yes" xml:space="preserve">
          <source>Any IPv4 port number.</source>
          <target state="translated">Любой номер порта IPv4.</target>
        </trans-unit>
        <trans-unit id="bb484c1e8a46997e29e20927039aa9b377327c02" translate="yes" xml:space="preserve">
          <source>Any IPv6 host address.</source>
          <target state="translated">Любой адрес хоста IPv6.</target>
        </trans-unit>
        <trans-unit id="94c6cca2615cd31987c71c42944c48bb96956b95" translate="yes" xml:space="preserve">
          <source>Any IPv6 port number.</source>
          <target state="translated">Любой номер порта IPv6.</target>
        </trans-unit>
        <trans-unit id="1e80ff69d9bdfebf77e41c7bd69caee37e4adb6e" translate="yes" xml:space="preserve">
          <source>Any Object types will be serialized in a key-sorted order.</source>
          <target state="translated">Любые типы объектов будут сериализованы в порядке сортировки по ключам.</target>
        </trans-unit>
        <trans-unit id="6f7c1cd84505fa215ea84971d24628315cd3387b" translate="yes" xml:space="preserve">
          <source>Any Statement that fails semantic() or has a component that is an ErrorExp or a TypeError should return an ErrorStatement from semantic().</source>
          <target state="translated">Любое утверждение,которое не работает semantic()или имеет компонент,который является ErrorExp или TypeError,должно возвращать ErrorStatement из semantic().</target>
        </trans-unit>
        <trans-unit id="baa16ecc9203783f7d302f47d6c7e99ca53b7882" translate="yes" xml:space="preserve">
          <source>Any ambiguities in the grammar between</source>
          <target state="translated">Любые неясности в грамматике между</target>
        </trans-unit>
        <trans-unit id="77ecebcd0dc38ae59d287e9d6832a173b570a0a2" translate="yes" xml:space="preserve">
          <source>Any atom</source>
          <target state="translated">Любой атом</target>
        </trans-unit>
        <trans-unit id="638621cad02fb4ef96d35005061aa41c6d8d2099" translate="yes" xml:space="preserve">
          <source>Any casting of a class reference to a derived class reference is done with a runtime check to make sure it really is a downcast. &lt;code&gt;null&lt;/code&gt; is the result if it isn't.</source>
          <target state="translated">Любое приведение ссылки на класс к производной ссылке на класс выполняется с проверкой во время выполнения, чтобы удостовериться, что это действительно уныло. &lt;code&gt;null&lt;/code&gt; результат, если это не так.</target>
        </trans-unit>
        <trans-unit id="7916c4b8de53330f21dcd29a0e59721012e5dd75" translate="yes" xml:space="preserve">
          <source>Any class invariants for base classes are applied before the class invariant for the derived class.</source>
          <target state="translated">Любые классовые инварианты для базовых классов применяются перед классом-инвариантом для производного класса.</target>
        </trans-unit>
        <trans-unit id="f7e950396436ad2a46ce9aad7dec469f189171b3" translate="yes" xml:space="preserve">
          <source>Any data referenced by the const declaration cannot be changed from the const declaration, but it might be changed by other references to the same data.</source>
          <target state="translated">Любые данные,на которые делается ссылка в заявлении const,не могут быть изменены из заявления const,но могут быть изменены другими ссылками на те же данные.</target>
        </trans-unit>
        <trans-unit id="ea9ba6b957e1ee541543e4ed84469edf4ec75cad" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined thread.</source>
          <target state="translated">Любое исключение,не обработанное соединительной резьбой.</target>
        </trans-unit>
        <trans-unit id="df41046890795b4eaa63b398c58e4d9d99374a20" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined threads.</source>
          <target state="translated">Любое исключение,не обработанное соединительными нитями.</target>
        </trans-unit>
        <trans-unit id="010d3e9dcdbd22cd7fd006df77170e4cb60a5618" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this fiber if rethrow = false, null otherwise.</source>
          <target state="translated">Любое исключение,не обработанное этим волокном,если перебрасывание=false,ноль в противном случае.</target>
        </trans-unit>
        <trans-unit id="b6ba130c34ce4b05804f636f1f2f916c5937c009" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this thread if rethrow = false, null otherwise.</source>
          <target state="translated">Любое исключение,не обработанное этим потоком,если rethrow=false,null иначе.</target>
        </trans-unit>
        <trans-unit id="3547b50f09fd44e299559c0d0f1b8fb00ea84d79" translate="yes" xml:space="preserve">
          <source>Any expression that resolves to either a tuple of strings or an empty tuple is accepted. When the expression resolves to an empty tuple, it is equivalent to &lt;code&gt;extern (C++)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f674a6378976f81a229e3e40bb92d9695e3314fe" translate="yes" xml:space="preserve">
          <source>Any functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. This means that the semantics of a function cannot depend on compile time values of the function. For example:</source>
          <target state="translated">Любые функции,которые выполняются в CTFE,также должны быть исполняемыми во время выполнения.Оценка времени компиляции функции эквивалентна выполнению функции во время выполнения.Это означает,что семантика функции не может зависеть от значений времени компиляции функции.Например:</target>
        </trans-unit>
        <trans-unit id="a57e0db645362adce30e4484501c92ffe3bbf8b7" translate="yes" xml:space="preserve">
          <source>Any insertion, removal, or lookups in an associative array</source>
          <target state="translated">Любая вставка,удаление или поиск в ассоциативном массиве</target>
        </trans-unit>
        <trans-unit id="0e84b6b0c57f34d7c618d447a7ab2c9f8792eac9" translate="yes" xml:space="preserve">
          <source>Any interface that derives from a C++ interface is also a C++ interface. A C++ interface differs from a D interface in that:</source>
          <target state="translated">Любой интерфейс,полученный из интерфейса C++,также является интерфейсом C++.Интерфейс C++отличается от интерфейса D:</target>
        </trans-unit>
        <trans-unit id="440031e52a8a0c7f5013522c41d2f3dc66691e39" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, along with releasing any intervening synchronization mutexes.</source>
          <target state="translated">Любые промежуточные заключительные положения выполняются вместе с освобождением любых промежуточных мьютексов синхронизации.</target>
        </trans-unit>
        <trans-unit id="752a908277ccaeb8ca9908aea34bc98614160ea6" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</source>
          <target state="translated">Любые промежуточные заключительные положения выполняются,а все промежуточные объекты синхронизации освобождаются.</target>
        </trans-unit>
        <trans-unit id="3c58819fbd73a8c9fe0c340f0db018003ce09975" translate="yes" xml:space="preserve">
          <source>Any invariants for fields are applied before the struct invariant.</source>
          <target state="translated">Любые инварианты для полей применяются перед инвариантом структуры.</target>
        </trans-unit>
        <trans-unit id="f9fe95fc6eae39aaf25f84d103f3acf7d7a384fd" translate="yes" xml:space="preserve">
          <source>Any license information for copyrighted code.</source>
          <target state="translated">Любая лицензионная информация для защищенного авторским правом кода.</target>
        </trans-unit>
        <trans-unit id="67b9adde439b5f8364926599d4a45d83875f65d8" translate="yes" xml:space="preserve">
          <source>Any numerical type that supports the modulo operator &lt;code&gt;%&lt;/code&gt;. If bit-shifting &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; are also supported, Stein's algorithm will be used; otherwise, Euclid's algorithm is used as a fallback.</source>
          <target state="translated">Любой числовой тип, который поддерживает оператор по модулю &lt;code&gt;%&lt;/code&gt; . Если смещение бит &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; также поддерживаются, будет использован алгоритм Стейна; в противном случае алгоритм Евклида используется как запасной вариант.</target>
        </trans-unit>
        <trans-unit id="81c3013df61cbea6a4c917b70878d87da30767d9" translate="yes" xml:space="preserve">
          <source>Any pointer may be cast to &lt;code&gt;void*&lt;/code&gt; and from &lt;code&gt;void*&lt;/code&gt; back to its original type. Casting between pointer and non-pointer types is prohibited.</source>
          <target state="translated">Любой указатель может быть приведен к &lt;code&gt;void*&lt;/code&gt; и из &lt;code&gt;void*&lt;/code&gt; обратно в исходный тип. Приведение между указателем и не указателем типов запрещено.</target>
        </trans-unit>
        <trans-unit id="c5cc05a90008a92dc38ec7d27e928baccc65c4ac" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;NegInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;NegInfInterval&lt;/code&gt; is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</source>
          <target state="translated">Любые диапазоны, которые перебирают &lt;code&gt;NegInfInterval&lt;/code&gt; , бесконечны. Итак, основная цель использования &lt;code&gt;NegInfInterval&lt;/code&gt; - создать бесконечный диапазон, который начинается с отрицательной бесконечности и идет к фиксированной конечной точке. Переберите его в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="fea46f39188f37b7400472b6a7256e566f0dadfc" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;PosInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;PosInfInterval&lt;/code&gt; is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</source>
          <target state="translated">Любые диапазоны, которые повторяются в &lt;code&gt;PosInfInterval&lt;/code&gt; , бесконечны. Итак, основная цель использования &lt;code&gt;PosInfInterval&lt;/code&gt; - создать бесконечный диапазон, который начинается в фиксированный момент времени и уходит в положительную бесконечность.</target>
        </trans-unit>
        <trans-unit id="f9d9d3b6ac3e9e29441a9345be2bae022fb55442" translate="yes" xml:space="preserve">
          <source>Any sequence of character class elements implicitly forms a union.</source>
          <target state="translated">Любая последовательность элементов класса символов неявно образует союз.</target>
        </trans-unit>
        <trans-unit id="f33c41254cc91d5ef5db3832237d967b66a6b7df" translate="yes" xml:space="preserve">
          <source>Any statement can be labeled, including empty statements, and so can serve as the target of a goto statement. Labeled statements can also serve as the target of a break or continue statement.</source>
          <target state="translated">Любое утверждение может быть помечено,включая пустые утверждения,и таким образом может служить в качестве цели goto утверждения.Металлизированные операторы также могут служить мишенью для перерыва или продолжения оператора.</target>
        </trans-unit>
        <trans-unit id="77bf850fc03647bf14bd010a86cea6f71dcbb566" translate="yes" xml:space="preserve">
          <source>Any type which implicitly converts to &lt;code&gt;dchar&lt;/code&gt;. In the case where it's a built-in type, or an enum of a built-in type, &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; is returned, whereas if it's a user-defined type, &lt;code&gt;dchar&lt;/code&gt; is returned.</source>
          <target state="translated">Любой тип, который неявно преобразуется в &lt;code&gt;dchar&lt;/code&gt; . В случае, если это встроенный тип или перечисление встроенного типа, &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; , тогда как если это определенный пользователем тип, возвращается &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83413c5ae04e9398c07c45877def24fe2d3e627f" translate="yes" xml:space="preserve">
          <source>Any usage examples</source>
          <target state="translated">Любые примеры использования</target>
        </trans-unit>
        <trans-unit id="5b0bf7c14ffa6d93dd97c17d04c8db163f500b7e" translate="yes" xml:space="preserve">
          <source>Append 'this' to the specific module members[]</source>
          <target state="translated">Добавьте 'this' к конкретным членам модуля[].</target>
        </trans-unit>
        <trans-unit id="e6389badcbed51133ce737118947b50567eac4a2" translate="yes" xml:space="preserve">
          <source>Append &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;&lt;code&gt;ch&lt;/code&gt; to this grapheme.</source>
          <target state="translated">Добавьте &lt;a href=&quot;#Character&quot;&gt;символ &lt;/a&gt; &lt;code&gt;ch&lt;/code&gt; к этой графеме.</target>
        </trans-unit>
        <trans-unit id="9423c656632feb94c95542550bc5776ab847c04f" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;e2&lt;/code&gt; to chain of exceptions that starts with &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="translated">Добавьте &lt;code&gt;e2&lt;/code&gt; к цепочке исключений, которая начинается с &lt;code&gt;e1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3d06094350a95ba5b433011fb835e7124c4ec5e" translate="yes" xml:space="preserve">
          <source>Append a CData item to the interior of this element</source>
          <target state="translated">Приложите элемент CD-данных к интерьеру этого элемента.</target>
        </trans-unit>
        <trans-unit id="984824e040f0720fce2fc4f6a13d57fc728e8caa" translate="yes" xml:space="preserve">
          <source>Append a comment to the interior of this element</source>
          <target state="translated">Добавить комментарий к интерьеру этого элемента</target>
        </trans-unit>
        <trans-unit id="db03388cd72ade8520d2e378966e698614e72a5e" translate="yes" xml:space="preserve">
          <source>Append a complete element to the interior of this element</source>
          <target state="translated">Добавить полный элемент в интерьер этого элемента</target>
        </trans-unit>
        <trans-unit id="ef21e116b7bca07b0b591badb0bc081fdcfe67e5" translate="yes" xml:space="preserve">
          <source>Append a processing instruction to the interior of this element</source>
          <target state="translated">Приложите инструкцию по обработке к внутренней части этого элемента.</target>
        </trans-unit>
        <trans-unit id="496596976c04bde5f7e7a5a8202d7b8abe85e980" translate="yes" xml:space="preserve">
          <source>Append a text item to the interior of this element</source>
          <target state="translated">Добавить текстовый элемент к интерьеру этого элемента</target>
        </trans-unit>
        <trans-unit id="f6dd93a31eb85b0a74d513a784054a244ba3c76c" translate="yes" xml:space="preserve">
          <source>Append all &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; from the input range &lt;code&gt;inp&lt;/code&gt; to this Grapheme.</source>
          <target state="translated">Добавьте все &lt;a href=&quot;#Character&quot;&gt;символы&lt;/a&gt; из входного диапазона &lt;code&gt;inp&lt;/code&gt; в эту графему.</target>
        </trans-unit>
        <trans-unit id="34b47904d2988c2185d4a53f77f7d8e792a3291d" translate="yes" xml:space="preserve">
          <source>Append array &lt;code&gt;y&lt;/code&gt; to array &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Добавить массив &lt;code&gt;y&lt;/code&gt; к массиву &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad6cd5314f128c12adc628c28aef59e004d422e0" translate="yes" xml:space="preserve">
          <source>Append data represented by ptr[0..size]</source>
          <target state="translated">Приложить данные,представленные в виде ptr[0...size].</target>
        </trans-unit>
        <trans-unit id="35f4f092745cbd38143bff7f25d5d2804e9a0623" translate="yes" xml:space="preserve">
          <source>Append data to the internal buffer.</source>
          <target state="translated">Добавить данные во внутренний буфер.</target>
        </trans-unit>
        <trans-unit id="6cfc826c67159c690715f887f4b34b4df17e6673" translate="yes" xml:space="preserve">
          <source>Append dchar to char[]</source>
          <target state="translated">Добавить dchar к char[]</target>
        </trans-unit>
        <trans-unit id="b6ff7bb65433411731c9ec32fd03f8c8b7ab8dbf" translate="yes" xml:space="preserve">
          <source>Append dchar to wchar[]</source>
          <target state="translated">Добавить dchar к wchar[]</target>
        </trans-unit>
        <trans-unit id="f099c58d9143b4e0a6f01a50957762bf07adaa8f" translate="yes" xml:space="preserve">
          <source>Append dt to data.</source>
          <target state="translated">Добавьте dt к данным.</target>
        </trans-unit>
        <trans-unit id="73602dd98d646af114882b411baed4caf29ed4aa" translate="yes" xml:space="preserve">
          <source>Append dtb to data.</source>
          <target state="translated">Добавить dtb к данным.</target>
        </trans-unit>
        <trans-unit id="05676aa51ec52e96deb89d7ae3b7bad0e2920095" translate="yes" xml:space="preserve">
          <source>Append instead of overwrite on upload!</source>
          <target state="translated">Добавьте вместо перезаписи при загрузке!</target>
        </trans-unit>
        <trans-unit id="725e2673bb64dd768f5e35adc33733f051daff12" translate="yes" xml:space="preserve">
          <source>Append integer item to list.</source>
          <target state="translated">Добавить целочисленный элемент к списку.</target>
        </trans-unit>
        <trans-unit id="8e98d78b75b667bfa9432c073969f89aad62837e" translate="yes" xml:space="preserve">
          <source>Append nbytes of 0 to the internal buffer.</source>
          <target state="translated">Добавить во внутренний буфер nbytes of 0.</target>
        </trans-unit>
        <trans-unit id="6100e49b257665109b21fcb575027c3b1d83fee9" translate="yes" xml:space="preserve">
          <source>Append output of C's printf() to internal buffer.</source>
          <target state="translated">Добавить вывод C's printf()во внутренний буфер.</target>
        </trans-unit>
        <trans-unit id="6f1cd15bde5d09d444835959bdf7cf1009a819c1" translate="yes" xml:space="preserve">
          <source>Append output of C's vprintf() to internal buffer.</source>
          <target state="translated">Добавить вывод vprintf()Си во внутренний буфер.</target>
        </trans-unit>
        <trans-unit id="26196f1c60516e313842646d760dfe092b0b8783" translate="yes" xml:space="preserve">
          <source>Append ptr to *plist.</source>
          <target state="translated">Добавьте ptr к *списту.</target>
        </trans-unit>
        <trans-unit id="379fc789872b087a61658c08353344a2820471c2" translate="yes" xml:space="preserve">
          <source>Append s to list of object files to generate later.</source>
          <target state="translated">Приложите s к списку объектных файлов для последующего генерирования.</target>
        </trans-unit>
        <trans-unit id="7c74420521a423ce5daf955e234405a229d6cc0f" translate="yes" xml:space="preserve">
          <source>Append the remaining segments of &lt;code&gt;path&lt;/code&gt; to the string and return.</source>
          <target state="translated">Добавьте оставшиеся сегменты &lt;code&gt;path&lt;/code&gt; к строке и верните.</target>
        </trans-unit>
        <trans-unit id="9e7e4b12820cee8e262b36441f586183f6d04cab" translate="yes" xml:space="preserve">
          <source>Append y[] to array x[]</source>
          <target state="translated">Добавить y[]к массиву x[]</target>
        </trans-unit>
        <trans-unit id="0ef306358b052f7e64b8bcc3cd14249cef33ca02" translate="yes" xml:space="preserve">
          <source>Appender!(E[]) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A : E[], E)(auto ref A array);</source>
          <target state="translated">Appender! (E []) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt; (A: E [], E) (автоматическая ссылка на массив);</target>
        </trans-unit>
        <trans-unit id="4e11e6991b83788f5357a19dc342f52d09507315" translate="yes" xml:space="preserve">
          <source>Appender!A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A)()</source>
          <target state="translated">Appender! A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt; (A) ()</target>
        </trans-unit>
        <trans-unit id="b06a35dce8dc5935a09578e40179d4dbbd0cee5e" translate="yes" xml:space="preserve">
          <source>Appending does not always create a copy, see &lt;a href=&quot;#resize&quot;&gt; setting dynamic array length&lt;/a&gt; for details.</source>
          <target state="translated">При добавлении не всегда создается копия, подробнее см. &lt;a href=&quot;#resize&quot;&gt;Настройку длины динамического массива&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d23d95cfc1028cebc43e6d6bc87290142bad8a2a" translate="yes" xml:space="preserve">
          <source>Appending to and direct manipulation of grapheme's &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; may render it no longer valid. Certain applications may chose to use Grapheme as a &quot;small string&quot; of any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; and ignore this property entirely.</source>
          <target state="translated">Присоединение и прямое манипулирование &lt;a href=&quot;#Character&quot;&gt;персонажами&lt;/a&gt; графемы может сделать его недействительным. Некоторые приложения могут использовать Grapheme в качестве &amp;laquo;маленькой строки&amp;raquo; любых &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек&lt;/a&gt; и полностью игнорировать это свойство.</target>
        </trans-unit>
        <trans-unit id="27687e63c8f2765f7f45c656d25a88a2f70872d2" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;buffer&lt;/code&gt; to file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Добавляет &lt;code&gt;buffer&lt;/code&gt; к &lt;code&gt;name&lt;/code&gt; файла .</target>
        </trans-unit>
        <trans-unit id="d7f62b12268c12952ecff14c3290b88618812066" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;item&lt;/code&gt; to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; types if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">Добавляет &lt;code&gt;item&lt;/code&gt; в управляемый массив. Выполняет кодирование для типов &lt;code&gt;char&lt;/code&gt; если &lt;code&gt;A&lt;/code&gt; является массивом &lt;code&gt;char&lt;/code&gt; другого типа .</target>
        </trans-unit>
        <trans-unit id="3fa391a5e33fe2002fc2b72cecadf723ca6b30fe" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;rhs&lt;/code&gt; to the managed array.</source>
          <target state="translated">Добавляет &lt;code&gt;rhs&lt;/code&gt; к управляемому массиву.</target>
        </trans-unit>
        <trans-unit id="7623fabcaede88b964c04becc831d4ac3e3b23ce" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; may be a single element or an input range type.</source>
          <target state="translated">Добавляет &lt;code&gt;x&lt;/code&gt; к &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; может быть отдельным элементом или типом входного диапазона.</target>
        </trans-unit>
        <trans-unit id="18bc8e8710e112a386b8301eb1ea86dca70c5d37" translate="yes" xml:space="preserve">
          <source>Appends a string to a linked list. If no list exists, it will be created first. Returns the new list, after appending.</source>
          <target state="translated">Добавляет строку к связанному списку.Если список не существует,то он будет создан первым.Возвращает новый список после добавления.</target>
        </trans-unit>
        <trans-unit id="81cdccb19773651976963e90237f5de77beaf9e6" translate="yes" xml:space="preserve">
          <source>Appends an entire range to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; elements if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">Добавляет весь диапазон к управляемому массиву. Выполняет кодирование для &lt;code&gt;char&lt;/code&gt; если &lt;code&gt;A&lt;/code&gt; является массивом &lt;code&gt;char&lt;/code&gt; другого типа .</target>
        </trans-unit>
        <trans-unit id="e1a17d68e5eb26669b8a6fd759bf09e863160e46" translate="yes" xml:space="preserve">
          <source>Appends the contents of the argument &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Добавляет содержимое аргумента &lt;code&gt;rhs&lt;/code&gt; в &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20cd868cd32de230764914be80101e71a8f019d2" translate="yes" xml:space="preserve">
          <source>Appends to the managed array.</source>
          <target state="translated">Применяется к управляемому массиву.</target>
        </trans-unit>
        <trans-unit id="762f62942181d4b2666650e69bb8c92655c35501" translate="yes" xml:space="preserve">
          <source>AppleTalk</source>
          <target state="translated">AppleTalk</target>
        </trans-unit>
        <trans-unit id="82cac29a8ad5cbbc38d1a1fb84f536367b07a15f" translate="yes" xml:space="preserve">
          <source>Application Binary Interface</source>
          <target state="translated">Двоичный интерфейс приложения</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">Кэш страниц,определяемый приложением.</target>
        </trans-unit>
        <trans-unit id="a1097391b6d8c24e778f4782f5e62fadaf414d9d" translate="yes" xml:space="preserve">
          <source>Applies a delegate or function to the given &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; depending on the held type, ensuring that all types are handled by the visiting functions.</source>
          <target state="translated">Применяет делегат или функцию к заданному &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt; зависимости от типа удержания, гарантируя, что все типы обрабатываются функциями посещения.</target>
        </trans-unit>
        <trans-unit id="2e64c5b4326d836829a0ebf41a9e13a5e62411c7" translate="yes" xml:space="preserve">
          <source>Apply MODxxxx bits to existing type.</source>
          <target state="translated">Применять биты MODxxxx к существующему типу.</target>
        </trans-unit>
        <trans-unit id="ee985a3510121398e40860de4ace149b4869d63d" translate="yes" xml:space="preserve">
          <source>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</source>
          <target state="translated">Применить биты STCxxx к существующему типу.Используйте *перед*выполнением семантического анализа.</target>
        </trans-unit>
        <trans-unit id="a27c3d86d32e5ed828ae9b07fd5ad23ae9593843" translate="yes" xml:space="preserve">
          <source>Apply a function fp to each member of a list.</source>
          <target state="translated">Применить функцию fp к каждому участнику списка.</target>
        </trans-unit>
        <trans-unit id="5c98d8debd927a2a04375be8cb963231c736c4c5" translate="yes" xml:space="preserve">
          <source>Applying a qualifier to a type that already has that qualifier is legal but has no effect, e.g. given an unqualified type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;shared(const shared T)&lt;/code&gt; yields the type &lt;code&gt;const shared T&lt;/code&gt;.</source>
          <target state="translated">Применение спецификатора типа , который уже имеет , что классификатор является законным , но не имеет никакого эффекта, например , данный неквалифицированный тип &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;shared(const shared T)&lt;/code&gt; дает тип &lt;code&gt;const shared T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a15b638351f6a01ae8878d2186ac098d189b867" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;immutable&lt;/code&gt; qualifier to any type (qualified or not) results in &lt;code&gt;immutable T&lt;/code&gt;. Applying any qualifier to &lt;code&gt;immutable T&lt;/code&gt; results in &lt;code&gt;immutable T&lt;/code&gt;. This makes &lt;code&gt;immutable&lt;/code&gt; a fixed point of qualifier combinations and makes types such as &lt;code&gt;const(immutable(shared T))&lt;/code&gt; impossible to create.</source>
          <target state="translated">Применяя &lt;code&gt;immutable&lt;/code&gt; спецификатор к любому типу (квалифицированного или нет) приводит к &lt;code&gt;immutable T&lt;/code&gt; . Применяя любую спецификатор к &lt;code&gt;immutable T&lt;/code&gt; приводит к &lt;code&gt;immutable T&lt;/code&gt; . Это делает &lt;code&gt;immutable&lt;/code&gt; фиксированные точки комбинаций квалификаторов и делает невозможным создание таких типов, как &lt;code&gt;const(immutable(shared T))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5e35d0b2742a654477e1cd63556f021113ce5b4c" translate="yes" xml:space="preserve">
          <source>Arabic Extended-A</source>
          <target state="translated">арабский Расширенный-A</target>
        </trans-unit>
        <trans-unit id="e2e75f0c9d3aecdda25899708775d147043e7830" translate="yes" xml:space="preserve">
          <source>Arabic Mathematical Alphabetic Symbols</source>
          <target state="translated">Арабские математические алфавитные символы</target>
        </trans-unit>
        <trans-unit id="1855677dcc7468bb9c8e6a1cd81ba79444a4ff7e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-A</source>
          <target state="translated">Формы для представления информации на арабском языке-A</target>
        </trans-unit>
        <trans-unit id="81d80ec90565c460cb86314a7772144c7915e63e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-B</source>
          <target state="translated">Формы для представления информации на арабском языке-B</target>
        </trans-unit>
        <trans-unit id="f967001c1a34ccb5d4db68033cb95ea3afa4f067" translate="yes" xml:space="preserve">
          <source>Arabic Supplement</source>
          <target state="translated">Арабское приложение</target>
        </trans-unit>
        <trans-unit id="f984e10440745697cc3d65ba4c39e78b962f2e10" translate="yes" xml:space="preserve">
          <source>Arbitrary block of memory (&lt;code&gt;null&lt;/code&gt; is allowed; &lt;code&gt;owns(null)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Произвольный блок памяти ( допускается &lt;code&gt;null&lt;/code&gt; ; &lt;code&gt;owns(null)&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="35ae340d74ec660428a4617d592eb281817c9ae4" translate="yes" xml:space="preserve">
          <source>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</source>
          <target state="translated">Произвольная длина и сложность lookbehind,включая lookahead в lookbehind и vise-versa.</target>
        </trans-unit>
        <trans-unit id="2b10f364535b59752b7187d9f87de14ac7b52ee5" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision ('bignum') arithmetic.</source>
          <target state="translated">Арифметика произвольной точности (&quot;bignum&quot;).</target>
        </trans-unit>
        <trans-unit id="04a64131d2f2d9afe00e52e932f2410778390372" translate="yes" xml:space="preserve">
          <source>ArchiveMember &lt;code&gt;de&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fcbd049669bd8c4ed6c2c7a64ef6513f2e0d6d" translate="yes" xml:space="preserve">
          <source>Are AMD extensions to MMX supported?</source>
          <target state="translated">Поддерживаются ли расширения AMD для MMX?</target>
        </trans-unit>
        <trans-unit id="01e21616c01d0a2fca25a82b396c6f6e959a0c86" translate="yes" xml:space="preserve">
          <source>Are LAHF and SAHF supported in 64-bit mode?</source>
          <target state="translated">Поддерживаются ли LAHF и SAHF в 64-битном режиме?</target>
        </trans-unit>
        <trans-unit id="3a1445e9d8e93be79bf26c9c6c4caa120500ae1a" translate="yes" xml:space="preserve">
          <source>Are any of the Objects an error?</source>
          <target state="translated">Является ли какой-либо из Объектов ошибкой?</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="4293e4b957c97199f617f8492936758c0b738afa" translate="yes" xml:space="preserve">
          <source>Args &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">Args &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f5be29a09e6e60319db52d529ad7515c16471a5" translate="yes" xml:space="preserve">
          <source>Argument Deduction</source>
          <target state="translated">Дедукция аргументов</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">Тип аргумента</target>
        </trans-unit>
        <trans-unit id="29654984a9e906a0a06167995d3f42a8d08cf353" translate="yes" xml:space="preserve">
          <source>Argument to xInit() and xShutdown()</source>
          <target state="translated">Аргумент к xInit()и xShutdown()</target>
        </trans-unit>
        <trans-unit id="daf86c8879ed0c69961403ceb76965c2482d6deb" translate="yes" xml:space="preserve">
          <source>ArgumentList</source>
          <target state="translated">ArgumentList</target>
        </trans-unit>
        <trans-unit id="8946712557cc8b1c3fb3e94fee0d0fce04b3802b" translate="yes" xml:space="preserve">
          <source>Arguments to pass to &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">Аргументы для передачи &lt;code&gt;T&lt;/code&gt; конструктору &amp;laquo;s.</target>
        </trans-unit>
        <trans-unit id="bfbc91d37e47f927568d7a30e3496cf96960cf08" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the method.</source>
          <target state="translated">Аргументы для перехода к методу.</target>
        </trans-unit>
        <trans-unit id="89180ef2e932b4599c798900639013ef3f341134" translate="yes" xml:space="preserve">
          <source>Arguments to the function.</source>
          <target state="translated">Аргументы в пользу функции.</target>
        </trans-unit>
        <trans-unit id="cd64cf49b3ec9934a802f3e5622e652b8742e909" translate="yes" xml:space="preserve">
          <source>Arguments to variadic functions (such as &lt;code&gt;printf&lt;/code&gt;) are considered to be consumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9630a5d15efcdc7541a36a0160b3500004aba0a" translate="yes" xml:space="preserve">
          <source>Arithmetic between &lt;code&gt;VariantN&lt;/code&gt; objects and numeric values. All arithmetic operations return a &lt;code&gt;VariantN&lt;/code&gt; object typed depending on the types of both values involved. The conversion rules mimic D's built-in rules for arithmetic conversions.</source>
          <target state="translated">Арифметика между объектами &lt;code&gt;VariantN&lt;/code&gt; и числовыми значениями. Все арифметические операции возвращают объект &lt;code&gt;VariantN&lt;/code&gt; , типизированный в зависимости от типов обоих используемых значений. Правила преобразования имитируют встроенные правила D для арифметических преобразований.</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="2c96bf3a668aac126792eaf02dadd14fa48e70d3" translate="yes" xml:space="preserve">
          <source>Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (string op, Stuff) (Разное)</target>
        </trans-unit>
        <trans-unit id="3660d1d1308b201f353bc8fa6130b29f9ba2d842" translate="yes" xml:space="preserve">
          <source>Array Bounds Checking</source>
          <target state="translated">Проверка границ массива</target>
        </trans-unit>
        <trans-unit id="1f1275d2846b1606eecf7847c7e27140c6dc6c89" translate="yes" xml:space="preserve">
          <source>Array Concatenation</source>
          <target state="translated">Концентрация массива</target>
        </trans-unit>
        <trans-unit id="5d1d05717fafa53ed33983c8c412c01fb3ca32f6" translate="yes" xml:space="preserve">
          <source>Array Copying</source>
          <target state="translated">Массивное копирование</target>
        </trans-unit>
        <trans-unit id="0b0779db36c24b1c78ab44d3d32261e35d9bc05e" translate="yes" xml:space="preserve">
          <source>Array Declarations</source>
          <target state="translated">Массивные декларации</target>
        </trans-unit>
        <trans-unit id="83248d40160f2cce014335fe1581785cb6bcecaf" translate="yes" xml:space="preserve">
          <source>Array Index/Slice scope</source>
          <target state="translated">Индекс массива/охват среза</target>
        </trans-unit>
        <trans-unit id="4b91e23ca287553cadb09bb925d112bdb13a167e" translate="yes" xml:space="preserve">
          <source>Array Indexing and Slicing Operators Overloading</source>
          <target state="translated">Операторы индексирования массивов и разрезания Перегрузка операторов</target>
        </trans-unit>
        <trans-unit id="b3e061b1b0837d1a9960794f282dd75e750eb332" translate="yes" xml:space="preserve">
          <source>Array Initialization</source>
          <target state="translated">Инициализация массива</target>
        </trans-unit>
        <trans-unit id="1c847e3a06bdc4135a7a456a0f00a984d2c67477" translate="yes" xml:space="preserve">
          <source>Array Length</source>
          <target state="translated">Длина массива</target>
        </trans-unit>
        <trans-unit id="f9f04b9d6c3b8a78da5ec9d06e0efef4332889f5" translate="yes" xml:space="preserve">
          <source>Array Literals</source>
          <target state="translated">Массив букв</target>
        </trans-unit>
        <trans-unit id="7106a989ccb65a04eb4c26053be05ad2d2e071e2" translate="yes" xml:space="preserve">
          <source>Array Operations</source>
          <target state="translated">Массивные операции</target>
        </trans-unit>
        <trans-unit id="9d517d3c8494600360cbc4c90cee07bed4ba0d68" translate="yes" xml:space="preserve">
          <source>Array Properties</source>
          <target state="translated">Свойства массива</target>
        </trans-unit>
        <trans-unit id="9703b944aa367c5aa673c3d017ce64794e77b9b2" translate="yes" xml:space="preserve">
          <source>Array Setting</source>
          <target state="translated">Настройка массива</target>
        </trans-unit>
        <trans-unit id="1aa037357a9b7f1c16ef42cc60976b8847ef657b" translate="yes" xml:space="preserve">
          <source>Array Usage</source>
          <target state="translated">Использование массива</target>
        </trans-unit>
        <trans-unit id="c01b400578305839c9f204fb953e859a5125d529" translate="yes" xml:space="preserve">
          <source>Array and associative array operations. If a &lt;code&gt; VariantN&lt;/code&gt; contains an (associative) array, it can be indexed into. Otherwise, an exception is thrown.</source>
          <target state="translated">Операции с массивами и ассоциативными массивами. Если &lt;code&gt; VariantN&lt;/code&gt; содержит (ассоциативный) массив, он может быть проиндексирован в. В противном случае выдается исключение.</target>
        </trans-unit>
        <trans-unit id="b84dfacc31a0969124c8d1abef734c629bb90a1e" translate="yes" xml:space="preserve">
          <source>Array appending</source>
          <target state="translated">Массив добавления</target>
        </trans-unit>
        <trans-unit id="5d76be94dc9a7b58ca84dbb5c3adb93a7d01641c" translate="yes" xml:space="preserve">
          <source>Array bound checks.</source>
          <target state="translated">Массивные проверки.</target>
        </trans-unit>
        <trans-unit id="85acbf2069ff740d2820da623cb0a7f96c951889" translate="yes" xml:space="preserve">
          <source>Array bounds checks are disabled (command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck=off&lt;/em&gt;&lt;/a&gt;)</source>
          <target state="translated">Проверка границ массива отключена (параметр командной строки &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck = off&lt;/em&gt;&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c9495b0030caddeaddd3d77aa9749a4ea64f6f7d" translate="yes" xml:space="preserve">
          <source>Array bounds checks are necessary to enforce memory safety, so these are enabled (by default) for &lt;code&gt;@safe&lt;/code&gt; code even in &lt;b&gt;-release&lt;/b&gt; mode.</source>
          <target state="translated">Проверка границ массива необходима для обеспечения безопасности памяти, поэтому они включены (по умолчанию) для кода &lt;code&gt;@safe&lt;/code&gt; даже в режиме &lt;b&gt;-release&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cea52181688b642f5fdfd14c038de482c009d5f6" translate="yes" xml:space="preserve">
          <source>Array concatenation</source>
          <target state="translated">Конкатенация массивов</target>
        </trans-unit>
        <trans-unit id="57ff9464bbbd1fa1767e470a5012532b91719c42" translate="yes" xml:space="preserve">
          <source>Array container for internal usage.</source>
          <target state="translated">Массивный контейнер для внутреннего использования.</target>
        </trans-unit>
        <trans-unit id="65a0b8da864827cd0478aba1fdf30610a77c4fd1" translate="yes" xml:space="preserve">
          <source>Array containing arrays that will be concatenated.</source>
          <target state="translated">Массив,содержащий массивы,которые будут соединены.</target>
        </trans-unit>
        <trans-unit id="67d3696aeb8ef015e2952b35a392df743f65e443" translate="yes" xml:space="preserve">
          <source>Array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">Массив буквально будет распределен на кучу ГК.Проверьте его элементы,чтобы узнать,не сбежит ли кто-нибудь из них на кучу.</target>
        </trans-unit>
        <trans-unit id="014dbf281d4d372cf828b4f858f7eb383406da80" translate="yes" xml:space="preserve">
          <source>Array literals (except when used to initialize static data)</source>
          <target state="translated">Массивные литералы (за исключением случаев,когда они используются для инициализации статических данных)</target>
        </trans-unit>
        <trans-unit id="f6a7d7c506c31a93cc6747b37be514d93fad8773" translate="yes" xml:space="preserve">
          <source>Array literals are a comma-separated list of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;s between square brackets &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;. The</source>
          <target state="translated">Литералы массива - это разделенный запятыми список &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;выражений AssignExpression, заключенных в&lt;/i&gt;&lt;/a&gt; квадратные скобки &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dae2c2b63d025ee4c0832bb31c33f2a5fbf34690" translate="yes" xml:space="preserve">
          <source>Array literals are allocated on the memory managed heap. Thus, they can be returned safely from functions:</source>
          <target state="translated">Массивные литералы распределяются по управляемой куче памяти.Таким образом,они могут быть безопасно возвращены из функций:</target>
        </trans-unit>
        <trans-unit id="e69b9d12c30731402c84433338297ab2257d2102" translate="yes" xml:space="preserve">
          <source>Array of VarDeclaration's for parameters</source>
          <target state="translated">Массив параметров VarDeclaration's</target>
        </trans-unit>
        <trans-unit id="5d9eb8f765adfc90b02ec28ca02924204c83af1e" translate="yes" xml:space="preserve">
          <source>Array of characters read.</source>
          <target state="translated">Массив прочитанных символов.</target>
        </trans-unit>
        <trans-unit id="1a234f4c4feb75a8aa7b93d09c3a8859c0ea7eb5" translate="yes" xml:space="preserve">
          <source>Array of pairs giving the offset and type information for each member in an aggregate.</source>
          <target state="translated">Массив пар,дающий информацию о смещении и типе каждого члена в совокупности.</target>
        </trans-unit>
        <trans-unit id="3cc66155c78e1b4720002ac02361e391e42c1fdd" translate="yes" xml:space="preserve">
          <source>Array of the strings representing time units, starting with the smallest unit and going to the largest. It does not include &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">Массив строк, представляющих единицы времени, начиная с самой маленькой единицы и заканчивая самой большой. Это не включает &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c26e25fdec1370d18f0c93ee54cfd77f08bc7279" translate="yes" xml:space="preserve">
          <source>Array options.</source>
          <target state="translated">Опции массива.</target>
        </trans-unit>
        <trans-unit id="fecbe8e577ceb3d414c1005061daf3736c402d86" translate="yes" xml:space="preserve">
          <source>Array representing the entire archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268c73e26ed36171acb2987f7e489853cedee3f4" translate="yes" xml:space="preserve">
          <source>Array representing the entire contents of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ee133059983d2093ca847eb799753d9f96eeef" translate="yes" xml:space="preserve">
          <source>Array slicing, and array bounds checking</source>
          <target state="translated">Срезание массива и проверка границ массива</target>
        </trans-unit>
        <trans-unit id="f187d73020c36a9ee259d3863cac2e2a8546f9fe" translate="yes" xml:space="preserve">
          <source>Array specialized for &lt;code&gt;bool&lt;/code&gt;. Packs together values efficiently by allocating one bit per element.</source>
          <target state="translated">Массив, специализированный для &lt;code&gt;bool&lt;/code&gt; . Эффективно объединяет значения, выделяя один бит на элемент.</target>
        </trans-unit>
        <trans-unit id="5058965ad79b9992b8f00aae6b40d9b43a8d0f10" translate="yes" xml:space="preserve">
          <source>Array syntax for json arrays.</source>
          <target state="translated">Синтаксис массивов для массивов Джсона.</target>
        </trans-unit>
        <trans-unit id="5973135baae02b17a741da0daeae795a22336d6f" translate="yes" xml:space="preserve">
          <source>Array to append the flags to, if any.</source>
          <target state="translated">Массив для прикрепления флагов,если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="d290f86768d5ed39f7a46e3545ef125df15763f2" translate="yes" xml:space="preserve">
          <source>Array to which binaries (shared/static libs and object files) will be appended</source>
          <target state="translated">Массив,к которому будут добавляться двоичные файлы (общие/статические библиотеки и объектные файлы)</target>
        </trans-unit>
        <trans-unit id="c59fb5bcd382383b02c6f2e682a6e49d5169c774" translate="yes" xml:space="preserve">
          <source>Array type with deterministic control of memory. The memory allocated for the array is reclaimed as soon as possible; there is no reliance on the garbage collector. &lt;code&gt;Array&lt;/code&gt; uses &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; for managing its own memory.</source>
          <target state="translated">Тип массива с детерминированным контролем памяти. Память, выделенная для массива, освобождается как можно скорее; нет никакой зависимости от сборщика мусора. &lt;code&gt;Array&lt;/code&gt; использует &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;realloc&lt;/code&gt; и &lt;code&gt;free&lt;/code&gt; для управления собственной памятью.</target>
        </trans-unit>
        <trans-unit id="17f3d834c909f91543323d2da6d7e392df7fc04d" translate="yes" xml:space="preserve">
          <source>Array utilities.</source>
          <target state="translated">Утилиты для массивов.</target>
        </trans-unit>
        <trans-unit id="d8d1c5f297e5b542d7b3b426ee67519393b84051" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;Address&lt;/code&gt; instance per socket address.</source>
          <target state="translated">Массив с одним экземпляром &lt;code&gt;Address&lt;/code&gt; на каждый адрес сокета.</target>
        </trans-unit>
        <trans-unit id="7b02c75e5cfd1dbb8861cc9d33aefc7788debf27" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;AddressInfo&lt;/code&gt; per socket address.</source>
          <target state="translated">Массив с одним &lt;code&gt;AddressInfo&lt;/code&gt; для каждого адреса сокета.</target>
        </trans-unit>
        <trans-unit id="ccb9694106595867500e36f178956e556d5f06d5" translate="yes" xml:space="preserve">
          <source>Array!T &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">Массив! T &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59ed81f06d61cee7ac46ef81d4494047f843a918" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="translated">Массив! BOOL &lt;strong id=&quot;opBinary&quot;&gt; Bool opBinary&lt;/strong&gt; (string op, Stuff) ( &lt;strong id=&quot;opBinary&quot;&gt;Штучные&lt;/strong&gt; материалы)</target>
        </trans-unit>
        <trans-unit id="f58b7e3beff7cb376f330022b72abdbf5e8d71a8" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">Array! &lt;strong id=&quot;opOpAssign&quot;&gt;Bool opOpAssign&lt;/strong&gt; (строка op, Stuff) (Материал вещи)</target>
        </trans-unit>
        <trans-unit id="fb8a70fa9de0823f16fd95fb5d95b4122c80f726" translate="yes" xml:space="preserve">
          <source>ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</source>
          <target state="translated">ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcde65a6ef36678480c533ad205a2b3653940979" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49604b859f9dbf7987784da7c49e4b4f67d157a7" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt;(UnionExp* pue, ref const Loc loc, Type type, Expression elem, size_t dim);</source>
          <target state="translated">ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt; (UnionExp * pue, ref const Loc loc, Тип типа, Выражение elem, size_t dim);</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="5ec121f807ed23a3ee478e2902d2a39d93f6938e" translate="yes" xml:space="preserve">
          <source>Arrays (dynamic and static)</source>
          <target state="translated">Массивы (динамические и статические)</target>
        </trans-unit>
        <trans-unit id="dad86d2f90fcf8d8a3cdfa4cf789d731af0dd940" translate="yes" xml:space="preserve">
          <source>Arrays and static arrays</source>
          <target state="translated">Массивы и статические массивы</target>
        </trans-unit>
        <trans-unit id="1f1d0899c823da5c8626a1dbb08800ddf6eec849" translate="yes" xml:space="preserve">
          <source>Arrays of any type can be implicitly converted to a void array; the compiler inserts the appropriate calculations so that the &lt;code&gt;.length&lt;/code&gt; of the resulting array's size is in bytes rather than number of elements. Void arrays cannot be converted back to the original type without using a cast, and it is an error to convert to an array type whose element size does not evenly divide the length of the void array.</source>
          <target state="translated">Массивы любого типа могут быть неявно преобразованы в массив void; компилятор вставляет соответствующие вычисления так, чтобы &lt;code&gt;.length&lt;/code&gt; результирующего массива была в байтах, а не в количестве элементов. Пустые массивы не могут быть преобразованы обратно в исходный тип без использования приведения, и это ошибка для преобразования в тип массива, размер элемента которого не делит поровну длину массива void.</target>
        </trans-unit>
        <trans-unit id="d07335e1b59b41b81acffb9c1b5c94e2033e5ab4" translate="yes" xml:space="preserve">
          <source>Arrays read right to left as well:</source>
          <target state="translated">Массивы тоже читают справа налево:</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="ebe044f5962ca7b8d7aab096e7aee2bc2b61b686" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;static foreach&lt;/code&gt; is a code generation construct and not a loop, &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; cannot be used to change control flow within it. Instead of breaking or continuing a suitable enclosing statement, such an usage yields an error (this is to prevent misunderstandings).</source>
          <target state="translated">Поскольку &lt;code&gt;static foreach&lt;/code&gt; является конструкцией генерации кода, а не циклом, &lt;code&gt;break&lt;/code&gt; и &lt;code&gt;continue&lt;/code&gt; не могут использоваться для изменения потока управления внутри него. Вместо того, чтобы ломать или продолжать подходящее вложение оператора, такое использование приводит к ошибке (это предотвращает недопонимание).</target>
        </trans-unit>
        <trans-unit id="8fe64c824a70f2fd7f91ffe1f685564777c5e63c" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;scope&lt;/code&gt; parameter must not escape, the compiler can potentially avoid heap-allocating a unique argument to a &lt;code&gt;scope&lt;/code&gt; parameter. Due to this, passing an array literal, delegate literal or a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; to a scope parameter may be allowed in a &lt;code&gt;@nogc&lt;/code&gt; context, depending on the compiler implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d13756a62d354c00bff64fd46fa593358676140" translate="yes" xml:space="preserve">
          <source>As a concession to practicality, a pure function can also:</source>
          <target state="translated">В качестве уступки практичности,чистая функция также может:</target>
        </trans-unit>
        <trans-unit id="8bc155ad0d18590ebe40ebe2b93eb23941ceadd8" translate="yes" xml:space="preserve">
          <source>As a contract, an &lt;code&gt;assert&lt;/code&gt; represents a guarantee that the code</source>
          <target state="translated">Как контракт, &lt;code&gt;assert&lt;/code&gt; представляет собой гарантию того, что код</target>
        </trans-unit>
        <trans-unit id="bccab5f9b93fd641ceebcd69566613681ff777b0" translate="yes" xml:space="preserve">
          <source>As a debugging aid, the compiler may insert a runtime check to verify that the expression is indeed true. If it is false, an &lt;code&gt;AssertError&lt;/code&gt; is thrown. When compiling for release, this check is not generated. The special &lt;code&gt;assert(0)&lt;/code&gt; expression, however, is generated even in release mode. See the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="translated">В качестве средства отладки компилятор может вставить проверку времени выполнения, чтобы убедиться, что выражение действительно истинно. Если оно ложно, генерируется &lt;code&gt;AssertError&lt;/code&gt; . При компиляции для релиза эта проверка не генерируется. Однако специальное выражение &lt;code&gt;assert(0)&lt;/code&gt; генерируется даже в режиме выпуска. См. Документацию &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="90a896ea477e7a62fdbd266c90ef3478e166538a" translate="yes" xml:space="preserve">
          <source>As a micro-optimization, to avoid the heap allocation associated with &lt;code&gt;task&lt;/code&gt; or with the creation of a closure.</source>
          <target state="translated">В качестве микрооптимизации, чтобы избежать выделения кучи, связанной с &lt;code&gt;task&lt;/code&gt; или созданием замыкания.</target>
        </trans-unit>
        <trans-unit id="842753f613e1812047f79b9da908210026f9a41f" translate="yes" xml:space="preserve">
          <source>As above, but also provides &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="translated">Как указано выше, но также предоставляет &lt;code&gt;back&lt;/code&gt; и &lt;code&gt;popBack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a95b268782f9af6c10edd99d4e3bb5baafff0eb" translate="yes" xml:space="preserve">
          <source>As above, but may be reallocated later. Examples of types fitting this description are &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt;double[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">Как указано выше, но может быть перераспределено позже. Примерами типов, подходящих под это описание, являются &lt;code&gt;int[]&lt;/code&gt; , &lt;code&gt;double[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt; , но не &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; , который содержит косвенное указание.</target>
        </trans-unit>
        <trans-unit id="ada3120f9cc1043d7b4f9c611d3e84f82bcb254e" translate="yes" xml:space="preserve">
          <source>As above, but may embed indirections. Examples of types fitting this description are &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;.</source>
          <target state="translated">Как указано выше, но может вставлять косвенные ссылки. Примерами типов, подходящих под это описание, являются &lt;code&gt;int*[]&lt;/code&gt; , &lt;code&gt;Object[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1700838138f9af03c11ccaa20b548dd32d2a5c61" translate="yes" xml:space="preserve">
          <source>As above, but the memory allocated is aligned at &lt;code&gt;a&lt;/code&gt; bytes.</source>
          <target state="translated">Как и выше, но память выделяется выравнивается по &lt;code&gt;a&lt;/code&gt; байт.</target>
        </trans-unit>
        <trans-unit id="9a7b2b5d58503b9d84dce03ccae75f857fd6475e" translate="yes" xml:space="preserve">
          <source>As above, but the type may be appended to in the future. Example: &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Как указано выше, но тип может быть добавлен в будущем. Пример: &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67b44aad993023067b75a99b577d6a3bad9df809" translate="yes" xml:space="preserve">
          <source>As above, but the type may embed references. Example: &lt;code&gt;immutable(Object)[]&lt;/code&gt;.</source>
          <target state="translated">Как и выше, но тип может вставлять ссылки. Пример: &lt;code&gt;immutable(Object)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ab111de9460a5c459418af453cc0583e8938ad" translate="yes" xml:space="preserve">
          <source>As an exception to the above, curl_off_t shall be typedef'ed to a 32-bit wide signed integral data type if there is no 64-bit type.</source>
          <target state="translated">В качестве исключения из вышесказанного,при отсутствии 64-битного типа,curl_off_t будет типизирован к 32-битному знаковому интегральному типу данных.</target>
        </trans-unit>
        <trans-unit id="00c376f2504564e95535f66220527b7aef723e32" translate="yes" xml:space="preserve">
          <source>As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments.</source>
          <target state="translated">Поскольку копирование диапазона означает копирование всех элементов,его можно безопасно вернуть из функций.По этой же причине копирование возвращаемого диапазона может быть дорогостоящим для большого количества аргументов.</target>
        </trans-unit>
        <trans-unit id="86ffd7c99fd994cc802f084df86d92e7d718ebb0" translate="yes" xml:space="preserve">
          <source>As long as the target range elements support assignment from source range elements, different types of ranges are accepted:</source>
          <target state="translated">До тех пор,пока элементы целевого диапазона поддерживают назначение от элементов исходного диапазона,принимаются различные типы диапазонов:</target>
        </trans-unit>
        <trans-unit id="89f24648855e3c77be3def51419022b8377886d0" translate="yes" xml:space="preserve">
          <source>As of this time, &lt;code&gt;std.experimental.allocator&lt;/code&gt; is not integrated with D's built-in operators that allocate memory, such as &lt;code&gt;new&lt;/code&gt;, array literals, or array concatenation operators. That means &lt;code&gt;std.experimental.allocator&lt;/code&gt; is opt-in</source>
          <target state="translated">На данный момент &lt;code&gt;std.experimental.allocator&lt;/code&gt; не интегрирован со встроенными операторами D, которые выделяют память, такими как &lt;code&gt;new&lt;/code&gt; , литералы массива или операторы конкатенации массивов. Это означает &lt;code&gt;std.experimental.allocator&lt;/code&gt; является неавтоматического</target>
        </trans-unit>
        <trans-unit id="7b1738337554a47ddb128a4a9aaf14cc6fec9d90" translate="yes" xml:space="preserve">
          <source>As some GC implementations (such as the current conservative one) don't support GC memory allocation during object finalization, this function can be used to guard against such programming errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c86647896232382d7c6363a032a8965f35f84" translate="yes" xml:space="preserve">
          <source>As the above example shows, a different compile-time argument is passed to &lt;code&gt;opDollar&lt;/code&gt; depending on which argument it appears in. A &lt;code&gt;$&lt;/code&gt; appearing in the first argument gets translated to &lt;code&gt;opDollar!0&lt;/code&gt;, a &lt;code&gt;$&lt;/code&gt; appearing in the second argument gets translated to &lt;code&gt;opDollar!1&lt;/code&gt;, and so on. Thus, the appropriate value for &lt;code&gt;$&lt;/code&gt; can be returned to implement multidimensional arrays.</source>
          <target state="translated">Как показывает приведенный выше пример, в &lt;code&gt;opDollar&lt;/code&gt; передается другой аргумент времени компиляции в зависимости от того, в каком аргументе он появляется. &lt;code&gt;$&lt;/code&gt; , Появляющийся в первом аргументе, преобразуется в &lt;code&gt;opDollar!0&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; , появляющийся во втором аргументе, преобразуется в &lt;code&gt;opDollar!1&lt;/code&gt; и тд. Таким образом, соответствующее значение для &lt;code&gt;$&lt;/code&gt; может быть возвращено для реализации многомерных массивов.</target>
        </trans-unit>
        <trans-unit id="6f1f55e4d756cae86481e151850fb4d8b6d4d597" translate="yes" xml:space="preserve">
          <source>As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Поскольку интервал становится отрицательной бесконечностью, диапазон всегда повторяется назад, а не вперед. &lt;code&gt;func&lt;/code&gt; должен сгенерировать момент времени, идущий в правильном направлении итерации, &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; будет сгенерировано исключение std.datetime.date.DateTimeException . Таким образом, временные точки, которые генерирует &lt;code&gt;func&lt;/code&gt; , должны быть раньше, чем те, которые были переданы ему. Если оно идентично или позже, то будет &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19397d297232fda90f291340ee30b5e3c1ea48c9" translate="yes" xml:space="preserve">
          <source>As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Поскольку интервал становится положительной бесконечностью, диапазон всегда повторяется вперед, а не назад. &lt;code&gt;func&lt;/code&gt; должен сгенерировать момент времени, идущий в правильном направлении итерации, &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; будет сгенерировано исключение std.datetime.date.DateTimeException . Таким образом, моменты времени, которые генерирует &lt;code&gt;func&lt;/code&gt; , должны быть позже, чем тот, который был передан ему. Если оно идентично или ранее, то будет &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80d4a16f3b080b8168646190c746d43efc570fe1" translate="yes" xml:space="preserve">
          <source>As this module is used for diagnostic, it should handle failures as gracefully as possible. Having the runtime error out on printing the stack trace one is trying to debug would be quite a terrible UX. For this reason, this module works on a &quot;best effort&quot; basis and will sometimes print mangled symbols, or &quot;???&quot; when it cannot do anything more useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85319de6635b6d77d85a430a22ed2839720cedf1" translate="yes" xml:space="preserve">
          <source>As we generate code, collect information about what parts of NT exception handling we need.</source>
          <target state="translated">По мере того,как мы генерируем код,собираем информацию о том,какие части обработки исключений NT нам нужны.</target>
        </trans-unit>
        <trans-unit id="51268903c8fb9b838b2eb55d7979a33593c37355" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#lists&quot;&gt;lists&lt;/a&gt;, note that the initial &lt;code&gt;*&lt;/code&gt; in the example above will be stripped because it is part of a documentation comment that is delimited with asterisks, so you need at least three subsequent asterisks.</source>
          <target state="translated">Как и в случае со &lt;a href=&quot;#lists&quot;&gt;списками&lt;/a&gt; , обратите внимание, что начальный &lt;code&gt;*&lt;/code&gt; в приведенном выше примере будет удален, поскольку он является частью комментария к документации, который разделен звездочками, поэтому вам нужно как минимум три последующие звездочки.</target>
        </trans-unit>
        <trans-unit id="ac7e95e21d2700c2e5e4f32e9e7f466df23faf33" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; there are 2 overloads - one with a format string, the other one with a user defined functor.</source>
          <target state="translated">Как и в случае &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; ,&lt;/a&gt; существует 2 перегрузки: одна со строкой форматирования, другая с определенным пользователем функтором.</target>
        </trans-unit>
        <trans-unit id="4799d67b11d550709cf6847100b2162c1067dd7e" translate="yes" xml:space="preserve">
          <source>As with any global resource, setting &lt;code&gt;theAllocator&lt;/code&gt; and &lt;code&gt;processAllocator&lt;/code&gt; should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.  To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using &lt;code&gt;theAllocator&lt;/code&gt; for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:</source>
          <target state="translated">Как с любым глобальным ресурсом, установка &lt;code&gt;theAllocator&lt;/code&gt; и &lt;code&gt;processAllocator&lt;/code&gt; не должна выполняться часто и случайно. В частности, выделение памяти одним распределителем и освобождение другого вызывает неопределенное поведение. Как правило, эти переменные устанавливаются на этапе инициализации приложения и сохраняются в приложении. Чтобы избежать этого, долгоживущие объекты, которые должны выполнять распределения, перераспределения и освобождения относительно часто, могут захотеть сохранить ссылку на объект-распределитель, который они используют в течение всей своей жизни. Затем вместо использования &lt;code&gt;theAllocator&lt;/code&gt; для внутренних задач, связанных с распределением, они будут использовать внутреннюю ссылку. Например, рассмотрим пользовательскую хеш-таблицу:</target>
        </trans-unit>
        <trans-unit id="a187fce74f3c088795c6e5b47e1056e5126c0fae" translate="yes" xml:space="preserve">
          <source>Ask curl for its fd_set sets. The app can use these to select() or poll() on. We want curl_multi_perform() called as soon as one of them are ready.</source>
          <target state="translated">Задайте curl для его наборов fd_set.Приложение может использовать их для select()или poll()on.Мы хотим,чтобы функция curl_multi_perform()вызывалась,как только один из них будет готов.</target>
        </trans-unit>
        <trans-unit id="407c3cb45f2c60add113bb40a5a457b3e7b28548" translate="yes" xml:space="preserve">
          <source>Ask the multi handle if there's any messages/informationals from the individual transfers. Messages include informationals such as error code from the transfer or just the fact that a transfer is completed. More details on these should be written down as well.</source>
          <target state="translated">Спросите у мультиручки,есть ли какие-нибудь сообщения/информация от отдельных переводов.Сообщения включают в себя такую информацию,как код ошибки от перевода или просто тот факт,что перевод завершен.Более подробная информация об этом также должна быть записана.</target>
        </trans-unit>
        <trans-unit id="00a0f49dff6a5c0c910755166ec70967a98d46e8" translate="yes" xml:space="preserve">
          <source>Asm Statement</source>
          <target state="translated">Заявление Асма</target>
        </trans-unit>
        <trans-unit id="1afc7a2cc88dee030813b66323a3af633b890e22" translate="yes" xml:space="preserve">
          <source>Asm instruction</source>
          <target state="translated">Asm-инструкция</target>
        </trans-unit>
        <trans-unit id="790208a1b6c1cdd2c13b57adc90b509e7d203c6c" translate="yes" xml:space="preserve">
          <source>Asm instructions are terminated by a ;, not by an end of line.</source>
          <target state="translated">Asm-инструкции заканчиваются на a ;,а не на конец строки.</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="translated">заявление Асма</target>
        </trans-unit>
        <trans-unit id="90e6cfa22a58ec4314abe99303529bc30df1cd45" translate="yes" xml:space="preserve">
          <source>AsmStatement</source>
          <target state="translated">AsmStatement</target>
        </trans-unit>
        <trans-unit id="7c9be4e0207ca69f4c35ec2cd41e7f07aef7a2ef" translate="yes" xml:space="preserve">
          <source>Assemble &lt;code&gt;values&lt;/code&gt; into a range that carries all its elements in-situ.</source>
          <target state="translated">Соберите &lt;code&gt;values&lt;/code&gt; в диапазон, который несет все его элементы на месте.</target>
        </trans-unit>
        <trans-unit id="c617a006ef306c30de2e4c3a12d2334fbba7a9af" translate="yes" xml:space="preserve">
          <source>Assembler instructions can be labeled just like other statements. They can be the target of goto statements. For example:</source>
          <target state="translated">Инструкции по сборке могут быть обозначены так же,как и другие утверждения.Они могут быть мишенью для высказываний goto.Например:</target>
        </trans-unit>
        <trans-unit id="e421bc1f45d2b482fe2ff716000545e5646f7277" translate="yes" xml:space="preserve">
          <source>Assembler instructions must be located inside an &lt;code&gt;asm&lt;/code&gt; block. Like functions, &lt;code&gt;asm&lt;/code&gt; statements must be anotated with adequate function attributes to be compatible with the caller. Asm statements attributes must be explicitly defined, they are not infered.</source>
          <target state="translated">Инструкции ассемблера должны быть расположены внутри &lt;code&gt;asm&lt;/code&gt; блока. Как и функции, операторы &lt;code&gt;asm&lt;/code&gt; должны быть аннотированы соответствующими атрибутами функции, чтобы быть совместимыми с вызывающей стороной. Атрибуты asm-операторов должны быть явно определены, они не выводятся.</target>
        </trans-unit>
        <trans-unit id="714e45eb8c405fbdb34a796120ab67c6ae2d72b9" translate="yes" xml:space="preserve">
          <source>Assembling Your Own Allocator</source>
          <target state="translated">Сборка собственного Распределителя</target>
        </trans-unit>
        <trans-unit id="b52465945f6ab45ca943fa9fa1e9d738eca2cc3b" translate="yes" xml:space="preserve">
          <source>Assert Contract</source>
          <target state="translated">Утверждать договор</target>
        </trans-unit>
        <trans-unit id="881c910749065a58abd709f4221af38a82fabadc" translate="yes" xml:space="preserve">
          <source>Assert Expressions</source>
          <target state="translated">Утверждать выражения</target>
        </trans-unit>
        <trans-unit id="c7a5b9464524d049c6fe8ff66c5b2bdc7b543fff" translate="yes" xml:space="preserve">
          <source>Assert Failure</source>
          <target state="translated">Утвердить о неудаче</target>
        </trans-unit>
        <trans-unit id="d7d72241e6b5848e305187f74df13930409f541f" translate="yes" xml:space="preserve">
          <source>Assert checks.</source>
          <target state="translated">Проверяйте.</target>
        </trans-unit>
        <trans-unit id="843aa1baaf4b9511699ef763eb98fe79f5099f70" translate="yes" xml:space="preserve">
          <source>Assert failure functions in the GLIBC library.</source>
          <target state="translated">Утверждать функции сбоя в библиотеке GLIBC.</target>
        </trans-unit>
        <trans-unit id="94e6ce29a6460dbe0c0daaaab648acdb3c2883d7" translate="yes" xml:space="preserve">
          <source>AssertExpression</source>
          <target state="translated">AssertExpression</target>
        </trans-unit>
        <trans-unit id="a422512dc44cc15063776e77a81a3f8e6eb0d6de" translate="yes" xml:space="preserve">
          <source>AssertExpressions</source>
          <target state="translated">AssertExpressions</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="2f19e0385b8f9d7c5a7eb86bb2c7ba5f0e720900" translate="yes" xml:space="preserve">
          <source>Asserts that the given condition is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Утверждает, что данное условие &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="120daecc558f73b157187685546d1c314c351c50" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression does</source>
          <target state="translated">Утверждает,что данное выражение</target>
        </trans-unit>
        <trans-unit id="bba2525f9e139559b132642a96447978bab43209" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression throws the given type of &lt;code&gt;Throwable&lt;/code&gt;. The &lt;code&gt;Throwable&lt;/code&gt; is caught and does not escape assertThrown. However, any other &lt;code&gt;Throwable&lt;/code&gt;s</source>
          <target state="translated">Утверждает, что данное выражение &lt;code&gt;Throwable&lt;/code&gt; данный тип Throwable . &lt;code&gt;Throwable&lt;/code&gt; перехватывается и не избежать assertThrown. Тем не менее, любой другой &lt;code&gt;Throwable&lt;/code&gt; с</target>
        </trans-unit>
        <trans-unit id="17e81c7a1f671e7e24608f38c1a74f6ff4e02c7b" translate="yes" xml:space="preserve">
          <source>Assign Expressions</source>
          <target state="translated">Назначить выражения</target>
        </trans-unit>
        <trans-unit id="7f86ed464704ba1c6b681ec2726c5fbeefb20008" translate="yes" xml:space="preserve">
          <source>Assign a value to the current thread's instance. This function has the same caveats as its overload.</source>
          <target state="translated">Присваивать значение экземпляру текущего потока.Эта функция имеет те же предостережения,что и ее перегрузка.</target>
        </trans-unit>
        <trans-unit id="76d3ba357057c554bcbcf6a7822d736c1e09e3bc" translate="yes" xml:space="preserve">
          <source>AssignExpression</source>
          <target state="translated">AssignExpression</target>
        </trans-unit>
        <trans-unit id="365e967e191a82b0dfa667724d9ef332e0565a97" translate="yes" xml:space="preserve">
          <source>Assigned to each element of range</source>
          <target state="translated">Присваивается каждому элементу диапазона</target>
        </trans-unit>
        <trans-unit id="2490af57d4237289ce473c7f9d5d5a7e29bbba7a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Expressions</source>
          <target state="translated">Выражения оператора назначения</target>
        </trans-unit>
        <trans-unit id="eda4293e36885d0479c5dae22502b3085be9643a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Overloading</source>
          <target state="translated">Перегрузка оператора</target>
        </trans-unit>
        <trans-unit id="3bf524ec3b928fa7a8316d5c4f46f6427bafeb2e" translate="yes" xml:space="preserve">
          <source>Assignment from another &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">Задание из другого &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad22a9ad0d4f785e89bbd9df67b80efd310fb186" translate="yes" xml:space="preserve">
          <source>Assignment from another BigInt.</source>
          <target state="translated">Назначение от другого крупного игрока.</target>
        </trans-unit>
        <trans-unit id="c734c417d0433b21b0c33224a47f994821944ee9" translate="yes" xml:space="preserve">
          <source>Assignment from built-in integer types.</source>
          <target state="translated">Присваивание из встроенных целочисленных типов.</target>
        </trans-unit>
        <trans-unit id="a2c6b545c0015432c32a5f8afe451255b5b743ef" translate="yes" xml:space="preserve">
          <source>Assignment helper functions</source>
          <target state="translated">Назначение вспомогательных функций</target>
        </trans-unit>
        <trans-unit id="84aa2531d79787134c4a3ba8faa799337584a358" translate="yes" xml:space="preserve">
          <source>Assignment operator. Has the same constraints as the constructor.</source>
          <target state="translated">Назначение оператора.Имеет те же ограничения,что и конструктор.</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">Назначивающие операторы</target>
        </trans-unit>
        <trans-unit id="99b05821addb139efb582d5733eb165057e45a88" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;super&lt;/code&gt; is not allowed.</source>
          <target state="translated">Назначение на &lt;code&gt;super&lt;/code&gt; не допускается.</target>
        </trans-unit>
        <trans-unit id="d46d956c7065444efb33c5f5602fe16eab572e8a" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;this&lt;/code&gt; is not allowed.</source>
          <target state="translated">Назначение на &lt;code&gt;this&lt;/code&gt; не допускается.</target>
        </trans-unit>
        <trans-unit id="ac9f4d1b12010a7c21b70ea99324f1a0dd8bcccd" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the first element of the container.</source>
          <target state="translated">Назначает &lt;code&gt;v&lt;/code&gt; первому элементу контейнера.</target>
        </trans-unit>
        <trans-unit id="922d6285649b37db600cf15c96dc723863c5afe5" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the last element of the container.</source>
          <target state="translated">Назначает &lt;code&gt;v&lt;/code&gt; последнему элементу контейнера.</target>
        </trans-unit>
        <trans-unit id="9af0d121c1f00202f8eb1627dd5494f59fbf6800" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to each element of input range &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Назначает &lt;code&gt;value&lt;/code&gt; каждому элементу диапазона входного &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5f7c4ee9f81cf1e0b7f9cbc458913458f588507" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state.</source>
          <target state="translated">Присваивает &lt;code&gt;value&lt;/code&gt; внутренне удерживаемому состоянию.</target>
        </trans-unit>
        <trans-unit id="21c3bd56c75643c04bab89ad011aec98a36c3a16" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null.</source>
          <target state="translated">Присваивает &lt;code&gt;value&lt;/code&gt; внутренне удерживаемому состоянию. Если назначение выполнено успешно, &lt;code&gt;this&lt;/code&gt; становится ненулевым.</target>
        </trans-unit>
        <trans-unit id="8d0fc7c17a3a2b5f1514756ed138007924a3a66a" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null. No null checks are made. Note that the assignment may leave &lt;code&gt;this&lt;/code&gt; in the null state.</source>
          <target state="translated">Присваивает &lt;code&gt;value&lt;/code&gt; внутренне удерживаемому состоянию. Если назначение выполнено успешно, &lt;code&gt;this&lt;/code&gt; становится ненулевым. Нулевые проверки не выполняются. Обратите внимание, что назначение может оставить &lt;code&gt;this&lt;/code&gt; в нулевом состоянии.</target>
        </trans-unit>
        <trans-unit id="5b359bc586830b69163a1e75c910372bb60f5dad" translate="yes" xml:space="preserve">
          <source>Assigns a &lt;code&gt;VariantN&lt;/code&gt; from a generic argument. Statically rejects disallowed types.</source>
          <target state="translated">Назначает &lt;code&gt;VariantN&lt;/code&gt; из общего аргумента. Статически отклоняет запрещенные типы.</target>
        </trans-unit>
        <trans-unit id="44eb8314103f2fdd05abf9443854b7e8c14d4780" translate="yes" xml:space="preserve">
          <source>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</source>
          <target state="translated">Назначает файл другому.Цель назначения отделяется от того файла,к которому он был прикреплен,и прикрепляется к новому файлу.</target>
        </trans-unit>
        <trans-unit id="057b5aa3c0ad5c43ab19d19f8ce9f6db63dca13d" translate="yes" xml:space="preserve">
          <source>Assigns a logical thread to execute the supplied op.</source>
          <target state="translated">Назначает логический поток для выполнения поставленной задачи.</target>
        </trans-unit>
        <trans-unit id="5425da91b2931a4dd8cdec7b13e0afa9866f1762" translate="yes" xml:space="preserve">
          <source>Assigns the given &lt;code&gt;value&lt;/code&gt; to the environment variable with the given &lt;code&gt;name&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is null the variable is removed from environment.</source>
          <target state="translated">Присваивает данное &lt;code&gt;value&lt;/code&gt; переменной среды с заданным &lt;code&gt;name&lt;/code&gt; . Если &lt;code&gt;value&lt;/code&gt; равно нулю, переменная удаляется из окружения.</target>
        </trans-unit>
        <trans-unit id="a6b3ed4789854a21da3d57b64bb5165df47849f8" translate="yes" xml:space="preserve">
          <source>Assigns to the &lt;code&gt;n&lt;/code&gt;th element in the composite range. Defined if all ranges offer random access.</source>
          <target state="translated">Назначает &lt;code&gt;n&lt;/code&gt; - й элемент в составном диапазоне. Определяется, если все диапазоны предлагают произвольный доступ.</target>
        </trans-unit>
        <trans-unit id="a41d06f6960668b2b925acd3bf255f8df4491e62" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteral</source>
          <target state="translated">AssocArrayLiteral</target>
        </trans-unit>
        <trans-unit id="5a9bcf3e687e72baa7a855ea1562aeb0b0f6c922" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c12f36c1b476d37e1b0680000a7ced07747bab" translate="yes" xml:space="preserve">
          <source>Associate a local address with this socket.</source>
          <target state="translated">Соедините местный адрес с этим гнездом.</target>
        </trans-unit>
        <trans-unit id="6fdc76eca25e9805145ab4faa10fd711ec8e7f73" translate="yes" xml:space="preserve">
          <source>Associates name with tid in a process-local map. When the thread represented by tid terminates, any names associated with it will be automatically unregistered.</source>
          <target state="translated">Название ассоциируется с &quot;tid&quot; на карте процессингового центра.Когда поток,представленный tid,завершает свою работу,любые связанные с ним имена будут автоматически незарегистрированы.</target>
        </trans-unit>
        <trans-unit id="d00bb7dcc304b2d3b149b7f7680cc932d7d86d19" translate="yes" xml:space="preserve">
          <source>Associates name with tid.</source>
          <target state="translated">Имя партнера ассоциируется с &quot;Тид&quot;.</target>
        </trans-unit>
        <trans-unit id="33ed59cb9cc5ad4f51c71cb705b6c66305c4ea95" translate="yes" xml:space="preserve">
          <source>Associative Array Example: counting Tuples</source>
          <target state="translated">Пример ассоциативного массива:подсчет кортежей</target>
        </trans-unit>
        <trans-unit id="66110798d937132b8b4c69b6c86f490e42147357" translate="yes" xml:space="preserve">
          <source>Associative Array Example: word count</source>
          <target state="translated">Пример ассоциативного массива:количество слов</target>
        </trans-unit>
        <trans-unit id="62a00c8d718bd407e11a04d361c97fd9304d9228" translate="yes" xml:space="preserve">
          <source>Associative Array Literals</source>
          <target state="translated">Буквы ассоциативного массива</target>
        </trans-unit>
        <trans-unit id="8cd02aabb1cb92301b44ecacb4a3476fbc048ed6" translate="yes" xml:space="preserve">
          <source>Associative Array Properties</source>
          <target state="translated">Свойства ассоциативного массива</target>
        </trans-unit>
        <trans-unit id="ac6bb05c1566d531b5e617bff01417f7eeacaa8d" translate="yes" xml:space="preserve">
          <source>Associative Arrays</source>
          <target state="translated">Ассоциированные массивы</target>
        </trans-unit>
        <trans-unit id="eac66f094196ab59907d539af93b0f79d61ccbc4" translate="yes" xml:space="preserve">
          <source>Associative array indexed by the name of each member of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a88997c71f98db7849444ee105aa1b9e104461" translate="yes" xml:space="preserve">
          <source>Associative array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">Буквальный ассоциативный массив будет выделен на куче GC.Проверьте его элементы,чтобы убедиться,что любой из них выйдет из кучи.</target>
        </trans-unit>
        <trans-unit id="2cdd3f26aaf9ed2ca50e34f9cba8cec0e214e787" translate="yes" xml:space="preserve">
          <source>Associative array literals</source>
          <target state="translated">Буквы ассоциативного массива</target>
        </trans-unit>
        <trans-unit id="aa59b9862478a41dd5f1d43314d8d4fd2f36cfac" translate="yes" xml:space="preserve">
          <source>Associative array literals are a comma-separated list of</source>
          <target state="translated">Буквы ассоциативного массива представляют собой разделенный запятыми список из</target>
        </trans-unit>
        <trans-unit id="f1464f4beecb9ccd1b6cd79f0d3fdebe26677ef6" translate="yes" xml:space="preserve">
          <source>Associative array of attributes</source>
          <target state="translated">Ассоциированный массив атрибутов</target>
        </trans-unit>
        <trans-unit id="b87ce9bf0d9a5c06c6d7bc4fc73a4cd816351837" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is converted by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3256b0ab3483fa8604ecf1ce16a782f56f85d2" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is printed by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">Ассоциативный преобразование массива в строку. Каждый элемент печатается путем вызова &lt;code&gt;to!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eed25868a22de24520441116395f69e925a6704" translate="yes" xml:space="preserve">
          <source>Associative array with all archive members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cf74a282aed4f93bc7369a99f5541139720753" translate="yes" xml:space="preserve">
          <source>Associative arrays</source>
          <target state="translated">Ассоциированные массивы</target>
        </trans-unit>
        <trans-unit id="b7b195035b64b57f923bdef12ca24604e56d713e" translate="yes" xml:space="preserve">
          <source>Associative arrays are declared by placing the</source>
          <target state="translated">Ассоциированные массивы декларируются путем размещения</target>
        </trans-unit>
        <trans-unit id="e2e6b379c645fab1d146e1f88662672372565c42" translate="yes" xml:space="preserve">
          <source>Associative arrays are formatted by using &lt;code&gt;':'&lt;/code&gt; and &lt;code&gt;&quot;, &quot;&lt;/code&gt; as separators, and enclosed by &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;.</source>
          <target state="translated">Ассоциативные массивы форматируются с использованием &lt;code&gt;':'&lt;/code&gt; и &lt;code&gt;&quot;, &quot;&lt;/code&gt; качестве разделителей и заключаются в &lt;code&gt;'['&lt;/code&gt; и &lt;code&gt;']'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="578b6958d55efc32eb2164f95c40c985b159a3d3" translate="yes" xml:space="preserve">
          <source>Associative arrays are initialized to having 0 elements.</source>
          <target state="translated">Ассоциированные массивы инициализируются до 0 элементов.</target>
        </trans-unit>
        <trans-unit id="1f9ac76e68b33aa5367eaec796765ac41035935d" translate="yes" xml:space="preserve">
          <source>Associative arrays are returned in EAX.</source>
          <target state="translated">Ассоциированные массивы возвращаются в EAX.</target>
        </trans-unit>
        <trans-unit id="5ca5da5a3d3a14509f014f2f90e91f3a2f1bc8b9" translate="yes" xml:space="preserve">
          <source>Associative arrays consist of a pointer to an opaque, implementation defined type.</source>
          <target state="translated">Ассоциированные массивы состоят из указателя на непрозрачный,определяемый реализацией тип.</target>
        </trans-unit>
        <trans-unit id="4b7aaeec3338d91fc185c073ff6aea7f4aaaf1d1" translate="yes" xml:space="preserve">
          <source>Associative arrays have an index that is not necessarily an integer, and can be sparsely populated. The index for an associative array is called the</source>
          <target state="translated">Ассоциированные массивы имеют индекс,который не обязательно является целым числом и может быть малозаселенным.Индекс ассоциативного массива называется</target>
        </trans-unit>
        <trans-unit id="24b2b993b7d8aa8b139deca02db3001c61ba8f93" translate="yes" xml:space="preserve">
          <source>Associative arrays have unique keys. If r contains duplicate keys, then the result will contain the value of the last pair for that key in r.</source>
          <target state="translated">Ассоциированные массивы имеют уникальные ключи.Если r содержит дубликаты ключей,то результат будет содержать значение последней пары для этого ключа в r.</target>
        </trans-unit>
        <trans-unit id="7140c60dcf97eae1fd241925dc294e9b664ccf47" translate="yes" xml:space="preserve">
          <source>Associativity and Commutativity</source>
          <target state="translated">Ассоциация и Коммунальная деятельность</target>
        </trans-unit>
        <trans-unit id="d4afb493c09c81bc22adc7df22495a98eac06f94" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt;. Then &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; leaves &lt;code&gt;a&lt;/code&gt; unchanged and returns &lt;code&gt;false&lt;/code&gt;, whereas &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to refer to &lt;code&gt;&quot;ah&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Предположим, &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt; . Тогда &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; оставляет &lt;code&gt;a&lt;/code&gt; неизменной и возвращает &lt;code&gt;false&lt;/code&gt; , а &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; продвигает ссылаться на &lt;code&gt;&quot;ah&quot;&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c94a2c42cde8321b948dff42533f346ec9014aea" translate="yes" xml:space="preserve">
          <source>Assume that it is safe to append to this array. Appends made to this array after calling this function may append in place, even if the array was a slice of a larger array to begin with.</source>
          <target state="translated">Предположим,что к этому массиву безопасно добавляться.Приложения,сделанные к этому массиву после вызова этой функции,могут добавляться на месте,даже если для начала массив был срезом большего массива.</target>
        </trans-unit>
        <trans-unit id="3954f2a28b82752323144cbb88151e77e6d01da9" translate="yes" xml:space="preserve">
          <source>Assume the given array of integers &lt;code&gt;arr&lt;/code&gt; is a well-formed UTF string and return it typed as a UTF string.</source>
          <target state="translated">Предположим, что данный массив целых чисел &lt;code&gt;arr&lt;/code&gt; является правильно сформированной строкой UTF и вернет ее в виде строки UTF.</target>
        </trans-unit>
        <trans-unit id="51fef9f691908f559d18676822c2b16e9811cadf" translate="yes" xml:space="preserve">
          <source>Assume, that the range is sorted without checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46abda9a40531b5c7ab25b4f982669308c54d50" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e62b25f8e7aaa35a775d4bc9ee591164888166" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To keep the checking costs low, the cost is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) in release mode (no checks for sorted-ness are performed). In debug mode, a few random elements of &lt;code&gt;r&lt;/code&gt; are checked for sorted-ness. The size of the sample is proportional &amp;Omicron;(&lt;code&gt;log(r.length)&lt;/code&gt;). That way, checking has no effect on the complexity of subsequent operations specific to sorted ranges (such as binary search). The probability of an arbitrary unsorted range failing the test is very high (however, an almost-sorted range is likely to pass it). To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Предполагается, что &lt;code&gt;r&lt;/code&gt; отсортирован по предикату &lt;code&gt;pred&lt;/code&gt; и возвращает соответствующий &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; имеющий &lt;code&gt;r&lt;/code&gt; в качестве поддержки. Для поддержания низких затрат на проверку стоимость составляет &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) в режиме деблокирования (проверки на сортировку не выполняются). В режиме отладки несколько случайных элементов &lt;code&gt;r&lt;/code&gt; проверяются на сортировку. Размер образца пропорционален &amp;Omicron; ( &lt;code&gt;log(r.length)&lt;/code&gt; ). Таким образом, проверка не влияет на сложность последующих операций, специфичных для отсортированных диапазонов (таких как бинарный поиск). Вероятность того, что произвольный несортированный диапазон не пройдёт тест, очень высока (однако, почти отсортированный диапазон, вероятно, пройдет его). Проверить отсортированность по стоимости &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; ), используйте &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt; &lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f92de52d34809fb9f9b5a422d22d2bd3f403b63b" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;T&lt;/code&gt; is an unqualified type, the graph below illustrates how qualifiers combine (combinations with &lt;code&gt;immutable&lt;/code&gt; are omitted). For each node, applying the qualifier labeling the edge leads to the resulting type.</source>
          <target state="translated">Предполагая, что &lt;code&gt;T&lt;/code&gt; является неквалифицированным типом, график ниже иллюстрирует, как объединяются квалификаторы (комбинации с &lt;code&gt;immutable&lt;/code&gt; опущены). Для каждого узла применение квалификатора, помечающего ребро, приводит к результирующему типу.</target>
        </trans-unit>
        <trans-unit id="317581a22ccf8624556bdb31509c5c5a51feef3f" translate="yes" xml:space="preserve">
          <source>Assuming that pages are laid out consequently in one array at &lt;code&gt;pages&lt;/code&gt;, the pseudo-code is:</source>
          <target state="translated">Предполагая, что страницы расположены последовательно в одном массиве на &lt;code&gt;pages&lt;/code&gt; , псевдокод:</target>
        </trans-unit>
        <trans-unit id="7bfdbbc84ee0d35091e2296c00a0a25e1c9d7c15" translate="yes" xml:space="preserve">
          <source>Assuming the file was at /example/test.d, this will output:</source>
          <target state="translated">Если предположить,что файл находился в /example/test.d,то будет выведен результат:</target>
        </trans-unit>
        <trans-unit id="4ade9724e5f6c8aea4d40d9c22982099c0a42498" translate="yes" xml:space="preserve">
          <source>Assuming the reverse meaning (i.e. &quot;ignoreTerminator&quot;) and inserting the wrong code compiles and runs with erroneous results.  After replacing the boolean parameter with an instantiation of &lt;code&gt;Flag&lt;/code&gt;, code calling &lt;code&gt;getLine&lt;/code&gt; can be easily read and understood even by people not fluent with the API:</source>
          <target state="translated">Принятие обратного значения (то есть &amp;laquo;ignoreTerminator&amp;raquo;) и вставка неправильного кода компилируется и запускается с ошибочными результатами. После замены логического параметра на экземпляр класса &lt;code&gt;Flag&lt;/code&gt; , вызывающий &lt;code&gt;getLine&lt;/code&gt; , можно легко прочитать и понять даже людям, не владеющим API:</target>
        </trans-unit>
        <trans-unit id="8b593995c88f61a609044a01e37e8e4ccc22e065" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
          <target state="translated">Assumptions</target>
        </trans-unit>
        <trans-unit id="875a558108f6180c117cd2a9851fbd31bf1ad357" translate="yes" xml:space="preserve">
          <source>At Least Alias</source>
          <target state="translated">По крайней мере,псевдоним</target>
        </trans-unit>
        <trans-unit id="319fc7f766d3014146f622cd42e082b9d29acc59" translate="yes" xml:space="preserve">
          <source>At any point in the program, for each memory object, there is exactly one live mutable pointer to it or all the live pointers to it are read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5e7ce73794fbffd33597afe29e6656f7606b48" translate="yes" xml:space="preserve">
          <source>At least one return statement, throw statement, or assert(0) expression is required if the function specifies a return type that is not void, unless the function contains inline assembler code.</source>
          <target state="translated">По крайней мере один оператор возврата,оператор throw или выражение assert(0)требуется,если функция указывает тип возврата,который не является непустым,если только функция не содержит встроенный ассемблерный код.</target>
        </trans-unit>
        <trans-unit id="90d61c89ed43af9a321f3f7948cd37fb3078855e" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. &lt;code&gt;Zip&lt;/code&gt; offers the lowest range facilities of all components, e.g. it offers random access iff all ranges offer random access, and also offers mutation and swapping if all ranges offer it. Due to this, &lt;code&gt;Zip&lt;/code&gt; is extremely powerful because it allows manipulating several ranges in lockstep.</source>
          <target state="translated">Как минимум, входной диапазон. &lt;code&gt;Zip&lt;/code&gt; предлагает средства наименьшего диапазона из всех компонентов, например, он предлагает произвольный доступ, если все диапазоны предлагают произвольный доступ, а также предлагает мутацию и обмен, если все диапазоны предлагают его. Благодаря этому &lt;code&gt;Zip&lt;/code&gt; чрезвычайно мощный, потому что он позволяет манипулировать несколькими диапазонами в шаге.</target>
        </trans-unit>
        <trans-unit id="bf82744118a56dc50e99bed95e0674d739012373" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. All other range primitives are given in the resulting range if &lt;code&gt;range&lt;/code&gt; has them. The exceptions are the bidirectional primitives, which are propagated only if &lt;code&gt;range&lt;/code&gt; has length.</source>
          <target state="translated">Как минимум, входной диапазон. Все остальные примитивы диапазона даются в результирующем диапазоне, если они есть в &lt;code&gt;range&lt;/code&gt; . Исключением являются двунаправленные примитивы, которые распространяются только в том случае, если &lt;code&gt;range&lt;/code&gt; имеет длину.</target>
        </trans-unit>
        <trans-unit id="e9641b92bdebc39e62f8119a95b586fda5bb953c" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. If the range offers random access and &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt; offers them as well.</source>
          <target state="translated">Как минимум, входной диапазон. Если предложения диапазон случайного доступа и &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;take&lt;/code&gt; предложения и их.</target>
        </trans-unit>
        <trans-unit id="b4f8bcff8fd004d35539b31be3e23eec00e83071" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. Range primitives such as bidirectionality and random access are given if the element type of &lt;code&gt;rr&lt;/code&gt; provides them.</source>
          <target state="translated">Как минимум, входной диапазон. Примитивы диапазона, такие как двунаправленность и произвольный доступ, даются, если их предоставляет тип элемента &lt;code&gt;rr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab81f7243697f45d24e88eac476807c5bafc54c5" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. The resulting range will adopt the range primitives of the underlying range as long as &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Как минимум, входной диапазон. Результирующий диапазон примет примитивы диапазона базового диапазона, если &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13e0cdc536d3ebf98a18c0bc6152dede0a930dcf" translate="yes" xml:space="preserve">
          <source>At offset index into buffer, create nbytes of space by shifting upwards all data past index.</source>
          <target state="translated">При индексе смещения в буфер,создайте nbytes пространства,сдвигая вверх все данные прошлого индекса.</target>
        </trans-unit>
        <trans-unit id="1427d1990cebaf6b24e9781e5fa4c566cf53ece6" translate="yes" xml:space="preserve">
          <source>At present, C++ exceptions cannot be caught in or thrown from D, and D exceptions cannot be caught in or thrown from C++. Additionally, objects in C++ stack frames are not guaranteed to be destroyed when unwinding the stack due to a D exception, and vice versa.</source>
          <target state="translated">В настоящее время исключения из C++не могут быть пойманы или брошены из D,а исключения из D не могут быть пойманы или брошены из C++.Кроме того,объекты в кадрах стека C++не гарантированно уничтожаются при разматывании стека из-за исключения из D,и наоборот.</target>
        </trans-unit>
        <trans-unit id="8d76f9b99e41b5780a5b8aa58882552e760fb6a3" translate="yes" xml:space="preserve">
          <source>Atomically adds &lt;code&gt;mod&lt;/code&gt; to the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79117be4a561837c4e341dc958c03f4b3575dace" translate="yes" xml:space="preserve">
          <source>Atomically increment the current count by one. This will notify one waiter, if there are any in the queue.</source>
          <target state="translated">Атоматически увеличивает текущий счет на единицу.Это уведомит одного официанта,если он есть в очереди.</target>
        </trans-unit>
        <trans-unit id="0e72ffed036979247fd717525ebb223918c99bbc" translate="yes" xml:space="preserve">
          <source>Atomically subtracts &lt;code&gt;mod&lt;/code&gt; from the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">Попытка освободить кучу памяти</target>
        </trans-unit>
        <trans-unit id="2d4188d946f5310d84944e1cbc16ca3404e12f5e" translate="yes" xml:space="preserve">
          <source>Attempt to write a readonly database</source>
          <target state="translated">Попытка написать доступную только для чтения базу данных</target>
        </trans-unit>
        <trans-unit id="bad2e7923396bd94563de54c8743dd18ec710863" translate="yes" xml:space="preserve">
          <source>Attempting to read a non-existent file.</source>
          <target state="translated">Попытка прочитать несуществующий файл.</target>
        </trans-unit>
        <trans-unit id="cfc72cd8439fa8fc0153768ece769b118903087b" translate="yes" xml:space="preserve">
          <source>Attempting to write to a read-only file.</source>
          <target state="translated">Попытка записи в файл,доступный только для чтения.</target>
        </trans-unit>
        <trans-unit id="f3bc6684b273ddb5150c8f76dec58669641f537c" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619f7dc21d7be2451ba09a0a31590c696e32ea77" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">Попытки получить считывающий замок на вложенном мьютексе.Если его можно получить без блокировки,то блокировка приобретается и возвращается true.Если нет,то замок не приобретается и возвращается false.</target>
        </trans-unit>
        <trans-unit id="3953627ccf0b01ecfcf23b7ad87c26a8060eafac" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640457600821a8df2d538564c057e12d520f4905" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">Попытки приобрести замок на вложенный мьютекс.Если его можно получить без блокировки,то блокировка приобретается и возвращается true.Если нет,то замок не приобретается и возвращается false.</target>
        </trans-unit>
        <trans-unit id="3b9757d22891fdb7b2db7ae0d5e59794d8111018" translate="yes" xml:space="preserve">
          <source>Attempts to cast Object o to class c. Returns o if successful, null if not.</source>
          <target state="translated">Попытки привести Объект o к классу c.Возвращает o,если успешно,ноль,если нет.</target>
        </trans-unit>
        <trans-unit id="fb9f33e63583d791ce38087ee972da2a9a91218e" translate="yes" xml:space="preserve">
          <source>Attempts to lock the specified file segment. If both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are zero, the entire file is locked.</source>
          <target state="translated">Попытки заблокировать указанный сегмент файла. Если и &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;length&lt;/code&gt; равны нулю, весь файл блокируется.</target>
        </trans-unit>
        <trans-unit id="25ad0c35f575b740f4d561c41e13284745953ceb" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host address as a human-readable string.</source>
          <target state="translated">Попытки получить адрес хоста в виде человекочитаемой строки.</target>
        </trans-unit>
        <trans-unit id="0ee6b4fbb8496cdc7d0620d9b9ed398b895a55e3" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host name as a fully qualified domain name.</source>
          <target state="translated">Попытки получить имя хоста как полное доменное имя.</target>
        </trans-unit>
        <trans-unit id="2288a588beafb785ffe5d4183be649edf540fac4" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the numeric port number as a string.</source>
          <target state="translated">Попытки получить номер цифрового порта в виде строки.</target>
        </trans-unit>
        <trans-unit id="f6c4cea55c8d840b0fc77f72a5e89fc5d0c7b734" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the service name as a string.</source>
          <target state="translated">Попытки получить имя сервиса в виде строки.</target>
        </trans-unit>
        <trans-unit id="06a30d499359e73aad911822ebc036ba5b33b771" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the process associated with &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Пытается завершить процесс, связанный с &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e521b72cd060c4862399350be7113a0bf337401" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution typing global memory. For example, if you pre-allocate memory in the DATA/TLS segment and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">Внимание: для включения точного сканирования требуется немного больше осторожности при наборе глобальной памяти. Например, если вы предварительно выделяете память в сегменте DATA / TLS, а затем добавляете экземпляр объекта со ссылками на другие выделения в эту память, вы не должны использовать базовые целочисленные типы для резервирования пространства. Это приведет к тому, что сборщик мусора не обнаружит ссылки. Вместо этого используйте тип массива, который будет сканировать эту область консервативно. Использование &lt;code&gt;void*&lt;/code&gt; обычно является наилучшим вариантом, поскольку оно также обеспечивает правильное выравнивание для указателей, сканируемых GC.</target>
        </trans-unit>
        <trans-unit id="435469686dcf93332d214d0927042b6ab70eb76c" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution with type declarations. For example, if you reserve a buffer as part of a struct and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">Внимание: для обеспечения точного сканирования требуется немного больше осторожности с объявлениями типов. Например, если вы резервируете буфер как часть структуры, а затем добавляете экземпляр объекта со ссылками на другие выделения в эту память, вы не должны использовать базовые целочисленные типы для резервирования пространства. Это приведет к тому, что сборщик мусора не обнаружит ссылки. Вместо этого используйте тип массива, который будет сканировать эту область консервативно. Использование &lt;code&gt;void*&lt;/code&gt; обычно является наилучшим вариантом, поскольку оно также обеспечивает правильное выравнивание для указателей, сканируемых GC.</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="563889efc6708465a0f8d7b13b7a64dc9449be63" translate="yes" xml:space="preserve">
          <source>Attribute inference is not done for other functions, even if the function body is present.</source>
          <target state="translated">Атрибутивный вывод не делается для других функций,даже если тело функции присутствует.</target>
        </trans-unit>
        <trans-unit id="fde0c64566e4280899df7f71f529a9c5822593d2" translate="yes" xml:space="preserve">
          <source>Attributed Unittests</source>
          <target state="translated">Назначенные юнит-тесты</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="3566d57f396227b960696c7c5f730c9617ce2ae9" translate="yes" xml:space="preserve">
          <source>Attributes are a way to modify one or more declarations. The general forms are:</source>
          <target state="translated">Атрибуты-это способ изменить одну или несколько деклараций.Общие формы:</target>
        </trans-unit>
        <trans-unit id="caa5510657413031ecde7637769e34ce12f05928" translate="yes" xml:space="preserve">
          <source>Attributes as obtained by &lt;a href=&quot;std_file#getAttributes&quot;&gt;&lt;code&gt;std.file.getAttributes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_file#DirEntry.attributes&quot;&gt;&lt;code&gt;std.file.DirEntry.attributes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a118fa9a5b31a61d074da7d6149cfba22d1f3ad" translate="yes" xml:space="preserve">
          <source>Authentication method as specified in &lt;a href=&quot;#AuthMethod&quot;&gt;&lt;code&gt;AuthMethod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Метод аутентификации, указанный в &lt;a href=&quot;#AuthMethod&quot;&gt; &lt;code&gt;AuthMethod&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1033f15759fcb47c36fb8ab321053fc3f1eca814" translate="yes" xml:space="preserve">
          <source>Authentication method equal to &lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt;&lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Метод аутентификации равен &lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt; &lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="66d5524bc6e9a905bcd8ad67ae1eb457c570b564" translate="yes" xml:space="preserve">
          <source>Authorization denied</source>
          <target state="translated">В разрешении отказано</target>
        </trans-unit>
        <trans-unit id="96526fc6efe098c9c6df94252412831b9ccb9466" translate="yes" xml:space="preserve">
          <source>Authors:</source>
          <target state="translated">Authors:</target>
        </trans-unit>
        <trans-unit id="ce0159a5518bc584a9e41b4b2690ef154fde135a" translate="yes" xml:space="preserve">
          <source>Auto Functions</source>
          <target state="translated">Автоматические функции</target>
        </trans-unit>
        <trans-unit id="cac7a53f813ead2d8559f8bf1f813c3742d1564d" translate="yes" xml:space="preserve">
          <source>Auto Ref Functions</source>
          <target state="translated">Автоматические функции</target>
        </trans-unit>
        <trans-unit id="5437bd3930e7f40ca7893e40f97b38d23c03f5fa" translate="yes" xml:space="preserve">
          <source>Auto functions have their return type inferred from any &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body.</source>
          <target state="translated">Авто функции имеют свой тип возврата, выведенный из любых &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt; s в теле функции.</target>
        </trans-unit>
        <trans-unit id="cec7110add8230fd3e3cee4a6982476165507102" translate="yes" xml:space="preserve">
          <source>Auto ref function can have explicit return type.</source>
          <target state="translated">Функция Auto ref может иметь явный тип возврата.</target>
        </trans-unit>
        <trans-unit id="1c98218626b244980716cf56d4d67cef842f3ffa" translate="yes" xml:space="preserve">
          <source>Auto ref functions infer their return type just as &lt;a href=&quot;#auto-functions&quot;&gt;auto functions&lt;/a&gt; do. In addition, they become &lt;a href=&quot;#ref-functions&quot;&gt;ref functions&lt;/a&gt; if all return expressions are lvalues, and it would not be a reference to a local or a parameter.</source>
          <target state="translated">Автореф-функции выводят свой тип возврата так же, как и &lt;a href=&quot;#auto-functions&quot;&gt;авто-функции&lt;/a&gt; . Кроме того, они становятся &lt;a href=&quot;#ref-functions&quot;&gt;функциями ref,&lt;/a&gt; если все возвращаемые выражения являются lvalues, и это не будет ссылкой на локальный элемент или параметр.</target>
        </trans-unit>
        <trans-unit id="72dbdd4328b363da1dc721bef13390d325cb449b" translate="yes" xml:space="preserve">
          <source>Auto ref parameters can be combined with auto ref return attributes:</source>
          <target state="translated">Параметры автоматического возврата ссылок могут быть объединены с атрибутами автоматического возврата ссылок:</target>
        </trans-unit>
        <trans-unit id="b60c388599c6393e9a67e964a642ad91629c903e" translate="yes" xml:space="preserve">
          <source>Auto start with constructor.</source>
          <target state="translated">Автоматический запуск с конструктором.</target>
        </trans-unit>
        <trans-unit id="efe7dcdfb00b164478f91903b1de63b3b45e9d2f" translate="yes" xml:space="preserve">
          <source>Auto-initialize the object</source>
          <target state="translated">Авто-инициализировать объект</target>
        </trans-unit>
        <trans-unit id="9d4560b6ff607cd4aecb5b5ff67e03b10904f66c" translate="yes" xml:space="preserve">
          <source>Autodecoding is enabled if this is set to true.</source>
          <target state="translated">Автодекодирование включено,если установлено значение true.</target>
        </trans-unit>
        <trans-unit id="360d06366226a26ec284df57dde94213ed2f94dc" translate="yes" xml:space="preserve">
          <source>Automatic input/output redirection using pipes</source>
          <target state="translated">Автоматическое перенаправление входа/выхода с помощью труб</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">Автоматически загружать статически сцепленные удлинители</target>
        </trans-unit>
        <trans-unit id="d2178e65328973816c4ca61d0183a96480a9ed99" translate="yes" xml:space="preserve">
          <source>Available GC options are:</source>
          <target state="translated">Доступны варианты GC:</target>
        </trans-unit>
        <trans-unit id="e14fc18612f34181b225bea7665a50b7b0f96761" translate="yes" xml:space="preserve">
          <source>Available output formats:</source>
          <target state="translated">Доступные выходные форматы:</target>
        </trans-unit>
        <trans-unit id="063d4770adfbdb2cd75f5fde3c562c12c1713762" translate="yes" xml:space="preserve">
          <source>Available parameters are: CURLFTPAUTH_DEFAULT - let libcurl decide CURLFTPAUTH_SSL - try &quot;AUTH SSL&quot; first, then TLS CURLFTPAUTH_TLS - try &quot;AUTH TLS&quot; first, then SSL</source>
          <target state="translated">Доступные параметры:CURLFTPAUTH_DEFAULT-пусть libcurl решит CURLFTPAUTH_SSL-сначала попробуйте &quot;AUTH SSL&quot;,затем TLS CURLFTPAUTH_TLS-сначала попробуйте &quot;AUTH TLS&quot;,затем SSL</target>
        </trans-unit>
        <trans-unit id="463bce54270761ca786235a57251bca24f1dbc8b" translate="yes" xml:space="preserve">
          <source>Available space in bytes</source>
          <target state="translated">Доступное место в байтах</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="2be47cf0ea6736915b049bc8ea265c97a2606e56" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be a sign of poor decomposition of program structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains declarations needed by the other two.</source>
          <target state="translated">Избегайте циклического импорта там,где это целесообразно.Они могут быть признаком плохого разложения структуры программы на независимые модули.Два модуля,которые импортируют друг друга,часто могут быть реорганизованы в три модуля без циклов,где третий содержит декларации,необходимые двум другим.</target>
        </trans-unit>
        <trans-unit id="4417a2a43deb22ade3de0092387bf58a8c4fe263" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be an indication of poor decomposition of a program's structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains the declarations needed by the other two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa042d5d9bad75e7a516100618f6fbb64a7728b7" translate="yes" xml:space="preserve">
          <source>Avoid dependence on byte order; i.e. whether the CPU is big-endian or little-endian.</source>
          <target state="translated">Избегайте зависимости от порядка байт,т.е.от того,какой процессор-большой или маленький.</target>
        </trans-unit>
        <trans-unit id="87263cc0efbd41c932d10eec489a5a9fa53f4615" translate="yes" xml:space="preserve">
          <source>Avoid dependence on the size of a pointer or reference being the same size as a particular integral type.</source>
          <target state="translated">Избегайте зависимости от размера указателя или ссылки,равной размеру определенного интегрального типа.</target>
        </trans-unit>
        <trans-unit id="a5f3c22b10cd44ac8e47f76e9ce3358fd5ea5dbb" translate="yes" xml:space="preserve">
          <source>Avoid depending on the order of side effects in a computation that may get reordered by the compiler. For example:</source>
          <target state="translated">Избегайте в зависимости от порядка возникновения побочных эффектов в вычислениях,которые могут быть переупорядочены компилятором.Например:</target>
        </trans-unit>
        <trans-unit id="07964cf6df89426658b50b243ee7036b1cf42153" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of classes with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">Избегайте мутирующих публичных полей классов с инвариантами,так как тогда инвариант не сможет проверить публичный интерфейс.</target>
        </trans-unit>
        <trans-unit id="4d3d6af1490ba88616db8531edd7f4d34c56a495" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of structs with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">Избегайте мутирующих публичных полей структур с инвариантами,так как тогда инвариант не сможет проверить публичный интерфейс.</target>
        </trans-unit>
        <trans-unit id="0209d0b0190d63b253227592d1649d56cf0d62a8" translate="yes" xml:space="preserve">
          <source>Avoid reliance on side effects in the invariant. as the invariant may or may not be executed.</source>
          <target state="translated">Избегайте использования побочных эффектов в инварианте.так как инвариант может выполняться или не выполняться.</target>
        </trans-unit>
        <trans-unit id="9a2c3569f4cdef214baa0f7dccd251b7796ef000" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs as parameters or arguments to variadic functions.</source>
          <target state="translated">Избегайте использования пустых структур в качестве параметров или аргументов для вариадических функций.</target>
        </trans-unit>
        <trans-unit id="aa27a565a88b1217ee8242e278c52dfa4dc27415" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs when interfacing with C and C++ code.</source>
          <target state="translated">Избегайте использования пустых структур при взаимодействии с C и C++кодом.</target>
        </trans-unit>
        <trans-unit id="fa97dd47910ed157d733ff928c6533de2cbdb883" translate="yes" xml:space="preserve">
          <source>A|B</source>
          <target state="translated">A|B</target>
        </trans-unit>
        <trans-unit id="ee75ef351995c342c1fa5ff34f0c8888a0c4023e" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed32df2c72f22e8029196feaab8d830b375f94a9" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;begin&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9228bacbd6367d63160ad16de9da2a5dc0a4c8ac" translate="yes" xml:space="preserve">
          <source>B &lt;strong id=&quot;select&quot;&gt;select&lt;/strong&gt;(bool cond : false, A, B)(lazy A a, B b);</source>
          <target state="translated">B &lt;strong id=&quot;select&quot;&gt;select&lt;/strong&gt; (bool cond: false, A, B) (ленивый A a, B b);</target>
        </trans-unit>
        <trans-unit id="38af9591e3fb4695fab9bf9aa8e4b04997260819" translate="yes" xml:space="preserve">
          <source>BE stands for BlockExit.</source>
          <target state="translated">BE означает BlockExit.</target>
        </trans-unit>
        <trans-unit id="f18291c5630b11c70838e02838757f776b664e5c" translate="yes" xml:space="preserve">
          <source>BE.xxxx</source>
          <target state="translated">BE.xxxx</target>
        </trans-unit>
        <trans-unit id="a8ac71a34c4bf8d47fcd34a3bb48e39638e1c9c2" translate="yes" xml:space="preserve">
          <source>BEL (alarm) character (U+0007).</source>
          <target state="translated">Символ BEL (тревога)(U+0007).</target>
        </trans-unit>
        <trans-unit id="c4c51eeb133480a8ab13e2aac716dc1c49511996" translate="yes" xml:space="preserve">
          <source>BODY</source>
          <target state="translated">BODY</target>
        </trans-unit>
        <trans-unit id="4248a9b200b0703a243217afa7ea61bb6e9a6078" translate="yes" xml:space="preserve">
          <source>BOM</source>
          <target state="translated">BOM</target>
        </trans-unit>
        <trans-unit id="9e5d541d33dd4e690757280921ed4737bc5066d7" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;builtin&quot;&gt;builtin&lt;/strong&gt;;</source>
          <target state="translated">BUILTIN &lt;strong id=&quot;builtin&quot;&gt;встроенный&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e08e1bc55cdffceca473579010d3eed8f80f3da4" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt;(FuncDeclaration fd);</source>
          <target state="translated">BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt; (FuncDeclaration fd);</target>
        </trans-unit>
        <trans-unit id="2ba208c7a57215fe25a2dc8edeb1eed6d80c323c" translate="yes" xml:space="preserve">
          <source>Back references</source>
          <target state="translated">Назад ссылки</target>
        </trans-unit>
        <trans-unit id="cc6aace08575981676ef15b08f05eb45989c65af" translate="yes" xml:space="preserve">
          <source>Back-end type seldom used directly by user code. Two commonly-used types using &lt;code&gt;VariantN&lt;/code&gt; are:</source>
          <target state="translated">Внутренний тип редко используется непосредственно кодом пользователя. Два часто используемых типа, использующих &lt;code&gt;VariantN&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="59c009b9aac36256a825b962a8506069b93a0cd0" translate="yes" xml:space="preserve">
          <source>Backspace (U+0008).</source>
          <target state="translated">Заднее пространство (U+0008).</target>
        </trans-unit>
        <trans-unit id="cc460f6a8460cfc0b7f80f1ff3a6c734e2b3ea57" translate="yes" xml:space="preserve">
          <source>Backward.</source>
          <target state="translated">Backward.</target>
        </trans-unit>
        <trans-unit id="be7e10d1c5dd2ad77f6d5a617372a7bf013cb7bf" translate="yes" xml:space="preserve">
          <source>Bad</source>
          <target state="translated">Bad</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="a4ba5616fd448eeba2a0c6f11c812abe221ea915" translate="yes" xml:space="preserve">
          <source>Bamum Supplement</source>
          <target state="translated">Бамумовое приложение</target>
        </trans-unit>
        <trans-unit id="8e0abbaab6b20b6084d656b5fa956a7ead91c3cf" translate="yes" xml:space="preserve">
          <source>Bare URLs</source>
          <target state="translated">Голые URL-адреса</target>
        </trans-unit>
        <trans-unit id="f70b3222f4784cd8b2d7fa95c5e6ff653751d799" translate="yes" xml:space="preserve">
          <source>Bare URLs are sequences of characters that start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;, continue with one or more characters from the set of letters, digits and &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt;, and contain at least one period. URL recognition happens before all macro text substitution. The URL is wrapped in a &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; macro and is otherwise left untouched.</source>
          <target state="translated">Голые URL - это последовательности символов, которые начинаются с &lt;code&gt;http://&lt;/code&gt; или &lt;code&gt;https://&lt;/code&gt; , продолжаются одним или несколькими символами из набора букв, цифр и &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt; и содержать хотя бы один период. Распознавание URL происходит перед заменой текста макроса. URL-адрес заключен в макрос &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; и в остальном остается нетронутым.</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">Базовые Типы</target>
        </trans-unit>
        <trans-unit id="cc110ca211bf143dd27dd71bfdb7b015a52cf91f" translate="yes" xml:space="preserve">
          <source>Base class construction is done by calling the base class constructor by the name &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">Конструкция базового класса выполняется путем вызова конструктора базового класса с именем &lt;code&gt;super&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da5e0d7ff0c3f501f663124890a539611d14d952" translate="yes" xml:space="preserve">
          <source>Base class for synchronization errors.</source>
          <target state="translated">Базовый класс для ошибок синхронизации.</target>
        </trans-unit>
        <trans-unit id="c38a7f6f1cb2f71a182073d464805a1edb6ea0e7" translate="yes" xml:space="preserve">
          <source>Base class for synchronization exceptions.</source>
          <target state="translated">Базовый класс для исключений синхронизации.</target>
        </trans-unit>
        <trans-unit id="672c3fd9686f0e99c9f798afb18e998c05c3a884" translate="yes" xml:space="preserve">
          <source>Base class for thread errors to be used for function inside GC when allocations are unavailable.</source>
          <target state="translated">Базовый класс для потоковых ошибок,который будет использоваться для функции внутри ГХ при недоступности распределений.</target>
        </trans-unit>
        <trans-unit id="db07e1efbf8851dc009b2f7a1cf1562018684f57" translate="yes" xml:space="preserve">
          <source>Base class for thread exceptions.</source>
          <target state="translated">Базовый класс для нитевых исключений.</target>
        </trans-unit>
        <trans-unit id="b0f6bbd9a7204a011357ddbe15da4f159805a9c3" translate="yes" xml:space="preserve">
          <source>Base classes are a list of these.</source>
          <target state="translated">Базовые классы-это список.</target>
        </trans-unit>
        <trans-unit id="72c50689eae38c1c7d83b57fc2a2426479cefce2" translate="yes" xml:space="preserve">
          <source>Base exception thrown by &lt;code&gt;std.socket&lt;/code&gt;.</source>
          <target state="translated">Базовое исключение, &lt;code&gt;std.socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05df8270dbce2a852d75025619c0b4d03bd1da5f" translate="yes" xml:space="preserve">
          <source>BaseClass* &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt;;</source>
          <target state="translated">BaseClass * &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="22f60185c7bbe04f26adbe40ecfd3daf1c5e1e4a" translate="yes" xml:space="preserve">
          <source>Based on a design by Mikola Lysenko.</source>
          <target state="translated">По проекту Миколы Лысенко.</target>
        </trans-unit>
        <trans-unit id="b9c44f636926230213ca4c58bc4bd5fa1a395472" translate="yes" xml:space="preserve">
          <source>Based on code written by Regan Heath</source>
          <target state="translated">На основе кода,написанного Реган Хит</target>
        </trans-unit>
        <trans-unit id="8a178898d54dc17c11ed3e0694b1794aa76cee7f" translate="yes" xml:space="preserve">
          <source>Based on ideas in Table 3.1 from &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt; Modern C++ Design&lt;/a&gt;, Andrei Alexandrescu (Addison-Wesley Professional, 2001)</source>
          <target state="translated">Основываясь на идеях из Таблицы 3.1 из &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt;Modern C ++ Design&lt;/a&gt; , Андрей Александреску (Addison-Wesley Professional, 2001)</target>
        </trans-unit>
        <trans-unit id="42a7227a261c13be83db50272e404bef15016672" translate="yes" xml:space="preserve">
          <source>Based on ideas in Table 3.1 from &lt;a href=&quot;https://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt; Modern C++ Design&lt;/a&gt;, Andrei Alexandrescu (Addison-Wesley Professional, 2001)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c70ad4dc394c37a35d8a9a02d3bbf206c6a2c3" translate="yes" xml:space="preserve">
          <source>Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt;;</source>
          <target state="translated">Басеок &lt;strong id=&quot;baseok&quot;&gt;басенок&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2958841f21ba5aab25e4b9de01c61072c4396f05" translate="yes" xml:space="preserve">
          <source>Basic (default)</source>
          <target state="translated">Основной (по умолчанию)</target>
        </trans-unit>
        <trans-unit id="0376175c25ef469be8d7167b7c3f076d8a83135c" translate="yes" xml:space="preserve">
          <source>Basic Data Types</source>
          <target state="translated">Типы основных данных</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">Основной пример</target>
        </trans-unit>
        <trans-unit id="e19913977bf78df5f5b70c758a83b5ae4241e38e" translate="yes" xml:space="preserve">
          <source>Basic Latin</source>
          <target state="translated">Базовая латынь</target>
        </trans-unit>
        <trans-unit id="0c51e02cc99b54172f7d7ba26283b9a2651139e1" translate="yes" xml:space="preserve">
          <source>Basic Logging</source>
          <target state="translated">Базовый журнал</target>
        </trans-unit>
        <trans-unit id="c1025054c73b30fcc4ab113e76ab64be203331d7" translate="yes" xml:space="preserve">
          <source>Basic SMTP protocol support.</source>
          <target state="translated">Поддержка базового протокола SMTP.</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">Основные типы</target>
        </trans-unit>
        <trans-unit id="bf25bdb7baac4ca40f143b32bfd463f5aa35f794" translate="yes" xml:space="preserve">
          <source>Basic and dumm visitor which implements a visit method for each AST node implemented in AST. This visitor is the parent of strict, transitive and permissive visitors.</source>
          <target state="translated">Базовый и фиктивный посетитель,который реализует метод посещения для каждого узла АСТ,реализованного в АСТ.Этот посетитель является родителем строгих,переходных и разрешающих посетителей.</target>
        </trans-unit>
        <trans-unit id="da424bc11d72f3a523d822671599c05d2482dd43" translate="yes" xml:space="preserve">
          <source>Basic block control flow operators.</source>
          <target state="translated">Основные операторы управления потоком блоков.</target>
        </trans-unit>
        <trans-unit id="55069311e393b3bc10e5288945ff6aebf4b60dce" translate="yes" xml:space="preserve">
          <source>Basic blocks: Basic blocks are a linked list of all the basic blocks in a function. startblock heads the list.</source>
          <target state="translated">Основные блоки:Базовые блоки-это связанный список всех базовых блоков в функции.стартовый блок возглавляет список.</target>
        </trans-unit>
        <trans-unit id="b015bc27621ab2a6e58582de340627d2513e110c" translate="yes" xml:space="preserve">
          <source>Basic data types are leaf types. Derived data types build on leaf types. User defined types are aggregates of basic and derived types.</source>
          <target state="translated">Основными типами данных являются типы листьев.Производные типы данных строятся на основе типов листьев.Пользовательские типы являются агрегатами базовых и производных типов.</target>
        </trans-unit>
        <trans-unit id="c76e778b9531849f5fdc3371b8bf8a9576ca93cb" translate="yes" xml:space="preserve">
          <source>Basic splitting with characters and numbers.</source>
          <target state="translated">Основное разделение с символами и цифрами.</target>
        </trans-unit>
        <trans-unit id="22d64c70202f0fd0175e71294c1f0654ef85c43d" translate="yes" xml:space="preserve">
          <source>Basic support for lock-free concurrent programming.</source>
          <target state="translated">Базовая поддержка бесблокового параллельного программирования.</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="f3a7ec26a786494d0ab6bd615e7d7023643666db" translate="yes" xml:space="preserve">
          <source>Be wary of CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') attacks. &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; More info: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&lt;/a&gt;</source>
          <target state="translated">Остерегайтесь CWE-22: Неправильное ограничение имени пути к атакам с ограниченным каталогом (&amp;laquo;обход пути&amp;raquo;). &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; Дополнительная информация: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating + от + испорченных + источников&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d9a6a84847309258cd9cad1f00b1d9b08270b36" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MultiwayMerge&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;MultiwayMerge&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;MultiwayMerge&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">Поскольку &lt;code&gt;MultiwayMerge&lt;/code&gt; не выделяет дополнительную память, он оставляет &lt;code&gt;ror&lt;/code&gt; измененным. А именно, &lt;code&gt;MultiwayMerge&lt;/code&gt; принимает на себя ответственность за &lt;code&gt;ror&lt;/code&gt; и по своему усмотрению меняет и продвигает его элементы. Если вы хотите, чтобы &lt;code&gt;ror&lt;/code&gt; сохранил его содержимое после вызова, вы можете передать дубликат &lt;code&gt;MultiwayMerge&lt;/code&gt; (и, возможно, кэшировать дубликат между вызовами).</target>
        </trans-unit>
        <trans-unit id="34edc8e4b66b211204a07db61a02d64017fc4c94" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;largestPartialIntersection&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;largestPartialIntersection&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;largestPartialIntersection&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">Так как &lt;code&gt;largestPartialIntersection&lt;/code&gt; не выделяет дополнительную память, он оставляет &lt;code&gt;ror&lt;/code&gt; измененным. А именно, &lt;code&gt;largestPartialIntersection&lt;/code&gt; принимает на себя ответственность за &lt;code&gt;ror&lt;/code&gt; и по своему усмотрению меняет и продвигает его элементы. Если вы хотите, чтобы &lt;code&gt;ror&lt;/code&gt; сохранил его содержимое после вызова, вы можете передать дубликат в &lt;code&gt;largestPartialIntersection&lt;/code&gt; (и, возможно, кэшировать дубликат между вызовами).</target>
        </trans-unit>
        <trans-unit id="f9b6407740dfbc3c5fa141971e324ac38d1b4cc4" translate="yes" xml:space="preserve">
          <source>Because errors are unusual, execution of error handling code is not performance critical.</source>
          <target state="translated">Поскольку ошибки необычны,выполнение кода обработки ошибок не является критичным с точки зрения производительности.</target>
        </trans-unit>
        <trans-unit id="1362358bff14273f0cd677a86a2f16a4032a69e1" translate="yes" xml:space="preserve">
          <source>Because immutable is transitive, data referred to by an immutable is also immutable:</source>
          <target state="translated">Поскольку незыблемость является переходной,данные,на которые ссылается незыблемый,также незыблемы:</target>
        </trans-unit>
        <trans-unit id="37a897f3827c71e8379bebae37724c5759dd60a2" translate="yes" xml:space="preserve">
          <source>Because it doesn't return the value, this function is cheaper than &lt;code&gt;get&lt;/code&gt;. However, if you do need the value as well, you should just check the return of &lt;code&gt;get&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; instead of using this function first.</source>
          <target state="translated">Поскольку она не возвращает значение, эта функция дешевле, чем &lt;code&gt;get&lt;/code&gt; . Однако, если вам действительно нужно это значение, вы должны просто проверить возвращение &lt;code&gt;get&lt;/code&gt; для &lt;code&gt;null&lt;/code&gt; вместо того, чтобы сначала использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="46a9674034fbe47581e972f1a85b13b8dd6bc584" translate="yes" xml:space="preserve">
          <source>Because modules are not part of C++, each function with C++ linkage in the global namespace must be globally unique within the program.</source>
          <target state="translated">Поскольку модули не являются частью C++,каждая функция,имеющая связь с C++в глобальном пространстве имён,должна быть глобально уникальной внутри программы.</target>
        </trans-unit>
        <trans-unit id="1a175b9174f2111e9e8065ab0dee738f3bde0af2" translate="yes" xml:space="preserve">
          <source>Because static arrays are passed to functions by value, a larger array can consume a lot of stack space. Use dynamic arrays instead.</source>
          <target state="translated">Поскольку статические массивы передаются в функции по значению,больший массив может потреблять много стека.Вместо этого используйте динамические массивы.</target>
        </trans-unit>
        <trans-unit id="f36468f4c3a8d99449e93cf621c400036ac04c35" translate="yes" xml:space="preserve">
          <source>Because the allocator does not reuse memory, any dangling references to deallocated memory will always result in deterministically crashing the process.</source>
          <target state="translated">Поскольку аллокатор не использует память повторно,любые висячие ссылки на освобожденную память всегда приведут к детерминированному завершению процесса.</target>
        </trans-unit>
        <trans-unit id="d8c3a61715e6c076e516e2adb94c24e13d1a7e0e" translate="yes" xml:space="preserve">
          <source>Because the reduction is being performed in parallel, &lt;code&gt;functions&lt;/code&gt; must be associative. For notational simplicity, let # be an infix operator representing &lt;code&gt;functions&lt;/code&gt;. Then, (a # b) # c must equal a # (b # c). Floating point addition is not associative even though addition in exact arithmetic is. Summing floating point numbers using this function may give different results than summing serially. However, for many practical purposes floating point addition can be treated as associative.</source>
          <target state="translated">Поскольку сокращение выполняется параллельно, &lt;code&gt;functions&lt;/code&gt; должны быть ассоциативными. Для простоты обозначения позвольте # быть инфиксным оператором, представляющим &lt;code&gt;functions&lt;/code&gt; . Тогда (a # b) # c должно равняться a # (b # c). Сложение с плавающей точкой не ассоциативно, хотя сложение в точной арифметике есть. Суммирование чисел с плавающей запятой с использованием этой функции может дать результаты, отличающиеся от суммирования последовательно. Однако для многих практических целей сложение с плавающей запятой можно рассматривать как ассоциативное.</target>
        </trans-unit>
        <trans-unit id="b6b9c971f1d02fbd8d1af3306f1013bb85ae0126" translate="yes" xml:space="preserve">
          <source>Because the validity of the day number depends on both on the year and month of which the day is occurring, take all three variables to validate the day.</source>
          <target state="translated">Поскольку валидность числа дней зависит как от года,так и от месяца,в котором этот день происходит,возьмите все три переменные для валидации дня.</target>
        </trans-unit>
        <trans-unit id="04beefc07e753c0350f57ce75d35ae3795bc6efa" translate="yes" xml:space="preserve">
          <source>Because there are no units larger than years, there is no difference between adding and rolling years.</source>
          <target state="translated">Так как нет единиц больше,чем годы,то нет разницы между годами добавления и прокатки.</target>
        </trans-unit>
        <trans-unit id="8b9fa636d60436156ac4d9755dc04095e1b03ef6" translate="yes" xml:space="preserve">
          <source>Before the function actually returns, any objects with scope storage duration are destroyed, any enclosing finally clauses are executed, any scope(exit) statements are executed, any scope(success) statements are executed, and any enclosing synchronization objects are released.</source>
          <target state="translated">Перед тем,как функция вернется,уничтожаются все объекты с длительностью хранения диапазона,выполняются все заключительные заключения,выполняются все операторы scope(exit),выполняются все успешные заключения scope(success),а также освобождаются все заключенные в оболочку объекты синхронизации.</target>
        </trans-unit>
        <trans-unit id="29b56d3b3ce732a418c6733f4aa512d819b9b955" translate="yes" xml:space="preserve">
          <source>Begins a full collection. While the meaning of this may change based on the garbage collector implementation, typical behavior is to scan all stack segments for roots, mark accessible memory blocks as alive, and then to reclaim free space. This action may need to suspend all running threads for at least part of the collection process.</source>
          <target state="translated">Начинает полную коллекцию.Хотя значение этого может меняться в зависимости от реализации сборщика мусора,типичным поведением является сканирование всех сегментов стека на наличие корней,пометка доступных блоков памяти как живых,а затем восстановление свободного места.Это действие может потребовать приостановки всех запущенных потоков,по крайней мере,на часть процесса сбора.</target>
        </trans-unit>
        <trans-unit id="a9290b213da7c41d3b9d381305e1a85dfd638ddf" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;#visit&quot;&gt;&lt;code&gt;visit&lt;/code&gt;&lt;/a&gt; but doesn't enforce that all types are handled by the visiting functions.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;#visit&quot;&gt; &lt;code&gt;visit&lt;/code&gt; &lt;/a&gt; но не гарантирует, что все типы обрабатываются функциями посещения.</target>
        </trans-unit>
        <trans-unit id="8671963c6358c10c30f0a9f60f5760e545d91151" translate="yes" xml:space="preserve">
          <source>Behaves like the identity function when args is empty.</source>
          <target state="translated">Ведет себя как идентификационная функция,когда аргументы пусты.</target>
        </trans-unit>
        <trans-unit id="f909782a90d0d82b3e7b38e26ebe9e00bc13126f" translate="yes" xml:space="preserve">
          <source>Being 100% compatible with C++ means more or less adding a fully functional C++ compiler front end to D. Anecdotal evidence suggests that writing such is a minimum of a 10 man-year project, essentially making a D compiler with such capability unimplementable. Other languages looking to hook up to C++ face the same problem, and the solutions have been:</source>
          <target state="translated">100%-ная совместимость с C++означает более или менее добавление в D полнофункционального компилятора C++.Анекдотичные данные свидетельствуют о том,что написание такого проекта-это минимум 10 человеко-летний проект,по сути дела дела делающий D-компилятор с такой возможностью неосуществимым.Другие языки,желающие подключиться к C++,сталкиваются с той же проблемой,и ее решение было найдено:</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="d6bc78c2edfd9a1e4a494692d443253b772c6030" translate="yes" xml:space="preserve">
          <source>Below here follows defines for the CURLOPT_IPRESOLVE option. If a host name resolves addresses using more than one IP protocol version, this option might be handy to force libcurl to use a specific IP version.</source>
          <target state="translated">Ниже приведено определение опции CURLOPT_IPRESOLVE.Если имя хоста разрешает адреса,используя более одной версии IP-протокола,то эта опция может быть полезна,чтобы заставить libcurl использовать определенную версию IP.</target>
        </trans-unit>
        <trans-unit id="8b8ee9a8f224bc381d10b9725300af6e8ad60b2f" translate="yes" xml:space="preserve">
          <source>Below is the table of names accepted by &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt;&lt;code&gt;unicode.hangulSyllableType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ниже приведена таблица имен, принятых &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt; &lt;code&gt;unicode.hangulSyllableType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f460beb4086eb83db26145c0c14bfc2836a2dd77" translate="yes" xml:space="preserve">
          <source>Below is the table with block names accepted by &lt;a href=&quot;#unicode.block&quot;&gt;&lt;code&gt;unicode.block&lt;/code&gt;&lt;/a&gt;. Note that the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; requires &quot;In&quot; to be prepended to the names of blocks so as to disambiguate scripts and blocks.</source>
          <target state="translated">Ниже приведена таблица с именами блоков, принятыми &lt;a href=&quot;#unicode.block&quot;&gt; &lt;code&gt;unicode.block&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что сокращенная версия &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; требует, чтобы перед именами блоков добавлялось &amp;laquo;In&amp;raquo;, чтобы устранить неоднозначность сценариев и блоков.</target>
        </trans-unit>
        <trans-unit id="c16ded473b8d6a501e3afbf1d6b1aaa3bb67b9a5" translate="yes" xml:space="preserve">
          <source>Below is the table with script names accepted by &lt;a href=&quot;#unicode.script&quot;&gt;&lt;code&gt;unicode.script&lt;/code&gt;&lt;/a&gt; and by the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Ниже приведена таблица с именами сценариев, принятыми &lt;a href=&quot;#unicode.script&quot;&gt; &lt;code&gt;unicode.script&lt;/code&gt; &lt;/a&gt; и сокращенной версией &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5cce75cef6b6f1b3c31bc07730b294f2256592a7" translate="yes" xml:space="preserve">
          <source>Benchmark with two functions comparing.</source>
          <target state="translated">Эталон с двумя функциями сравнения.</target>
        </trans-unit>
        <trans-unit id="aa8cbccdf814344c472fdc83108ce95f463d76c2" translate="yes" xml:space="preserve">
          <source>Benchmarks code for speed assessment and comparison.</source>
          <target state="translated">Код бенчмарков для оценки и сравнения скорости.</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="39b464ae10a3403acc76206ce3373cf277ad5588" translate="yes" xml:space="preserve">
          <source>Beta function</source>
          <target state="translated">бета-функция</target>
        </trans-unit>
        <trans-unit id="6cf60f60aed600fb3f70f4f199ce23160c46df50" translate="yes" xml:space="preserve">
          <source>Better C</source>
          <target state="translated">Лучше С</target>
        </trans-unit>
        <trans-unit id="fa66737ffd71fbd94c99a79ae1d7c0f7a3f83f97" translate="yes" xml:space="preserve">
          <source>Bidi_Control</source>
          <target state="translated">Bidi_Control</target>
        </trans-unit>
        <trans-unit id="c1dd854953db9a48bc0d0ea0a3df0b423f22bafe" translate="yes" xml:space="preserve">
          <source>Bidirectional primitives. They are offered if &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt;.</source>
          <target state="translated">Двунаправленные примитивы. Они предлагаются, если &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd2b2945fcece1d7de6dc41f877ba8c67c13689" translate="yes" xml:space="preserve">
          <source>Bidirectional range of elements</source>
          <target state="translated">Двунаправленный диапазон элементов</target>
        </trans-unit>
        <trans-unit id="019ef9f3f8b5262d462588c43fd756f3913eee2d" translate="yes" xml:space="preserve">
          <source>Bidirectional range primitives. Provided only if both &lt;code&gt;hasSlicing!Source&lt;/code&gt; and &lt;code&gt;hasLength!Source&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Двунаправленный диапазон примитивов. Предоставляется только в том случае, если оба значения &lt;code&gt;hasSlicing!Source&lt;/code&gt; и &lt;code&gt;hasLength!Source&lt;/code&gt; имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71bfb07d0cb12b1ba4834790c7322d9de720c8a3" translate="yes" xml:space="preserve">
          <source>BidirectionalRange &lt;code&gt;range&lt;/code&gt;</source>
          <target state="translated">Двунаправленный &lt;code&gt;range&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635846f5f8a3535fe06ebe7bdfb132d87f3a3a9b" translate="yes" xml:space="preserve">
          <source>Big endian byte order</source>
          <target state="translated">Большой эндийский байт-ордер</target>
        </trans-unit>
        <trans-unit id="880ccaf424d3d59837e9afca21d218a82696d56c" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;base&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;base&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15d8e19b48cf73cfcbd5673d000427a6c89fe0cf" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;dividend&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;dividend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bf4e8892121a909f8719ff5ba16cf85f8324a8e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;divisor&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;divisor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9d72c5e7f7fec77eccf61954e6a190a6919e39" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;exponent&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;exponent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d09af76576312e7fbdeb58e15f85ddf03bdfeca" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;modulus&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;modulus&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6719bddb8d0310ee6d49cac219e4be2a60dd859e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;quotient&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;quotient&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6acf46d3f9c34c441344f4052f380185deff090a" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;remainder&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;remainder&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc0d6128e74b8ffa38299adc002109eff669779d" translate="yes" xml:space="preserve">
          <source>BigInt implements value semantics using copy-on-write. This means that assignment is cheap, but operations such as x++ will cause heap allocation. (But note that for most bigint operations, heap allocation is inevitable anyway.)</source>
          <target state="translated">BigInt реализует ценностную семантику с помощью копирования на запись.Это означает,что присваивание дешево,но такие операции как x++приведут к распределению кучи.(Но обратите внимание,что для большинства крупных операций распределение кучи все равно неизбежно).</target>
        </trans-unit>
        <trans-unit id="2ae987b3c8b155139b22a17dacfded40cd54d6e8" translate="yes" xml:space="preserve">
          <source>Binary Operator Overloading</source>
          <target state="translated">Перегрузка двоичного оператора</target>
        </trans-unit>
        <trans-unit id="7ea3f10d7dc50a5d1d60c584be4ba66327be2344" translate="yes" xml:space="preserve">
          <source>Binary exponentiation</source>
          <target state="translated">двоичное исчисление</target>
        </trans-unit>
        <trans-unit id="bc0e2dd063d01cb0a49d6952e1a447f5a0786666" translate="yes" xml:space="preserve">
          <source>Binary expressions except for &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt;, and &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt; are evaluated in lexical order (left-to-right). Example:</source>
          <target state="translated">Двоичные выражения, за исключением &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt; и &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt; , оцениваются в лексическом порядке (слева направо). Пример:</target>
        </trans-unit>
        <trans-unit id="3f59323ff0289ed186c342bdb4f9ade9bee4b594" translate="yes" xml:space="preserve">
          <source>Binary files: Number of bytes to offset from origin.</source>
          <target state="translated">Двоичные файлы:Количество байт для смещения от начала.</target>
        </trans-unit>
        <trans-unit id="5ec3f5b7c67a25b307ee5761394fbc7f85f5c4ec" translate="yes" xml:space="preserve">
          <source>Binary files: Position used as reference for the offset, must be one of &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;, &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; or &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt;.</source>
          <target state="translated">Двоичные файлы: позиция, используемая в качестве ссылки для смещения, должна быть одной из &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt; , &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; или &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="710001c86b903db5ac28284015f70ad29d702165" translate="yes" xml:space="preserve">
          <source>Binary integers are a sequence of binary digits preceded by a &amp;lsquo;0b&amp;rsquo; or &amp;lsquo;0B&amp;rsquo;.</source>
          <target state="translated">Двоичные целые числа представляют собой последовательность двоичных цифр, перед которыми стоят &amp;laquo;0b&amp;raquo; или &amp;laquo;0B&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e30449766634fc47649993e043f53913e318f363" translate="yes" xml:space="preserve">
          <source>Binary operations: subtracting and intersecting flags</source>
          <target state="translated">Двоичные операции:вычитание и пересечение флагов</target>
        </trans-unit>
        <trans-unit id="5bc41f55b9ac5ad602ac2a15812f4fa17e719258" translate="yes" xml:space="preserve">
          <source>Binary predicate for determining equivalence of two elements.</source>
          <target state="translated">Двоичный предикат для определения эквивалентности двух элементов.</target>
        </trans-unit>
        <trans-unit id="1b5c4d6f642263934709007da433b44cfafe3dfa" translate="yes" xml:space="preserve">
          <source>Binary predicate that reverses the order of arguments, e.g., given &lt;code&gt;pred(a, b)&lt;/code&gt;, returns &lt;code&gt;pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">Двоичный предикат, который меняет порядок аргументов, например, заданный &lt;code&gt;pred(a, b)&lt;/code&gt; , возвращает &lt;code&gt;pred(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3390f0873b37228eb9da1981c4edea13376f4ce4" translate="yes" xml:space="preserve">
          <source>Binary zero (NUL, U+0000).</source>
          <target state="translated">Двоичный ноль (NUL,U+0000).</target>
        </trans-unit>
        <trans-unit id="f07c525c75d6754496cc9e553ac6cf1931c4d038" translate="yes" xml:space="preserve">
          <source>BinaryHeap!(Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, Store)(Store s, size_t initialSize = size_t.max);</source>
          <target state="translated">BinaryHeap! (Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt; (псевдоним less = &quot;a &amp;lt;b&quot;, Store) (Store s, size_t initialSize = size_t.max);</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">Привязка стоимости к подготовленным отчетам</target>
        </trans-unit>
        <trans-unit id="29d9453c80dc53e32cc00f3280980ce7ea8a0687" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr)</source>
          <target state="translated">Привязка для ::operator delete(void*ptr)</target>
        </trans-unit>
        <trans-unit id="f7d97838adda037dd541956c0b38a3516ae36925" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr, const std::nothrow_t&amp;amp; tag)</source>
          <target state="translated">Привязка для :: оператора delete (void * ptr, const std :: nothrow_t &amp;amp; tag)</target>
        </trans-unit>
        <trans-unit id="9e8bd6d0542a61db39dc7370f4ff9f5bdec532e6" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count)</source>
          <target state="translated">Привязка для ::operator new(std::size_t count)</target>
        </trans-unit>
        <trans-unit id="c9209fa1a437c94943e83fdcf912d410e070a043" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count, const std::nothrow_t&amp;amp;)</source>
          <target state="translated">Привязка для :: оператора new (std :: size_t count, const std :: nothrow_t &amp;amp;)</target>
        </trans-unit>
        <trans-unit id="c595af9a225910870bb198153cb9e584ec6c2237" translate="yes" xml:space="preserve">
          <source>Binds the internal state to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Связывает внутреннее состояние со &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e718a122aa87d12e98c5f3055711cc94d264e1c" translate="yes" xml:space="preserve">
          <source>Bionic C runtime</source>
          <target state="translated">время прогона Бионика С</target>
        </trans-unit>
        <trans-unit id="cec8cf9a0b27bd714792dac06606e5c1b0178367" translate="yes" xml:space="preserve">
          <source>Bit constructs</source>
          <target state="translated">Битовые конструкции</target>
        </trans-unit>
        <trans-unit id="70402e7ad10ad5f2124d70b6b5dfed369e14c974" translate="yes" xml:space="preserve">
          <source>Bit decoding of the TargetOS</source>
          <target state="translated">Битовое декодирование TargetOS</target>
        </trans-unit>
        <trans-unit id="da97ac52d02a77703c633362dd74456458d249b2" translate="yes" xml:space="preserve">
          <source>Bit fields are supported with the &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;bitfields&lt;/a&gt; template.</source>
          <target state="translated">Битовые поля поддерживаются с &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;битовыми&lt;/a&gt; матрицами.</target>
        </trans-unit>
        <trans-unit id="11ee76002d783da853ef20847f30176e5d03ae44" translate="yes" xml:space="preserve">
          <source>Bit flipping</source>
          <target state="translated">Немного переворачивание</target>
        </trans-unit>
        <trans-unit id="8f76655665dcf73e363d56fc2df9877070986357" translate="yes" xml:space="preserve">
          <source>Bit wise expressions perform a bitwise operation on their operands. Their operands must be integral types. First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done. Then, the bitwise operation is done.</source>
          <target state="translated">Побитовые выражения выполняют побитовую операцию над своими операндами. Их операнды должны быть целочисленными типами. Во-первых, &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычные арифметические преобразования&lt;/a&gt; сделаны. Затем выполняется побитовая операция.</target>
        </trans-unit>
        <trans-unit id="0ab61da13a6c10abbc480c4a1c0747cb3baa6877" translate="yes" xml:space="preserve">
          <source>Bit-level manipulation facilities.</source>
          <target state="translated">Способы манипулирования на уровне битов.</target>
        </trans-unit>
        <trans-unit id="d9eff8dc4264242a1ae12f932821b47da28a5cc7" translate="yes" xml:space="preserve">
          <source>Bitwise Expressions</source>
          <target state="translated">Побочные выражения</target>
        </trans-unit>
        <trans-unit id="df5079d347ee1e4244353fecfac2f5edf6b28c3c" translate="yes" xml:space="preserve">
          <source>Bitwise adapter over an integral type range. Consumes the range elements bit by bit, from the least significant bit to the most significant bit.</source>
          <target state="translated">Битовый адаптер в интегральном диапазоне типов.Потребляет элементы диапазона по битам,от наименее значимого бита до наиболее значимого.</target>
        </trans-unit>
        <trans-unit id="9b504c7d294e8d9e76232c80318479234720041d" translate="yes" xml:space="preserve">
          <source>Bitwise rotate &lt;code&gt;value&lt;/code&gt; left (&lt;code&gt;rol&lt;/code&gt;) or right (&lt;code&gt;ror&lt;/code&gt;) by &lt;code&gt;count&lt;/code&gt; bit positions.</source>
          <target state="translated">Побитовое вращение &lt;code&gt;value&lt;/code&gt; влево ( &lt;code&gt;rol&lt;/code&gt; ) или вправо ( &lt;code&gt;ror&lt;/code&gt; ) на &lt;code&gt;count&lt;/code&gt; битов.</target>
        </trans-unit>
        <trans-unit id="8ac6960d99f504b227c089027d841f4e9c385375" translate="yes" xml:space="preserve">
          <source>Block Elements</source>
          <target state="translated">Блочные элементы</target>
        </trans-unit>
        <trans-unit id="44f23b923d4c118ace9751471e8a32d3ddca275e" translate="yes" xml:space="preserve">
          <source>Block Statement</source>
          <target state="translated">Блок-схема</target>
        </trans-unit>
        <trans-unit id="7358e14919f4d134af66ef6ad913b5a7d1139ac8" translate="yes" xml:space="preserve">
          <source>Block comments can span multiple lines, but do not nest.</source>
          <target state="translated">Комментарии блока могут охватывать несколько строк,но не гнездиться.</target>
        </trans-unit>
        <trans-unit id="7fbe37dc50c1260fc0044f00cb0158d89f4c81af" translate="yes" xml:space="preserve">
          <source>Block of memory to serve as support for the allocator. Memory must be larger than two words and word-aligned.</source>
          <target state="translated">Блок памяти для поддержки аллокатора.Память должна быть больше двух слов и выровнена по словам.</target>
        </trans-unit>
        <trans-unit id="ae0016c0671df573a3221620d651641a4c8dfdcc" translate="yes" xml:space="preserve">
          <source>Block previously obtained by a call to &lt;code&gt;allocate&lt;/code&gt; against this allocator (&lt;code&gt;null&lt;/code&gt; is allowed).</source>
          <target state="translated">Блок, ранее полученный вызовом для &lt;code&gt;allocate&lt;/code&gt; против этого распределителя ( допускается &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ccb689779e89b6ac603e18c3e2082f3bf5ed78f" translate="yes" xml:space="preserve">
          <source>Block to deallocate.</source>
          <target state="translated">Блок,чтобы разобраться.</target>
        </trans-unit>
        <trans-unit id="8117bd427e84d25123d525df198441ce5a262ba4" translate="yes" xml:space="preserve">
          <source>BlockStatement</source>
          <target state="translated">BlockStatement</target>
        </trans-unit>
        <trans-unit id="1c575a00b6c6472431006e69a67cda683c681cb6" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator</source>
          <target state="translated">BookkeepingAllocator</target>
        </trans-unit>
        <trans-unit id="642b597338266fa6f0fcfa51d03f6363e4f3af1d" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator &lt;strong id=&quot;bkalloc&quot;&gt;bkalloc&lt;/strong&gt;;</source>
          <target state="translated">BookkeepingAllocator &lt;strong id=&quot;bkalloc&quot;&gt;bkalloc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="807b1864fdb6805b8347ae2bc9a6c20e8e44cbff" translate="yes" xml:space="preserve">
          <source>Boolean Operations</source>
          <target state="translated">логические операции</target>
        </trans-unit>
        <trans-unit id="9a7bb38540335c853c8483b5f52966e014c86be1" translate="yes" xml:space="preserve">
          <source>Boolean flag set to true while the runtime is initialized.</source>
          <target state="translated">Булевый флаг установлен в true во время инициализации выполнения.</target>
        </trans-unit>
        <trans-unit id="919ba0f721b82028f799116e9733b52309e726b3" translate="yes" xml:space="preserve">
          <source>Boolean options</source>
          <target state="translated">логические варианты</target>
        </trans-unit>
        <trans-unit id="d62f48763e9c33e113d6e562d9814ef6092b4bb1" translate="yes" xml:space="preserve">
          <source>Boolean values are converted to &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401d2f1688a777ae0bc5be157d0d7272e332e127" translate="yes" xml:space="preserve">
          <source>Boolean values are printed as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">Логические значения печатаются как &lt;code&gt;&quot;true&quot;&lt;/code&gt; или &lt;code&gt;&quot;false&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="105c6c86d7dd1b24e773395f017e7ee3c51ac8ff" translate="yes" xml:space="preserve">
          <source>Boost License 1.0</source>
          <target state="translated">Лицензия на повышение 1.0</target>
        </trans-unit>
        <trans-unit id="e47a3386c7e74d205f749769164e9ef5c8040834" translate="yes" xml:space="preserve">
          <source>Boost Signals</source>
          <target state="translated">Повышающие сигналы</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="5ba82cb02c720f3652f57a038e834a4bcc4c4c2f" translate="yes" xml:space="preserve">
          <source>Bopomofo Extended</source>
          <target state="translated">Бопомофо Расширенный</target>
        </trans-unit>
        <trans-unit id="50d58ef5d04eba875c690e66a2db13e6043d0608" translate="yes" xml:space="preserve">
          <source>Borrowed</source>
          <target state="translated">Borrowed</target>
        </trans-unit>
        <trans-unit id="a5cd3b3f934540f0788541fb598aaaad1cf890f6" translate="yes" xml:space="preserve">
          <source>Borrowers are considered Owners if they are initialized from other than a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a58aa19fb67e0b5abe5d7641293ce8ffcd1a87d" translate="yes" xml:space="preserve">
          <source>Borrowers can be Owners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60c93251f61201f166e2379b490f975956e31c4" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Algebraic&lt;/code&gt; and &lt;code&gt;Variant&lt;/code&gt; share &lt;code&gt; VariantN&lt;/code&gt;'s interface. (See their respective documentations below.)</source>
          <target state="translated">И &lt;code&gt;Algebraic&lt;/code&gt; и &lt;code&gt;Variant&lt;/code&gt; имеют &lt;code&gt; VariantN&lt;/code&gt; интерфейс VariantN . (См. Их соответствующие документы ниже.)</target>
        </trans-unit>
        <trans-unit id="6535ded07930e3ddda0a1fe0ceda88dc9ce33dfa" translate="yes" xml:space="preserve">
          <source>Both backward and forward.</source>
          <target state="translated">Как назад,так и вперед.</target>
        </trans-unit>
        <trans-unit id="b8f7ae57cc9f0d657e03c01e9e4d98ba216ba14c" translate="yes" xml:space="preserve">
          <source>Both immutable and const are</source>
          <target state="translated">Как непреложные,так и константные</target>
        </trans-unit>
        <trans-unit id="e6a3f4fd036b065b2e797530c76e1c67c7c891ad" translate="yes" xml:space="preserve">
          <source>Both isThis() and isNested() should return true if function needs a dual-context pointer, otherwise if isThis() returns true, isNested() should return false.</source>
          <target state="translated">И isThis(),и isNested()должны возвращать true,если функции нужен указатель двойного контекста,в противном случае,если isThis()возвращает true,isNested()должна возвращать false.</target>
        </trans-unit>
        <trans-unit id="bf39d0ca68e0898427724a5e452ff23fb939fa46" translate="yes" xml:space="preserve">
          <source>Both rewrites are tried. If only one compiles, that one is taken. If they both resolve to the same function, the first rewrite is done. If they resolve to different functions, the best matching one is used. If they both match the same, but are different functions, an ambiguity error results.</source>
          <target state="translated">Оба переписывания испробованы.Если только один составлен,то этот взят.Если они оба решаются на одну и ту же функцию,выполняется первая перезапись.Если они решаются в разные функции,используется наиболее подходящая из них.Если они оба совпадают,но являются разными функциями,это приводит к ошибке неоднозначности.</target>
        </trans-unit>
        <trans-unit id="0cd32d8791a4b901dbb6cc0f81dd64df4c40048e" translate="yes" xml:space="preserve">
          <source>Both the test and the return expressions are lazily evaluated.</source>
          <target state="translated">И тестовое,и возвратное выражения оцениваются лениво.</target>
        </trans-unit>
        <trans-unit id="171f0c459de342d1f54dbc2ce2646745cc4ebc56" translate="yes" xml:space="preserve">
          <source>Both variants are implemented as instantiations of the template &lt;a href=&quot;#Base64Impl&quot;&gt;&lt;code&gt;Base64Impl&lt;/code&gt;&lt;/a&gt;. Most users will not need to use this template directly; however, it can be used to create customized Base64 encodings, such as one that omits padding characters, or one that is safe to embed inside a regular expression.</source>
          <target state="translated">Оба варианта реализованы в виде экземпляров шаблона &lt;a href=&quot;#Base64Impl&quot;&gt; &lt;code&gt;Base64Impl&lt;/code&gt; &lt;/a&gt; . Большинству пользователей не нужно использовать этот шаблон напрямую; однако его можно использовать для создания пользовательских кодировок Base64, таких как код, в котором пропускаются символы заполнения, или код, который безопасно внедрять в регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="00d1805af0d734eef9db29bbdcf7d82b5d3e7f04" translate="yes" xml:space="preserve">
          <source>Box Drawing</source>
          <target state="translated">розыгрыш ящика</target>
        </trans-unit>
        <trans-unit id="b8d28f7a363659e9c4b08c47130a0d8f80f5c106" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(binaryFun!pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range needle)</source>
          <target state="translated">BoyerMooreFinder! (BinaryFun! Pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt; (псевдоним &lt;strong id=&quot;boyerMooreFinder&quot;&gt;pred&lt;/strong&gt; = &quot;a == b&quot;, Range) (стрелка диапазона)</target>
        </trans-unit>
        <trans-unit id="2a76fd949603813a813972f30d7b0eeea91480d5" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(pred, InputRange) &lt;code&gt;needle&lt;/code&gt;</source>
          <target state="translated">BoyerMooreFinder! (Пред, InputRange) &lt;code&gt;needle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e5a99860d31900d36389daa3fa718de031554d4" translate="yes" xml:space="preserve">
          <source>Brahmi</source>
          <target state="translated">Brahmi</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="754a680c22eb1f9ecca61fac281a3f23b7fb9d29" translate="yes" xml:space="preserve">
          <source>Braille Patterns</source>
          <target state="translated">Шрифты Брайля</target>
        </trans-unit>
        <trans-unit id="b2fcd02a50371b93a9e3654260745ee0af90cca2" translate="yes" xml:space="preserve">
          <source>Break Statement</source>
          <target state="translated">Заявление о перерыве</target>
        </trans-unit>
        <trans-unit id="76820814ec6d343b49333e574d3bb22a7fa8676a" translate="yes" xml:space="preserve">
          <source>Break and Continue out of Foreach</source>
          <target state="translated">Выходите и продолжайте выходить из Фореча</target>
        </trans-unit>
        <trans-unit id="0a89343c3ed16b2574554e37596ef4b4facffb9f" translate="yes" xml:space="preserve">
          <source>Breaking from a parallel foreach loop via a break, labeled break, labeled continue, return or goto statement throws a &lt;code&gt;ParallelForeachError&lt;/code&gt;.  In the case of non-random access ranges, parallel foreach buffers lazily to an array of size &lt;code&gt;workUnitSize&lt;/code&gt; before executing the parallel portion of the loop. The exception is that, if a parallel foreach is executed over a range returned by &lt;code&gt;asyncBuf&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;, the copying is elided and the buffers are simply swapped. In this case &lt;code&gt;workUnitSize&lt;/code&gt; is ignored and the work unit size is set to the buffer size of &lt;code&gt;range&lt;/code&gt;.  A memory barrier is guaranteed to be executed on exit from the loop, so that results produced by all threads are visible in the calling thread.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside a parallel foreach loop, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown by any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">Прерывание параллельного цикла foreach с помощью оператора break, помеченного как break, помеченного как continue, return или goto приводит к возникновению &lt;code&gt;ParallelForeachError&lt;/code&gt; . В случае диапазонов неслучайного доступа параллельные foreach буферизуются лениво в массив размера &lt;code&gt;workUnitSize&lt;/code&gt; перед выполнением параллельной части цикла. Исключением является то, что, если параллельный foreach выполняется в диапазоне, возвращаемом &lt;code&gt;asyncBuf&lt;/code&gt; или &lt;code&gt;map&lt;/code&gt; , копирование исключается, а буферы просто меняются местами. В этом случае &lt;code&gt;workUnitSize&lt;/code&gt; игнорируется, а размер рабочего блока устанавливается равным размеру буфера &lt;code&gt;range&lt;/code&gt; , Гарантированный барьер памяти будет выполнен при выходе из цикла, так что результаты, полученные всеми потоками, будут видны в вызывающем потоке. &lt;b&gt;Обработка исключений&lt;/b&gt; : Когда по крайней мере одно исключение выдается из параллельного цикла foreach, отправка дополнительных объектов &lt;code&gt;Task&lt;/code&gt; прекращается как можно скорее недетерминированным способом. Все выполняемые или поставленные в очередь рабочие единицы могут быть завершены. Затем все исключения, которые были &lt;code&gt;Throwable.next&lt;/code&gt; любым рабочим модулем, объединяются в цепочку с помощью Throwable.next и перебрасываются. Порядок цепочки исключений является недетерминированным.</target>
        </trans-unit>
        <trans-unit id="9d3201041918654fbf75089e070856aa79ebc523" translate="yes" xml:space="preserve">
          <source>Breaks x into an integral part and a fractional part, each of which has the same sign as x. The integral part is stored in i.</source>
          <target state="translated">Разбивает х на составную часть и дробную часть,каждая из которых имеет тот же знак,что и х.Интегральная часть хранится в i.</target>
        </trans-unit>
        <trans-unit id="4324d0ed28641cb58b631967da3876548c2a70ef" translate="yes" xml:space="preserve">
          <source>Bring leaves to common type.</source>
          <target state="translated">Приведите листья к общему типу.</target>
        </trans-unit>
        <trans-unit id="399d0f0935a4fd7e2adf0462c69b1578bb0496b9" translate="yes" xml:space="preserve">
          <source>Buffer &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">Буферный &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535393fe6f448d36dc112ebfa2c4ec8acdaebcaa" translate="yes" xml:space="preserve">
          <source>Buffer to receive error messages in, must be at least CURL_ERROR_SIZE bytes big. If this is not used, error messages go to stderr instead:</source>
          <target state="translated">Буфер для получения сообщений об ошибках должен иметь размер не менее CURL_ERROR_SIZE байт.Если это не используется,сообщения об ошибках переходят в stderr:</target>
        </trans-unit>
        <trans-unit id="303f92df69f201e44e4c0ca1825e2e280d1f0c91" translate="yes" xml:space="preserve">
          <source>Buffer to structure as a free list. If &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, the buffer is assumed to be allocated by &lt;code&gt;parent&lt;/code&gt; and will be freed in the destructor.</source>
          <target state="translated">Буфер для структурирования как свободный список. Если &lt;code&gt;ParentAllocator&lt;/code&gt; не является &lt;code&gt;NullAllocator&lt;/code&gt; , предполагается , что буфер выделен &lt;code&gt;parent&lt;/code&gt; и будет освобожден в деструкторе.</target>
        </trans-unit>
        <trans-unit id="c05d2a8029044c4c4e57f66bbd40a3eac5b198a2" translate="yes" xml:space="preserve">
          <source>Buffer to write the escaped path to</source>
          <target state="translated">Буфер,чтобы написать сбежавший путь к</target>
        </trans-unit>
        <trans-unit id="c083c9d2a3d468528bb5dd1cebdd4400312c43c2" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is enlarged if necessary, then set to the slice exactly containing the line.</source>
          <target state="translated">Буфер,используемый для хранения результирующих данных строки.buf при необходимости увеличивается,а затем устанавливается на срез,точно содержащий строку.</target>
        </trans-unit>
        <trans-unit id="7ab4ac68db7c219824ba8029fe0a1e0d5e5c01c5" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is resized as necessary.</source>
          <target state="translated">Буфер,используемый для хранения результирующих данных строки.buf при необходимости изменяет размер.</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="80432fb4403119d7fa36b39cc0581f74363b7507" translate="yes" xml:space="preserve">
          <source>Bugs:</source>
          <target state="translated">Bugs:</target>
        </trans-unit>
        <trans-unit id="e543d61d1db526d2c201a9150a8eeb4f6a08a7bb" translate="yes" xml:space="preserve">
          <source>Bugzilla 2137</source>
          <target state="translated">Бугзилла 2137</target>
        </trans-unit>
        <trans-unit id="d957a3ddca24bb7ba3415ed5d23a475def657008" translate="yes" xml:space="preserve">
          <source>Bugzilla 592</source>
          <target state="translated">Бугзилла 592</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="e4ce8210e89bb0abea338092bae131b54bcd5ff1" translate="yes" xml:space="preserve">
          <source>Build __xopCmp for TypeInfo_Struct static bool __xopCmp(ref const S p, ref const S q) { return p.opCmp(q); }</source>
          <target state="translated">Сборка __xopCmp для TypeInfo_Struct статический bool __xopCmp(ref const S p,ref const S q){return p.opCmp(q);}</target>
        </trans-unit>
        <trans-unit id="f3d924ea22f0f293cf6f3ebfcd84f23fb87ecdc9" translate="yes" xml:space="preserve">
          <source>Build __xopEquals for TypeInfo_Struct static bool __xopEquals(ref const S p, ref const S q) { return p == q; }</source>
          <target state="translated">Сборка __xopEquals для TypeInfo_Struct статический bool __xopEquals(ref const S p,ref const S q){return p ==q;}</target>
        </trans-unit>
        <trans-unit id="edd21187462263909c4e5bccda552a4211a055ce" translate="yes" xml:space="preserve">
          <source>Build _xtoHash for non-bitwise hashing static hash_t xtoHash(ref const S p) nothrow @trusted;</source>
          <target state="translated">Сборка _xtoHash для небитумного хэширования статическим хэшем_t xtoHash(ref const S p)nothrow @trusted;</target>
        </trans-unit>
        <trans-unit id="02755102e393b0ceee36f18acf3cd4f3a97f903b" translate="yes" xml:space="preserve">
          <source>Build a list out of the null-terminated argument list.</source>
          <target state="translated">Постройте список из нулевого списка аргументов.</target>
        </trans-unit>
        <trans-unit id="8926cd9ddf0e4003036d0a204fc3589b6f556c48" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to copy the value of e into.</source>
          <target state="translated">Постройте временную переменную для копирования значения e.</target>
        </trans-unit>
        <trans-unit id="7126b83ecb05ac49ee0d9a4bfd7fa2c9443a5db6" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to extract e's evaluation, if e is not trivial.</source>
          <target state="translated">Постройте временную переменную для извлечения оценки e,если e не тривиальна.</target>
        </trans-unit>
        <trans-unit id="5f0947173a3022e64a66ace8a16da7bd0953de0d" translate="yes" xml:space="preserve">
          <source>Build opAssign for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Создайте opAssign для &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd267126bb39bb406bc3a0c8c87a8165b825fa2e" translate="yes" xml:space="preserve">
          <source>Build opEquals for struct. const bool opEquals(const S s) { ... }</source>
          <target state="translated">Постройте opEquals для struct.const bool opEquals(const S){...}</target>
        </trans-unit>
        <trans-unit id="6dd999e7845d7581c295f9165da47448ffe76f29" translate="yes" xml:space="preserve">
          <source>Build scoped variables and reference-counted types.</source>
          <target state="translated">Построение переменных в диапазоне видимости и ссылочных типов.</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="e777aa2ee0a1277f1927115dd56047ae99acaf63" translate="yes" xml:space="preserve">
          <source>Building Blocks</source>
          <target state="translated">Строительные блоки</target>
        </trans-unit>
        <trans-unit id="3f334616286956fcb816046552d7f9bf1acd6341" translate="yes" xml:space="preserve">
          <source>Building block functions, they translate to a single x87 instruction.</source>
          <target state="translated">Функции строительного блока,они переводят на одну единственную команду x87.</target>
        </trans-unit>
        <trans-unit id="5d7f3504504044d481b2cb93792c53ee903721c6" translate="yes" xml:space="preserve">
          <source>Building blocks</source>
          <target state="translated">Строительные блоки</target>
        </trans-unit>
        <trans-unit id="39c609d88be88f825074ec54ab9e12948dadee89" translate="yes" xml:space="preserve">
          <source>Building contract support into the language makes for:</source>
          <target state="translated">Сопровождение договора на языке делает для:</target>
        </trans-unit>
        <trans-unit id="e5d9a44c338285ef0b2cf2cbe5abd6d13da4bd15" translate="yes" xml:space="preserve">
          <source>Builds a &lt;code&gt;Trie&lt;/code&gt; with typically optimal speed-size trade-off and wraps it into a delegate of the following type: &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt;.</source>
          <target state="translated">Создает &lt;code&gt;Trie&lt;/code&gt; с обычно оптимальным компромиссом скорости и размера и оборачивает его в делегат следующего типа: &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddd9b5faf4e195f0b71766badf13e8513590fa7" translate="yes" xml:space="preserve">
          <source>Builds an index of the top elements of a range.</source>
          <target state="translated">Строит индекс верхних элементов диапазона.</target>
        </trans-unit>
        <trans-unit id="8ac6cb76b75c220d2577581173ee0a6d992a81d1" translate="yes" xml:space="preserve">
          <source>Builds an object. Usually this is invoked indirectly by using the &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Строит объект. Обычно это вызывается косвенно с помощью функции &lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12e943a67bf614d76638933b655f13c408534085" translate="yes" xml:space="preserve">
          <source>Built-in mathematical intrinsics.</source>
          <target state="translated">Встроенная математика.</target>
        </trans-unit>
        <trans-unit id="393ada6b17ede7fe1acbc7b82bec2f4e8c1c04b5" translate="yes" xml:space="preserve">
          <source>Built-in postfix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to lambda invocations as follows: &lt;code&gt;expr++&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt;, and &lt;code&gt;expr--&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt;. Therefore, the result of postfix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is an rvalue just before the side effect has been effected.</source>
          <target state="translated">Встроенные постфиксные унарные выражения &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; оцениваются так, как если бы они понижались (переписывались) к лямбда-вызовам следующим образом: &lt;code&gt;expr++&lt;/code&gt; становится &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt; , и &lt;code&gt;expr--&lt;/code&gt; становится &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt; . Таким образом, результат postfix &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; является значением непосредственно перед тем, как побочный эффект был достигнут.</target>
        </trans-unit>
        <trans-unit id="140a63c50a697c2475ba756ea1b637cf7b49226e" translate="yes" xml:space="preserve">
          <source>Built-in prefix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to assignments as follows: &lt;code&gt;++expr&lt;/code&gt; becomes &lt;code&gt;((expr) += 1)&lt;/code&gt;, and &lt;code&gt;--expr&lt;/code&gt; becomes &lt;code&gt;((expr) -= 1)&lt;/code&gt;. Therefore, the result of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is the lvalue after the side effect has been effected.</source>
          <target state="translated">Встроенные префиксы унарных выражений &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; оцениваются так, как будто они понижены (переписаны) для присваиваний следующим образом: &lt;code&gt;++expr&lt;/code&gt; становится &lt;code&gt;((expr) += 1)&lt;/code&gt; , а &lt;code&gt;--expr&lt;/code&gt; становится &lt;code&gt;((expr) -= 1)&lt;/code&gt; , Таким образом, результат префикса &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; это lvalue после побочного эффекта.</target>
        </trans-unit>
        <trans-unit id="f4ef630934a7f1267240a157c0264f348c4dadf3" translate="yes" xml:space="preserve">
          <source>Built-in threading (e.g. &lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt;&lt;code&gt;core.thread&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Встроенные потоки (например, &lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt; &lt;code&gt;core.thread&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="738019c18e7d3c678f51b2d2bb9de596778335f1" translate="yes" xml:space="preserve">
          <source>Builtin SIMD intrinsics</source>
          <target state="translated">Встроенные SIMD</target>
        </trans-unit>
        <trans-unit id="809be9a33e4a381b76b3f2392efbde90e7cac474" translate="yes" xml:space="preserve">
          <source>Builtin mathematical intrinsics</source>
          <target state="translated">Строительная математика</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="aee13f098c3fbc98d67893709d2f60dddc7f25f1" translate="yes" xml:space="preserve">
          <source>But the precision of &lt;code&gt;StopWatch&lt;/code&gt; differs from system to system. It is impossible to for it to be the same from system to system since the precision of the system clock varies from system to system, and other system-dependent and situation-dependent stuff (such as the overhead of a context switch between threads) can also affect &lt;code&gt;StopWatch&lt;/code&gt;'s accuracy.</source>
          <target state="translated">Но точность &lt;code&gt;StopWatch&lt;/code&gt; отличается от системы к системе. Невозможно, чтобы он был одинаковым для разных систем, поскольку точность системных часов варьируется от системы к системе, и другие зависящие от системы и зависящие от ситуации вещи (такие как издержки переключения контекста между потоками) могут также влияет на точность &lt;code&gt;StopWatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="768690cb6415ff721efd279bcb993c49ad663947" translate="yes" xml:space="preserve">
          <source>But, if one context is indirectly accessible from other context, it is allowed.</source>
          <target state="translated">Но,если один контекст косвенно доступен из другого контекста,то это разрешено.</target>
        </trans-unit>
        <trans-unit id="bbd7cb5dd010de18293afcbf1ef490f5cd753c28" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because these names have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. Using all lower case package and module names will avoid or minimize problems when moving projects between dissimilar file systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45921646718dbb6e00896e143e95be14de95c04" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because those names can have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. All lower case package and module names will minimize problems moving projects between dissimilar file systems.</source>
          <target state="translated">По условию,имена пакетов и модулей в нижнем регистре.Это связано с тем,что эти имена могут иметь однозначное соответствие с именами каталогов и файлов операционной системы,и многие файловые системы не чувствительны к регистру.Все нижние регистры имен пакетов и модулей минимизируют проблемы переноса проектов между разными файловыми системами.</target>
        </trans-unit>
        <trans-unit id="2f986e628567a153d5373360f16e912e237bc63a" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;StoppingPolicy&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt;.</source>
          <target state="translated">По умолчанию для &lt;code&gt;StoppingPolicy&lt;/code&gt; установлено значение &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8a76e2827ccb54962a847a022109fb17e84070" translate="yes" xml:space="preserve">
          <source>By default a request has it's &quot;User-Agent&quot; field set to &lt;a href=&quot;#%20defaultUserAgent&quot;&gt;&lt;code&gt; defaultUserAgent&lt;/code&gt;&lt;/a&gt; even if &lt;code&gt;setUserAgent&lt;/code&gt; was never called. Pass an empty string to suppress the &quot;User-Agent&quot; field altogether.</source>
          <target state="translated">По умолчанию для запроса в поле &amp;laquo;User-Agent&amp;raquo; установлено значение &lt;a href=&quot;#%20defaultUserAgent&quot;&gt; &lt;code&gt; defaultUserAgent&lt;/code&gt; ,&lt;/a&gt; даже если &lt;code&gt;setUserAgent&lt;/code&gt; никогда не вызывался. Передайте пустую строку, чтобы полностью исключить поле &amp;laquo;Пользователь-агент&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="478b0d271a29c1d5ae05535cd04bb959cef13353" translate="yes" xml:space="preserve">
          <source>By default an &lt;code&gt;Error&lt;/code&gt; will be thrown.</source>
          <target state="translated">По умолчанию выдается &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6de89d666cfcbf1e2d91df4f90cb3d04defa9a2" translate="yes" xml:space="preserve">
          <source>By default four &lt;code&gt;Logger&lt;/code&gt; implementations are given. The &lt;code&gt;FileLogger&lt;/code&gt; logs data to files. It can also be used to log to &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; as these devices are files as well. A &lt;code&gt;Logger&lt;/code&gt; that logs to &lt;code&gt;stdout&lt;/code&gt; can therefore be created by &lt;code&gt;new FileLogger(stdout)&lt;/code&gt;. The &lt;code&gt;MultiLogger&lt;/code&gt; is basically an associative array of &lt;code&gt;string&lt;/code&gt;s to &lt;code&gt;Logger&lt;/code&gt;. It propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;ArrayLogger&lt;/code&gt; contains an array of &lt;code&gt;Logger&lt;/code&gt; and also propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;NullLogger&lt;/code&gt; does not do anything. It will never log a message and will never throw on a log call with &lt;code&gt;LogLevel&lt;/code&gt;&lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">По умолчанию приведены четыре реализации &lt;code&gt;Logger&lt;/code&gt; . &lt;code&gt;FileLogger&lt;/code&gt; записывает данные в файлы. Его также можно использовать для входа в &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; ,так как эти устройства также являются файлами. &lt;code&gt;Logger&lt;/code&gt; , что журналы в &lt;code&gt;stdout&lt;/code&gt; , следовательно , может быть создан &lt;code&gt;new FileLogger(stdout)&lt;/code&gt; . &lt;code&gt;MultiLogger&lt;/code&gt; в основном ассоциативный массив &lt;code&gt;string&lt;/code&gt; s в &lt;code&gt;Logger&lt;/code&gt; . Он передает вызовы журнала в свой сохраненный &lt;code&gt;Logger&lt;/code&gt; . &lt;code&gt;ArrayLogger&lt;/code&gt; содержит массив &lt;code&gt;Logger&lt;/code&gt; , а также распространяет журнал звонков на его хранящегося &lt;code&gt;Logger&lt;/code&gt; . &lt;code&gt;NullLogger&lt;/code&gt; ничего не делает. Он никогда не будет регистрировать сообщение и никогда не вызовет журнал с &lt;code&gt;error&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ef4ca6979d9539ab9bd7cee842dec5c1148639b" translate="yes" xml:space="preserve">
          <source>By default it is conservatively assumed that allocated memory may be &lt;code&gt;cast&lt;/code&gt; to &lt;code&gt;shared&lt;/code&gt;, passed across threads, and deallocated in a different thread than the one that allocated it. If that's not the case, there are two options. First, &lt;code&gt;immutableShared&lt;/code&gt; means the memory is allocated for &lt;code&gt;immutable&lt;/code&gt; data and will be deallocated in the same thread it was allocated in. Second, &lt;code&gt;threadLocal&lt;/code&gt; means the memory is not to be shared across threads at all. The two flags cannot be simultaneously present.</source>
          <target state="translated">По умолчанию консервативно предполагается, что выделенная память может быть &lt;code&gt;cast&lt;/code&gt; в &lt;code&gt;shared&lt;/code&gt; , переданную между потоками и освобождена в другом потоке, чем тот, который ее выделил. Если это не так, есть два варианта. Во-первых, &lt;code&gt;immutableShared&lt;/code&gt; означает, что память выделена для &lt;code&gt;immutable&lt;/code&gt; данных и будет освобождена в том же потоке, в котором она была выделена. Во-вторых, &lt;code&gt;threadLocal&lt;/code&gt; означает, что память вообще не должна распределяться между потоками. Два флага не могут присутствовать одновременно.</target>
        </trans-unit>
        <trans-unit id="6f5b3a15a485cfab1e5a75e1fa6e376cde7fb92a" translate="yes" xml:space="preserve">
          <source>By default options are case-insensitive. You can change that behavior by passing &lt;code&gt;getopt&lt;/code&gt; the &lt;code&gt;caseSensitive&lt;/code&gt; directive like this:</source>
          <target state="translated">По умолчанию параметры регистрозависимы. Вы можете изменить это поведение, передав &lt;code&gt;getopt&lt;/code&gt; в &lt;code&gt;caseSensitive&lt;/code&gt; директивы , как это:</target>
        </trans-unit>
        <trans-unit id="dbec3e9c45747840b24455eb80ba1df0a750e9ae" translate="yes" xml:space="preserve">
          <source>By default the garbage collector uses all available CPU cores to mark the heap.</source>
          <target state="translated">По умолчанию сборщик мусора использует все доступные ядра процессора для маркировки кучи.</target>
        </trans-unit>
        <trans-unit id="b8fa023c2d92a0d81832e9bd89d175d5927659d9" translate="yes" xml:space="preserve">
          <source>By default, GC options can only be passed on the command line of the program to run, e.g.</source>
          <target state="translated">По умолчанию опции GC могут быть переданы только в командной строке программы для запуска,например</target>
        </trans-unit>
        <trans-unit id="8b24a9b44aee4758b90d689774f561a91ccfd9f7" translate="yes" xml:space="preserve">
          <source>By default, a string literal is typed as a dynamic array, but the element count is known at compile time. So all string literals can be implicitly converted to static array types.</source>
          <target state="translated">По умолчанию строковый литерал типизируется как динамический массив,но количество элементов известно во время компиляции.Поэтому все строковые литералы могут быть неявно преобразованы в статические типы массивов.</target>
        </trans-unit>
        <trans-unit id="8bdaa68e3c22ff7ff0194a0456f12cfccad4e7b3" translate="yes" xml:space="preserve">
          <source>By default, an array literal is typed as a dynamic array, but the element count is known at compile time. So all array literals can be implicitly converted to static array types.</source>
          <target state="translated">По умолчанию литерал массива типизируется как динамический массив,но количество элементов известно во время компиляции.Поэтому все массивные литералы могут быть неявно преобразованы в статические типы массивов.</target>
        </trans-unit>
        <trans-unit id="22091b5b2cb326fb7704d38d801e2ea343fe0a4b" translate="yes" xml:space="preserve">
          <source>By default, imports are</source>
          <target state="translated">По умолчанию,импорт</target>
        </trans-unit>
        <trans-unit id="f143feea6dee31aa56bf9053dddf3e0e772b7f34" translate="yes" xml:space="preserve">
          <source>By default, non-immutable global declarations reside in thread local storage. When a global variable is marked with the &lt;code&gt;__gshared&lt;/code&gt; attribute, its value is shared across all threads.</source>
          <target state="translated">По умолчанию неизменяемые глобальные объявления находятся в локальном хранилище потока. Когда глобальная переменная помечается атрибутом &lt;code&gt;__gshared&lt;/code&gt; , ее значение является общим для всех потоков.</target>
        </trans-unit>
        <trans-unit id="aad3d8313e40930c344804ce8ccc20bf40a3e89a" translate="yes" xml:space="preserve">
          <source>By default, parameters take rvalue arguments. A ref parameter takes an lvalue argument, so changes to its value will operate on the caller's argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079ae70c5ecf861c3729c19e224c7956b1bb4ed1" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#execute&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt; functions will capture child processes' both stdout and stderr. This can be undesirable if the standard output is to be processed or otherwise used by the invoking program, as &lt;code&gt;execute&lt;/code&gt;'s result would then contain a mix of output and warning/error messages.</source>
          <target state="translated">По умолчанию функции &lt;a href=&quot;#execute&quot;&gt; &lt;code&gt;execute&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt; будут захватывать дочерние процессы как stdout, так и stderr. Это может быть нежелательным , если стандартный вывод должны быть обработан или иным образом используется программой вызывающей, так как &lt;code&gt;execute&lt;/code&gt; результат &amp;laquo;s будет содержать смесь вывода и предупреждения / сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="5c5dc33ccdd6fb02e11d57deb9c037003d388703" translate="yes" xml:space="preserve">
          <source>By default, the above will print:</source>
          <target state="translated">По умолчанию будет выполнена печать:</target>
        </trans-unit>
        <trans-unit id="2a431b7902a6f8a61040ea86e57ea9fd88c07b45" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the environment of the parent process, along with any additional variables specified in the &lt;code&gt;env&lt;/code&gt; parameter. If the same variable exists in both the parent's environment and in &lt;code&gt;env&lt;/code&gt;, the latter takes precedence.</source>
          <target state="translated">По умолчанию дочерний процесс наследует среду родительского процесса вместе с любыми дополнительными переменными, указанными в параметре &lt;code&gt;env&lt;/code&gt; . Если одна и та же переменная существует как в родительской среде, так и в &lt;code&gt;env&lt;/code&gt; , последняя имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="00f97c90e4779d49bd0154dcbe3ccd270b7c1a5c" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the parent's environment, and any environment variables passed to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; will be added to it. If this flag is set, the only variables in the child process' environment will be those given to spawnProcess.</source>
          <target state="translated">По умолчанию дочерний процесс наследует родительскую среду, и любые переменные среды, переданные в &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; ,&lt;/a&gt; будут добавлены в него. Если этот флаг установлен, единственными переменными в среде дочернего процесса будут те, которые переданы spawnProcess.</target>
        </trans-unit>
        <trans-unit id="164f65e6c4e1ffea6984f3be9b15c6fd4fcd5bd7" translate="yes" xml:space="preserve">
          <source>By default, the return type is time_t (which is normally an alias for int on 32-bit systems and long on 64-bit systems), but if a different size is required than either int or long can be passed as a template argument to get the desired size.</source>
          <target state="translated">По умолчанию типом возврата является time_t (обычно это псевдоним для int на 32-битных системах и long на 64-битных),но если требуется другой размер,чем int или long,то для получения желаемого размера в качестве аргумента шаблона может быть передан параметр time_t.</target>
        </trans-unit>
        <trans-unit id="887970dcbfc9d8811c8813f736813ed286b7d258" translate="yes" xml:space="preserve">
          <source>By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the</source>
          <target state="translated">По умолчанию режим округления RoundToNearest и все аппаратные исключения отключены.Для большинства приложений,отладка проще,если в</target>
        </trans-unit>
        <trans-unit id="6e33332413c374faf23d6382e0a46b9fcaf1aadb" translate="yes" xml:space="preserve">
          <source>By definition, empty ranges are matched fully and if &lt;code&gt;needles&lt;/code&gt; contains an empty range, &lt;code&gt;skipOver&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">По определению, пустые диапазоны полностью совпадают, и если &lt;code&gt;needles&lt;/code&gt; содержат пустой диапазон, &lt;code&gt;skipOver&lt;/code&gt; вернет &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ce83358e38997bfd068876bacbbbb4077fd36b" translate="yes" xml:space="preserve">
          <source>By definition, if a pre contract fails, then the function received bad parameters. If a post contract fails, then there is a bug in the function. In either case, an &lt;code&gt;assert&lt;/code&gt; statement within the corresponding &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; block will throw an &lt;code&gt;AssertError&lt;/code&gt;.</source>
          <target state="translated">По определению, если предварительный контракт не выполняется, функция получила неверные параметры. Если почтовый контракт не выполняется, значит, в функции есть ошибка. В любом случае оператор &lt;code&gt;assert&lt;/code&gt; в соответствующем блоке &lt;code&gt;in&lt;/code&gt; или &lt;code&gt;out&lt;/code&gt; генерирует &lt;code&gt;AssertError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb96c2ff58da640b614e1d83a03d1ae961343b00" translate="yes" xml:space="preserve">
          <source>By fixing &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; opEquals is changed to be never implicitly generated. Now, struct objects comparison s1 == s2 is translated to: s1.tupleof == s2.tupleof to calculate structural equality. See EqualExp.op_overload.</source>
          <target state="translated">Устанавливая &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; opEquals изменяется не будет никогда неявно генерируется. Теперь сравнение объектов struct s1 == s2 переводится в: s1.tupleof == s2.tupleof для вычисления структурного равенства. Смотрите EqualExp.op_overload.</target>
        </trans-unit>
        <trans-unit id="aac8d772d9fb45f1ebe981cf3bff581d81f0a9a1" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;std_utf#byUTF&quot;&gt;&lt;code&gt;std.utf.byUTF&lt;/code&gt;&lt;/a&gt; and its aliases, GC allocations via auto-decoding and thrown exceptions can be avoided, making &lt;code&gt;icmp&lt;/code&gt;&lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt;.</source>
          <target state="translated">Используя &lt;a href=&quot;std_utf#byUTF&quot;&gt; &lt;code&gt;std.utf.byUTF&lt;/code&gt; &lt;/a&gt; и его псевдонимы, можно избежать выделения GC с помощью автоматического декодирования и &lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt; исключений, что делает &lt;code&gt;icmp&lt;/code&gt; @safe @nogc nothrow pure .</target>
        </trans-unit>
        <trans-unit id="bc291c2891b81ab141f345fa0230adb20fd10cd9" translate="yes" xml:space="preserve">
          <source>Byte order endianness.</source>
          <target state="translated">Эндианство по байтовому порядку.</target>
        </trans-unit>
        <trans-unit id="1eb54b97f13d87edcd6a934d982b6f81fb1b387f" translate="yes" xml:space="preserve">
          <source>Byte order, least significant first</source>
          <target state="translated">Порядок байтов,наименее значимый первый</target>
        </trans-unit>
        <trans-unit id="b59f4e1ab4662646945739f875a2dc8274ccd34b" translate="yes" xml:space="preserve">
          <source>Byte order, most significant first</source>
          <target state="translated">Байтовый порядок,наиболее значимый первый</target>
        </trans-unit>
        <trans-unit id="0c1f86b6eef786b75f48b5164472c5f379f29825" translate="yes" xml:space="preserve">
          <source>Byte value in hexadecimal, where</source>
          <target state="translated">Байтовое значение в шестнадцатеричной системе,где</target>
        </trans-unit>
        <trans-unit id="f4e5cf625ea1bf16e64b237498429dc72e94863d" translate="yes" xml:space="preserve">
          <source>Byte value in octal.</source>
          <target state="translated">Значение байта в восьмеричном исчислении.</target>
        </trans-unit>
        <trans-unit id="a58fed109fdbc425c9e3e299c4f472aa1e81b9e2" translate="yes" xml:space="preserve">
          <source>Bytes (not items) to be allocated for the free list. Memory will be allocated during construction and deallocated in the destructor.</source>
          <target state="translated">Байты (не пункты),которые должны быть выделены для бесплатного списка.Память будет выделена при построении и разложена в деструкторе.</target>
        </trans-unit>
        <trans-unit id="b2e625cfca365b6f5ed6d88821a2c881a6679253" translate="yes" xml:space="preserve">
          <source>Bytes to allocate</source>
          <target state="translated">Байты для выделения</target>
        </trans-unit>
        <trans-unit id="2eadc64c1cdbc5d6ca752a0b38f5f0a02d05c4b1" translate="yes" xml:space="preserve">
          <source>Bytes to allocate using &lt;code&gt;ParentAllocator&lt;/code&gt;. This constructor is only defined If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;parent.allocate(n)&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the region will be initialized as empty (correctly initialized but unable to allocate).</source>
          <target state="translated">Байты для выделения с использованием &lt;code&gt;ParentAllocator&lt;/code&gt; . Этот конструктор определяется только в том случае, если &lt;code&gt;ParentAllocator&lt;/code&gt; отличается от &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;parent.allocate(n)&lt;/code&gt; возвращает &lt;code&gt;null&lt;/code&gt; , область будет инициализирован как пустой (правильно инициализирован , но не в состоянии выделить).</target>
        </trans-unit>
        <trans-unit id="d3fc47eb5e867c1a90c1c6140022201511e39c13" translate="yes" xml:space="preserve">
          <source>Byzantine Musical Symbols</source>
          <target state="translated">Византийские музыкальные символы</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="91ab2886a8945715f467ad2616dd5309295ba114" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">C &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="922a6aa3cb89e34ea72fe9d27effc2df259df392" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;create&lt;/code&gt;</source>
          <target state="translated">С &lt;code&gt;create&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9652018eda95d6aa3dab8e093571b39cf52c2264" translate="yes" xml:space="preserve">
          <source>C ABI</source>
          <target state="translated">C ABI</target>
        </trans-unit>
        <trans-unit id="f824a58327e609cd9fdba23fe1a3c84c364898ea" translate="yes" xml:space="preserve">
          <source>C code can correspondingly call D functions, if the D functions use an attribute that is compatible with the C compiler, most likely the extern (C):</source>
          <target state="translated">Код на Си может соответственно вызывать функции D,если функции D используют атрибут,совместимый с компилятором Си,скорее всего,extern (C):</target>
        </trans-unit>
        <trans-unit id="0ffb7f8837c1a11eeb25850dd4e1e4ef9b573509" translate="yes" xml:space="preserve">
          <source>C code explicitly manages memory with calls to &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc()&lt;/a&gt; and &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free()&lt;/a&gt;. D allocates memory using the D garbage collector, so no explicit frees are necessary.</source>
          <target state="translated">Код C явно управляет памятью с помощью вызовов &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc ()&lt;/a&gt; и &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free ()&lt;/a&gt; . D выделяет память, используя сборщик мусора D, поэтому явных освобождений не требуется.</target>
        </trans-unit>
        <trans-unit id="d221b852c9ebec0058ed069c0351edaaeb33622d" translate="yes" xml:space="preserve">
          <source>C code often adjusts the alignment and packing of struct members with a command line switch or with various implementation specific #pragmas. D supports explicit alignment attributes that correspond to the C compiler's rules. Check what alignment the C code is using, and explicitly set it for the D struct declaration.</source>
          <target state="translated">Код на C часто регулирует выравнивание и упаковку членов структуры с помощью переключателя командной строки или с помощью различных #pragmas,специфичных для реализации.D поддерживает явные атрибуты выравнивания,соответствующие правилам компилятора Си.Проверьте,какое выравнивание используется в Си-коде,и явно задайте его для объявления структуры D.</target>
        </trans-unit>
        <trans-unit id="ad0081e0fe0dd4d8c8faa110d448e18b099251c6" translate="yes" xml:space="preserve">
          <source>C function calling conventions are specified by:</source>
          <target state="translated">Условия вызова функций C задаются:</target>
        </trans-unit>
        <trans-unit id="7bbdeb583f7af40df326e5ef45b5341310bfa3a8" translate="yes" xml:space="preserve">
          <source>C functions can be called directly from D. There is no need for wrapper functions, argument swizzling, and the C functions do not need to be put into a separate DLL.</source>
          <target state="translated">Функции C можно вызывать непосредственно из D.Нет необходимости в функциях обертки,пролистывания аргументов,а функции C не нужно помещать в отдельную DLL.</target>
        </trans-unit>
        <trans-unit id="391732c6d45f595037ed6d3acf61093990d2af4d" translate="yes" xml:space="preserve">
          <source>C functions cannot be overloaded with another C function with the same name.</source>
          <target state="translated">Функции C не могут быть перегружены другой функцией C с тем же именем.</target>
        </trans-unit>
        <trans-unit id="5f547f273af63b8119db89b56d4a8680c878d370" translate="yes" xml:space="preserve">
          <source>C globals can be accessed directly from D. C globals have the C naming convention, and so must be in an &lt;code&gt;extern (C)&lt;/code&gt; block. Use the &lt;code&gt;extern&lt;/code&gt; storage class to indicate that the global is allocated in the C code, not the D code. C globals default to being in global, not thread local, storage. To reference global storage from D, use the &lt;code&gt;__gshared&lt;/code&gt; storage class.</source>
          <target state="translated">Доступ к глобалам C можно получить непосредственно из D. Глобалы C имеют соглашение по именованию C, поэтому должны находиться в &lt;code&gt;extern (C)&lt;/code&gt; блоке. Используйте класс &lt;code&gt;extern&lt;/code&gt; хранилища, чтобы указать, что глобальное выделено в коде C, а не в коде D. По умолчанию, глобальные C-ресурсы находятся в глобальном, а не локальном потоке. Чтобы ссылаться на глобальное хранилище из D, используйте &lt;code&gt;__gshared&lt;/code&gt; хранилища __gshared .</target>
        </trans-unit>
        <trans-unit id="088f42af395914ff1b11b211001ff8dc3bfb47de" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.initialize, returns 1/0 instead of bool</source>
          <target state="translated">C-интерфейс для инициализации Runtime.initialize,возвращает 1/0 вместо bool.</target>
        </trans-unit>
        <trans-unit id="dc4b969769a12fb03185e79820cbdb1188eba5a6" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.loadLibrary</source>
          <target state="translated">C-интерфейс для Runtime.loadLibrary</target>
        </trans-unit>
        <trans-unit id="1ba4ae2523a2983e2479e8220f1eed45cabbda41" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.terminate, returns 1/0 instead of bool</source>
          <target state="translated">C-интерфейс для Runtime.termination,возвращает 1/0 вместо bool.</target>
        </trans-unit>
        <trans-unit id="8ebac48238568ab95c4c5ad69ed5cd780269c53c" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.unloadLibrary, returns 1/0 instead of bool</source>
          <target state="translated">C интерфейс для Runtime.unloadLibrary,возвращает 1/0 вместо bool.</target>
        </trans-unit>
        <trans-unit id="86cf735b5a9e30aaa5f0fee060cea7d39ebc4f60" translate="yes" xml:space="preserve">
          <source>C library routines. See callclib().</source>
          <target state="translated">Библиотека С.См.callclib().</target>
        </trans-unit>
        <trans-unit id="c1ff5ead3c46826c14b71159d580aef25ffbf060" translate="yes" xml:space="preserve">
          <source>C name mangling is done by adding a prefix on some platforms.</source>
          <target state="translated">Изменение имени на C осуществляется путем добавления префикса на некоторых платформах.</target>
        </trans-unit>
        <trans-unit id="126f7b78af09df06aa9df51a74fef4005eae1de9" translate="yes" xml:space="preserve">
          <source>C style variadic function</source>
          <target state="translated">вариадическая функция стиля С</target>
        </trans-unit>
        <trans-unit id="dd58d1bb166ddedbf2d0eda882e81a02524b0fbc" translate="yes" xml:space="preserve">
          <source>C#'s &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;embedded XML&lt;/a&gt;</source>
          <target state="translated">C # &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;встроенный XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34cf1ff3bbe582bde426d598f3ad72cfcc2d599c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;free&lt;/code&gt; does not have a safe interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd30234820540d843ae13b550abfa205649ae3c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;malloc&lt;/code&gt; does have a safe interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0143508b7b64b86b3401c85034e750942cedf11" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;strlen&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; do not have safe interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0548c5e650e5d6686abc5b2a04b9371833fa90" translate="yes" xml:space="preserve">
          <source>C's printf() and Strings</source>
          <target state="translated">C's printf()и Strings</target>
        </trans-unit>
        <trans-unit id="4f540b0aaef1641b1d80a5208b7c055e606bf72a" translate="yes" xml:space="preserve">
          <source>C++ Interfaces</source>
          <target state="translated">интерфейсы C++</target>
        </trans-unit>
        <trans-unit id="f1642c1a4e4dce54c68aa20addb027e83adf0715" translate="yes" xml:space="preserve">
          <source>C++ Namespaces</source>
          <target state="translated">C++Пространства имён</target>
        </trans-unit>
        <trans-unit id="c5cb41022921444e105840eeb5b0879ab0ff1d75" translate="yes" xml:space="preserve">
          <source>C++ Support</source>
          <target state="translated">Поддержка C++</target>
        </trans-unit>
        <trans-unit id="f9f27585ae5da3fc2a761861b44ded6adf3015ec" translate="yes" xml:space="preserve">
          <source>C++ Templates</source>
          <target state="translated">Шаблоны C++</target>
        </trans-unit>
        <trans-unit id="7e28b0c0a074b69119fdaf750d5061c6c3eed943" translate="yes" xml:space="preserve">
          <source>C++ allows a struct to inherit from a base struct. This is done in D using &lt;code&gt;alias this&lt;/code&gt;:</source>
          <target state="translated">C ++ позволяет структуре наследоваться от базовой структуры. Это делается в D с использованием &lt;code&gt;alias this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="270c92d90f5419eb56fc78a11ccc1e3fb6e75988" translate="yes" xml:space="preserve">
          <source>C++ and D follow different rules for function overloading. D source code, even when calling &lt;code&gt;extern (C++)&lt;/code&gt; functions, will still follow D overloading rules.</source>
          <target state="translated">C ++ и D следуют различным правилам перегрузки функций. Исходный код D, даже при вызове функций &lt;code&gt;extern (C++)&lt;/code&gt; , все равно будет следовать правилам перегрузки D.</target>
        </trans-unit>
        <trans-unit id="803c33c0bd9c5c8e423f248219c12fcafd72a234" translate="yes" xml:space="preserve">
          <source>C++ can open the same namespace in the same file and multiple files. In D, this can be done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9777d8f776f92bf25e9cab083b49833d4a402d3" translate="yes" xml:space="preserve">
          <source>C++ class</source>
          <target state="translated">класс С++</target>
        </trans-unit>
        <trans-unit id="bc6ef19080a44be47740e7c8ef1fb2da8b514001" translate="yes" xml:space="preserve">
          <source>C++ classes can be declared in D by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; declarations. &lt;code&gt;extern (C++)&lt;/code&gt; interfaces have the same restrictions as D interfaces, which means that Multiple Inheritance is supported to the extent that only one base class can have member fields.</source>
          <target state="translated">Классы C ++ могут быть объявлены в D с помощью атрибута &lt;code&gt;extern (C++)&lt;/code&gt; в объявлениях &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; и &lt;code&gt;interface&lt;/code&gt; . Интерфейсы &lt;code&gt;extern (C++)&lt;/code&gt; имеют те же ограничения, что и интерфейсы D, что означает, что множественное наследование поддерживается в той степени, в которой только один базовый класс может иметь поля-члены.</target>
        </trans-unit>
        <trans-unit id="2696fbb29a2404060229a5c0ef4dcf0d930ebf5a" translate="yes" xml:space="preserve">
          <source>C++ code explicitly manages memory with calls to &lt;code&gt;::operator new()&lt;/code&gt; and &lt;code&gt;::operator delete()&lt;/code&gt;. D's &lt;code&gt;new&lt;/code&gt; operator allocates memory using the D garbage collector, so no explicit delete is necessary. D's &lt;code&gt;new&lt;/code&gt; operator is not compatible with C++'s &lt;code&gt;::operator new&lt;/code&gt; and &lt;code&gt;::operator delete&lt;/code&gt;. Attempting to allocate memory with D's &lt;code&gt;new&lt;/code&gt; and deallocate with C++ &lt;code&gt;::operator delete&lt;/code&gt; will result in miserable failure.</source>
          <target state="translated">Код C ++ явно управляет памятью с помощью вызовов &lt;code&gt;::operator new()&lt;/code&gt; и &lt;code&gt;::operator delete()&lt;/code&gt; . Двойки &lt;code&gt;new&lt;/code&gt; оператор выделяет память , используя D сборщик мусора, поэтому нет явного удаления необходимо. &lt;code&gt;new&lt;/code&gt; оператор D не совместим с C ++ &lt;code&gt;::operator new&lt;/code&gt; и &lt;code&gt;::operator delete&lt;/code&gt; . Попытка выделить память с &lt;code&gt;new&lt;/code&gt; D и освободить с помощью C ++ &lt;code&gt;::operator delete&lt;/code&gt; приведет к жалкому сбою.</target>
        </trans-unit>
        <trans-unit id="bc28c8a3178ea35aefa2bc7cad45f485c5c7f436" translate="yes" xml:space="preserve">
          <source>C++ constructors, copy constructors, move constructors and destructors cannot be called directly in D code, and D constructors, postblit operators and destructors cannot be directly exported to C++ code. Interoperation of types with these special operators is possible by either 1) disabling the operator in the client language and only using it in the host language, or 2) faithfully reimplementing the operator in the client language. With the latter approach, care needs to be taken to ensure observable semantics remain the same with both implementations, which can be difficult, or in some edge cases impossible, due to differences in how the operators work in the two languages. For example, in D all objects are movable and there is no move constructor.</source>
          <target state="translated">Конструкторы C++,конструкторы копирования,конструкторы перемещения и деструкторы не могут быть вызваны непосредственно в D-коде,а конструкторы D,постоблитные операторы и деструкторы не могут быть напрямую экспортированы в C++код.Взаимодействие типов с этими специальными операторами возможно либо 1)отключением оператора на клиентском языке и использованием его только на хост-языке,либо 2)добросовестным переопределением оператора на клиентском языке.При последнем подходе необходимо позаботиться о том,чтобы наблюдаемая семантика оставалась одинаковой в обеих реализациях,что может быть затруднительно,а в некоторых крайних случаях невозможно из-за различий в работе операторов на двух языках.Например,в D все объекты являются подвижными и отсутствует конструктор перемещения.</target>
        </trans-unit>
        <trans-unit id="7201ae364cc48822a82b73b893189a5dd94aef18" translate="yes" xml:space="preserve">
          <source>C++ function and type templates can be bound by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on a function or type template declaration.</source>
          <target state="translated">Шаблоны функций и типов C ++ могут быть связаны с помощью атрибута &lt;code&gt;extern (C++)&lt;/code&gt; в объявлении шаблона функции или типа.</target>
        </trans-unit>
        <trans-unit id="b5593ddf6c58f1012fa7ffeb46813794152a771a" translate="yes" xml:space="preserve">
          <source>C++ global functions, including those in namespaces, can be declared and called in D, or defined in D and called in C++.</source>
          <target state="translated">Глобальные функции C++,в том числе и в пространствах имен,могут быть объявлены и вызваны в D,или определены в D и вызваны в C++.</target>
        </trans-unit>
        <trans-unit id="4e9e4356221d1ee2aa897fff7328f9ee52314134" translate="yes" xml:space="preserve">
          <source>C++ interfaces are interfaces declared with C++ linkage:</source>
          <target state="translated">Интерфейсы C++-это интерфейсы,объявленные со связью C++:</target>
        </trans-unit>
        <trans-unit id="5099e4c841655b922a765e68cbf8aefc57d5356e" translate="yes" xml:space="preserve">
          <source>C++ namespace this symbol belongs to</source>
          <target state="translated">Пространство имён C++этот символ принадлежит</target>
        </trans-unit>
        <trans-unit id="c6f5200183cdf7ce197fbb3bc50824c16c47152a" translate="yes" xml:space="preserve">
          <source>C++ reference:</source>
          <target state="translated">Ссылка на C++:</target>
        </trans-unit>
        <trans-unit id="912b136567cd7cbd9fc8f323d5606bbe39d07750" translate="yes" xml:space="preserve">
          <source>C++ symbols that reside in namespaces can be accessed from D. A &lt;a href=&quot;attribute#namespace&quot;&gt;namespace&lt;/a&gt; can be added to the &lt;code&gt;extern (C++)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute&lt;/a&gt;:</source>
          <target state="translated">К символам C ++, находящимся в пространствах имен, можно получить доступ из D. &lt;a href=&quot;attribute#linkage&quot;&gt;Пространство &lt;/a&gt;&lt;a href=&quot;attribute#namespace&quot;&gt;имен&lt;/a&gt; может быть добавлено к &lt;code&gt;extern (C++)&lt;/code&gt; LinkageAttribute :</target>
        </trans-unit>
        <trans-unit id="2f98b3c489784aabeb7da68a1d1411495ec51290" translate="yes" xml:space="preserve">
          <source>C++'s make_shared</source>
          <target state="translated">С++'s make_shared</target>
        </trans-unit>
        <trans-unit id="588f44e70bf472a1f45f7efcfa562168c8457c0a" translate="yes" xml:space="preserve">
          <source>C-style Variadic Functions</source>
          <target state="translated">Вариадические функции в стиле С</target>
        </trans-unit>
        <trans-unit id="d5ccb24bc3ad9fc7c10cfe2824e9cb190ac91f9d" translate="yes" xml:space="preserve">
          <source>C-style array, function pointer and pointer to array declarations are deprecated:</source>
          <target state="translated">Массив в стиле C,указатель функции и указатель на объявления массива устарели:</target>
        </trans-unit>
        <trans-unit id="f0848a8145c311481df53130b777fe467332d312" translate="yes" xml:space="preserve">
          <source>C-style octal integer notation was deemed too easy to mix up with decimal notation; it is only fully supported in string literals. D still supports octal integer literals interpreted at compile time through the &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt;&lt;code&gt;std.conv.octal&lt;/code&gt;&lt;/a&gt; template, as in &lt;code&gt;octal!167&lt;/code&gt;.</source>
          <target state="translated">Считалось, что восьмеричное целочисленное представление в стиле C слишком легко смешивать с десятичным обозначением; он полностью поддерживается только в строковых литералах. D по-прежнему поддерживает восьмеричные целочисленные литералы, интерпретируемые во время компиляции через шаблон &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt; &lt;code&gt;std.conv.octal&lt;/code&gt; &lt;/a&gt; , как в &lt;code&gt;octal!167&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9adf55a50113afd886edb1cbfcea7b8ecf56ed5e" translate="yes" xml:space="preserve">
          <source>C-style semantics on pointer arithmetic are strictly enforced. Pointer arithmetic is permitted only on pointers which point to static or dynamic array elements. Such pointers must point to an element of the array, or to the first element past the array. Pointer arithmetic is completely forbidden on pointers which are null, or which point to a non-array.</source>
          <target state="translated">Семантика в стиле С по арифметике с указателями строго соблюдается.Арифметика с указателями разрешена только на указатели,которые указывают на статические или динамические элементы массива.Такие указатели должны указывать на элемент массива или на первый элемент,проходящий мимо массива.Арифметика указателей полностью запрещена на указатели,которые являются нулевыми или указывают на не массив.</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">вариадические функции в стиле С</target>
        </trans-unit>
        <trans-unit id="77ba44bb9e589c769fa658f005333eee147a4900" translate="yes" xml:space="preserve">
          <source>C-style variadic functions cannot be marked as &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">Variadic-функции в стиле C не могут быть помечены как &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ddb858f8a20b16ac93e15adcc78e42ffbd8db66" translate="yes" xml:space="preserve">
          <source>C-style variadic functions match the C calling convention for variadic functions, and is most useful for calling C library functions like &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">Variadic-функции в стиле C соответствуют соглашению о вызовах C для различных функций и наиболее полезны для вызова функций библиотеки C, таких как &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8818f4ee4a0e406f4fe10b1e03aebaf4d71f3819" translate="yes" xml:space="preserve">
          <source>C1 &lt;code&gt;next&lt;/code&gt;</source>
          <target state="translated">С1 &lt;code&gt;next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30212c965112a877f52f60d83e8ff113ef1b3f96" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; C1</target>
        </trans-unit>
        <trans-unit id="9089e6f07372bce6e832f5f650cb3e7c0c621e3b" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aa0499528f63537a98f340c34d4972647df60e5" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;suffix&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;suffix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c459d7b347295856b421ffb8792a1964353bfe70" translate="yes" xml:space="preserve">
          <source>C1[] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt;(C1, C2, C3, C4 = immutable(char))(C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null);</source>
          <target state="translated">C1 [] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt; (C1, C2, C3, C4 = неизменяемый (символ)) (C1 [] str, const (C2) [] из, const (C3) [] в, const (C4) [] модификаторы = ноль) ;</target>
        </trans-unit>
        <trans-unit id="a0d01d3baedb5ae97bde5874c2012010c575e84c" translate="yes" xml:space="preserve">
          <source>C2 &lt;code&gt;empty&lt;/code&gt;</source>
          <target state="translated">C2 &lt;code&gt;empty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8e1804fe922cd90750831c2c298d54a222ba628" translate="yes" xml:space="preserve">
          <source>C2[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C2 [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b7d328ba78816f38f975bb5147f4c05534a9bc5" translate="yes" xml:space="preserve">
          <source>CAPI3REF</source>
          <target state="translated">CAPI3REF</target>
        </trans-unit>
        <trans-unit id="bd963590f78aa017d53387443be555aa971b1144" translate="yes" xml:space="preserve">
          <source>CData &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">CDATA &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afdd392374481b4db6ac2ce43fdc87d5888fe7e3" translate="yes" xml:space="preserve">
          <source>CDataException if the segment body is illegal (contains &quot;]]&amp;gt;&quot;)</source>
          <target state="translated">CDataException, если тело сегмента недопустимо (содержит &quot;]]&amp;gt;&quot;)</target>
        </trans-unit>
        <trans-unit id="3061e575e355c19788f22cb3d62aa0cd47f40e40" translate="yes" xml:space="preserve">
          <source>CData[] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt;;</source>
          <target state="translated">CData [] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="92b00c2e72a02d322e30292a494b0f77de93d540" translate="yes" xml:space="preserve">
          <source>CJK Compatibility</source>
          <target state="translated">совместимость с CJK</target>
        </trans-unit>
        <trans-unit id="24dc7006e4bfb5dae3e8ea7f01d766f357b0514b" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Forms</source>
          <target state="translated">Формы совместимости CJK</target>
        </trans-unit>
        <trans-unit id="28610435f9d6e37ccd13448891ef635456bc6798" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs</source>
          <target state="translated">Идеографы совместимости CJK</target>
        </trans-unit>
        <trans-unit id="3a3044d64bf35123af4c2034c39688d2f85c3b7d" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs Supplement</source>
          <target state="translated">Приложение к идеографам совместимости CJK</target>
        </trans-unit>
        <trans-unit id="56398f3cc299fcadc8172ed7743fcc8d6604a2b2" translate="yes" xml:space="preserve">
          <source>CJK Radicals Supplement</source>
          <target state="translated">CJK Радикальное приложение</target>
        </trans-unit>
        <trans-unit id="c80daba1e9c50935dee4c69ef20e42e31a63bfcb" translate="yes" xml:space="preserve">
          <source>CJK Strokes</source>
          <target state="translated">инсульты CJK</target>
        </trans-unit>
        <trans-unit id="41d774013768fc4cae9cda6ce11ff4062ab10d65" translate="yes" xml:space="preserve">
          <source>CJK Symbols and Punctuation</source>
          <target state="translated">CJK Символы и пунктуация</target>
        </trans-unit>
        <trans-unit id="a8e25b3246b6d0e0fa06fb72ba766979769141a7" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs</source>
          <target state="translated">CJK Унифицированные идеографы</target>
        </trans-unit>
        <trans-unit id="6370cdf4d714b545f5b7bf4ee34e57e56e359487" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension A</source>
          <target state="translated">CJK Унифицированные идеографы Расширение A</target>
        </trans-unit>
        <trans-unit id="a1724e7543e72f713653f623821483898403f1d0" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension B</source>
          <target state="translated">CJK Унифицированные идеографы Расширение B</target>
        </trans-unit>
        <trans-unit id="71e4356045ae7c85afc88a13e5be97e037f502d4" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension C</source>
          <target state="translated">CJK Унифицированные идеографы Расширение C</target>
        </trans-unit>
        <trans-unit id="de4f53e7b0971e7c4fd9b6b5639b6d9d3d564380" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension D</source>
          <target state="translated">CJK Унифицированные идеографы Расширение D</target>
        </trans-unit>
        <trans-unit id="df31bd94e79946dcd6e346825f4e84b5f0358f50" translate="yes" xml:space="preserve">
          <source>CLI flag without leading &lt;code&gt;-&lt;/code&gt;, e.g. &lt;code&gt;color&lt;/code&gt;</source>
          <target state="translated">Флаг CLI без начального &lt;code&gt;-&lt;/code&gt; например, &lt;code&gt;color&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d78b798fee78a64b81d6899e06efc15c1dccde51" translate="yes" xml:space="preserve">
          <source>COM Interfaces</source>
          <target state="translated">COM-интерфейсы</target>
        </trans-unit>
        <trans-unit id="154721c66d149bb61466c03b8ff3861e25ef38c7" translate="yes" xml:space="preserve">
          <source>COM classes and C++ classes</source>
          <target state="translated">классы COM и C++</target>
        </trans-unit>
        <trans-unit id="ae337737f416d275254734defda66541f870f22e" translate="yes" xml:space="preserve">
          <source>COMPILER INTERFACE /////////////////////</source>
          <target state="translated">ИНТЕРФЕЙС КОМПИЛЯТОРА //////////////////////////.</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="0af12e3ea89b844b314d17c7e3f7bac655ebd0c7" translate="yes" xml:space="preserve">
          <source>CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt;;</source>
          <target state="translated">CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="95fe9c2b68a6150c2538241de478d073b3c01eb6" translate="yes" xml:space="preserve">
          <source>CPU architectures supported -mcpu=id</source>
          <target state="translated">Поддерживаемые архитектуры ЦП -mcpu=id</target>
        </trans-unit>
        <trans-unit id="73c7fc0f09e167cc17d6e2ae64cdb2bc100ca9d7" translate="yes" xml:space="preserve">
          <source>CPUs often support specialized vector types and vector operations (a.k.a.</source>
          <target state="translated">Процессоры часто поддерживают специализированные векторные типы и векторные операции (так же известные,как и CPU).</target>
        </trans-unit>
        <trans-unit id="bf887172139520e2ce3c00abdb93ee2e9fd86211" translate="yes" xml:space="preserve">
          <source>CRC32 of data</source>
          <target state="translated">CRC32 данных</target>
        </trans-unit>
        <trans-unit id="992514a6a8b2e73f449a04615c81ce6686d74551" translate="yes" xml:space="preserve">
          <source>CRC32 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764a2bd592ab90f526cba7f18836f8fb323c69e5" translate="yes" xml:space="preserve">
          <source>CRC64-ECMA of data</source>
          <target state="translated">CRC64-ECMA данных</target>
        </trans-unit>
        <trans-unit id="de219addfefcc2e27f49a3ca6fa5a51d3de19ec6" translate="yes" xml:space="preserve">
          <source>CRC64-ISO of data</source>
          <target state="translated">CRC64-ISO данных</target>
        </trans-unit>
        <trans-unit id="91d96d88652e57b949051060aed04c0c7a55db68" translate="yes" xml:space="preserve">
          <source>CRCs are usually printed with the MSB first. When using &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt; the result will be in an unexpected order. Use &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt;'s optional order parameter to specify decreasing order for the correct result. The &lt;a href=&quot;#crcHexString&quot;&gt;&lt;code&gt;crcHexString&lt;/code&gt;&lt;/a&gt; alias can also be used for this purpose.</source>
          <target state="translated">CRC обычно сначала печатаются с MSB. При использовании &lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; &lt;/a&gt; результат будет в неожиданном порядке. Используйте необязательный параметр порядка &lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; &lt;/a&gt; , чтобы указать убывающий порядок для правильного результата. &lt;a href=&quot;#crcHexString&quot;&gt; &lt;code&gt;crcHexString&lt;/code&gt; &lt;/a&gt; псевдоним также может быть использован для этой цели.</target>
        </trans-unit>
        <trans-unit id="20226dce447690b9ec8699b49af5230d49691790" translate="yes" xml:space="preserve">
          <source>CRL file</source>
          <target state="translated">CRL-файл</target>
        </trans-unit>
        <trans-unit id="9d1c93dd97d25f4c239981585e218bded30a91de" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a402cf31f9cf0e6b5b8a55752e348488f03f726b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9864028d4f462263a4ffef0bfb1252c98316a14b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;csx&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;csx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8934fa932e57010a67e3ca78ffd8b25af059e9" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6cb8e5d0c4fc4c6db7f22e70f099ed917c02dc9a" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;csx&quot;&gt;CSX&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ef70b18a1d95d31d7157c61d4106f2015fb5f903" translate="yes" xml:space="preserve">
          <source>CTFE</source>
          <target state="translated">CTFE</target>
        </trans-unit>
        <trans-unit id="f226c00a4d670c28c9ce96128a908ed75e3c4fc6" translate="yes" xml:space="preserve">
          <source>CTFE Sanity Checks</source>
          <target state="translated">CTFE проверки благонадёжности</target>
        </trans-unit>
        <trans-unit id="bcdc8bcedfff54c513bf8524b5ea04b31a01d40f" translate="yes" xml:space="preserve">
          <source>CTFE is not supported.</source>
          <target state="translated">CTFE не поддерживается.</target>
        </trans-unit>
        <trans-unit id="2e8b7f100028e56862c1d736efc547af30992b6b" translate="yes" xml:space="preserve">
          <source>CTFE is subject to the following restrictions:</source>
          <target state="translated">На CTFE распространяются следующие ограничения:</target>
        </trans-unit>
        <trans-unit id="5cbcfb039635320e7ff7d8feb659fe88d90d6d53" translate="yes" xml:space="preserve">
          <source>CTFE-able expression, resolving to &lt;code&gt;TupleExp&lt;/code&gt; or &lt;code&gt;StringExp&lt;/code&gt;</source>
          <target state="translated">CTFE-способное выражение, &lt;code&gt;TupleExp&lt;/code&gt; в TupleExp или &lt;code&gt;StringExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da921efe49d919390e46ee7013dc94409e0427b9" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">&lt;strong id=&quot;curl_easy_duphandle&quot;&gt;CURL&lt;/strong&gt; * &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt; ( &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;CURL&lt;/strong&gt; * curl);</target>
        </trans-unit>
        <trans-unit id="f3df3af8e49ed4cabb82ec3eb374069c299119bb" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt;();</source>
          <target state="translated">&lt;strong id=&quot;curl_easy_init&quot;&gt;CURL&lt;/strong&gt; * &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="6751502e2bc0440a5e6927ebe6c763c9fb33f615" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;easy_handle&quot;&gt;CURL&lt;/strong&gt; * &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="828fa48577f41dee0175a07d2bcd99aa7917b639" translate="yes" xml:space="preserve">
          <source>CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error instead of a memory allocation error if CURL_DOES_CONVERSIONS is defined</source>
          <target state="translated">CURLE_OUT_OF_MEMORY может иногда указывать на ошибку преобразования вместо ошибки выделения памяти,если определено CURL_DOES_CONVERSIONS</target>
        </trans-unit>
        <trans-unit id="2ab51649023b66c808197a6d0ba638e7d65bf9da" translate="yes" xml:space="preserve">
          <source>CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt;(curl_httppost** httppost, curl_httppost** last_post, ...);</source>
          <target state="translated">CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt; (curl_httppost ** httppost, curl_httppost ** last_post, ...);</target>
        </trans-unit>
        <trans-unit id="ee42c010a41bbc2d374ffe159f6514f8ff046b0e" translate="yes" xml:space="preserve">
          <source>CURLINFO_RESPONSE_CODE is the new name for the option previously known as CURLINFO_HTTP_CODE</source>
          <target state="translated">CURLINFO_RESPONSE_CODE-это новое имя для опции,ранее известной как CURLINFO_HTTP_CODE.</target>
        </trans-unit>
        <trans-unit id="32ad7575f66b5734a63076c0cb3d75f3884da653" translate="yes" xml:space="preserve">
          <source>CURLM error code.</source>
          <target state="translated">Код ошибки CURLM.</target>
        </trans-unit>
        <trans-unit id="99dd99b527ed789fcfbdfc456b2eb941ef204be1" translate="yes" xml:space="preserve">
          <source>CURLM* &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt;();</source>
          <target state="translated">CURLM * &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="3b90f598cb268ee4dc09f1ac996362f90296018c" translate="yes" xml:space="preserve">
          <source>CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt;;</source>
          <target state="translated">CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1999612ad18366624e0d0b2cd56012c1afc025b3" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt; (CURLM * multi_handle, CURL * curl_handle);</target>
        </trans-unit>
        <trans-unit id="22a1019ea56e4dab3fcad53491bac13d0d8af5fb" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t sockfd, void* sockp);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t sockfd, void * sockp);</target>
        </trans-unit>
        <trans-unit id="25a2804bd3b7261884e99b1fc524c94a8f152120" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt;(CURLM* multi_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt; (CURLM * multi_handle);</target>
        </trans-unit>
        <trans-unit id="0d7d7eae82011af95f4a6e15b19e86d79b7d077b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt;(CURLM* multi_handle, fd_set* read_fd_set, fd_set* write_fd_set, fd_set* exc_fd_set, int* max_fd);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt; (CURLM * multi_handle, fd_set * read_fd_set, fd_set * write_fd_set, fd_set * exc_fd_set, int * max_fd);</target>
        </trans-unit>
        <trans-unit id="811b3bdcf0c9e88ad95fd7b9e1e9194bc510f1d4" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt; (CURLM * multi_handle, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="cdc21e6a79fac27e25ab2401a2231a5159d42fa2" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt; (CURLM * multi_handle, CURL * curl_handle);</target>
        </trans-unit>
        <trans-unit id="b77796e4441642019f5f0ee725e2d2ccbaf79203" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt;(CURLM* multi_handle, CURLMoption option, ...);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt; (CURLM * multi_handle, опция CURLMoption, ...);</target>
        </trans-unit>
        <trans-unit id="a09fadf338e9129df789fdea317e027aaed23a5b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t s, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="ff40633804853059e167a117757dc66453ca66ad" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int ev_bitmask, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t s, int ev_bitmask, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="2466194fef4d1ee2ade6e8ccdeda99a667524258" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt; (CURLM * multi_handle, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="11ebb04cdf64624f9d24ec68ab137e1aca46350a" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt;(CURLM* multi_handle, c_long* milliseconds);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt; (CURLM * multi_handle, c_long * milliseconds);</target>
        </trans-unit>
        <trans-unit id="78c7684a9c1f8b1ac34050129574ece72e711bdd" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.</source>
          <target state="translated">Тип CURLMcode,общий код мульти-ошибки.</target>
        </trans-unit>
        <trans-unit id="4dc759c2b4e3bdbdc1edda0576bc41603b22a66f" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.  tmp decl</source>
          <target state="translated">Тип CURLMcode,общий код мульти-ошибки.tmp decl</target>
        </trans-unit>
        <trans-unit id="8b52c35c36f45f74e7316bea0caa3ca7b9817c93" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code. &lt;em&gt;NOTE&lt;/em&gt; that this only returns errors etc regarding the whole multi stack. There might still have occurred problems on invidual transfers even when this returns OK.</source>
          <target state="translated">Тип кода CURLM, общий код множественной ошибки. &lt;em&gt;ОБРАТИТЕ ВНИМАНИЕ,&lt;/em&gt; что это только возвращает ошибки и т. Д. Относительно всего мультистека. Могут все еще возникать проблемы с переносом по отдельности, даже если это возвращает ОК.</target>
        </trans-unit>
        <trans-unit id="24871c0c35a14246d94f5b601f5067185618ba89" translate="yes" xml:space="preserve">
          <source>CURLMsg* &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt;(CURLM* multi_handle, int* msgs_in_queue);</source>
          <target state="translated">CURLMsg * &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt; (CURLM * multi_handle, int * msgs_in_queue);</target>
        </trans-unit>
        <trans-unit id="af2fa369dcf8fd4fae6663dacfb6660f7d91238e" translate="yes" xml:space="preserve">
          <source>CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options</source>
          <target state="translated">CURLPROTO_определяет для опций CURLOPT_*PROTOCOLS</target>
        </trans-unit>
        <trans-unit id="d2e3b588ca39c50e2dd064cfebdc4915a19704fb" translate="yes" xml:space="preserve">
          <source>CURLSH* &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt;();</source>
          <target state="translated">CURLSH * &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="0cd2315c9c925b9d61d4c461b411526f237b821b" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt;(CURLSH*);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt; (CURLSH *);</target>
        </trans-unit>
        <trans-unit id="c12fc1ef3ac28f47fb0a0bb249fb914036edd5d6" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt;(CURLSH*, CURLSHoption option, ...);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt; (CURLSH *, опция CURLSHoption, ...);</target>
        </trans-unit>
        <trans-unit id="80c9a3afaa37cabae0ead42d1ea2a983b4448ab3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_ILLEGAL_ARRAY if an illegal option is used in an array</source>
          <target state="translated">CURL_FORMADD_ILLEGAL_ARRAY,если в массиве используется незаконная опция</target>
        </trans-unit>
        <trans-unit id="237caace3d00237f9fad71d5fdcb4b423276a5aa" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_INCOMPLETE if the some FormInfo is not complete (or error)</source>
          <target state="translated">CURL_FORMADD_INCOMPLETE,если некоторая формаInfo не является полной (или ошибка)</target>
        </trans-unit>
        <trans-unit id="16321db303d4490b9645491e5cfe20deb293518b" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if a curl_httppost struct cannot be allocated</source>
          <target state="translated">CURL_FORMADD_MEMORY,если структура curl_httppost не может быть выделена</target>
        </trans-unit>
        <trans-unit id="468f4fa1bb410d0fd70e03f6a5dce8bd45ccdbe3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if some allocation for string copying failed.</source>
          <target state="translated">CURL_FORMADD_MEMORY,если некоторое распределение для копирования строк не удалось.</target>
        </trans-unit>
        <trans-unit id="244588782f153f2f49d14b88a76a4b1567aa1f97" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the FormInfo allocation fails</source>
          <target state="translated">CURL_FORMADD_MEMORY,если распределение FormInfo не проходит успешно</target>
        </trans-unit>
        <trans-unit id="21b7579474f488d4369aa40ec4d89dc3bb5304c5" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the allocation of a FormInfo struct failed</source>
          <target state="translated">CURL_FORMADD_MEMORY,если выделение структуры FormInfo было неудачным</target>
        </trans-unit>
        <trans-unit id="f486f564c902d8b166b922ce6666a103809fa080" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_NULL if a null pointer was given for a char</source>
          <target state="translated">CURL_FORMADD_NULL,если для графика был указан нулевой указатель</target>
        </trans-unit>
        <trans-unit id="03c087c14e47ce05c5a730cee27884e0f0271510" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OK on success</source>
          <target state="translated">CURL_FORMADD_OK об успехе</target>
        </trans-unit>
        <trans-unit id="657acce1995ce0c4c4cc9704302fc40b3180ce0c" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OPTION_TWICE if one option is given twice for one Form</source>
          <target state="translated">CURL_FORMADD_OPTION_TWICE,если для одной формы дважды задан один параметр</target>
        </trans-unit>
        <trans-unit id="fb231ca0da85a5247735b55bae68726897d51402" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used</source>
          <target state="translated">CURL_FORMADD_UNKNOWN_OPTION,если использовалась неизвестная опция</target>
        </trans-unit>
        <trans-unit id="c1c36583a3bee413dd4d6eabaaf03906540af6c8" translate="yes" xml:space="preserve">
          <source>CURL_LOCK_DATA_SHARE is used internally to say that the locking is just made to change the internal state of the share itself.</source>
          <target state="translated">CURL_LOCK_DATA_SHARE используется внутренне,чтобы сказать,что блокировка производится только для изменения внутреннего состояния самой акции.</target>
        </trans-unit>
        <trans-unit id="08d333ae982f2ab5fd05c92959c9f03604998f78" translate="yes" xml:space="preserve">
          <source>CURL_VERSION</source>
          <target state="translated">CURL_VERSION</target>
        </trans-unit>
        <trans-unit id="311de4a4e55e22b4fb916aea606488f2810807f6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt;(CURL* curl, CURLINFO info, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt; ( &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;CURL&lt;/strong&gt; * curl, информация CURLINFO, ...);</target>
        </trans-unit>
        <trans-unit id="732ee216b7a86b2068f3e21e26d039d5ff87d0a6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt;(CURL* handle, int bitmask);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt; ( &lt;strong id=&quot;curl_easy_pause&quot;&gt;CURL&lt;/strong&gt; * handle, int bitmask);</target>
        </trans-unit>
        <trans-unit id="743291b335af5fe8701249accd883cdee309abc2" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt; ( &lt;strong id=&quot;curl_easy_perform&quot;&gt;CURL&lt;/strong&gt; * curl);</target>
        </trans-unit>
        <trans-unit id="5ef9ed35887a97572c7e153166cf3c37d4499135" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt; ( &lt;strong id=&quot;curl_easy_recv&quot;&gt;CURL&lt;/strong&gt; * curl, void * buffer, size_t buflen, size_t * n);</target>
        </trans-unit>
        <trans-unit id="03f5e5216a441a870631a8ebbf1324f0d53aad46" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt; ( &lt;strong id=&quot;curl_easy_send&quot;&gt;CURL&lt;/strong&gt; * curl, void * buffer, size_t buflen, size_t * n);</target>
        </trans-unit>
        <trans-unit id="c2267b7c0b6dd8f394f4e53f9877924630091aa4" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt;(CURL* curl, CURLoption option, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt; ( &lt;strong id=&quot;curl_easy_setopt&quot;&gt;CURL&lt;/strong&gt; * curl, опция CURLoption, ...);</target>
        </trans-unit>
        <trans-unit id="856a997055fde5b0daa6466669272d7c21200826" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt;(c_long flags);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt; (флаги c_long);</target>
        </trans-unit>
        <trans-unit id="ad44c3dd1dc580f2f09873c3d8bc4b0f2c99e680" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt;(c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt; (флаги c_long, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</target>
        </trans-unit>
        <trans-unit id="47d9bbe805f8580c705596e7003de4a50cbc2583" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;result&quot;&gt;result&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;result&quot;&gt;Результат&lt;/strong&gt; CURLcode ;</target>
        </trans-unit>
        <trans-unit id="304f1ec0769d4c548febbdf47625f266fdcfab5b" translate="yes" xml:space="preserve">
          <source>CURLformoption &lt;strong id=&quot;option&quot;&gt;option&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;option&quot;&gt;Опция&lt;/strong&gt; CURLformoption ;</target>
        </trans-unit>
        <trans-unit id="a4c24fe1a70e51826ba9ae7c30e20cd7e2a29828" translate="yes" xml:space="preserve">
          <source>CURLversion &lt;strong id=&quot;age&quot;&gt;age&lt;/strong&gt;;</source>
          <target state="translated">Возрастной &lt;strong id=&quot;age&quot;&gt;возраст&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b4a140e494ddd4ae40e04aab42088b88b1becbfe" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;buf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afe63bc0735098979cb97ac441f55ea9bf41ba0b" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bacd88197768daee4b3de506c5c3a95e5a62751a" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06ae80fea6ce71846e64d1060826cd17e855a35" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">С [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7150792a1546098dee35fe7a98fdfc975256a790" translate="yes" xml:space="preserve">
          <source>Cache size and behaviour</source>
          <target state="translated">Размер кэша и поведение</target>
        </trans-unit>
        <trans-unit id="f800f99aa3df3800502bbb36ab972cc0eb0d5c0b" translate="yes" xml:space="preserve">
          <source>CacheInfo[5] &lt;strong id=&quot;datacache&quot;&gt;datacache&lt;/strong&gt;;</source>
          <target state="translated">CacheInfo [5] &lt;strong id=&quot;datacache&quot;&gt;datacache&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6bcc4b116e2d06311b0fc9927d035dbff820590a" translate="yes" xml:space="preserve">
          <source>Calculate and return</source>
          <target state="translated">Рассчитать и вернуть</target>
        </trans-unit>
        <trans-unit id="3d6ed85fb2e3f634e358f0719e27875d435ea774" translate="yes" xml:space="preserve">
          <source>Calculate built-in properties which just the type is necessary.</source>
          <target state="translated">Рассчитать встроенные свойства,которые нужны только по типу.</target>
        </trans-unit>
        <trans-unit id="a4aa52fc673bba9caf0d9f71c29d0ae6f9877456" translate="yes" xml:space="preserve">
          <source>Calculate field[i].overlapped and overlapUnsafe, and check that all of explicit field initializers have unique memory space on instance.</source>
          <target state="translated">Вычислите поле[i].overlapped and overlapUnsafe и убедитесь,что все явные инициализаторы поля имеют уникальное пространство в памяти,например.</target>
        </trans-unit>
        <trans-unit id="5c68d55b4c8ec705956e2d8e0515e64b113840ed" translate="yes" xml:space="preserve">
          <source>Calculate the base-10 logarithm of x.</source>
          <target state="translated">Рассчитайте логарифм базиса 10 x.</target>
        </trans-unit>
        <trans-unit id="aa77a0a0c44f9dd6e1b336ed64c758b221d1485c" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence ending one code unit before &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Вычислить длину последовательности UTF, заканчивающейся на одну кодовую единицу перед &lt;code&gt;index&lt;/code&gt; в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14c2e14715fa06b8f138716be37c507138d963e7" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence starting at &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Вычислить длину последовательности UTF, начиная с &lt;code&gt;index&lt;/code&gt; в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e12b3a821d4bde6f6cb14b1be6565da8f2b8ddac" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x.</source>
          <target state="translated">Рассчитайте натуральный логарифм x.</target>
        </trans-unit>
        <trans-unit id="3f112af5d27881f2633fc0efa7c8c3ce5a0a8242" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x. The branch cut is along the negative axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30b6367e2a4061ed4b790ec3600b0de931f9e1f" translate="yes" xml:space="preserve">
          <source>Calculate the next largest floating point value after x.</source>
          <target state="translated">Вычислите следующее по величине значение с плавающей точкой после x.</target>
        </trans-unit>
        <trans-unit id="b9c742d632c337bd8cbf69961edcf3221964c540" translate="yes" xml:space="preserve">
          <source>Calculate the next smallest floating point value before x.</source>
          <target state="translated">Вычислите следующее наименьшее значение с плавающей точкой до x.</target>
        </trans-unit>
        <trans-unit id="018fa0870c360e2cac7a8c4bc28e389efc5f1613" translate="yes" xml:space="preserve">
          <source>Calculate the remainder x REM y, following IEC 60559.</source>
          <target state="translated">Рассчитайте остаток x REM y,в соответствии с МЭК 60559.</target>
        </trans-unit>
        <trans-unit id="3fba25e1430b0ae9ada9b4efe1168d1151f49b29" translate="yes" xml:space="preserve">
          <source>Calculates 2&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">Вычисляет 2 &lt;sup&gt;х&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="63c1fbfad55eb2f0634d2925033191320d7fe148" translate="yes" xml:space="preserve">
          <source>Calculates e&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">Рассчитывает е &lt;sup&gt;х&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="552f818572293e7e3df3d8078e1d8502861c8778" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number</source>
          <target state="translated">Вычисляет абсолютное значение числа</target>
        </trans-unit>
        <trans-unit id="4ec6328d585b956e719618a807b023dcff090ac5" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be2a6f70202c3264162991c74bed6c4baae9236" translate="yes" xml:space="preserve">
          <source>Calculates the arc cosine of x, returning a value ranging from 0 to &amp;pi;.</source>
          <target state="translated">Вычисляет арккосинус от x, возвращая значение в диапазоне от 0 до &amp;pi;.</target>
        </trans-unit>
        <trans-unit id="d946a27b03ca4cac969d0047946f4fc66affc0fa" translate="yes" xml:space="preserve">
          <source>Calculates the arc sine of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">Вычисляет арксинус x, возвращая значение в диапазоне от -&amp;pi; / 2 до &amp;pi; / 2.</target>
        </trans-unit>
        <trans-unit id="d9e1b5526d250f5e8ab8ddc83903cc95d1cc029a" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">Вычисляет арктангенс x, возвращая значение в диапазоне от -&amp;pi; / 2 до &amp;pi; / 2.</target>
        </trans-unit>
        <trans-unit id="3783817bf938b83309854c6205d56ee4a302e644" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of y / x, returning a value ranging from -&amp;pi; to &amp;pi;.</source>
          <target state="translated">Вычисляет арктангенс y / x, возвращая значение в диапазоне от -&amp;pi; до &amp;pi;.</target>
        </trans-unit>
        <trans-unit id="e1c3e20fd2cd7d94fdcf1efca206597755351a82" translate="yes" xml:space="preserve">
          <source>Calculates the base-2 logarithm of x: log&lt;sub&gt;2&lt;/sub&gt;x</source>
          <target state="translated">Рассчитывает основание-2 логарифм х: лог &lt;sub&gt;2&lt;/sub&gt; х</target>
        </trans-unit>
        <trans-unit id="ba562ff7e573b706f15ed8cff069704fa53ed5ac" translate="yes" xml:space="preserve">
          <source>Calculates the cube root of x.</source>
          <target state="translated">Вычисляет кубический корень x.</target>
        </trans-unit>
        <trans-unit id="c6b3ccb038ca0414c5d73b25ada62fdde6188a5c" translate="yes" xml:space="preserve">
          <source>Calculates the hash value of &lt;code&gt;arg&lt;/code&gt; with an optional &lt;code&gt;seed&lt;/code&gt; initial value. The result might not be equal to &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt;.</source>
          <target state="translated">Вычисляет значение хеш-функции &lt;code&gt;arg&lt;/code&gt; с необязательным начальным значением &lt;code&gt;seed&lt;/code&gt; . Результат может быть не равен &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6077e40f1d7c6b4630a9eabd54e9cc9ad6cdbbd5" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic cosine of x.</source>
          <target state="translated">Вычисляет гиперболический косинус Х.</target>
        </trans-unit>
        <trans-unit id="c3be2955cec737e95210a83c0153e5a7b26737f0" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic sine of x.</source>
          <target state="translated">Вычисляет гиперболический синус Х.</target>
        </trans-unit>
        <trans-unit id="836a3048b7c344efad04edc701d9a39358e4ddc2" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic tangent of x.</source>
          <target state="translated">Вычисляет гиперболический тангенс Х.</target>
        </trans-unit>
        <trans-unit id="26863b4aef8c0a694cd2e723d6778f9f04e7eb52" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic cosine of x.</source>
          <target state="translated">Вычисляет обратный гиперболический косинус x.</target>
        </trans-unit>
        <trans-unit id="c627e3b3df39ce6438ba816e8a109c0ffed6f76d" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic sine of x.</source>
          <target state="translated">Вычисляет обратный гиперболический синус x.</target>
        </trans-unit>
        <trans-unit id="8af98eaa49794884fefd803885cf1f1893246ddf" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic tangent of x, returning a value from ranging from -1 to 1.</source>
          <target state="translated">Вычисляет обратный гиперболический тангенс x,возвращающий значение от -1 до 1.</target>
        </trans-unit>
        <trans-unit id="5c5618c4bbf47d472509dd6366443a216865a98d" translate="yes" xml:space="preserve">
          <source>Calculates the length needed to store the encoded string corresponding to an input of the given length.</source>
          <target state="translated">Вычисляет длину,необходимую для хранения кодированной строки,соответствующей входу заданной длины.</target>
        </trans-unit>
        <trans-unit id="027e373dfea678dcf40ffef9e131551d07153fd8" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angled triangle with sides of length x and y. The hypotenuse is the value of the square root of the sums of the squares of x and y:</source>
          <target state="translated">Вычисляет длину гипотенузы прямоугольного треугольника со сторонами длины x и y.Гипотенуза-это значение квадратного корня из суммы квадратов x и y:</target>
        </trans-unit>
        <trans-unit id="49efa739aec865cfda8564b9080c48989d5e33a7" translate="yes" xml:space="preserve">
          <source>Calculates the natural logarithm of 1 + x.</source>
          <target state="translated">Рассчитывает натуральный логарифм 1+х.</target>
        </trans-unit>
        <trans-unit id="2c06de5b0b0a99a9dfc2d0912c58bdadc98082d6" translate="yes" xml:space="preserve">
          <source>Calculates the next representable value after x in the direction of y.</source>
          <target state="translated">Вычисляет следующее представляемое значение после x в направлении y.</target>
        </trans-unit>
        <trans-unit id="3754c2ce035cf1b13a7cd37e615749fb652610b4" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer using the X86 SSE4 POPCNT instruction. POPCNT is not available on all X86 CPUs.</source>
          <target state="translated">Вычисляет количество заданных битов в целочисленном виде с помощью инструкции X86 SSE4 POPCNT.POPCNT доступен не на всех процессорах X86.</target>
        </trans-unit>
        <trans-unit id="06d72e9a8ced5d5423191cc63ca6b46b4610af0d" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer.</source>
          <target state="translated">Вычисляет количество заданных бит в целочисленном виде.</target>
        </trans-unit>
        <trans-unit id="9a6eed62af9d1a47c1ab6bc79899d39e32a6483a" translate="yes" xml:space="preserve">
          <source>Calculates the remainder from the calculation x/y.</source>
          <target state="translated">Вычисляет остаток от вычисления x/y.</target>
        </trans-unit>
        <trans-unit id="fe24886c3219456f2196eb244fb852afd4fb56a9" translate="yes" xml:space="preserve">
          <source>Calculates the value of the natural logarithm base (e) raised to the power of x, minus 1.</source>
          <target state="translated">Рассчитывает значение натурального логарифма базы (д),увеличенного до мощности x,минус 1.</target>
        </trans-unit>
        <trans-unit id="af2f291e997ca41e56ba422f46bf86ff11ebb79d" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;n&lt;/sup&gt;. The branch cut is on the negative axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f6cce6873a9a6bb919b268ff433dd1e133a874" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;y&lt;/sup&gt;.</source>
          <target state="translated">Вычисляет х &lt;sup&gt;у&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="801ce4a0b5aa9b661ade0819332605cc7b1ae809" translate="yes" xml:space="preserve">
          <source>Call each of the connected slots, passing the argument(s) i to them. Nested call will be ignored.</source>
          <target state="translated">Вызовите каждый из подключенных слотов,передав им аргумент(ы)i.Вложенный вызов будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="5f9f4deb84100f6aec181820d5a751140cd068c1" translate="yes" xml:space="preserve">
          <source>Call this after printing out fatal error messages to clean up and exit the compiler.</source>
          <target state="translated">Вызовите этот вызов после распечатки сообщений о фатальных ошибках для очистки и выхода из компилятора.</target>
        </trans-unit>
        <trans-unit id="f75e5681020d520d2c6f752e809e81b0c81a85b8" translate="yes" xml:space="preserve">
          <source>CallExp &lt;code&gt;ce&lt;/code&gt;</source>
          <target state="translated">CallExp &lt;code&gt;ce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf7b36d93b4e5475d0f1769a4ea2f0934f697c5" translate="yes" xml:space="preserve">
          <source>Callback for each received StatusLine.</source>
          <target state="translated">Обратный звонок для каждого полученного StatusLine.</target>
        </trans-unit>
        <trans-unit id="f3869aa6b3628e9280e1301a0819ce5b27364caa" translate="yes" xml:space="preserve">
          <source>Callback function for opening socket (instead of socket(2)). Optionally, callback is able change the address or refuse to connect returning CURL_SOCKET_BAD. The callback should have type curl_opensocket_callback</source>
          <target state="translated">Функция обратного вызова для открытия сокета (вместо сокета(2)).Опционально,функция обратного вызова может изменить адрес или отказаться от подключения,вернув CURL_SOCKET_BAD.Обратный вызов должен иметь тип curl_opensocket_callback</target>
        </trans-unit>
        <trans-unit id="fa6c180b210d6c195ea47a0f5808f2e991c787e3" translate="yes" xml:space="preserve">
          <source>Callback function for seeking in the input stream</source>
          <target state="translated">Функция обратного вызова для поиска во входном потоке</target>
        </trans-unit>
        <trans-unit id="d4829fe836ac65e604efec860420d6bb34e163e7" translate="yes" xml:space="preserve">
          <source>Callback implementation user data</source>
          <target state="translated">Обратный вызов реализации пользовательские данные</target>
        </trans-unit>
        <trans-unit id="7958bba34f83b3f0d9bec51f1aa784c3099f4330" translate="yes" xml:space="preserve">
          <source>Callback options.</source>
          <target state="translated">Опции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="2c70d267e735763e25416c3729426a88c83fd93c" translate="yes" xml:space="preserve">
          <source>Callback parameters</source>
          <target state="translated">Параметры обратного вызова</target>
        </trans-unit>
        <trans-unit id="83da71c0b0c98f854fd142c883ddfbc56d402d5a" translate="yes" xml:space="preserve">
          <source>Callback returns</source>
          <target state="translated">Возврат звонка</target>
        </trans-unit>
        <trans-unit id="5277f74ec6b2c07897ae08c4150298f4a47bfee7" translate="yes" xml:space="preserve">
          <source>Callback routine requested an abort</source>
          <target state="translated">Программа обратного вызова запросила аборт</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="9d7a88bd45dd2018e4f369390635318ba64e842f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad &lt;code&gt;opOpAssign&lt;/code&gt; call (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">Вызывается автоматически при неправильном вызове &lt;code&gt;opOpAssign&lt;/code&gt; (который теряет точность или пытается преобразовать отрицательное значение в тип без знака).</target>
        </trans-unit>
        <trans-unit id="7102900b536c87cd1ddcccfc7367f11bb9536bf4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast (one that loses precision or attempts to convert a negative value to an unsigned type). The source type is &lt;code&gt;Src&lt;/code&gt; and the destination type is &lt;code&gt;Dst&lt;/code&gt;.</source>
          <target state="translated">Вызывается автоматически при неудачном приведении (которое теряет точность или пытается преобразовать отрицательное значение в тип без знака). Тип источника - &lt;code&gt;Src&lt;/code&gt; , а тип назначения - &lt;code&gt;Dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09ced3e78029e52a33dba4c3dc622cbf4db610e5" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast from &lt;code&gt;src&lt;/code&gt; to type &lt;code&gt;Dst&lt;/code&gt; (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">Вызывается автоматически при неудачном приведении от &lt;code&gt;src&lt;/code&gt; к типу &lt;code&gt;Dst&lt;/code&gt; (тот, который теряет точность или пытается преобразовать отрицательное значение в тип без знака).</target>
        </trans-unit>
        <trans-unit id="1b890f532573803598c95ff0855037312602e65a" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bounds error.</source>
          <target state="translated">Вызывается автоматически при ошибке ограничения.</target>
        </trans-unit>
        <trans-unit id="cec93f38cfc349e778449343568f595e85578df6" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of a erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), this hook issues &lt;code&gt;assert(0)&lt;/code&gt; which terminates the application.</source>
          <target state="translated">Вызывается автоматически при сравнении на равенство. В случае ошибочного сравнения (при котором отрицательное значение со знаком выглядит равным положительному значению без знака), этот хук выдает &lt;code&gt;assert(0)&lt;/code&gt; который завершает приложение.</target>
        </trans-unit>
        <trans-unit id="0d9a0c46bb6698d633be1a9f6fd1250d9925d992" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of an Erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), writes a warning message to &lt;code&gt;stderr&lt;/code&gt; as a side effect.</source>
          <target state="translated">Вызывается автоматически при сравнении на равенство. В случае ошибочного сравнения (при котором отрицательное значение со знаком будет равно положительному значению без знака), в качестве побочного эффекта записывается предупреждающее сообщение в &lt;code&gt;stderr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5f36c313c02bf2d55947333ca1b1ce5b5e726cd" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. Throws upon an erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value).</source>
          <target state="translated">Вызывает автоматическое сравнение для равенства.Вызывает ошибочное сравнение (такое,при котором подписанное отрицательное значение оказывается равным неподписанному положительному).</target>
        </trans-unit>
        <trans-unit id="482787b051181ec9851e392f48ceca8d8cc29f3f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then a warning message is printed to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">Вызывается автоматически при сравнении для заказа с использованием одного из операторов &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;gt;=&lt;/code&gt; . В случае, если сравнение ошибочно (т. Е. Отрицательное значение со знаком будет больше или равно положительному значению без знака), тогда на &lt;code&gt;stderr&lt;/code&gt; выводится предупреждение .</target>
        </trans-unit>
        <trans-unit id="f347895ce62ab753804db2ed8acefc457ef89fc4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then application is terminated with &lt;code&gt;assert(0)&lt;/code&gt;. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">Вызывается автоматически при сравнении для заказа с использованием одного из операторов &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;gt;=&lt;/code&gt; . В случае, если сравнение ошибочно (т. Е. Отрицательное значение со знаком будет больше или равно положительному значению без знака), приложение завершается с помощью &lt;code&gt;assert(0)&lt;/code&gt; . В противном случае возвращается результат с тремя состояниями (положительный, если &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; , отрицательный, если &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; в противном случае).</target>
        </trans-unit>
        <trans-unit id="fd9dee545de2de37ec8d225d3452d9b9db4a4de3" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), throws a &lt;code&gt;Throw.CheckFailure&lt;/code&gt; exception. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">Вызывается автоматически при сравнении для заказа с использованием одного из операторов &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;gt;=&lt;/code&gt; . В случае ошибочного сравнения (т. &lt;code&gt;Throw.CheckFailure&lt;/code&gt; значение со знаком будет больше или равно положительному значению без знака), генерируется исключение Throw.CheckFailure . В противном случае возвращается результат с тремя состояниями (положительный, если &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; , отрицательный, если &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; в противном случае).</target>
        </trans-unit>
        <trans-unit id="288a3bb051cf2f7e5a316c4d4e70d5118f188801" translate="yes" xml:space="preserve">
          <source>Called automatically upon an overflow during a unary or binary operation.</source>
          <target state="translated">Вызывается автоматически при переполнении во время выполнения одинарной или двоичной операции.</target>
        </trans-unit>
        <trans-unit id="18ffd2396df8d946aeaff03367807e9289b502e5" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;accept&lt;/code&gt; when a new &lt;code&gt;Socket&lt;/code&gt; must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned &lt;code&gt;Socket&lt;/code&gt;'s handle must not be set; &lt;code&gt;Socket&lt;/code&gt; has a protected constructor &lt;code&gt;this()&lt;/code&gt; to use in this situation.</source>
          <target state="translated">Вызывается &lt;code&gt;accept&lt;/code&gt; когда новый &lt;code&gt;Socket&lt;/code&gt; должен быть создан для нового соединения. Чтобы использовать производный класс, переопределите этот метод и верните экземпляр вашего класса. Возвращенный &lt;code&gt;Socket&lt;/code&gt; ручка &amp;laquo;сек не должен быть установлен; &lt;code&gt;Socket&lt;/code&gt; имеет защищенный конструктор &lt;code&gt;this()&lt;/code&gt; для использования в этой ситуации.</target>
        </trans-unit>
        <trans-unit id="b54f1e19b12e53615e8a653c409ba5ab2951a872" translate="yes" xml:space="preserve">
          <source>Called by D code to throw an exception via</source>
          <target state="translated">Вызывается кодом D,чтобы бросить исключение через</target>
        </trans-unit>
        <trans-unit id="1ca7f5a39bbf37ff1a678bd1aa4c79aba11959d4" translate="yes" xml:space="preserve">
          <source>Called by SQLite to clean up pUser</source>
          <target state="translated">Призван SQLite для очистки пьюзеров.</target>
        </trans-unit>
        <trans-unit id="9743db8f1711c6b311db6267994885195b8a6347" translate="yes" xml:space="preserve">
          <source>Called by libcurl whenever the library detects a change in the maximum number of milliseconds the app is allowed to wait before curl_multi_socket() or curl_multi_perform() must be called (to allow libcurl's timed events to take place).</source>
          <target state="translated">Вызывается libcurl всякий раз,когда библиотека обнаруживает изменение в максимальном количестве миллисекунд,когда приложению разрешено ждать,прежде чем должна быть вызвана функция curl_multi_socket()или curl_multi_perform()(чтобы позволить событиям с таймером libcurl произойти).</target>
        </trans-unit>
        <trans-unit id="3edd2c76a126518315d7a71140c73140e3fc8324" translate="yes" xml:space="preserve">
          <source>Called during runtime initialization to initialize a GC instance of given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Вызывается во время инициализации во время выполнения для инициализации экземпляра GC с заданным &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6980b4453fbc6893945f9512aa33baa854c12d55" translate="yes" xml:space="preserve">
          <source>Called from back end.</source>
          <target state="translated">Вызывается с задней стороны.</target>
        </trans-unit>
        <trans-unit id="f90881b5eb5e600ad18d60ab2849afead809fc76" translate="yes" xml:space="preserve">
          <source>Called once per thread; returns array of thread local storage ranges</source>
          <target state="translated">Вызывается один раз на поток;возвращает массив локальных диапазонов хранения данных потока</target>
        </trans-unit>
        <trans-unit id="7a912bc6a899a5bd4ea502581245c2ef16bd2966" translate="yes" xml:space="preserve">
          <source>Called when fibers switch contexts.</source>
          <target state="translated">Вызывается,когда волокна меняют контекст.</target>
        </trans-unit>
        <trans-unit id="c0acd999c318ee36079d9ad700960738ccee34ac" translate="yes" xml:space="preserve">
          <source>Called when setting a version identifier, e.g. &lt;code&gt;-version=identifier&lt;/code&gt; parameter to the compiler or &lt;code&gt;version = Foo&lt;/code&gt; in user code.</source>
          <target state="translated">Вызывается при установке идентификатора версии, например, параметр &lt;code&gt;-version=identifier&lt;/code&gt; для компилятора или &lt;code&gt;version = Foo&lt;/code&gt; в коде пользователя.</target>
        </trans-unit>
        <trans-unit id="495dea06203f25ae26116f2f5772a696918832bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#reset&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; will reset this to &lt;code&gt;Duration.zero&lt;/code&gt;.</source>
          <target state="translated">Вызов &lt;a href=&quot;#reset&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; сбросит это на &lt;code&gt;Duration.zero&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23a63a5505f1213693ee8224d96b5310cf3183b" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; with the resulting &lt;code&gt;Pid&lt;/code&gt; is invalid.</source>
          <target state="translated">Вызов &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt; с полученным &lt;code&gt;Pid&lt;/code&gt; недействителен.</target>
        </trans-unit>
        <trans-unit id="796201301481a494676b87bd22f58df79f6f3bdb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;printf()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69ccd3a1a7e462d569968184a6624c2a8f6e037" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;reopen&lt;/code&gt; with a &lt;code&gt;null&lt;/code&gt;&lt;code&gt;name&lt;/code&gt; is not implemented in all C runtimes.</source>
          <target state="translated">Вызов &lt;code&gt;reopen&lt;/code&gt; с &lt;code&gt;null&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; не реализован во всех средах выполнения C.</target>
        </trans-unit>
        <trans-unit id="8a670c32e5ff77bac0fbdbb4ed6c86d3156f5f82" translate="yes" xml:space="preserve">
          <source>Calling C Functions</source>
          <target state="translated">Вызов С Функции</target>
        </trans-unit>
        <trans-unit id="2a58b71a9eba354c8a2762dcf96889501c4c8b2f" translate="yes" xml:space="preserve">
          <source>Calling C++ Global Functions from D</source>
          <target state="translated">Вызов C++Глобальные функции из D</target>
        </trans-unit>
        <trans-unit id="0af92a8a9a70b3aa97a6e09d334eff695960b293" translate="yes" xml:space="preserve">
          <source>Calling CTFE-able functions or using manifest constants is also possible.</source>
          <target state="translated">Также возможен вызов CTFE-функций или использование манифестных констант.</target>
        </trans-unit>
        <trans-unit id="ab9616e4fb5ac458c376db23b38a3a4f41bdffa3" translate="yes" xml:space="preserve">
          <source>Calling Global D Functions From C++</source>
          <target state="translated">Вызов глобальных D-функций с C++</target>
        </trans-unit>
        <trans-unit id="011de1cd8c5a8313b4819150b58f7b77ffe1686b" translate="yes" xml:space="preserve">
          <source>Calling an Instance Method</source>
          <target state="translated">Вызов метода инстанцирования</target>
        </trans-unit>
        <trans-unit id="882cd8e97a7e6dec1b20f7ffc308265e42981f07" translate="yes" xml:space="preserve">
          <source>Calling an Objective-C instance method uses the same syntax as calling regular D methods:</source>
          <target state="translated">Вызов метода экземпляра Objective-C использует тот же синтаксис,что и вызов обычных методов D:</target>
        </trans-unit>
        <trans-unit id="2837bac68cbbca90ef92df0ecb7045b8bad05e30" translate="yes" xml:space="preserve">
          <source>Calling any system functions.</source>
          <target state="translated">Вызов любых системных функций.</target>
        </trans-unit>
        <trans-unit id="99afec36350160ba55067caa792fb170d47da7f2" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the @nogc-ness, i.e. if we're in a @nogc function we can only call other @nogc functions. Returns true if error occurs.</source>
          <target state="translated">Вызов функции f.Проверьте @nogc-ness,т.е.если мы находимся в функции @nogc,то можем вызывать только другие функции @nogc.Возвращает true,если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="889558fe1d6b373ebfb4108727201ca1efea7bd9" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the purity, i.e. if we're in a pure function we can only call other pure functions. Returns true if error occurs.</source>
          <target state="translated">Вызов функции f.Проверьте чистоту,т.е.если мы находимся в чистой функции,мы можем вызвать только другие чистые функции.Возвращает true,если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="9d07dff2f17d03cbf0372862de2a911c37b1df31" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the safety, i.e. if we're in a @safe function we can only call @safe or @trusted functions. Returns true if error occurs.</source>
          <target state="translated">Вызов функции f.Проверьте безопасность,т.е.если мы находимся в функции @safe,мы можем вызвать только @safe или @trusted функции.Возвращает true,если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="49f72934b9748e8925ba7a574cd2caf074e942d5" translate="yes" xml:space="preserve">
          <source>Calling printf()</source>
          <target state="translated">Вызов printf()</target>
        </trans-unit>
        <trans-unit id="06859dbd6f7a9d0b1a468c855675188601e16f52" translate="yes" xml:space="preserve">
          <source>Calling this function sets a flag indicating that this struct is no longer worker-local, and attempting to use the &lt;code&gt;get&lt;/code&gt; method again will result in an assertion failure if assertions are enabled.</source>
          <target state="translated">Вызов этой функции устанавливает флаг, указывающий, что эта структура больше не является рабочей-локальной, и попытка использовать метод &lt;code&gt;get&lt;/code&gt; снова приведет к ошибке подтверждения, если утверждения включены.</target>
        </trans-unit>
        <trans-unit id="c5e417ef005e02e78fdb802550dfe5fd2fa097a5" translate="yes" xml:space="preserve">
          <source>Calling this function with &lt;code&gt;blocking = true&lt;/code&gt; from a worker thread that is a member of the same &lt;code&gt;TaskPool&lt;/code&gt; that &lt;code&gt;finish&lt;/code&gt; is being called on will result in a deadlock.</source>
          <target state="translated">Вызов этой функции с &lt;code&gt;blocking = true&lt;/code&gt; из рабочего потока, который является членом того же &lt;code&gt;TaskPool&lt;/code&gt; , для которого вызывается метод &lt;code&gt;finish&lt;/code&gt; , приведет к взаимоблокировке.</target>
        </trans-unit>
        <trans-unit id="a483b09288907bf0c6892b8a0c3a3688580a1534" translate="yes" xml:space="preserve">
          <source>Calling this function, and then using references to data located after the given array results in undefined behavior.</source>
          <target state="translated">Вызов этой функции,а затем использование ссылок на данные,расположенные после данного массива,приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="0a48762ee3e2f7b163567b2b8c2bdc321fb3d29c" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; for the file handle.</source>
          <target state="translated">Вызывает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="5fa582845b2a8965acb06e6a0955d839742fab8a" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt; for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively.</source>
          <target state="translated">Вызывает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;фред&lt;/a&gt; для дескриптора файла. Количество считываемых элементов и размер каждого элемента определяются из размера и типа входного массива соответственно.</target>
        </trans-unit>
        <trans-unit id="4204f336078b400c2ca8218f3dc707eed9fc8eef" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; for the file handle to move its position indicator.</source>
          <target state="translated">Вызывает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; для дескриптора файла, чтобы переместить его индикатор положения.</target>
        </trans-unit>
        <trans-unit id="b841aa017960fa21330d3bce71d1341f08261fc1" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; for the managed file handle.</source>
          <target state="translated">Вызывает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; для дескриптора управляемого файла.</target>
        </trans-unit>
        <trans-unit id="19416b73e0b0cfe1706209f1904f9557babb3844" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety.</source>
          <target state="translated">Вызывает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; для дескриптора файла. Количество записываемых элементов и размер каждого элемента выводятся из размера и типа входного массива соответственно. Выдается ошибка, если буфер не может быть записан полностью.</target>
        </trans-unit>
        <trans-unit id="b50971f4c5e8a0e45c73e7c7c90d36d61fddcb7f" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;rewind&lt;/a&gt; for the file handle.</source>
          <target state="translated">&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;Перемотка&lt;/a&gt; вызовов для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="6954ffddc60a249c70b2b20272f1b59673a22e6b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; for the file handle.</source>
          <target state="translated">Вызывает &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="660af3415b8af8c796363c6a336c94f83d470574" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; (as it must be called or copied in any function overriding &lt;code&gt;newScope&lt;/code&gt;), then set the &lt;code&gt;Scope&lt;/code&gt;'s depdecl.</source>
          <target state="translated">Вызовы &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; (как это должно быть названо или скопирована в любой переопределение функции &lt;code&gt;newScope&lt;/code&gt; ), затем установите &lt;code&gt;Scope&lt;/code&gt; &amp;laquo;s depdecl.</target>
        </trans-unit>
        <trans-unit id="ea66981f1c839cec218fd677425515ff882faad6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;free(b.ptr)&lt;/code&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">&lt;code&gt;free(b.ptr)&lt;/code&gt; звонки (b.ptr) в Posix и &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt; &lt;/a&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="80b24062036e8206a4a3aaaa50eca541bcbb2352" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;free(b.ptr)&lt;/code&gt; on Posix and &lt;a href=&quot;https://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e076da4834d8b045458f6ec7dd1c5d3b78bd298c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;impl.deallocateAll()&lt;/code&gt; and returns the result if defined, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;impl.deallocateAll()&lt;/code&gt; и возвращает результат, если он определен, в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b0309269b86732c6de69ae225028495fc3e76bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order, stopping when either range has been exhausted.</source>
          <target state="translated">Вызовы &lt;code&gt;move(a, b)&lt;/code&gt; для каждого элемента &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;src&lt;/code&gt; и соответствующего элемента &lt;code&gt;b&lt;/code&gt; в &lt;code&gt;tgt&lt;/code&gt; , в порядке возрастания, останавливаются при исчерпании любого диапазона.</target>
        </trans-unit>
        <trans-unit id="b3aff67db2952371a04e1469cf552b2bafe5ed21" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order.</source>
          <target state="translated">Вызовы &lt;code&gt;move(a, b)&lt;/code&gt; для каждого элемента &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;src&lt;/code&gt; и соответствующего элемента &lt;code&gt;b&lt;/code&gt; в &lt;code&gt;tgt&lt;/code&gt; в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="9326ff35ce625813cb6e134a6874955a7343c986" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;popBack&lt;/code&gt; for all controlled ranges.</source>
          <target state="translated">Вызывает &lt;code&gt;popBack&lt;/code&gt; для всех контролируемых диапазонов.</target>
        </trans-unit>
        <trans-unit id="1cb6a5ebd9c3d585d565184c781a892ebfa3d0e5" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol.</source>
          <target state="translated">Звонит dg(Dsymbol *sym)для каждого Dsymbol.</target>
        </trans-unit>
        <trans-unit id="f0ea91146057c0154bb8b4caec2606cab70e289d" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol. If dg returns !=0, stops and returns that value else returns 0.</source>
          <target state="translated">Звонит dg(Dsymbol *sym)для каждого Dsymbol.Если dg возвращает !=0,то останавливается и возвращает это значение,в противном случае возвращается 0.</target>
        </trans-unit>
        <trans-unit id="20447109fe962cd134aaca38e701f9a14ee5ab9e" translate="yes" xml:space="preserve">
          <source>Calls the destructor &lt;code&gt;~this()&lt;/code&gt; for the object referred to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a class or interface reference) or for the object pointed to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a pointer to a &lt;code&gt;struct&lt;/code&gt;). Arrays of structs call the destructor, if defined, for each element in the array. If no destructor is defined, this step has no effect.</source>
          <target state="translated">Вызывает деструктор &lt;code&gt;~this()&lt;/code&gt; для объекта, на который ссылается &lt;code&gt;x&lt;/code&gt; (если &lt;code&gt;x&lt;/code&gt; является ссылкой на класс или интерфейс) или для объекта, на который указывает &lt;code&gt;x&lt;/code&gt; (если &lt;code&gt;x&lt;/code&gt; является указателем на &lt;code&gt;struct&lt;/code&gt; ). Массивы структур вызывают деструктор, если он определен, для каждого элемента в массиве. Если деструктор не определен, этот шаг не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="d91be267ab03b3c9611f9cbcd4786308f2144fc6" translate="yes" xml:space="preserve">
          <source>Calls to functions with &lt;code&gt;extern(D)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage&lt;/a&gt; (which is the default linkage) are evaluated in the following order: first, if necessary, the address of the function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then, arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</source>
          <target state="translated">Вызовы функций со &lt;a href=&quot;attribute#linkage&quot;&gt;связью &lt;/a&gt; &lt;code&gt;extern(D)&lt;/code&gt; (которая является связью по умолчанию) оцениваются в следующем порядке: сначала, если необходимо, адрес вызываемой функции оценивается (например, в случае вычисленного указателя на функцию или делегата) , Затем аргументы оцениваются слева направо. Наконец, передача передается функции. Пример:</target>
        </trans-unit>
        <trans-unit id="0645e6f6a8a53952c04e63653f8086d201146bb8" translate="yes" xml:space="preserve">
          <source>Calls to the free standing log functions are not directly forwarded to the global &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;sharedLog&lt;/code&gt;. Actually, a thread local &lt;code&gt;Logger&lt;/code&gt; of type &lt;code&gt;StdForwardLogger&lt;/code&gt; processes the log call and then, by default, forwards the created &lt;code&gt;Logger.LogEntry&lt;/code&gt; to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The thread local &lt;code&gt;Logger&lt;/code&gt; is accessible by the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; property. This property allows to assign user defined &lt;code&gt;Logger&lt;/code&gt;. The default &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt; and it will therefore forward all messages to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; can be used to filter log calls before they reach the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Вызовы автономных функций журнала напрямую не перенаправляются в глобальный &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;sharedLog&lt;/code&gt; . На самом деле, поток локального &lt;code&gt;Logger&lt;/code&gt; типа &lt;code&gt;StdForwardLogger&lt;/code&gt; обрабатывает вызов журнала , а затем, по умолчанию, передает созданный &lt;code&gt;Logger.LogEntry&lt;/code&gt; в &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; . Локальный &lt;code&gt;Logger&lt;/code&gt; потока доступен через свойство &lt;code&gt;stdThreadLocalLog&lt;/code&gt; . Это свойство позволяет назначать определенный пользователем &lt;code&gt;Logger&lt;/code&gt; . &lt;code&gt;LogLevel&lt;/code&gt; по умолчанию для &lt;code&gt;stdThreadLocalLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; - &lt;code&gt;LogLevel.all&lt;/code&gt; , и поэтому он будет пересылать все сообщения &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; . &lt;code&gt;LogLevel&lt;/code&gt; из &lt;code&gt;stdThreadLocalLog&lt;/code&gt; может быть использован для бревенчатых фильтра вызовов , прежде чем они достигнут &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb904d86116e0af2b9834a7896df4545d587c42c" translate="yes" xml:space="preserve">
          <source>Can also assign class values</source>
          <target state="translated">Также может присваивать значения классов</target>
        </trans-unit>
        <trans-unit id="0e9fa73b910a6a2eb1eaa95a1ab5ac09bd2a00f0" translate="yes" xml:space="preserve">
          <source>Can be called from either the driver or a &lt;code&gt;debug = Ident;&lt;/code&gt; statement. Unlike version identifier, there isn't any reserved debug identifier so no validation takes place.</source>
          <target state="translated">Может вызываться либо из драйвера, либо из &lt;code&gt;debug = Ident;&lt;/code&gt; заявление. В отличие от идентификатора версии, нет зарезервированного идентификатора отладки, поэтому проверка не выполняется.</target>
        </trans-unit>
        <trans-unit id="38f77fd06cc4025566434eff583d8ad55911f526" translate="yes" xml:space="preserve">
          <source>Can be overridden to support other addresses.</source>
          <target state="translated">Может быть переопределен для поддержки других адресов.</target>
        </trans-unit>
        <trans-unit id="b93c4ede92c61cd906a3c26c9c976c09eb1f2fc5" translate="yes" xml:space="preserve">
          <source>Can start enumeration from a negative position:</source>
          <target state="translated">Может начать подсчет с отрицательного положения:</target>
        </trans-unit>
        <trans-unit id="9a5600ddf1629b08398131936e3e9652bd1d2e46" translate="yes" xml:space="preserve">
          <source>Can variable be read and written by CTFE?</source>
          <target state="translated">Может ли переменная быть прочитана и записана с помощью CTFE?</target>
        </trans-unit>
        <trans-unit id="3b92458a5ee7b262130f2150d91ab4bffe0cab98" translate="yes" xml:space="preserve">
          <source>Can't run semantic on s now, try again later.</source>
          <target state="translated">Не могу запустить семантику сейчас,попробуй позже.</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="77dfd2135f4db726c47299bb55be26f7f4525a46" translate="yes" xml:space="preserve">
          <source>Cancel</source>
          <target state="translated">Cancel</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">Отменить автоматическое расширение загрузки</target>
        </trans-unit>
        <trans-unit id="33b8203d640b9445058eff13b7f608ffa2a1d260" translate="yes" xml:space="preserve">
          <source>Cannot access &lt;code&gt;__gshared&lt;/code&gt; variables.</source>
          <target state="translated">Невозможно получить доступ &lt;code&gt;__gshared&lt;/code&gt; переменным __gshared .</target>
        </trans-unit>
        <trans-unit id="23679ec318316b42991fb0add8c6df84610db970" translate="yes" xml:space="preserve">
          <source>Cannot access unions that have pointers or references overlapping with other types.</source>
          <target state="translated">Невозможно получить доступ к объединениям,в которых указатели или ссылки пересекаются с другими типами.</target>
        </trans-unit>
        <trans-unit id="486e3c068e9f84acb903fe338c21a7a8da40f7e4" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for class or interface references.</source>
          <target state="translated">Невозможно использовать инициализаторы &lt;code&gt;void&lt;/code&gt; для ссылок на класс или интерфейс.</target>
        </trans-unit>
        <trans-unit id="71a9611e8c1a236df296e1967a0f6238ddd70798" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for pointers.</source>
          <target state="translated">Нельзя использовать &lt;code&gt;void&lt;/code&gt; инициализаторы для указателей.</target>
        </trans-unit>
        <trans-unit id="774c0fbc4f368f6c2081f7a0dddc8b68729cb7f6" translate="yes" xml:space="preserve">
          <source>Canonical decomposition. The result is canonically equivalent sequence.</source>
          <target state="translated">Каноническое разложение.Результат-канонически эквивалентная последовательность.</target>
        </trans-unit>
        <trans-unit id="aae48ee7b1f403f38486b8bf47778fda77282b5f" translate="yes" xml:space="preserve">
          <source>Canonical name, when &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; is used.</source>
          <target state="translated">Каноническое имя, когда используется &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca2d0802f87ef08825202a1ca29c54992dad17b0" translate="yes" xml:space="preserve">
          <source>Capabilities of the CPU the program is running on.</source>
          <target state="translated">Возможности процессора,на котором работает программа.</target>
        </trans-unit>
        <trans-unit id="7e1973f266a216415dc191028046ea7f74365eb7" translate="yes" xml:space="preserve">
          <source>Capacity desired. This constructor is defined only if &lt;code&gt; ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;.</source>
          <target state="translated">Вместимость желаемая. Этот конструктор определяется, только если &lt;code&gt; ParentAllocator&lt;/code&gt; не является &lt;code&gt;NullAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70603ccef126aa6da95612288168a613c4bc83f0" translate="yes" xml:space="preserve">
          <source>Capitalize a the first character of a ASCII string.</source>
          <target state="translated">Заглавная буква первого символа ASCII-строки.</target>
        </trans-unit>
        <trans-unit id="7bac59f23d8a421d02552a2b75009a6de4d133eb" translate="yes" xml:space="preserve">
          <source>Capitalize an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; or string, meaning convert the first character to upper case and subsequent characters to lower case.</source>
          <target state="translated">Используйте заглавные буквы для &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;входного диапазона&lt;/a&gt; или строки, что означает преобразование первого символа в верхний регистр и последующих символов в нижний регистр.</target>
        </trans-unit>
        <trans-unit id="d87b28abafacc3e31f8a5ef814dc1a89c95adc81" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of &lt;code&gt;s&lt;/code&gt; and convert the rest of &lt;code&gt;s&lt;/code&gt; to lowercase.</source>
          <target state="translated">Заглавные буквы первого символа &lt;code&gt;s&lt;/code&gt; и преобразовать остальные &lt;code&gt;s&lt;/code&gt; в нижний регистр.</target>
        </trans-unit>
        <trans-unit id="63beb67c34339e7c0d71b7c05343dfc0c5c06706" translate="yes" xml:space="preserve">
          <source>Captures a range state.</source>
          <target state="translated">Захватывает состояние дальности.</target>
        </trans-unit>
        <trans-unit id="6e0d5cedfdd10366517f607a93eeeef9b4785a51" translate="yes" xml:space="preserve">
          <source>Carian</source>
          <target state="translated">Carian</target>
        </trans-unit>
        <trans-unit id="df10067f5a8780a3c7f1ce6b060b8d78df100b22" translate="yes" xml:space="preserve">
          <source>Carriage return</source>
          <target state="translated">Возврат вагона</target>
        </trans-unit>
        <trans-unit id="b94582323a02af8750c89d9914ff8a094fbada5b" translate="yes" xml:space="preserve">
          <source>Carriage return (U+000D).</source>
          <target state="translated">Возврат вагона (U+000D).</target>
        </trans-unit>
        <trans-unit id="9254c4bba00f5ff69304a7921d3118fcbac7e6b8" translate="yes" xml:space="preserve">
          <source>Case</source>
          <target state="translated">Case</target>
        </trans-unit>
        <trans-unit id="af7c0d9ee5c8a6c4478105142a141d1bad096c35" translate="yes" xml:space="preserve">
          <source>Case expressions must all evaluate to distinct values. Const or immutable variables must all have different names. If they share a value, the first case statement with that value gets control. There must be exactly one default statement.</source>
          <target state="translated">Случайные выражения должны оцениваться до различных значений.Констные или неизменяемые переменные должны иметь разные имена.Если они разделяют значение,то первый оператор регистра с этим значением получает управление.Должен быть ровно один оператор по умолчанию.</target>
        </trans-unit>
        <trans-unit id="be29d0c965453b901d4ad20bdc8e2ddd09f27c5c" translate="yes" xml:space="preserve">
          <source>Case insensitive matching.</source>
          <target state="translated">Чувствительное совпадение корпуса.</target>
        </trans-unit>
        <trans-unit id="b632747e3a93dfa45ef0653a66ab6ac246268230" translate="yes" xml:space="preserve">
          <source>Case statements and default statements associated with the switch can be nested within block statements; they do not have to be in the outermost block. For example, this is allowed:</source>
          <target state="translated">Операторы корпуса и операторы по умолчанию,связанные с переключателем,могут быть вложены в блочные операторы;они не обязательно должны быть во внешнем блоке.Например,это разрешено:</target>
        </trans-unit>
        <trans-unit id="4830655a69813534d85f86f1ac7683b83fc06b02" translate="yes" xml:space="preserve">
          <source>Case-insensitive find of a string</source>
          <target state="translated">Чувствительное к регистру обнаружение строки</target>
        </trans-unit>
        <trans-unit id="22a0daee669e27ee86078432c6d32a4c0da14fe0" translate="yes" xml:space="preserve">
          <source>Case-insensitive string comparison (&lt;a href=&quot;#sicmp&quot;&gt;&lt;code&gt;sicmp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#icmp&quot;&gt;&lt;code&gt;icmp&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Сравнение строк без &lt;a href=&quot;#sicmp&quot;&gt; &lt;code&gt;sicmp&lt;/code&gt; &lt;/a&gt; регистра ( sicmp , &lt;a href=&quot;#icmp&quot;&gt; &lt;code&gt;icmp&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc02e22f8ccf2c7182decb6993c9ab41402098ce" translate="yes" xml:space="preserve">
          <source>Case-sensitivity of the comparison.</source>
          <target state="translated">Чувствительность сравнения.</target>
        </trans-unit>
        <trans-unit id="8647c28bed14fb487e34d3da55fb4ace9c3a88fa" translate="yes" xml:space="preserve">
          <source>CaseRangeStatement</source>
          <target state="translated">CaseRangeStatement</target>
        </trans-unit>
        <trans-unit id="f31bf93714d4f8de709a473ac493e8917fd94741" translate="yes" xml:space="preserve">
          <source>CaseSensitive &lt;code&gt;cs&lt;/code&gt;</source>
          <target state="translated">CaseSensitive &lt;code&gt;cs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82cbdef9815d26de04f79b63bed3258b574ec1e5" translate="yes" xml:space="preserve">
          <source>CaseStatements* &lt;strong id=&quot;cases&quot;&gt;cases&lt;/strong&gt;;</source>
          <target state="translated">CaseStatements * &lt;strong id=&quot;cases&quot;&gt;дел&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="93e81c6075ed3230ff50ed8c47578708810401aa" translate="yes" xml:space="preserve">
          <source>Case_Ignorable</source>
          <target state="translated">Case_Ignorable</target>
        </trans-unit>
        <trans-unit id="744f1d9b60891d9266196d1c3e78b1d6da592b82" translate="yes" xml:space="preserve">
          <source>Cased</source>
          <target state="translated">Cased</target>
        </trans-unit>
        <trans-unit id="f3d4dffe4c9ebac969ee4f02157e5740619b3299" translate="yes" xml:space="preserve">
          <source>Casing</source>
          <target state="translated">Casing</target>
        </trans-unit>
        <trans-unit id="fdce1732b6c6c14b93a5e9a8f896d5e70598b645" translate="yes" xml:space="preserve">
          <source>Cast Expressions</source>
          <target state="translated">Литые экспрессии</target>
        </trans-unit>
        <trans-unit id="1be1f5579be197b60f4cbccf065fa7be7bb581e6" translate="yes" xml:space="preserve">
          <source>Cast Operator Overloading</source>
          <target state="translated">Перегрузка оператора литья</target>
        </trans-unit>
        <trans-unit id="5a95ed2864a76fc66062c5a7f51b3cb5c4d55c8a" translate="yes" xml:space="preserve">
          <source>Cast Operators</source>
          <target state="translated">Литые операторы</target>
        </trans-unit>
        <trans-unit id="ca826936bee948f2eb775d1f8e1ae92d516c0afe" translate="yes" xml:space="preserve">
          <source>Cast is not necessary if the type of the variable is inferred. See the example below.</source>
          <target state="translated">Выводить тип переменной не требуется.См.пример ниже.</target>
        </trans-unit>
        <trans-unit id="25e55b52ee2f3dc95810f24ff7dd2b0e1de46b08" translate="yes" xml:space="preserve">
          <source>CastExpression</source>
          <target state="translated">CastExpression</target>
        </trans-unit>
        <trans-unit id="f137db9c32541b4a024e2e40ec97ea3e4571d7c9" translate="yes" xml:space="preserve">
          <source>Casting a class object to an interface consists of adding the offset of the interface's corresponding vptr to the address of the base of the object. Casting an interface ptr back to the class type it came from involves getting the correct offset to subtract from it from the object.Interface entry at vtbl[0]. Adjustor thunks are created and pointers to them stored in the method entries in the vtbl[] in order to set the this pointer to the start of the object instance corresponding to the implementing method.</source>
          <target state="translated">Привязка объекта класса к интерфейсу состоит в добавлении смещения соответствующего vptr интерфейса к адресу базы объекта.Обращение интерфейса ptr обратно к типу класса,из которого он вышел,включает в себя получение корректного смещения для вычитания из него из записи object.Interface на vtbl[0].Для установки этого указателя на начало экземпляра объекта,соответствующего методу реализации,в элементах метода vtbl[]создаются элементы настройки и указатели на них.</target>
        </trans-unit>
        <trans-unit id="2be16817be1151d2bfd103342ffb9b83c9bc8eec" translate="yes" xml:space="preserve">
          <source>Casting a dynamic array to another dynamic array is done only if the array lengths multiplied by the element sizes match. The cast is done as a type paint, with the array length adjusted to match any change in element size. If there's not a match, a runtime error is generated.</source>
          <target state="translated">Вывод динамического массива в другой динамический массив производится только в том случае,если совпадают длины массивов,умноженные на размеры элементов.Выводится как закраска типа,при этом длина массива подстраивается под любое изменение размера элемента.Если совпадение отсутствует,генерируется ошибка во время выполнения.</target>
        </trans-unit>
        <trans-unit id="16edfc7539440dbdc02f7a14941c4d5ef8ef9a5e" translate="yes" xml:space="preserve">
          <source>Casting a floating point literal from one type to another changes its type, but internally it is retained at full precision for the purposes of constant folding.</source>
          <target state="translated">Литье с плавающей точкой буквально от одного типа к другому меняет свой тип,но внутренне оно сохраняется с полной точностью для целей постоянного складывания.</target>
        </trans-unit>
        <trans-unit id="11324dd9fa7b8d9c53df605d6416fafef2a68188" translate="yes" xml:space="preserve">
          <source>Casting a floating point value to an integral type is the equivalent of converting to an integer using truncation.</source>
          <target state="translated">Приведение значения с плавающей точкой к интегральному типу эквивалентно приведению к целому числу с использованием усечения.</target>
        </trans-unit>
        <trans-unit id="f259cd40444c3107ae944acf4631f694eae6b61d" translate="yes" xml:space="preserve">
          <source>Casting a pointer type to and from a class type is done as a type paint (i.e. a reinterpret cast).</source>
          <target state="translated">Литье указателя на тип класса и обратно выполняется в виде типовой краски (т.е.переинтерпретировать литье).</target>
        </trans-unit>
        <trans-unit id="67471401dacb96c319b67d90467f1e1ec414ef57" translate="yes" xml:space="preserve">
          <source>Casting a value</source>
          <target state="translated">Кастинг стоимости</target>
        </trans-unit>
        <trans-unit id="c6340b2b57764ca857638ab68adda2ab272e357c" translate="yes" xml:space="preserve">
          <source>Casting an expression to &lt;code&gt;void&lt;/code&gt; type is allowed to mark that the result is unused. On &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt;, it could be used properly to avoid &quot;has no effect&quot; error.</source>
          <target state="translated">Приведение выражения к типу &lt;code&gt;void&lt;/code&gt; позволяет пометить, что результат не используется. На &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt; его можно использовать правильно, чтобы избежать ошибки &amp;laquo;не имеет никакого эффекта&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="01335a9c442d0255ed0b8bd54d5bf5a26e8b8dab" translate="yes" xml:space="preserve">
          <source>Casting operator to integral, &lt;code&gt;bool&lt;/code&gt;, or floating point type. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpCast&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt;. Otherwise, casting to &lt;code&gt;bool&lt;/code&gt; yields &lt;code&gt; get != 0&lt;/code&gt; and casting to another integral that can represent all values of &lt;code&gt;T&lt;/code&gt; returns &lt;code&gt;get&lt;/code&gt; promoted to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Оператор приведения к целочисленному, &lt;code&gt;bool&lt;/code&gt; или плавающему типу. Если &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;hookOpCast&lt;/code&gt; , вызов немедленно возвращает &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; . В противном случае, приведение к &lt;code&gt;bool&lt;/code&gt; дает &lt;code&gt; get != 0&lt;/code&gt; и приводился к другому интегралу , который может представлять все значения &lt;code&gt;T&lt;/code&gt; возвратов &lt;code&gt;get&lt;/code&gt; звание &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563db6d9dd42954287b5cda42119295bd4e28aa4" translate="yes" xml:space="preserve">
          <source>Casting pointers to non-pointers and vice versa is allowed.</source>
          <target state="translated">Допускается литье указателей на не указатели и наоборот.</target>
        </trans-unit>
        <trans-unit id="e8c8325b9ae374bf1edc7d50c4d5a016a9981e5a" translate="yes" xml:space="preserve">
          <source>Casting to a &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; replaces the qualifiers to the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;Приведение&lt;/i&gt;&lt;/a&gt; к &lt;i&gt;CastQual&lt;/i&gt; заменяет квалификаторы на тип &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;выражения UnaryExpression&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d98bf7b9cde5141dc8af74c8c9759ef593ae47b" translate="yes" xml:space="preserve">
          <source>Casting to/from &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; may break type system guarantees. Use with care.</source>
          <target state="translated">Приведение к / от &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; может нарушить системные гарантии типа. Используйте с осторожностью.</target>
        </trans-unit>
        <trans-unit id="b02f79fb40c6ba2556a5ea0081aed386869f0012" translate="yes" xml:space="preserve">
          <source>Casting with no &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; or &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; removes any top level &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;inout&lt;/code&gt; type modifiers from the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Кастинг без какого - либо &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;типа&lt;/i&gt;&lt;/a&gt; или &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; удаляет верхний уровень &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; , &lt;code&gt;shared&lt;/code&gt; или &lt;code&gt;inout&lt;/code&gt; модификаторов типа от типа &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;УнарноеВыражения&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5591322bc1301d82b541b6b5ad169c351dc74a45" translate="yes" xml:space="preserve">
          <source>Casts a mutable array to an immutable array in an idiomatic manner. Technically, &lt;code&gt;assumeUnique&lt;/code&gt; just inserts a cast, but its name documents assumptions on the part of the caller. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; should only be called when there are no more active mutable aliases to elements of &lt;code&gt; arr&lt;/code&gt;. To strengthen this assumption, &lt;code&gt;assumeUnique(arr)&lt;/code&gt; also clears &lt;code&gt;arr&lt;/code&gt; before returning. Essentially &lt;code&gt; assumeUnique(arr)&lt;/code&gt; indicates commitment from the caller that there is no more mutable access to any of &lt;code&gt;arr&lt;/code&gt;'s elements (transitively), and that all future accesses will be done through the immutable array returned by &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">Преобразует изменяемый массив в неизменяемый массив идиоматическим образом. Технически, &lt;code&gt;assumeUnique&lt;/code&gt; просто вставляет приведение, но его имя документирует предположения со стороны вызывающей стороны. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; следует вызывать только тогда, когда больше нет активных изменяемых псевдонимов для элементов &lt;code&gt; arr&lt;/code&gt; . Чтобы усилить это предположение, предположим, что &lt;code&gt;assumeUnique(arr)&lt;/code&gt; также очищает &lt;code&gt;arr&lt;/code&gt; перед возвратом. По сути, &lt;code&gt; assumeUnique(arr)&lt;/code&gt; указывает обязательство вызывающей стороны, что нет более изменчивого доступа к любому из элементов &lt;code&gt;arr&lt;/code&gt; (транзитивно), и что все будущие обращения будут осуществляться через неизменяемый массив, возвращаемый &lt;code&gt;assumeUnique&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96fd17cf1de8b408679f9b1db49477fb8f0c66b6" translate="yes" xml:space="preserve">
          <source>Casts that break the type system.</source>
          <target state="translated">Отбрасывает,что нарушает систему типов.</target>
        </trans-unit>
        <trans-unit id="bc260f3af1fc6e8bf46c5b8f8a854fbc6153096b" translate="yes" xml:space="preserve">
          <source>Cat Expressions</source>
          <target state="translated">Кошачьи выражения</target>
        </trans-unit>
        <trans-unit id="a953a29fa47d85867e2fab2716c48cee491dd470" translate="yes" xml:space="preserve">
          <source>CatExpression</source>
          <target state="translated">CatExpression</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="d3ce6d6c33d89c5cd835012c244acc4d8b858a0e" translate="yes" xml:space="preserve">
          <source>CatchParameter</source>
          <target state="translated">CatchParameter</target>
        </trans-unit>
        <trans-unit id="5e59a1d3b6be9c8f0e29f469cc4ebfb54cc7e205" translate="yes" xml:space="preserve">
          <source>Catches</source>
          <target state="translated">Catches</target>
        </trans-unit>
        <trans-unit id="f1645524550ec6b1dbf604c910de525c1199c393" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned and &lt;code&gt;result&lt;/code&gt; is set to the result of the expression.</source>
          <target state="translated">Ловит и возвращает исключение, выброшенное из данного выражения. Если исключение не выдается, возвращается значение null и &lt;code&gt;result&lt;/code&gt; устанавливается равным результату выражения.</target>
        </trans-unit>
        <trans-unit id="040c55a2a9c3c731e36a7abc0e21f539bc1f80a5" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Ловит и возвращает исключение, выброшенное из данного выражения. Если исключение не выдается, возвращается ноль. &lt;code&gt;E&lt;/code&gt; может быть &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d90ffac3b749155c40310e22300174e6246501c0" translate="yes" xml:space="preserve">
          <source>Catches the exception thrown from the given expression and returns the msg property of that exception. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Ловит исключение, выброшенное из данного выражения, и возвращает свойство msg этого исключения. Если исключение не выдается, возвращается ноль. &lt;code&gt;E&lt;/code&gt; может быть &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73a0dfe4cefda0d8bb54b75566ce6c7751cb0769" translate="yes" xml:space="preserve">
          <source>Catching C++ Class Objects</source>
          <target state="translated">Поймать объекты класса C++</target>
        </trans-unit>
        <trans-unit id="df7467bf765f309d90be05cf8631fc4bacfe7590" translate="yes" xml:space="preserve">
          <source>Categories of types</source>
          <target state="translated">Категории типов</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="729cda91611ce285ba0ef14cc4efdd486065b7fa" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an</source>
          <target state="translated">Заставляет ассемблера издавать NOP инструкции для выравнивания следующей инструкции ассемблера на</target>
        </trans-unit>
        <trans-unit id="147c8bbdbf1f140f88bd53dffd29cf82c9997a05" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an even boundary.</source>
          <target state="translated">Заставляет ассемблера излучать NOP инструкции,чтобы выровнять следующую инструкцию ассемблера по четной границе.</target>
        </trans-unit>
        <trans-unit id="70c5dda624176ab62b854d62901ed2b2ed8a9f72" translate="yes" xml:space="preserve">
          <source>Causes the compiler to not generate the function prolog and epilog sequences. This means such is the responsibility of inline assembly programmer, and is normally used when the entire function is to be written in assembler.</source>
          <target state="translated">Причина,по которой компилятор не генерирует последовательности функций пролога и эпилога.Это означает,что за это отвечает программист встроенной ассемблерной сборки,и обычно используется,когда вся функция должна быть написана на ассемблере.</target>
        </trans-unit>
        <trans-unit id="1fd6a880ee16bb33003559b204f8a2cff5a9e90c" translate="yes" xml:space="preserve">
          <source>Cc</source>
          <target state="translated">Cc</target>
        </trans-unit>
        <trans-unit id="51f00921e108b6ca8be5e3997778036a6ec831aa" translate="yes" xml:space="preserve">
          <source>Cells in the delimiter row contain hyphens (&lt;code&gt;-&lt;/code&gt;) and optional colons (&lt;code&gt;:&lt;/code&gt;). A &lt;code&gt;:&lt;/code&gt; to the left of the hyphens creates a left-aligned column, a &lt;code&gt;:&lt;/code&gt; to the right of the hyphens creates a right-aligned column (like the example above), and &lt;code&gt;:&lt;/code&gt;'s on both sides of the hyphens create a center-aligned column.</source>
          <target state="translated">Ячейки в строке разделителя содержат дефис ( &lt;code&gt;-&lt;/code&gt; ) и дополнительное двоеточие ( &lt;code&gt;:&lt;/code&gt; ). A &lt;code&gt;:&lt;/code&gt; слева от дефисов создается столбец с выравниванием по левому краю, a &lt;code&gt;:&lt;/code&gt; справа от дефисов создается столбец с выравниванием по правому краю (как в примере выше), а &lt;code&gt;:&lt;/code&gt; s по обе стороны от дефисов создают центр. выровненный столбец.</target>
        </trans-unit>
        <trans-unit id="20b2af77551ab62ecafee8361a6775168a8911be" translate="yes" xml:space="preserve">
          <source>Centaur Isiah = VIA Nano (family 6, model F) is an out-of-order core.</source>
          <target state="translated">Кентавр Исия=VIA Nano (семейство 6,модель F)-нестандартное ядро.</target>
        </trans-unit>
        <trans-unit id="8408f82534bfffd0ab07188fc9d719f71130e4e0" translate="yes" xml:space="preserve">
          <source>Center &lt;code&gt;s&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;s&lt;/code&gt; doesn't fill.</source>
          <target state="translated">Центр &lt;code&gt;s&lt;/code&gt; в поле &lt;code&gt;width&lt;/code&gt; символов. &lt;code&gt;fillChar&lt;/code&gt; это символ , который будет использоваться для заполнения пространства в поле , что &lt;code&gt;s&lt;/code&gt; не заполняет.</target>
        </trans-unit>
        <trans-unit id="4e74b6056afd83cbdf235c0e1e1aa022d7643f34" translate="yes" xml:space="preserve">
          <source>Center justify &lt;code&gt;r&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;r&lt;/code&gt; doesn't fill.</source>
          <target state="translated">Центр выравнивания &lt;code&gt;r&lt;/code&gt; в поле &lt;code&gt;width&lt;/code&gt; символов. &lt;code&gt;fillChar&lt;/code&gt; - это символ, который будет использоваться для заполнения пространства в поле, которое &lt;code&gt;r&lt;/code&gt; не заполняет.</target>
        </trans-unit>
        <trans-unit id="fb14d77020e4dbef1a189a81fe3dbc04509cb2d1" translate="yes" xml:space="preserve">
          <source>Certain alphabets like German and Greek have no 1:1 upper-lower mapping. Use overload of toUpper which takes full string instead.</source>
          <target state="translated">Некоторые алфавиты,такие как немецкий и греческий,не имеют верхне-нижнего отображения 1:1.Вместо этого используйте перегрузку ToUpper,которая занимает полную строку.</target>
        </trans-unit>
        <trans-unit id="64a2e3e9bc5b4cd297d23de932339bb6c474455f" translate="yes" xml:space="preserve">
          <source>Cf</source>
          <target state="translated">Cf</target>
        </trans-unit>
        <trans-unit id="70b3ae21ee59942a0d41812e09cc5d908774f36f" translate="yes" xml:space="preserve">
          <source>Chain multiple calls to ifThrown, each capturing errors from the entire preceding expression.</source>
          <target state="translated">Цепочки многократных вызовов ifThrown,каждый из которых перехватывает ошибки из всего предыдущего выражения.</target>
        </trans-unit>
        <trans-unit id="6a803e5d1d5407c176b6adb93c4ec23f4ef3c32f" translate="yes" xml:space="preserve">
          <source>Chakma</source>
          <target state="translated">Chakma</target>
        </trans-unit>
        <trans-unit id="5e052ac9c7fd6c9d46817ea48b907dbb7047ae81" translate="yes" xml:space="preserve">
          <source>Cham</source>
          <target state="translated">Cham</target>
        </trans-unit>
        <trans-unit id="c94dac697486986e71af2c37242755c0937be074" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and POSIX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458b3d4cc82936041a171ad6f7ca77493ddeb2bd" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and Posix.</source>
          <target state="translated">Измените каталог на &lt;code&gt;pathname&lt;/code&gt; . Эквивалент &lt;code&gt;cd&lt;/code&gt; на Windows и Posix.</target>
        </trans-unit>
        <trans-unit id="6f314cb3c24c1c8ee48dc8abfd534cc520363d6c" translate="yes" xml:space="preserve">
          <source>Change match (fnmatch-like) callback for wildcard matching</source>
          <target state="translated">Обратный вызов на замену (как в фнэнматче)для подстановочного совпадения.</target>
        </trans-unit>
        <trans-unit id="e8304f2bae085deed1b3c8125f9fa43407a675db" translate="yes" xml:space="preserve">
          <source>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions.</source>
          <target state="translated">Измените режим округления с плавающей запятой в IEEE754 и исключения аппаратных средств с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="9f333c0a78429177429051909d1f599b48a73b54" translate="yes" xml:space="preserve">
          <source>Change the floating-point hardware rounding mode</source>
          <target state="translated">Изменить режим аппаратного округления с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="3d9d32d43390d1a2629123edfc32deb49f461b6a" translate="yes" xml:space="preserve">
          <source>Change the key on an open database. If the current database is not encrypted, this routine will encrypt it. If pNew == 0 or nNew == 0, the database is decrypted.</source>
          <target state="translated">Измените ключ в открытой базе данных.Если текущая база данных не зашифрована,эта рутина зашифрует ее.Если pNew ==0 или nNew ==0,то база данных будет расшифрована.</target>
        </trans-unit>
        <trans-unit id="5ba310a0f8acd1b8bbbdaa00b70d0bff2f5990f6" translate="yes" xml:space="preserve">
          <source>Change this function so the caller doesn't have to be aware of this issue. Either return by value and expect the caller to always check the base ptr as an indication of whether the struct is valid, or set the BlkInfo as a side-effect and return a bool to indicate success.</source>
          <target state="translated">Измените эту функцию так,чтобы вызывающий абонент не должен был знать об этой проблеме.Либо вернитесь по значению и ожидайте,что вызывающий абонент всегда будет проверять базовый ptr как признак того,что структура действительна,либо установите BlkInfo в качестве побочного эффекта и верните bool для индикации успеха.</target>
        </trans-unit>
        <trans-unit id="e7d3b1db7f0a311580f3e633ae63903d1a427f37" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; arguments are not propagated to the call site, only to &lt;code&gt;args&lt;/code&gt; in this struct.</source>
          <target state="translated">Изменения в аргументах &lt;code&gt;ref&lt;/code&gt; и &lt;code&gt;out&lt;/code&gt; не распространяются на сайт вызова, только на &lt;code&gt;args&lt;/code&gt; в этой структуре.</target>
        </trans-unit>
        <trans-unit id="8c06a1392ead6cea3258d7b832ab861bbcb2d0e3" translate="yes" xml:space="preserve">
          <source>Changing the rounding mode in the middle of a function can interfere with optimizations of floating point expressions, as the optimizer assumes that the rounding mode does not change. It is best to change the rounding mode only at the beginning of the function, and keep it until the function returns. It is also best to add the line:</source>
          <target state="translated">Изменение режима округления в середине функции может помешать оптимизации выражений с плавающей точкой,так как оптимизатор предполагает,что режим округления не изменяется.Лучше всего изменить режим округления только в начале функции,и держать его до тех пор,пока функция не вернется.Также лучше всего добавить строку:</target>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="c6b74142b3b389f15ac5cd805f70960cc3a1abf0" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">Char [] &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d66a912fb521a267fef61e2619d881aa8e9c5935" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">Char [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516088a32b97fe8b60ae41af7a9da5ea8c8b89b1" translate="yes" xml:space="preserve">
          <source>Character Entities</source>
          <target state="translated">Характеристики Элементы</target>
        </trans-unit>
        <trans-unit id="669b19e596ff87d2ed122a5266e7aff0c3d614e2" translate="yes" xml:space="preserve">
          <source>Character Literals</source>
          <target state="translated">Буквы персонажей</target>
        </trans-unit>
        <trans-unit id="2760308a0f6d1684065a6510212e96dc91848ae1" translate="yes" xml:space="preserve">
          <source>Character Set</source>
          <target state="translated">Набор символов</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">Классы характера</target>
        </trans-unit>
        <trans-unit id="ad3c933b2dd70972eec55e516f2ae9ffae669d0e" translate="yes" xml:space="preserve">
          <source>Character classification by category and common properties: &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">Классификация персонажей по категориям и общим свойствам: &lt;a href=&quot;#isAlpha&quot;&gt; &lt;code&gt;isAlpha&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt; и другие.</target>
        </trans-unit>
        <trans-unit id="1ef00f56499c816e60a9c87369bcd2210570f41d" translate="yes" xml:space="preserve">
          <source>Character input ranges</source>
          <target state="translated">Диапазоны ввода символов</target>
        </trans-unit>
        <trans-unit id="133c67a5c003572ca8daaddcc62800905a7a14d7" translate="yes" xml:space="preserve">
          <source>Character literals are a single character or escape sequence enclosed by single quotes.</source>
          <target state="translated">Символьные литералы-это одиночная символьная или экранирующая последовательность,заключенная в одиночные кавычки.</target>
        </trans-unit>
        <trans-unit id="aa8ec24f3290e6543c77a63504c45b69a0237e5a" translate="yes" xml:space="preserve">
          <source>Character literals are single characters and resolve to one of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;. If the literal is a &lt;code&gt;\u&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;wchar&lt;/code&gt;. If the literal is a &lt;code&gt;\U&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;dchar&lt;/code&gt;. Otherwise, it resolves to the type with the smallest size it will fit into.</source>
          <target state="translated">Символьные литералы представляют собой одиночные символы и разрешаются в один из типов &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; или &lt;code&gt;dchar&lt;/code&gt; . Если литерал является escape-последовательностью &lt;code&gt;\u&lt;/code&gt; , он разрешается набирать &lt;code&gt;wchar&lt;/code&gt; . Если литерал является escape-последовательностью &lt;code&gt;\U&lt;/code&gt; , он разрешается набирать &lt;code&gt;dchar&lt;/code&gt; . В противном случае он разрешает тип с наименьшим размером, в который он помещается.</target>
        </trans-unit>
        <trans-unit id="3748669139d2553c2dce70085bc8d87e3b65bf04" translate="yes" xml:space="preserve">
          <source>Character to insert between digits.</source>
          <target state="translated">Символ для вставки между цифрами.</target>
        </trans-unit>
        <trans-unit id="b03707df5e411692fe21adde8672bde4c3d712ec" translate="yes" xml:space="preserve">
          <source>Character traits classes specify character properties and provide specific semantics for certain operations on characters and sequences of characters.</source>
          <target state="translated">Классы признаков символов задают свойства символов и обеспечивают определенную семантику для определенных операций с символами и последовательностями символов.</target>
        </trans-unit>
        <trans-unit id="7d08e774321e793244bcf20b89151a8c5636ee9d" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Тип символа для каждой строки, по умолчанию &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ea2c19a4eb8af5f3f4d555aac37a5f0f405718" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;immutable char&lt;/code&gt;.</source>
          <target state="translated">Тип символа для каждой строки, по умолчанию &lt;code&gt;immutable char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fe23e4b9b84f174b905f70c10737ea338eb6786" translate="yes" xml:space="preserve">
          <source>Characters and Entities</source>
          <target state="translated">Символы и объекты</target>
        </trans-unit>
        <trans-unit id="407259c6fa72a57c5df67c0a931d6eaafa218825" translate="yes" xml:space="preserve">
          <source>Characters and Escape Macros</source>
          <target state="translated">Персонажи и макросы &quot;Побег</target>
        </trans-unit>
        <trans-unit id="e688823a84fa6f43670fb82f99c26f690e6bccb5" translate="yes" xml:space="preserve">
          <source>Cheat Sheet</source>
          <target state="translated">Шпаргалка</target>
        </trans-unit>
        <trans-unit id="98fea9560fa564556454626729a76607af1a8cca" translate="yes" xml:space="preserve">
          <source>Check access to d for expression e.d Returns true if the declaration is not accessible.</source>
          <target state="translated">Проверка доступа к выражению d для выражения e.d Возвращает true,если объявление недоступно.</target>
        </trans-unit>
        <trans-unit id="992d8a3514d4f8fb1a7565ecd89e7c7459b088b7" translate="yes" xml:space="preserve">
          <source>Check access to package/module &lt;code&gt;p&lt;/code&gt; from scope &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">Проверьте доступ к пакету / модулю &lt;code&gt;p&lt;/code&gt; из области &lt;code&gt;sc&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
