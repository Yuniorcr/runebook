<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="bfcc76451138cf6e179bded66babeafecdbfe06a" translate="yes" xml:space="preserve">
          <source>The element to stop at.</source>
          <target state="translated">Элемент,на котором нужно остановиться.</target>
        </trans-unit>
        <trans-unit id="b80bff8085fdd511cb9c4d9e05da48019bf3dd74" translate="yes" xml:space="preserve">
          <source>The element type for 32-bit implementation.</source>
          <target state="translated">Тип элемента для 32-битной реализации.</target>
        </trans-unit>
        <trans-unit id="218ef2dcaf3b3057dc646bab34be48640fa2fc83" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;Char[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">Тип элемента для диапазона будет &lt;code&gt;Char[]&lt;/code&gt; . Примитивы диапазона могут &lt;code&gt;StdioException&lt;/code&gt; при ошибке ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="c8e0ad7d182f093115b2321024fb0d43eeab8ccb" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;ubyte[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">Тип элемента для диапазона будет &lt;code&gt;ubyte[]&lt;/code&gt; . Примитивы диапазона могут &lt;code&gt;StdioException&lt;/code&gt; при ошибке ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="146f6e63904487c6bc88a456ffe5bb5d872efab2" translate="yes" xml:space="preserve">
          <source>The element type of &lt;code&gt;R&lt;/code&gt;. &lt;code&gt;R&lt;/code&gt; does not have to be a range. The element type is determined as the type yielded by &lt;code&gt;r.front&lt;/code&gt; for an object &lt;code&gt;r&lt;/code&gt; of type &lt;code&gt;R&lt;/code&gt;. For example, &lt;code&gt;ElementType!(T[])&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T[]&lt;/code&gt; isn't a narrow string; if it is, the element type is &lt;code&gt;dchar&lt;/code&gt;. If &lt;code&gt;R&lt;/code&gt; doesn't have &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;ElementType!R&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Тип элемента &lt;code&gt;R&lt;/code&gt; . &lt;code&gt;R&lt;/code&gt; не должен быть диапазоном. Тип элемента определяется как тип , полученный в результате &lt;code&gt;r.front&lt;/code&gt; для объекта &lt;code&gt;r&lt;/code&gt; типа &lt;code&gt;R&lt;/code&gt; . Например, &lt;code&gt;ElementType!(T[])&lt;/code&gt; - это &lt;code&gt;T&lt;/code&gt; , если &lt;code&gt;T[]&lt;/code&gt; не является узкой строкой; если это так, тип элемента &lt;code&gt;dchar&lt;/code&gt; . Если у &lt;code&gt;R&lt;/code&gt; нет &lt;code&gt;front&lt;/code&gt; , &lt;code&gt;ElementType!R&lt;/code&gt; будет &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="242b60e2b158a7060db8baf4f6cc26e6d87af9f3" translate="yes" xml:space="preserve">
          <source>The element's CData items</source>
          <target state="translated">Элементы CD-данных элемента</target>
        </trans-unit>
        <trans-unit id="c3b9d2b70df47460f19754a079e90ba32c948935" translate="yes" xml:space="preserve">
          <source>The element's child elements</source>
          <target state="translated">Детские элементы элемента</target>
        </trans-unit>
        <trans-unit id="a931fa1a5c6e1ac62a1fb67480e5e8ac09b9bdb7" translate="yes" xml:space="preserve">
          <source>The element's comments</source>
          <target state="translated">Комментарии элемента</target>
        </trans-unit>
        <trans-unit id="a2b54c10854bacd9d44680700556c9e99d65c27d" translate="yes" xml:space="preserve">
          <source>The element's items</source>
          <target state="translated">Элементы элемента</target>
        </trans-unit>
        <trans-unit id="585ede5c120291a9643e02011ada89b79cd9d6f7" translate="yes" xml:space="preserve">
          <source>The element's processing instructions</source>
          <target state="translated">Инструкции по обработке элемента</target>
        </trans-unit>
        <trans-unit id="eb70f51eec72df5d60ca23b74395601f21da9c66" translate="yes" xml:space="preserve">
          <source>The element's text items</source>
          <target state="translated">Текстовые элементы элемента</target>
        </trans-unit>
        <trans-unit id="e5bc2ae39e4f9e29954c5367c1c69157fdd19e00" translate="yes" xml:space="preserve">
          <source>The email address to check</source>
          <target state="translated">Адрес электронной почты для проверки</target>
        </trans-unit>
        <trans-unit id="48e5305233fe3d75b0443ee1f50818a6d648fd6c" translate="yes" xml:space="preserve">
          <source>The email status code</source>
          <target state="translated">Код статуса электронной почты</target>
        </trans-unit>
        <trans-unit id="4346e3e9e5e3a95198a31c78de02c8e03150e933" translate="yes" xml:space="preserve">
          <source>The encoded string</source>
          <target state="translated">Закодированная строка</target>
        </trans-unit>
        <trans-unit id="381ff9274ef41642af8e81eebffce945d9f4f6ee" translate="yes" xml:space="preserve">
          <source>The encoding element type of &lt;code&gt;R&lt;/code&gt;. For narrow strings (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt; and their qualified variants including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;), &lt;code&gt;ElementEncodingType&lt;/code&gt; is the character type of the string. For all other types, &lt;code&gt;ElementEncodingType&lt;/code&gt; is the same as &lt;code&gt;ElementType&lt;/code&gt;.</source>
          <target state="translated">Кодирующий элемент типа &lt;code&gt;R&lt;/code&gt; . Для узких строк ( &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; и их квалифицированных вариантов, включая &lt;code&gt;string&lt;/code&gt; и &lt;code&gt;wstring&lt;/code&gt; ), &lt;code&gt;ElementEncodingType&lt;/code&gt; является типом символа строки. Для всех других типов &lt;code&gt;ElementEncodingType&lt;/code&gt; такой же, как &lt;code&gt;ElementType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ddaa2a73311c2a472b8bde0c140d7d16072aef8" translate="yes" xml:space="preserve">
          <source>The end point of the interval. It is excluded from the interval.</source>
          <target state="translated">Конечная точка интервала.Она исключается из интервала.</target>
        </trans-unit>
        <trans-unit id="3045098b74bc924c86c93e1e08406b98332239d1" translate="yes" xml:space="preserve">
          <source>The endianness that the bytes are assumed to be in.</source>
          <target state="translated">Эндианность,в которой предположительно находятся байты.</target>
        </trans-unit>
        <trans-unit id="d625680f2f5053e8d89e9dc8332e606f7d3ff5c0" translate="yes" xml:space="preserve">
          <source>The endianness that the program was compiled for.</source>
          <target state="translated">Эндианность,для которой была скомпилирована программа.</target>
        </trans-unit>
        <trans-unit id="2c31e59fa05bc473d51ba9ff8b1fbea71679f185" translate="yes" xml:space="preserve">
          <source>The endianness to write the bytes in.</source>
          <target state="translated">Эндианство записывать байты.</target>
        </trans-unit>
        <trans-unit id="4b673a6e15bd55d6aa4a35d2bd69a88952502624" translate="yes" xml:space="preserve">
          <source>The entire contents of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598292bc5270606189fdedc665ef492ceced68f0" translate="yes" xml:space="preserve">
          <source>The entire random number library architecture is derived from the excellent &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C++0X&lt;/a&gt; random number facility proposed by Jens Maurer and contributed to by researchers at the Fermi laboratory (excluding Xorshift).</source>
          <target state="translated">Вся архитектура библиотеки случайных чисел получена из превосходного средства случайных чисел &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C ++ 0X&lt;/a&gt; , предложенного Дженсом Маурером и предоставленного исследователями в лаборатории Ферми (исключая Xorshift).</target>
        </trans-unit>
        <trans-unit id="694779fd846cde08f1b1e4968157c26de84e61a0" translate="yes" xml:space="preserve">
          <source>The entry point of this module is &lt;code&gt;traceHandlerOpApplyImpl&lt;/code&gt;, and the only really &quot;public&quot; symbol (since all &lt;code&gt;rt&lt;/code&gt; symbols are private). In the future, this implementation should probably be made idiomatic, so that it can for example work with attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888201d962022c79856dc1d83803a781978d38cd" translate="yes" xml:space="preserve">
          <source>The equality and inequality operators are treated separately because while practically all user-defined types can be compared for equality, only a subset of types have a meaningful ordering. For example, while it makes sense to determine if two RGB color vectors are equal, it is not meaningful to say that one color is greater than another, because colors do not have an ordering. Thus, one would define &lt;code&gt;opEquals&lt;/code&gt; for a &lt;code&gt;Color&lt;/code&gt; type, but not &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">Операторы равенства и неравенства рассматриваются отдельно, потому что, хотя практически все пользовательские типы можно сравнивать на равенство, только подмножество типов имеет значимый порядок. Например, хотя имеет смысл определить, равны ли два цветовых вектора RGB, не имеет смысла говорить, что один цвет больше другого, потому что цвета не имеют порядка. Таким образом, можно определить &lt;code&gt;opEquals&lt;/code&gt; для типа &lt;code&gt;Color&lt;/code&gt; , но не &lt;code&gt;opCmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1ab6f47e6e402fb3a24bfb9f554e1d0036e9f7" translate="yes" xml:space="preserve">
          <source>The equivalent of member function pointers can be constructed using anonymous lambda functions:</source>
          <target state="translated">Эквивалент указателей членских функций может быть построен с использованием анонимных лямбда-функций:</target>
        </trans-unit>
        <trans-unit id="b934e5ce8d172dbc9fefc885ad8f4ba875129f8a" translate="yes" xml:space="preserve">
          <source>The error message incase &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</source>
          <target state="translated">Сообщение об ошибке в случае &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74494fb82c47edd9793007790b8ec76ed5efb325" translate="yes" xml:space="preserve">
          <source>The error message to put in the exception if it is thrown.</source>
          <target state="translated">Сообщение об ошибке,которое нужно вставить в исключение,если оно брошено.</target>
        </trans-unit>
        <trans-unit id="ac179c7a25f054b9a84b196608bf4de9e907b671" translate="yes" xml:space="preserve">
          <source>The error number.</source>
          <target state="translated">Номер ошибки.</target>
        </trans-unit>
        <trans-unit id="bb2bfcd8d277ad988cd58683c68c61867529b4d8" translate="yes" xml:space="preserve">
          <source>The escape sequences listed in &lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;Escape-&lt;/i&gt;&lt;/a&gt; последовательности, перечисленные в &lt;i&gt;EscapeSequence&lt;/i&gt; :</target>
        </trans-unit>
        <trans-unit id="813068399b629e54556fe2331c136edacd43967a" translate="yes" xml:space="preserve">
          <source>The escapes section is a series of substitutions which replace special characters with a string. It's useful when the output format requires escaping of certain characters, for example in HTML &lt;b&gt;&amp;amp;&lt;/b&gt; should be escaped with &lt;b&gt;&amp;amp;amp;&lt;/b&gt;.</source>
          <target state="translated">Раздел escapes представляет собой серию замен, которые заменяют специальные символы строкой. Это полезно, когда формат вывода требует экранирования определенных символов, например, в HTML, &lt;b&gt;и&lt;/b&gt; должен экранироваться с помощью &lt;b&gt;&amp;amp; amp; &lt;/b&gt;,</target>
        </trans-unit>
        <trans-unit id="75a80775312b743d79dc5f0458ad6638745e66ff" translate="yes" xml:space="preserve">
          <source>The event handler that gets called to inform of upload/download progress.</source>
          <target state="translated">Обработчик событий,который получает вызов,чтобы сообщить о прогрессе загрузки/загрузки.</target>
        </trans-unit>
        <trans-unit id="28ee4bbd0a86e9401b5c283e4626c6777888197c" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending.</source>
          <target state="translated">Обработчик событий,который вызывается,когда данные необходимы для отправки.</target>
        </trans-unit>
        <trans-unit id="ec0b1eb03ea092eed8857727c86d04dbd3bf6621" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending. The length of the &lt;code&gt;void[]&lt;/code&gt; specifies the maximum number of bytes that can be sent.</source>
          <target state="translated">Обработчик события, который вызывается, когда данные необходимы для отправки. Длина &lt;code&gt;void[]&lt;/code&gt; указывает максимальное количество байтов, которое может быть отправлено.</target>
        </trans-unit>
        <trans-unit id="c126a38e12f3ea900a6ea7dfdda2e34138f69566" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the curl backend needs to seek the data to be sent.</source>
          <target state="translated">Обработчик событий,который вызывается,когда бэкенду свертывания нужно искать данные для отправки.</target>
        </trans-unit>
        <trans-unit id="c7e1c85c7ca7e98c1826ed981521b324453ed7c7" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the net socket has been created but a &lt;code&gt;connect()&lt;/code&gt; call has not yet been done. This makes it possible to set misc. socket options.</source>
          <target state="translated">Обработчик события, который вызывается, когда сетевой сокет создан, но вызов &lt;code&gt;connect()&lt;/code&gt; еще не выполнен. Это позволяет установить разное. варианты сокетов.</target>
        </trans-unit>
        <trans-unit id="02f312ca0b7e961f5a4f5917e4aa7edb41e07360" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data.</source>
          <target state="translated">Обработчик событий,принимающий входящие данные.</target>
        </trans-unit>
        <trans-unit id="b87e0289d3effbf7cf04a5f7cfbfced82cc1d3d4" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns.</source>
          <target state="translated">Обработчик событий,принимающий входящие данные.Обязательно скопируйте входящий ubyte[],так как он не гарантированно будет действителен после возвращения обратного вызова.</target>
        </trans-unit>
        <trans-unit id="4c604b49f0361c7bde910df7da9e4d17ed0e24e3" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming headers for protocols that uses headers.</source>
          <target state="translated">Обработчик событий,получающий входящие заголовки для протоколов,использующих заголовки.</target>
        </trans-unit>
        <trans-unit id="52a6be95e3d2f965951f9ddade7c43108c67742d" translate="yes" xml:space="preserve">
          <source>The event module provides a primitive for lightweight signaling of other threads (emulating Windows events on Posix)</source>
          <target state="translated">Модуль событий предоставляет примитив для легкой сигнализации других потоков (эмулируя события Windows на Posix).</target>
        </trans-unit>
        <trans-unit id="76cbd20f024df6b80d67a632d5c0a1a01fd91d83" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOExtString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">Точный формат точно такой же, как описано в &lt;code&gt;toISOExtString&lt;/code&gt; , за исключением того, что допускаются конечные нули, включая дробные секунды со всеми нулями. Однако десятичная точка, за которой ничего не следует, недопустима. Кроме того, хотя &lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; &lt;/a&gt; никогда не будет генерировать строку с более чем 7 цифрами за доли секунды (поскольку это предел с точностью до гекто-наносекунды), она будет позволять более 7 цифр для чтения строк из других источников с более высокой точностью ( однако любые цифры после 7 будут усечены).</target>
        </trans-unit>
        <trans-unit id="dbfdac6af98f1a47c12d787fa314f16848732e36" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOString&quot;&gt;&lt;code&gt;toISOString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">Точный формат в точности соответствует описанию &lt;code&gt;toISOString&lt;/code&gt; , за исключением того, что допускаются конечные нули, включая дробные секунды со всеми нулями. Однако десятичная точка, за которой ничего не следует, недопустима. Кроме того, хотя &lt;a href=&quot;#toISOString&quot;&gt; &lt;code&gt;toISOString&lt;/code&gt; &lt;/a&gt; никогда не будет генерировать строку с более чем 7 цифрами за доли секунды (потому что это предел с точностью до гекто-наносекунды), она позволит использовать более 7 цифр для чтения строк из других источников, которые имеют более высокую точность ( однако любые цифры после 7 будут усечены).</target>
        </trans-unit>
        <trans-unit id="8035aabeb60ff48fad9d3507168fac10a852f522" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toSimpleString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toSimpleString&quot;&gt;&lt;code&gt;toSimpleString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">Точный формат точно такой же, как описано в &lt;code&gt;toSimpleString&lt;/code&gt; , за исключением того, что допускаются конечные нули, включая дробные секунды со всеми нулями. Однако десятичная точка, за которой ничего не следует, недопустима. Кроме того, хотя &lt;a href=&quot;#toSimpleString&quot;&gt; &lt;code&gt;toSimpleString&lt;/code&gt; &lt;/a&gt; никогда не будет генерировать строку с более чем 7 цифрами за доли секунды (поскольку это предел с точностью до гекто-наносекунды), он будет разрешать более 7 цифр для чтения строк из других источников с более высокой точностью ( однако любые цифры после 7 будут усечены).</target>
        </trans-unit>
        <trans-unit id="65836ccc655a37d33dfc806f525851b4dc381228" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged pointer in the struct A. The pointer is of type &lt;code&gt;uint*&lt;/code&gt; as specified by the first argument, and is named x, as specified by the second argument.</source>
          <target state="translated">В приведенном выше примере создается теговый указатель в структуре A. Указатель имеет тип &lt;code&gt;uint*&lt;/code&gt; как указано в первом аргументе, и называется x, как указано во втором аргументе.</target>
        </trans-unit>
        <trans-unit id="a8289a8de27bbcdd9e4b7b9885e6899b4349a782" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged reference to an Object in the struct A. This expects the same parameters as &lt;code&gt;taggedPointer&lt;/code&gt;, except the first argument which must be a class type instead of a pointer type.</source>
          <target state="translated">Приведенный выше пример создает теговую ссылку на Object в структуре A. Это ожидает те же параметры, что и &lt;code&gt;taggedPointer&lt;/code&gt; , за исключением первого аргумента, который должен быть типом класса вместо типа указателя.</target>
        </trans-unit>
        <trans-unit id="95c0102684861c4577b62ad69eb70ff34b2390d6" translate="yes" xml:space="preserve">
          <source>The example above wreaks havoc on client code because it is modifying arrays that callers considered immutable. To obtain an immutable array from the writable array &lt;code&gt;buffer&lt;/code&gt;, replace the last line with:</source>
          <target state="translated">Приведенный выше пример наносит ущерб клиентскому коду, поскольку он модифицирует массивы, которые вызывающие абоненты считают неизменяемыми. Чтобы получить неизменяемый массив из &lt;code&gt;buffer&lt;/code&gt; массива с возможностью записи , замените последнюю строку на:</target>
        </trans-unit>
        <trans-unit id="399a22d99c9e7b3b5ee30ddef81ec062aec6bdce" translate="yes" xml:space="preserve">
          <source>The example below features an allocator modeled after &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;, which uses a battery of free-list allocators spaced so as to keep internal fragmentation to a minimum. The &lt;code&gt;FList&lt;/code&gt; definitions specify no bounds for the freelist because the &lt;code&gt;Segregator&lt;/code&gt; does all size selection in advance.</source>
          <target state="translated">В приведенном ниже примере представлен распределитель, смоделированный по образцу &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt; , который использует батарею распределителей свободных списков, разнесенных так, чтобы минимизировать внутреннюю фрагментацию. Определения &lt;code&gt;FList&lt;/code&gt; не определяют границ для freelist, потому что &lt;code&gt;Segregator&lt;/code&gt; делает весь выбор размера заранее.</target>
        </trans-unit>
        <trans-unit id="03c82011a176c73b7fd2e55e8d4ca5d5e5bc2671" translate="yes" xml:space="preserve">
          <source>The example sets a new &lt;code&gt;FileLogger&lt;/code&gt; as new &lt;code&gt;sharedLog&lt;/code&gt;.  If at some point you want to use the original default logger again, you can use &lt;code&gt;sharedLog = null;&lt;/code&gt;. This will put back the original.</source>
          <target state="translated">Пример устанавливает новый &lt;code&gt;FileLogger&lt;/code&gt; как новый &lt;code&gt;sharedLog&lt;/code&gt; . Если в какой-то момент вы захотите снова использовать оригинальный регистратор по умолчанию, вы можете использовать &lt;code&gt;sharedLog = null;&lt;/code&gt; , Это вернет оригинал.</target>
        </trans-unit>
        <trans-unit id="ad582bc954e72accfcbe7e749d32e98547d0b17c" translate="yes" xml:space="preserve">
          <source>The exception module defines all system-level exceptions and provides a mechanism to alter system-level error handling.</source>
          <target state="translated">Модуль исключений определяет все исключения системного уровня и предоставляет механизм изменения обработки ошибок системного уровня.</target>
        </trans-unit>
        <trans-unit id="7a6c8dd2c388cd128d91f81fff3c160065b3f34b" translate="yes" xml:space="preserve">
          <source>The exception thrown during finalization.</source>
          <target state="translated">Исключение,брошенное во время доработки.</target>
        </trans-unit>
        <trans-unit id="9e6c1b1caa6f537b3b32ae230a3319f2a84949f0" translate="yes" xml:space="preserve">
          <source>The exception to throw if the value evaluates to false.</source>
          <target state="translated">Исключение бросать,если значение оценки ложно.</target>
        </trans-unit>
        <trans-unit id="10d46feeb5a300f1f28f6d3818a7a14193d2059d" translate="yes" xml:space="preserve">
          <source>The expanded data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc3d84209a76290f33343978e317c76e214fa4c" translate="yes" xml:space="preserve">
          <source>The exponent is negative and the factor is one, i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].</source>
          <target state="translated">Экспонент отрицательный,а коэффициент один,т.е.output[j]:=sum[exp(-2 PI i j k/N)input[k]].</target>
        </trans-unit>
        <trans-unit id="08786360cdc12838546c00b5767cf2cab959b50c" translate="yes" xml:space="preserve">
          <source>The exponent is positive and the factor is 1/N, i.e., output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].</source>
          <target state="translated">Экспонент положительный и коэффициент 1/N,т.е.выход[j]:=(1/N)sum[exp(+2 PI i j k/N)input[k]].</target>
        </trans-unit>
        <trans-unit id="c871c5d07aafe7ec6925f7e7fae1500b032e2b52" translate="yes" xml:space="preserve">
          <source>The expression and the errorHandler must have a common type they can both be implicitly casted to, and that type will be the type of the compound expression.</source>
          <target state="translated">Выражение и errorHandler должны иметь общий тип,к которому они оба могут быть неявно приведены,и этот тип будет типом составного выражения.</target>
        </trans-unit>
        <trans-unit id="34375c5ee3f5635a2e38da6b0e76fc609894c573" translate="yes" xml:space="preserve">
          <source>The expression asserted not to throw.</source>
          <target state="translated">Выражение утверждало,что не бросать.</target>
        </trans-unit>
        <trans-unit id="940dd3375faca27ce190b8fb03def99092a3aab1" translate="yes" xml:space="preserve">
          <source>The expression form is:</source>
          <target state="translated">Форма выражения</target>
        </trans-unit>
        <trans-unit id="cc54de17f165e5e9a2ba7fa962f4eecaa39f90b2" translate="yes" xml:space="preserve">
          <source>The expression is evaluated.</source>
          <target state="translated">Выражение оценивается.</target>
        </trans-unit>
        <trans-unit id="22a556158ebfbc64522a677428ab0391c34f8183" translate="yes" xml:space="preserve">
          <source>The expression that copy constructs or moves the value.</source>
          <target state="translated">Выражение,которое копирует конструирует или перемещает значение.</target>
        </trans-unit>
        <trans-unit id="91f707cf0e8e3128051036fb96ff3b7693733b1d" translate="yes" xml:space="preserve">
          <source>The expression to resolve as type or symbol.</source>
          <target state="translated">Выражение для разрешения как тип или символ.</target>
        </trans-unit>
        <trans-unit id="29c4204e99277952fc7a54ab66543bc42d61a803" translate="yes" xml:space="preserve">
          <source>The expression to run and return its result.</source>
          <target state="translated">Выражение,чтобы бежать и вернуть свой результат.</target>
        </trans-unit>
        <trans-unit id="92d0bb2bd94dd52b7503e678d48be02f028860ef" translate="yes" xml:space="preserve">
          <source>The expression to test.</source>
          <target state="translated">Выражение для проверки.</target>
        </trans-unit>
        <trans-unit id="3ba5f3fe8e3c4ad3783ea96faee9ce1e4526ddb4" translate="yes" xml:space="preserve">
          <source>The expression which may throw an exception.</source>
          <target state="translated">Выражение,которое может сделать исключение.</target>
        </trans-unit>
        <trans-unit id="646fe39033d4569a34021185a6750173a3852965" translate="yes" xml:space="preserve">
          <source>The expression:</source>
          <target state="translated">Выражение:</target>
        </trans-unit>
        <trans-unit id="24968438ed1fc3f9aa123f08e882cf9dcb629a30" translate="yes" xml:space="preserve">
          <source>The extension part of a file name, including the dot.  If there is no extension, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">Часть расширения имени файла, включая точку. Если расширения нет, возвращается &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="001c41a8faed92276e0710e5f77bacf1f43befe9" translate="yes" xml:space="preserve">
          <source>The extra *'s and +'s on the comment opening, closing and left margin are ignored and are not part of the embedded documentation. Comments not following one of those forms are not documentation comments.</source>
          <target state="translated">Дополнительные*и+в комментариях открытия,закрытия и левого поля игнорируются и не являются частью встроенной документации.Комментарии,не следующие одной из этих форм,не являются комментариями к документации.</target>
        </trans-unit>
        <trans-unit id="60cbf9a8b6c782eeaf3b240238aaad4006024e93" translate="yes" xml:space="preserve">
          <source>The factory should print an error and abort the program if it cannot successfully initialize the GC instance.</source>
          <target state="translated">Завод должен распечатать ошибку и прервать работу программы,если он не сможет успешно инициализировать экземпляр ГХ.</target>
        </trans-unit>
        <trans-unit id="f5a2d7b1faf4a00e391206a0b6d040b1dd55f507" translate="yes" xml:space="preserve">
          <source>The fallback allocator.</source>
          <target state="translated">Отложенный аллокатор.</target>
        </trans-unit>
        <trans-unit id="6444c34b4999b63334e3fe1c10565688c176440d" translate="yes" xml:space="preserve">
          <source>The fiber function.</source>
          <target state="translated">Функция волокна.</target>
        </trans-unit>
        <trans-unit id="c0e4569946778edcb0cfe73790a6deb0f483408e" translate="yes" xml:space="preserve">
          <source>The fiber module provides OS-indepedent lightweight threads aka fibers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebf4ba0f41676101df65de78d14565377976d26" translate="yes" xml:space="preserve">
          <source>The fiber object representing the calling fiber or null if no fiber is currently active within this thread. The result of deleting this object is undefined.</source>
          <target state="translated">Объект волокна,представляющий вызывающее волокно или ноль,если в данный момент в этом потоке нет активного волокна.Результат удаления этого объекта неопределен.</target>
        </trans-unit>
        <trans-unit id="7163e2b220c5c73c7ee35da99996a1282317d054" translate="yes" xml:space="preserve">
          <source>The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">Поле заканчивается,когда нет ввода,даже если котировка не была закрыта.</target>
        </trans-unit>
        <trans-unit id="779d09c98e4cfcdaab8d2edfcd062b2bc1c5fe62" translate="yes" xml:space="preserve">
          <source>The fields below this were added in CURLVERSION_SECOND</source>
          <target state="translated">Поля,расположенные ниже,были добавлены в CURLVERSION_SECOND</target>
        </trans-unit>
        <trans-unit id="7fb4d8eebf35f6bbc1f833a412d5cc7420dea229" translate="yes" xml:space="preserve">
          <source>The file (or directory) to get a DirEntry for.</source>
          <target state="translated">Файл (или каталог)для получения DirEntry.</target>
        </trans-unit>
        <trans-unit id="40dabb9eb8e81154153036d71178601514e1f7f3" translate="yes" xml:space="preserve">
          <source>The file and line of the call.</source>
          <target state="translated">Файл и линия вызова.</target>
        </trans-unit>
        <trans-unit id="e2f6f4f187fd62357491cbe8478aa3ae4cefb31e" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. POSIX).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2587d80da404ef88f56c1d45c26f059538ee948c" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. Posix).</source>
          <target state="translated">Атрибуты файла или 0,если атрибуты файла были закодированы для несовместимой ОС (Windows vs.Posix).</target>
        </trans-unit>
        <trans-unit id="f357296885e979c9eb815032610719a979731bd8" translate="yes" xml:space="preserve">
          <source>The file attributes.</source>
          <target state="translated">Атрибуты файла.</target>
        </trans-unit>
        <trans-unit id="f692a5a95eb19a88be916cc17fd3a299fdb0b4c2" translate="yes" xml:space="preserve">
          <source>The file data in compressed form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11cc9842d65b87247a394d2db23ff2854dbd2625" translate="yes" xml:space="preserve">
          <source>The file data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21cf4d39fea8701f9ccea1f6e9c33a8dca629be0" translate="yes" xml:space="preserve">
          <source>The file name of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">Имя файла исходного кода D,соответствующего тому,откуда была выброшена ошибка.</target>
        </trans-unit>
        <trans-unit id="b64522363b929d137710605ff07b8daf334bc620" translate="yes" xml:space="preserve">
          <source>The file name to show. If not set, the actual file name will be used (if this is a file part)</source>
          <target state="translated">Имя файла,который нужно показать.Если не установлено,будет использоваться фактическое имя файла (если это часть файла).</target>
        </trans-unit>
        <trans-unit id="bf8ad1ee8706b576c3d861ca4c35b04004625b5d" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should also be composed of the ASCII characters lower case letters, digits or &lt;code&gt;_&lt;/code&gt; and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Имена файлов для пакетов и модулей также должны состоять из строчных букв ASCII, цифр или &lt;code&gt;_&lt;/code&gt; и не должны быть &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;ключевым словом&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="568163d3852e8f82e9cc9864a262f9868cd7a80a" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should be composed only of the ASCII lower case letters, digits, and &lt;code&gt;_&lt;/code&gt;s, and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e521d84e71e057af31f6b16036a8dda6098775" translate="yes" xml:space="preserve">
          <source>The file that is being linked. This is the target path that's stored in the symlink. A relative path is relative to the created symlink.</source>
          <target state="translated">Файл,на который делается ссылка.Это целевой путь,который хранится в symlink.Относительный путь связан с созданной симлинкией.</target>
        </trans-unit>
        <trans-unit id="a48d130bf6ed7fe001b9b68c13bd4356b06eb640" translate="yes" xml:space="preserve">
          <source>The file that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">Файл, который &lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; &lt;/a&gt; перечислит, если выброшен.</target>
        </trans-unit>
        <trans-unit id="886ddc5df982fa3a52b4dae1cc5e097e3fae8531" translate="yes" xml:space="preserve">
          <source>The file to get the attributes of.</source>
          <target state="translated">Файл для получения атрибутов.</target>
        </trans-unit>
        <trans-unit id="c5856ac3b9ed35958ce9f401bbff0c265bcd66da" translate="yes" xml:space="preserve">
          <source>The file to get the symbolic link attributes of.</source>
          <target state="translated">Файл для получения атрибутов символической ссылки.</target>
        </trans-unit>
        <trans-unit id="d5a902223a6a641c14dbfbc008db96721d6af330" translate="yes" xml:space="preserve">
          <source>The file used for logging.</source>
          <target state="translated">Файл,используемый для протоколирования.</target>
        </trans-unit>
        <trans-unit id="f7969ce864cdb7d64da59da6dfc8b40cf28ba7bb" translate="yes" xml:space="preserve">
          <source>The file where the error occurred.</source>
          <target state="translated">Файл,в котором произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="3ff1fcb05fd162b545299ba30ad59377c1eb86a5" translate="yes" xml:space="preserve">
          <source>The file where the error occurred. Defaults to &lt;code&gt;__FILE__&lt;/code&gt;.</source>
          <target state="translated">Файл, в котором произошла ошибка. По умолчанию &lt;code&gt;__FILE__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a7b4c097e4526bdecb31861d25a87231f1a612b" translate="yes" xml:space="preserve">
          <source>The file where the exception occurred.</source>
          <target state="translated">Файл,в котором произошло исключение.</target>
        </trans-unit>
        <trans-unit id="2a8a857ec47a034acf4c2fcaed0de229c31869d5" translate="yes" xml:space="preserve">
          <source>The filename of the &lt;code&gt;File&lt;/code&gt; log messages are written to.</source>
          <target state="translated">Имя &lt;code&gt;File&lt;/code&gt; сообщений журнала файлов записывается в.</target>
        </trans-unit>
        <trans-unit id="37dc45c1af7cba50c135f406c906822e95a5938d" translate="yes" xml:space="preserve">
          <source>The filename of the output file of the &lt;code&gt;FileLogger&lt;/code&gt;. If that file can not be opened for writting an exception will be thrown.</source>
          <target state="translated">Имя файла выходного файла &lt;code&gt;FileLogger&lt;/code&gt; . Если этот файл не может быть открыт для записи, будет сгенерировано исключение.</target>
        </trans-unit>
        <trans-unit id="3910614447549528bc2d2fc1be565210c1526e11" translate="yes" xml:space="preserve">
          <source>The finish function returns the final hash sum and resets the Digest.</source>
          <target state="translated">Функция завершения возвращает итоговую хеш-сумму и сбрасывает Дайджест.</target>
        </trans-unit>
        <trans-unit id="133d5dd83ff02e493d05a0e47c1deb319a8252d7" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must be at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes big.</source>
          <target state="translated">Функция Finish возвращает значение хеша. Требуется дополнительный буфер для копирования данных. Если буфер передан, он должен иметь &lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; не менее байтов.</target>
        </trans-unit>
        <trans-unit id="22bbeb22c4ba0a11e694a3fb88ce4ce66c1aa8c4" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must have a length at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes.</source>
          <target state="translated">Функция Finish возвращает значение хеша. Требуется дополнительный буфер для копирования данных. Если буфер передан, он должен иметь длину не менее &lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="957dc77c438abefa8c77eaf7563108a790ce4d94" translate="yes" xml:space="preserve">
          <source>The first</source>
          <target state="translated">Первый</target>
        </trans-unit>
        <trans-unit id="fb47524b87677bd448123bb56b7daf118be97145" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; is evaluated at compile time, and converted to a boolean value. If the value is true, the static assert is ignored. If the value is false, an error diagnostic is issued and the compile fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33576b80d4f4e8bd604397c308091bd4d49eeac" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Exception&lt;/code&gt; which was bypassed when this Error was thrown, or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;Exception&lt;/code&gt;s were pending.</source>
          <target state="translated">Первое &lt;code&gt;Exception&lt;/code&gt; которое было обойдено при возникновении этой ошибки, или &lt;code&gt;null&lt;/code&gt; если &lt;code&gt;Exception&lt;/code&gt; не ожидалось.</target>
        </trans-unit>
        <trans-unit id="83bd533ac7ce9ad8a841e8cf9ee5bfbb37b7a8f6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;v1&lt;/code&gt; for which &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; is true determines the result. This could lead to unexpected behaviour.</source>
          <target state="translated">Первый &lt;code&gt;v1&lt;/code&gt; , для которого &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; истинно, определяет результат. Это может привести к неожиданному поведению.</target>
        </trans-unit>
        <trans-unit id="ba9501cbc71e13c8461adcfc7cfb46ad49a3228f" translate="yes" xml:space="preserve">
          <source>The first argument for the predicate.</source>
          <target state="translated">Первый аргумент для предиката.</target>
        </trans-unit>
        <trans-unit id="d76b59c9568cb4d5adeddeb8e61ac34ba34641de" translate="yes" xml:space="preserve">
          <source>The first argument is a class type or an expression of class type. The second argument is a string that matches the name of one of the functions of that class. The result is a tuple of the virtual overloads of that function. It does not include final functions that do not override anything.</source>
          <target state="translated">Первый аргумент-тип класса или выражение типа класса.Второй аргумент-строка,совпадающая с именем одной из функций этого класса.В результате получается кортеж виртуальной перегрузки этой функции.В него не входят конечные функции,которые ничего не переопределяют.</target>
        </trans-unit>
        <trans-unit id="dd726d5af5bf0120b5bd49b63370601b230f8cd3" translate="yes" xml:space="preserve">
          <source>The first argument is a type that has members, or is an expression of a type that has members. The second argument is a string. If the string is a valid property of the type, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Первый аргумент - это тип, в котором есть члены, или выражение типа, в котором есть члены. Второй аргумент - это строка. Если строка является допустимым свойством типа, возвращается &lt;code&gt;true&lt;/code&gt; , иначе &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a43e4ec8b9b76809401c1e8287827f1c5ded36c" translate="yes" xml:space="preserve">
          <source>The first argument is an aggregate (e.g. struct/class/module). The second argument is a &lt;code&gt;string&lt;/code&gt; that matches the name of the member(s) to return. The third argument is a &lt;code&gt;bool&lt;/code&gt;, and is optional. If &lt;code&gt;true&lt;/code&gt;, the result will also include template overloads. The result is a tuple of all the overloads of the supplied name.</source>
          <target state="translated">Первый аргумент является агрегатом (например, структура / класс / модуль). Второй аргумент - это &lt;code&gt;string&lt;/code&gt; которая соответствует имени возвращаемого члена (членов). Третий аргумент является &lt;code&gt;bool&lt;/code&gt; и необязательным. Если &lt;code&gt;true&lt;/code&gt; , результат также будет включать перегрузки шаблона. Результатом является кортеж всех перегрузок указанного имени.</target>
        </trans-unit>
        <trans-unit id="2a174554ed3bb0d11c52209ee3ed7c598d6bcaa6" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;Checked&lt;/code&gt;, e.g. &lt;code&gt;int&lt;/code&gt; if the left-hand side of the operator is &lt;code&gt;Checked!int&lt;/code&gt;</source>
          <target state="translated">Первый аргумент &lt;code&gt;Checked&lt;/code&gt; , например, &lt;code&gt;int&lt;/code&gt; , если левая часть оператора &lt;code&gt;Checked!int&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8841f05f16f8289043fb3adb8a0d9f6c62e9f3bb" translate="yes" xml:space="preserve">
          <source>The first argument that passes the test &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Первый аргумент, который проходит тест &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f69babce0033893a00ba9dd4fdded8c5d91d428" translate="yes" xml:space="preserve">
          <source>The first argument to apply to &lt;code&gt;fun&lt;/code&gt;</source>
          <target state="translated">Первый аргумент, чтобы применить к &lt;code&gt;fun&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e0881d9245470375fca9c2a63d7fd75c1ab511d" translate="yes" xml:space="preserve">
          <source>The first array to compare</source>
          <target state="translated">Первый массив для сравнения</target>
        </trans-unit>
        <trans-unit id="6402ea9c3911f868771a9ad2ee306a3ff47b76c7" translate="yes" xml:space="preserve">
          <source>The first choice that &lt;code&gt;switchObject&lt;/code&gt; can be casted to the type of argument it accepts will be called with &lt;code&gt;switchObject&lt;/code&gt; casted to that type, and the value it'll return will be returned by &lt;code&gt;castSwitch&lt;/code&gt;.</source>
          <target state="translated">Первый выбор, который &lt;code&gt;switchObject&lt;/code&gt; может быть приведен к типу аргумента, который он принимает, будет вызван с &lt;code&gt;switchObject&lt;/code&gt; ,приведенным к этому типу, и возвращаемое им значение будет возвращено &lt;code&gt;castSwitch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0a3698b1be7dcab735cd7cac7d279e510c1569" translate="yes" xml:space="preserve">
          <source>The first element of the array is the size of the type (for classes it is the &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt;).</source>
          <target state="translated">Первый элемент массива - это размер типа (для классов это &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d156d92ea93ea0bd49c4929ebca8565a10591e92" translate="yes" xml:space="preserve">
          <source>The first element of the array.</source>
          <target state="translated">Первый элемент массива.</target>
        </trans-unit>
        <trans-unit id="d8e16b70885d5121ddc9494a6960e6bb4c96cb43" translate="yes" xml:space="preserve">
          <source>The first expression is converted to &lt;code&gt;bool&lt;/code&gt;, and is evaluated.</source>
          <target state="translated">Первое выражение преобразуется в &lt;code&gt;bool&lt;/code&gt; и оценивается.</target>
        </trans-unit>
        <trans-unit id="cf9e5f533fce6e846463f393ddd35d42bb1f1cd6" translate="yes" xml:space="preserve">
          <source>The first field in the input</source>
          <target state="translated">Первое поле на входе</target>
        </trans-unit>
        <trans-unit id="d4d950398e4d3043c7b4cad357808ae2f4342dfd" translate="yes" xml:space="preserve">
          <source>The first form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;scope&lt;/code&gt;, and has &lt;a href=&quot;#return-scope-parameters&quot;&gt;return scope parameter&lt;/a&gt; semantics for the value of the &lt;code&gt;ref&lt;/code&gt; parameter.</source>
          <target state="translated">Первая форма присоединяет &lt;code&gt;return&lt;/code&gt; к &lt;code&gt;scope&lt;/code&gt; и имеет семантику &lt;a href=&quot;#return-scope-parameters&quot;&gt;возвращаемого параметра области&lt;/a&gt; для значения параметра &lt;code&gt;ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1ce77e77b315411f0f72483fe564f04bb631f4" translate="yes" xml:space="preserve">
          <source>The first function</source>
          <target state="translated">Первая функция</target>
        </trans-unit>
        <trans-unit id="f3024cc5ecfa3c08bdbe44b263a51764ec97fd6f" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the &lt;code&gt;Interface&lt;/code&gt;, but the first virtual function pointer.</source>
          <target state="translated">Первый член &lt;code&gt;vtbl[]&lt;/code&gt; - это не указатель на &lt;code&gt;Interface&lt;/code&gt; , а первый указатель виртуальной функции.</target>
        </trans-unit>
        <trans-unit id="847d6d02e0c1f522b786c8972c9a6146a642fa90" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the InterfaceInfo, but the first virtual function pointer.</source>
          <target state="translated">Первый член &lt;code&gt;vtbl[]&lt;/code&gt; - это не указатель на InterfaceInfo, а первый указатель виртуальной функции.</target>
        </trans-unit>
        <trans-unit id="c2d2ce897245ef2180a0c50b1783471cf2be4244" translate="yes" xml:space="preserve">
          <source>The first overload exists only if &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt;. So if &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; or called for a constant or immutable object, then &lt;code&gt;refCountedPayload&lt;/code&gt; will also be qualified as safe and nothrow (but will still assert if not initialized).</source>
          <target state="translated">Первая перегрузка существует, только если &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt; . Поэтому, если &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; или вызывается для константного или неизменяемого объекта, тогда &lt;code&gt;refCountedPayload&lt;/code&gt; также будет квалифицироваться как safe и nothrow (но все равно будет утверждаться, если не инициализирован).</target>
        </trans-unit>
        <trans-unit id="dfd8266058456fb8b44a614fe1b78098bba5c6d8" translate="yes" xml:space="preserve">
          <source>The first overload of &lt;code&gt;makeIndex&lt;/code&gt; writes to a range containing pointers, and the second writes to a range containing offsets. The first overload requires &lt;code&gt;Range&lt;/code&gt; to be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, and the latter requires it to be a random-access range.</source>
          <target state="translated">Первая перегрузка &lt;code&gt;makeIndex&lt;/code&gt; выполняет запись в диапазон, содержащий указатели, а вторая - в диапазон, содержащий смещения. Первая перегрузка требует, чтобы &lt;code&gt;Range&lt;/code&gt; был &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном&lt;/a&gt; , а последний требует, чтобы это был диапазон произвольного доступа.</target>
        </trans-unit>
        <trans-unit id="2797f8bab40930285c67d69e0f78f4ff6b12f672" translate="yes" xml:space="preserve">
          <source>The first overload of this function will return &lt;code&gt;T.init&lt;/code&gt; if the range is empty. However, the second overload will return &lt;code&gt;seed&lt;/code&gt; on empty ranges.</source>
          <target state="translated">Первая перегрузка этой функции вернет &lt;code&gt;T.init&lt;/code&gt; , если диапазон пуст. Однако вторая перегрузка вернет &lt;code&gt;seed&lt;/code&gt; в пустых диапазонах.</target>
        </trans-unit>
        <trans-unit id="fa15d56dc093902b6572dae74b23ea12e4df8659" translate="yes" xml:space="preserve">
          <source>The first part is done automatically by the language, the second part is done if a postblit function is defined for the struct. The postblit has access only to the destination struct object, not the source. Its job is to &amp;lsquo;fix up&amp;rsquo; the destination as necessary, such as making copies of referenced data, incrementing reference counts, etc. For example:</source>
          <target state="translated">Первая часть выполняется автоматически языком, вторая часть выполняется, если для структуры определена функция postblit. Постблит имеет доступ только к целевому объекту структуры, а не к источнику. Его задача состоит в том, чтобы &amp;laquo;исправить&amp;raquo; место назначения по мере необходимости, например, делать копии ссылочных данных, увеличивать количество ссылок и т. Д. Например:</target>
        </trans-unit>
        <trans-unit id="b6a25e3471beef6bed20eb948a4b0de3cefb170f" translate="yes" xml:space="preserve">
          <source>The first part of the desired time zones.</source>
          <target state="translated">Первая часть нужных часовых поясов.</target>
        </trans-unit>
        <trans-unit id="f479a5f1dc2ec5b3e8f93d2c246a61132b592fa7" translate="yes" xml:space="preserve">
          <source>The first range</source>
          <target state="translated">Первый диапазон</target>
        </trans-unit>
        <trans-unit id="978014a33cbc746b950a93b0f0736f4203ea8def" translate="yes" xml:space="preserve">
          <source>The first range to be compared.</source>
          <target state="translated">Первый диапазон для сравнения.</target>
        </trans-unit>
        <trans-unit id="ca9cc691843153958d1dfce3f9f135428053bc03" translate="yes" xml:space="preserve">
          <source>The first range.</source>
          <target state="translated">Первый диапазон.</target>
        </trans-unit>
        <trans-unit id="376b0679101f4b59ef8dcfe360d9831914d2f062" translate="yes" xml:space="preserve">
          <source>The first section is the</source>
          <target state="translated">Первый раздел</target>
        </trans-unit>
        <trans-unit id="0a2ac8281c00878fb6aeb93d4c1aa8543d1c7cdd" translate="yes" xml:space="preserve">
          <source>The first template argument is the size of the region and the second is the needed alignment. Depending on the alignment requested and platform details, the actual available storage may be smaller than the compile-time parameter. To make sure that at least &lt;code&gt;n&lt;/code&gt; bytes are available in the region, use &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt;.</source>
          <target state="translated">Первый аргумент шаблона - это размер области, а второй - необходимое выравнивание. В зависимости от запрошенного выравнивания и сведений о платформе фактическое доступное хранилище может быть меньше параметра времени компиляции. Чтобы убедиться, что в регионе доступно не менее &lt;code&gt;n&lt;/code&gt; байтов, используйте &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09dcfe52dd359d217c384efcd5e2b579c11d4d5" translate="yes" xml:space="preserve">
          <source>The first thing a catch handler does is call this.</source>
          <target state="translated">Первое,что делает обработчик улова,это называет это.</target>
        </trans-unit>
        <trans-unit id="06bc16353a0bd43b921f8f9a4d6fe2a9b273859a" translate="yes" xml:space="preserve">
          <source>The first time point in the range.</source>
          <target state="translated">Первая временная точка в диапазоне.</target>
        </trans-unit>
        <trans-unit id="ee856ba33815edde83d3ab4573c1bb58ec0e2ba8" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if &lt;code&gt;alloc&lt;/code&gt;'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">Первые два перегруженных бросить только если &lt;code&gt;alloc&lt;/code&gt; примитивы &amp;laquo;s делать. Перегрузки, которые включают инициализацию копирования, освобождают память и распространяют исключение, если выдает операция копирования.</target>
        </trans-unit>
        <trans-unit id="333231d0183ec9a4310007ffcf10aa12ccaa5deb" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if the used allocator's primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">Первые две перегрузки бросаются только в том случае,если это делают примитивы используемого аллокатора.Перегрузки,связанные с инициализацией копирования,освобождают память и распространяют исключение при выполнении операции копирования.</target>
        </trans-unit>
        <trans-unit id="8adbee74bf4af885c51ba2cdd7ef319e8a5ccd70" translate="yes" xml:space="preserve">
          <source>The first type to receive the type name for</source>
          <target state="translated">Первый тип,получивший имя типа для</target>
        </trans-unit>
        <trans-unit id="24a327b5e33473298dc52e8aa179b1270880d206" translate="yes" xml:space="preserve">
          <source>The first version counts the number of elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;pred&lt;/code&gt; defaults to equality. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Первая версия подсчитывает количество элементов &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;r&lt;/code&gt; , для которых &lt;code&gt;pred(x, value)&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;pred&lt;/code&gt; умолчанию равенству. Выполняет &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; ) оценки &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9816b3b28ee2e6c5406da992bb1cbb42be32059" translate="yes" xml:space="preserve">
          <source>The first way is to use a literal that is already immutable, such as string literals. String literals are always immutable.</source>
          <target state="translated">Первый способ-использовать литералы,которые уже являются неизменными,например,строковые литералы.Строковые литералы всегда неизменны.</target>
        </trans-unit>
        <trans-unit id="b05e9e189cc2bf7e6e8a6f344ff95d0591fc3a0f" translate="yes" xml:space="preserve">
          <source>The first will queue writers until no readers hold the mutex, then pass the writers through one at a time. If a reader acquires the mutex while there are still writers queued, the reader will take precedence.</source>
          <target state="translated">Первые будут стоять в очереди писателей до тех пор,пока ни один читатель не удержит мьютекс,а затем передавать писателей по одному за раз.Если читатель приобретает мьютекс,пока в очереди еще есть авторы,то приоритет будет отдан читателю.</target>
        </trans-unit>
        <trans-unit id="1b1951cc36673198c26cd910de69ac59cf5f6d05" translate="yes" xml:space="preserve">
          <source>The focus of this module is the core needs of developing Unicode-aware applications. To that effect it provides the following optimized primitives:</source>
          <target state="translated">Основное внимание в этом модуле уделяется основным потребностям разработки приложений с поддержкой Unicode-технологий.Для этого он предоставляет следующие оптимизированные примитивы:</target>
        </trans-unit>
        <trans-unit id="6fa1fe0d7308c90108a99d43bd343885cf39b2f7" translate="yes" xml:space="preserve">
          <source>The following IEEE 'real' formats are currently supported:</source>
          <target state="translated">В настоящее время поддерживаются следующие &quot;реальные&quot; форматы IEEE:</target>
        </trans-unit>
        <trans-unit id="fd79ad5ff3bdc8ea5cc9c7e973de1494e808a075" translate="yes" xml:space="preserve">
          <source>The following algorithm is used:</source>
          <target state="translated">Используется следующий алгоритм:</target>
        </trans-unit>
        <trans-unit id="3781d7d912eacb6b194d6abe4908fafb2e1b7d5d" translate="yes" xml:space="preserve">
          <source>The following algorithms are currently implemented:</source>
          <target state="translated">В настоящее время реализованы следующие алгоритмы:</target>
        </trans-unit>
        <trans-unit id="d55ceaf72919876c8f40561d12b134a3ea66a2f7" translate="yes" xml:space="preserve">
          <source>The following alias declarations are valid:</source>
          <target state="translated">Действительны следующие заявления под псевдонимом:</target>
        </trans-unit>
        <trans-unit id="3cfdc04ab915c01ce32c8d0e68bf6bc781aec0c7" translate="yes" xml:space="preserve">
          <source>The following are all embedded documentation comments:</source>
          <target state="translated">Ниже приведены все встроенные комментарии к документации:</target>
        </trans-unit>
        <trans-unit id="98d73aa2fbdeacfd5d17519697402797329a5e39" translate="yes" xml:space="preserve">
          <source>The following are rules of input ranges are assumed to hold true in all Phobos code. These rules are not checkable at compile-time, so not conforming to these rules when writing ranges or range based code will result in undefined behavior.</source>
          <target state="translated">Ниже приведены правила входных диапазонов,которые считаются истинными во всем коде Phobos.Эти правила не проверяются во время компиляции,поэтому несоблюдение этих правил при написании диапазонов или кода на основе диапазонов приведет к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="eabfe29dc68817824868f2b1cc59ea44b7368f75" translate="yes" xml:space="preserve">
          <source>The following are what the Unicode standard considers as line terminators:</source>
          <target state="translated">Ниже приведено то,что стандарт Юникода считает терминаторами строк:</target>
        </trans-unit>
        <trans-unit id="21052e7f487ea1e8da6a5dfd837062e0257bbb6f" translate="yes" xml:space="preserve">
          <source>The following binary operators are overloadable:</source>
          <target state="translated">Следующие двоичные операторы перегрузочны:</target>
        </trans-unit>
        <trans-unit id="85cad5d1bff24fce98bfd578ab9c72fa9869b15d" translate="yes" xml:space="preserve">
          <source>The following code compares the use of &lt;code&gt;formatValue&lt;/code&gt; and &lt;code&gt;formattedWrite&lt;/code&gt;.</source>
          <target state="translated">Следующий код сравнивает использование &lt;code&gt;formatValue&lt;/code&gt; и &lt;code&gt;formattedWrite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36006625c3fb62c010db1770cfe9a955d1abc844" translate="yes" xml:space="preserve">
          <source>The following code does a full unzip</source>
          <target state="translated">Следующий код выполняет полную распаковку</target>
        </trans-unit>
        <trans-unit id="707a5e8dae71e24794f64d11490781d72f147427" translate="yes" xml:space="preserve">
          <source>The following code should compile for any forward range.</source>
          <target state="translated">Следующий код должен быть скомпилирован для любого прямого диапазона.</target>
        </trans-unit>
        <trans-unit id="b75b3b21bc4ed533a6d7d4185c0635676c150be0" translate="yes" xml:space="preserve">
          <source>The following describes the behavior of the qualified postblit definitions:</source>
          <target state="translated">Ниже описывается поведение квалифицированных послеблитовых дефиниций:</target>
        </trans-unit>
        <trans-unit id="cc1ef4d0137291a52b36237f0a56da4b9479ab3e" translate="yes" xml:space="preserve">
          <source>The following describes the specific implementation of the vector types for the X86 and X86_64 architectures.</source>
          <target state="translated">Ниже описана специфическая реализация векторных типов для архитектур X86 и X86_64.</target>
        </trans-unit>
        <trans-unit id="105f7db9c11f1b737bfecc2ad34e6e665b2f7c19" translate="yes" xml:space="preserve">
          <source>The following divide or modulus integral operands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a4096a1a2c3a608e01b521d07c483d3463c6b6" translate="yes" xml:space="preserve">
          <source>The following elements describe the locations of GC managed pointers within the memory occupied by an instance of the type. For type T, there are &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; possible pointers represented by the bits of the array values.</source>
          <target state="translated">Следующие элементы описывают расположение управляемых указателей GC в памяти, занимаемой экземпляром типа. Для типа T есть &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; возможных указателей, представленных битами значений массива.</target>
        </trans-unit>
        <trans-unit id="64e995a24781ca67ad26542b15d464819ff2f49a" translate="yes" xml:space="preserve">
          <source>The following example shows binding of a pure virtual function, its implementation in a derived class, a non-virtual member function, and a member field:</source>
          <target state="translated">В следующем примере показана привязка чистой виртуальной функции,ее реализация в производном классе,невиртуальная функция-член и поле-член:</target>
        </trans-unit>
        <trans-unit id="7394f4cff4af73de38cdcc123f9d9cc433c49d32" translate="yes" xml:space="preserve">
          <source>The following expression must be true for &lt;code&gt;hasSlicing&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">Следующее выражение должно быть true, чтобы &lt;code&gt;hasSlicing&lt;/code&gt; был &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9182b2bc4da6786571366018715b092f896d0a9d" translate="yes" xml:space="preserve">
          <source>The following flag from DMD can be used to add a new path in which to search for frameworks:</source>
          <target state="translated">Следующий флаг из DMD может быть использован для добавления нового пути для поиска фреймворков:</target>
        </trans-unit>
        <trans-unit id="f255eea7299aed827ce99b1b18680817e56fa6aa" translate="yes" xml:space="preserve">
          <source>The following forms of slice expression can be convertible to a static array type:</source>
          <target state="translated">Следующие формы слайс-выражений могут быть конвертированы в статический тип массива:</target>
        </trans-unit>
        <trans-unit id="b112356e7e4259c722c195a6e095476ecaa2fdb9" translate="yes" xml:space="preserve">
          <source>The following functions are publicly imported:</source>
          <target state="translated">Следующие функции импортируются публично:</target>
        </trans-unit>
        <trans-unit id="37498d7cc50ed898202c2748c98849d1a32c6302" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined, but are deprecated:</source>
          <target state="translated">Следующие идентификаторы определены,но устарели:</target>
        </trans-unit>
        <trans-unit id="4b758467388bb94c690cea1fb26de17875ff1787" translate="yes" xml:space="preserve">
          <source>The following information might be of help with choosing the appropriate block size. Actual allocation occurs in sizes multiple of the block size. Allocating one block is the fastest because only one 0 bit needs to be found in the metadata. Allocating 2 through 64 blocks is the next cheapest because it affects a maximum of two &lt;code&gt;ulong&lt;/code&gt; in the metadata. Allocations greater than 64 blocks require a multiword search through the metadata.</source>
          <target state="translated">Следующая информация может помочь при выборе подходящего размера блока. Фактическое распределение происходит в размерах, кратных размеру блока. Выделение одного блока является самым быстрым, поскольку в метаданных должен быть найден только один 0-бит. Выделение блоков от 2 до 64 является следующим самым дешевым, поскольку оно затрагивает максимум два &lt;code&gt;ulong&lt;/code&gt; в метаданных. Выделения более 64 блоков требуют многоэлементного поиска по метаданным.</target>
        </trans-unit>
        <trans-unit id="3576cbb0f30565829c9a8b467650fa45b457f446" translate="yes" xml:space="preserve">
          <source>The following is a list of important Unicode notions and definitions. Any conventions used specifically in this module alone are marked as such. The descriptions are based on the formal definition as found in &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt; chapter three of The Unicode Standard Core Specification.&lt;/a&gt;</source>
          <target state="translated">Ниже приведен список важных понятий и определений Unicode. Любые соглашения, используемые только в этом модуле, помечаются как таковые. Описания основаны на формальном определении, приведенном в &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt;третьей главе Стандартной базовой спецификации Unicode.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee35f7e05bf101609042076d8164187dce2ce440" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;Allocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;.</source>
          <target state="translated">Следующие методы определены, если &lt;code&gt;Allocator&lt;/code&gt; определяет их и пересылает на них: &lt;code&gt;deallocateAll&lt;/code&gt; , &lt;code&gt;empty&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91a10c7b038d71ce23d47d4e91b5d6d57a0c0ec0" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">Следующие методы определены , если &lt;code&gt;ParentAllocator&lt;/code&gt; определяет их, и вперед к нему: &lt;code&gt;allocateAll&lt;/code&gt; , &lt;code&gt;expand&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14685afb8641a641e101312bd747ad3ce716f779" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">Следующие методы определены, если &lt;code&gt;ParentAllocator&lt;/code&gt; определяет их и пересылает на них: &lt;code&gt;expand&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e999922ed0b2b38ea541add7eceec13e307896" translate="yes" xml:space="preserve">
          <source>The following methods are forwarded to the parent allocator if present: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;.</source>
          <target state="translated">Следующие методы пересылаются родительскому распределителю, если он присутствует: &lt;code&gt;allocateAll&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;deallocateAll&lt;/code&gt; , &lt;code&gt;empty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90832fc606780913417ad9424b5b78d805e2f1c9" translate="yes" xml:space="preserve">
          <source>The following must not compile:</source>
          <target state="translated">Следующее не должно быть составлено:</target>
        </trans-unit>
        <trans-unit id="151cf7cc11e7e2474415594512b78561ff78c2e4" translate="yes" xml:space="preserve">
          <source>The following op assignment operators are overloadable:</source>
          <target state="translated">Следующие операторы назначения опций перегружены:</target>
        </trans-unit>
        <trans-unit id="1686f8bc7687029bb8df07eb18087ba36d800516" translate="yes" xml:space="preserve">
          <source>The following operations are not allowed in safe functions:</source>
          <target state="translated">Следующие операции не допускаются при выполнении безопасных функций:</target>
        </trans-unit>
        <trans-unit id="74510166d7dbf32dd076c82ed552fa55a6bbe522" translate="yes" xml:space="preserve">
          <source>The following part &lt;code&gt;=&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Следующая часть &lt;code&gt;=&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f46ca3cf008a6a798269fad6d3b26dd55f13657" translate="yes" xml:space="preserve">
          <source>The following registers are supported. Register names are always in upper case.</source>
          <target state="translated">Поддерживаются следующие регистры.Имена регистров всегда находятся в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="747c928a756931b0ee0b7f4bfca0b996d4e0288f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to class construction:</source>
          <target state="translated">Следующие ограничения относятся к классу конструкции:</target>
        </trans-unit>
        <trans-unit id="b257030ef10af45e49786ee89d857d61ed4e94b9" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to struct construction:</source>
          <target state="translated">Следующие ограничения относятся к конструкции сооружений:</target>
        </trans-unit>
        <trans-unit id="35dabc106beeab4a557770a611849cc8c36d5347" translate="yes" xml:space="preserve">
          <source>The following restrictions apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f5e979077d2f3caabdbb4640da99e0c00a00749" translate="yes" xml:space="preserve">
          <source>The following steps happen:</source>
          <target state="translated">Происходят следующие шаги:</target>
        </trans-unit>
        <trans-unit id="b441496fc086e7e8d354986714d6c04ebf32cc29" translate="yes" xml:space="preserve">
          <source>The following table compactly summarises the different process creation functions and how they relate to each other:</source>
          <target state="translated">В следующей таблице в сжатом виде представлены различные функции создания процессов и их взаимосвязь:</target>
        </trans-unit>
        <trans-unit id="05b248b2126c26cb91a89762582c19941d257e43" translate="yes" xml:space="preserve">
          <source>The following table is a quick reference guide for which Phobos modules to use for a given category of functionality. Note that some modules may appear in more than one category, as some Phobos modules are quite generic and can be applied in a variety of situations.</source>
          <target state="translated">Следующая таблица представляет собой краткое справочное руководство по использованию модулей Phobos для данной категории функциональности.Обратите внимание,что некоторые модули могут появляться более чем в одной категории,так как некоторые модули Phobos достаточно общие и могут применяться в различных ситуациях.</target>
        </trans-unit>
        <trans-unit id="a2cf73cb06dd66656b8e69a1d451407dbc663bbe" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to succesfully invoke the postblit:</source>
          <target state="translated">В следующей таблице перечислены все возможности группировки квалификаторов для постблита,связанных с типом объекта,который необходимо использовать для успешного вызова постблита:</target>
        </trans-unit>
        <trans-unit id="45f0025d65c3c173c7ccd0fb97c1cf0de30e0385" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to successfully invoke the postblit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824da93e42b4013db578b67b46a78528e680f556" translate="yes" xml:space="preserve">
          <source>The following transformations of floating point expressions are not allowed because under IEEE rules they could produce different results.</source>
          <target state="translated">Следующие преобразования выражений с плавающей точкой не допускаются,так как по правилам IEEE они могут давать разные результаты.</target>
        </trans-unit>
        <trans-unit id="a206952bbb005ee76451476eb55d6acde4281a6d" translate="yes" xml:space="preserve">
          <source>The following typedef's are signatures of malloc, free, realloc, strdup and calloc respectively. Function pointers of these types can be passed to the curl_global_init_mem() function to set user defined memory management callback routines.</source>
          <target state="translated">Следующие шрифты являются сигнатурами malloc,free,realloc,strdup и calloc соответственно.Указатели функций этих типов могут передаваться в функцию curl_global_init_mem()для задания пользовательских процедур обратного вызова управления памятью.</target>
        </trans-unit>
        <trans-unit id="6266d602387c0c2612f1f18ac8c95fc02fe3bb5d" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is applied the expanded &lt;code&gt;Tuple&lt;/code&gt;, so it may contain as many formats as the &lt;code&gt;Tuple&lt;/code&gt; has fields.</source>
          <target state="translated">В формате &lt;code&gt;inner&lt;/code&gt; применяются расширенный &lt;code&gt;Tuple&lt;/code&gt; , так что он может содержать так много форматов как &lt;code&gt;Tuple&lt;/code&gt; имеет поле.</target>
        </trans-unit>
        <trans-unit id="d91cc2eaba6a476564c6ddbd8124208fde7d92fe" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is one format, that is applied on all fields of the &lt;code&gt;Tuple&lt;/code&gt;. The inner format must be compatible to all of them.</source>
          <target state="translated">Формат &lt;code&gt;inner&lt;/code&gt; один формат, который применяется во всех полях &lt;code&gt;Tuple&lt;/code&gt; . Внутренний формат должен быть совместим со всеми из них.</target>
        </trans-unit>
        <trans-unit id="b804a9979bb24328a2b2b5b25616b3fc268adff1" translate="yes" xml:space="preserve">
          <source>The format of the data to read.</source>
          <target state="translated">Формат считываемых данных.</target>
        </trans-unit>
        <trans-unit id="0a7a62414c21f47b50a1e92c766dda1b08a5910c" translate="yes" xml:space="preserve">
          <source>The format of the date should follow this template:</source>
          <target state="translated">Формат даты должен соответствовать этому шаблону:</target>
        </trans-unit>
        <trans-unit id="659e106c79a7ed685e316895f1b36b5ece514b7f" translate="yes" xml:space="preserve">
          <source>The format of the instructions is, of course, highly dependent on the native instruction set of the target CPU, and so is &lt;a href=&quot;iasm&quot;&gt;implementation defined&lt;/a&gt;. But, the format will follow the following conventions:</source>
          <target state="translated">Формат инструкций, конечно, сильно зависит от собственного набора команд целевого ЦП, и поэтому &lt;a href=&quot;iasm&quot;&gt;определяется реализацией&lt;/a&gt; . Но формат будет следовать следующим соглашениям:</target>
        </trans-unit>
        <trans-unit id="d00ef203b4bd1ca0d23b1201e668116dd138801d" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">Формат строки целенаправленно не указан, и код, который заботится о формате строки, должен использовать &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; , &lt;code&gt;toSimpleString&lt;/code&gt; или некоторую другую пользовательскую функцию форматирования, которая явно генерирует формат, необходимый коду. Причина в том, что в этом коде становится ясным, в каком формате он используется, что делает его менее подверженным ошибкам для обслуживания кода и взаимодействия с другим программным обеспечением, которое использует сгенерированные строки. По этой же причине у &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; нет функции &lt;code&gt;fromString&lt;/code&gt; , тогда как у нее есть &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; и &lt;code&gt;fromSimpleString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e82eb1994e0d2ee7e98c5b8f8c20cfd78e8b067" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">Формат строки &lt;code&gt;toISOString&lt;/code&gt; &lt;code&gt;toISOExtString&lt;/code&gt; , и код, который заботится о формате строки, должен использовать toISOString , toISOExtString , &lt;code&gt;toSimpleString&lt;/code&gt; или некоторую другую пользовательскую функцию форматирования, которая явно генерирует формат, необходимый коду. Причина в том, что в этом коде становится ясным, в каком формате он используется, что делает его менее подверженным ошибкам для обслуживания кода и взаимодействия с другим программным обеспечением, которое использует сгенерированные строки. По этой же причине &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; не имеет функции &lt;code&gt;fromString&lt;/code&gt; , тогда как у него есть &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; и &lt;code&gt;fromSimpleString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96cf4abaa3ec73526e49a27860bcadf20906a190" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">Формат строки &lt;code&gt;toISOString&lt;/code&gt; &lt;code&gt;toISOExtString&lt;/code&gt; , и код, который заботится о формате строки, должен использовать toISOString , toISOExtString , &lt;code&gt;toSimpleString&lt;/code&gt; или некоторую другую пользовательскую функцию форматирования, которая явно генерирует формат, необходимый коду. Причина в том, что в этом коде становится ясным, в каком формате он используется, что делает его менее подверженным ошибкам для обслуживания кода и взаимодействия с другим программным обеспечением, которое использует сгенерированные строки. По этой же причине &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; не имеет функции &lt;code&gt;fromString&lt;/code&gt; , тогда как у него есть &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; и &lt;code&gt;fromSimpleString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02a7f64095e841cf54dadcac2f9cbc728022a8d4" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt; and &lt;code&gt;fromISOExtString&lt;/code&gt;.</source>
          <target state="translated">Формат строки целенаправленно не указан, и код, который заботится о формате строки, должен использовать &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; или некоторую другую пользовательскую функцию форматирования, которая явно генерирует формат, который необходим коду. Причина в том, что в этом коде становится ясным, в каком формате он используется, что делает его менее подверженным ошибкам для обслуживания кода и взаимодействия с другим программным обеспечением, которое использует сгенерированные строки. По этой же причине &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; не имеет функции &lt;code&gt;fromString&lt;/code&gt; , тогда как у него есть &lt;code&gt;fromISOString&lt;/code&gt; и &lt;code&gt;fromISOExtString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffca9618faa656329893915994f22e9af2d88357" translate="yes" xml:space="preserve">
          <source>The format returned by toString may or may not change in the future.</source>
          <target state="translated">Формат,возвращаемый системой toString,может изменяться или не изменяться в будущем.</target>
        </trans-unit>
        <trans-unit id="03b68c7b67ac69b6f5b3f857c44f365ee971e450" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;' '&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">Спецификатор формата содержал &lt;code&gt;' '&lt;/code&gt; ( совместимость с &lt;code&gt;printf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f06eba7969af19af6a609393b286c72694c125a1" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'#'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">Спецификатор формата содержал &lt;code&gt;'#'&lt;/code&gt; ( совместимость с &lt;code&gt;printf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b3efef6165630dae7b0c5941cb57f0ff6fb2723" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">Спецификатор формата содержал &lt;code&gt;'+'&lt;/code&gt; ( совместимость с &lt;code&gt;printf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6460ee5bc9ce27cd4f9cfd713bf8f2494817b14f" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;','&lt;/code&gt;</source>
          <target state="translated">Спецификатор формата содержал &lt;code&gt;','&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="962882364923635b105d5f54d8d7565b59680ac3" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">Спецификатор формата содержал &lt;code&gt;'-'&lt;/code&gt; ( совместимость с &lt;code&gt;printf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d34bdd42fd319223df703e24b238ea323c66c17e" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">Спецификатор формата содержал &lt;code&gt;'0'&lt;/code&gt; ( совместимость с &lt;code&gt;printf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e47d83ed9645d662de3546c090652b44c5fa2bb" translate="yes" xml:space="preserve">
          <source>The format string can be checked at compile-time (see &lt;a href=&quot;#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; for details):</source>
          <target state="translated">Строка формата может быть проверена во время компиляции ( подробности см. В &lt;a href=&quot;#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="bd749ebde47823b6d49d60691dec84566b639bf8" translate="yes" xml:space="preserve">
          <source>The format string can reference parts of match using the following notation.</source>
          <target state="translated">Строка формата может ссылаться на части совпадения,используя следующую нотацию.</target>
        </trans-unit>
        <trans-unit id="2d3aec5d983c44f1af503ee811b2266d3dca8cd3" translate="yes" xml:space="preserve">
          <source>The format string has the following grammar:</source>
          <target state="translated">Строка формата имеет следующую грамматику:</target>
        </trans-unit>
        <trans-unit id="0625c7ec1018d088678495be9b57d04b31498a03" translate="yes" xml:space="preserve">
          <source>The format string supports the formatting of array and nested array elements via the grouping format specifiers &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt;. Each matching pair of &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt; corresponds with a single array argument. The enclosed sub-format string is applied to individual array elements. The trailing portion of the sub-format string following the conversion specifier for the array element is interpreted as the array delimiter, and is therefore omitted following the last array element. The &lt;b&gt;%|&lt;/b&gt; specifier may be used to explicitly indicate the start of the delimiter, so that the preceding portion of the string will be included following the last array element. (See below for explicit examples.)</source>
          <target state="translated">Строка формата поддерживает форматирование элементов массива и вложенного массива с помощью спецификаторов формата группировки &lt;b&gt;% (&lt;/b&gt; и &lt;b&gt;%)&lt;/b&gt; . Каждая совпадающая пара &lt;b&gt;% (&lt;/b&gt; и &lt;b&gt;%)&lt;/b&gt; соответствует одному аргументу массива. Вложенная строка подформат применяется к отдельным элементам массива. Задняя часть строки подформата после спецификатора преобразования для элемента массива интерпретируется как разделитель массива и поэтому опускается после последнего элемента массива. &lt;b&gt;% |&lt;/b&gt; спецификатор может быть использован для явного указания начала разделителя, так что предыдущая часть строки будет включена после последнего элемента массива. (См. Ниже для явных примеров.)</target>
        </trans-unit>
        <trans-unit id="693a71e5dd0ab926d97018418f98a27b3e174029" translate="yes" xml:space="preserve">
          <source>The format string used for this log call.</source>
          <target state="translated">Строка форматирования,используемая для этого вызова журнала.</target>
        </trans-unit>
        <trans-unit id="9fa2fc4abd1b83aca1055ee06f982cdb131c59e5" translate="yes" xml:space="preserve">
          <source>The formatting flag is applied individually to each value, for example:</source>
          <target state="translated">Флаг форматирования применяется,например,индивидуально к каждому значению:</target>
        </trans-unit>
        <trans-unit id="d26ac44ffe5a86909c11c81e0ef71d3888da5c4c" translate="yes" xml:space="preserve">
          <source>The forms of the</source>
          <target state="translated">Формы</target>
        </trans-unit>
        <trans-unit id="38e88fa7315be494a88a395eb056b9ace726e37c" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. Returns null if there is no Soundex representation for the string.</source>
          <target state="translated">В результате получается массив из четырех символов с Soundex.Возвращает ноль,если для строки нет представления Soundex.</target>
        </trans-unit>
        <trans-unit id="0480c3df77ed33fc07e614d2d8de8fc045910624" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. The array has zero's in it if there is no Soundex representation for the string.</source>
          <target state="translated">В результате получается массив из четырех символов с Soundex.Если для строки нет представления Soundex,то массив имеет нулевое значение.</target>
        </trans-unit>
        <trans-unit id="5766013bffb3825b0abbe1d083667aa11616b979" translate="yes" xml:space="preserve">
          <source>The fourth form, &lt;code&gt;goto case&lt;/code&gt;&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;, transfers to the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; with a matching &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Четвертая форма, &lt;code&gt;goto case&lt;/code&gt; &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; &lt;code&gt;;&lt;/code&gt; , передает &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; самого внутреннего включающего &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; с соответствующим &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражением&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13efbc5e672643becc355867b63d8f22b9e474d7" translate="yes" xml:space="preserve">
          <source>The fourth version counts the number of elements in a range. It is an optimization for the third version: if the given range has the &lt;code&gt;length&lt;/code&gt; property the count is returned right away, otherwise performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) to walk the range.</source>
          <target state="translated">Четвертая версия подсчитывает количество элементов в диапазоне. Это оптимизация для третьей версии: если заданный диапазон имеет свойство &lt;code&gt;length&lt;/code&gt; счет возвращается сразу, в противном случае выполняется &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; ) для обхода диапазона.</target>
        </trans-unit>
        <trans-unit id="48edc0798b06f223cb1ddbda6fdb31f83f4e14ab" translate="yes" xml:space="preserve">
          <source>The fractional part of x.</source>
          <target state="translated">Дробная часть Х.</target>
        </trans-unit>
        <trans-unit id="afaeb9378608c5260a3259e8f02e82dbd938d6f1" translate="yes" xml:space="preserve">
          <source>The fractional seconds portion of the time.</source>
          <target state="translated">Дробная часть времени.</target>
        </trans-unit>
        <trans-unit id="a033f1a65da2c07804aca3b53ca406684bb91d81" translate="yes" xml:space="preserve">
          <source>The free list is circular, with the last node pointing back to the first.</source>
          <target state="translated">Свободный список-круглый,последний узел указывает на первый.</target>
        </trans-unit>
        <trans-unit id="c4517bc5d244bf2185e9745bb334e09ef6af1ee0" translate="yes" xml:space="preserve">
          <source>The free tree has special handling of duplicates (a singly-linked list per node) in anticipation of large number of duplicates. Allocation time from the free tree is expected to be &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) where &lt;code&gt;n&lt;/code&gt; is the number of distinct sizes (not total nodes) kept in the free tree.</source>
          <target state="translated">Свободное дерево имеет специальную обработку дубликатов (односвязный список на узел) в ожидании большого количества дубликатов. Ожидается, что время выделения из свободного дерева будет &amp;Omicron; ( &lt;code&gt;log n&lt;/code&gt; ), где &lt;code&gt;n&lt;/code&gt; - это число различных размеров (не всех узлов), хранящихся в свободном дереве.</target>
        </trans-unit>
        <trans-unit id="ee4d09c6e55b89fcf5b3563176298a96aa717ff4" translate="yes" xml:space="preserve">
          <source>The freelist is maintained in increasing address order, which makes coalescing easy.</source>
          <target state="translated">Фрилист поддерживается в возрастающем порядке адресов,что облегчает коалесценцию.</target>
        </trans-unit>
        <trans-unit id="8fea8f11f99f1f8b366c244a4de1a614fd67b29c" translate="yes" xml:space="preserve">
          <source>The front element in the container</source>
          <target state="translated">Фронтальный элемент в контейнере</target>
        </trans-unit>
        <trans-unit id="13da137fb2ab48bf4928214ec4fc5ac7d9dd7e0b" translate="yes" xml:space="preserve">
          <source>The full URL to get/put</source>
          <target state="translated">Полный URL для получения/выдачи</target>
        </trans-unit>
        <trans-unit id="bdda625bfb1430028e4b6006d0968612c21121d6" translate="yes" xml:space="preserve">
          <source>The full list of named character entities from the &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5 Spec&lt;/a&gt; is supported except for the named entities which contain multiple code points. Below is a</source>
          <target state="translated">Поддерживается полный список объектов именованных символов из &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;спецификации HTML 5,&lt;/a&gt; за исключением именованных объектов, которые содержат несколько кодовых точек. Ниже</target>
        </trans-unit>
        <trans-unit id="53abcf6f821b2e7ec7e516af58f09e5bd8d1aff5" translate="yes" xml:space="preserve">
          <source>The full module system</source>
          <target state="translated">Полностью модульная система</target>
        </trans-unit>
        <trans-unit id="ee63124c4c066661e689e48b06ebee05399673e5" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the symbol.</source>
          <target state="translated">Полностью квалифицированное название символа.</target>
        </trans-unit>
        <trans-unit id="4d00150ca0468a4f7743a4f3a38c13aec942337c" translate="yes" xml:space="preserve">
          <source>The fully-qualified names of both types if the two type names are not the same, or the unqualified names of both types if the two type names are the same.</source>
          <target state="translated">Полноценные имена обоих типов,если имена двух типов не являются одинаковыми,или безоговорочные имена обоих типов,если имена двух типов являются одинаковыми.</target>
        </trans-unit>
        <trans-unit id="38a1580a58c3012db59e4a8a700c45c0c6b1674d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fd&lt;/code&gt; is added to the nested references of the newly created variable such that a closure is made for the variable when the address of &lt;code&gt;fd&lt;/code&gt; is taken.</source>
          <target state="translated">Функция &lt;code&gt;fd&lt;/code&gt; добавляется к вложенным ссылкам вновь созданной переменной, так что для переменной делается закрытие, когда берется адрес &lt;code&gt;fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bc8d00dffc62265a3b988178c4153a69f61f3ec" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;remove&lt;/code&gt; works on bidirectional ranges that have assignable lvalue elements. The moving strategy is (listed from fastest to slowest):</source>
          <target state="translated">Функция &lt;code&gt;remove&lt;/code&gt; работает с двунаправленными диапазонами, которые имеют назначаемые элементы lvalue. Стратегия движения (перечислена от самой быстрой до самой медленной):</target>
        </trans-unit>
        <trans-unit id="dfdecb6a33548c2c3a57ed9788619ffcbcd64fcd" translate="yes" xml:space="preserve">
          <source>The function allocates memory if and only if it gets to the third stage of this algorithm.</source>
          <target state="translated">Функция выделяет память,если и только если она попадает на третий этап данного алгоритма.</target>
        </trans-unit>
        <trans-unit id="59d7ef7bccfe8628462077a719a53074c919f8fa" translate="yes" xml:space="preserve">
          <source>The function call operator, &lt;code&gt;()&lt;/code&gt;, can be overloaded by declaring a function named &lt;code&gt;opCall&lt;/code&gt;:</source>
          <target state="translated">Оператор вызова функции &lt;code&gt;()&lt;/code&gt; может быть перегружен объявлением функции с именем &lt;code&gt;opCall&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="75414fa30a8eeadba0f9df43d9a81faffe1eb302" translate="yes" xml:space="preserve">
          <source>The function declaration makes it clear what the inputs and outputs to the function are.</source>
          <target state="translated">Декларация функций дает четкое представление о том,что такое входы и выходы для функции.</target>
        </trans-unit>
        <trans-unit id="36bd72a87a6fb51210593d16c9d3850d26ad2813" translate="yes" xml:space="preserve">
          <source>The function generated tests if the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; passed belongs to this set or not. The result is to be used with string mixin. The intended usage area is aggressive optimization via meta programming in parser generators and the like.</source>
          <target state="translated">Функция генерирует тесты, принадлежит ли пройденная &lt;a href=&quot;#Code%20point&quot;&gt;кодовая точка&lt;/a&gt; этому набору или нет. Результат должен использоваться со строкой mixin. Предполагаемая область использования - агрессивная оптимизация через метапрограммирование в генераторах синтаксических анализаторов и тому подобное.</target>
        </trans-unit>
        <trans-unit id="98e31cd639a66b786829a51b07b196c9eb02f441" translate="yes" xml:space="preserve">
          <source>The function is doing something impure, so mark it as impure. If there's a purity error, return true.</source>
          <target state="translated">Функция делает что-то нечистое,так что отметьте это как нечистое.Если есть ошибка чистоты,верните правду.</target>
        </trans-unit>
        <trans-unit id="78716a8e02a777fde55cd9f5bd9506b86f2cd433" translate="yes" xml:space="preserve">
          <source>The function is doing something that may allocate with the GC, so mark it as not nogc (not no-how).</source>
          <target state="translated">Функция делает что-то,что может быть выделено с ГХ,так что пометьте его как не nogc (не как не-шоу).</target>
        </trans-unit>
        <trans-unit id="1582435911618910fd1cebd4a56e5bade73d2f42" translate="yes" xml:space="preserve">
          <source>The function is doing something unsafe, so mark it as unsafe. If there's a safe error, return true.</source>
          <target state="translated">Функция делает что-то небезопасное,так что отметьте это как небезопасное.Если есть безопасная ошибка,верните true.</target>
        </trans-unit>
        <trans-unit id="185793595bc4f7b5898c63f905d91abe291e2c5e" translate="yes" xml:space="preserve">
          <source>The function is explicitly annotated &lt;code&gt;@nogc&lt;/code&gt; because inference could fail, see &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;issue 17084&lt;/a&gt;.</source>
          <target state="translated">Функция явно аннотирована &lt;code&gt;@nogc&lt;/code&gt; , поскольку вывод может завершиться ошибкой, см. &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;Выпуск 17084&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94377b90d447230e8a5ccf1a52d33d616f20136c" translate="yes" xml:space="preserve">
          <source>The function is intended to replace the hexadecimal literal strings starting with &lt;code&gt;'x'&lt;/code&gt;, which could be removed to simplify the core language.</source>
          <target state="translated">Функция предназначена для замены шестнадцатеричных буквенных строк, начинающихся с &lt;code&gt;'x'&lt;/code&gt; , которые могут быть удалены для упрощения основного языка.</target>
        </trans-unit>
        <trans-unit id="408608d2bfc199a6a551d83606a62872252fdf6d" translate="yes" xml:space="preserve">
          <source>The function overloads returning a string allocate their return values using the GC. The versions returning static arrays use pass-by-value for the return value, effectively avoiding dynamic allocation.</source>
          <target state="translated">Функция перегружает возвращающую строку,распределяя их возвращаемые значения с помощью ГХ.Версии,возвращающие статические массивы,используют pass-by-value для возвращаемого значения,эффективно избегая динамического распределения.</target>
        </trans-unit>
        <trans-unit id="7b0e25cbd51eccc8cf3fde77bb9a906902973f49" translate="yes" xml:space="preserve">
          <source>The function parameter attributes &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt; are used to track what happens to low-level pointers passed to functions. Such pointers include: raw pointers, arrays, &lt;code&gt;this&lt;/code&gt;, classes, &lt;code&gt;ref&lt;/code&gt; parameters, delegate/lazy parameters, and aggregates containing a pointer.</source>
          <target state="translated">Атрибуты параметров функции &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;scope&lt;/code&gt; используются для отслеживания того, что происходит с указателями низкого уровня, передаваемыми в функции. К таким указателям относятся: необработанные указатели, массивы, &lt;code&gt;this&lt;/code&gt; , классы, параметры &lt;code&gt;ref&lt;/code&gt; , параметры для делегатов / ленивых и агрегаты, содержащие указатель.</target>
        </trans-unit>
        <trans-unit id="6e994bfc1a839ed290d4129f0f5733e981d5373e" translate="yes" xml:space="preserve">
          <source>The function returns a range containing the consecutive reduced values. If there is more than one &lt;code&gt;fun&lt;/code&gt;, the element type will be &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt; std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; containing one element for each &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Функция возвращает диапазон, содержащий последовательные уменьшенные значения. Если имеется более одного &lt;code&gt;fun&lt;/code&gt; , тип элемента будет &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt; std.typecons.Tuple&lt;/code&gt; ,&lt;/a&gt; содержащий один элемент для каждого &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1de9581bb40aa0605e1d4f2b900b32c62cf6dcb" translate="yes" xml:space="preserve">
          <source>The function returns immediately, leaving the child process to execute in parallel with its parent. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; unless the process was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">Функция немедленно возвращается, оставляя дочерний процесс для выполнения параллельно с его родителем. Рекомендуется всегда вызывать &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; для возвращенного &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; ,&lt;/a&gt; если процесс не был порожден флагом &lt;code&gt;Config.detached&lt;/code&gt; , как подробно описано в документации для &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1462ec35dc456ac6ff3045ecdc8148b89412c36" translate="yes" xml:space="preserve">
          <source>The function source code must be available to the compiler. Functions which exist in the source code only as extern declarations cannot be executed in CTFE.</source>
          <target state="translated">Исходный код функции должен быть доступен компилятору.Функции,которые существуют в исходном коде только в виде внешних объявлений,не могут быть выполнены в CTFE.</target>
        </trans-unit>
        <trans-unit id="c99c9ccaa6aadf1ddb21d118ac9a2b39a2936c1d" translate="yes" xml:space="preserve">
          <source>The function that wants to measure speed.</source>
          <target state="translated">Функция,которая хочет измерить скорость.</target>
        </trans-unit>
        <trans-unit id="411ac38391245e7bd9f2d61489a0679e909d3705" translate="yes" xml:space="preserve">
          <source>The function to become the base of the speed.</source>
          <target state="translated">Функция,которая станет основой скорости.</target>
        </trans-unit>
        <trans-unit id="ca30c519a6a156f76c6573e841573612bc2aad51" translate="yes" xml:space="preserve">
          <source>The function to execute.</source>
          <target state="translated">Функция,которую нужно выполнить.</target>
        </trans-unit>
        <trans-unit id="38560d673ec14174a5201f65e942b10ff886f6eb" translate="yes" xml:space="preserve">
          <source>The function to execute. This may be the actual function passed by the user to spawn itself, or may be a wrapper function.</source>
          <target state="translated">Функция,которую нужно выполнить.Это может быть фактическая функция,переданная пользователем для нереста,или может быть функцией обертки.</target>
        </trans-unit>
        <trans-unit id="67a64604c4717ec6e34e3f3a6e53ee63c3039ae1" translate="yes" xml:space="preserve">
          <source>The function used to check if &lt;code&gt;addr&lt;/code&gt; is marked.</source>
          <target state="translated">Функция, используемая для проверки , отмечен ли &lt;code&gt;addr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4a8105c562ae246a8ce7c12b0a3320ba9511dc7" translate="yes" xml:space="preserve">
          <source>The function used to generate the next time point in the range.</source>
          <target state="translated">Функция,используемая для генерации следующей временной точки в диапазоне.</target>
        </trans-unit>
        <trans-unit id="dc715bdc2551fef5137debdc9a1fe82c19568021" translate="yes" xml:space="preserve">
          <source>The function used to generate the time points of the range over the interval.</source>
          <target state="translated">Функция,используемая для генерации временных точек диапазона на интервале.</target>
        </trans-unit>
        <trans-unit id="f3d2158936e817ae5d4b5a34d016e49a32ca1146" translate="yes" xml:space="preserve">
          <source>The function will not return if any enclosing finally clause does a return, goto or throw that exits the finally clause.</source>
          <target state="translated">Функция не будет возвращаться,если какое-либо прилагаемое окончательное условие возвращает,возвращает или бросает то,что выходит из окончательного условия.</target>
        </trans-unit>
        <trans-unit id="46f3e02eaaa99bc9ca72c46c606ddf965d307189" translate="yes" xml:space="preserve">
          <source>The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN.</source>
          <target state="translated">Функциональность строго следует стандарту IEEE754-2008 для арифметики с плавающей точкой,включая использование верблюжьих имён вместо имён в нижнем регистре в стиле C99.Все эти функции корректно ведут себя при представлении с бесконечностью или NaN.</target>
        </trans-unit>
        <trans-unit id="a8b49dde8278905e1da61afa2345291851916bc1" translate="yes" xml:space="preserve">
          <source>The functionally is based on &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. LibCurl is licensed under an MIT/X derivative license.</source>
          <target state="translated">Функционально основан на &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt; . LibCurl лицензируется по производной лицензии MIT / X.</target>
        </trans-unit>
        <trans-unit id="4e9193abd91f293a360c49af75182f625a029338" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#formatValue&quot;&gt;&lt;code&gt;formatValue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unformatValue&quot;&gt;&lt;code&gt;unformatValue&lt;/code&gt;&lt;/a&gt; are used for the plumbing.</source>
          <target state="translated">Функции &lt;a href=&quot;#formatValue&quot;&gt; &lt;code&gt;formatValue&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#unformatValue&quot;&gt; &lt;code&gt;unformatValue&lt;/code&gt; &lt;/a&gt; используются для сантехники.</target>
        </trans-unit>
        <trans-unit id="09d84b61f63134826318f5b038f0d9e7c6a89164" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#multiwayMerge&quot;&gt;&lt;code&gt;multiwayMerge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiwayUnion&quot;&gt;&lt;code&gt;multiwayUnion&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setDifference&quot;&gt;&lt;code&gt;setDifference&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setIntersection&quot;&gt;&lt;code&gt;setIntersection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setSymmetricDifference&quot;&gt;&lt;code&gt;setSymmetricDifference&lt;/code&gt;&lt;/a&gt; expect a range of sorted ranges as input.</source>
          <target state="translated">Функции &lt;a href=&quot;#multiwayMerge&quot;&gt; &lt;code&gt;multiwayMerge&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiwayUnion&quot;&gt; &lt;code&gt;multiwayUnion&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setDifference&quot;&gt; &lt;code&gt;setDifference&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setIntersection&quot;&gt; &lt;code&gt;setIntersection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setSymmetricDifference&quot;&gt; &lt;code&gt;setSymmetricDifference&lt;/code&gt; &lt;/a&gt; ожидать диапазон отсортированных диапазонов в качестве входных данных.</target>
        </trans-unit>
        <trans-unit id="4fde7de03cdc04e15dde2a51577db6987e675d9f" translate="yes" xml:space="preserve">
          <source>The functions can use &lt;code&gt;@trusted&lt;/code&gt; instead of &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">Функции могут использовать &lt;code&gt;@trusted&lt;/code&gt; вместо &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30a160975f83d4201f4fd65daf1113007bc807be" translate="yes" xml:space="preserve">
          <source>The gamma and related functions, and the error function are crucial for mathematical statistics. The Bessel and related functions arise in problems involving wave propagation (especially in optics). Other major categories of special functions include the elliptic integrals (related to the arc length of an ellipse), and the hypergeometric functions.</source>
          <target state="translated">Гамма и связанные с ней функции,а также функция ошибки имеют решающее значение для математической статистики.Бессел и связанные с ним функции возникают в задачах,связанных с распространением волн (особенно в оптике).К другим основным категориям специальных функций относятся интегралы эллипса (связанные с длиной дуги эллипса)и гипергеометрические функции.</target>
        </trans-unit>
        <trans-unit id="447281d1324337b15482dcfc848c6a78d28256cf" translate="yes" xml:space="preserve">
          <source>The gapped similarity at the current match length (initially 1, grows with each call to &lt;code&gt;popFront&lt;/code&gt;).</source>
          <target state="translated">Схожесть с разрывом при текущей длине совпадения (изначально 1, увеличивается с каждым вызовом &lt;code&gt;popFront&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="05176e7bf5bf611688f908ea258370d40d6b3039" translate="yes" xml:space="preserve">
          <source>The garbage collector calls the destructor function when the object is deleted. The syntax is:</source>
          <target state="translated">При удалении объекта сборщик мусора вызывает функцию деструктора.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="8162594fc1e13b54530b98ac255177e2a9d2ab78" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan non-pointer fields for GC pointers.</source>
          <target state="translated">Сборщик мусора не сканирует не указательные поля для указателей GC.</target>
        </trans-unit>
        <trans-unit id="bace0715c82c9b149257399e18cc90537b20fbf1" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not created by the D Thread interface. Nor does it scan the data segments of other DLLs, etc.</source>
          <target state="translated">Сборщик мусора не сканирует стопки потоков,не созданные интерфейсом D Thread.Он также не сканирует сегменты данных других DLL и т.д.</target>
        </trans-unit>
        <trans-unit id="679912e5f590d3f8f03034fbcabdaff8e29c8cba" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not registered with the D runtime, nor does it scan the data segments of shared libraries that aren't registered with the D runtime.</source>
          <target state="translated">Сборщик мусора не сканирует стопки потоков,не зарегистрированных во время выполнения D,а также сегменты данных совместно используемых библиотек,не зарегистрированных во время выполнения D.</target>
        </trans-unit>
        <trans-unit id="248f5f617e65210251e2aceaf897cfac6784a5ad" translate="yes" xml:space="preserve">
          <source>The garbage collector is not guaranteed to run the destructor for all unreferenced objects. Furthermore, the order in which the garbage collector calls destructors for unreferenced objects is not specified. This means that when the garbage collector calls a destructor for an object of a class that has members which are references to garbage collected objects, those references may no longer be valid. This means that destructors cannot reference sub objects. This rule does not apply to auto objects or objects destructed with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, as the destructor is not being run by the garbage collector, meaning all references are valid.</source>
          <target state="translated">Сборщик мусора не гарантирует запуск деструктора для всех объектов, на которые нет ссылок. Кроме того, порядок, в котором сборщик мусора вызывает деструкторы для объектов, на которые нет ссылок, не указан. Это означает, что когда сборщик мусора вызывает деструктор для объекта класса, члены которого являются ссылками на объекты, собираемые мусором, эти ссылки могут быть недействительными. Это означает, что деструкторы не могут ссылаться на подобъекты. Это правило не применяется к автоматическим объектам или объектам, разрушенным с помощью &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; , поскольку деструктор не запускается сборщиком мусора, то есть все ссылки действительны.</target>
        </trans-unit>
        <trans-unit id="7ed0a2988d2028482af5b70f4886f714e874cd68" translate="yes" xml:space="preserve">
          <source>The garbage collector looks for roots in:</source>
          <target state="translated">Мусорщик ищет корни:</target>
        </trans-unit>
        <trans-unit id="a61608c994e8531817d927f16b69cb4ec2652687" translate="yes" xml:space="preserve">
          <source>The general usage guideline is to keep regex complexity on the side of simplicity, as its capabilities reside in purely character-level manipulation. As such it's ill-suited for tasks involving higher level invariants like matching an integer number &lt;em&gt;bounded&lt;/em&gt; in an [a,b] interval. Checks of this sort of are better addressed by additional post-processing.</source>
          <target state="translated">Общее руководство по использованию заключается в том, чтобы сохранить сложность регулярных выражений на стороне простоты, поскольку его возможности заключаются в чисто символьных манипуляциях. Как таковой, он плохо подходит для задач, включающих инварианты более высокого уровня, таких как сопоставление целого числа, &lt;em&gt;ограниченного&lt;/em&gt; интервалом [a, b]. Проверки такого рода лучше решаются путем дополнительной постобработки.</target>
        </trans-unit>
        <trans-unit id="587ae2153e1cd24d01fed6ce88e2ec32ff8c2014" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;opAssign&lt;/code&gt; function has the following signature:</source>
          <target state="translated">Сгенерированная функция &lt;code&gt;opAssign&lt;/code&gt; имеет следующую подпись:</target>
        </trans-unit>
        <trans-unit id="e40de6a32624f7e6b5379975d2cd46fa3f2fa94f" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65a1da736509a9381ee000758f5d850e508e3e2" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceeded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="translated">Сгенерированные ссылки на символы D являются относительными, если они имеют тот же корневой пакет, что и документируемый модуль. Если нет, то перед их URL- &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; макрос &amp;amp; dollar; (DDOC_ROOT_pkg) , где &lt;code&gt;pkg&lt;/code&gt; - корневой пакет символа, с которым связано. Ссылки на символы D создаются с помощью макроса &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; после имени модуля. Таким образом, сгенерированный URL для &lt;code&gt;[Object]&lt;/code&gt; в приведенном выше примере выглядит так, как если бы вы написали:</target>
        </trans-unit>
        <trans-unit id="adc505580a3e3a25fed9b9c63e6f0745b68f08fa" translate="yes" xml:space="preserve">
          <source>The getopt module implements a &lt;code&gt;getopt&lt;/code&gt; function, which adheres to the POSIX syntax for command line options. GNU extensions are supported in the form of long options introduced by a double dash (&quot;--&quot;). Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">Модуль getopt реализует функцию &lt;code&gt;getopt&lt;/code&gt; , которая придерживается синтаксиса POSIX для параметров командной строки. Расширения GNU поддерживаются в форме длинных опций, введенных двойной чертой (&quot;-&quot;). Поддержка связывания параметров командной строки, как в случае с более традиционным однобуквенным подходом, предоставляется, но не включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="38436bf13581d96cda14b3d712a9839eef76ade6" translate="yes" xml:space="preserve">
          <source>The given HMAC token is compared with the expected token using the &lt;code&gt;==&lt;/code&gt; string comparison, which returns &lt;code&gt;false&lt;/code&gt; as soon as the first wrong element is found. If a wrong element is found, then a rejection is sent back to the sender.</source>
          <target state="translated">Данный токен HMAC сравнивается с ожидаемым токеном с помощью сравнения строк &lt;code&gt;==&lt;/code&gt; , которое возвращает &lt;code&gt;false&lt;/code&gt; , как только будет найден первый неправильный элемент. Если найден неправильный элемент, отклонение отправляется обратно отправителю.</target>
        </trans-unit>
        <trans-unit id="262b74b064f7ed4973ae2acf3633f01634ced6b1" translate="yes" xml:space="preserve">
          <source>The given array exposed to a standard D array.</source>
          <target state="translated">Данный массив подвергается воздействию стандартного массива D.</target>
        </trans-unit>
        <trans-unit id="8bc950de5698dccabc99a10c52424998aec0c7a6" translate="yes" xml:space="preserve">
          <source>The given array of &lt;code&gt;char&lt;/code&gt; or random-access range of &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;ubyte&lt;/code&gt; is expected to be in the format specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; section 3.3 with the grammar rule</source>
          <target state="translated">Ожидается, что данный массив &lt;code&gt;char&lt;/code&gt; или диапазон произвольного доступа &lt;code&gt;char&lt;/code&gt; или &lt;code&gt;ubyte&lt;/code&gt; будут иметь формат, указанный в разделе 3.3 &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; с правилом грамматики.</target>
        </trans-unit>
        <trans-unit id="12501a73a540c686a37f4823a66a820dabde2f39" translate="yes" xml:space="preserve">
          <source>The glob pattern</source>
          <target state="translated">Шаровой узор</target>
        </trans-unit>
        <trans-unit id="496ff2fc921b0a5cf99d9a4227ed4bf96d90c632" translate="yes" xml:space="preserve">
          <source>The grapheme cluster represents a horizontally segmentable unit of text, consisting of some grapheme base (which may consist of a Korean syllable) together with any number of nonspacing marks applied to it.</source>
          <target state="translated">Графемный кластер представляет собой горизонтально сегментированную единицу текста,состоящую из некоторой базы графем (которая может состоять из корейского слога)вместе с произвольным количеством нерассеянных знаков,нанесенных на нее.</target>
        </trans-unit>
        <trans-unit id="37af0a5e629675000a6dfa7103d088d3ddd62dac" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the given arguments.</source>
          <target state="translated">Самый большой общий делитель данных аргументов.</target>
        </trans-unit>
        <trans-unit id="8b3e1c284ef7e8df3ea6a61551c667aeed265141" translate="yes" xml:space="preserve">
          <source>The hack for bugzilla 4820 case is still questionable. Perhaps would have to handle a delegate expression with 'null' context properly in front-end.</source>
          <target state="translated">Взлом дела багзиллы 4820 всё ещё под вопросом.Возможно,придется правильно обрабатывать выражение делегата с &quot;нулевым&quot; контекстом во фронтальной части.</target>
        </trans-unit>
        <trans-unit id="38f5b63c8a583d4d295cf756159c50490e54c13e" translate="yes" xml:space="preserve">
          <source>The handle to an array is specified by naming the array, as in p, s or a:</source>
          <target state="translated">Ручка для массива задается именованием массива,как в p,s или a:</target>
        </trans-unit>
        <trans-unit id="06b9457ea3f4fa7b2cb019db8602c7584d3ac0a3" translate="yes" xml:space="preserve">
          <source>The handler to run if the expression throwed.</source>
          <target state="translated">Обработчик,который бежит,если выражение брошено.</target>
        </trans-unit>
        <trans-unit id="bb782c4330787617d4fce577aae35ea8ac20fb68" translate="yes" xml:space="preserve">
          <source>The hash function RIPEMD-160</source>
          <target state="translated">Хэш-функция RIPEMD-160</target>
        </trans-unit>
        <trans-unit id="1a548321e03af2d162f5b6fb8172e4e75095c3be" translate="yes" xml:space="preserve">
          <source>The hashBlockSize and digestSize are in bits. However, it's likely easier to simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512, SHA512_224 and SHA512_256.</source>
          <target state="translated">Размеры hashBlockSize и digestSize находятся в битах.Однако,скорее всего,проще просто использовать удобные псевдонимы:SHA1,SHA224,SHA256,SHA384,SHA512,SHA512_224 и SHA512_256.</target>
        </trans-unit>
        <trans-unit id="71c022924374f373de8247c9ee1154db2efdf429" translate="yes" xml:space="preserve">
          <source>The header can also be left empty if the input contains a header row and all columns should be iterated. The header from the input can always be accessed from the &lt;code&gt;header&lt;/code&gt; field.</source>
          <target state="translated">Заголовок также можно оставить пустым, если вход содержит строку заголовка и все столбцы должны быть повторены. Заголовок из ввода всегда можно получить доступ из поля &lt;code&gt;header&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23806478590a3d73211d3f9cfeab9ec2c30f42f5" translate="yes" xml:space="preserve">
          <source>The header of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; for tutorials on ranges.</source>
          <target state="translated">Заголовок &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; для учебников по диапазонам.</target>
        </trans-unit>
        <trans-unit id="a73e614d706951342951d40aeeb01697424cadb7" translate="yes" xml:space="preserve">
          <source>The headers read from a successful response.</source>
          <target state="translated">Заголовки читаются от успешного ответа.</target>
        </trans-unit>
        <trans-unit id="1ba658c4da138d5aa67105b1d7cc27b3cfde13e6" translate="yes" xml:space="preserve">
          <source>The highlighting macros start with &lt;code&gt;DDOC_&lt;/code&gt;. They control the formatting of individual parts of the presentation.</source>
          <target state="translated">&lt;code&gt;DDOC_&lt;/code&gt; выделения начинаются с DDOC_ . Они контролируют форматирование отдельных частей презентации.</target>
        </trans-unit>
        <trans-unit id="7850bd95e95bab4d64e3c6d1c398982e32639f37" translate="yes" xml:space="preserve">
          <source>The hook to wrap</source>
          <target state="translated">Крючок для обёртывания</target>
        </trans-unit>
        <trans-unit id="8f90c58c05f3db77fe848d30cab0798e3f6b00e3" translate="yes" xml:space="preserve">
          <source>The hook's members are looked up statically in a Design by Introspection manner and are all optional. The table below illustrates the members that a hook type may define and their influence over the behavior of the &lt;code&gt;Checked&lt;/code&gt; type using it. In the table, &lt;code&gt;hook&lt;/code&gt; is an alias for &lt;code&gt;Hook&lt;/code&gt; if the type &lt;code&gt;Hook&lt;/code&gt; does not introduce any state, or an object of type &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="translated">Члены хуков ищутся статически в манере Design by Introspection и являются необязательными. Таблица ниже иллюстрирует элементы, которые может определять тип ловушки, и их влияние на поведение &lt;code&gt;Checked&lt;/code&gt; типа, использующего его. В таблице &lt;code&gt;hook&lt;/code&gt; - это псевдоним для &lt;code&gt;Hook&lt;/code&gt; , если тип &lt;code&gt;Hook&lt;/code&gt; не вводит никакого состояния, или объект типа &lt;code&gt;Hook&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="c351eba3d013581a191d3a885a49968be29fd469" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">Час дня, для которого нужно установить значение этого &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66136c779346b036c2def79ac7f0dfb73004b7bb" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">Час дня, для которого нужно установить время этого &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a4e60304c50d5e98aa115b78722f98c55537a4" translate="yes" xml:space="preserve">
          <source>The hour portion of the time;</source>
          <target state="translated">Часовая часть времени;</target>
        </trans-unit>
        <trans-unit id="ae576aa7ec4954f0a9eb6186b74173801d58e446" translate="yes" xml:space="preserve">
          <source>The hours to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">Часы, чтобы установить час этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc9947af90e8e00095ff57d0a5f1abb3e951dbc5" translate="yes" xml:space="preserve">
          <source>The idea being these are compatible with C structs.</source>
          <target state="translated">Идея в том,что они совместимы со структурами С.</target>
        </trans-unit>
        <trans-unit id="1355f078be2cb8440aa75f9a09689cdae9f0217b" translate="yes" xml:space="preserve">
          <source>The idea of a contract is simple - it's just an expression that must evaluate to true. If it does not, the contract is broken, and by definition, the program has a bug in it. Contracts form part of the specification for a program, moving it from the documentation to the code itself. And as every programmer knows, documentation tends to be incomplete, out of date, wrong, or non-existent. Moving the contracts into the code makes them verifiable against the program.</source>
          <target state="translated">Идея договора проста-это просто выражение,которое должно оцениваться до истины.Если этого не происходит,то договор нарушается,и в программе,по определению,есть ошибка.Контракты являются частью спецификации программы,перенося ее из документации в сам код.И,как знает каждый программист,документация имеет тенденцию быть неполной,устаревшей,неправильной или вообще отсутствующей.Перемещение контрактов в код делает их верифицируемыми по отношению к программе.</target>
        </trans-unit>
        <trans-unit id="f6757769fd791ee402dbfe3e43c1aa10845db21c" translate="yes" xml:space="preserve">
          <source>The identity operator &lt;code&gt;is&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">Оператор идентификации &lt;code&gt;is&lt;/code&gt; может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="1a6dd428d8629e97cfcace7f86b78f24c85c36c4" translate="yes" xml:space="preserve">
          <source>The imaginary part of the number.</source>
          <target state="translated">Воображаемая часть числа.</target>
        </trans-unit>
        <trans-unit id="1ac7f7e21c56da918de0900c242a59f862e477cf" translate="yes" xml:space="preserve">
          <source>The immutable applies to the type within the following parentheses. So, while &lt;code&gt;s&lt;/code&gt; can be assigned new values, the contents of &lt;code&gt;s[]&lt;/code&gt; cannot be:</source>
          <target state="translated">Неизменяемый относится к типу в следующих скобках. Таким образом, в то время как &lt;code&gt;s&lt;/code&gt; могут быть присвоены новые значения, содержимое &lt;code&gt;s[]&lt;/code&gt; не может быть:</target>
        </trans-unit>
        <trans-unit id="b076480db50c8a69f17ceccfb8074a2146342dec" translate="yes" xml:space="preserve">
          <source>The immutable array.</source>
          <target state="translated">Неизменный массив.</target>
        </trans-unit>
        <trans-unit id="d4da7504d70ac035ecf312cd124c3e9b875475b7" translate="yes" xml:space="preserve">
          <source>The implementation exploits properties of types and operations to minimize additional work.</source>
          <target state="translated">В реализации используются свойства типов и операций для минимизации дополнительной работы.</target>
        </trans-unit>
        <trans-unit id="94333a362aef71aa736007c1291437cf4a5d5675" translate="yes" xml:space="preserve">
          <source>The implementation guarantees that all threads simultaneously calling initOnce with the same var argument block until var is fully initialized. All side-effects of init are globally visible afterwards.</source>
          <target state="translated">Реализация гарантирует,что все потоки,одновременно вызывающие initOnce с одним и тем же блоком аргументов var,будут инициализированы до тех пор,пока var не будет полностью инициализирован.Все побочные эффекты init после этого видны глобально.</target>
        </trans-unit>
        <trans-unit id="2e2b0dbd8c35c5a1541392596f49b59f590b7d4b" translate="yes" xml:space="preserve">
          <source>The implementation is available as a public member.</source>
          <target state="translated">Реализация доступна в качестве публичного члена.</target>
        </trans-unit>
        <trans-unit id="61a0fdac2dd135b95e81234f7a42c96423c9eb12" translate="yes" xml:space="preserve">
          <source>The implementation is based on the pseudocode in Fig. 4 of the paper &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&quot;Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets&quot;&lt;/a&gt; by Rousu et al., with additional algorithmic and systems-level optimizations.</source>
          <target state="translated">Реализация основана на псевдокоде на рис. 4 статьи &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&amp;laquo;Эффективное вычисление ядер с защелкой подстроки на больших алфавитах&amp;raquo;&lt;/a&gt; Роусу и др. С дополнительной алгоритмической и системной оптимизацией.</target>
        </trans-unit>
        <trans-unit id="c3c79f00444b1a8f6b8dd0d247228e66376bb4b5" translate="yes" xml:space="preserve">
          <source>The implementation may handle the case of the first</source>
          <target state="translated">Реализация может быть осуществлена в случае первого</target>
        </trans-unit>
        <trans-unit id="3f62d25116bc0232c42a3fb96db6f12be7eef293" translate="yes" xml:space="preserve">
          <source>The implementations of all predefined macros are implementation-defined. The reference implementation's macro definitions can be found &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Реализации всех предопределенных макросов определяются реализацией. Макроопределения эталонной реализации можно найти &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce44ea558c01cd44607fe7bfdaba1c3db8da7616" translate="yes" xml:space="preserve">
          <source>The implicit conversions of built-in scalar types can be explicitly represented by using function call syntax. For example:</source>
          <target state="translated">Неявные приведения встроенных скалярных типов могут быть явно представлены с помощью синтаксиса вызова функций.Например:</target>
        </trans-unit>
        <trans-unit id="8663ba6f06eeb782a371db21df4acbb1af0c444b" translate="yes" xml:space="preserve">
          <source>The importance of component programming (properties, signals and slots, etc)</source>
          <target state="translated">Важность компонентного программирования (свойства,сигналы и слоты и т.д.).</target>
        </trans-unit>
        <trans-unit id="c5712d89ed6b6b5326913e6635b003b614c7a5c4" translate="yes" xml:space="preserve">
          <source>The imports are looked up to satisfy any unresolved symbols at that scope. Imported symbols may hide symbols from outer scopes.</source>
          <target state="translated">Импорт просматривается на предмет удовлетворения любых нерешенных символов в этом объеме.Импортируемые символы могут скрывать символы из внешних областей применения.</target>
        </trans-unit>
        <trans-unit id="28c93ed79edf143da68c0f3519f73741ba79046d" translate="yes" xml:space="preserve">
          <source>The index of the element that should be in sorted position after the function is done.</source>
          <target state="translated">Индекс элемента,который после выполнения функции должен находиться в отсортированном положении.</target>
        </trans-unit>
        <trans-unit id="7b8cbc4deacf04830f34d38905f8ffd00330c728" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the maximum in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">Индекс первого столкновения максимума в &lt;code&gt;range&lt;/code&gt; . Если &lt;code&gt;range&lt;/code&gt; пуст, возвращается -1.</target>
        </trans-unit>
        <trans-unit id="1a84eb9548c30b563a95a1fcfb270886bdd52d9e" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the minimum element in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">Индекс первого столкновения минимального элемента в &lt;code&gt;range&lt;/code&gt; . Если &lt;code&gt;range&lt;/code&gt; пуст, возвращается -1.</target>
        </trans-unit>
        <trans-unit id="33a0038a0fcaf095d5057aead72f83713739fc8b" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is not found, then &lt;code&gt;-1&lt;/code&gt; is returned. The &lt;code&gt;startIdx&lt;/code&gt; slices &lt;code&gt;s&lt;/code&gt; in the following way &lt;code&gt;s[0 .. startIdx]&lt;/code&gt;. &lt;code&gt;startIdx&lt;/code&gt; represents a codeunit index in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Индекс последнего появления &lt;code&gt;c&lt;/code&gt; в &lt;code&gt;s&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; не найден, то возвращается &lt;code&gt;-1&lt;/code&gt; . В &lt;code&gt;startIdx&lt;/code&gt; ломтики &lt;code&gt;s&lt;/code&gt; следующим образом &lt;code&gt;s[0 .. startIdx]&lt;/code&gt; . &lt;code&gt;startIdx&lt;/code&gt; представляет индекс блока кода в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e5baf3f6abe9b83760e32cef1632ac5f67ea47" translate="yes" xml:space="preserve">
          <source>The index of the pivot for partitioning, must be less than &lt;code&gt;r.length&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;r.length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">Индекс стержня для разделения должен быть меньше &lt;code&gt;r.length&lt;/code&gt; или &lt;code&gt;0&lt;/code&gt; , если &lt;code&gt;r.length&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4e8d4da6e42c851e373823697d10ed8eae4adf3" translate="yes" xml:space="preserve">
          <source>The index of the type among &lt;code&gt;AllowedTypesParam&lt;/code&gt;, zero-based.</source>
          <target state="translated">Индекс типа среди &lt;code&gt;AllowedTypesParam&lt;/code&gt; , начиная с нуля.</target>
        </trans-unit>
        <trans-unit id="6f4d7d5591308d1987c179c707865f7263b2522b" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive.</source>
          <target state="translated">Индекс этого члена архива внутри архива.</target>
        </trans-unit>
        <trans-unit id="6bca3732803cf0cac5bd51a87fe2e1e77dd22909" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive. Set this to a different value for reordering the members of an archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3efb64d9c8c3a8462cc2762d6a92ac26c24dcc" translate="yes" xml:space="preserve">
          <source>The index starts at &lt;code&gt;start&lt;/code&gt; and is incremented by one on every iteration.</source>
          <target state="translated">Индекс начинается с &lt;code&gt;start&lt;/code&gt; и увеличивается на единицу на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="86fe7372a9779ec608c645bda74b3617bd2f68d1" translate="yes" xml:space="preserve">
          <source>The index to start reading from (instead of starting at the front). If index is a pointer, then it is updated to the index after the bytes read. The overloads with index are only available if &lt;code&gt;hasSlicing!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Индекс, с которого нужно начать чтение (вместо того, чтобы начинать с фронта). Если index является указателем, он обновляется до индекса после чтения байтов. Перегрузки с индексом доступны, только если &lt;code&gt;hasSlicing!R&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b0d5226f25947ab0cd2172717539dced2cf1ca0" translate="yes" xml:space="preserve">
          <source>The index to start writing to. If index is a pointer, then it is updated to the index after the bytes read.</source>
          <target state="translated">Индекс,на который нужно начать писать.Если индекс является указателем,то после прочтения байтов он обновляется до индекса.</target>
        </trans-unit>
        <trans-unit id="4dd9df4788f29de75fb62d913aea700844f5ed25" translate="yes" xml:space="preserve">
          <source>The index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ffb074b766c5938ff8b7357963618eaf462bcb" translate="yes" xml:space="preserve">
          <source>The indexed range. If rs consists of only one range, the return type is an alias of that range's type.</source>
          <target state="translated">Индексируемый диапазон.Если rs состоит только из одного диапазона,то возвращаемый тип является псевдонимом этого диапазона.</target>
        </trans-unit>
        <trans-unit id="619765ffdaa0071187a8f77abd362e7dda091d2c" translate="yes" xml:space="preserve">
          <source>The inference is done by determining if the function body follows the rules of the particular attribute.</source>
          <target state="translated">Вывод делается путем определения,следует ли тело функции правилам конкретного атрибута.</target>
        </trans-unit>
        <trans-unit id="44470f7ce0660d4121c31a312118ccb100fd5b58" translate="yes" xml:space="preserve">
          <source>The initial count for the semaphore.</source>
          <target state="translated">Начальный отсчёт для семафора.</target>
        </trans-unit>
        <trans-unit id="8c9e853ca955ba71f49e1626fd9e59d97a172b5c" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with its predicates converted to an equivalent single predicate.</source>
          <target state="translated">Начальный диапазон обернут как &lt;code&gt;SortedRange&lt;/code&gt; с его предикатами, преобразованными в эквивалентный одиночный предикат.</target>
        </trans-unit>
        <trans-unit id="47bf51e4f2c2e73e2360a982a3dcd26ed977c3bb" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt;.</source>
          <target state="translated">Начальный диапазон заключен в &lt;code&gt;SortedRange&lt;/code&gt; с предикатом &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae187df68ec47146dca1715d3e3c373579beb355" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;binaryFun!less&lt;/code&gt;.</source>
          <target state="translated">Начальный диапазон заключен в &lt;code&gt;SortedRange&lt;/code&gt; с предикатом &lt;code&gt;binaryFun!less&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d1aad4ad1e534532ce1e885f47d8eb7c78b11f" translate="yes" xml:space="preserve">
          <source>The initial size of each buffer. If &lt;code&gt;next&lt;/code&gt; takes its array by reference, it may resize the buffers.</source>
          <target state="translated">Начальный размер каждого буфера. Если &lt;code&gt;next&lt;/code&gt; использует свой массив по ссылке, он может изменить размер буферов.</target>
        </trans-unit>
        <trans-unit id="06bcd9aed8f8362952958dfe41f57dcc25fe7b79" translate="yes" xml:space="preserve">
          <source>The initialization expression for the type.</source>
          <target state="translated">Выражение инициализации для типа.</target>
        </trans-unit>
        <trans-unit id="ef4a846934e7e3a7c6fada2c58784a67e938dc53" translate="yes" xml:space="preserve">
          <source>The initializer for a manifest constant is evaluated using compile time function evaluation.</source>
          <target state="translated">Инициализатор манифестной константы оценивается с помощью оценки функции времени компиляции.</target>
        </trans-unit>
        <trans-unit id="4866f78cdd0450f210abe845a0008dc25126137c" translate="yes" xml:space="preserve">
          <source>The initializer for a non-local immutable declaration must be evaluatable at compile time:</source>
          <target state="translated">Инициализатор нелокальной неизменяемой декларации должен быть оценен на этапе компиляции:</target>
        </trans-unit>
        <trans-unit id="c3ff76d4230d39e88bec6a17e3fa23c6428b640f" translate="yes" xml:space="preserve">
          <source>The initializer for a non-static local immutable declaration is evaluated at run time:</source>
          <target state="translated">Инициализатор для нестатического локального неизменяемого объявления оценивается во время выполнения:</target>
        </trans-unit>
        <trans-unit id="8f27ed7b518832024e3d6a15cbe377f8e47f39ab" translate="yes" xml:space="preserve">
          <source>The initializer for a static variable must be evaluatable at compile time, and they are initialized upon the start of the thread (or the start of the program for &lt;code&gt;__gshared&lt;/code&gt;). There are no static constructors or static destructors for static local variables.</source>
          <target state="translated">Инициализатор статической переменной должен оцениваться во время компиляции, и они инициализируются при запуске потока (или запуске программы для &lt;code&gt;__gshared&lt;/code&gt; ). Не существует статических конструкторов или статических деструкторов для статических локальных переменных.</target>
        </trans-unit>
        <trans-unit id="56398784568892251b9dcc7b9a121fdad0fc1209" translate="yes" xml:space="preserve">
          <source>The inout forms a wildcard that stands in for any of mutable, const, immutable, inout, or inout const. When the function is called, the inout of the return type is changed to whatever the mutable, const, immutable, inout, or inout const status of the argument type to the parameter inout was.</source>
          <target state="translated">Inout образует подстановочный символ,обозначающий любую из изменчивых,неизменчивых,не изменчивых или не изменчивых констант.При вызове функции входящий тип возвращаемого параметра изменяется на любой из состояний mutable,const,immutable,inout или inout const типа аргумента,который был в параметре inout.</target>
        </trans-unit>
        <trans-unit id="47e39fe3c6321bc48452728017762afb10e65931" translate="yes" xml:space="preserve">
          <source>The inout in the return type is then rewritten to be the inout matched qualifiers:</source>
          <target state="translated">Затем тип возвращаемого входа переписывается как соответствующий входу квалификатор:</target>
        </trans-unit>
        <trans-unit id="894e5ecc4ff73411cc66384f9e949e3263a04d5e" translate="yes" xml:space="preserve">
          <source>The input data is too long (There's no guarantee the first part of the data is valid)</source>
          <target state="translated">Входные данные слишком длинные (Нет гарантии,что первая часть данных действительна).</target>
        </trans-unit>
        <trans-unit id="37721cea9b7ff856cc5a0d72da55bfcef8342f2c" translate="yes" xml:space="preserve">
          <source>The input elements. If there are less elements than the specified length of the static array, the rest of it is default-initialized. If there are more than specified, the first elements up to the specified length are used.</source>
          <target state="translated">Входные элементы.Если элементов меньше заданной длины статического массива,то остальная его часть по умолчанию инициализируется.Если их больше указанной длины,используются первые элементы до указанной длины.</target>
        </trans-unit>
        <trans-unit id="4b42c37fa56b476654b6a22d064c38aab28dcdfc" translate="yes" xml:space="preserve">
          <source>The input is returned.</source>
          <target state="translated">Вход возвращается.</target>
        </trans-unit>
        <trans-unit id="fb78206bd59b576b51359aab6e37d1fe64780809" translate="yes" xml:space="preserve">
          <source>The input may have originated from &lt;code&gt;U[]&lt;/code&gt; or &lt;code&gt;immutable(U)[]&lt;/code&gt;, so it may be actually shared or not. Returning an unqualified affix may result in race conditions, whereas returning a &lt;code&gt;shared&lt;/code&gt; affix may result in inadvertent sharing of mutable thread-local data across multiple threads. So the returned type is conservatively &lt;code&gt;ref const&lt;/code&gt;.</source>
          <target state="translated">Входные данные могли быть получены из &lt;code&gt;U[]&lt;/code&gt; или &lt;code&gt;immutable(U)[]&lt;/code&gt; , поэтому они могут быть фактически общими или нет. Возврат неквалифицированного аффикса может привести к условиям состязания, тогда как возврат &lt;code&gt;shared&lt;/code&gt; аффикса может привести к непреднамеренному совместному использованию изменяемых локальных данных потока между несколькими потоками. Таким образом, возвращаемый тип является консервативным &lt;code&gt;ref const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab7802e78bae021ec9f77bb19cdbefc46c138fde" translate="yes" xml:space="preserve">
          <source>The input range being passed through.</source>
          <target state="translated">Диапазон входного сигнала,через который проходит.</target>
        </trans-unit>
        <trans-unit id="c0225247a221452c012002a0bc4a76423e77fd6b" translate="yes" xml:space="preserve">
          <source>The input range must not be empty.</source>
          <target state="translated">Диапазон ввода не должен быть пустым.</target>
        </trans-unit>
        <trans-unit id="786f6ba29b51fa6818ec422c83e424f885e18b3d" translate="yes" xml:space="preserve">
          <source>The input range set up to parse one line at a time into a record tuple.</source>
          <target state="translated">Диапазон входных данных настроен на разбиение одной строки за раз на кортеж записи.</target>
        </trans-unit>
        <trans-unit id="4c83aa414329fad18718e6fa488a3b442df22d1b" translate="yes" xml:space="preserve">
          <source>The input range to check.</source>
          <target state="translated">Диапазон ввода для проверки.</target>
        </trans-unit>
        <trans-unit id="4dd476cc824391e088069cbddbb750e2eef61f40" translate="yes" xml:space="preserve">
          <source>The input text string s is formed into a paragraph by breaking it up into a sequence of lines, delineated by \n, such that the number of columns is not exceeded on each line. The last line is terminated with a \n.</source>
          <target state="translated">Входная текстовая строка s формируется в абзац путем разбиения на последовательность строк,очерченную \n,таким образом,чтобы количество столбцов в каждой строке не превышалось.Последняя строка заканчивается на \n.</target>
        </trans-unit>
        <trans-unit id="93424042a1977cf3da75467c8916a2a7eddec8a8" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point.</source>
          <target state="translated">Вход в эту функцию ДОЛЖЕН быть действительной кодовой точкой.</target>
        </trans-unit>
        <trans-unit id="44b890bb7f50ef5e291775cda4bfde289081100b" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point. This is enforced by the function's in-contract.</source>
          <target state="translated">Вход в эту функцию ДОЛЖЕН быть действительной кодовой точкой.Это обеспечивается внутрифункциональным контрактом функции.</target>
        </trans-unit>
        <trans-unit id="c67615e6ffc16592b049d69cbff653f9fe85f2f3" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by DocumentParser's in contract.</source>
          <target state="translated">Вход для этой функции ДОЛЖЕН быть действительным XML.Это обеспечивается контрактом DocumentParser's.</target>
        </trans-unit>
        <trans-unit id="4bb4a25af5340195ef134855f808d1711e956a9a" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by the function's in contract.</source>
          <target state="translated">Вход для этой функции ДОЛЖЕН быть действительным XML.Это обеспечивается функцией в контракте.</target>
        </trans-unit>
        <trans-unit id="323b8c9102f07dbc17e6156b32bdb18e8608c8b5" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded.</source>
          <target state="translated">Вход в эту функцию ДОЛЖЕН быть закодирован.</target>
        </trans-unit>
        <trans-unit id="d4a76f46d20716b9c53fd13981afb49f20693850" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded. This is enforced by the function's in-contract.</source>
          <target state="translated">Вход в эту функцию ДОЛЖЕН быть закодирован.Это обеспечивается внутрифункциональным контрактом функции.</target>
        </trans-unit>
        <trans-unit id="52bc0973d7be9145a7f9c10120f8ee1522aa2643" translate="yes" xml:space="preserve">
          <source>The instantiated template.</source>
          <target state="translated">инстанцированный шаблон.</target>
        </trans-unit>
        <trans-unit id="caa69ad6f2cd188077c7e982e4e11f26b6cdf5a4" translate="yes" xml:space="preserve">
          <source>The integral and floating type sizes should be considered as minimums. Algorithms should be designed to continue to work properly if the type size increases.</source>
          <target state="translated">Интегральный и плавающий типы должны рассматриваться как минимум.Алгоритмы должны быть спроектированы таким образом,чтобы продолжать работать правильно,если размер типа увеличивается.</target>
        </trans-unit>
        <trans-unit id="bfaa650f603081ed06b593e3b4e5c458c3260e28" translate="yes" xml:space="preserve">
          <source>The integral is</source>
          <target state="translated">Неотъемлемой частью является</target>
        </trans-unit>
        <trans-unit id="d07416a83435e11558037f6cda4d47f4d33fe73e" translate="yes" xml:space="preserve">
          <source>The integral is evaluated by a continued fraction expansion or, when b * x is small, by a power series.</source>
          <target state="translated">Интеграл оценивается продолжающимся дробным расширением или,когда b*x мал,последовательностью мощности.</target>
        </trans-unit>
        <trans-unit id="4502af3e801c133bfaf7193afbee4f48610ef881" translate="yes" xml:space="preserve">
          <source>The integral type to convert the first &lt;code&gt;T.sizeof&lt;/code&gt; bytes to.</source>
          <target state="translated">&lt;code&gt;T.sizeof&lt;/code&gt; тип для преобразования первых байтов T.sizeof в.</target>
        </trans-unit>
        <trans-unit id="51127e20341aada7d08b3905487eaefce7dd284a" translate="yes" xml:space="preserve">
          <source>The integral value to return the absolute value of.</source>
          <target state="translated">Интегральное значение для возврата абсолютного значения.</target>
        </trans-unit>
        <trans-unit id="54f14afee26358f556f656a70b82a5a8901a5411" translate="yes" xml:space="preserve">
          <source>The intent of this function is to provide an allocation-less way to call a C function using a D slice. The function internally allocates a buffer if needed, but frees it on exit.</source>
          <target state="translated">Целью этой функции является предоставление способа вызова функции C без распределения с использованием среза D.Функция внутренне выделяет буфер при необходимости,но освобождает его при выходе.</target>
        </trans-unit>
        <trans-unit id="aa32bace5214cedb20ff140ded35da64a7980bf0" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opDollar!i&lt;/code&gt; should return the length of the array along its &lt;code&gt;i&lt;/code&gt;'th dimension, or a user-defined object representing the end of the array along that dimension, that is understood by &lt;code&gt;opSlice&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">Предполагается, что &lt;code&gt;opDollar!i&lt;/code&gt; должен возвращать длину массива по его &lt;code&gt;i&lt;/code&gt; -му измерению или определенный пользователем объект, представляющий конец массива по этому измерению, что понимается &lt;code&gt;opSlice&lt;/code&gt; и &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ed569bfceb9bac4ccf7954c87c2cc7395c8f770" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opSlice!i&lt;/code&gt; should return a user-defined object that represents an interval of indices along the &lt;code&gt;i&lt;/code&gt;'th dimension of the array. This object is then passed to &lt;code&gt;opIndex&lt;/code&gt; to perform the actual slicing operation. If only one-dimensional slicing is desired, &lt;code&gt;opSlice&lt;/code&gt; may be declared without the compile-time parameter &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Предполагается, что &lt;code&gt;opSlice!i&lt;/code&gt; должен вернуть определенный пользователем объект, который представляет интервал индексов по &lt;code&gt;i&lt;/code&gt; -му измерению массива. Этот объект затем передается в &lt;code&gt;opIndex&lt;/code&gt; для выполнения фактической операции среза. Если требуется только одномерное срезание, &lt;code&gt;opSlice&lt;/code&gt; может быть объявлен без параметра времени компиляции &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6066b8690ba4fa47007edd6d83a6b71547ae35" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism defined above (back up to a comment remarkably similar to this one) is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">Интерфейс к механизму виртуального стола,описанному выше (до комментария,удивительно похожего на этот),в настоящее время считается экспериментальным.Интерфейс может измениться несовместимыми способами.Если для вас это проблема,не используйте этот интерфейс в данный момент.</target>
        </trans-unit>
        <trans-unit id="6250bca0465ce111dcc80945b2149f4168412958" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">В настоящее время интерфейс к механизму виртуального стола считается экспериментальным.Интерфейс может измениться несовместимыми способами.Если для вас это проблема,не используйте этот интерфейс в данный момент.</target>
        </trans-unit>
        <trans-unit id="8d2e293904f5395fe014c79325ed5dca620f1643" translate="yes" xml:space="preserve">
          <source>The interface to this is found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc/gcinterface.d&lt;/a&gt;.</source>
          <target state="translated">Интерфейс для этого находится в Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc / gcinterface.d&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70ba1bd45dceaea5f1daa9192d952a7efda4639e" translate="yes" xml:space="preserve">
          <source>The interval that this &lt;code&gt;IntervalRange&lt;/code&gt; currently covers.</source>
          <target state="translated">Интервал, который этот &lt;code&gt;IntervalRange&lt;/code&gt; в настоящее время покрывает.</target>
        </trans-unit>
        <trans-unit id="b1b8b6efa0b6085f29ca02a503001474bd874de3" translate="yes" xml:space="preserve">
          <source>The interval that this range currently covers.</source>
          <target state="translated">Интервал,который в настоящее время охватывает этот диапазон.</target>
        </trans-unit>
        <trans-unit id="99ed0102a151474509c2f50c80c6a8fd9abde664" translate="yes" xml:space="preserve">
          <source>The interval to check against this interval.</source>
          <target state="translated">Интервал для проверки по этому интервалу.</target>
        </trans-unit>
        <trans-unit id="e9709ec7167a6294d35ca54cb0db7b761b6bd4bb" translate="yes" xml:space="preserve">
          <source>The interval to check for against this interval.</source>
          <target state="translated">Интервал для проверки по этому интервалу.</target>
        </trans-unit>
        <trans-unit id="c93a05b54bf8db01ca44894e1b6574520f0f25cd" translate="yes" xml:space="preserve">
          <source>The interval to check for inclusion in this interval.</source>
          <target state="translated">Интервал для проверки включения в этот интервал.</target>
        </trans-unit>
        <trans-unit id="7af5c560175f78550b8fa16520f8bceb2478bd1e" translate="yes" xml:space="preserve">
          <source>The interval to check for intersection with this interval.</source>
          <target state="translated">Интервал для проверки пересечения с этим интервалом.</target>
        </trans-unit>
        <trans-unit id="758e2e8521e78873ca075d9d09978b3e79b23a85" translate="yes" xml:space="preserve">
          <source>The interval to check whether its adjecent to this interval.</source>
          <target state="translated">Интервал,чтобы проверить,является ли его адъюнкт к этому интервалу.</target>
        </trans-unit>
        <trans-unit id="ec8c525abec811d6fafbe3af351dcf7c933228a1" translate="yes" xml:space="preserve">
          <source>The interval to create a span together with this interval.</source>
          <target state="translated">Интервал для создания пролета вместе с этим интервалом.</target>
        </trans-unit>
        <trans-unit id="ffa8edd7fe1af9b169dddd595e3c77f03e44244d" translate="yes" xml:space="preserve">
          <source>The interval to intersect with this interval.</source>
          <target state="translated">Интервал для пересечения с этим интервалом.</target>
        </trans-unit>
        <trans-unit id="450cf7fb1673450b11d1c6b4254176a2488c262a" translate="yes" xml:space="preserve">
          <source>The interval to merge with this interval.</source>
          <target state="translated">Интервал для слияния с этим интервалом.</target>
        </trans-unit>
        <trans-unit id="6dd87bff580699a73195a62f3312346bd1ffd61d" translate="yes" xml:space="preserve">
          <source>The invariant can be checked with an &lt;code&gt;assert()&lt;/code&gt; expression:</source>
          <target state="translated">Инвариант можно проверить с помощью выражения &lt;code&gt;assert()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3d1bc4f7a43b5f2dfbf63c4d45e4f9ad2787305a" translate="yes" xml:space="preserve">
          <source>The invariant is a contract saying that the &lt;code&gt;assert&lt;/code&gt;s must hold true. The invariant is checked when a class or struct constructor completes, and at the start of the class or struct destructor. For public or exported functions, the order of execution is:</source>
          <target state="translated">Инвариант - это контракт, в котором говорится, что &lt;code&gt;assert&lt;/code&gt; должны выполняться. Инвариант проверяется, когда конструктор класса или структуры завершается, и в начале деструктора класса или структуры. Для открытых или экспортированных функций порядок выполнения:</target>
        </trans-unit>
        <trans-unit id="db3237f4b413cd2d050f8846cd6a9cf6b11b5b9b" translate="yes" xml:space="preserve">
          <source>The invariant is in the form of a &lt;code&gt;const&lt;/code&gt; member function. The invariant is defined to</source>
          <target state="translated">Инвариант находится в форме &lt;code&gt;const&lt;/code&gt; функции-члена. Инвариант определен для</target>
        </trans-unit>
        <trans-unit id="4013ec9a85db3fcab85de75b73cedbcdfe5398d3" translate="yes" xml:space="preserve">
          <source>The invariant is not checked if the class or struct is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">Инвариант не проверяется, если класс или структура неявно &lt;code&gt;.init&lt;/code&gt; с использованием значения .init по умолчанию .</target>
        </trans-unit>
        <trans-unit id="b006ea59664dde8c9966b0ba37f0d9de49867d7b" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the class instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">Инвариант не обязательно должен храниться, если экземпляр класса неявно &lt;code&gt;.init&lt;/code&gt; с использованием значения .init по умолчанию .</target>
        </trans-unit>
        <trans-unit id="90d62a6c20b7727a896f3c7231e895bd333ec112" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the struct instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">Инвариант не обязательно должен храниться, если экземпляр структуры неявно &lt;code&gt;.init&lt;/code&gt; с использованием значения .init по умолчанию .</target>
        </trans-unit>
        <trans-unit id="ae2f7e963cff5e59d45cd356ad6b537b6f9c2bbf" translate="yes" xml:space="preserve">
          <source>The isMarked callback function.</source>
          <target state="translated">Функция обратного вызова помечена.</target>
        </trans-unit>
        <trans-unit id="b53b0d99e692dbe7d750a9e3a8ec485970e1fe1a" translate="yes" xml:space="preserve">
          <source>The issue remains of calling &lt;code&gt;a.deallocate(b)&lt;/code&gt; from a different thread than the one that allocated &lt;code&gt;b&lt;/code&gt;. It follows that both threads must have access to the same instance &lt;code&gt;a&lt;/code&gt; of the respective allocator type. By definition of D, this is possible only if &lt;code&gt;a&lt;/code&gt; has the &lt;code&gt;shared&lt;/code&gt; qualifier. It follows that the allocator type must implement &lt;code&gt;allocate&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; as &lt;code&gt;shared&lt;/code&gt; methods. That way, the allocator commits to allowing usable &lt;code&gt;shared&lt;/code&gt; instances.</source>
          <target state="translated">Остается проблема вызова &lt;code&gt;a.deallocate(b)&lt;/code&gt; из потока, отличного от того, который выделил &lt;code&gt;b&lt;/code&gt; . Из этого следует , что оба поток должен иметь доступ к одному экземпляру &lt;code&gt;a&lt;/code&gt; соответствующий типа распределителя. По определению D это возможно, только если &lt;code&gt;a&lt;/code&gt; имеет &lt;code&gt;shared&lt;/code&gt; квалификатор. Отсюда следует, что тип распределителя должен реализовывать &lt;code&gt;allocate&lt;/code&gt; и &lt;code&gt;deallocate&lt;/code&gt; качестве &lt;code&gt;shared&lt;/code&gt; методов. Таким образом, распределитель обязуется разрешить использование &lt;code&gt;shared&lt;/code&gt; экземпляров.</target>
        </trans-unit>
        <trans-unit id="f906deb3cb569875f4c530161fd80e93b9be746c" translate="yes" xml:space="preserve">
          <source>The key is the IANA time zone database name, and the value is a list of Windows time zone names which are close (usually only one, but it could be multiple).</source>
          <target state="translated">Ключом является имя базы данных часового пояса IANA,а значением-список близких часовых поясов Windows (обычно только один,но может быть и несколько).</target>
        </trans-unit>
        <trans-unit id="0cdd5bd88b6b5b8af271fba7af0cd3f24ac411a0" translate="yes" xml:space="preserve">
          <source>The key is the Windows time zone name, and the value is a list of IANA TZ database names which are close (currently only ever one, but it allows for multiple in case it's ever necessary).</source>
          <target state="translated">Ключом является имя часового пояса Windows,а значением-список близких к нему имен базы данных IANA TZ (в настоящее время это только одно,но позволяет использовать несколько,если в этом возникнет необходимость).</target>
        </trans-unit>
        <trans-unit id="07021616652b4190834cc6f5cd3d6a99828ab34d" translate="yes" xml:space="preserve">
          <source>The key.</source>
          <target state="translated">Ключ.</target>
        </trans-unit>
        <trans-unit id="a80046e2f9e469e161e9b64d7a84ab6bec7ee185" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;do&lt;/code&gt; can be used to announce the function body. Although any number of pre or post contracts of any form may follow each other, &lt;code&gt;do&lt;/code&gt; is required only when the last contract before the body is a block statement. (Before the acceptance of &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003&lt;/a&gt;, the keyword &lt;code&gt;body&lt;/code&gt; was required instead of &lt;code&gt;do&lt;/code&gt;, and may still be encountered in old code bases. In the long term, &lt;code&gt;body&lt;/code&gt; may be deprecated, but for now it's allowed both as a keyword in this context and as an identifier elsewhere, although &lt;code&gt;do&lt;/code&gt; is preferred.)</source>
          <target state="translated">Ключевое слово &lt;code&gt;do&lt;/code&gt; может использоваться для объявления тела функции. Хотя любое количество до или после контрактов любой формы может следовать друг за другом, &lt;code&gt;do&lt;/code&gt; требуется, только если последний контракт перед телом является оператором блока. (До принятия &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003 &lt;/a&gt; &lt;code&gt;body&lt;/code&gt; ключевого слова требовалось вместо &lt;code&gt;do&lt;/code&gt; и могло встречаться в старых базах кода. В долгосрочной перспективе &lt;code&gt;body&lt;/code&gt; может быть объявлено устаревшим, но на данный момент оно разрешено как ключевое слово в этом контексте, так и как идентификатор в другом месте, хотя &lt;code&gt;do&lt;/code&gt; это предпочтительнее.)</target>
        </trans-unit>
        <trans-unit id="d0cf199fa5ede60a30e00df7068d936c5578eb01" translate="yes" xml:space="preserve">
          <source>The kind of pragma it is determined by the</source>
          <target state="translated">Вид прагмы,который определяется</target>
        </trans-unit>
        <trans-unit id="8c29b92f234fc529a35e51b203804649a01ac419" translate="yes" xml:space="preserve">
          <source>The lambda function arguments must not have a template instantiation as an explicit argument type. Any other argument types (basic, user-defined, template) are supported.</source>
          <target state="translated">Аргументы лямбда-функции не должны иметь инстанцирование шаблона в качестве явного типа аргумента.Поддерживаются любые другие типы аргументов (базовый,пользовательский,шаблон).</target>
        </trans-unit>
        <trans-unit id="bdcf91e0f4f606e17a112c301f88ad8c5b2c10fe" translate="yes" xml:space="preserve">
          <source>The lambda function body must contain a single expression (no return statement) which contains only numeric values, manifest constants, enum values, function arguments and function calls. If the expression contains local variables or return statements, the function is considered incomparable.</source>
          <target state="translated">Тело лямбда-функции должно содержать единственное выражение (без возвратного оператора),которое содержит только числовые значения,явные константы,значения перечислений,аргументы функции и вызовы функций.Если выражение содержит локальные переменные или операторы возврата,то функция считается несопоставимой.</target>
        </trans-unit>
        <trans-unit id="95be9f6bb557ebac60c617f8309a121bd86960bc" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">Последний день месяца, в котором находится эта &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a278dbcde6702c093900cb5053e8bf5709be9d8" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">Последний день месяца, в котором находится этот &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49136c9e4ea103b38fd972475d00bbb19f727989" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">Последний день месяца, в &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; находится этот SysTime .</target>
        </trans-unit>
        <trans-unit id="a7a9289af76d268aef34222393a4318b6b13e368" translate="yes" xml:space="preserve">
          <source>The last element in the container</source>
          <target state="translated">Последний элемент в контейнере</target>
        </trans-unit>
        <trans-unit id="6a4a00d2337afbe6c2df52717b98e8e13215bd50" translate="yes" xml:space="preserve">
          <source>The last element of the array.</source>
          <target state="translated">Последний элемент массива.</target>
        </trans-unit>
        <trans-unit id="9093baea1e3cf86fea0c4e3a6b9e58ab2a97f5a2" translate="yes" xml:space="preserve">
          <source>The last modification time in DosFileFormat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc0ac79d31e7752c2d29a6d8b9bf43609b17c83" translate="yes" xml:space="preserve">
          <source>The last parameter is passed in EAX rather than being pushed on the stack if the following conditions are met:</source>
          <target state="translated">Последний параметр передается в EAX,а не выталкивается на стек при выполнении следующих условий:</target>
        </trans-unit>
        <trans-unit id="746b4bdff136b3fa913bf1eeb63d7355bf56ba56" translate="yes" xml:space="preserve">
          <source>The last template parameter if it's a &lt;code&gt;TemplateTupleParameter&lt;/code&gt;</source>
          <target state="translated">Последний параметр шаблона, если это &lt;code&gt;TemplateTupleParameter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81aad1de98ee0f65f497fb989a25778e1871d9df" translate="yes" xml:space="preserve">
          <source>The lazy initializer value</source>
          <target state="translated">Ленивое значение инициализатора</target>
        </trans-unit>
        <trans-unit id="ea4b5c8a99ea43d9dec4f2b203a2486705eaedf1" translate="yes" xml:space="preserve">
          <source>The lazy variadic delegate solution is preferable to using a lazy variadic array, because each array index would evaluate every element:</source>
          <target state="translated">Ленивый вариадический делегат предпочтительнее использовать ленивый вариадический массив,так как каждый индекс массива будет оценивать каждый элемент:</target>
        </trans-unit>
        <trans-unit id="421c4166a84b43c53a129a72090df266fc5436fb" translate="yes" xml:space="preserve">
          <source>The least significant bit in any &lt;code&gt;size_t&lt;/code&gt; unit is the starting bit of this unit, and the most significant bit is the last bit of this unit. Therefore, passing e.g. an array of &lt;code&gt;int&lt;/code&gt;s may result in a different &lt;code&gt;BitArray&lt;/code&gt; depending on the processor's endianness.</source>
          <target state="translated">Младший значащий бит в любом блоке &lt;code&gt;size_t&lt;/code&gt; является начальным битом этого блока, а самый младший бит - последний бит этого блока. Следовательно, передача, например, массива &lt;code&gt;int&lt;/code&gt; s, может привести к другому &lt;code&gt;BitArray&lt;/code&gt; в зависимости от порядкового номера процессора.</target>
        </trans-unit>
        <trans-unit id="eeb9274b7abe5ec5313e249b7496b6be61a66b8b" translate="yes" xml:space="preserve">
          <source>The left operand of the &lt;code&gt;,&lt;/code&gt; is evaluated, then the right operand is evaluated. The type of the expression is the type of the right operand, and the result is the result of the right operand. Using the result of comma expressions isn't allowed.</source>
          <target state="translated">Левый операнд из &lt;code&gt;,&lt;/code&gt; вычисляется, то правый операнд. Тип выражения - это тип правого операнда, а результат - результат правого операнда. Использование результатов запятых выражений не допускается.</target>
        </trans-unit>
        <trans-unit id="f0716ee491b6b3f2e07375f7797e5c102ad33bdc" translate="yes" xml:space="preserve">
          <source>The left-hand side (or sole) argument</source>
          <target state="translated">Левый (или единственный)аргумент...</target>
        </trans-unit>
        <trans-unit id="4d310cf569bfdf7161ed54cffc976e1b48e7851c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">Левая часть сравнения ( &lt;code&gt;Lhs&lt;/code&gt; - первый аргумент для &lt;code&gt;Checked&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="204d5f370e11576f0fecb8929fdcdb88b117af5c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;T&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">Левая часть сравнения ( &lt;code&gt;T&lt;/code&gt; - первый аргумент для &lt;code&gt;Checked&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4fefd353c917f9a3bb60b52cf3d51cddee41a3f3" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for equality</source>
          <target state="translated">Левая сторона сравнения для равенства</target>
        </trans-unit>
        <trans-unit id="2b109cf29bece1affa9b23e640454252b8ecd16d" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for ordering</source>
          <target state="translated">Левая сторона сравнения для заказа</target>
        </trans-unit>
        <trans-unit id="ae7fc7c90c99a250cd16f28bd7d7dbc3b81e86a8" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator</source>
          <target state="translated">Левая сторона оператора</target>
        </trans-unit>
        <trans-unit id="b4517c6bf6d758579387be92cded7d53dd545722" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">Левая часть оператора ( &lt;code&gt;Lhs&lt;/code&gt; - первый аргумент для &lt;code&gt;Checked&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1d155e4a7561179c70fb7012ae70744e878991c7" translate="yes" xml:space="preserve">
          <source>The left-hand side operand</source>
          <target state="translated">Левый операнд</target>
        </trans-unit>
        <trans-unit id="56ecf39f32678f6ba12fdb543c053bc2a2538cfe" translate="yes" xml:space="preserve">
          <source>The left-hand side operand (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">Левый операнд ( &lt;code&gt;Lhs&lt;/code&gt; - первый аргумент для &lt;code&gt;Checked&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fdc93a0d76b637886498906e463f3074234e7249" translate="yes" xml:space="preserve">
          <source>The leftmost side of the inheritance graph of the interfaces all share their vptrs, this is the single inheritance model. Every time the inheritance graph forks (for multiple inheritance) a new vptr is created and stored in the class' instance. Every time a virtual method is overridden, a new vtbl[] must be created with the updated method pointers in it.</source>
          <target state="translated">В левой части графика наследования интерфейсов все разделяют свои vptrs,это единая модель наследования.Каждый раз,когда граф наследования развивает (для множественного наследования)новый vptr создаётся и хранится в экземпляре класса.Каждый раз при переопределении виртуального метода необходимо создавать новый vtbl[]с обновленными указателями на метод.</target>
        </trans-unit>
        <trans-unit id="f8ab85ff43a9b405f7f858dd6bd44661050bcbfb" translate="yes" xml:space="preserve">
          <source>The leftover portion of &lt;code&gt;tgt&lt;/code&gt; after all elements from &lt;code&gt;src&lt;/code&gt; have been moved.</source>
          <target state="translated">&lt;code&gt;tgt&lt;/code&gt; часть tgt после того, как все элементы из &lt;code&gt;src&lt;/code&gt; были перемещены.</target>
        </trans-unit>
        <trans-unit id="ff1f6ec0205e886692fcbf4cdbd24c49883d76fd" translate="yes" xml:space="preserve">
          <source>The leftover portions of the two ranges after one or the other of the ranges have been exhausted.</source>
          <target state="translated">Оставшиеся части двух диапазонов после того,как один или другой из них исчерпан.</target>
        </trans-unit>
        <trans-unit id="4aa5bf288555be6562c9b8eb71a2ee00b9edbaea" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">Допустимые типы арифметики для &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; с использованием этого оператора:</target>
        </trans-unit>
        <trans-unit id="06d117fb1568b3c185b1dd70cf5e4111bec8c49d" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">Допустимые типы арифметики для &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; с использованием этого оператора:</target>
        </trans-unit>
        <trans-unit id="31c5da3679aa5d6d97a971e899c7a8329e3f0d92" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; типы арифметики для SysTime с использованием этого оператора:</target>
        </trans-unit>
        <trans-unit id="1d00a55c762fc066020331efbb630b4cfc23721c" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; типы арифметики для TimeOfDay с использованием этого оператора:</target>
        </trans-unit>
        <trans-unit id="e029991ebf163a2ec03f499fc47cd21941b26f69" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator are</source>
          <target state="translated">Допустимые типы арифметики для &lt;code&gt;Duration&lt;/code&gt; с использованием этого оператора:</target>
        </trans-unit>
        <trans-unit id="2131ddc8b843bbfb7a2f56781e6183f4a90599d7" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">Допустимые типы арифметики для &lt;code&gt;Duration&lt;/code&gt; , использующие эту перегрузку оператора:</target>
        </trans-unit>
        <trans-unit id="5584f88d5b275ee008fabf19cf9bf9477c6ef1e2" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator are</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; типы арифметики для TickDuration с использованием этого оператора:</target>
        </trans-unit>
        <trans-unit id="c5479006c238183b17f8e4535d66092bdb92a1fe" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; типы арифметики для TickDuration, использующие эту перегрузку оператора:</target>
        </trans-unit>
        <trans-unit id="0bd23cc00d282f158f381c5c9ffe519dc3f30f3b" translate="yes" xml:space="preserve">
          <source>The length dimension(s) of the resulting array</source>
          <target state="translated">Измерение(и)длины результирующего массива</target>
        </trans-unit>
        <trans-unit id="44d89bfdd05d1a58a582eeedae0d9a14e3912d91" translate="yes" xml:space="preserve">
          <source>The length of a Base64 encoding of an array of the given length.</source>
          <target state="translated">Длина массива в Base64-кодировке заданной длины.</target>
        </trans-unit>
        <trans-unit id="a5db64910ec8c3458fc1370fda6dd6afe4df6242" translate="yes" xml:space="preserve">
          <source>The length of the Base64 encoding.</source>
          <target state="translated">Длина кодировки Base64.</target>
        </trans-unit>
        <trans-unit id="a6c0235529e0d9db5d811993877bcc8428ae8800" translate="yes" xml:space="preserve">
          <source>The length of the decoded string corresponding to a Base64 encoding of length sourceLength.</source>
          <target state="translated">Длина декодированной строки,соответствующая Base64-кодировке длины sourceLength.</target>
        </trans-unit>
        <trans-unit id="11a141a49e0a68aaa17cb7bd6222ca0a80676913" translate="yes" xml:space="preserve">
          <source>The length of the initial segment of &lt;code&gt;r&lt;/code&gt; to sort.</source>
          <target state="translated">Длина начального сегмента &lt;code&gt;r&lt;/code&gt; для сортировки.</target>
        </trans-unit>
        <trans-unit id="79633e883a28c37fc7cd1efc3c868307222fbc17" translate="yes" xml:space="preserve">
          <source>The length of the resulting range is the sum of all lengths of the ranges passed as input. This means that all elements (duplicates included) are transferred to the resulting range.</source>
          <target state="translated">Длина результирующего диапазона представляет собой сумму всех длин диапазонов,переданных на вход.Это означает,что все элементы (дубликаты включены)передаются в результирующий диапазон.</target>
        </trans-unit>
        <trans-unit id="e1ae840eb910889a7516866d4d199999a725e819" translate="yes" xml:space="preserve">
          <source>The length of the token is known to be 40 characters long due to its format, so the attacker first sends &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt;, and so on.</source>
          <target state="translated">Известно, что длина токена составляет 40 символов из-за его формата, поэтому злоумышленник сначала отправляет &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt; , затем &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="1987089f20ee0b5d2ec2f8112d140a36df239f5b" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined.</source>
          <target state="translated">Уровень,на котором определяется опция сокета.</target>
        </trans-unit>
        <trans-unit id="b86bd023c662d4e208c258be711aadc0b1b2efae" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined:</source>
          <target state="translated">Уровень,на котором определяется опция сокета:</target>
        </trans-unit>
        <trans-unit id="2ae0654a2a0ebe273a0d01c5f266e55c0eaa1eb7" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of these tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f491d891c138db3f9bceff46473b495e216f49dc" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of those tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner for it. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="translated">Лексический анализ не зависит от синтаксического разбора и семантического анализа.Лексический анализатор разделяет исходный текст на лексемы.Лексическая грамматика описывает синтаксис этих лексем.Грамматика предназначена для высокоскоростного сканирования и облегчения написания правильного сканера.В ней есть минимальное количество правил для особых случаев,и существует только один этап перевода.</target>
        </trans-unit>
        <trans-unit id="64fc62f1647f32635083b06c594d00bb08d6c211" translate="yes" xml:space="preserve">
          <source>The lexical order of the attributes &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; is not significant.</source>
          <target state="translated">Лексический порядок атрибутов &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;scope&lt;/code&gt; не имеет значения.</target>
        </trans-unit>
        <trans-unit id="ecb003b0d2de026222073a3d8a4296c476e97462" translate="yes" xml:space="preserve">
          <source>The lifetime of a Borrowed or Readonly pointer value starts when it is assigned a value from an Owner or another Borrowed pointer, and ends at the last read of that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68c7b698966b101a1a595982c2044cc2a404192" translate="yes" xml:space="preserve">
          <source>The line number information from where the call originates</source>
          <target state="translated">Информация о номере линии,откуда исходит звонок</target>
        </trans-unit>
        <trans-unit id="630ea807f4230ab332463ca98ac961bf9f44e6d5" translate="yes" xml:space="preserve">
          <source>The line number of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">Номер строки исходного кода D,соответствующий тому,откуда была выброшена ошибка.</target>
        </trans-unit>
        <trans-unit id="229e0a2bdd93317a19e4a68e09629b3b6f154aca" translate="yes" xml:space="preserve">
          <source>The line number of the caller.</source>
          <target state="translated">Номер линии вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="0ad55de99f59d99a8ffdf4bac1fdfeed484559cb" translate="yes" xml:space="preserve">
          <source>The line number on which this error occurred.</source>
          <target state="translated">Номер строки,на которой произошла эта ошибка.</target>
        </trans-unit>
        <trans-unit id="b99341808eb5c2aeef537e3bc3ba23e7d2391ae4" translate="yes" xml:space="preserve">
          <source>The line number that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">Номер строки, который &lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; &lt;/a&gt; перечислит, если выброшено.</target>
        </trans-unit>
        <trans-unit id="f269870f6d1360520fe00512e2c2e3c4c0c50b6e" translate="yes" xml:space="preserve">
          <source>The line number where the exception occurred.</source>
          <target state="translated">Номер строки,где произошло исключение.</target>
        </trans-unit>
        <trans-unit id="f737b0208cdb15cf160156fb11b96cdbc64efed4" translate="yes" xml:space="preserve">
          <source>The line terminator (&lt;code&gt;'\n'&lt;/code&gt; by default) is part of the string read (it could be missing in the last line of the file). Several types are supported for &lt;code&gt;line&lt;/code&gt;, and the behavior of &lt;code&gt;lines&lt;/code&gt; changes accordingly:</source>
          <target state="translated">Терминатор строки ( по умолчанию &lt;code&gt;'\n'&lt;/code&gt; ) является частью прочитанной строки (она может отсутствовать в последней строке файла). Для &lt;code&gt;line&lt;/code&gt; поддерживаются несколько типов , и поведение &lt;code&gt;lines&lt;/code&gt; изменяется соответственно:</target>
        </trans-unit>
        <trans-unit id="4223574eefbbf292923ac805daa2d742c2ceff1c" translate="yes" xml:space="preserve">
          <source>The line that was read, including the line terminator character.</source>
          <target state="translated">Строка,которая была прочитана,включая символ терминатора строки.</target>
        </trans-unit>
        <trans-unit id="0c791857d998bbf0bb74dbde8821e8c09defc3d6" translate="yes" xml:space="preserve">
          <source>The line where the error occurred.</source>
          <target state="translated">Строка,в которой произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="5ba806293f71618709ac5ca5570d100d47098201" translate="yes" xml:space="preserve">
          <source>The line where the error occurred. Defaults to &lt;code&gt;__LINE__&lt;/code&gt;.</source>
          <target state="translated">Строка, где произошла ошибка. По умолчанию &lt;code&gt;__LINE__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ec5dcfd170a3e54aa2b0486e8b3a659ecba856" translate="yes" xml:space="preserve">
          <source>The linkage form &lt;code&gt;extern (C++, &lt;/code&gt;</source>
          <target state="translated">Форма связи &lt;code&gt;extern (C++, &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a68509fefd64796f7d1a07f49a259470873e621" translate="yes" xml:space="preserve">
          <source>The linkage is recognized on all platforms but will issue a compile error if it is used on a platform where Objective-C support is not available. This allows to easily hide Objective-C declarations from platforms where it is not available using the &lt;a href=&quot;version#version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; statement, without resorting to string mixins or other workarounds.</source>
          <target state="translated">Связь распознается на всех платформах, но выдает ошибку компиляции, если она используется на платформе, где поддержка Objective-C недоступна. Это позволяет легко скрывать объявления Objective-C от платформ, где они недоступны, с помощью оператора &lt;a href=&quot;version#version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; , не прибегая к строковым смешиваниям или другим обходным путям.</target>
        </trans-unit>
        <trans-unit id="ee2dc34efb622f40653a49dbfe76ceb8d1ee0eff" translate="yes" xml:space="preserve">
          <source>The list of allowed types. If empty, any type is allowed.</source>
          <target state="translated">Список разрешенных типов.Если пусто,то разрешен любой тип.</target>
        </trans-unit>
        <trans-unit id="7d752b3e0c165ac9972ad67362f39567c19601ad" translate="yes" xml:space="preserve">
          <source>The literal may not exceed the range of the type. The literal is rounded to fit into the significant digits of the type.</source>
          <target state="translated">Буквенное обозначение не должно выходить за пределы диапазона типа.Буквальное число округляется до значащих цифр типа.</target>
        </trans-unit>
        <trans-unit id="cfda6f32ee8182b11470321e18429ff54847d85e" translate="yes" xml:space="preserve">
          <source>The local part is in a deprecated form</source>
          <target state="translated">Местная часть находится в устаревшей форме.</target>
        </trans-unit>
        <trans-unit id="6f51eadb663d2759618c2c7f55ed73ce81e81662" translate="yes" xml:space="preserve">
          <source>The local part of the address is too long</source>
          <target state="translated">Локальная часть адреса слишком длинная</target>
        </trans-unit>
        <trans-unit id="d43703ab62f0fdfb0730decc44b9accfe993fc48" translate="yes" xml:space="preserve">
          <source>The local part of the email address, that is, the part before the @ sign.</source>
          <target state="translated">Локальная часть адреса электронной почты,то есть часть перед знаком @.</target>
        </trans-unit>
        <trans-unit id="fb2b16bfeb403dd9d23822ef47a96282d2506733" translate="yes" xml:space="preserve">
          <source>The logger used by the logging function as reference.</source>
          <target state="translated">Регистратор,используемый функцией протоколирования в качестве справочника.</target>
        </trans-unit>
        <trans-unit id="9dc35ce16bcd5e0f3997b30f4a3a933ead8e2be7" translate="yes" xml:space="preserve">
          <source>The long</source>
          <target state="translated">Длинный</target>
        </trans-unit>
        <trans-unit id="cdce859b555eda9a366f161871fcdb633ee5b0eb" translate="yes" xml:space="preserve">
          <source>The long symbol for this option</source>
          <target state="translated">Длинный символ для этой опции</target>
        </trans-unit>
        <trans-unit id="eb826857f96e2fa8c72d4f984e7520701feb3d3d" translate="yes" xml:space="preserve">
          <source>The loop is correctly written:</source>
          <target state="translated">Петля написана правильно:</target>
        </trans-unit>
        <trans-unit id="80cd3f025f71ab9fb6d037c50456d7fb59577d15" translate="yes" xml:space="preserve">
          <source>The lower bound of the clamp.</source>
          <target state="translated">Нижняя граница зажима.</target>
        </trans-unit>
        <trans-unit id="c3ba355fcfd258cdc3b0962e2c92c7fd02aec3ad" translate="yes" xml:space="preserve">
          <source>The macro &quot;##&quot; is ISO C, we assume pre-ISO C doesn't support it.</source>
          <target state="translated">Макрос &quot;##&quot;-это ISO C,мы предполагаем,что пре-ISO C его не поддерживает.</target>
        </trans-unit>
        <trans-unit id="4493cedee574dfabffbc81a40e14a5b6a3a6b77b" translate="yes" xml:space="preserve">
          <source>The macros section follows the same syntax as the &lt;b&gt;Params:&lt;/b&gt; section. It's a series of</source>
          <target state="translated">Секция макросов имеет тот же синтаксис, что и секция &lt;b&gt;Params :&lt;/b&gt; . Это серия</target>
        </trans-unit>
        <trans-unit id="cf6c8468c449f6bacda719f4e15ba7d61861d0e7" translate="yes" xml:space="preserve">
          <source>The magnitude is an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of unsigned integers that satisfies either &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;&lt;code&gt;std.range.primitives.isForwardRange&lt;/code&gt;&lt;/a&gt;. The first (leftmost) element of the magnitude is considered the most significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae8a3b1299a2612db122fcc08bc88452fa0e22f" translate="yes" xml:space="preserve">
          <source>The magnitude of x is limited to about 106.56 for IEEE 80-bit arithmetic; 1 or -1 is returned outside this range.</source>
          <target state="translated">Величина х ограничена примерно 106.56 для 80-разрядной арифметики IEEE;1 или -1 возвращается за пределы этого диапазона.</target>
        </trans-unit>
        <trans-unit id="327523b3c0bae538d6dd857c0b63c542d4c2e3ff" translate="yes" xml:space="preserve">
          <source>The main &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; module provides template-based tools for working with ranges, but sometimes an object-based interface for ranges is needed, such as when runtime polymorphism is required. For this purpose, this submodule provides a number of object and &lt;code&gt;interface&lt;/code&gt; definitions that can be used to wrap around range objects created by the &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; templates.</source>
          <target state="translated">Основной модуль &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; предоставляет инструменты на основе шаблонов для работы с диапазонами, но иногда необходим объектный интерфейс для диапазонов, например, когда требуется полиморфизм во время выполнения. Для этой цели этот подмодуль предоставляет ряд определений объектов и &lt;code&gt;interface&lt;/code&gt; которые можно использовать для обтекания объектов диапазона, созданных шаблонами &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c02f05cd38724c7e8cb17756e9c5152cd9c1060" translate="yes" xml:space="preserve">
          <source>The main entry point for garbage collection. The supplied delegate will be passed ranges representing both stack and register values.</source>
          <target state="translated">Главная точка входа для сбора мусора.Поставляемому делегату будут переданы диапазоны,представляющие как значения штабеля,так и значения регистра.</target>
        </trans-unit>
        <trans-unit id="70a5f20578712db84e71fcdbe8fd245260ba0674" translate="yes" xml:space="preserve">
          <source>The main reasons that a program might need to use ticks directly is if the system clock has higher precision than hnsecs, and the program needs that higher precision, or if the program needs to avoid the rounding errors caused by converting to hnsecs.</source>
          <target state="translated">Основные причины,по которым программе может понадобиться использовать галочки напрямую,это если системные часы имеют более высокую точность,чем hnsecs,и программе нужна эта более высокая точность,или если программе необходимо избежать ошибок округления,вызванных преобразованием в hnsecs.</target>
        </trans-unit>
        <trans-unit id="99346c9361ee044918b5692d75d84b05203809b4" translate="yes" xml:space="preserve">
          <source>The main uses cases for &lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; are:</source>
          <target state="translated">Основные варианты использования &lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37721286eae1f656c81db469ea0c2aa0407bd201" translate="yes" xml:space="preserve">
          <source>The major 32-bit x86 microarchitecture 'dynasties' have been:</source>
          <target state="translated">Основные 32-битные x86 микроархитектурные &quot;династии&quot; были:</target>
        </trans-unit>
        <trans-unit id="982a1e7c4fc73fa370e90c954afb1f355930cd55" translate="yes" xml:space="preserve">
          <source>The managed array.</source>
          <target state="translated">Управляемый массив.</target>
        </trans-unit>
        <trans-unit id="24b3c10fb402cc3696f43a7e032402872866e5ae" translate="yes" xml:space="preserve">
          <source>The mangled name for a function with function pointer type T and the given fully qualified name.</source>
          <target state="translated">Искаженное имя для функции с указателем на функцию типа T и заданным полностью квалифицированным именем.</target>
        </trans-unit>
        <trans-unit id="2222f24e9ff7ad414fdd6df5db1a3a27354c9552" translate="yes" xml:space="preserve">
          <source>The mangled name for a symbols of type T and the given fully qualified name.</source>
          <target state="translated">Искаженное имя для символов типа T и данное полностью квалифицированное имя.</target>
        </trans-unit>
        <trans-unit id="582a49c9af38036e1960cd170f7932701e0fb6f3" translate="yes" xml:space="preserve">
          <source>The mangled name with deduplicated identifiers</source>
          <target state="translated">Искаженное имя с вычитаемыми идентификаторами.</target>
        </trans-unit>
        <trans-unit id="08774dd4c4d75e3bd42a748ee71506481a4f0a1b" translate="yes" xml:space="preserve">
          <source>The mangled string representing the type</source>
          <target state="translated">Искаженная строка,представляющая тип</target>
        </trans-unit>
        <trans-unit id="40a84060f0327e9db3cfd8bbb21dc9782f40397c" translate="yes" xml:space="preserve">
          <source>The manner in which to display the output of each &lt;code&gt;Option.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7ae029a5326a80d32c23d17dde2c45ccbc8321" translate="yes" xml:space="preserve">
          <source>The mapping of package and module identifiers to directory and file names.</source>
          <target state="translated">Отображение идентификаторов пакетов и модулей на имена каталогов и файлов.</target>
        </trans-unit>
        <trans-unit id="43effc8161287353136863e8d2f53a67a4ef703b" translate="yes" xml:space="preserve">
          <source>The max aliases are the largest integral types:</source>
          <target state="translated">Максимальные псевдонимы являются самыми большими интегральными типами:</target>
        </trans-unit>
        <trans-unit id="986ee926972449f806f769e32d7dd4ba24b84874" translate="yes" xml:space="preserve">
          <source>The maximal element of the passed-in range.</source>
          <target state="translated">Максимальный элемент проходного диапазона.</target>
        </trans-unit>
        <trans-unit id="ae723b7ad52bbfa1e17cf08fd49aa1b7abbdc458" translate="yes" xml:space="preserve">
          <source>The maximum allowed nesting level.</source>
          <target state="translated">Максимально допустимый уровень вложенности.</target>
        </trans-unit>
        <trans-unit id="c15b5870b72ff9ade8671f564f3ad47e5d8703b2" translate="yes" xml:space="preserve">
          <source>The maximum guarantee of &lt;code&gt;pure&lt;/code&gt; is called &quot;strong purity&quot;. It can enable optimizations based on the fact that a function is guaranteed to not mutate anything which isn't passed to it. For cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). To that end, a pure function:</source>
          <target state="translated">Максимальная гарантия &lt;code&gt;pure&lt;/code&gt; называется &amp;laquo;сильная чистота&amp;raquo;. Он может включать оптимизацию на основе того факта, что функция гарантированно не изменяет ничего, что ей не передается. В случаях, когда компилятор может гарантировать, что чистая функция не может изменить свои аргументы, он может включить полную функциональную чистоту (то есть гарантию, что функция всегда будет возвращать один и тот же результат для одних и тех же аргументов). Для этого чисто функция:</target>
        </trans-unit>
        <trans-unit id="c855c6313f529356306d651f3e145813bb160323" translate="yes" xml:space="preserve">
          <source>The maximum length of &lt;code&gt;filename&lt;/code&gt; is given by the constant &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt;. (On Windows, this number is defined as the maximum number of UTF-16 code points, and the test will therefore only yield strictly correct results when &lt;code&gt;filename&lt;/code&gt; is a string of &lt;code&gt;wchar&lt;/code&gt;s.)</source>
          <target state="translated">Максимальная длина имени &lt;code&gt;filename&lt;/code&gt; задается константой &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt; . (В Windows это число определяется как максимальное количество кодовых точек UTF-16, и поэтому тест даст только точные результаты, когда &lt;code&gt;filename&lt;/code&gt; является строкой &lt;code&gt;wchar&lt;/code&gt; s.)</target>
        </trans-unit>
        <trans-unit id="05e735a756b3fa2f43497424f8b3020883222ceb" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes of output that should be captured.</source>
          <target state="translated">Максимальное количество байтов вывода,которое должно быть захвачено.</target>
        </trans-unit>
        <trans-unit id="f3e3e4f751fc559f30cd92f8522a3febd435ec99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements the array can store without reallocating memory and invalidating iterators upon insertion.</source>
          <target state="translated">Максимальное количество элементов,которое может храниться в массиве без перераспределения памяти и аннулирования итераторов при вставке.</target>
        </trans-unit>
        <trans-unit id="ff490f34a5e2c376eac774681e1598898ac5391d" translate="yes" xml:space="preserve">
          <source>The maximum number of messages or zero if no limit.</source>
          <target state="translated">Максимальное количество сообщений или ноль,если нет предела.</target>
        </trans-unit>
        <trans-unit id="23ffb3d6838b02986026c5eeb543b889e4e64af2" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in args. The type of the returned value is the type among the passed arguments that is able to store the largest value.</source>
          <target state="translated">Максимум переданных аргументов.Тип возвращаемого значения-это тип среди передаваемых аргументов,способный хранить наибольшее значение.</target>
        </trans-unit>
        <trans-unit id="e3f981b26c63cbef1dde8cf88e0c6fd5a78eba99" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in values. The type of the returned value is the type among the passed arguments that is able to store the largest value. If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt;&lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb2470a27937a3494cee9a54b8062f651c54299" translate="yes" xml:space="preserve">
          <source>The maximum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the maximum valid priority for the scheduling policy of the process.</source>
          <target state="translated">Максимальный приоритет планирования,который может быть установлен для потока.На системах,где определено несколько политик планирования,это значение представляет собой максимальный допустимый приоритет для политики планирования процесса.</target>
        </trans-unit>
        <trans-unit id="f397747108afabbaad398b1bbfbbdd699e4c5ce8" translate="yes" xml:space="preserve">
          <source>The maximum size of the GC buffer to hold the return values</source>
          <target state="translated">Максимальный размер буфера GC для хранения возвращаемых значений</target>
        </trans-unit>
        <trans-unit id="075c481912178c8ac79090ee5b3669c3def2fbb2" translate="yes" xml:space="preserve">
          <source>The maximum value representable is &lt;code&gt;T.max&lt;/code&gt; for signed integrals, &lt;code&gt; T.max - 1&lt;/code&gt; for unsigned integrals. The minimum value representable is &lt;code&gt; T.min + 1&lt;/code&gt; for signed integrals, &lt;code&gt;0&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">Максимальное представимое значение - &lt;code&gt;T.max&lt;/code&gt; для знаковых интегралов, &lt;code&gt; T.max - 1&lt;/code&gt; для беззнаковых интегралов. Минимальное представимое значение составляет &lt;code&gt; T.min + 1&lt;/code&gt; для интегралов со знаком , &lt;code&gt;0&lt;/code&gt; для интегралов без знака.</target>
        </trans-unit>
        <trans-unit id="4957d9a3700ae6f7d93e51da85b7d5a4964d27b2" translate="yes" xml:space="preserve">
          <source>The mean of &lt;code&gt;r&lt;/code&gt; when &lt;code&gt;r&lt;/code&gt; is non-empty.</source>
          <target state="translated">Среднее значение &lt;code&gt;r&lt;/code&gt; , когда &lt;code&gt;r&lt;/code&gt; не пусто.</target>
        </trans-unit>
        <trans-unit id="c587177906e3358831db8b1c6944ffdb24226077" translate="yes" xml:space="preserve">
          <source>The members are completely hidden to the user, and so the only operations on those types are ones that do not require any knowledge of the contents of those types. For example:</source>
          <target state="translated">Члены полностью скрыты для пользователя,и поэтому единственные операции над этими типами-это те,которые не требуют никакого знания содержимого этих типов.Например:</target>
        </trans-unit>
        <trans-unit id="00dd946dd7ec09c0536b1658fc7e8ead520e7c8e" translate="yes" xml:space="preserve">
          <source>The memory is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">Память получается из &lt;code&gt;SmallAllocator&lt;/code&gt; , если &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt; , или &lt;code&gt;LargeAllocator&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="f8c96911fea13cb1c02d9f105c0c295fa2deb239" translate="yes" xml:space="preserve">
          <source>The memory location of different memory blocks is not defined. Ordered comparison (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;) between two pointers is permitted when both pointers point to the same array, or when at least one pointer is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Расположение памяти разных блоков памяти не определено. Упорядоченное сравнение ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; ) между двумя указателями допускается, когда оба указателя указывают на один и тот же массив или когда хотя бы один указатель равен &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe0b84897743c23c53a5e9577a10299a7a7b020c" translate="yes" xml:space="preserve">
          <source>The memory usage of this implementation is guaranteed to be constant in &lt;code&gt;range.length&lt;/code&gt;.</source>
          <target state="translated">Использование памяти в этой реализации гарантируется постоянным в &lt;code&gt;range.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7609ac8f3cf653b1ce0270fa8139880a547a9eea" translate="yes" xml:space="preserve">
          <source>The message for the exception.</source>
          <target state="translated">Сообщение для исключения.</target>
        </trans-unit>
        <trans-unit id="4c338cd37584d6e6e69bd4c24d1ae2acb50b8634" translate="yes" xml:space="preserve">
          <source>The message that was sent.</source>
          <target state="translated">Сообщение,которое было отправлено.</target>
        </trans-unit>
        <trans-unit id="68d612f02557a1940b9b2866c12015c2578745a2" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;AssertError&lt;/code&gt; if the assumption turns out to be false.</source>
          <target state="translated">Сообщение для включения в &lt;code&gt;AssertError&lt;/code&gt; , если предположение оказывается ложным.</target>
        </trans-unit>
        <trans-unit id="488aa84d557c1a01800a687e8f424ca1dc36fdd6" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;ErrnoException&lt;/code&gt; if it is thrown.</source>
          <target state="translated">Сообщение для включения в &lt;code&gt;ErrnoException&lt;/code&gt; , если оно выброшено.</target>
        </trans-unit>
        <trans-unit id="79b8f8765c27119a953cd29d5a9f80179e617637" translate="yes" xml:space="preserve">
          <source>The metaclass of this class.</source>
          <target state="translated">Метакласс этого класса.</target>
        </trans-unit>
        <trans-unit id="93cc36b0067843c6450f0911a4ca8b3ad0ea0493" translate="yes" xml:space="preserve">
          <source>The method used to enable or disable the unit tests. Use of a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt; to enable them is suggested.</source>
          <target state="translated">Метод, используемый для включения или отключения юнит-тестов. &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;Рекомендуется&lt;/b&gt;&lt;/a&gt; использовать параметр компилятора, такой как &lt;b&gt;-unittest,&lt;/b&gt; чтобы включить их.</target>
        </trans-unit>
        <trans-unit id="c6a75cd2237917d2ed85214e205b4f1cf25efd9f" translate="yes" xml:space="preserve">
          <source>The minimal element of the passed-in range.</source>
          <target state="translated">Минимальный элемент проходного диапазона.</target>
        </trans-unit>
        <trans-unit id="ab6714e3fe053113da2960956c8eb82b3e5bbc67" translate="yes" xml:space="preserve">
          <source>The minimal number of edits to transform s into t.  Does not allocate GC memory.</source>
          <target state="translated">Минимальное количество правок для преобразования s в t.Не выделяет ГХ память.</target>
        </trans-unit>
        <trans-unit id="10a4be4f3adcabd3abe79325f2076e9b9a100888" translate="yes" xml:space="preserve">
          <source>The minimum duration the calling thread should be suspended.</source>
          <target state="translated">Минимальная продолжительность вызывающей нити должна быть приостановлена.</target>
        </trans-unit>
        <trans-unit id="28711c27ca983081eb31b72306fa4a118f39be3b" translate="yes" xml:space="preserve">
          <source>The minimum extension size in bytes.</source>
          <target state="translated">Минимальный размер расширения в байтах.</target>
        </trans-unit>
        <trans-unit id="c06ab7e4e215252c3c928d52e3071658c4a68764" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values.</source>
          <target state="translated">Минимум переданных значений.</target>
        </trans-unit>
        <trans-unit id="edffbb1612aecedbb9b2455ef9f7bc186445862c" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values. The type of the returned value is the type among the passed arguments that is able to store the smallest value. If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt;&lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95346b92b5307b71b43fcd27332d111b5c7b81cb" translate="yes" xml:space="preserve">
          <source>The minimum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the minimum valid priority for the scheduling policy of the process.</source>
          <target state="translated">Минимальный приоритет планирования,который может быть установлен для потока.На системах,где определено несколько политик планирования,это значение представляет собой минимальный допустимый приоритет для политики планирования процесса.</target>
        </trans-unit>
        <trans-unit id="91d9db5c5ad3a0f6b05ff83250575799825e9e6d" translate="yes" xml:space="preserve">
          <source>The minimum, respectively maximum element of a range together with the number it occurs in the range.</source>
          <target state="translated">Минимальный,соответственно максимальный элемент диапазона вместе с числом,которое он имеет в диапазоне.</target>
        </trans-unit>
        <trans-unit id="4776ba2a4d44664c280371c94d75db0a68aa7f47" translate="yes" xml:space="preserve">
          <source>The minute portion of the time;</source>
          <target state="translated">Минутная часть времени;</target>
        </trans-unit>
        <trans-unit id="804dde72e3fca52bb6fee9e6c9a891f7a218393e" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">Минута для установки минуты &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd8186f6e2f846fa308524ef0f64113f0d7289dd" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">Минута для установки минуты этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80d86d248f3ac806d407ff7069134427130713b0" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">Минута для установки минуты этого &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de600cb5888514e99355f24b957b0d7134a283a8" translate="yes" xml:space="preserve">
          <source>The mode must be compatible with the mode of the file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204cac3357eeb22cb6ce425410ebf52a7b2c34ef" translate="yes" xml:space="preserve">
          <source>The mode the memory mapped file is opened with.</source>
          <target state="translated">Режим,в котором открывается файл отображения памяти.</target>
        </trans-unit>
        <trans-unit id="973816115210d9c45eb2bc6fdd4a572e4108483e" translate="yes" xml:space="preserve">
          <source>The modified &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for any time on this date (since, the modified Julian day changes at midnight).</source>
          <target state="translated">Измененный &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;юлианский день&lt;/a&gt; для любого времени в эту дату (поскольку измененный юлианский день изменяется в полночь).</target>
        </trans-unit>
        <trans-unit id="860d6be9b0cf54ee441891db4a2fd6202c776fe2" translate="yes" xml:space="preserve">
          <source>The modifier to apply.</source>
          <target state="translated">Модификатор для применения.</target>
        </trans-unit>
        <trans-unit id="124f2941f2e52ecf62ccffc3b7646e3953931e7d" translate="yes" xml:space="preserve">
          <source>The modifiers of the &lt;code&gt;lhsMod&lt;/code&gt; mismatching the ones with the &lt;code&gt;rhsMod&lt;/code&gt; are printed, i.e. lhs(shared) vs. rhs() prints &quot;&lt;code&gt;shared&lt;/code&gt;&quot;, wheras lhs() vs rhs(shared) prints &quot;non-shared&quot;.</source>
          <target state="translated">&lt;code&gt;lhsMod&lt;/code&gt; модификаторы lhsMod, не соответствующие тем, которые используются с &lt;code&gt;rhsMod&lt;/code&gt; , т.е. lhs (shared) против rhs () печатает &amp;laquo; &lt;code&gt;shared&lt;/code&gt; &amp;raquo;, тогда как lhs () vs rhs (shared) печатает &amp;laquo;non-shared&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="95523edab7d804c0b6ab6eed37c8c3cadada1694" translate="yes" xml:space="preserve">
          <source>The module edges as found in the &lt;code&gt;importedModules&lt;/code&gt; member of each ModuleInfo. Generated in sortCtors.</source>
          <target state="translated">Модуль кромок, которые содержатся в &lt;code&gt;importedModules&lt;/code&gt; члена каждого ModuleInfo. Генерируется в sortCtors.</target>
        </trans-unit>
        <trans-unit id="47af20b56ee3955f4fd47d6c7951eb2d036d5a4c" translate="yes" xml:space="preserve">
          <source>The module for this virtual table</source>
          <target state="translated">Модуль для этой виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="cab05c206d3bb715fd01c040c88f5fe361c942e4" translate="yes" xml:space="preserve">
          <source>The modulus</source>
          <target state="translated">Модуль</target>
        </trans-unit>
        <trans-unit id="82131155f810a5f75ba3764eb1563b749deb3cf3" translate="yes" xml:space="preserve">
          <source>The monotonic clock has no relation to wall clock time. Rather, it holds its time as the number of ticks of the clock which have occurred since the clock started (typically when the system booted up). So, to determine how much time has passed between two points in time, one monotonic time is subtracted from the other to determine the number of ticks which occurred between the two points of time, and those ticks are divided by the number of ticks that occur every second (as represented by MonoTime.ticksPerSecond) to get a meaningful duration of time. Normally, MonoTime does these calculations for the programmer, but the &lt;code&gt;ticks&lt;/code&gt; and &lt;code&gt;ticksPerSecond&lt;/code&gt; properties are provided for those who require direct access to the system ticks. The normal way that MonoTime would be used is</source>
          <target state="translated">Монотонные часы не имеют отношения к настенным часам. Скорее, он хранит время как количество тактов часов, которые произошли с момента запуска часов (обычно при загрузке системы). Таким образом, чтобы определить, сколько времени прошло между двумя моментами времени, одно монотонное время вычитается из другого, чтобы определить количество тиков, которые произошли между двумя моментами времени, и эти тики разделены на количество тиков, которые происходят каждую секунду (как представлено MonoTime.ticksPerSecond), чтобы получить значимую продолжительность времени. Обычно MonoTime выполняет эти вычисления для программиста, но свойства &lt;code&gt;ticks&lt;/code&gt; и &lt;code&gt;ticksPerSecond&lt;/code&gt; предоставляются для тех, кому требуется прямой доступ к системным тикам. Обычный способ использования MonoTime:</target>
        </trans-unit>
        <trans-unit id="d74977e8496820ecedeff19e20ade1b05de3e4b6" translate="yes" xml:space="preserve">
          <source>The month of the day to validate (January is 1).</source>
          <target state="translated">Месяц дня проверки (1 января).</target>
        </trans-unit>
        <trans-unit id="6ebaf2163e939c5ad1bf15c5f8dae4f8a043e786" translate="yes" xml:space="preserve">
          <source>The month of the day to validate.</source>
          <target state="translated">Месяц дня для подтверждения.</target>
        </trans-unit>
        <trans-unit id="d4d21752a92d87f995da2fa4e777f8856076f4d2" translate="yes" xml:space="preserve">
          <source>The month of the year to get the number of months to.</source>
          <target state="translated">Месяц года,чтобы получить количество месяцев.</target>
        </trans-unit>
        <trans-unit id="3b03ba6279034200ca13bdea73b6dd032c6515f6" translate="yes" xml:space="preserve">
          <source>The month portion of the date (January is 1).</source>
          <target state="translated">Месячная часть даты (1 января).</target>
        </trans-unit>
        <trans-unit id="e6fd335018a8476e0b61c3352fc0e3562dbfcc53" translate="yes" xml:space="preserve">
          <source>The month that each time point in the range will be in (January is 1).</source>
          <target state="translated">Месяц,в котором каждый момент времени будет находиться в диапазоне (1 января).</target>
        </trans-unit>
        <trans-unit id="3a058535cdaf9aa70980ff68790ecdb70d352df1" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">Месяц, для которого нужно установить месяц этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b85e045063e5ffa8ef021269a9798226e87028d9" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">Месяц, для которого нужно установить месяц &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9daf4d7ebc51fc3e649125b409fa21bb86aa474" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">Месяц, для которого нужно установить месяц &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6b4f0b397f7fd7fb57c763984e8789cb54772a" translate="yes" xml:space="preserve">
          <source>The most basic contract is the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;. An &lt;b&gt;assert&lt;/b&gt; declares an expression that must evaluate to true, with an optional failure string as a second argument:</source>
          <target state="translated">Основным контрактом является &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; . &lt;b&gt;Утверждает&lt;/b&gt; , объявляет выражение , которое должно оценить истинно, с дополнительной строкой отказа в качестве второго аргумента:</target>
        </trans-unit>
        <trans-unit id="8a6bd68f79c5b13e9b7d8eaf7293f850cd2e0e6d" translate="yes" xml:space="preserve">
          <source>The most conservative/general allocation: memory may be shared, deallocated in a different thread, may or may not be resized, and may embed references.</source>
          <target state="translated">Наиболее консервативное/общее распределение:память может совместно использоваться,перераспределяться в другом потоке,может изменяться или не изменяться размер,а также могут встраиваться ссылки.</target>
        </trans-unit>
        <trans-unit id="1f6880935884c96d8b2634bfd6b4fbc9dbe4652c" translate="yes" xml:space="preserve">
          <source>The most interesting case is when gapped matches still participate in the result, but not as strongly as ungapped matches. The result will be a smooth, fine-grained similarity measure between the input strings. This is where values of &lt;code&gt;lambda&lt;/code&gt; between 0 and 1 enter into play: gapped matches are</source>
          <target state="translated">Наиболее интересным является случай, когда в результате все еще участвуют гапсовые матчи, но не так сильно, как матчи без гэпов. Результатом будет плавная, детальная мера подобия между входными строками. Это где значения &lt;code&gt;lambda&lt;/code&gt; между 0 и 1 вступают в игру:</target>
        </trans-unit>
        <trans-unit id="9317ec6cdc50605b3f7ad3a0a9efb80f09d16bb9" translate="yes" xml:space="preserve">
          <source>The mutex associated with this condition.</source>
          <target state="translated">Мьютекс,связанный с этим состоянием.</target>
        </trans-unit>
        <trans-unit id="8402314bcd0aba6dacdd48ffde4057ad88f89bec" translate="yes" xml:space="preserve">
          <source>The mutex module provides a primitive for maintaining mutually exclusive access.</source>
          <target state="translated">Модуль mutex предоставляет примитив для поддержания взаимоисключающего доступа.</target>
        </trans-unit>
        <trans-unit id="437cb228e7e76ab9ff7feb1b0fb4ca0971be7ae2" translate="yes" xml:space="preserve">
          <source>The mutex with which this condition will be associated.</source>
          <target state="translated">Мьютекс,с которым это условие будет связано.</target>
        </trans-unit>
        <trans-unit id="4d5ce17987e89e660e90474cca14f7f4718221ad" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;string&lt;/code&gt; is aliased to &lt;code&gt;immutable(char)[]&lt;/code&gt;, so the above declarations could be equivalently written as:</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; имени имеет псевдоним &lt;code&gt;immutable(char)[]&lt;/code&gt; , поэтому приведенные выше объявления могут быть эквивалентно записаны в виде:</target>
        </trans-unit>
        <trans-unit id="abdfc7dd54ebeb228e02bc4ac46894950c3ebbee" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class::WhiteHole&lt;/a&gt; Perl module by Michael G Schwern.</source>
          <target state="translated">Название происходит от Perl-модуля &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class :: WhiteHole&lt;/a&gt; Майкла Г. Шверна.</target>
        </trans-unit>
        <trans-unit id="173aa229bfebb13b14fcecd5dd6654d108541499" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class::BlackHole&lt;/a&gt; Perl module by Sean M. Burke.</source>
          <target state="translated">Название происходит от &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;модуля&lt;/a&gt; Perl Class :: BlackHole от Шона М. Бёрка.</target>
        </trans-unit>
        <trans-unit id="ba677412cf6055cfe046fa4f2b82702d23be25af" translate="yes" xml:space="preserve">
          <source>The name if the &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">Имя, если &lt;code&gt;Logger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2072d20b70963efec270cc1f87503a1f3984cd8" translate="yes" xml:space="preserve">
          <source>The name last used to initialize this this file, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef45a06b2c7cb94d26e3df83157cd1f979d10e1a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to insert.</source>
          <target state="translated">Имя &lt;code&gt;Logger&lt;/code&gt; для вставки.</target>
        </trans-unit>
        <trans-unit id="dd55ce2538ac752361cbfd21c951f733e9d094b0" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to remove. If the &lt;code&gt;Logger&lt;/code&gt; is not found &lt;code&gt;null&lt;/code&gt; will be returned. Only the first occurrence of a &lt;code&gt;Logger&lt;/code&gt; with the given name will be removed.</source>
          <target state="translated">Имя &lt;code&gt;Logger&lt;/code&gt; для удаления. Если &lt;code&gt;Logger&lt;/code&gt; не найден &lt;code&gt;null&lt;/code&gt; будет возвращен. Только первое вхождение &lt;code&gt;Logger&lt;/code&gt; с указанным именем будет удалено.</target>
        </trans-unit>
        <trans-unit id="cc826e0e638f15943c2d93a5fc1dee8020c30510" translate="yes" xml:space="preserve">
          <source>The name of the archive member; it is used to index the archive directory for the member. Each member must have a unique name. Do not change without removing member from the directory first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee544165e4b0ac751c5682d99380143dea28b21" translate="yes" xml:space="preserve">
          <source>The name of the coverage file.</source>
          <target state="translated">Имя файла покрытия.</target>
        </trans-unit>
        <trans-unit id="8ede299dc9f0c5729961ad67f198075314269cda" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library to load.</source>
          <target state="translated">Имя динамической библиотеки для загрузки.</target>
        </trans-unit>
        <trans-unit id="eb57c5ab9b22c7728fcb5026ae94a8f672f4064a" translate="yes" xml:space="preserve">
          <source>The name of the file in the path name, without any leading directory and with an optional suffix chopped off.  If &lt;code&gt;suffix&lt;/code&gt; is specified, it will be compared to &lt;code&gt;path&lt;/code&gt; using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">Имя файла в пути, без какого-либо начального каталога и с необязательным суффиксом обрезается. Если указан &lt;code&gt;suffix&lt;/code&gt; , он будет сравниваться с &lt;code&gt;path&lt;/code&gt; с использованием &lt;code&gt;filenameCmp!cs&lt;/code&gt; , где &lt;code&gt;cs&lt;/code&gt; - необязательный параметр шаблона, определяющий, является ли сравнение чувствительным к регистру или нет. Подробности смотрите в документации к &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="300f2fc600e9d7ddc4bfc394a66a2e870cf5e607" translate="yes" xml:space="preserve">
          <source>The name of the file that signaled this error.</source>
          <target state="translated">Имя файла,который сигнализировал об этой ошибке.</target>
        </trans-unit>
        <trans-unit id="c3104c1d832397234efa203c02c8d138f5d9f9fd" translate="yes" xml:space="preserve">
          <source>The name of the file to get the modification time for.</source>
          <target state="translated">Имя файла для получения времени модификации.</target>
        </trans-unit>
        <trans-unit id="e8109b9ee879cd4547f4e2ca59c0889a944b8289" translate="yes" xml:space="preserve">
          <source>The name of the time zone.</source>
          <target state="translated">Название часового пояса.</target>
        </trans-unit>
        <trans-unit id="f27bf1b63b731926e3cb9f283408921e662cdceb" translate="yes" xml:space="preserve">
          <source>The name of the time zone. Exactly how the time zone name is formatted depends on the derived class. In the case of &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;, it's the TZ Database name, whereas with &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, it's the name that Windows chose to give the registry key for that time zone (typically the name that they give &lt;a href=&quot;#stdTime&quot;&gt;&lt;code&gt;stdTime&lt;/code&gt;&lt;/a&gt; if the OS is in English). For other time zone types, what it is depends on how they're implemented.</source>
          <target state="translated">Название часового пояса. Как именно форматируется имя часового пояса, зависит от производного класса. В случае &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; это имя базы данных TZ, тогда как в &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; это имя, которое Windows выбрала для предоставления ключа реестра для этого часового пояса (обычно это имя, которое они дают &lt;a href=&quot;#stdTime&quot;&gt; &lt;code&gt;stdTime&lt;/code&gt; ,&lt;/a&gt; если ОС на английском языке). Для других типов часовых поясов это зависит от того, как они реализованы.</target>
        </trans-unit>
        <trans-unit id="7356c9b705dbe74fbd4051d488c2e6132abcd4c9" translate="yes" xml:space="preserve">
          <source>The name of this thread.</source>
          <target state="translated">Название этой нити.</target>
        </trans-unit>
        <trans-unit id="c1776179bbf96730aef0ae7bbd1e4946315a478b" translate="yes" xml:space="preserve">
          <source>The name to associate with tid.</source>
          <target state="translated">Имя,которое ассоциируется с &quot;Тид&quot;.</target>
        </trans-unit>
        <trans-unit id="6450e623e92fd399a84552aa61d8d22ade4cc69a" translate="yes" xml:space="preserve">
          <source>The name to locate within the registry.</source>
          <target state="translated">Имя,которое можно найти в реестре.</target>
        </trans-unit>
        <trans-unit id="2b6764cf8c6facb0fec9b546a291b7a2d4a5f2ee" translate="yes" xml:space="preserve">
          <source>The name to unregister.</source>
          <target state="translated">Имя для снятия с регистрации.</target>
        </trans-unit>
        <trans-unit id="237ed33d70031f44c43457be931f956373047992" translate="yes" xml:space="preserve">
          <source>The names of the &lt;code&gt;Tuple&lt;/code&gt;'s components. Unnamed fields have empty names.</source>
          <target state="translated">Имена компонентов &lt;code&gt;Tuple&lt;/code&gt; . Безымянные поля имеют пустые имена.</target>
        </trans-unit>
        <trans-unit id="3ad8dfc5a740c084b53b8cdd123ef24e70479c04" translate="yes" xml:space="preserve">
          <source>The names of the fields that are to be aligned.</source>
          <target state="translated">Названия полей,которые должны быть выровнены.</target>
        </trans-unit>
        <trans-unit id="32748ca9205b0eda60d1a2b3377d67735262b73b" translate="yes" xml:space="preserve">
          <source>The natural alignment of an aggregate is the maximum alignment of its fields. It can be overridden by setting the alignment outside of the aggregate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d205145a6dee0cb48fa4896fcd5718737412eec" translate="yes" xml:space="preserve">
          <source>The necessity of &lt;code&gt;FPTemporary&lt;/code&gt; stems from the optimized floating-point operations and registers present in virtually all processors. When adding numbers in the example above, the addition may in fact be done in &lt;code&gt;real&lt;/code&gt; precision internally. In that case, storing the intermediate &lt;code&gt;result&lt;/code&gt; in &lt;code&gt;double format&lt;/code&gt; is not only less precise, it is also (surprisingly) slower, because a conversion from &lt;code&gt;real&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt; is performed every pass through the loop. This being a lose-lose situation, &lt;code&gt;FPTemporary!F&lt;/code&gt; has been defined as the</source>
          <target state="translated">Необходимость &lt;code&gt;FPTemporary&lt;/code&gt; вытекает из оптимизированных операций с плавающей запятой и регистров, присутствующих практически во всех процессорах. При добавлении чисел в вышеприведенном примере, сложение может фактически быть сделано в &lt;code&gt;real&lt;/code&gt; точности внутри. В этом случае сохранение промежуточного &lt;code&gt;result&lt;/code&gt; в &lt;code&gt;double format&lt;/code&gt; не только менее точно, но и (на удивление) медленнее, потому что преобразование из &lt;code&gt;real&lt;/code&gt; в &lt;code&gt;double&lt;/code&gt; выполняется при каждом проходе цикла. &lt;code&gt;FPTemporary!F&lt;/code&gt; определяется как ситуация безубыточности.</target>
        </trans-unit>
        <trans-unit id="ce69a83fa824acdbab753bf226be620b99f45d75" translate="yes" xml:space="preserve">
          <source>The needles against which the range is to be checked, which may be individual elements or input ranges of elements.</source>
          <target state="translated">Иглы,с которыми должен быть проверен диапазон,которые могут быть отдельными элементами или входными диапазонами элементов.</target>
        </trans-unit>
        <trans-unit id="bfdb89ae3952e0ebbdb470ec1b2208c20a477858" translate="yes" xml:space="preserve">
          <source>The needles to check against, which may be single elements, or bidirectional ranges of elements.</source>
          <target state="translated">Иглы для проверки,которые могут быть одиночными или двунаправленными.</target>
        </trans-unit>
        <trans-unit id="aadc952b806bed5663dabd85a1e647a24a59b7a9" translate="yes" xml:space="preserve">
          <source>The network interface to use in form of the the IP of the interface.</source>
          <target state="translated">Сетевой интерфейс для использования в виде IP-адреса интерфейса.</target>
        </trans-unit>
        <trans-unit id="d0400083bef2e7ef7cc46b24ddfeddfeb8ab8c14" translate="yes" xml:space="preserve">
          <source>The new GC is added to the list of available garbage collectors that can be selected via the usual configuration options, e.g. by embedding &lt;code&gt;rt_options&lt;/code&gt; into the binary:</source>
          <target state="translated">Новый GC добавлен в список доступных сборщиков мусора, которые можно выбрать с помощью обычных параметров конфигурации, например, путем встраивания &lt;code&gt;rt_options&lt;/code&gt; в двоичный файл:</target>
        </trans-unit>
        <trans-unit id="9669eec52fe11c4d6bad1a51de754d4e92f468df" translate="yes" xml:space="preserve">
          <source>The new capacity of the array (which may be larger than the requested capacity).</source>
          <target state="translated">Новая емкость массива (которая может быть больше запрашиваемой емкости).</target>
        </trans-unit>
        <trans-unit id="1cf6198accddd14ad946cf8a5d9d64fbb23a0e02" translate="yes" xml:space="preserve">
          <source>The new collect handler. Set to null to use the default handler.</source>
          <target state="translated">Новый обработчик коллекции.Устанавливается в ноль,чтобы использовать обработчик по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0c74f8b0b947d138316f600a118f4af837db2c6f" translate="yes" xml:space="preserve">
          <source>The new daemon status for this thread.</source>
          <target state="translated">Новый статус демона для этой нити.</target>
        </trans-unit>
        <trans-unit id="cc66954b4cb782475e75068053434548b84f648b" translate="yes" xml:space="preserve">
          <source>The new extension</source>
          <target state="translated">Новое расширение</target>
        </trans-unit>
        <trans-unit id="6c6fed22d3bfa6cee371ded07b99f5fc419355ad" translate="yes" xml:space="preserve">
          <source>The new handle will have all options set as the one it was duplicated from. An exception to this is that all options that cannot be shared across threads are reset thereby making it safe to use the duplicate in a new thread.</source>
          <target state="translated">В новой ручке будут установлены все опции,как в той,с которой она была дублирована.Исключением является то,что все опции,которые не могут быть общими для всех потоков,сбрасываются,что делает безопасным использование дубликата в новом потоке.</target>
        </trans-unit>
        <trans-unit id="acc5bddfa65365c1a41f6c814bd0b6ebf529b8b6" translate="yes" xml:space="preserve">
          <source>The new length of the array</source>
          <target state="translated">Новая длина массива</target>
        </trans-unit>
        <trans-unit id="44a43ff11b1752259ff91b328a916debf3f4639d" translate="yes" xml:space="preserve">
          <source>The new name of this thread.</source>
          <target state="translated">Новое название этой нити.</target>
        </trans-unit>
        <trans-unit id="06d8bda027bfab1541ebec46a9bfa9f862174683" translate="yes" xml:space="preserve">
          <source>The new path name.</source>
          <target state="translated">Новое название пути.</target>
        </trans-unit>
        <trans-unit id="69ac0b91bb8b9e837548ad9dd2ea12af0f0c91cd" translate="yes" xml:space="preserve">
          <source>The new position of the pivot</source>
          <target state="translated">Новое положение шарнира</target>
        </trans-unit>
        <trans-unit id="66818226d4d8e1db31b172237309a1e18f4a385a" translate="yes" xml:space="preserve">
          <source>The new scheduling priority of this thread.</source>
          <target state="translated">Новый приоритет планирования этого потока.</target>
        </trans-unit>
        <trans-unit id="bd1e49caf2a8a204c7259f45e5e91918594335cb" translate="yes" xml:space="preserve">
          <source>The new trace handler. Set to null to use the default handler.</source>
          <target state="translated">Новый обработчик следов.Установите значение null,чтобы использовать обработчик по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ef32f36ed520dab3a13bb8e95c2b955f22dc9b02" translate="yes" xml:space="preserve">
          <source>The new type supports all operations that the underlying type does, including all operators such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, etc.</source>
          <target state="translated">Новый тип поддерживает все операции, выполняемые базовым типом, включая все операторы, такие как &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="4c2af0bb285d74b0268707c20367567927c3ffc7" translate="yes" xml:space="preserve">
          <source>The new unit tester. Set both to null to use the default unit tester.</source>
          <target state="translated">Новый тестер.Установите оба значения равными нулю,чтобы использовать тестер устройств по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6444785f7ab11942d704329e47346be10efdb756" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;px&lt;/code&gt;</source>
          <target state="translated">Новое значение &lt;code&gt;px&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a51d15a8fa704020915ee450c5caa4010f6aa779" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Новое значение &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4e6a0eafbf606dbc06607e9b4455a1bb56b0445" translate="yes" xml:space="preserve">
          <source>The new-style generator objects hold their own state so they are immune of threading issues. The generators feature a number of well-known and well-documented methods of generating random numbers. An overall fast and reliable means to generate random numbers is the Mt19937 generator, which derives its name from &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; with a period of 2 to the power of 19937&quot;. In memory-constrained situations, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;linear congruential generators&lt;/a&gt; such as &lt;code&gt;MinstdRand0&lt;/code&gt; and &lt;code&gt;MinstdRand&lt;/code&gt; might be useful. The standard library provides an alias Random for whichever generator it considers the most fit for the target environment.</source>
          <target state="translated">Объекты генератора нового стиля хранят свое собственное состояние, поэтому они защищены от проблем с многопоточностью. Генераторы имеют ряд хорошо известных и документированных способов генерации случайных чисел. Общим быстрым и надежным средством для генерации случайных чисел является генератор Mt19937, который получил свое название от &amp;laquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; с периодом от 2 до 19937&amp;raquo;. В ситуациях с ограничением памяти могут быть полезны &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;линейные конгруэнтные генераторы,&lt;/a&gt; такие как &lt;code&gt;MinstdRand0&lt;/code&gt; и &lt;code&gt;MinstdRand&lt;/code&gt; . Стандартная библиотека предоставляет псевдоним Random для любого генератора, который она считает наиболее подходящим для целевой среды.</target>
        </trans-unit>
        <trans-unit id="6e04d5ec9d8b3f77749de3ac5300639b2dab8407" translate="yes" xml:space="preserve">
          <source>The newline following the opening identifier is not part of the string, but the last newline before the closing identifier is part of the string. The closing identifier must be placed on its own line at the leftmost column.</source>
          <target state="translated">Новая строка,следующая за открывающим идентификатором,не является частью строки,но последняя новая строка перед закрывающим идентификатором является частью строки.Закрывающий идентификатор должен быть помещен в свою строку в крайнем левом столбце.</target>
        </trans-unit>
        <trans-unit id="51929efa4bba26701d3e4c3aa50f3e9c95ba7e57" translate="yes" xml:space="preserve">
          <source>The newly constructed object.</source>
          <target state="translated">Недавно построенный объект.</target>
        </trans-unit>
        <trans-unit id="c4d7c48e5f93c9ad9f6d35527dbfa50a57849838" translate="yes" xml:space="preserve">
          <source>The newly-created array, or &lt;code&gt;null&lt;/code&gt; if either &lt;code&gt;length&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt; or allocation failed.</source>
          <target state="translated">Вновь созданный массив, или &lt;code&gt;null&lt;/code&gt; , если либо &lt;code&gt;length&lt;/code&gt; была &lt;code&gt;0&lt;/code&gt; или распределение не удалось.</target>
        </trans-unit>
        <trans-unit id="b81ee0139f4bf3ca132aff416b4badbbfb8df40c" translate="yes" xml:space="preserve">
          <source>The next unnamed section is the</source>
          <target state="translated">Следующий безымянный раздел</target>
        </trans-unit>
        <trans-unit id="4c1d1956fd234c462fed35c0d040ec6b5d07b95f" translate="yes" xml:space="preserve">
          <source>The non-static data members of a struct are called</source>
          <target state="translated">Нестатические члены структуры называются</target>
        </trans-unit>
        <trans-unit id="604fdea6e74692fe9e13e9f5a58a3d2b1b6ac2cf" translate="yes" xml:space="preserve">
          <source>The normal (or Gaussian, or bell-shaped) distribution is defined as:</source>
          <target state="translated">Нормальное (или гауссовское,или колоколообразное)распределение определяется как:</target>
        </trans-unit>
        <trans-unit id="eff21418db566bf6deaa5b9e66141af90f3d37fd" translate="yes" xml:space="preserve">
          <source>The normal flow of program logic is performance critical.</source>
          <target state="translated">Нормальный поток программной логики является критическим с точки зрения производительности.</target>
        </trans-unit>
        <trans-unit id="7d10d0ff78a75299a167b0002f609034c9aaa171" translate="yes" xml:space="preserve">
          <source>The nth &lt;code&gt;ulong&lt;/code&gt; in the representation of this &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">N-й &lt;code&gt;ulong&lt;/code&gt; в представлении этого &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb3057bb9b7c5b0a70e9ce3b421bd111159e0bc0" translate="yes" xml:space="preserve">
          <source>The nth number to retrieve. Must be less than &lt;a href=&quot;#ulongLength&quot;&gt;&lt;code&gt;ulongLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uintLength&quot;&gt;&lt;code&gt;uintLength&lt;/code&gt;&lt;/a&gt; with respect to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Номер n для извлечения. Должно быть меньше , чем &lt;a href=&quot;#ulongLength&quot;&gt; &lt;code&gt;ulongLength&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#uintLength&quot;&gt; &lt;code&gt;uintLength&lt;/code&gt; &lt;/a&gt; по отношению к &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b76d5847a278447b3f3920d9aa794bc68c09f466" translate="yes" xml:space="preserve">
          <source>The null value which denotes the null state of this &lt;code&gt;Nullable&lt;/code&gt;. Must be of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Нулевое значение, которое обозначает нулевое состояние этого &lt;code&gt;Nullable&lt;/code&gt; . Должно быть типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="199b0fb0977641f832ecd7a38d40b0a14f3dad41" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;Tgt&lt;/code&gt; elements written.</source>
          <target state="translated">Количество &lt;code&gt;Tgt&lt;/code&gt; элементов Tgt .</target>
        </trans-unit>
        <trans-unit id="95368522e59bb86a89704bd4d6738e476908f01e" translate="yes" xml:space="preserve">
          <source>The number of bits of state of this generator. This must be a positive multiple of the size in bits of UIntType. If nbits is large this struct may occupy slightly more memory than this so it can use a circular counter instead of shifting the entire array.</source>
          <target state="translated">Количество битов состояния этого генератора.Оно должно быть кратно положительному размеру в битах UIntType.Если nbits большой,то эта структура может занимать чуть больше памяти,поэтому она может использовать круговой счетчик вместо того,чтобы сдвигать весь массив.</target>
        </trans-unit>
        <trans-unit id="ed0599417ff90656d7b8a7db044e9965e3ca5970" translate="yes" xml:space="preserve">
          <source>The number of buffers to cycle through when calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">Количество буферов для циклического перехода при &lt;code&gt;next&lt;/code&gt; вызове .</target>
        </trans-unit>
        <trans-unit id="30308060113660277e7be67f08fdce3f91011c41" translate="yes" xml:space="preserve">
          <source>The number of bytes actually received, &lt;code&gt;0&lt;/code&gt; if the remote side has closed the connection, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">Количество фактически полученных байтов, &lt;code&gt;0&lt;/code&gt; , если удаленная сторона закрыла соединение, или &lt;code&gt;Socket.ERROR&lt;/code&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="52771a2599e853e22c9997ae74caf507a27e6674" translate="yes" xml:space="preserve">
          <source>The number of bytes actually sent, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">Количество фактически отправленных байтов или &lt;code&gt;Socket.ERROR&lt;/code&gt; при ошибке .</target>
        </trans-unit>
        <trans-unit id="cb4925770f917957f95841228cf7a081251584ac" translate="yes" xml:space="preserve">
          <source>The number of bytes written to &lt;code&gt;result&lt;/code&gt;. The length, in bytes, of the actual result - very different from getsockopt()</source>
          <target state="translated">Количество байтов, записанных в &lt;code&gt;result&lt;/code&gt; . Длина в байтах фактического результата - очень отличается от getsockopt ()</target>
        </trans-unit>
        <trans-unit id="18e0b014069c5b9a5015fd8266605137eb19d431" translate="yes" xml:space="preserve">
          <source>The number of cache levels in the CPU.</source>
          <target state="translated">Количество уровней кэша в процессоре.</target>
        </trans-unit>
        <trans-unit id="4e1a5c7628d25ca94f5309da0ccfd2a5e3544707" translate="yes" xml:space="preserve">
          <source>The number of chunks buffered asynchronously</source>
          <target state="translated">Количество кусков,забуферированных асинхронно.</target>
        </trans-unit>
        <trans-unit id="d794552fb711e9d13296816f458408c772152acf" translate="yes" xml:space="preserve">
          <source>The number of code units in &lt;code&gt;input&lt;/code&gt; when encoded to &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">Количество единиц кода на &lt;code&gt;input&lt;/code&gt; при кодировании в &lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4af8e22ffe4686545114fe30d8267cec1e21b38c" translate="yes" xml:space="preserve">
          <source>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, section 3&lt;/a&gt;). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.</source>
          <target state="translated">Количество кодовых единиц в последовательности UTF. Для UTF-8 это значение от 1 до 4 (согласно &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, раздел 3&lt;/a&gt; ). Для UTF-16 это либо 1, либо 2. Для UTF-32 это всегда 1.</target>
        </trans-unit>
        <trans-unit id="5eb0aafa3d3443973bc7f248675786f305586655" translate="yes" xml:space="preserve">
          <source>The number of colons in the selector needs to match the number of parameters the method is declared with</source>
          <target state="translated">Количество двоеточий в селекторе должно соответствовать количеству параметров,с которыми объявлен метод</target>
        </trans-unit>
        <trans-unit id="cf1a54117f4160455c190793bfbc5f270d3ef431" translate="yes" xml:space="preserve">
          <source>The number of colons in the string need to match the number of arguments the method accept.</source>
          <target state="translated">Количество двоеточий в строке должно совпадать с количеством аргументов,принимаемых методом.</target>
        </trans-unit>
        <trans-unit id="74867ebd8619c3c9f54bb7be26778ccc990cfd33" translate="yes" xml:space="preserve">
          <source>The number of days to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество дней, чтобы добавить к этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17519ebe025dfa827b2543290a321667b7bbfac2" translate="yes" xml:space="preserve">
          <source>The number of elements brought to the front, i.e., the length of &lt;code&gt;back&lt;/code&gt;.</source>
          <target state="translated">Количество элементов, вынесенных вперед, т. Е. Длина &lt;code&gt;back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30c9197d75a0a694e962a609bbc59e4ba11be6f0" translate="yes" xml:space="preserve">
          <source>The number of elements in an</source>
          <target state="translated">Количество элементов в</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">Количество элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="325aeffb680232bb5eba0a4534994930400a1165" translate="yes" xml:space="preserve">
          <source>The number of elements inserted</source>
          <target state="translated">Количество вставленных элементов</target>
        </trans-unit>
        <trans-unit id="4f13d3392d3b50fea45a81fe242fa67f3021e8e8" translate="yes" xml:space="preserve">
          <source>The number of elements inserted.</source>
          <target state="translated">Количество вставленных элементов.</target>
        </trans-unit>
        <trans-unit id="c6d6d4be5d1980bfa9a3ce44b333a124372b6ae3" translate="yes" xml:space="preserve">
          <source>The number of elements removed</source>
          <target state="translated">Количество удаленных элементов</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">Количество удаленных элементов.</target>
        </trans-unit>
        <trans-unit id="a147df2d8f03d61a2cbd49ca985ab3c09c4946c0" translate="yes" xml:space="preserve">
          <source>The number of elements to evaluate in a single &lt;code&gt;Task&lt;/code&gt;. Must be less than or equal to &lt;code&gt;bufSize&lt;/code&gt;, and should be a fraction of &lt;code&gt;bufSize&lt;/code&gt; such that all worker threads can be used. If the default of size_t.max is used, workUnitSize will be set to the pool-wide default.</source>
          <target state="translated">Количество элементов для оценки в одной &lt;code&gt;Task&lt;/code&gt; . Должно быть меньше или равно &lt;code&gt;bufSize&lt;/code&gt; и должно быть частью &lt;code&gt;bufSize&lt;/code&gt; , чтобы можно было использовать все рабочие потоки. Если используется значение по умолчанию size_t.max, для workUnitSize будет установлено значение по умолчанию для всего пула.</target>
        </trans-unit>
        <trans-unit id="9de93b8e68b06f4138b723f65ba57f9135fbd680" translate="yes" xml:space="preserve">
          <source>The number of elements which must be popped from the front of &lt;code&gt;haystack&lt;/code&gt; before reaching an element for which &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; for any element in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;-1&lt;/code&gt; is returned. If only &lt;code&gt;pred&lt;/code&gt; is provided, &lt;code&gt;pred(haystack)&lt;/code&gt; is tested for each element.</source>
          <target state="translated">Число элементов, которые должны быть извлечены из передней части &lt;code&gt;haystack&lt;/code&gt; до достижения элемента, для которого &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; . Если &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; не &lt;code&gt;true&lt;/code&gt; ни одному элементу &lt;code&gt;haystack&lt;/code&gt; , то возвращается &lt;code&gt;-1&lt;/code&gt; . Если &lt;code&gt;pred&lt;/code&gt; только pred , &lt;code&gt;pred(haystack)&lt;/code&gt; проверяется для каждого элемента.</target>
        </trans-unit>
        <trans-unit id="11ccb90c9b9e42a2c399f8ec744f0b51f68401b5" translate="yes" xml:space="preserve">
          <source>The number of files in this archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495bce27f099960a19a7f2777229fe07b08dc353" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since January 1st, 1 A.D. UTC.</source>
          <target state="translated">Количество гнсеков с 1 января 1 года нашей эры по UTC.</target>
        </trans-unit>
        <trans-unit id="0128cf9b280876e985f5bc63b3c33b05eec8b671" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</source>
          <target state="translated">Количество гнсеков с полуночи,1 января,1 ночи по UTC.</target>
        </trans-unit>
        <trans-unit id="dfa696143d106fe9221db705fdd3a015ad40f3ab" translate="yes" xml:space="preserve">
          <source>The number of lines buffered asynchronously</source>
          <target state="translated">Количество буферизованных строк асинхронно</target>
        </trans-unit>
        <trans-unit id="9bd6f12f8ce1f299c0d0263b77bcc143be77d073" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество месяцев или лет, добавляемых к этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c39f066ee7dbe68f94fd81f8c5f3cf00396747" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество месяцев или лет, добавляемых к данному &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57340a14727c652a36c1e1fc1ba3e2830bbfa123" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество месяцев или лет, добавляемых к этому &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02485194b1dc362bace73e65c9372da46a13c61b" translate="yes" xml:space="preserve">
          <source>The number of months to add to the time point passed to the delegate.</source>
          <target state="translated">Количество месяцев для добавления к пункту времени,переданному делегату.</target>
        </trans-unit>
        <trans-unit id="aca30d94828d21a4c6a8ef3a42e227aa33b46f16" translate="yes" xml:space="preserve">
          <source>The number of months to expand the interval by.</source>
          <target state="translated">Количество месяцев для расширения интервала на.</target>
        </trans-unit>
        <trans-unit id="4f7751ef3f5968bb794d3b81c43237882d9d52ee" translate="yes" xml:space="preserve">
          <source>The number of months to shift the interval by.</source>
          <target state="translated">Количество месяцев для сдвига интервала на.</target>
        </trans-unit>
        <trans-unit id="63a68d030d7307514d07c50786c06b3b1b3f26d9" translate="yes" xml:space="preserve">
          <source>The number of pages is variable (but not less then 1) unlike the number of entries in the index. The slots of the index all have to contain a number of a page that is present. The lookup is then just a couple of operations - slice the upper bits, lookup an index for these, take a page at this index and use the lower bits as an offset within this page.</source>
          <target state="translated">Количество страниц переменное (но не менее 1)в отличие от количества записей в индексе.Все слоты индекса должны содержать номер страницы,которая присутствует.Тогда поиск-это всего лишь пара операций-нарезать верхние биты,найти для них индекс,взять страницу в этом индексе и использовать нижние биты как смещение внутри этой страницы.</target>
        </trans-unit>
        <trans-unit id="a4a9d929861b7f4540e0616b20649c026af1b75f" translate="yes" xml:space="preserve">
          <source>The number of positions in the &lt;code&gt;haystack&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returned true.</source>
          <target state="translated">Число позиций в &lt;code&gt;haystack&lt;/code&gt; для которых &lt;code&gt;pred&lt;/code&gt; вернул true.</target>
        </trans-unit>
        <trans-unit id="e5d60a9e70df9e4591b2299d06f99ccc91195edd" translate="yes" xml:space="preserve">
          <source>The number of sockets with status changes, &lt;code&gt;0&lt;/code&gt; on timeout, or &lt;code&gt;-1&lt;/code&gt; on interruption. If the return value is greater than &lt;code&gt;0&lt;/code&gt;, the &lt;code&gt;SocketSets&lt;/code&gt; are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.  &lt;code&gt;SocketSet&lt;/code&gt;'s updated to include only those sockets which an event occured. For a &lt;code&gt;connect()&lt;/code&gt;ing socket, writeability means connected. For a &lt;code&gt;listen()&lt;/code&gt;ing socket, readability means listening &lt;code&gt;Winsock&lt;/code&gt;; possibly internally limited to 64 sockets per set.</source>
          <target state="translated">Количество сокетов с изменениями состояния, &lt;code&gt;0&lt;/code&gt; по таймауту или &lt;code&gt;-1&lt;/code&gt; при прерывании. Если возвращаемое значение больше &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;SocketSets&lt;/code&gt; обновляются и содержат только сокеты, имеющие изменения состояния. Для соединительного сокета изменение статуса записи означает, что соединение установлено и оно может отправлять. Для сокета прослушивания изменение статуса чтения означает, что есть входящий запрос на соединение, и он может принять. &lt;code&gt;SocketSet&lt;/code&gt; включает в себя только те сокеты, в которых произошло событие. Для сокета &lt;code&gt;connect()&lt;/code&gt; , возможность записи означает подключенный. Для сокета &lt;code&gt;listen()&lt;/code&gt; читаемость означает прослушивание &lt;code&gt;Winsock&lt;/code&gt; ; возможно внутренне ограничено до 64 сокетов в наборе.</target>
        </trans-unit>
        <trans-unit id="92623bd7d09398f80bbab3bb0f5f2ef38d3da421" translate="yes" xml:space="preserve">
          <source>The number of system ticks in this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">Количество системных тиков в этом &lt;code&gt;TickDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7611dde88762f088b010293dbcd7b4751f9ec60a" translate="yes" xml:space="preserve">
          <source>The number of the disk where this member can be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f11ee7d7d27eb3d41061b45eac584df0b5f1cfe" translate="yes" xml:space="preserve">
          <source>The number of ticks in the TickDuration.</source>
          <target state="translated">Количество тиков в TickDuration.</target>
        </trans-unit>
        <trans-unit id="c3535c21516c22bad36e4ae79f60e710279eebd0" translate="yes" xml:space="preserve">
          <source>The number of ticks in the monotonic time.</source>
          <target state="translated">Количество клещей в монотонном времени.</target>
        </trans-unit>
        <trans-unit id="133c2247d181f5eb459c19f2950580ed684e418a" translate="yes" xml:space="preserve">
          <source>The number of ticks that MonoTime has per second - i.e. the resolution or frequency of the system's monotonic clock.</source>
          <target state="translated">Количество тиков,которое MonoTime имеет в секунду-т.е.разрешение или частота монотонных часов системы.</target>
        </trans-unit>
        <trans-unit id="8271982f8f2afc20c964508f18ca6b32767857e7" translate="yes" xml:space="preserve">
          <source>The number of ticks that the system clock has in one second.</source>
          <target state="translated">Количество галочек,которые есть у системных часов за одну секунду.</target>
        </trans-unit>
        <trans-unit id="8b51266ea49a500bd86819d90d5f5babd9fda252" translate="yes" xml:space="preserve">
          <source>The number of times each function is to be executed.</source>
          <target state="translated">Количество раз,когда каждая функция должна быть выполнена.</target>
        </trans-unit>
        <trans-unit id="f1050ae226927365357fc51efba9b81760d7056b" translate="yes" xml:space="preserve">
          <source>The number of times the output range's &lt;code&gt;put&lt;/code&gt; method was invoked.</source>
          <target state="translated">Сколько раз &lt;code&gt;put&lt;/code&gt; метод put выходного диапазона .</target>
        </trans-unit>
        <trans-unit id="4d82522805f2ebbbf559fec74a61f5c7cb9cc3a6" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Количество единиц в &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="794f084381c766ea0ff9fffa3e14bba305b1eb34" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">Количество единиц в &lt;code&gt;TickDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22c3d0c8685c468fadcdccd79c29727ddf2e7e9a" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество единиц, добавляемых к данному &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b148446ca97774856b435f40497b3469e8ca6ab" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество единиц, добавляемых к этому &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3b24aff6aba1d0b2f312ff80d7560f7feabc059" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество единиц, добавляемых к этому &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37c2540cc1f38510b5307fd0d898532d4c17f0e5" translate="yes" xml:space="preserve">
          <source>The number of units to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">Количество единиц, на которое нужно умножить эту &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f6b34534215487ddb13229d1e9eb704abfb659b" translate="yes" xml:space="preserve">
          <source>The number of values inserted.</source>
          <target state="translated">Количество вставленных значений.</target>
        </trans-unit>
        <trans-unit id="d14be6e779a48d8faa82f80e4dc078722606651d" translate="yes" xml:space="preserve">
          <source>The number of waiting threads to release in unison.</source>
          <target state="translated">Количество ожидающих потоков,которые должны быть освобождены в унисон.</target>
        </trans-unit>
        <trans-unit id="365cb2c08dafe42960332e827da68e53b00a9bd8" translate="yes" xml:space="preserve">
          <source>The number of years to add to the time point passed to the delegate.</source>
          <target state="translated">Количество лет для добавления к пункту времени,переданному делегату.</target>
        </trans-unit>
        <trans-unit id="fcc2e5d2212e8d8be70b8d4677e493fc3848a020" translate="yes" xml:space="preserve">
          <source>The number of years to expand the interval by.</source>
          <target state="translated">Количество лет для расширения интервала на.</target>
        </trans-unit>
        <trans-unit id="2241ab252f8a5484883abb33a8af4a6dad25eb69" translate="yes" xml:space="preserve">
          <source>The number of years to shift the interval by.</source>
          <target state="translated">Количество лет,на которое можно сдвинуть интервал.</target>
        </trans-unit>
        <trans-unit id="ab33e33805a08eda08dd986381c2b8f8b862f93b" translate="yes" xml:space="preserve">
          <source>The number to validate.</source>
          <target state="translated">Номер для проверки.</target>
        </trans-unit>
        <trans-unit id="b28803e23c2f1bebd73a4d48e79b273e730f7db3" translate="yes" xml:space="preserve">
          <source>The numeric literals &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; can be implicitly converted to the &lt;code&gt;bool&lt;/code&gt; values &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;, respectively. Casting an expression to &lt;code&gt;bool&lt;/code&gt; means testing for &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;!=0&lt;/code&gt; for arithmetic types, and &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;!=null&lt;/code&gt; for pointers or references.</source>
          <target state="translated">Числовые литералы &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; могут быть неявно преобразованы в значения &lt;code&gt;bool&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;true&lt;/code&gt; соответственно. Приведение выражения к &lt;code&gt;bool&lt;/code&gt; означает проверку на &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;!=0&lt;/code&gt; для арифметических типов, а также &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;!=null&lt;/code&gt; для указателей или ссылок.</target>
        </trans-unit>
        <trans-unit id="fe0da3c8ef7d3c766ce89becdf0b23671a0397f9" translate="yes" xml:space="preserve">
          <source>The numeric version number is also available &quot;in parts&quot; by using these constants</source>
          <target state="translated">Цифровой номер версии также доступен &quot;по частям&quot; при использовании этих констант</target>
        </trans-unit>
        <trans-unit id="126529265bda77a1ffa31840d1614e6dc6547606" translate="yes" xml:space="preserve">
          <source>The object to throw.</source>
          <target state="translated">Объект для броска.</target>
        </trans-unit>
        <trans-unit id="917127d4e18a9f0f96c8fddb70a363dd7f1bb7b1" translate="yes" xml:space="preserve">
          <source>The object-oriented features of D all come from classes. The class hierarchy has as its root the class Object. Object defines a minimum level of functionality that each derived class has, and a default implementation for that functionality.</source>
          <target state="translated">Объектно-ориентированные особенности D все приходят из классов.Корнем иерархии классов является Объект класса.Объект определяет минимальный уровень функциональности,который имеет каждый производный класс,и реализацию по умолчанию для этой функциональности.</target>
        </trans-unit>
        <trans-unit id="83450785309cc6865682ad266cad8f967bd48d27" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that comparingBenchmark has not been ported over, because it's a trivial wrapper around benchmark. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">Старая функциональность сравнения в std.datetime (которая использует &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; ) устарела. Вместо этого используйте то, что находится в std.datetime.stopwatch. Он использует &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что comparingBenchmark не был перенесен, потому что это тривиальная оболочка для теста. Смотрите &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; &lt;/a&gt; . Этот символ будет удален из документации в октябре 2018 года и полностью удален из Фобоса в октябре 2019 года.</target>
        </trans-unit>
        <trans-unit id="efeb1eab4dde5b659a31f85b9f2c2ca05099ac2d" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that measureTime has not been ported over, because it's a trivial wrapper around StopWatch. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">Старая функциональность сравнения в std.datetime (которая использует &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; ) устарела. Вместо этого используйте то, что находится в std.datetime.stopwatch. Он использует &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что measureTime не был перенесен, потому что это тривиальная оболочка вокруг StopWatch. Смотрите &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; &lt;/a&gt; . Этот символ будет удален из документации в октябре 2018 года и полностью удален из Фобоса в октябре 2019 года.</target>
        </trans-unit>
        <trans-unit id="8251e06b859fc1bf7834e47982a51786233d653a" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt;&lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">Старая функциональность сравнения в std.datetime (которая использует &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; ) устарела. Вместо этого используйте то, что находится в std.datetime.stopwatch. Он использует &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; . Смотрите &lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt; &lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt; &lt;/a&gt; . Этот символ будет удален из документации в октябре 2018 года и полностью удален из Фобоса в октябре 2019 года.</target>
        </trans-unit>
        <trans-unit id="3836851ebe09983822b4948475513fd0ffdb5b68" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">Старая функциональность сравнения в std.datetime (которая использует &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; ) устарела. Вместо этого используйте то, что находится в std.datetime.stopwatch. Он использует &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; . Смотрите &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; &lt;/a&gt; . Этот символ будет удален из документации в октябре 2018 года и полностью удален из Фобоса в октябре 2019 года.</target>
        </trans-unit>
        <trans-unit id="852cd69a4d8476a6740350b9e4fa04e022f147f2" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">Старая функциональность сравнения в std.datetime (которая использует &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; ) устарела. Вместо этого используйте то, что находится в std.datetime.stopwatch. Он использует &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; . Смотрите &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; &lt;/a&gt; . Этот символ будет удален из документации в октябре 2018 года и полностью удален из Фобоса в октябре 2019 года.</target>
        </trans-unit>
        <trans-unit id="e2b766119f4b2cc6bf40fa4a91668ec3bf749415" translate="yes" xml:space="preserve">
          <source>The one area in which this function violates RFC 5322 is that it accepts &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in folding whitespace in the place of &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, because the HTTP spec requires it.</source>
          <target state="translated">Единственная область, в которой эта функция нарушает RFC 5322, - это то, что она принимает &lt;code&gt;&quot;\n&quot;&lt;/code&gt; в складывающихся пробелах вместо &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; , потому что спецификация HTTP требует этого.</target>
        </trans-unit>
        <trans-unit id="1e2e3dd788c39da352fad71950c0b91387508356" translate="yes" xml:space="preserve">
          <source>The one shared instance.</source>
          <target state="translated">Один общий экземпляр.</target>
        </trans-unit>
        <trans-unit id="c72b10055e71a8b6b107b05c7231e9b97b023ff1" translate="yes" xml:space="preserve">
          <source>The only accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">Единственными принятыми единицами являются &lt;code&gt;&quot;days&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5649b3ae07a628e1e89097ca2f1b006efdc1767" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, !, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8437a6599312b98a4f8ede285a1950b78c0b6f0d" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="translated">Единственные операторы, которые могут принимать операнды типа bool: &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1537443715ac19491a620a6f1ab8a8c13f12a2ec" translate="yes" xml:space="preserve">
          <source>The only pointers that are tracked are those declared in the &lt;code&gt;@live&lt;/code&gt; function as &lt;code&gt;this&lt;/code&gt;, function parameters or local variables. Variables from other functions are not tracked, even &lt;code&gt;@live&lt;/code&gt; ones, as the analysis of interactions with other functions depends entirely on that function signature, not its internals. Parameters that are &lt;code&gt;const&lt;/code&gt; are not tracked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984e1c71edfda04f82606405d232f57e26747587" translate="yes" xml:space="preserve">
          <source>The only reason to have a max limit for this is to avoid the risk of a bad server feeding libcurl with a never-ending header that will cause reallocs infinitely</source>
          <target state="translated">Единственная причина иметь максимальный лимит для этого-это избежать риска плохой подачи libcurl сервером с бесконечным заголовком,который будет бесконечно вызывать reallocs</target>
        </trans-unit>
        <trans-unit id="6b3469bf6885e1dc5e98c3245a18dbbf237d2baa" translate="yes" xml:space="preserve">
          <source>The opAssign function will be built for a struct &lt;code&gt;S&lt;/code&gt; if the following constraints are met:</source>
          <target state="translated">Функция opAssign будет построена для struct &lt;code&gt;S&lt;/code&gt; , если соблюдены следующие ограничения:</target>
        </trans-unit>
        <trans-unit id="7e056906d7315529b66ec021904f0bc134465c13" translate="yes" xml:space="preserve">
          <source>The operand syntax more or less follows the Intel CPU documentation conventions. In particular, the convention is that for two operand instructions the source is the right operand and the destination is the left operand. The syntax differs from that of Intel's in order to be compatible with the D language tokenizer and to simplify parsing.</source>
          <target state="translated">Синтаксис операндов более или менее соответствует соглашениям по документации на процессоры Intel.В частности,соглашение заключается в том,что для двух инструкций операндов источником является правый операнд,а получателем-левый операнд.Синтаксис отличается от синтаксиса Intel,что позволяет обеспечить совместимость с маркером языка D и упростить синтаксический разбор.</target>
        </trans-unit>
        <trans-unit id="73d4a21766587b932de571c9748f396e770947d7" translate="yes" xml:space="preserve">
          <source>The operands are AND'd together.</source>
          <target state="translated">Оперы идут вместе.</target>
        </trans-unit>
        <trans-unit id="8d68364ecd5a5efc98bbefe2167cf9e02f879955" translate="yes" xml:space="preserve">
          <source>The operands are OR'd together.</source>
          <target state="translated">Оперы вместе.</target>
        </trans-unit>
        <trans-unit id="164b0a5deb7171b65940816115319c8c761747b7" translate="yes" xml:space="preserve">
          <source>The operands are XOR'd together.</source>
          <target state="translated">Оперы-это XOR'd вместе.</target>
        </trans-unit>
        <trans-unit id="efb02cff4c27dc22b01308f5fbd88aaf28eb4b20" translate="yes" xml:space="preserve">
          <source>The operands must be arithmetic types. They undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Операнды должны быть арифметическими типами. Они проходят &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычные арифметические преобразования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d66ba90561dbdef784a715ae4ab9b7cee0e0776" translate="yes" xml:space="preserve">
          <source>The operands must be integral types, and undergo the &lt;a href=&quot;type#integer-promotions&quot;&gt;Integer Promotions&lt;/a&gt;. The result type is the type of the left operand after the promotions. The result value is the result of shifting the bits by the right operand's value.</source>
          <target state="translated">Операнды должны быть целочисленными типами и проходить &lt;a href=&quot;type#integer-promotions&quot;&gt;целочисленные продвижения&lt;/a&gt; . Тип результата - это тип левого операнда после повышения. Результирующее значение является результатом смещения битов на значение правого операнда.</target>
        </trans-unit>
        <trans-unit id="194f20d5a432fe368709d99fb1ac7743c7e38bcc" translate="yes" xml:space="preserve">
          <source>The operation takes time proportional to the number of adjacent free blocks at the front of the free list. These blocks get coalesced, whether &lt;code&gt;allocateAll&lt;/code&gt; succeeds or fails due to fragmentation.</source>
          <target state="translated">Операция занимает время, пропорциональное количеству смежных свободных блоков в начале списка свободных. Эти блоки получают коалесцированного, будь &lt;code&gt;allocateAll&lt;/code&gt; успех или неудачу из - за фрагментации.</target>
        </trans-unit>
        <trans-unit id="f1c4e404ec78b75726373485d13f7546b584f7c2" translate="yes" xml:space="preserve">
          <source>The operator involved</source>
          <target state="translated">Вовлеченный оператор</target>
        </trans-unit>
        <trans-unit id="56d4f8f0aeb6a713fa59381e88345eb1ab065529" translate="yes" xml:space="preserve">
          <source>The operator involved (without the &lt;code&gt;&quot;=&quot;&lt;/code&gt;, e.g. &lt;code&gt;&quot;+&quot;&lt;/code&gt; for &lt;code&gt;&quot;+=&quot;&lt;/code&gt; etc)</source>
          <target state="translated">Вовлеченный оператор (без &lt;code&gt;&quot;=&quot;&lt;/code&gt; , например, &lt;code&gt;&quot;+&quot;&lt;/code&gt; для &lt;code&gt;&quot;+=&quot;&lt;/code&gt; и т. Д.)</target>
        </trans-unit>
        <trans-unit id="141e2b7ce22914ac93e27f77aab194720297a6c0" translate="yes" xml:space="preserve">
          <source>The operator involved in the &lt;code&gt;opAssign&lt;/code&gt; operation</source>
          <target state="translated">Оператор, участвующий в операции &lt;code&gt;opAssign&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c70edf6dccf2f2bcea3add3cefb68aaf253c7966" translate="yes" xml:space="preserve">
          <source>The operator symbol</source>
          <target state="translated">Символ оператора</target>
        </trans-unit>
        <trans-unit id="a647036ebf74c7864e90900632a3906ffefe590e" translate="yes" xml:space="preserve">
          <source>The operator symbol (without the &lt;code&gt;=&lt;/code&gt;)</source>
          <target state="translated">Символ оператора (без &lt;code&gt;=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e53e52b5f08d1bbd687148f6992aae7c464c1b9d" translate="yes" xml:space="preserve">
          <source>The operator, e.g. &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">Оператор, например &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="638907907a566c0abcca8d70105d1f419f1a935d" translate="yes" xml:space="preserve">
          <source>The option &quot;--Foo&quot; is rejected due to &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt;, but not &quot;--Bar&quot;, &quot;--bAr&quot; etc. because the directive &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; turned sensitivity off before option &quot;bar&quot; was parsed.</source>
          <target state="translated">Параметр &amp;laquo;--Foo&amp;raquo; отклонен из-за &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt; , но не &amp;laquo;--Bar&amp;raquo;, &amp;laquo;--bAr&amp;raquo; и т. Д., Поскольку директива &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; отключила чувствительность перед параметром &amp;raquo; Бар &quot;был разобран.</target>
        </trans-unit>
        <trans-unit id="ca52d0f89f2c76dbc26910f2e62e7d1ae6cb85b2" translate="yes" xml:space="preserve">
          <source>The option character (default '-').</source>
          <target state="translated">Символ опции (по умолчанию '-').</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">Дополнительный</target>
        </trans-unit>
        <trans-unit id="2c9d42a79cf23316432c06818064db7b0873ce86" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; may be used to assign arbitrary &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; objects as the standard input, output and error streams, respectively, of the child process. The former must be opened for reading, while the latter two must be opened for writing. The default is for the child process to inherit the standard streams of its parent.</source>
          <target state="translated">Необязательные аргументы &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; могут использоваться для назначения произвольных объектов &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; в качестве стандартных потоков ввода, вывода и ошибок, соответственно, дочернего процесса. Первый должен быть открыт для чтения, а два последних должны быть открыты для записи. По умолчанию дочерний процесс наследует стандартные потоки своего родителя.</target>
        </trans-unit>
        <trans-unit id="fa35856038ac4a3b33d6b7f25cf0f4d58ca154fb" translate="yes" xml:space="preserve">
          <source>The optional identifier in either type of &lt;code&gt;out&lt;/code&gt; contract is set to the return value of the function.</source>
          <target state="translated">Необязательный идентификатор в любом типе &lt;code&gt;out&lt;/code&gt; контракта устанавливается равным возвращаемому значению функции.</target>
        </trans-unit>
        <trans-unit id="2a198d0d9bb81399553ce901d094fc3b34485c1e" translate="yes" xml:space="preserve">
          <source>The optional parameters &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt; are meant for avoiding duplicate computation. Many applications may have already computed &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; and/or &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt;. In that case, they can be passed as &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt;, respectively.</source>
          <target state="translated">Необязательные параметры &lt;code&gt;sSelfSim&lt;/code&gt; и &lt;code&gt;tSelfSim&lt;/code&gt; предназначены для избежания дублирования вычислений. Во многих приложениях уже могут быть вычислены &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; и / или &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt; . В этом случае они могут быть переданы как &lt;code&gt;sSelfSim&lt;/code&gt; и &lt;code&gt;tSelfSim&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="5c87a0f28ba13b43a3c29d6c4b297e44986adfc3" translate="yes" xml:space="preserve">
          <source>The optional second &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; can be used to supply additional information, such as a text string, that will be printed out along with the error diagnostic.</source>
          <target state="translated">Необязательное второе &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;выражение AssignExpression&lt;/i&gt;&lt;/a&gt; может использоваться для предоставления дополнительной информации, такой как текстовая строка, которая будет распечатана вместе с диагностикой ошибок.</target>
        </trans-unit>
        <trans-unit id="c53af2790b7d2658a475ec200743c6decbbbabb1" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;minSize == unbounded&lt;/code&gt; and &lt;code&gt;maxSize == unbounded&lt;/code&gt; are not available for &lt;code&gt;ContiguousFreeList&lt;/code&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;minSize == unbounded&lt;/code&gt; и &lt;code&gt;maxSize == unbounded&lt;/code&gt; недоступны для &lt;code&gt;ContiguousFreeList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908f73a8a6b26eae214ea14d01c95ac8e585a696" translate="yes" xml:space="preserve">
          <source>The options corresponding to the statistics collected.</source>
          <target state="translated">Опции,соответствующие собранной статистике.</target>
        </trans-unit>
        <trans-unit id="9f44bfb42bea099b410e3ae043b64bf941a3d3a9" translate="yes" xml:space="preserve">
          <source>The order in which</source>
          <target state="translated">Порядок,в котором</target>
        </trans-unit>
        <trans-unit id="b05eb5dee9e8e5735c1321572abe7fba26d328c8" translate="yes" xml:space="preserve">
          <source>The order in which modules are called to run their unit tests.</source>
          <target state="translated">Порядок вызова модулей для проведения юнит-тестов.</target>
        </trans-unit>
        <trans-unit id="ded62be1138c956a50d03fffedad7ec44e6f9533" translate="yes" xml:space="preserve">
          <source>The order in which modules are imported does not affect the semantics.</source>
          <target state="translated">Порядок импортирования модулей не влияет на семантику.</target>
        </trans-unit>
        <trans-unit id="506073a2cdf721a37f43310020509dea0ea03bee" translate="yes" xml:space="preserve">
          <source>The order in which the array elements are computed is implementation defined, and may even occur in parallel. An application must not depend on this order.</source>
          <target state="translated">Порядок,в котором вычисляются элементы массива,определен,и может даже происходить параллельно.Приложение не должно зависеть от этого порядка.</target>
        </trans-unit>
        <trans-unit id="fae272dd73f8d57ce9c199e28861d6ffb1d9af6c" translate="yes" xml:space="preserve">
          <source>The order in which the strings appear in the result is not defined.</source>
          <target state="translated">Порядок,в котором строки появляются в результате,не определен.</target>
        </trans-unit>
        <trans-unit id="ce7e17de4cb24469d3444a40e36096efcb9cbfd4" translate="yes" xml:space="preserve">
          <source>The order is defined as follows:</source>
          <target state="translated">Порядок определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="29a373653e2bfc1cca0d961f259da0c1298ecbea" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments for functions with linkage other than &lt;code&gt;extern (D)&lt;/code&gt;.</source>
          <target state="translated">Порядок вычисления аргументов функции для функций со связью, отличной от &lt;code&gt;extern (D)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a021fc1e222d6a27aea27e4b5f97128841b9a128" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Порядок вычисления операндов &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d093662468f96c13ae9c5b9d6116c7cabff1635" translate="yes" xml:space="preserve">
          <source>The order of execution within a function is controlled by &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statement&lt;/i&gt;&lt;/a&gt;s. A function's body consists of a sequence of zero or more</source>
          <target state="translated">Порядок исполнения в рамках функции контролируется &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Заявление&lt;/i&gt;&lt;/a&gt; s. Тело функции состоит из последовательности из нуля или более</target>
        </trans-unit>
        <trans-unit id="86b67a2b0c6a048e601645470c096d4bbf2604b6" translate="yes" xml:space="preserve">
          <source>The order of static initialization is implicitly determined by the</source>
          <target state="translated">Порядок статической инициализации неявно определяется</target>
        </trans-unit>
        <trans-unit id="24e23dd7191b5b1c5bce0de2b67d0f3911ebed53" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum) element.</source>
          <target state="translated">Предикат заказа для определения экстремумального (минимального или максимального)элемента.</target>
        </trans-unit>
        <trans-unit id="15fe5b10e5755a86213c0dc1ab135ad913a77ba2" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum).</source>
          <target state="translated">Предикат заказа,используемый для определения экстремумального значения (минимального или максимального).</target>
        </trans-unit>
        <trans-unit id="15cad23161bf9aec9c429568dd291ae988b53252" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the maximum element.</source>
          <target state="translated">Предикат заказа для определения максимального элемента.</target>
        </trans-unit>
        <trans-unit id="c31f591c19316494ae227e4269b1bc55d8071c12" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the minimum element.</source>
          <target state="translated">Предикат заказа для определения минимального элемента.</target>
        </trans-unit>
        <trans-unit id="c29760283ce7793aa4d7bc71616456fe1b03fbb5" translate="yes" xml:space="preserve">
          <source>The ordering to be used to determine lexicographical ordering of the permutations.</source>
          <target state="translated">Порядок,используемый для определения лексикографического порядка перестановок.</target>
        </trans-unit>
        <trans-unit id="e1d7ba6a0bf70661c8825f1616095c8946712ba1" translate="yes" xml:space="preserve">
          <source>The original input string which should have been parsed.</source>
          <target state="translated">Оригинальная входная строка,которая должна была быть разобрана.</target>
        </trans-unit>
        <trans-unit id="d69e475dd9b96313d02abbca4307d1659af41d28" translate="yes" xml:space="preserve">
          <source>The original range.</source>
          <target state="translated">Оригинальный ассортимент.</target>
        </trans-unit>
        <trans-unit id="8724db772d60fec4013f34182f1e847ecec76068" translate="yes" xml:space="preserve">
          <source>The original string.</source>
          <target state="translated">Оригинальная строка.</target>
        </trans-unit>
        <trans-unit id="59de85bb0dd2a62ce448e919359e8b24cc7a90ea" translate="yes" xml:space="preserve">
          <source>The osthread module provides low-level, OS-dependent code for thread creation and management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0e83de5dd344b677213345fa51e9db2eed3ab8" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ClockType&lt;/code&gt;s are provided so that other clocks provided by the underlying C, system calls can be used with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; without having to use the C API directly.</source>
          <target state="translated">Другие &lt;code&gt;ClockType&lt;/code&gt; предоставляются таким образом, чтобы другие часы, предоставляемые базовыми системными вызовами C, могли использоваться с &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; без необходимости непосредственного использования API C.</target>
        </trans-unit>
        <trans-unit id="c97e71bfcc50324ba20390fc9837bc308a37f3b9" translate="yes" xml:space="preserve">
          <source>The other piece of data used is the DWARF &lt;code&gt;.debug_line&lt;/code&gt; section, which contains the line informations of a program, necessary to associate the instruction address with its (file, line) information.  Since debug lines informations are quite large, they are encoded using a program that is to be fed to a finite state machine. See &lt;code&gt;runStateMachine&lt;/code&gt; and &lt;code&gt;readLineNumberProgram&lt;/code&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="a69373623c7518d00fa36ea24366f398f8ce8bad" translate="yes" xml:space="preserve">
          <source>The output of the code above is:</source>
          <target state="translated">Вывод кода выше:</target>
        </trans-unit>
        <trans-unit id="515b77d0f9f95e74d1d9b053ac5339be1c82aca5" translate="yes" xml:space="preserve">
          <source>The output range used to write the help information.</source>
          <target state="translated">Диапазон выхода,используемый для записи справочной информации.</target>
        </trans-unit>
        <trans-unit id="708e6e32f4bb4d910b35568c24af1ecbdd8ae5b7" translate="yes" xml:space="preserve">
          <source>The overflow indicator (assigned &lt;code&gt;true&lt;/code&gt; in case there's an error)</source>
          <target state="translated">Индикатор переполнения (присваивается значение &lt;code&gt;true&lt;/code&gt; в случае ошибки)</target>
        </trans-unit>
        <trans-unit id="49d360d20fd79e75a1f6f41c1f5efdbc589a5b18" translate="yes" xml:space="preserve">
          <source>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end.</source>
          <target state="translated">Переполнение является липким,то есть последовательность операций может быть выполнена,а переполнение нужно проверять только в конце.</target>
        </trans-unit>
        <trans-unit id="ef93ac8e948c5ada2f00084b4ec036473c66f367" translate="yes" xml:space="preserve">
          <source>The overlapping portion of the two arrays.</source>
          <target state="translated">Перекрывающаяся часть двух массивов.</target>
        </trans-unit>
        <trans-unit id="fae150090ecb0366b43d58bfc4a6f3010da8d11c" translate="yes" xml:space="preserve">
          <source>The overload which accepts function arguments takes integral types in the order that the time unit strings were given, and those integers are passed by &lt;code&gt;ref&lt;/code&gt;. split assigns the values for the units to each corresponding integer. Any integral type may be used, but no attempt is made to prevent integer overflow, so don't use small integral types in circumstances where the values for those units aren't likely to fit in an integral type that small.</source>
          <target state="translated">Перегрузка, которая принимает аргументы функции, принимает целочисленные типы в том порядке, в котором были заданы строки единицы времени, и эти целые числа передаются с помощью &lt;code&gt;ref&lt;/code&gt; . split присваивает значения единиц измерения каждому соответствующему целому числу. Можно использовать любой целочисленный тип, но не делается попытка предотвратить переполнение целых чисел, поэтому не используйте маленькие целочисленные типы в обстоятельствах, когда значения для этих единиц вряд ли будут соответствовать целочисленному типу, который так мал.</target>
        </trans-unit>
        <trans-unit id="8a27d36415963d11bb0a2a74d725380e58b5b81a" translate="yes" xml:space="preserve">
          <source>The overload with no arguments returns the values for the units in a struct with members whose names are the same as the given time unit strings. The members are all &lt;code&gt;long&lt;/code&gt;s. This overload will also work with no time strings being given, in which case</source>
          <target state="translated">Перегрузка без аргументов возвращает значения для единиц в структуре с членами, имена которых совпадают с заданными строками единиц времени. Участники все &lt;code&gt;long&lt;/code&gt; с. Эта перегрузка также будет работать без указания временных строк, в этом случае</target>
        </trans-unit>
        <trans-unit id="36651e7ea0b89af408ad5149a0f7f1de2f23e2a1" translate="yes" xml:space="preserve">
          <source>The owner is the sole pointer to a memory object graph. An Owner pointer normally does not have a &lt;code&gt;scope&lt;/code&gt; attribute. If a pointer with the &lt;code&gt;scope&lt;/code&gt; attribute is initialized with an expression not derived from a tracked pointer, it is an Owner.  If an Owner pointer is assigned to another Owner pointer, the former enters the Undefined state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260af145e3cbda28a26f16fe1989f4e1c8d1a0d0" translate="yes" xml:space="preserve">
          <source>The package module can then be imported with the standard module import declaration:</source>
          <target state="translated">Пакетный модуль может быть импортирован со стандартной декларацией импорта модуля:</target>
        </trans-unit>
        <trans-unit id="5512330e5fcd74efc6dbc5aca616099f51685035" translate="yes" xml:space="preserve">
          <source>The package module must have the file name &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="translated">Модуль пакета должен иметь имя файла &lt;code&gt;package.d&lt;/code&gt; . Имя модуля объявляется как полное имя пакета. Модули пакетов можно импортировать так же, как и любые другие модули:</target>
        </trans-unit>
        <trans-unit id="e03b2152cc1b6a58ba8032733b5d2def3eb73480" translate="yes" xml:space="preserve">
          <source>The package module's file name must be &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136770d3c4f96881a7cd83ac52b3b200de071989" translate="yes" xml:space="preserve">
          <source>The padding data can be accessed, but its contents are undefined.</source>
          <target state="translated">Доступ к данным подкладки возможен,но ее содержание не определено.</target>
        </trans-unit>
        <trans-unit id="c23637ad29e92d690ee7e91ffa4bbac52dae1105" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;level&lt;/code&gt; indicates the number of trie levels to use, allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs speed-size wise.</source>
          <target state="translated">Параметр &lt;code&gt;level&lt;/code&gt; указывает число уровней TRIE для использования, допустимые значения: 1, 2, 3 или 4. Уровни представляют собой различные компромиссы скорости размера мудрым.</target>
        </trans-unit>
        <trans-unit id="0ee7ae2b2ebe38b1747e38029361876a0bcd2e42" translate="yes" xml:space="preserve">
          <source>The parameter is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14dbb4daa817a9a1b69f1e2b66e17c6c825d9628" translate="yes" xml:space="preserve">
          <source>The parameter is an input to the function. Input parameters behaves as if they have the &lt;code&gt;const scope&lt;/code&gt; storage classes. Input parameters may be passed by reference by the compiler. Unlike &lt;code&gt;ref&lt;/code&gt; parameters, &lt;code&gt;in&lt;/code&gt; parameters can bind to both lvalues and rvalues (such as literals). Types that would trigger a side effect if passed by value (such as types with postblit, copy constructor, or destructor), and types which cannot be copied, e.g. if their copy constructor is marked as &lt;code&gt;@disable&lt;/code&gt;, will always be passed by reference. Dynamic arrays, classes, associative arrays, function pointers, and delegates will always be passed by value, to allow for covariance. If the type of the parameter does not fall in one of those categories, whether or not it is passed by reference is implementation defined, and the backend is free to choose the method that will best fit the ABI of the platform. Note: This requires the &lt;code&gt;-preview=in&lt;/code&gt; switch, available in v2.094.0 or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0758911fe007939762ea0a98ab73ee500552cb01" translate="yes" xml:space="preserve">
          <source>The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, &lt;code&gt;byChunk&lt;/code&gt; accepts a user-provided buffer that it uses directly.</source>
          <target state="translated">Параметр может быть числом (как показано в примере выше), определяющим размер каждого чанка. В качестве альтернативы, &lt;code&gt;byChunk&lt;/code&gt; принимает предоставленный пользователем буфер, который он использует напрямую.</target>
        </trans-unit>
        <trans-unit id="3a7b9fcbdd08c7e12be96a35248bec20128f934f" translate="yes" xml:space="preserve">
          <source>The parameter must not escape the function call (e.g. by being assigned to a global variable). Ignored for any parameter that is not a reference type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7a5827114de776669ef80597ccf4da04a43fa6" translate="yes" xml:space="preserve">
          <source>The parameter will be a mutable copy of its argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c903948dffd2abfd68770b5195aac5d542b83003" translate="yes" xml:space="preserve">
          <source>The parameters of this distribution. The random number is x = (x * multipler + increment) % modulus.</source>
          <target state="translated">Параметры этого распределения.Случайное число x=(x*умножение+приращение)% модуль.</target>
        </trans-unit>
        <trans-unit id="2c7bb35e4246e498ccd1516d5c0a045c041414c6" translate="yes" xml:space="preserve">
          <source>The parameters to the non-variadic function:</source>
          <target state="translated">Параметры к не-вариантной функции:</target>
        </trans-unit>
        <trans-unit id="8c00f330278c8a3688d755f58c6ef387d6c281e7" translate="yes" xml:space="preserve">
          <source>The parameters to the variadic function:</source>
          <target state="translated">Параметры для вариадической функции:</target>
        </trans-unit>
        <trans-unit id="5ebad486f6049114c19bd433cacf524aaf10fabc" translate="yes" xml:space="preserve">
          <source>The parameters with which to instantiate the template.</source>
          <target state="translated">Параметры,с помощью которых можно инстанцировать шаблон.</target>
        </trans-unit>
        <trans-unit id="4fbe12ec5cf422714865a37fd1864dec27719969" translate="yes" xml:space="preserve">
          <source>The parent allocator is publicly accessible either as a direct member if it holds state, or as an alias to &lt;code&gt;Allocator.instance&lt;/code&gt; otherwise. One may use it for making calls that won't count toward statistics collection.</source>
          <target state="translated">Родительский распределитель общедоступен либо как прямой член, если он содержит состояние, либо как псевдоним &lt;code&gt;Allocator.instance&lt;/code&gt; в противном случае. Можно использовать его для звонков, которые не будут учитываться при сборе статистики.</target>
        </trans-unit>
        <trans-unit id="a7916e9fe1cbcecc9e5b2265b50cee59f409bc09" translate="yes" xml:space="preserve">
          <source>The parent allocator. Depending on whether &lt;code&gt;ParentAllocator&lt;/code&gt; holds state or not, this is a member variable or an alias for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Родительский распределитель. В зависимости от того, содержит ли &lt;code&gt;ParentAllocator&lt;/code&gt; состояние или нет, это переменная-член или псевдоним для &lt;code&gt;ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a766f10bdfc11306f72dafd5b728bd7317c675f" translate="yes" xml:space="preserve">
          <source>The parser initially sets it to TOK.concatenateAssign, and semantic() later decides which of the three it will be set to.</source>
          <target state="translated">Сначала синтаксический анализатор устанавливает его в TOK.concatenateAssign,а затем семантическая()решает,в какую из трех точек он будет установлен.</target>
        </trans-unit>
        <trans-unit id="8ca59cb5bd26311e5307aeb5f44c313335ea3580" translate="yes" xml:space="preserve">
          <source>The passed in input was correct, but more input was expected.</source>
          <target state="translated">Переданный вход был правильным,но ожидалось больше входных данных.</target>
        </trans-unit>
        <trans-unit id="04a94fe6ab7793bd68edc946edd3c4d4f906c623" translate="yes" xml:space="preserve">
          <source>The passed text will be printed first, followed by a newline, then the short and long version of every option will be printed. The short and long version will be aligned to the longest option of every &lt;code&gt;Option&lt;/code&gt; passed. If the option is required, then &quot;Required:&quot; will be printed after the long version of the &lt;code&gt;Option&lt;/code&gt;. If a help message is present it will be printed next. The format is illustrated by this code:</source>
          <target state="translated">Переданный текст будет напечатан первым, за которым следует новая строка, а затем будет напечатана короткая и длинная версия каждой опции. Короткая и длинная версия будут выровнены по самой длинной опции из всех переданных &lt;code&gt;Option&lt;/code&gt; . Если опция обязательна, то после обязательной версии &lt;code&gt;Option&lt;/code&gt; будет напечатано &amp;laquo;Required:&amp;raquo; . Если имеется справочное сообщение, оно будет напечатано следующим. Формат иллюстрируется этим кодом:</target>
        </trans-unit>
        <trans-unit id="ae0176808c4338a2b32bdc055054955a47109b3c" translate="yes" xml:space="preserve">
          <source>The path given by &lt;code&gt;path&lt;/code&gt;, with the extension given by &lt;code&gt;ext&lt;/code&gt; appended if the path doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when path is immutable and already has an extension.</source>
          <target state="translated">Путь, заданный &lt;code&gt;path&lt;/code&gt; , с расширением, заданным &lt;code&gt;ext&lt;/code&gt; , добавляется, если у пути его еще нет. Включение точки в расширение необязательно. Эта функция всегда выделяет новую строку, за исключением случая, когда путь неизменен и уже имеет расширение.</target>
        </trans-unit>
        <trans-unit id="9978fd2b7b1c58a32b59d2d933a84ff2eeb9cad1" translate="yes" xml:space="preserve">
          <source>The path name to expand.</source>
          <target state="translated">Имя пути для расширения.</target>
        </trans-unit>
        <trans-unit id="dba74006c9911dd825361c79175c3816c02f4fd6" translate="yes" xml:space="preserve">
          <source>The path of the executable as a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Путь к исполняемому файлу в виде &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c35dcd32a0cd2b956596caddc202c46a4ae3354" translate="yes" xml:space="preserve">
          <source>The path to be matched against</source>
          <target state="translated">Путь,который должен быть сопоставлен</target>
        </trans-unit>
        <trans-unit id="a5d7f6c37fe93af27b88af304f713208b3e7e43a" translate="yes" xml:space="preserve">
          <source>The path to the file.</source>
          <target state="translated">Путь к файлу.</target>
        </trans-unit>
        <trans-unit id="b9caa4476a8447e566c7b52e6155891828512bf8" translate="yes" xml:space="preserve">
          <source>The path to the shell to use to run the specified program. By default this is &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Путь к оболочке, используемой для запуска указанной программы. По умолчанию это &lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a791a6dee2401c3ac563dc595efe14cc5ee858e9" translate="yes" xml:space="preserve">
          <source>The permutation to permutate &lt;code&gt;range&lt;/code&gt; to.</source>
          <target state="translated">Перестановка для перестановки &lt;code&gt;range&lt;/code&gt; до.</target>
        </trans-unit>
        <trans-unit id="3bf6df59e4efc6178ad86ce4d172dd74e35f57bc" translate="yes" xml:space="preserve">
          <source>The permuted range.</source>
          <target state="translated">Пересеченный диапазон.</target>
        </trans-unit>
        <trans-unit id="b51b8abc388ed1faa0574f36244673bca9d03127" translate="yes" xml:space="preserve">
          <source>The pivot element.</source>
          <target state="translated">Шарнирный элемент.</target>
        </trans-unit>
        <trans-unit id="2141dbd9249b3127ee2311abb3285ea6f62646d8" translate="yes" xml:space="preserve">
          <source>The plan is to support all of the above except throwing D exceptions directly in C++ code (but they will be throwable indirectly by calling into a D function with C++ linkage).</source>
          <target state="translated">Планируется поддерживать все вышеперечисленное,за исключением бросания исключений D непосредственно в Си++код (но они будут бросаться косвенно при вызове в функцию D со связкой на Си++).</target>
        </trans-unit>
        <trans-unit id="5e9fcc91fd47a551fe2c3ec3018788e0626a6afc" translate="yes" xml:space="preserve">
          <source>The platform-specific native shell path.</source>
          <target state="translated">Нативный путь оболочки для конкретной платформы.</target>
        </trans-unit>
        <trans-unit id="c744ae6de5a0c2342c1ec26c71bf9d84af5482c5" translate="yes" xml:space="preserve">
          <source>The point is to allow AliasDeclarationY to use &lt;code&gt;__traits()&lt;/code&gt;, see issue 7804.</source>
          <target state="translated">Суть в том, чтобы разрешить AliasDeclarationY использовать &lt;code&gt;__traits()&lt;/code&gt; , см. Проблему 7804.</target>
        </trans-unit>
        <trans-unit id="0b4bb95d6a8d2b3e99a53954eaab5d58c7eb10b4" translate="yes" xml:space="preserve">
          <source>The pointer</source>
          <target state="translated">Указатель</target>
        </trans-unit>
        <trans-unit id="cf7acba2bb0e0c6f04c4c0cb72022cca37ae2438" translate="yes" xml:space="preserve">
          <source>The pointer is in an invalid state. Dereferencing such a pointer is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5b5206507758892b71f3f58e5e23e1c1f7f65c" translate="yes" xml:space="preserve">
          <source>The pointer, dynamic array, or reference is set to &lt;code&gt;null&lt;/code&gt; after the delete is performed. Any attempt to reference the data after the deletion via another reference to it will result in undefined behavior.</source>
          <target state="translated">Указатель, динамический массив или ссылка устанавливаются в &lt;code&gt;null&lt;/code&gt; после выполнения удаления. Любая попытка обратиться к данным после удаления с помощью другой ссылки на них приведет к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="594f71d424c88492080e5062a3ecf8853308a43e" translate="yes" xml:space="preserve">
          <source>The pointer-based version returns a &lt;code&gt;SortedRange&lt;/code&gt; wrapper over index, of type &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; thus reflecting the ordering of the index. The index-based version returns &lt;code&gt;void&lt;/code&gt; because the ordering relation involves not only &lt;code&gt;index&lt;/code&gt; but also &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Основанная на указателе версия возвращает оболочку &lt;code&gt;SortedRange&lt;/code&gt; над индексом типа &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; отражая, таким образом, порядок индекса. Версия на основе индекса возвращает &lt;code&gt;void&lt;/code&gt; , поскольку отношение упорядочения включает в себя не только &lt;code&gt;index&lt;/code&gt; но и &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c0b6520bd81ff00673e639fb3748bb290589c44" translate="yes" xml:space="preserve">
          <source>The policy to use.</source>
          <target state="translated">Политика,которую нужно использовать.</target>
        </trans-unit>
        <trans-unit id="5bfa0d8b059a39ab26c6f284f964719eecf94f69" translate="yes" xml:space="preserve">
          <source>The policy used by this mutex.</source>
          <target state="translated">Политика,используемая этим мьютексом.</target>
        </trans-unit>
        <trans-unit id="8629893a44c9c276074edd00bae067e6b519cbda" translate="yes" xml:space="preserve">
          <source>The position in &lt;code&gt;array&lt;/code&gt; to insert the &lt;code&gt;stuff&lt;/code&gt;.</source>
          <target state="translated">Позиция в &lt;code&gt;array&lt;/code&gt; для вставки &lt;code&gt;stuff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9eb86610993ddd6856217e1e6d70c91e6f75dbc" translate="yes" xml:space="preserve">
          <source>The position in the input string where the error occurred.</source>
          <target state="translated">Позиция во входной строке,где произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="f421096d1588c50f7ea09d98220627162688c28b" translate="yes" xml:space="preserve">
          <source>The position of the minimum (respectively maximum) element of forward range &lt;code&gt;range&lt;/code&gt;, i.e. a subrange of &lt;code&gt;range&lt;/code&gt; starting at the position of its smallest (respectively largest) element and with the same ending as &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Положение минимума (соответственно максимума) элемента переднего диапазона &lt;code&gt;range&lt;/code&gt; , т.е. поддиапазоне &lt;code&gt;range&lt;/code&gt; , начиная с позиции его наименьшего (соответственно) по величине элемента и с тем же окончанием в качестве &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51fc654e8d5c11108a73d4836e9e77c133dfb257" translate="yes" xml:space="preserve">
          <source>The possible states of the &lt;code&gt;Ternary&lt;/code&gt;</source>
          <target state="translated">Возможные состояния &lt;code&gt;Ternary&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c6cabbb86643a051bf73c292aa98533c672138" translate="yes" xml:space="preserve">
          <source>The possible targets are computed more conservatively than the language allows, eliminating all dangerous conversions. For example, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; does not include &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">Возможные цели вычисляются более консервативно, чем позволяет язык, исключая все опасные преобразования. Например, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; не включает &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d29604df18454624b74cfa89078e0417260306" translate="yes" xml:space="preserve">
          <source>The possible values for units are &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, (microseconds), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds, i.e. 100 ns), and &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">Возможные значения для единиц измерения: &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; , &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (миллисекунды), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; , (микросекунды), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (гекто-наносекунды, т.е. 100 нс) и &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4f82ffde3ae1f423f2307932836a1e645ef668" translate="yes" xml:space="preserve">
          <source>The postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; and &lt;code&gt;__aggrPostblit&lt;/code&gt; are generated without any implicit qualifiers and are not considered struct members. This leads to the situation where qualifying an entire struct declaration with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; does not have any impact on the above-mentioned postblits. However, since &lt;code&gt;__xpostblit&lt;/code&gt; is a member of the struct and an alias of one of the other postblits, the qualifiers applied to the struct will affect the aliased postblit.</source>
          <target state="translated">Постблиты &lt;code&gt;__fieldPostblit&lt;/code&gt; и &lt;code&gt;__aggrPostblit&lt;/code&gt; генерируются без каких-либо неявных квалификаторов и не считаются членами структуры. Это приводит к ситуации, когда квалификация объявления всей структуры с помощью &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; не влияет на вышеупомянутые постблиты. Однако, поскольку &lt;code&gt;__xpostblit&lt;/code&gt; является членом структуры и псевдонимом одного из других постблитов, квалификаторы, примененные к структуре, будут влиять на псевдоним постблитов.</target>
        </trans-unit>
        <trans-unit id="d47161252adc52b1f430344a53bb4997710446f2" translate="yes" xml:space="preserve">
          <source>The power modulus value of (base ^ exponent) % modulus.</source>
          <target state="translated">Значение модуля мощности (базовый ^экспонент)%.</target>
        </trans-unit>
        <trans-unit id="309c3d73f76b800f2ba5fd6059ce5bcf824a5c98" translate="yes" xml:space="preserve">
          <source>The pre contracts specify the preconditions before a statement is executed. The most typical use of this would be in validating the parameters to a function. The post contracts validate the result of the statement. The most typical use of this would be in validating the return value of a function and of any side effects it has. In D, pre contracts begin with &lt;code&gt;in&lt;/code&gt;, and post contracts begin with &lt;code&gt;out&lt;/code&gt;. They come at the end of the function signature and before the opening brace of the function body.</source>
          <target state="translated">Предварительные контракты определяют предварительные условия перед выполнением оператора. Наиболее типичное использование этого было бы в проверке параметров функции. Почтовые контракты подтверждают результат заявления. Наиболее типичное использование этого было бы в проверке возвращаемого значения функции и любых побочных эффектов, которые это имеет. В D предварительные контракты начинаются с &lt;code&gt;in&lt;/code&gt; , а последующие контракты начинаются с &lt;code&gt;out&lt;/code&gt; . Они идут в конце сигнатуры функции и перед открывающей фигурной скобкой тела функции.</target>
        </trans-unit>
        <trans-unit id="bad3757e2d3ea8e03615372cc42932fa498e0342" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;less&lt;/code&gt; defines the lexicographical ordering to be used on the range.</source>
          <target state="translated">Предикат &lt;code&gt;less&lt;/code&gt; определяет лексикографический порядок, который будет использоваться в диапазоне.</target>
        </trans-unit>
        <trans-unit id="75eafad6126e4b32c7a8770becfcb1f1b009b4fa" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;pred&lt;/code&gt; needs to accept an element of &lt;code&gt;r&lt;/code&gt; and the separator &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Предикат &lt;code&gt;pred&lt;/code&gt; должен принимать элемент &lt;code&gt;r&lt;/code&gt; и разделитель &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73639f6f297aaeaa7398fc5473b39c5c235bf984" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the needle, defaulting to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The negated predicate &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; can be used to search instead for the first element</source>
          <target state="translated">Предикат для сравнения каждого элемента с иглой, по умолчанию равен равенству &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; . Отрицательный предикат &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; можно использовать для поиска первого элемента</target>
        </trans-unit>
        <trans-unit id="ad19c283f2ff0ef86cf40f35fd842064c7bd010d" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the separator, defaulting to &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">Предикат для сравнения каждого элемента с разделителем, по умолчанию &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5a87643179e233709de5c2f1a144d80a09a77b5" translate="yes" xml:space="preserve">
          <source>The predicate for deciding where to split the range when no separator is passed</source>
          <target state="translated">Предикат для принятия решения о том,где разделить диапазон,когда сепаратор не пройден.</target>
        </trans-unit>
        <trans-unit id="e35b33251882d624f933a2c1b64ccb5eb65ade7b" translate="yes" xml:space="preserve">
          <source>The predicate for determining when to stop counting.</source>
          <target state="translated">Предикат для определения,когда остановить подсчет.</target>
        </trans-unit>
        <trans-unit id="0c33296dd22cd76b6c27b1beb8636640e4665dda" translate="yes" xml:space="preserve">
          <source>The predicate is expected to satisfy certain rules in order for &lt;code&gt;sort&lt;/code&gt; to behave as expected - otherwise, the program may fail on certain inputs (but not others) when not compiled in release mode, due to the cursory &lt;code&gt;assumeSorted&lt;/code&gt; check. Specifically, &lt;code&gt;sort&lt;/code&gt; expects &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; to imply &lt;code&gt;less(a,c)&lt;/code&gt; (transitivity), and, conversely, &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; to imply &lt;code&gt;!less(a,c)&lt;/code&gt;. Note that the default predicate (&lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;) does not always satisfy these conditions for floating point types, because the expression will always be &lt;code&gt;false&lt;/code&gt; when either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is NaN. Use &lt;a href=&quot;std_math#cmp&quot;&gt;&lt;code&gt;std.math.cmp&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Предполагается, что предикат будет удовлетворять определенным правилам, чтобы &lt;code&gt;sort&lt;/code&gt; &lt;code&gt;assumeSorted&lt;/code&gt; образом - в противном случае программа может не работать на определенных входных данных (но не на других), если они не скомпилированы в режиме выпуска, из-за поверхностной проверки acceptSorted . В частности, &lt;code&gt;sort&lt;/code&gt; предполагает , что &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; означает &lt;code&gt;less(a,c)&lt;/code&gt; (транзитивность) и, наоборот &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; подразумевает &lt;code&gt;!less(a,c)&lt;/code&gt; . Обратите внимание, что предикат по умолчанию ( &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; ) не всегда удовлетворяет этим условиям для типов с плавающей запятой, потому что выражение всегда будет &lt;code&gt;false&lt;/code&gt; когда &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; является NaN. &lt;a href=&quot;std_math#cmp&quot;&gt; &lt;code&gt;std.math.cmp&lt;/code&gt; &lt;/a&gt; этого используйте std.math.cmp .</target>
        </trans-unit>
        <trans-unit id="27f1015c9d3c968b66e69f35344a3e7b0807ccce" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; and accepts any callable function that can be executed via &lt;code&gt;pred(element, s)&lt;/code&gt;.</source>
          <target state="translated">Предикат передается в &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; и принимает любую вызываемую функцию, которая может быть выполнена через &lt;code&gt;pred(element, s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2040ad77d27bfa42d579b0732a628553443b56b4" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;.</source>
          <target state="translated">Предикат передается в &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; и может принимать строку или любой вызываемый объект, который может быть выполнен с помощью &lt;code&gt;pred(element, element)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1cc6d6782bb5ddbb272e878b0a97cd35ebd9643" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">Предикат передается в &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt; и может принимать строку или любой вызываемый объект, который может быть выполнен с помощью &lt;code&gt;pred(element)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b49793439ff4c8d008cc1bf8471d003e4d8abc" translate="yes" xml:space="preserve">
          <source>The predicate that determines whether elements from each respective range match. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">Предикат, который определяет, совпадают ли элементы из каждого соответствующего диапазона. По умолчанию равенство &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11c0e0e174294f0d039166c9a6e153edb402dcf7" translate="yes" xml:space="preserve">
          <source>The predicate that the range should be partitioned by.</source>
          <target state="translated">Предикат,на который следует разделить диапазон.</target>
        </trans-unit>
        <trans-unit id="efb36bba668de1092c1769f6aab990aa0cb00922" translate="yes" xml:space="preserve">
          <source>The predicate the ranges are sorted by.</source>
          <target state="translated">Предикат диапазонов отсортирован.</target>
        </trans-unit>
        <trans-unit id="87bdd1f3ad180a36d78f0b0a9fe20115fabf7d4e" translate="yes" xml:space="preserve">
          <source>The predicate to evaluate.</source>
          <target state="translated">Предикат для оценки.</target>
        </trans-unit>
        <trans-unit id="793b27dece0d99ba7788014f7bf7dd0fb1085592" translate="yes" xml:space="preserve">
          <source>The predicate to partition by.</source>
          <target state="translated">Предикат к разделу по.</target>
        </trans-unit>
        <trans-unit id="d5491576ad03ca04a8526c028f920296327ac77a" translate="yes" xml:space="preserve">
          <source>The predicate to satisfy.</source>
          <target state="translated">Предикат для удовлетворения.</target>
        </trans-unit>
        <trans-unit id="c929e818343f11140b434407d7b74c242dda71fa" translate="yes" xml:space="preserve">
          <source>The predicate to sort by.</source>
          <target state="translated">Предикат для сортировки по.</target>
        </trans-unit>
        <trans-unit id="1d648ec381e9cf43fb0241bd298676f64d9af32e" translate="yes" xml:space="preserve">
          <source>The predicate to sort the transformed elements by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04024868be7f287d2663bbef1dbf103a8da3cc6b" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements between the range and the needle(s).</source>
          <target state="translated">Предикат,используемый для сравнения элементов между диапазоном и иглой (иглами).</target>
        </trans-unit>
        <trans-unit id="28f32071ce8ed6579de4bc0673c1fb09d434c803" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements.</source>
          <target state="translated">Предикат,используемый для сравнения элементов.</target>
        </trans-unit>
        <trans-unit id="8e5598b5509b9c6eafc0eab8a5a91702947d0e63" translate="yes" xml:space="preserve">
          <source>The predicate to use for determining a match.</source>
          <target state="translated">Предикат,используемый для определения соответствия.</target>
        </trans-unit>
        <trans-unit id="89fd4b4f61967cf71a560e54be19f8d76cbb1cde" translate="yes" xml:space="preserve">
          <source>The predicate to use for the rearrangement.</source>
          <target state="translated">Предикат для перестановки.</target>
        </trans-unit>
        <trans-unit id="aafedf7f211b6bcd89cdb1a78ec67451cd224b87" translate="yes" xml:space="preserve">
          <source>The predicate to use in comparing elements for commonality. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">Предикат для использования при сравнении элементов на общность. По умолчанию равенство &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d6ef6e2289f7e8b2fa887a80d23adf75d1641e1" translate="yes" xml:space="preserve">
          <source>The predicate used for comparison, modeled as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt; strict weak ordering&lt;/a&gt; (irreflexive, antisymmetric, transitive, and implying a transitive equivalence)</source>
          <target state="translated">Предикат, используемый для сравнения, смоделирован как &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt;строгий слабый порядок&lt;/a&gt; (нерефлексивный, антисимметричный, транзитивный и подразумевающий транзитивную эквивалентность)</target>
        </trans-unit>
        <trans-unit id="7f8c0f3692256237f756958104cf2f7dfb39d06e" translate="yes" xml:space="preserve">
          <source>The predicate used to compare the values.</source>
          <target state="translated">Предикат,используемый для сравнения значений.</target>
        </trans-unit>
        <trans-unit id="97370c26d71acf94352a17fb62d152e3830e5289" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a false result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">Предикаты оцениваются слева направо,прерывая оценку коротким путем при обнаружении ложного результата,и в этом случае последние не нуждаются в компиляции.</target>
        </trans-unit>
        <trans-unit id="1d7464c6a5c260ac34ab99c016228d6b560c3e52" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a true result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">Предикаты оцениваются слева направо,прерывая оценку коротким путем,если встречается истинный результат,и в этом случае последние не нуждаются в компиляции.</target>
        </trans-unit>
        <trans-unit id="c330fdecec36e8afd7824dda6b681cda50cda735" translate="yes" xml:space="preserve">
          <source>The preferred way to do memory management in Objective-C is to use Automatic Reference Counting, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;. This is not supported in D, therefore manual memory management is required to be used instead. This is achieved by calling &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; on an Objective-C instance, like in the old days of Objective-C.</source>
          <target state="translated">Предпочтительным способом управления памятью в Objective-C является использование автоматического подсчета ссылок, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; . Это не поддерживается в D, поэтому необходимо использовать ручное управление памятью. Это достигается путем вызова &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; для экземпляра Objective-C, как в старые времена Objective-C.</target>
        </trans-unit>
        <trans-unit id="9c5a92eca5579a36fc2d0481a3b2f7e8a916467c" translate="yes" xml:space="preserve">
          <source>The presentation of unit test results to the user.</source>
          <target state="translated">Представление пользователю результатов модульного тестирования.</target>
        </trans-unit>
        <trans-unit id="8662f0b9530b0402d97b53b894f53167be45df40" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions, if any.</source>
          <target state="translated">Предыдущее исключение в цепочке исключений,если таковое имеется.</target>
        </trans-unit>
        <trans-unit id="279b676cef017bbf61d78e4700dc992f1809ccb0" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions.</source>
          <target state="translated">Предыдущее исключение в цепочке исключений.</target>
        </trans-unit>
        <trans-unit id="e3fc0517fe6d8889b123aa839a1f6e19c03962c2" translate="yes" xml:space="preserve">
          <source>The primary allocator.</source>
          <target state="translated">Первичный аллокатор.</target>
        </trans-unit>
        <trans-unit id="4f0154c15aa8860cab6cca5d166473b2dfba4c14" translate="yes" xml:space="preserve">
          <source>The primary range of a container</source>
          <target state="translated">Основной ассортимент контейнера</target>
        </trans-unit>
        <trans-unit id="ab5e84bf7b0a53be5c65c8499a656cc503de367a" translate="yes" xml:space="preserve">
          <source>The primary range type associated with the container.</source>
          <target state="translated">Основной тип диапазона,связанный с контейнером.</target>
        </trans-unit>
        <trans-unit id="33a169f7cc45c68212a77c63178f168570e503e4" translate="yes" xml:space="preserve">
          <source>The primary usefulness of</source>
          <target state="translated">Основная полезность</target>
        </trans-unit>
        <trans-unit id="6d1a3cd0b06a0c49d350401e273d786a65d53304" translate="yes" xml:space="preserve">
          <source>The primary way that programs should time how long something takes is to do</source>
          <target state="translated">Основной способ,с помощью которого программы должны засечь время,необходимое для того,чтобы что-то сделать.</target>
        </trans-unit>
        <trans-unit id="c12de0da440bbe44b6cbc2ce06649502cfbb1a15" translate="yes" xml:space="preserve">
          <source>The process ID number.</source>
          <target state="translated">Идентификационный номер процесса.</target>
        </trans-unit>
        <trans-unit id="57ea5f74d898ca9f45c60b0cceb17881be0464f6" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase has no dependence on subsequent phases. For example, the scanner is not perturbed by the semantic analyzer. This separation of the passes makes language tools like syntax directed editors relatively easy to produce. It also is possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="translated">Процесс компиляции делится на несколько этапов. Каждый этап не зависит от последующих этапов. Например, семантический анализатор не возмущает сканер. Такое разделение проходов делает языковые инструменты, такие как синтаксически направленные редакторы, относительно простыми в создании. Также возможно сжать источник D, сохранив его в &amp;laquo;токенизированной&amp;raquo; форме.</target>
        </trans-unit>
        <trans-unit id="ea34e4c27e6af1bb0e75da5e0e23701dae05bbf4" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase is independent of subsequent phases. For example, the scanner is not affected by the semantic analyzer. This separation of passes makes language tools like syntax-directed editors relatively easy to create. It is also possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28114859ca08917818ce7134f60ebbc9ff108b7d" translate="yes" xml:space="preserve">
          <source>The process of constructing a trie is more involved and is hidden from the user in a form of the convenience functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; and the even more convenient &lt;a href=&quot;#toTrie&quot;&gt;&lt;code&gt;toTrie&lt;/code&gt;&lt;/a&gt;. In general a set or built-in AA with &lt;code&gt;dchar&lt;/code&gt; type can be turned into a trie. The trie object in this module is read-only (immutable); it's effectively frozen after construction.</source>
          <target state="translated">Процесс создания Trie более сложен и скрыт от пользователя в виде удобных функций &lt;a href=&quot;#codepointTrie&quot;&gt; &lt;code&gt;codepointTrie&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#codepointSetTrie&quot;&gt; &lt;code&gt;codepointSetTrie&lt;/code&gt; &lt;/a&gt; и еще более удобных &lt;a href=&quot;#toTrie&quot;&gt; &lt;code&gt;toTrie&lt;/code&gt; &lt;/a&gt; . В общем случае набор или встроенный AA с типом &lt;code&gt;dchar&lt;/code&gt; можно превратить в три. Три объекта в этом модуле только для чтения (неизменяемый); он фактически заморожен после строительства.</target>
        </trans-unit>
        <trans-unit id="d2a069ebee0eb3fc705692f747a2a23547f8a461" translate="yes" xml:space="preserve">
          <source>The process of deducing template type parameters from function arguments is called Implicit Function Template Instantiation (IFTI).</source>
          <target state="translated">Процесс вычитания параметров шаблонного типа из аргументов функции называется Implicit Function Template Instantiation (IFTI).</target>
        </trans-unit>
        <trans-unit id="a65917e549f3ee7bf2fcc111ebfc87ae282e8929" translate="yes" xml:space="preserve">
          <source>The process will be &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;forcefully and abruptly terminated&lt;/a&gt;. If &lt;code&gt;codeOrSignal&lt;/code&gt; is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use &lt;code&gt;codeOrSignal = 259&lt;/code&gt;, as this is a special value (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;) used by Windows to signal that a process has in fact</source>
          <target state="translated">Процесс будет &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;принудительно и внезапно прекращен&lt;/a&gt; . Если &lt;code&gt;codeOrSignal&lt;/code&gt; , это должно быть неотрицательное число, которое будет использоваться в качестве кода выхода процесса. Если нет, процесс завершится с кодом 1. Не используйте &lt;code&gt;codeOrSignal = 259&lt;/code&gt; , так как это специальное значение (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt; ), используемое Windows для сигнализации о том, что процесс на самом деле имеет</target>
        </trans-unit>
        <trans-unit id="a52379dcfb4fdf54c286085a8d7b935d4c3bf51f" translate="yes" xml:space="preserve">
          <source>The program can explicitly inform the garbage collector that an object is no longer referred to with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, and then the garbage collector calls the destructor immediately. The destructor is guaranteed to never be called twice.</source>
          <target state="translated">Программа может явно сообщить сборщику мусора, что объект больше не упоминается с помощью &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; , и затем сборщик мусора немедленно вызывает деструктор. Деструктор гарантированно никогда не будет вызван дважды.</target>
        </trans-unit>
        <trans-unit id="da8f18e43875ff3b21ffb3a65f1d74da9627baee" translate="yes" xml:space="preserve">
          <source>The program name,</source>
          <target state="translated">Название программы,</target>
        </trans-unit>
        <trans-unit id="75fd342f2dff09b71b21a32efe312806ee1c88b1" translate="yes" xml:space="preserve">
          <source>The projection of &lt;code&gt;z&lt;/code&gt; onto the Riemann sphere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212a3b865b9d39089a835e861cd51456362e9629" translate="yes" xml:space="preserve">
          <source>The proper way to instantiate this object is to call &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt;. Once instantiated, this object behaves as a finite random-access range with assignable, lvalue elements and a length equal to the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; that created it plus 1.</source>
          <target state="translated">Правильный способ создания экземпляра этого объекта - вызов &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt; . После создания этот объект ведет себя как конечный диапазон произвольного доступа с назначаемыми элементами lvalue и длиной, равной числу рабочих потоков в &lt;code&gt;TaskPool&lt;/code&gt; , который его создал, плюс 1.</target>
        </trans-unit>
        <trans-unit id="06cb3e37f16148a51f8965d4f1cdc4ea883f0365" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;.__vptr&lt;/code&gt; and &lt;code&gt;.__monitor&lt;/code&gt; give access to the class object's vtbl[] and monitor, respectively, but should not be used in user code.</source>
          <target state="translated">Свойства &lt;code&gt;.__vptr&lt;/code&gt; и &lt;code&gt;.__monitor&lt;/code&gt; предоставляют доступ к объектам класса vtbl [] и monitor соответственно, но не должны использоваться в коде пользователя.</target>
        </trans-unit>
        <trans-unit id="465978af9e7d0929cd7aec7d44ae79ba13368247" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;.outer&lt;/code&gt; used in a nested class gives the &lt;code&gt;this&lt;/code&gt; pointer to its enclosing class. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would return a pointer to enclosing function frame with &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;.outer&lt;/code&gt; , используемое во вложенном классе, дает указатель &lt;code&gt;this&lt;/code&gt; на включающий его класс. Если контекст &lt;code&gt;.outer&lt;/code&gt; класса отсутствует, .outer вернет указатель на рамку включающей функции с &lt;code&gt;void*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18230b4e21a7c31cb0b0a527787c1242f4f98838" translate="yes" xml:space="preserve">
          <source>The proxied value must be an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">Значение прокси должно быть &lt;b&gt;lvalue&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa3e8b16a5d628661af4b4300a9494770cb4fda" translate="yes" xml:space="preserve">
          <source>The ptr aliases are integral types guaranteed to be large enough to hold a pointer without losing bits:</source>
          <target state="translated">ptr псевдонимы-это интегральные типы,которые гарантированно будут достаточно большими,чтобы удерживать указатель без потери битов:</target>
        </trans-unit>
        <trans-unit id="5110028f04b358ea03cfe31d14fda076a20fecde" translate="yes" xml:space="preserve">
          <source>The purpose is to bypass the special case decoding that &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; does to character arrays. As a result, using ranges with &lt;code&gt;byCodeUnit&lt;/code&gt; can be &lt;code&gt;nothrow&lt;/code&gt; while &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; throws when it encounters invalid Unicode sequences.</source>
          <target state="translated">Цель состоит в том, чтобы обойти специальное декодирование, которое &lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt; делает с символьными массивами. В результате использование диапазонов с помощью &lt;code&gt;byCodeUnit&lt;/code&gt; может оказаться &lt;code&gt;nothrow&lt;/code&gt; то время как &lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt; генерирует ошибки при обнаружении недопустимых последовательностей Unicode.</target>
        </trans-unit>
        <trans-unit id="c265a2d12f1e7e5cd63d17026023fdb0d5f3f129" translate="yes" xml:space="preserve">
          <source>The purpose of this is so that continue will go to the next of the statements, and break will go to the end of the statements.</source>
          <target state="translated">Цель этого заключается в том,чтобы перейти к следующему заявлению,а перерыв перейдет к концу заявления.</target>
        </trans-unit>
        <trans-unit id="1651c6e27b3326d67f792a155dd955abdff9b39f" translate="yes" xml:space="preserve">
          <source>The qualifier template from the given type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Шаблон классификатора из заданного типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e09036cabacde1d4e95f44667e0017f4b4c08158" translate="yes" xml:space="preserve">
          <source>The qualifiers of the affix are not always the same as the qualifiers of the argument. This is because the affixes are not part of the data itself, but instead are just</source>
          <target state="translated">Ограничители аффикса не всегда совпадают с ограничителями аргумента.Это происходит потому,что аффиксы не являются частью самих данных,а просто</target>
        </trans-unit>
        <trans-unit id="0c6a006eb9560342bd14cc8557e22fb25a226fd2" translate="yes" xml:space="preserve">
          <source>The random-access range to partition.</source>
          <target state="translated">Диапазон случайного доступа к разделу.</target>
        </trans-unit>
        <trans-unit id="97092cfd186fb5b900f835cf73b9eb2468215664" translate="yes" xml:space="preserve">
          <source>The random-access range to rearrange.</source>
          <target state="translated">Диапазон случайного доступа для перестановки.</target>
        </trans-unit>
        <trans-unit id="e4ce54dd9a7b88e5f2bf201fe3fb2e94f16d9fa9" translate="yes" xml:space="preserve">
          <source>The random-access range to reorder.</source>
          <target state="translated">Диапазон случайного доступа для переупорядочивания.</target>
        </trans-unit>
        <trans-unit id="9759b91222e0376d244c7fe53ea2166dd785b989" translate="yes" xml:space="preserve">
          <source>The range API is supported for both encoding and decoding:</source>
          <target state="translated">API диапазона поддерживается как для кодирования,так и для декодирования:</target>
        </trans-unit>
        <trans-unit id="f827934761dc7cbd89045f8928d650c1c6adfe0d" translate="yes" xml:space="preserve">
          <source>The range being partitioned</source>
          <target state="translated">Разделяемый диапазон</target>
        </trans-unit>
        <trans-unit id="ff34249e986a29860f6c5d437ad8145efcb4a0b9" translate="yes" xml:space="preserve">
          <source>The range primitives that the resulting range provides depends whether or not &lt;code&gt;r&lt;/code&gt; provides them. Except the functions &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;, which also require the range to have a length as well as &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;</source>
          <target state="translated">Примитивы диапазона, которые предоставляет результирующий диапазон, зависят от того, предоставляет ли их &lt;code&gt;r&lt;/code&gt; . За исключением функций &lt;code&gt;back&lt;/code&gt; и &lt;code&gt;popBack&lt;/code&gt; , которые также требуют, чтобы диапазон имел длину, а также &lt;code&gt;back&lt;/code&gt; и &lt;code&gt;popBack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e867771f52adb05da2dc3c29c4eccce7ead17be" translate="yes" xml:space="preserve">
          <source>The range to append to.</source>
          <target state="translated">Диапазон,к которому можно прибавить.</target>
        </trans-unit>
        <trans-unit id="b8f92036ba2322967a7c304f2680091886c10a9f" translate="yes" xml:space="preserve">
          <source>The range to check.</source>
          <target state="translated">Диапазон для проверки.</target>
        </trans-unit>
        <trans-unit id="92faab42363803d3ec822fdd1af0c67c9ba8588a" translate="yes" xml:space="preserve">
          <source>The range to count.</source>
          <target state="translated">Диапазон для подсчета.</target>
        </trans-unit>
        <trans-unit id="2a5042de5707ed27e3cd38336bffdd36cd0572c7" translate="yes" xml:space="preserve">
          <source>The range to handle.</source>
          <target state="translated">Дальность действия.</target>
        </trans-unit>
        <trans-unit id="e058b4d6c31bc35cf580da1ebefcc71d18f5d1ca" translate="yes" xml:space="preserve">
          <source>The range to index.</source>
          <target state="translated">Диапазон к индексу.</target>
        </trans-unit>
        <trans-unit id="80d973acf722de6a5268aeaa4c8fc9646330d9bc" translate="yes" xml:space="preserve">
          <source>The range to permute.</source>
          <target state="translated">Диапазон для завивки.</target>
        </trans-unit>
        <trans-unit id="804c985240d645660c7de05e2788995416dc345a" translate="yes" xml:space="preserve">
          <source>The range to read from.</source>
          <target state="translated">Диапазон для чтения.</target>
        </trans-unit>
        <trans-unit id="8b4ec9a859bd18ea04f9de73b722dd789467f7e7" translate="yes" xml:space="preserve">
          <source>The range to search.</source>
          <target state="translated">Дальность поиска.</target>
        </trans-unit>
        <trans-unit id="121036e1b0b497292221a25f49b6dd27cc53e9e1" translate="yes" xml:space="preserve">
          <source>The range to sort.</source>
          <target state="translated">Диапазон для сортировки.</target>
        </trans-unit>
        <trans-unit id="cc147be5451f6cfb0b41f5b2277bb929ce23d7db" translate="yes" xml:space="preserve">
          <source>The range to subtract from &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">Диапазон вычитать из &lt;code&gt;r1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49d274ac9ff8b631f4dc3f4b09f1138c62b7ffc0" translate="yes" xml:space="preserve">
          <source>The range to write to.</source>
          <target state="translated">Диапазон,на который можно писать.</target>
        </trans-unit>
        <trans-unit id="49360fcd22b248a482a8ca2592193dd9241be2ca" translate="yes" xml:space="preserve">
          <source>The range type</source>
          <target state="translated">Тип диапазона</target>
        </trans-unit>
        <trans-unit id="802ba550fbcee32bf81ae1613d2bfa286e1456a5" translate="yes" xml:space="preserve">
          <source>The range types for &lt;code&gt;RedBlackTree&lt;/code&gt;</source>
          <target state="translated">Типы диапазонов для &lt;code&gt;RedBlackTree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a11d808dfbdf148bbb169a6a95255aca3179a47b" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;begin&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">Светильника, &lt;code&gt;front&lt;/code&gt; интервал - х &lt;code&gt;begin&lt;/code&gt; . func используется для генерации следующего &lt;code&gt;front&lt;/code&gt; при &lt;code&gt;popFront&lt;/code&gt; . Если popFirst - это &lt;code&gt;PopFirst.yes&lt;/code&gt; , то &lt;code&gt;popFront&lt;/code&gt; вызывается перед возвратом диапазона (так что &lt;code&gt;front&lt;/code&gt; - это момент времени, который генерирует func).</target>
        </trans-unit>
        <trans-unit id="2230a6c9d63e9a6e8252220108f18931ca810d49" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;end&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">&lt;code&gt;front&lt;/code&gt; диапазона - это &lt;code&gt;end&lt;/code&gt; интервала . func используется для генерации следующего &lt;code&gt;front&lt;/code&gt; при &lt;code&gt;popFront&lt;/code&gt; . Если popFirst - это &lt;code&gt;PopFirst.yes&lt;/code&gt; , то &lt;code&gt;popFront&lt;/code&gt; вызывается перед возвратом диапазона (так что &lt;code&gt;front&lt;/code&gt; - это момент времени, который генерирует func).</target>
        </trans-unit>
        <trans-unit id="bc87d893530544a1088c66c1a3ebadf8aa8d14c3" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types (i.e. &lt;code&gt;CommonType&lt;/code&gt; must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. &lt;code&gt;ForwardRange&lt;/code&gt; if &lt;code&gt;R1&lt;/code&gt; is a random-access range and &lt;code&gt;R2&lt;/code&gt; is a forward range).</source>
          <target state="translated">Диапазоны могут быть разными, но они должны иметь совместимые типы элементов (т. &lt;code&gt;CommonType&lt;/code&gt; должен существовать для двух типов элементов). Результатом является диапазон, который предлагает самые слабые возможности из двух (например, &lt;code&gt;ForwardRange&lt;/code&gt; , если &lt;code&gt;R1&lt;/code&gt; - диапазон произвольного доступа, а &lt;code&gt;R2&lt;/code&gt; - прямой диапазон).</target>
        </trans-unit>
        <trans-unit id="3f573b0cbf92f973f94497f03f6ff76a63fec72f" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all &lt;code&gt;Ranges&lt;/code&gt;.</source>
          <target state="translated">Диапазоны могут быть разными, но они должны иметь совместимые типы элементов. Результатом является диапазон, который предлагает самые слабые возможности всех &lt;code&gt;Ranges&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b730db3bfe83c0cd05e43737d06094aae7960b40" translate="yes" xml:space="preserve">
          <source>The ranges to compute the intersection for.</source>
          <target state="translated">Диапазоны для расчета пересечения.</target>
        </trans-unit>
        <trans-unit id="46baca537890237a1942208ed4eade3a2e0fe13d" translate="yes" xml:space="preserve">
          <source>The ranges to compute the union for.</source>
          <target state="translated">Диапазоны для расчета союза.</target>
        </trans-unit>
        <trans-unit id="5497d81d16c2927140f25a4c1006f37fea2563ca" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the class definition. The pointer to the vtbl[] (the array of pointers to virtual functions) is assigned. Constructors are passed fully formed objects for which virtual functions can be called. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">Исходные данные статически инициализируются с помощью значений,указанных в определении класса.Присваивается указатель на vtbl[](массив указателей на виртуальные функции).Конструкторам передаются полностью сформированные объекты,для которых можно вызывать виртуальные функции.Эта операция эквивалентна копированию памяти статического варианта объекта на вновь выделенный.</target>
        </trans-unit>
        <trans-unit id="fcae8af2965ab59e0bb8589c5d279780cbfa5e92" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the struct definition. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">Исходные данные статически инициализируются с помощью значений,представленных в определении структуры.Эта операция эквивалентна копированию памяти статического варианта объекта на вновь выделенный.</target>
        </trans-unit>
        <trans-unit id="b86128a6bd2767acc00fa6def304105cbf1e478d" translate="yes" xml:space="preserve">
          <source>The read end of the pipe.</source>
          <target state="translated">Считанный конец трубы.</target>
        </trans-unit>
        <trans-unit id="13a2374af67fe26dbb9c14a59fb5ce5f9e9d781a" translate="yes" xml:space="preserve">
          <source>The read/write mutex module provides a primitive for maintaining shared read access and mutually exclusive write access.</source>
          <target state="translated">Модуль read/write mutex предоставляет примитив для поддержания общего доступа на чтение и взаимоисключающего доступа на запись.</target>
        </trans-unit>
        <trans-unit id="1ea37ce134dc82d56b80e1186c5f0aadafbf2545" translate="yes" xml:space="preserve">
          <source>The real part of the number.</source>
          <target state="translated">Настоящая часть номера.</target>
        </trans-unit>
        <trans-unit id="d84af79636d58f1538ce03a4ef706cc4269fc0ca" translate="yes" xml:space="preserve">
          <source>The reason why local symbols are not considered by UFCS, is to avoid unexpected name conflicts. See below problematic examples.</source>
          <target state="translated">Причина,по которой локальные символы не учитываются UFCS,заключается в том,чтобы избежать неожиданных конфликтов имен.См.ниже проблемные примеры.</target>
        </trans-unit>
        <trans-unit id="6e1a9e9d57c1e11e3c0d69a36fca45727647f054" translate="yes" xml:space="preserve">
          <source>The reason why parsing the UUID string failed (if known)</source>
          <target state="translated">Причина,по которой анализ UUID-строки не удался (если известно).</target>
        </trans-unit>
        <trans-unit id="444ce1c54b9e6e4aeb187c02bb491ead21cc3157" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T.length&lt;/code&gt; is greater than one, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полученное сообщение. Если &lt;code&gt;T.length&lt;/code&gt; больше единицы, сообщение будет упаковано в &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca01b3f617c720041b0621fa546228daeb7a4c84" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T&lt;/code&gt; has more than one entry, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629439e6d0394e525c1da0e460386c227bde37f1" translate="yes" xml:space="preserve">
          <source>The recommended default type for set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. For details, see the current implementation: &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Рекомендуемый тип по умолчанию для набора &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек&lt;/a&gt; . Подробности смотрите в текущей реализации: &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1dc42bd6a98f128cb04e650caf0c66b2c441a15" translate="yes" xml:space="preserve">
          <source>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings.</source>
          <target state="translated">Рекомендуемое решение (см. Руководство по внедрению Unicode) использует многоэтапные таблицы, которые являются реализацией структуры данных &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; с целочисленными ключами и фиксированным числом этапов. В оставшейся части раздела это будет называться фиксированным. Далее описывается конкретная реализация, нацеленная на скорость доступа за счет экономии идеального размера.</target>
        </trans-unit>
        <trans-unit id="64d2cded1f6173c486fb7ad21ff19a0763451581" translate="yes" xml:space="preserve">
          <source>The recommended type of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; to represent [a, b) intervals of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. As used in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;. Any interval type should pass &lt;a href=&quot;#isIntegralPair&quot;&gt;&lt;code&gt;isIntegralPair&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Рекомендуемый тип &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; для представления [a, b) интервалов &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек&lt;/a&gt; . Как используется в &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt; . Любой тип интервала должен передавать черту &lt;a href=&quot;#isIntegralPair&quot;&gt; &lt;code&gt;isIntegralPair&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="859ae610f623e658d3afadb3f75618929c558560" translate="yes" xml:space="preserve">
          <source>The recommended use of &lt;code&gt;KRRegion&lt;/code&gt; is as a</source>
          <target state="translated">Рекомендуемое использование &lt;code&gt;KRRegion&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="388d2ad6c415253a61a360bde9d489b23f6dc8d0" translate="yes" xml:space="preserve">
          <source>The ref-ness of a function is determined from all &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body:</source>
          <target state="translated">&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;Ссылка&lt;/i&gt;&lt;/a&gt; на функцию определяется по всем &lt;i&gt;элементам ReturnStatement&lt;/i&gt; в теле функции:</target>
        </trans-unit>
        <trans-unit id="3b502b2fed948d53834e6a08aa36762dc04287b2" translate="yes" xml:space="preserve">
          <source>The reference label must match a reference defined elsewhere. This may be a D symbol in scope of the source code being documented, like &lt;code&gt;[Object]&lt;/code&gt; in the example above, or it may be an explicit reference that is defined in the same documentation comment, like &lt;code&gt;[ref]&lt;/code&gt; in the example above. In the example both instances of &lt;code&gt;[ref]&lt;/code&gt; in item &lt;code&gt;1.&lt;/code&gt; will be replaced with the URL and title text from the matching definition at the bottom of the example. The first link will read &lt;code&gt;reference link&lt;/code&gt; and the second will read &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">Метка ссылки должна соответствовать ссылке, определенной в другом месте. Это может быть символ D в области документирования исходного кода, например, &lt;code&gt;[Object]&lt;/code&gt; в приведенном выше примере, или это может быть явная ссылка, определенная в том же комментарии к документации, как &lt;code&gt;[ref]&lt;/code&gt; в приведенном выше примере. В примере оба экземпляра &lt;code&gt;[ref]&lt;/code&gt; в пункте &lt;code&gt;1.&lt;/code&gt; будут заменены URL-адресом и текстом заголовка из соответствующего определения в нижней части примера. Первая ссылка будет читать &lt;code&gt;reference link&lt;/code&gt; и второй будет читать &lt;code&gt;ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7f3a52223d62265f3e1ec0b1d084d2cc36a6550" translate="yes" xml:space="preserve">
          <source>The region only stores three pointers, corresponding to the current position in the store and the limits. One allocation entails rounding up the allocation size for alignment purposes, bumping the current pointer, and comparing it against the limit.</source>
          <target state="translated">В регионе хранятся только три указателя,соответствующие текущей позиции в магазине и лимитам.Одно распределение влечет за собой округление размера распределения для целей выравнивания,нагромождение текущего указателя и сравнение его с лимитом.</target>
        </trans-unit>
        <trans-unit id="8dfea884780d568afe3690e3e3875bf9d38d17dd" translate="yes" xml:space="preserve">
          <source>The registry does not perform synchronization, as registration is assumed to be executed serially, as is the case for C constructors.</source>
          <target state="translated">Реестр не выполняет синхронизацию,так как предполагается,что регистрация выполняется последовательно,как в случае с конструкторами C.</target>
        </trans-unit>
        <trans-unit id="323d86762a22443df4223066c5d79a8182348cc7" translate="yes" xml:space="preserve">
          <source>The rehashed associative array.</source>
          <target state="translated">Рефлексированный ассоциативный массив.</target>
        </trans-unit>
        <trans-unit id="2287a637460b49ec8f0775da73953a50ae5c2dbd" translate="yes" xml:space="preserve">
          <source>The relative path.</source>
          <target state="translated">Относительный путь.</target>
        </trans-unit>
        <trans-unit id="6288b454d7838d0a858531ccb0a8c1a5187d7261" translate="yes" xml:space="preserve">
          <source>The removed &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Удаленный &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0fe435252d4242a9ba6f628f9c2050e5381799" translate="yes" xml:space="preserve">
          <source>The replacement text is recursively scanned for more macros. If a macro is recursively encountered, with no argument or with the same argument text as the enclosing macro, it is replaced with no text. Macro invocations that cut across replacement text boundaries are not expanded. If the macro name is undefined, the replacement text has no characters in it. If a &amp;amp;dollar;(NAME) is desired to exist in the output without being macro expanded, the &amp;amp;dollar; should be &lt;a href=&quot;#punctuation_escapes&quot;&gt; backslash-escaped&lt;/a&gt;: &lt;code&gt;\$&lt;/code&gt;.</source>
          <target state="translated">Текст замены рекурсивно сканируется на наличие дополнительных макросов. Если макрос встречается рекурсивно, без аргумента или с тем же текстом аргумента, что и вмещающий макрос, он заменяется без текста. Вызовы макросов, которые пересекают границы замещающего текста, не раскрываются. Если имя макроса не определено, в тексте замены нет символов. Если в выходных данных требуется наличие символа &amp;amp; dollar; (NAME) без расширения макроса, то параметр &amp;amp; dollar; должен быть с &lt;a href=&quot;#punctuation_escapes&quot;&gt;обратной косой чертой&lt;/a&gt; : &lt;code&gt;\$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00c0559f793b29523699536174f193f79d1404f9" translate="yes" xml:space="preserve">
          <source>The representation of the passed string.</source>
          <target state="translated">Представление передаваемой строки.</target>
        </trans-unit>
        <trans-unit id="541a2ee308f80899ed39d343b6df8bc566dc23af" translate="yes" xml:space="preserve">
          <source>The requested type. The currently stored value must implicitly convert to the requested type, in fact &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt;. If an implicit conversion is not possible, throws a &lt;code&gt;VariantException&lt;/code&gt;.</source>
          <target state="translated">Запрашиваемый тип. В настоящее время хранится значение должно неявно преобразовать в запрашиваемом типа, на самом деле &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt; . Если неявное преобразование невозможно, &lt;code&gt;VariantException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb7b072c5ec5c51e2bc9f0c47309355a93d189e" translate="yes" xml:space="preserve">
          <source>The required value.</source>
          <target state="translated">Требуемое значение.</target>
        </trans-unit>
        <trans-unit id="2b92c124327023d2112fc02de9225ba21a0e356f" translate="yes" xml:space="preserve">
          <source>The rest of the EH data can be placed anywhere, it is immutable.</source>
          <target state="translated">Остальные данные EH могут быть размещены где угодно,они неизменны.</target>
        </trans-unit>
        <trans-unit id="bc76ec74ecd985115be5a95df44e330a29c95a31" translate="yes" xml:space="preserve">
          <source>The result cannot be represented exactly, so rounding occurred.</source>
          <target state="translated">Результат не может быть представлен точно,поэтому произошло округление.</target>
        </trans-unit>
        <trans-unit id="ab324d21f7bc55d7dd8b6c95008f59bdf991ab91" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">Результатом является &lt;code&gt;&quot;true&quot;&lt;/code&gt; или &lt;code&gt;&quot;false&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4130bb4d8bac0fbef0c07bb06c97970f537d8b6" translate="yes" xml:space="preserve">
          <source>The result is [s&lt;sub&gt;0&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;, ...] where s&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">В результате получается [s &lt;sub&gt;0&lt;/sub&gt; , s &lt;sub&gt;1&lt;/sub&gt; , ...] где s &lt;sub&gt;n&lt;/sub&gt; - это n-й элемент, отформатированный в формате по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2b142e927d8266a5d73b4c96f242e530946b4181" translate="yes" xml:space="preserve">
          <source>The result is reasonable even if the programmer fails to check for errors.</source>
          <target state="translated">Результат оправдан даже в том случае,если программист не проверяет на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="e6fee708ae88c1f8ca73e67b83e15b2edc455c01" translate="yes" xml:space="preserve">
          <source>The result is reasonable result even if the programmer fails to check for errors.</source>
          <target state="translated">Результат будет разумным даже в том случае,если программист не сможет проверить на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="5df04c97a049ab6feec7de9282693846423b4f8b" translate="yes" xml:space="preserve">
          <source>The result is the equivalent of what the initializer would look like for the contents of the associative array, e.g.: [&quot;red&quot; : 10, &quot;blue&quot; : 20].</source>
          <target state="translated">В результате получается эквивалент того,как инициализирующий массив будет выглядеть для содержимого ассоциативного массива,например:[&quot;красный&quot;:10,&quot;синий&quot;:20].</target>
        </trans-unit>
        <trans-unit id="08ac164a7aed36036f9bcf755150a74df3d7b24f" translate="yes" xml:space="preserve">
          <source>The result is the string converted to UTF-8. A</source>
          <target state="translated">В результате строка конвертируется в UTF-8.A</target>
        </trans-unit>
        <trans-unit id="1509a90746b95e562f0978b9e4493748f60d91cb" translate="yes" xml:space="preserve">
          <source>The result is the string returned from the class instance's &lt;b&gt;.toString()&lt;/b&gt; method. A</source>
          <target state="translated">Результатом является строка, возвращаемая методом экземпляра класса &lt;b&gt;.toString ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="778aba0a364d09c18b371bc8036e82626d093a0a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;takeExactly&lt;/code&gt; is identical to that of &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; in cases where the original range defines &lt;code&gt;length&lt;/code&gt; or is infinite.</source>
          <target state="translated">Результат &lt;code&gt;takeExactly&lt;/code&gt; идентичен результату &lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; в тех случаях, когда исходный диапазон определяет &lt;code&gt;length&lt;/code&gt; или бесконечен.</target>
        </trans-unit>
        <trans-unit id="07564cb52ad1e727fc81a3311ff06a2d773285ae" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been cleared.</source>
          <target state="translated">Результат вызова getAttr после удаления указанных битов.</target>
        </trans-unit>
        <trans-unit id="f30cfdc760b36139b0f53b5d0be507ea3d824ed7" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been set.</source>
          <target state="translated">Результат вызова getAttr после установки указанных битов.</target>
        </trans-unit>
        <trans-unit id="445b97c22b054bdd6ff54c4dae46c9df7f4357c6" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;getopt&lt;/code&gt; function.</source>
          <target state="translated">Результат функции &lt;code&gt;getopt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e35be57e8c5a96f93fd5bad1cb28bc557187a1" translate="yes" xml:space="preserve">
          <source>The result of the cast operation.</source>
          <target state="translated">Результат литья.</target>
        </trans-unit>
        <trans-unit id="83715d44bc2b7900f8b6419b6c4fbc003acad08e" translate="yes" xml:space="preserve">
          <source>The result of the comparison (negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, positive if &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the values are equal)</source>
          <target state="translated">Результат сравнения (отрицательный, если &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , положительный, если &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , если значения равны)</target>
        </trans-unit>
        <trans-unit id="b2ab3e5031cd5a46b28a9645ebcd2ff7f110159a" translate="yes" xml:space="preserve">
          <source>The result of the comparison, &lt;code&gt;true&lt;/code&gt; if the values are equal</source>
          <target state="translated">Результат сравнения &lt;code&gt;true&lt;/code&gt; , если значения равны</target>
        </trans-unit>
        <trans-unit id="0c6e42e7ac37e1c83ed4b193d1c4849e41daad91" translate="yes" xml:space="preserve">
          <source>The result of the comparison.</source>
          <target state="translated">Результат сравнения.</target>
        </trans-unit>
        <trans-unit id="6c6d52fd3aff83619b0b5496c6e3c7be89c2a3aa" translate="yes" xml:space="preserve">
          <source>The result of the expression if no exception is thrown.</source>
          <target state="translated">Результат выражения,если не выбрасывается исключение.</target>
        </trans-unit>
        <trans-unit id="0c56ce95759c8e42c05e176cc9b231a6a3180930" translate="yes" xml:space="preserve">
          <source>The result of the operation, which is the same as the built-in operator</source>
          <target state="translated">Результат операции,такой же,как и у встроенного оператора.</target>
        </trans-unit>
        <trans-unit id="5b1c264300cd8b658cc8b4e315b7758a06a23af7" translate="yes" xml:space="preserve">
          <source>The result of the operation.</source>
          <target state="translated">Результат операции.</target>
        </trans-unit>
        <trans-unit id="9d8e130938ba904bc8f047659f58c659ed670a0b" translate="yes" xml:space="preserve">
          <source>The result of this expression will be discarded. Print error messages if the operation has no side effects (and hence is meaningless).</source>
          <target state="translated">Результат этого выражения будет отброшен.Если операция не имеет побочных эффектов (а значит,бессмысленна),то будут выведены сообщения об ошибках.</target>
        </trans-unit>
        <trans-unit id="2a7cfc7639682da470adfb6b183264f1a3b8552c" translate="yes" xml:space="preserve">
          <source>The result type of an</source>
          <target state="translated">Тип результата</target>
        </trans-unit>
        <trans-unit id="4056040f4fa407b267fad8cbca77b5fc61b11543" translate="yes" xml:space="preserve">
          <source>The resulting addresses will be used in a call to &lt;code&gt;Socket.bind&lt;/code&gt;.</source>
          <target state="translated">Полученные адреса будут использованы при вызове &lt;code&gt;Socket.bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b20f209f4a7f010b51d8af08450b0f594e3ca06" translate="yes" xml:space="preserve">
          <source>The resulting center-justified string. The returned string is GC-allocated. To avoid GC allocation, use &lt;a href=&quot;#centerJustifier&quot;&gt;&lt;code&gt;centerJustifier&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Результирующая выравниваемая по центру строка. Возвращаемая строка выделяется GC. Чтобы избежать выделения GC, используйте &lt;a href=&quot;#centerJustifier&quot;&gt; &lt;code&gt;centerJustifier&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6de191dd7ab6e3535ad839e47c65dfd4fc76b1d8" translate="yes" xml:space="preserve">
          <source>The resulting index.</source>
          <target state="translated">Полученный индекс.</target>
        </trans-unit>
        <trans-unit id="3934e1c05473de8755d2bda617c6973f102e169c" translate="yes" xml:space="preserve">
          <source>The return code of the operation. The value stored in val should be used only if the return value is &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt;.</source>
          <target state="translated">Код возврата операции. Значение, хранящееся в val, следует использовать только в том случае, если возвращаемое значение - &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1da37adfbfe4961b78a217ba2c3b5022d249608b" translate="yes" xml:space="preserve">
          <source>The return expression associated with the first test expression that made the predicate yield true, or the default return expression if no test expression matched.</source>
          <target state="translated">Выражение возврата,связанное с первым тестовым выражением,которое сделало предикат yield true,или с выражением возврата по умолчанию,если ни одно из тестовых выражений не совпало.</target>
        </trans-unit>
        <trans-unit id="96d68b6363dece3bf1b664aecfe8cf00504e56f0" translate="yes" xml:space="preserve">
          <source>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</source>
          <target state="translated">Тип возврата (int или long).По умолчанию он имеет значение time_t,которое на 32-битной системе обычно составляет 32 бита,а на 64-битной-64 бита.</target>
        </trans-unit>
        <trans-unit id="205ac1a8649e05600dd566c06cc715bf690a04c6" translate="yes" xml:space="preserve">
          <source>The return type must not have unshared aliasing unless &lt;code&gt;fun&lt;/code&gt; is &lt;code&gt;pure&lt;/code&gt; or the &lt;code&gt;Task&lt;/code&gt; is executed via &lt;code&gt;executeInNewThread&lt;/code&gt; instead of using a &lt;code&gt;TaskPool&lt;/code&gt;.</source>
          <target state="translated">Тип возврата не должен иметь псевдонимов без &lt;code&gt;executeInNewThread&lt;/code&gt; если только &lt;code&gt;fun&lt;/code&gt; не является &lt;code&gt;pure&lt;/code&gt; или если &lt;code&gt;Task&lt;/code&gt; выполняется через executeInNewThread вместо использования &lt;code&gt;TaskPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e9168599ed0b4047c1160546ea0dbeb54368257" translate="yes" xml:space="preserve">
          <source>The return type of the error handler.</source>
          <target state="translated">Тип возвращаемого обработчика ошибок.</target>
        </trans-unit>
        <trans-unit id="97a463467304a89d6cd8cb9cc6d419fcfa020151" translate="yes" xml:space="preserve">
          <source>The return type of the function called by this &lt;code&gt;Task&lt;/code&gt;. This can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Тип возврата функции, вызываемой этой &lt;code&gt;Task&lt;/code&gt; . Это может быть &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5cb9f689236bc6a0892c16310f01988eb2264f8" translate="yes" xml:space="preserve">
          <source>The return type of tryVisit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">Тип возврата tryVisit выводится из функций посещения и должен быть одинаковым для всех перегрузок.</target>
        </trans-unit>
        <trans-unit id="1337a5d1a9830872413420563b85bf03297ab386" translate="yes" xml:space="preserve">
          <source>The return type of visit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">Тип обратного посещения вычитается из функций посещения и должен быть одинаковым для всех перегрузок.</target>
        </trans-unit>
        <trans-unit id="1ae63b720e25e931777a9598eac602b1cc909af8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="463c16879da8ce6d09697a58e7475146e16150d1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c060f61f5611e03952bbbab3e92b4fea17da134a" translate="yes" xml:space="preserve">
          <source>The return value of the function is cached, so the procedures described below will only be performed the first time the function is called. All subsequent runs will return the same string, regardless of whether environment variables and directory structures have changed in the meantime.</source>
          <target state="translated">Возвращаемое значение функции кэшируется,поэтому процедуры,описанные ниже,будут выполняться только при первом вызове функции.Все последующие запуски будут возвращать одну и ту же строку,независимо от того,изменились ли за это время переменные окружения и структуры каталогов.</target>
        </trans-unit>
        <trans-unit id="1adffc51f8315eaf8be8bf12efa55eccecc130de" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stderr&quot;&gt;&lt;code&gt;core.stdc.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25646bf2b751680fc9f348ccd8f6fea18202d8c1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stdin&quot;&gt;&lt;code&gt;core.stdc.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b78c3af2ae7539b55d9cf5b58f2854c458dd90" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stdout&quot;&gt;&lt;code&gt;core.stdc.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818fa28d06533d229f1e780afce11dd92bba71cd" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stderr&quot;&gt;&lt;code&gt;core.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; оборачивает &lt;a href=&quot;core_stdio#stderr&quot;&gt; &lt;code&gt;core.stdio.stderr&lt;/code&gt; &lt;/a&gt; , и поэтому нить глобальное. Переназначение &lt;code&gt;stderr&lt;/code&gt; другому &lt;code&gt;File&lt;/code&gt; должно выполняться в однопоточном или заблокированном контексте, чтобы избежать гонки.</target>
        </trans-unit>
        <trans-unit id="c5c6e553a95738c70b1b18bed8de44ea5bcf8eb1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdin&quot;&gt;&lt;code&gt;core.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; оборачивает &lt;a href=&quot;core_stdio#stdin&quot;&gt; &lt;code&gt;core.stdio.stdin&lt;/code&gt; &lt;/a&gt; , и поэтому нить глобальное. Переназначение &lt;code&gt;stdin&lt;/code&gt; другому &lt;code&gt;File&lt;/code&gt; должно выполняться в однопоточном или заблокированном контексте, чтобы избежать условий гонки.</target>
        </trans-unit>
        <trans-unit id="58bd0e7417109f330774ab518ccd7daa1f03d122" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdout&quot;&gt;&lt;code&gt;core.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; оборачивает &lt;a href=&quot;core_stdio#stdout&quot;&gt; &lt;code&gt;core.stdio.stdout&lt;/code&gt; &lt;/a&gt; , и поэтому нить глобальное. Переназначение &lt;code&gt;stdout&lt;/code&gt; другому &lt;code&gt;File&lt;/code&gt; должно выполняться в однопоточном или заблокированном контексте, чтобы избежать условий гонки.</target>
        </trans-unit>
        <trans-unit id="ac381e0220e927fc50320b0674e141c6fbd265c5" translate="yes" xml:space="preserve">
          <source>The returned object additionally supports &lt;a href=&quot;#unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возвращенный объект дополнительно поддерживает &lt;a href=&quot;#unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6492e8cd4172777485864f95c54fa9ab563046c6" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is by default taken to be the current working directory. If specified, &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый путь относительно &lt;code&gt;base&lt;/code&gt; , которая по умолчанию считается текущей рабочей директорией. Если указан, &lt;code&gt;base&lt;/code&gt; должен быть абсолютным путем, и всегда предполагается, что он ссылается на каталог. Если &lt;code&gt;path&lt;/code&gt; и &lt;code&gt;base&lt;/code&gt; ссылаются на один и тот же каталог, функция возвращает &lt;code&gt;.&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="27a61535d29f02d1215deba5ffbffddc1e97e7db" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is usually the current working directory. &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый путь относительно &lt;code&gt;base&lt;/code&gt; , которая обычно является текущим рабочим каталогом. &lt;code&gt;base&lt;/code&gt; должен быть абсолютным путем, и всегда предполагается, что он ссылается на каталог. Если &lt;code&gt;path&lt;/code&gt; и &lt;code&gt;base&lt;/code&gt; ссылаются на один и тот же каталог, функция возвращает &lt;code&gt;'.'&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="e221dcc2a55e6ae3990cde11462a83ddb8c59e57" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;a href=&quot;#ticksToNSecs&quot;&gt;&lt;code&gt;ticksToNSecs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реверс &lt;a href=&quot;#ticksToNSecs&quot;&gt; &lt;code&gt;ticksToNSecs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6ea2f4408254d943e5179ee3bbfade7f366fbe9" translate="yes" xml:space="preserve">
          <source>The right part of &lt;code&gt;r&lt;/code&gt; after partitioning.  If &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;. If &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in the left part of &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;.</source>
          <target state="translated">Правая часть &lt;code&gt;r&lt;/code&gt; после разбиения. Если &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt; , &lt;code&gt;partition&lt;/code&gt; сохраняет относительный порядок всех элементов &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; в &lt;code&gt;r&lt;/code&gt; , для которых &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; . Если &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt; , &lt;code&gt;partition&lt;/code&gt; сохраняет относительный порядок всех элементов &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; в левой части &lt;code&gt;r&lt;/code&gt; , для которых &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74483ebbb544d307348c8757c03b1bb648258bec" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison</source>
          <target state="translated">Правая сторона сравнения</target>
        </trans-unit>
        <trans-unit id="0e9a080e28a8d91db65b56c19e48812d639eb325" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for equality</source>
          <target state="translated">Правая сторона сравнения для равенства</target>
        </trans-unit>
        <trans-unit id="82b77c8515d584392179571806e80acab0df8e0e" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for ordering</source>
          <target state="translated">Правая сторона сравнения для заказа</target>
        </trans-unit>
        <trans-unit id="ce77342cf014dfbdd37bba884529bb7b1ea8eb76" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator</source>
          <target state="translated">Правая сторона оператора</target>
        </trans-unit>
        <trans-unit id="9e41eb8c1a87bc5b03b6c14f9d03728097407757" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator (left-hand side is &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">Правая сторона оператора (левая сторона &lt;code&gt;this&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="44c8baae8e4b1cafc92c8edb1f1a4bc6398dfd3a" translate="yes" xml:space="preserve">
          <source>The right-hand side operand</source>
          <target state="translated">Правый операнд</target>
        </trans-unit>
        <trans-unit id="ac11224128b70935424423a8a77fd6fd68210ba1" translate="yes" xml:space="preserve">
          <source>The right-hand side operand (&lt;code&gt;Rhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">Правый операнд ( &lt;code&gt;Rhs&lt;/code&gt; - первый аргумент для &lt;code&gt;Checked&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0295cf674c21bae7e541254ba48b44bd641bdb8f" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the assignment, after the operation has been computed</source>
          <target state="translated">Правый тип в задании,после расчета операции</target>
        </trans-unit>
        <trans-unit id="718e1f58f1f55d464000d479f6fd938c33906894" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the operator</source>
          <target state="translated">Введите правой кнопкой оператора</target>
        </trans-unit>
        <trans-unit id="a73d548c23060689342ba25b61016e797895c8bb" translate="yes" xml:space="preserve">
          <source>The right-hand side type involved in the operator</source>
          <target state="translated">Правый тип,участвующий в работе оператора.</target>
        </trans-unit>
        <trans-unit id="e3fed9dabe35a6b8579a8bd12124493c72510d8b" translate="yes" xml:space="preserve">
          <source>The right-hand side value in the assignment, after the operator has been evaluated</source>
          <target state="translated">Значение правой стороны в задании,после того как оператор оценен</target>
        </trans-unit>
        <trans-unit id="cd88512e1e583ed536b72443b9651f20abee0041" translate="yes" xml:space="preserve">
          <source>The routine called when a message is sent to a full mailbox.</source>
          <target state="translated">Обычная процедура вызывается,когда сообщение отправляется на полный почтовый ящик.</target>
        </trans-unit>
        <trans-unit id="b66d87a6c0e08abdd807f5a483f6da0a435298a3" translate="yes" xml:space="preserve">
          <source>The routines and algorithms are derived from the</source>
          <target state="translated">Рутины и алгоритмы выведены из</target>
        </trans-unit>
        <trans-unit id="89f0c0488274c89f59fab106ec127c844449805c" translate="yes" xml:space="preserve">
          <source>The rules for strings are the usual for literals: If it can fit in an &lt;code&gt;int&lt;/code&gt;, it is an &lt;code&gt;int&lt;/code&gt;. Otherwise, it is a &lt;code&gt;long&lt;/code&gt;. But, if the user specifically asks for a &lt;code&gt;long&lt;/code&gt; with the &lt;code&gt;L&lt;/code&gt; suffix, always give the &lt;code&gt;long&lt;/code&gt;. Give an unsigned iff it is asked for with the &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; suffix. Octals created from integers preserve the type of the passed-in integral.</source>
          <target state="translated">Правила для строк являются обычными для литералов: если он может вписываться в &lt;code&gt;int&lt;/code&gt; , то это &lt;code&gt;int&lt;/code&gt; . Иначе это &lt;code&gt;long&lt;/code&gt; . Но, если пользователь специально запрашивает &lt;code&gt;long&lt;/code&gt; с суффиксом &lt;code&gt;L&lt;/code&gt; , всегда указывайте &lt;code&gt;long&lt;/code&gt; . Дайте без знака, если он запрашивается с суффиксом &lt;code&gt;U&lt;/code&gt; или &lt;code&gt;u&lt;/code&gt; . Восьмеричные числа, созданные из целых чисел, сохраняют тип переданного интеграла.</target>
        </trans-unit>
        <trans-unit id="e32ff39ea4f694316ee9d2d062e0ec9da6e2270f" translate="yes" xml:space="preserve">
          <source>The runtime might have been terminated and not be usable anymore when the destructors are called. Otherwise, usage and requirements of &lt;code&gt;crt_destructor&lt;/code&gt; are similar to those of &lt;code&gt;crt_constructor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0dffdc084b14542b868ac2c2fcdcfbf771ea55f" translate="yes" xml:space="preserve">
          <source>The runtime module exposes information specific to the D runtime code.</source>
          <target state="translated">Модуль времени выполнения раскрывает информацию,специфичную для кода времени выполнения D.</target>
        </trans-unit>
        <trans-unit id="1e0c7d670da430e1c2fcc83076d681bba14efcaf" translate="yes" xml:space="preserve">
          <source>The safety level of this function is faked. It shows itself as &lt;code&gt;@trusted pure nothrow&lt;/code&gt; to not break existing code.</source>
          <target state="translated">Уровень безопасности этой функции подделан. Он показывает себя как &lt;code&gt;@trusted pure nothrow&lt;/code&gt; , чтобы не нарушать существующий код.</target>
        </trans-unit>
        <trans-unit id="269ccafe0cbb6bd48c0c364d60e7c6c6e04d5947" translate="yes" xml:space="preserve">
          <source>The same applies to other &lt;code&gt;Object&lt;/code&gt; methods such as &lt;code&gt;opCmp&lt;/code&gt;, &lt;code&gt;toHash&lt;/code&gt;, etc.</source>
          <target state="translated">То же самое относится и к другим методам &lt;code&gt;Object&lt;/code&gt; , таким как &lt;code&gt;opCmp&lt;/code&gt; , &lt;code&gt;toHash&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="e9e9404807d647f780072b029fb88dbb6d89a0b9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt;, except that final functions that do not override anything are included.</source>
          <target state="translated">Так же, как &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt; , за исключением того, что включены заключительные функции, которые ничего не переопределяют.</target>
        </trans-unit>
        <trans-unit id="93baf85b2a1ff9ebbdedf5ac60d17440ac90bad4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt;, except that final functions that don't override anything return true.</source>
          <target state="translated">Так же, как &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt; , за исключением того, что конечные функции, которые ничего не переопределяют, возвращают true.</target>
        </trans-unit>
        <trans-unit id="484feea935bb2f51a17677737f5a18c29ab34260" translate="yes" xml:space="preserve">
          <source>The same is true for structs.</source>
          <target state="translated">То же самое относится и к структурам.</target>
        </trans-unit>
        <trans-unit id="daa76d61107754eb643bbf2894986cd43d9f6292" translate="yes" xml:space="preserve">
          <source>The same lookup across blocks, scripts, or binary properties, but performed at run-time. This version is provided for cases where &lt;code&gt;name&lt;/code&gt; is not known beforehand; otherwise compile-time checked &lt;a href=&quot;#opDispatch&quot;&gt;&lt;code&gt;opDispatch&lt;/code&gt;&lt;/a&gt; is typically a better choice.</source>
          <target state="translated">Тот же поиск блоков, сценариев или двоичных свойств, но выполняется во время выполнения. Эта версия предназначена для случаев, когда &lt;code&gt;name&lt;/code&gt; не известно заранее; в противном случае проверенный временем компиляции &lt;a href=&quot;#opDispatch&quot;&gt; &lt;code&gt;opDispatch&lt;/code&gt; &lt;/a&gt; обычно является лучшим выбором.</target>
        </trans-unit>
        <trans-unit id="bed255bb45839fece8e5cb2e49994a8474ab1390" translate="yes" xml:space="preserve">
          <source>The saturated result of the operator.</source>
          <target state="translated">Насыщенный результат оператора.</target>
        </trans-unit>
        <trans-unit id="44ebf5442f3ff515c11231f709e48f19fb0fd8ce" translate="yes" xml:space="preserve">
          <source>The scanner function. It should scan from p1 through p2 - 1.</source>
          <target state="translated">Функция сканера.Он должен сканировать от p1 до p2-1.</target>
        </trans-unit>
        <trans-unit id="2b5611ba00d0c5303ec080902ad8f7d6474ce6c0" translate="yes" xml:space="preserve">
          <source>The scanning function.</source>
          <target state="translated">Функция сканирования.</target>
        </trans-unit>
        <trans-unit id="6c94bc26dd8e2388a5758b02c027326a48e92c3c" translate="yes" xml:space="preserve">
          <source>The scheduling priority of this thread.</source>
          <target state="translated">Приоритет планирования этого потока.</target>
        </trans-unit>
        <trans-unit id="bce914b8aac817557e08a2a5b7b1a5b382065247" translate="yes" xml:space="preserve">
          <source>The scope characteristic is inherited, so any classes derived from a scope class are also scope.</source>
          <target state="translated">Характеристика области видимости наследуется,поэтому любые классы,производные от класса области видимости,также являются областью видимости.</target>
        </trans-unit>
        <trans-unit id="bece65d16e0da3cd8d963615575ef27d8569dde0" translate="yes" xml:space="preserve">
          <source>The second</source>
          <target state="translated">Второй</target>
        </trans-unit>
        <trans-unit id="f0aa270a7ba151a0f73151e3a972f6dc7bf0ee07" translate="yes" xml:space="preserve">
          <source>The second array to compare</source>
          <target state="translated">Второй массив для сравнения</target>
        </trans-unit>
        <trans-unit id="970cba63abb463ea9e374f88bdbe56bd7fb71605" translate="yes" xml:space="preserve">
          <source>The second form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;ref&lt;/code&gt;, and has &lt;a href=&quot;#return-ref-parameters&quot;&gt;return ref parameter&lt;/a&gt; semantics with additional &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;scope parameter&lt;/a&gt; semantics.</source>
          <target state="translated">Вторая форма присоединяет &lt;code&gt;return&lt;/code&gt; к &lt;code&gt;ref&lt;/code&gt; и имеет семантику &lt;a href=&quot;#return-ref-parameters&quot;&gt;возвращаемого параметра ref&lt;/a&gt; с дополнительной семантикой &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;параметра scope&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="061d4f927a4a2679d380b604c58cb6c22d22e3d1" translate="yes" xml:space="preserve">
          <source>The second form of this function is usually not called directly; instead, it is used via &lt;a href=&quot;std_string#format&quot;&gt;&lt;code&gt;std.string.format&lt;/code&gt;&lt;/a&gt;, as shown in the examples below. Supported format characters are 'e', 'f', 'g', 'a', and 's'.</source>
          <target state="translated">Вторая форма этой функции обычно не вызывается напрямую; вместо этого он используется через &lt;a href=&quot;std_string#format&quot;&gt; &lt;code&gt;std.string.format&lt;/code&gt; &lt;/a&gt; , как показано в примерах ниже. Поддерживаемые символы формата: &amp;laquo;e&amp;raquo;, &amp;laquo;f&amp;raquo;, &amp;laquo;g&amp;raquo;, &amp;laquo;a&amp;raquo; и &amp;laquo;s&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6175891dc518c6e785380cc43703fbdbef055ecb" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;goto default;&lt;/code&gt;, transfers to the innermost &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; of an enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Вторая форма, &lt;code&gt;goto default;&lt;/code&gt; , передает внутреннему &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; включающего &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b51588d42d45bcafc26dcdf68b259620359d8f6" translate="yes" xml:space="preserve">
          <source>The second function</source>
          <target state="translated">Вторая функция</target>
        </trans-unit>
        <trans-unit id="9a381cf5b12ec2751302d71f1f36bb254a3a2a6d" translate="yes" xml:space="preserve">
          <source>The second makes use of template mixins:</source>
          <target state="translated">Второй использует смеси шаблонов:</target>
        </trans-unit>
        <trans-unit id="b6d7d023028752f2dd5e8e8741a79baee2991163" translate="yes" xml:space="preserve">
          <source>The second portion of the time;</source>
          <target state="translated">Вторую часть времени;</target>
        </trans-unit>
        <trans-unit id="d17baa58ea7c9cb2b5fdeeba1668762e0d314080" translate="yes" xml:space="preserve">
          <source>The second range</source>
          <target state="translated">Второй диапазон</target>
        </trans-unit>
        <trans-unit id="03495ddd562bb985866c15203033cded1697fdb5" translate="yes" xml:space="preserve">
          <source>The second range to be compared.</source>
          <target state="translated">Второй диапазон для сравнения.</target>
        </trans-unit>
        <trans-unit id="17805909c78bc23c485d6d0eee55678a2626d3ec" translate="yes" xml:space="preserve">
          <source>The second range.</source>
          <target state="translated">Второй диапазон.</target>
        </trans-unit>
        <trans-unit id="b5c0d389b19e84b52a4b93582ba1ef6275bab88b" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">Второй, чтобы установить второй &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5f5f8367bfce8ad586cc8594d3c281eb469bd2" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">Второй, чтобы установить второй &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="996418c92be5b452f3de4ff986e1cee8b8da9918" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; чтобы установить в секундах этого TimeOfDay .</target>
        </trans-unit>
        <trans-unit id="fb3c67e4431bd2d01f2e0a28a1a5ab4c776bb0a0" translate="yes" xml:space="preserve">
          <source>The second type to receive the type name for</source>
          <target state="translated">Второй тип для получения имени типа для</target>
        </trans-unit>
        <trans-unit id="572604b99f4f13c97178a7bb83d0a01c9c1fdbf8" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;AutoImplement&lt;/code&gt; automatically implements &lt;code&gt;Interface&lt;/code&gt;, while deriving from &lt;code&gt;BaseClass&lt;/code&gt;.</source>
          <target state="translated">Вторая версия &lt;code&gt;AutoImplement&lt;/code&gt; автоматически реализует &lt;code&gt;Interface&lt;/code&gt; , &lt;code&gt;BaseClass&lt;/code&gt; от BaseClass .</target>
        </trans-unit>
        <trans-unit id="9922ebb56662094439fd0982652299a78a77cb79" translate="yes" xml:space="preserve">
          <source>The second version of the function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.  In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">Вторая версия функции записывает данные в &lt;code&gt;sharedLog&lt;/code&gt; в стиле &lt;code&gt;printf&lt;/code&gt; . Для того , чтобы в результате сообщения журнала , которые будут перенесены на &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;sharedLog&lt;/code&gt; и должно быть больше или равно , чем глобальная &lt;code&gt;LogLevel&lt;/code&gt; . Дополнительно &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca00f96f63ee8d1d8ffcc6e490cc9b3f2af7ff1" translate="yes" xml:space="preserve">
          <source>The second version returns the number of times &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;haystack&lt;/code&gt;. Throws an exception if &lt;code&gt;needle.empty&lt;/code&gt;, as the count of the empty range in any range would be infinite. Overlapped counts are not considered, for example &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Вторая версия возвращает число раз &lt;code&gt;needle&lt;/code&gt; происходит в &lt;code&gt;haystack&lt;/code&gt; . Выдает исключение, если &lt;code&gt;needle.empty&lt;/code&gt; , так как количество пустых диапазонов в любом диапазоне будет бесконечным. Счетчики с перекрытием не учитываются, например, &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; равен &lt;code&gt;1&lt;/code&gt; , а не &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ad6e5d9828f85ec68413d4266b0a775c993286" translate="yes" xml:space="preserve">
          <source>The second way is to cast data to immutable. When doing so, it is up to the programmer to ensure that any mutable references to the same data are not used to modify the data after the cast.</source>
          <target state="translated">Второй способ заключается в приведении данных к непреложности.При этом программист должен убедиться,что любые мутирующие ссылки на те же самые данные не используются для модификации данных после кастинга.</target>
        </trans-unit>
        <trans-unit id="98a2a2f9f0974d5cf21ef2c42fb8d7b511ec7622" translate="yes" xml:space="preserve">
          <source>The second way is to use the precision specifier. The length comes first, followed by the pointer:</source>
          <target state="translated">Второй способ-использование спецификатора точности.Сначала идет длина,затем указатель:</target>
        </trans-unit>
        <trans-unit id="6258e42911fadc579ef629cac8b879505c815405" translate="yes" xml:space="preserve">
          <source>The second will queue readers if there are any writers queued. Writers are passed through one at a time, and once there are no writers present, all queued readers will be alerted.</source>
          <target state="translated">Второй будет ставить в очередь читателей,если в очереди есть какие-нибудь писатели.Писатели проходят по одному,и как только их нет в очереди,все стоящие в очереди читатели будут предупреждены.</target>
        </trans-unit>
        <trans-unit id="222f9be8417077b869fc4ec2ffe85613dca810b0" translate="yes" xml:space="preserve">
          <source>The selector parameter for Objective-C methods.</source>
          <target state="translated">Параметр селектора для методов Objective-C.</target>
        </trans-unit>
        <trans-unit id="c7b62a580f33ebf95a2e808ad6d0fddcde51f3ed" translate="yes" xml:space="preserve">
          <source>The semantics of a bidirectional range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">Предполагается, что семантика двунаправленного диапазона (не проверяемого во время компиляции) следующая ( &lt;code&gt;r&lt;/code&gt; - это объект типа &lt;code&gt;R&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="17817f0aec7117e53dffc5a42bb0ce81b624678f" translate="yes" xml:space="preserve">
          <source>The semantics of a forward range (not checkable during compilation) are the same as for an input range, with the additional requirement that backtracking must be possible by saving a copy of the range object with &lt;code&gt;save&lt;/code&gt; and using it later.</source>
          <target state="translated">Семантика переднего диапазона (не подлежит проверке во время компиляции) такая же, как и для входного диапазона, с дополнительным требованием, чтобы возврат был возможен путем сохранения копии объекта диапазона с &lt;code&gt;save&lt;/code&gt; и последующего использования.</target>
        </trans-unit>
        <trans-unit id="9ad7ef472479146863a20e103ea6caeaec90cbb2" translate="yes" xml:space="preserve">
          <source>The semantics of a module are not affected by what imports it.</source>
          <target state="translated">Семантика модуля не зависит от того,что его импортирует.</target>
        </trans-unit>
        <trans-unit id="1896dacb2ba5ac95d6272bdae742dc30f30d5318" translate="yes" xml:space="preserve">
          <source>The semantics of a random-access range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">Предполагается, что семантика диапазона произвольного доступа (не проверяемого во время компиляции) является следующей ( &lt;code&gt;r&lt;/code&gt; является объектом типа &lt;code&gt;R&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="a29d19e0a1c63b8d3f0187e1b535c432966dec4b" translate="yes" xml:space="preserve">
          <source>The semaphore module provides a general use semaphore for synchronization.</source>
          <target state="translated">Семафорный модуль общего назначения обеспечивает семафор для синхронизации.</target>
        </trans-unit>
        <trans-unit id="0cb8e57171fd0fa8e03b5c22f3ff466ddf864a6e" translate="yes" xml:space="preserve">
          <source>The sequence of tokens is parsed to form syntax trees.</source>
          <target state="translated">Последовательность токенов анализируется с целью формирования синтаксических деревьев.</target>
        </trans-unit>
        <trans-unit id="438ac8d829e20acc25c07ebf7273d7538987132c" translate="yes" xml:space="preserve">
          <source>The sequence to check for the &lt;code&gt;BOM&lt;/code&gt;</source>
          <target state="translated">Последовательность для проверки &lt;code&gt;BOM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aec41afa837cbb030bd78ed48712b8225ab720a9" translate="yes" xml:space="preserve">
          <source>The short symbol for this option</source>
          <target state="translated">Короткий символ для этой опции</target>
        </trans-unit>
        <trans-unit id="14ab0adc14c1851e03d1a893322666eb1605f066" translate="yes" xml:space="preserve">
          <source>The shuffled random-access range.</source>
          <target state="translated">Перепутанный диапазон случайного доступа.</target>
        </trans-unit>
        <trans-unit id="b938bafa6a37b04fed1bbf8b758bf0a54b828b83" translate="yes" xml:space="preserve">
          <source>The sign of &amp;Gamma;(x).</source>
          <target state="translated">Знак &amp;Gamma; (x).</target>
        </trans-unit>
        <trans-unit id="691fa1f516ff445955097300abb84801c17ce9af" translate="yes" xml:space="preserve">
          <source>The signature of this function should be:</source>
          <target state="translated">Подпись этой функции должна быть:</target>
        </trans-unit>
        <trans-unit id="1c551bae643970a0fd547169fd9a9d141dddbbc8" translate="yes" xml:space="preserve">
          <source>The signed type is converted to the unsigned type.</source>
          <target state="translated">Знаковый тип преобразуется в беззнаковый.</target>
        </trans-unit>
        <trans-unit id="ee800310ad7741a1c2a988b7683af21966b44816" translate="yes" xml:space="preserve">
          <source>The similarity per &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; has an issue in that it grows with the lengths of the two strings, even though the strings are not actually very similar. For example, the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; is increasingly similar with the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; as more instances of &lt;code&gt;&quot;world&quot;&lt;/code&gt; are appended. To prevent that, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; computes a normalized version of the similarity that is computed as &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt;. The function &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (a so-called normalized kernel) is bounded in &lt;code&gt;[0, 1]&lt;/code&gt;, reaches &lt;code&gt;0&lt;/code&gt; only for ranges that don't match in any position, and &lt;code&gt;1&lt;/code&gt; only for identical ranges.</source>
          <target state="translated">Сходство в &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; на gapWeightedSogeneity связано с тем, что оно увеличивается с длиной двух строк, хотя строки на самом деле не очень похожи. Например, диапазон &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; становится все более сходным с диапазоном &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; как добавляется больше экземпляров &lt;code&gt;&quot;world&quot;&lt;/code&gt; , Чтобы предотвратить это, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; вычисляет нормализованную версию сходства, которая вычисляется как &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt; .Функция &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (так называемое нормализованное ядро) ограничена в &lt;code&gt;[0, 1]&lt;/code&gt; , достигает &lt;code&gt;0&lt;/code&gt; только для диапазонов, которые не совпадают ни в одной позиции, и &lt;code&gt;1&lt;/code&gt; только для идентичных диапазонов.</target>
        </trans-unit>
        <trans-unit id="88799e576696dc3374489d7e5f75d72056dc1dfa" translate="yes" xml:space="preserve">
          <source>The simplest form of importing is to just list the modules being imported:</source>
          <target state="translated">Самая простая форма импорта-просто перечислить импортируемые модули:</target>
        </trans-unit>
        <trans-unit id="e2009ad4b4c0d89d88051ad98575cc82bbbcf921" translate="yes" xml:space="preserve">
          <source>The simplest immutable declarations use it as a storage class. It can be used to declare manifest constants.</source>
          <target state="translated">Самые простые неизменяемые декларации используют его как класс хранения.Его можно использовать для объявления манифестных констант.</target>
        </trans-unit>
        <trans-unit id="b20f562102f67ba45af181d477da8263c4656fad" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;bringToFront&lt;/code&gt; is for rotating elements in a buffer. For example:</source>
          <target state="translated">Простейшее использование метода &lt;code&gt;bringToFront&lt;/code&gt; - вращение элементов в буфере. Например:</target>
        </trans-unit>
        <trans-unit id="87bc4b882bb607c1c565d6a1ffe9da4b18a9935d" translate="yes" xml:space="preserve">
          <source>The sine and cosine of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="translated">Синус и косинус &lt;code&gt;z&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="1ad591c3d3f25fb3fd9de0046684571acd9030d0" translate="yes" xml:space="preserve">
          <source>The sine, cosine and tangent of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4beb2d03043706421491257b91174cce75401dc3" translate="yes" xml:space="preserve">
          <source>The single element to check.</source>
          <target state="translated">Единственный элемент для проверки.</target>
        </trans-unit>
        <trans-unit id="e20b632a66e4a0973d296fc8dc97c6e7878340fa" translate="yes" xml:space="preserve">
          <source>The single needle to check, which may be either a single element or an input range of elements.</source>
          <target state="translated">Одиночная игла для проверки,которая может быть как отдельным элементом,так и входным диапазоном элементов.</target>
        </trans-unit>
        <trans-unit id="936e0c490ea32a66488b88e6407723c37e53055d" translate="yes" xml:space="preserve">
          <source>The size in bytes of the block to add. If sz is zero then the no operation will occur. If p is null then sz must be zero.</source>
          <target state="translated">Размер в байтах добавляемого блока.Если sz равен нулю,то операция не будет выполнена.Если p равен нулю,то sz должно быть нулевым.</target>
        </trans-unit>
        <trans-unit id="d5f548166d575892e245b5d531ead88e195d968a" translate="yes" xml:space="preserve">
          <source>The size in bytes of the extended memory block referenced by p or zero if no extension occurred.</source>
          <target state="translated">Размер в байтах расширенного блока памяти,на который ссылается p или ноль,если расширение не произошло.</target>
        </trans-unit>
        <trans-unit id="f5a5bf7ffaae9ea0e47a648c75ab38577c22cdee" translate="yes" xml:space="preserve">
          <source>The size in bytes of the memory block referenced by p or zero on error.</source>
          <target state="translated">Размер в байтах блока памяти,на который по ошибке ссылается p или ноль.</target>
        </trans-unit>
        <trans-unit id="a5ec735b95eb9947e1d6e43682f1263ddf71f814" translate="yes" xml:space="preserve">
          <source>The size of a system page in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c428b4443aaffa87ab01d194f64c1d9938dadd" translate="yes" xml:space="preserve">
          <source>The size of each block can be selected either during compilation or at run time. Statically-known block sizes are frequent in practice and yield slightly better performance. To choose a block size statically, pass it as the &lt;code&gt;blockSize&lt;/code&gt; parameter as in &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt;. To choose a block size parameter, use &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; and pass the block size to the constructor.</source>
          <target state="translated">Размер каждого блока можно выбрать во время компиляции или во время выполнения. Статически известные размеры блоков часто встречаются на практике и дают немного лучшую производительность. Чтобы статически выбрать размер блока, передайте его как параметр &lt;code&gt;blockSize&lt;/code&gt; , как в &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt; . Чтобы выбрать параметр размера блока, используйте &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; и передайте размер блока конструктору.</target>
        </trans-unit>
        <trans-unit id="a8db79a8cc24d1fb50ebc2a5392b4de19bea96fb" translate="yes" xml:space="preserve">
          <source>The size of each chunk</source>
          <target state="translated">Размер каждого кусочка</target>
        </trans-unit>
        <trans-unit id="812d083ae4b6202df6ef9285312c396838fbce8c" translate="yes" xml:space="preserve">
          <source>The size of file in bytes.</source>
          <target state="translated">Размер файла в байтах.</target>
        </trans-unit>
        <trans-unit id="5299bf2c3bb77629866128b69aa3cd98cc936e97" translate="yes" xml:space="preserve">
          <source>The size of the allocated length at the end depends on the block size:</source>
          <target state="translated">Размер выделенной длины в конце зависит от размера блока:</target>
        </trans-unit>
        <trans-unit id="a507a2fd30a698197eb87aec60496407de2cc9b4" translate="yes" xml:space="preserve">
          <source>The size of the buffer to store the evaluated elements.</source>
          <target state="translated">Размер буфера для хранения вычисленных элементов.</target>
        </trans-unit>
        <trans-unit id="f51f328cc82fa5e1146c1bcd8d39f77ba7f1a772" translate="yes" xml:space="preserve">
          <source>The size of the chunks</source>
          <target state="translated">Размер кусков</target>
        </trans-unit>
        <trans-unit id="f95ddc1cb4621988d676a326385232a6d69ff6df" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buf&lt;/code&gt; containing the formatted string.</source>
          <target state="translated">Кусочек &lt;code&gt;buf&lt;/code&gt; содержащий отформатированную строку.</target>
        </trans-unit>
        <trans-unit id="c76fb8fffafacca9cf978997fee5c7ec6adb0669" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buffer&lt;/code&gt; containing the data that was actually read. This will be shorter than &lt;code&gt;buffer&lt;/code&gt; if EOF was reached before the buffer could be filled.</source>
          <target state="translated">Часть &lt;code&gt;buffer&lt;/code&gt; содержащая данные, которые были фактически прочитаны. Это будет короче &lt;code&gt;buffer&lt;/code&gt; если EOF был достигнут до того, как буфер мог быть заполнен.</target>
        </trans-unit>
        <trans-unit id="25175c4c04d78f4f21e72598ea69bd88d569188a" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;target&lt;/code&gt; containing the copied elements.</source>
          <target state="translated">Кусочек &lt;code&gt;target&lt;/code&gt; содержащий скопированные элементы.</target>
        </trans-unit>
        <trans-unit id="ad4934ab24ff890e3942dd0930dacb128284b747" translate="yes" xml:space="preserve">
          <source>The slice of buffer containing the decoded result.</source>
          <target state="translated">Кусочек буфера,содержащий декодированный результат.</target>
        </trans-unit>
        <trans-unit id="2493c4fc7b08258cd8cb15270e3f883e67df77ba" translate="yes" xml:space="preserve">
          <source>The slice of buffer that contains the encoded string.</source>
          <target state="translated">Кусочек буфера,содержащий закодированную строку.</target>
        </trans-unit>
        <trans-unit id="ad35a55effab17cdb298d4bb62b7946a0a05ee95" translate="yes" xml:space="preserve">
          <source>The slice on the left and any slices on the right must not overlap. All operands are evaluated exactly once, even if the array slice has zero elements in it.</source>
          <target state="translated">Фрагмент слева и любые фрагменты справа не должны перекрываться.Все операнды вычисляются ровно один раз,даже если в массиве срез имеет нулевые элементы.</target>
        </trans-unit>
        <trans-unit id="7d8c2f61d4c506e7a291057e4bc000a710aed4c4" translate="yes" xml:space="preserve">
          <source>The slice's usable size will not match the block size. Use &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; to retrieve actual usable capacity.</source>
          <target state="translated">Полезный размер среза не будет соответствовать размеру блока. Используйте &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; чтобы получить фактическую полезную емкость.</target>
        </trans-unit>
        <trans-unit id="bba8f7aecbe8029037e1ea79aca03fd651b20234" translate="yes" xml:space="preserve">
          <source>The smallest size that can be allocated is two words (16 bytes on 64-bit systems, 8 bytes on 32-bit systems). This is because the free list management needs two words (one for the length, the other for the next pointer in the singly-linked list).</source>
          <target state="translated">Наименьший размер,который может быть выделен,-два слова (16 байт на 64-битных системах,8 байт на 32-битных).Это связано с тем,что для свободного управления списками необходимо два слова (одно для длины,другое для следующего указателя в односвязанном списке).</target>
        </trans-unit>
        <trans-unit id="c8f2935f9d51846f40ce3a8ff14ea8411e17c417" translate="yes" xml:space="preserve">
          <source>The so-called &quot;all-lengths gap-weighted string kernel&quot; computes a similarity measure between &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; based on all of their common subsequences of all lengths. Gapped subsequences are also included.</source>
          <target state="translated">Так называемое &amp;laquo;строковое ядро ​​со взвешиванием на всю длину&amp;raquo; вычисляет меру подобия между &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;t&lt;/code&gt; на основе всех их общих подпоследовательностей всех длин. Гапсовые подпоследовательности также включены.</target>
        </trans-unit>
        <trans-unit id="b69c2f4a1b196deb3a8f2c9757a25cc977da4151" translate="yes" xml:space="preserve">
          <source>The solution is to use exception handling to report errors. All errors are objects derived from abstract class &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;Error&lt;/code&gt; has a pure virtual function called toString() which produces a &lt;code&gt;string&lt;/code&gt; with a human readable description of the error.</source>
          <target state="translated">Решение состоит в том, чтобы использовать обработку исключений для сообщения об ошибках. Все ошибки являются объектами, производными от абстрактного класса &lt;code&gt;Error&lt;/code&gt; . &lt;code&gt;Error&lt;/code&gt; имеет чисто виртуальную функцию toString (), которая создает &lt;code&gt;string&lt;/code&gt; с понятным для человека описанием ошибки.</target>
        </trans-unit>
        <trans-unit id="869eb1c2ddd5095ece630ff3cd9aa908770a28d3" translate="yes" xml:space="preserve">
          <source>The sorted alias sequence</source>
          <target state="translated">Сортированная последовательность псевдонимов</target>
        </trans-unit>
        <trans-unit id="5890e22a27a487c3d84b74c6aadd83e7f574f4f1" translate="yes" xml:space="preserve">
          <source>The sorted, left-hand side of the random access range to be sorted.</source>
          <target state="translated">Сортировка с левой стороны случайного диапазона доступа,который должен быть отсортирован.</target>
        </trans-unit>
        <trans-unit id="327825eee250d31d85788280f6649c7f91900518" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;Tuple&lt;/code&gt; to assign from. Each element of the source &lt;code&gt;Tuple&lt;/code&gt; must be implicitly assignable to each respective element of the target &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">Исходный &lt;code&gt;Tuple&lt;/code&gt; для назначения. Каждый элемент исходного &lt;code&gt;Tuple&lt;/code&gt; должен быть неявно назначен каждому соответствующему элементу целевого &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04c2f4edcae02e1187a2d950f9afa01879a679fc" translate="yes" xml:space="preserve">
          <source>The source file is checked to determine its encoding and the appropriate scanner is loaded. 7-bit ASCII and UTF encodings are accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5030b9b136204dc20df5dd72c92bea98a422bbd5" translate="yes" xml:space="preserve">
          <source>The source file is checked to see what character set it is, and the appropriate scanner is loaded. ASCII and UTF formats are accepted.</source>
          <target state="translated">Проверяется исходный файл,чтобы узнать,какой это набор символов,и загружается соответствующий сканер.Принимаются форматы ASCII и UTF.</target>
        </trans-unit>
        <trans-unit id="720cc790393ba54be158f390e51929cd3fbb4795" translate="yes" xml:space="preserve">
          <source>The source file is divided into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdc9b54ae3eba8ba8704bc6e8f6a3bd3398e870" translate="yes" xml:space="preserve">
          <source>The source file is divided up into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="translated">Исходный файл разбит на последовательность токенов. &lt;a href=&quot;lex#specialtokens&quot;&gt;Специальные токены&lt;/a&gt; заменяются другими токенами. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; s обрабатываются и удаляются.</target>
        </trans-unit>
        <trans-unit id="81874a58d9273e37ffa0ff4c91450536e1226f36" translate="yes" xml:space="preserve">
          <source>The source file name of the caller.</source>
          <target state="translated">Имя исходного файла вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="63c931360a6dacfd65be2e57e259c4c016ac5c72" translate="yes" xml:space="preserve">
          <source>The source file of the caller.</source>
          <target state="translated">Исходный файл звонящего.</target>
        </trans-unit>
        <trans-unit id="5e1d1c43260b49fce3e8356d81c8f39a6eaf6f86" translate="yes" xml:space="preserve">
          <source>The source location.</source>
          <target state="translated">Местоположение источника.</target>
        </trans-unit>
        <trans-unit id="57597d8f1413ea294f9a97a53e7900b691ef6e36" translate="yes" xml:space="preserve">
          <source>The source object</source>
          <target state="translated">Объект-источник</target>
        </trans-unit>
        <trans-unit id="a8df6910eb6a7836cdf1dd95711fe44c7f692e87" translate="yes" xml:space="preserve">
          <source>The source of the cast</source>
          <target state="translated">Источник литья</target>
        </trans-unit>
        <trans-unit id="79f7b5f01174bbbd5d3e9abcd1ae8cab2d28d824" translate="yes" xml:space="preserve">
          <source>The source range.</source>
          <target state="translated">Диапазон источников.</target>
        </trans-unit>
        <trans-unit id="139f7114b9b6fbeefdd429dfd8ce09ec26e9b7ae" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, all followed by &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Исходный текст декодируется из его исходного представления в Unicode , &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;символы&lt;/i&gt;&lt;/a&gt; с. В &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Символьном&lt;/i&gt;&lt;/a&gt; ы далее разделен на: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;пробельный&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;комментарий&lt;/i&gt;&lt;/a&gt; с, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; ы, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;маркера&lt;/i&gt;&lt;/a&gt; с, а затем все &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;ENDOFFILE&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80e2eeed7c3f3243964c7d881365f7f9018dc7a1" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, and &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, with the source terminated by an &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bd371bebb79ced3649c783e9ef8bd79386c89d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch algorithm, i.e., the lexical analyzer makes the longest possible token. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e734d8ecbd4a33f2c2bfd5df8fb1b69390624d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch technique, i.e., the lexical analyzer makes the longest token it can. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="translated">Исходный текст разбивается на токены с использованием техники максимального жевания, т. Е. Лексический анализатор создает самый длинный токен, какой только может. Например, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; - токен сдвига вправо, а не два больше токенов. Есть два исключения из этого правила:</target>
        </trans-unit>
        <trans-unit id="262fd934f3ad11cda48e320770c23b6cbce4d978" translate="yes" xml:space="preserve">
          <source>The source text is terminated by whichever comes first.</source>
          <target state="translated">Исходный текст завершается в зависимости от того,что наступит раньше.</target>
        </trans-unit>
        <trans-unit id="81738bf1b1d3def6ac2869102bc650c16fdd9cf9" translate="yes" xml:space="preserve">
          <source>The source type in the conversion or comparison</source>
          <target state="translated">Тип источника при преобразовании или сравнении</target>
        </trans-unit>
        <trans-unit id="7363cb9e0bea89a84f2ef7322159cb48984847e8" translate="yes" xml:space="preserve">
          <source>The specific &lt;code&gt;LogLevel&lt;/code&gt; used for logging the log message.</source>
          <target state="translated">Определенный &lt;code&gt;LogLevel&lt;/code&gt; , используемый для регистрации сообщения журнала.</target>
        </trans-unit>
        <trans-unit id="02d763555333f9cf77c0541a37bf5b34481db397" translate="yes" xml:space="preserve">
          <source>The specification for the form of embedded documentation comments only specifies how information is to be presented to the compiler. It is implementation-defined how that information is used and the form of the final presentation. Whether the final presentation form is an HTML web page, a man page, a PDF file, etc. is not specified as part of the D Programming Language.</source>
          <target state="translated">В спецификации формы встроенных комментариев к документации указано только то,как информация должна быть представлена компилятору.Она определяет реализацию-как эта информация используется и форму конечного представления.Является ли конечная форма представления HTML веб-страницей,man-страницей,PDF-файлом и т.д.,не указывается как часть языка программирования D.</target>
        </trans-unit>
        <trans-unit id="c631213db2c74550b3a422d0caf42968e12b014d" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Квадратный корень из &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f0df139a9fed00ace05dd03db279a17a8b348a2" translate="yes" xml:space="preserve">
          <source>The squared magnitude of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54a2e145a2a6ad88bd2025575b8d9841ee25294" translate="yes" xml:space="preserve">
          <source>The squared modulus of &lt;code&gt;z&lt;/code&gt;. For genericity, if called on a real number, returns its square.</source>
          <target state="translated">Модуль квадрата &lt;code&gt;z&lt;/code&gt; . Для универсальности, если вызывается на действительное число, возвращает его квадрат.</target>
        </trans-unit>
        <trans-unit id="d04cf6152ee5948faeb5107c99bbd4c4ee9e3f00" translate="yes" xml:space="preserve">
          <source>The stack and/or registers are being scanned.</source>
          <target state="translated">Стек и/или регистры сканируются.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
