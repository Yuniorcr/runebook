<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="0758911fe007939762ea0a98ab73ee500552cb01" translate="yes" xml:space="preserve">
          <source>The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, &lt;code&gt;byChunk&lt;/code&gt; accepts a user-provided buffer that it uses directly.</source>
          <target state="translated">Параметр может быть числом (как показано в примере выше), определяющим размер каждого чанка. В качестве альтернативы, &lt;code&gt;byChunk&lt;/code&gt; принимает предоставленный пользователем буфер, который он использует напрямую.</target>
        </trans-unit>
        <trans-unit id="c903948dffd2abfd68770b5195aac5d542b83003" translate="yes" xml:space="preserve">
          <source>The parameters of this distribution. The random number is x = (x * multipler + increment) % modulus.</source>
          <target state="translated">Параметры этого распределения.Случайное число x=(x*умножение+приращение)% модуль.</target>
        </trans-unit>
        <trans-unit id="2c7bb35e4246e498ccd1516d5c0a045c041414c6" translate="yes" xml:space="preserve">
          <source>The parameters to the non-variadic function:</source>
          <target state="translated">Параметры к не-вариантной функции:</target>
        </trans-unit>
        <trans-unit id="8c00f330278c8a3688d755f58c6ef387d6c281e7" translate="yes" xml:space="preserve">
          <source>The parameters to the variadic function:</source>
          <target state="translated">Параметры для вариадической функции:</target>
        </trans-unit>
        <trans-unit id="5ebad486f6049114c19bd433cacf524aaf10fabc" translate="yes" xml:space="preserve">
          <source>The parameters with which to instantiate the template.</source>
          <target state="translated">Параметры,с помощью которых можно инстанцировать шаблон.</target>
        </trans-unit>
        <trans-unit id="4fbe12ec5cf422714865a37fd1864dec27719969" translate="yes" xml:space="preserve">
          <source>The parent allocator is publicly accessible either as a direct member if it holds state, or as an alias to &lt;code&gt;Allocator.instance&lt;/code&gt; otherwise. One may use it for making calls that won't count toward statistics collection.</source>
          <target state="translated">Родительский распределитель общедоступен либо как прямой член, если он содержит состояние, либо как псевдоним &lt;code&gt;Allocator.instance&lt;/code&gt; в противном случае. Можно использовать его для звонков, которые не будут учитываться при сборе статистики.</target>
        </trans-unit>
        <trans-unit id="a7916e9fe1cbcecc9e5b2265b50cee59f409bc09" translate="yes" xml:space="preserve">
          <source>The parent allocator. Depending on whether &lt;code&gt;ParentAllocator&lt;/code&gt; holds state or not, this is a member variable or an alias for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Родительский распределитель. В зависимости от того, содержит ли &lt;code&gt;ParentAllocator&lt;/code&gt; состояние или нет, это переменная-член или псевдоним для &lt;code&gt;ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a766f10bdfc11306f72dafd5b728bd7317c675f" translate="yes" xml:space="preserve">
          <source>The parser initially sets it to TOK.concatenateAssign, and semantic() later decides which of the three it will be set to.</source>
          <target state="translated">Сначала синтаксический анализатор устанавливает его в TOK.concatenateAssign,а затем семантическая()решает,в какую из трех точек он будет установлен.</target>
        </trans-unit>
        <trans-unit id="8ca59cb5bd26311e5307aeb5f44c313335ea3580" translate="yes" xml:space="preserve">
          <source>The passed in input was correct, but more input was expected.</source>
          <target state="translated">Переданный вход был правильным,но ожидалось больше входных данных.</target>
        </trans-unit>
        <trans-unit id="04a94fe6ab7793bd68edc946edd3c4d4f906c623" translate="yes" xml:space="preserve">
          <source>The passed text will be printed first, followed by a newline, then the short and long version of every option will be printed. The short and long version will be aligned to the longest option of every &lt;code&gt;Option&lt;/code&gt; passed. If the option is required, then &quot;Required:&quot; will be printed after the long version of the &lt;code&gt;Option&lt;/code&gt;. If a help message is present it will be printed next. The format is illustrated by this code:</source>
          <target state="translated">Переданный текст будет напечатан первым, за которым следует новая строка, а затем будет напечатана короткая и длинная версия каждой опции. Короткая и длинная версия будут выровнены по самой длинной опции из всех переданных &lt;code&gt;Option&lt;/code&gt; . Если опция обязательна, то после обязательной версии &lt;code&gt;Option&lt;/code&gt; будет напечатано &amp;laquo;Required:&amp;raquo; . Если имеется справочное сообщение, оно будет напечатано следующим. Формат иллюстрируется этим кодом:</target>
        </trans-unit>
        <trans-unit id="ae0176808c4338a2b32bdc055054955a47109b3c" translate="yes" xml:space="preserve">
          <source>The path given by &lt;code&gt;path&lt;/code&gt;, with the extension given by &lt;code&gt;ext&lt;/code&gt; appended if the path doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when path is immutable and already has an extension.</source>
          <target state="translated">Путь, заданный &lt;code&gt;path&lt;/code&gt; , с расширением, заданным &lt;code&gt;ext&lt;/code&gt; , добавляется, если у пути его еще нет. Включение точки в расширение необязательно. Эта функция всегда выделяет новую строку, за исключением случая, когда путь неизменен и уже имеет расширение.</target>
        </trans-unit>
        <trans-unit id="9978fd2b7b1c58a32b59d2d933a84ff2eeb9cad1" translate="yes" xml:space="preserve">
          <source>The path name to expand.</source>
          <target state="translated">Имя пути для расширения.</target>
        </trans-unit>
        <trans-unit id="dba74006c9911dd825361c79175c3816c02f4fd6" translate="yes" xml:space="preserve">
          <source>The path of the executable as a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Путь к исполняемому файлу в виде &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c35dcd32a0cd2b956596caddc202c46a4ae3354" translate="yes" xml:space="preserve">
          <source>The path to be matched against</source>
          <target state="translated">Путь,который должен быть сопоставлен</target>
        </trans-unit>
        <trans-unit id="a5d7f6c37fe93af27b88af304f713208b3e7e43a" translate="yes" xml:space="preserve">
          <source>The path to the file.</source>
          <target state="translated">Путь к файлу.</target>
        </trans-unit>
        <trans-unit id="b9caa4476a8447e566c7b52e6155891828512bf8" translate="yes" xml:space="preserve">
          <source>The path to the shell to use to run the specified program. By default this is &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Путь к оболочке, используемой для запуска указанной программы. По умолчанию это &lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a791a6dee2401c3ac563dc595efe14cc5ee858e9" translate="yes" xml:space="preserve">
          <source>The permutation to permutate &lt;code&gt;range&lt;/code&gt; to.</source>
          <target state="translated">Перестановка для перестановки &lt;code&gt;range&lt;/code&gt; до.</target>
        </trans-unit>
        <trans-unit id="3bf6df59e4efc6178ad86ce4d172dd74e35f57bc" translate="yes" xml:space="preserve">
          <source>The permuted range.</source>
          <target state="translated">Пересеченный диапазон.</target>
        </trans-unit>
        <trans-unit id="b51b8abc388ed1faa0574f36244673bca9d03127" translate="yes" xml:space="preserve">
          <source>The pivot element.</source>
          <target state="translated">Шарнирный элемент.</target>
        </trans-unit>
        <trans-unit id="2141dbd9249b3127ee2311abb3285ea6f62646d8" translate="yes" xml:space="preserve">
          <source>The plan is to support all of the above except throwing D exceptions directly in C++ code (but they will be throwable indirectly by calling into a D function with C++ linkage).</source>
          <target state="translated">Планируется поддерживать все вышеперечисленное,за исключением бросания исключений D непосредственно в Си++код (но они будут бросаться косвенно при вызове в функцию D со связкой на Си++).</target>
        </trans-unit>
        <trans-unit id="5e9fcc91fd47a551fe2c3ec3018788e0626a6afc" translate="yes" xml:space="preserve">
          <source>The platform-specific native shell path.</source>
          <target state="translated">Нативный путь оболочки для конкретной платформы.</target>
        </trans-unit>
        <trans-unit id="c744ae6de5a0c2342c1ec26c71bf9d84af5482c5" translate="yes" xml:space="preserve">
          <source>The point is to allow AliasDeclarationY to use &lt;code&gt;__traits()&lt;/code&gt;, see issue 7804.</source>
          <target state="translated">Суть в том, чтобы разрешить AliasDeclarationY использовать &lt;code&gt;__traits()&lt;/code&gt; , см. Проблему 7804.</target>
        </trans-unit>
        <trans-unit id="0b4bb95d6a8d2b3e99a53954eaab5d58c7eb10b4" translate="yes" xml:space="preserve">
          <source>The pointer</source>
          <target state="translated">Указатель</target>
        </trans-unit>
        <trans-unit id="fd5b5206507758892b71f3f58e5e23e1c1f7f65c" translate="yes" xml:space="preserve">
          <source>The pointer, dynamic array, or reference is set to &lt;code&gt;null&lt;/code&gt; after the delete is performed. Any attempt to reference the data after the deletion via another reference to it will result in undefined behavior.</source>
          <target state="translated">Указатель, динамический массив или ссылка устанавливаются в &lt;code&gt;null&lt;/code&gt; после выполнения удаления. Любая попытка обратиться к данным после удаления с помощью другой ссылки на них приведет к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="594f71d424c88492080e5062a3ecf8853308a43e" translate="yes" xml:space="preserve">
          <source>The pointer-based version returns a &lt;code&gt;SortedRange&lt;/code&gt; wrapper over index, of type &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; thus reflecting the ordering of the index. The index-based version returns &lt;code&gt;void&lt;/code&gt; because the ordering relation involves not only &lt;code&gt;index&lt;/code&gt; but also &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Основанная на указателе версия возвращает оболочку &lt;code&gt;SortedRange&lt;/code&gt; над индексом типа &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; отражая, таким образом, порядок индекса. Версия на основе индекса возвращает &lt;code&gt;void&lt;/code&gt; , поскольку отношение упорядочения включает в себя не только &lt;code&gt;index&lt;/code&gt; но и &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c0b6520bd81ff00673e639fb3748bb290589c44" translate="yes" xml:space="preserve">
          <source>The policy to use.</source>
          <target state="translated">Политика,которую нужно использовать.</target>
        </trans-unit>
        <trans-unit id="5bfa0d8b059a39ab26c6f284f964719eecf94f69" translate="yes" xml:space="preserve">
          <source>The policy used by this mutex.</source>
          <target state="translated">Политика,используемая этим мьютексом.</target>
        </trans-unit>
        <trans-unit id="8629893a44c9c276074edd00bae067e6b519cbda" translate="yes" xml:space="preserve">
          <source>The position in &lt;code&gt;array&lt;/code&gt; to insert the &lt;code&gt;stuff&lt;/code&gt;.</source>
          <target state="translated">Позиция в &lt;code&gt;array&lt;/code&gt; для вставки &lt;code&gt;stuff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9eb86610993ddd6856217e1e6d70c91e6f75dbc" translate="yes" xml:space="preserve">
          <source>The position in the input string where the error occurred.</source>
          <target state="translated">Позиция во входной строке,где произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="f421096d1588c50f7ea09d98220627162688c28b" translate="yes" xml:space="preserve">
          <source>The position of the minimum (respectively maximum) element of forward range &lt;code&gt;range&lt;/code&gt;, i.e. a subrange of &lt;code&gt;range&lt;/code&gt; starting at the position of its smallest (respectively largest) element and with the same ending as &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Положение минимума (соответственно максимума) элемента переднего диапазона &lt;code&gt;range&lt;/code&gt; , т.е. поддиапазоне &lt;code&gt;range&lt;/code&gt; , начиная с позиции его наименьшего (соответственно) по величине элемента и с тем же окончанием в качестве &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51fc654e8d5c11108a73d4836e9e77c133dfb257" translate="yes" xml:space="preserve">
          <source>The possible states of the &lt;code&gt;Ternary&lt;/code&gt;</source>
          <target state="translated">Возможные состояния &lt;code&gt;Ternary&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c6cabbb86643a051bf73c292aa98533c672138" translate="yes" xml:space="preserve">
          <source>The possible targets are computed more conservatively than the language allows, eliminating all dangerous conversions. For example, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; does not include &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">Возможные цели вычисляются более консервативно, чем позволяет язык, исключая все опасные преобразования. Например, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; не включает &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d29604df18454624b74cfa89078e0417260306" translate="yes" xml:space="preserve">
          <source>The possible values for units are &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, (microseconds), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds, i.e. 100 ns), and &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">Возможные значения для единиц измерения: &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; , &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (миллисекунды), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; , (микросекунды), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (гекто-наносекунды, т.е. 100 нс) и &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4f82ffde3ae1f423f2307932836a1e645ef668" translate="yes" xml:space="preserve">
          <source>The postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; and &lt;code&gt;__aggrPostblit&lt;/code&gt; are generated without any implicit qualifiers and are not considered struct members. This leads to the situation where qualifying an entire struct declaration with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; does not have any impact on the above-mentioned postblits. However, since &lt;code&gt;__xpostblit&lt;/code&gt; is a member of the struct and an alias of one of the other postblits, the qualifiers applied to the struct will affect the aliased postblit.</source>
          <target state="translated">Постблиты &lt;code&gt;__fieldPostblit&lt;/code&gt; и &lt;code&gt;__aggrPostblit&lt;/code&gt; генерируются без каких-либо неявных квалификаторов и не считаются членами структуры. Это приводит к ситуации, когда квалификация объявления всей структуры с помощью &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; не влияет на вышеупомянутые постблиты. Однако, поскольку &lt;code&gt;__xpostblit&lt;/code&gt; является членом структуры и псевдонимом одного из других постблитов, квалификаторы, примененные к структуре, будут влиять на псевдоним постблитов.</target>
        </trans-unit>
        <trans-unit id="d47161252adc52b1f430344a53bb4997710446f2" translate="yes" xml:space="preserve">
          <source>The power modulus value of (base ^ exponent) % modulus.</source>
          <target state="translated">Значение модуля мощности (базовый ^экспонент)%.</target>
        </trans-unit>
        <trans-unit id="309c3d73f76b800f2ba5fd6059ce5bcf824a5c98" translate="yes" xml:space="preserve">
          <source>The pre contracts specify the preconditions before a statement is executed. The most typical use of this would be in validating the parameters to a function. The post contracts validate the result of the statement. The most typical use of this would be in validating the return value of a function and of any side effects it has. In D, pre contracts begin with &lt;code&gt;in&lt;/code&gt;, and post contracts begin with &lt;code&gt;out&lt;/code&gt;. They come at the end of the function signature and before the opening brace of the function body.</source>
          <target state="translated">Предварительные контракты определяют предварительные условия перед выполнением оператора. Наиболее типичное использование этого было бы в проверке параметров функции. Почтовые контракты подтверждают результат заявления. Наиболее типичное использование этого было бы в проверке возвращаемого значения функции и любых побочных эффектов, которые это имеет. В D предварительные контракты начинаются с &lt;code&gt;in&lt;/code&gt; , а последующие контракты начинаются с &lt;code&gt;out&lt;/code&gt; . Они идут в конце сигнатуры функции и перед открывающей фигурной скобкой тела функции.</target>
        </trans-unit>
        <trans-unit id="bad3757e2d3ea8e03615372cc42932fa498e0342" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;less&lt;/code&gt; defines the lexicographical ordering to be used on the range.</source>
          <target state="translated">Предикат &lt;code&gt;less&lt;/code&gt; определяет лексикографический порядок, который будет использоваться в диапазоне.</target>
        </trans-unit>
        <trans-unit id="75eafad6126e4b32c7a8770becfcb1f1b009b4fa" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;pred&lt;/code&gt; needs to accept an element of &lt;code&gt;r&lt;/code&gt; and the separator &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Предикат &lt;code&gt;pred&lt;/code&gt; должен принимать элемент &lt;code&gt;r&lt;/code&gt; и разделитель &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73639f6f297aaeaa7398fc5473b39c5c235bf984" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the needle, defaulting to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The negated predicate &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; can be used to search instead for the first element</source>
          <target state="translated">Предикат для сравнения каждого элемента с иглой, по умолчанию равен равенству &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; . Отрицательный предикат &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; можно использовать для поиска первого элемента</target>
        </trans-unit>
        <trans-unit id="ad19c283f2ff0ef86cf40f35fd842064c7bd010d" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the separator, defaulting to &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">Предикат для сравнения каждого элемента с разделителем, по умолчанию &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5a87643179e233709de5c2f1a144d80a09a77b5" translate="yes" xml:space="preserve">
          <source>The predicate for deciding where to split the range when no separator is passed</source>
          <target state="translated">Предикат для принятия решения о том,где разделить диапазон,когда сепаратор не пройден.</target>
        </trans-unit>
        <trans-unit id="e35b33251882d624f933a2c1b64ccb5eb65ade7b" translate="yes" xml:space="preserve">
          <source>The predicate for determining when to stop counting.</source>
          <target state="translated">Предикат для определения,когда остановить подсчет.</target>
        </trans-unit>
        <trans-unit id="0c33296dd22cd76b6c27b1beb8636640e4665dda" translate="yes" xml:space="preserve">
          <source>The predicate is expected to satisfy certain rules in order for &lt;code&gt;sort&lt;/code&gt; to behave as expected - otherwise, the program may fail on certain inputs (but not others) when not compiled in release mode, due to the cursory &lt;code&gt;assumeSorted&lt;/code&gt; check. Specifically, &lt;code&gt;sort&lt;/code&gt; expects &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; to imply &lt;code&gt;less(a,c)&lt;/code&gt; (transitivity), and, conversely, &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; to imply &lt;code&gt;!less(a,c)&lt;/code&gt;. Note that the default predicate (&lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;) does not always satisfy these conditions for floating point types, because the expression will always be &lt;code&gt;false&lt;/code&gt; when either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is NaN. Use &lt;a href=&quot;std_math#cmp&quot;&gt;&lt;code&gt;std.math.cmp&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Предполагается, что предикат будет удовлетворять определенным правилам, чтобы &lt;code&gt;sort&lt;/code&gt; &lt;code&gt;assumeSorted&lt;/code&gt; образом - в противном случае программа может не работать на определенных входных данных (но не на других), если они не скомпилированы в режиме выпуска, из-за поверхностной проверки acceptSorted . В частности, &lt;code&gt;sort&lt;/code&gt; предполагает , что &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; означает &lt;code&gt;less(a,c)&lt;/code&gt; (транзитивность) и, наоборот &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; подразумевает &lt;code&gt;!less(a,c)&lt;/code&gt; . Обратите внимание, что предикат по умолчанию ( &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; ) не всегда удовлетворяет этим условиям для типов с плавающей запятой, потому что выражение всегда будет &lt;code&gt;false&lt;/code&gt; когда &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; является NaN. &lt;a href=&quot;std_math#cmp&quot;&gt; &lt;code&gt;std.math.cmp&lt;/code&gt; &lt;/a&gt; этого используйте std.math.cmp .</target>
        </trans-unit>
        <trans-unit id="27f1015c9d3c968b66e69f35344a3e7b0807ccce" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; and accepts any callable function that can be executed via &lt;code&gt;pred(element, s)&lt;/code&gt;.</source>
          <target state="translated">Предикат передается в &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; и принимает любую вызываемую функцию, которая может быть выполнена через &lt;code&gt;pred(element, s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2040ad77d27bfa42d579b0732a628553443b56b4" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;.</source>
          <target state="translated">Предикат передается в &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; и может принимать строку или любой вызываемый объект, который может быть выполнен с помощью &lt;code&gt;pred(element, element)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1cc6d6782bb5ddbb272e878b0a97cd35ebd9643" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">Предикат передается в &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt; и может принимать строку или любой вызываемый объект, который может быть выполнен с помощью &lt;code&gt;pred(element)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b49793439ff4c8d008cc1bf8471d003e4d8abc" translate="yes" xml:space="preserve">
          <source>The predicate that determines whether elements from each respective range match. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">Предикат, который определяет, совпадают ли элементы из каждого соответствующего диапазона. По умолчанию равенство &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11c0e0e174294f0d039166c9a6e153edb402dcf7" translate="yes" xml:space="preserve">
          <source>The predicate that the range should be partitioned by.</source>
          <target state="translated">Предикат,на который следует разделить диапазон.</target>
        </trans-unit>
        <trans-unit id="efb36bba668de1092c1769f6aab990aa0cb00922" translate="yes" xml:space="preserve">
          <source>The predicate the ranges are sorted by.</source>
          <target state="translated">Предикат диапазонов отсортирован.</target>
        </trans-unit>
        <trans-unit id="87bdd1f3ad180a36d78f0b0a9fe20115fabf7d4e" translate="yes" xml:space="preserve">
          <source>The predicate to evaluate.</source>
          <target state="translated">Предикат для оценки.</target>
        </trans-unit>
        <trans-unit id="793b27dece0d99ba7788014f7bf7dd0fb1085592" translate="yes" xml:space="preserve">
          <source>The predicate to partition by.</source>
          <target state="translated">Предикат к разделу по.</target>
        </trans-unit>
        <trans-unit id="d5491576ad03ca04a8526c028f920296327ac77a" translate="yes" xml:space="preserve">
          <source>The predicate to satisfy.</source>
          <target state="translated">Предикат для удовлетворения.</target>
        </trans-unit>
        <trans-unit id="c929e818343f11140b434407d7b74c242dda71fa" translate="yes" xml:space="preserve">
          <source>The predicate to sort by.</source>
          <target state="translated">Предикат для сортировки по.</target>
        </trans-unit>
        <trans-unit id="04024868be7f287d2663bbef1dbf103a8da3cc6b" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements between the range and the needle(s).</source>
          <target state="translated">Предикат,используемый для сравнения элементов между диапазоном и иглой (иглами).</target>
        </trans-unit>
        <trans-unit id="28f32071ce8ed6579de4bc0673c1fb09d434c803" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements.</source>
          <target state="translated">Предикат,используемый для сравнения элементов.</target>
        </trans-unit>
        <trans-unit id="8e5598b5509b9c6eafc0eab8a5a91702947d0e63" translate="yes" xml:space="preserve">
          <source>The predicate to use for determining a match.</source>
          <target state="translated">Предикат,используемый для определения соответствия.</target>
        </trans-unit>
        <trans-unit id="89fd4b4f61967cf71a560e54be19f8d76cbb1cde" translate="yes" xml:space="preserve">
          <source>The predicate to use for the rearrangement.</source>
          <target state="translated">Предикат для перестановки.</target>
        </trans-unit>
        <trans-unit id="aafedf7f211b6bcd89cdb1a78ec67451cd224b87" translate="yes" xml:space="preserve">
          <source>The predicate to use in comparing elements for commonality. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">Предикат для использования при сравнении элементов на общность. По умолчанию равенство &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d6ef6e2289f7e8b2fa887a80d23adf75d1641e1" translate="yes" xml:space="preserve">
          <source>The predicate used for comparison, modeled as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt; strict weak ordering&lt;/a&gt; (irreflexive, antisymmetric, transitive, and implying a transitive equivalence)</source>
          <target state="translated">Предикат, используемый для сравнения, смоделирован как &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt;строгий слабый порядок&lt;/a&gt; (нерефлексивный, антисимметричный, транзитивный и подразумевающий транзитивную эквивалентность)</target>
        </trans-unit>
        <trans-unit id="7f8c0f3692256237f756958104cf2f7dfb39d06e" translate="yes" xml:space="preserve">
          <source>The predicate used to compare the values.</source>
          <target state="translated">Предикат,используемый для сравнения значений.</target>
        </trans-unit>
        <trans-unit id="97370c26d71acf94352a17fb62d152e3830e5289" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a false result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">Предикаты оцениваются слева направо,прерывая оценку коротким путем при обнаружении ложного результата,и в этом случае последние не нуждаются в компиляции.</target>
        </trans-unit>
        <trans-unit id="1d7464c6a5c260ac34ab99c016228d6b560c3e52" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a true result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">Предикаты оцениваются слева направо,прерывая оценку коротким путем,если встречается истинный результат,и в этом случае последние не нуждаются в компиляции.</target>
        </trans-unit>
        <trans-unit id="c330fdecec36e8afd7824dda6b681cda50cda735" translate="yes" xml:space="preserve">
          <source>The preferred way to do memory management in Objective-C is to use Automatic Reference Counting, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;. This is not supported in D, therefore manual memory management is required to be used instead. This is achieved by calling &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; on an Objective-C instance, like in the old days of Objective-C.</source>
          <target state="translated">Предпочтительным способом управления памятью в Objective-C является использование автоматического подсчета ссылок, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; . Это не поддерживается в D, поэтому необходимо использовать ручное управление памятью. Это достигается путем вызова &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; для экземпляра Objective-C, как в старые времена Objective-C.</target>
        </trans-unit>
        <trans-unit id="9c5a92eca5579a36fc2d0481a3b2f7e8a916467c" translate="yes" xml:space="preserve">
          <source>The presentation of unit test results to the user.</source>
          <target state="translated">Представление пользователю результатов модульного тестирования.</target>
        </trans-unit>
        <trans-unit id="8662f0b9530b0402d97b53b894f53167be45df40" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions, if any.</source>
          <target state="translated">Предыдущее исключение в цепочке исключений,если таковое имеется.</target>
        </trans-unit>
        <trans-unit id="279b676cef017bbf61d78e4700dc992f1809ccb0" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions.</source>
          <target state="translated">Предыдущее исключение в цепочке исключений.</target>
        </trans-unit>
        <trans-unit id="e3fc0517fe6d8889b123aa839a1f6e19c03962c2" translate="yes" xml:space="preserve">
          <source>The primary allocator.</source>
          <target state="translated">Первичный аллокатор.</target>
        </trans-unit>
        <trans-unit id="4f0154c15aa8860cab6cca5d166473b2dfba4c14" translate="yes" xml:space="preserve">
          <source>The primary range of a container</source>
          <target state="translated">Основной ассортимент контейнера</target>
        </trans-unit>
        <trans-unit id="ab5e84bf7b0a53be5c65c8499a656cc503de367a" translate="yes" xml:space="preserve">
          <source>The primary range type associated with the container.</source>
          <target state="translated">Основной тип диапазона,связанный с контейнером.</target>
        </trans-unit>
        <trans-unit id="33a169f7cc45c68212a77c63178f168570e503e4" translate="yes" xml:space="preserve">
          <source>The primary usefulness of</source>
          <target state="translated">Основная полезность</target>
        </trans-unit>
        <trans-unit id="6d1a3cd0b06a0c49d350401e273d786a65d53304" translate="yes" xml:space="preserve">
          <source>The primary way that programs should time how long something takes is to do</source>
          <target state="translated">Основной способ,с помощью которого программы должны засечь время,необходимое для того,чтобы что-то сделать.</target>
        </trans-unit>
        <trans-unit id="c12de0da440bbe44b6cbc2ce06649502cfbb1a15" translate="yes" xml:space="preserve">
          <source>The process ID number.</source>
          <target state="translated">Идентификационный номер процесса.</target>
        </trans-unit>
        <trans-unit id="57ea5f74d898ca9f45c60b0cceb17881be0464f6" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase has no dependence on subsequent phases. For example, the scanner is not perturbed by the semantic analyzer. This separation of the passes makes language tools like syntax directed editors relatively easy to produce. It also is possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="translated">Процесс компиляции делится на несколько этапов. Каждый этап не зависит от последующих этапов. Например, семантический анализатор не возмущает сканер. Такое разделение проходов делает языковые инструменты, такие как синтаксически направленные редакторы, относительно простыми в создании. Также возможно сжать источник D, сохранив его в &amp;laquo;токенизированной&amp;raquo; форме.</target>
        </trans-unit>
        <trans-unit id="28114859ca08917818ce7134f60ebbc9ff108b7d" translate="yes" xml:space="preserve">
          <source>The process of constructing a trie is more involved and is hidden from the user in a form of the convenience functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; and the even more convenient &lt;a href=&quot;#toTrie&quot;&gt;&lt;code&gt;toTrie&lt;/code&gt;&lt;/a&gt;. In general a set or built-in AA with &lt;code&gt;dchar&lt;/code&gt; type can be turned into a trie. The trie object in this module is read-only (immutable); it's effectively frozen after construction.</source>
          <target state="translated">Процесс создания Trie более сложен и скрыт от пользователя в виде удобных функций &lt;a href=&quot;#codepointTrie&quot;&gt; &lt;code&gt;codepointTrie&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#codepointSetTrie&quot;&gt; &lt;code&gt;codepointSetTrie&lt;/code&gt; &lt;/a&gt; и еще более удобных &lt;a href=&quot;#toTrie&quot;&gt; &lt;code&gt;toTrie&lt;/code&gt; &lt;/a&gt; . В общем случае набор или встроенный AA с типом &lt;code&gt;dchar&lt;/code&gt; можно превратить в три. Три объекта в этом модуле только для чтения (неизменяемый); он фактически заморожен после строительства.</target>
        </trans-unit>
        <trans-unit id="d2a069ebee0eb3fc705692f747a2a23547f8a461" translate="yes" xml:space="preserve">
          <source>The process of deducing template type parameters from function arguments is called Implicit Function Template Instantiation (IFTI).</source>
          <target state="translated">Процесс вычитания параметров шаблонного типа из аргументов функции называется Implicit Function Template Instantiation (IFTI).</target>
        </trans-unit>
        <trans-unit id="a65917e549f3ee7bf2fcc111ebfc87ae282e8929" translate="yes" xml:space="preserve">
          <source>The process will be &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;forcefully and abruptly terminated&lt;/a&gt;. If &lt;code&gt;codeOrSignal&lt;/code&gt; is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use &lt;code&gt;codeOrSignal = 259&lt;/code&gt;, as this is a special value (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;) used by Windows to signal that a process has in fact</source>
          <target state="translated">Процесс будет &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;принудительно и внезапно прекращен&lt;/a&gt; . Если &lt;code&gt;codeOrSignal&lt;/code&gt; , это должно быть неотрицательное число, которое будет использоваться в качестве кода выхода процесса. Если нет, процесс завершится с кодом 1. Не используйте &lt;code&gt;codeOrSignal = 259&lt;/code&gt; , так как это специальное значение (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt; ), используемое Windows для сигнализации о том, что процесс на самом деле имеет</target>
        </trans-unit>
        <trans-unit id="a52379dcfb4fdf54c286085a8d7b935d4c3bf51f" translate="yes" xml:space="preserve">
          <source>The program can explicitly inform the garbage collector that an object is no longer referred to with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, and then the garbage collector calls the destructor immediately. The destructor is guaranteed to never be called twice.</source>
          <target state="translated">Программа может явно сообщить сборщику мусора, что объект больше не упоминается с помощью &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; , и затем сборщик мусора немедленно вызывает деструктор. Деструктор гарантированно никогда не будет вызван дважды.</target>
        </trans-unit>
        <trans-unit id="da8f18e43875ff3b21ffb3a65f1d74da9627baee" translate="yes" xml:space="preserve">
          <source>The program name,</source>
          <target state="translated">Название программы,</target>
        </trans-unit>
        <trans-unit id="212a3b865b9d39089a835e861cd51456362e9629" translate="yes" xml:space="preserve">
          <source>The proper way to instantiate this object is to call &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt;. Once instantiated, this object behaves as a finite random-access range with assignable, lvalue elements and a length equal to the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; that created it plus 1.</source>
          <target state="translated">Правильный способ создания экземпляра этого объекта - вызов &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt; . После создания этот объект ведет себя как конечный диапазон произвольного доступа с назначаемыми элементами lvalue и длиной, равной числу рабочих потоков в &lt;code&gt;TaskPool&lt;/code&gt; , который его создал, плюс 1.</target>
        </trans-unit>
        <trans-unit id="06cb3e37f16148a51f8965d4f1cdc4ea883f0365" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;.__vptr&lt;/code&gt; and &lt;code&gt;.__monitor&lt;/code&gt; give access to the class object's vtbl[] and monitor, respectively, but should not be used in user code.</source>
          <target state="translated">Свойства &lt;code&gt;.__vptr&lt;/code&gt; и &lt;code&gt;.__monitor&lt;/code&gt; предоставляют доступ к объектам класса vtbl [] и monitor соответственно, но не должны использоваться в коде пользователя.</target>
        </trans-unit>
        <trans-unit id="465978af9e7d0929cd7aec7d44ae79ba13368247" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;.outer&lt;/code&gt; used in a nested class gives the &lt;code&gt;this&lt;/code&gt; pointer to its enclosing class. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would return a pointer to enclosing function frame with &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;.outer&lt;/code&gt; , используемое во вложенном классе, дает указатель &lt;code&gt;this&lt;/code&gt; на включающий его класс. Если контекст &lt;code&gt;.outer&lt;/code&gt; класса отсутствует, .outer вернет указатель на рамку включающей функции с &lt;code&gt;void*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18230b4e21a7c31cb0b0a527787c1242f4f98838" translate="yes" xml:space="preserve">
          <source>The proxied value must be an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">Значение прокси должно быть &lt;b&gt;lvalue&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa3e8b16a5d628661af4b4300a9494770cb4fda" translate="yes" xml:space="preserve">
          <source>The ptr aliases are integral types guaranteed to be large enough to hold a pointer without losing bits:</source>
          <target state="translated">ptr псевдонимы-это интегральные типы,которые гарантированно будут достаточно большими,чтобы удерживать указатель без потери битов:</target>
        </trans-unit>
        <trans-unit id="5110028f04b358ea03cfe31d14fda076a20fecde" translate="yes" xml:space="preserve">
          <source>The purpose is to bypass the special case decoding that &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; does to character arrays. As a result, using ranges with &lt;code&gt;byCodeUnit&lt;/code&gt; can be &lt;code&gt;nothrow&lt;/code&gt; while &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; throws when it encounters invalid Unicode sequences.</source>
          <target state="translated">Цель состоит в том, чтобы обойти специальное декодирование, которое &lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt; делает с символьными массивами. В результате использование диапазонов с помощью &lt;code&gt;byCodeUnit&lt;/code&gt; может оказаться &lt;code&gt;nothrow&lt;/code&gt; то время как &lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt; генерирует ошибки при обнаружении недопустимых последовательностей Unicode.</target>
        </trans-unit>
        <trans-unit id="c265a2d12f1e7e5cd63d17026023fdb0d5f3f129" translate="yes" xml:space="preserve">
          <source>The purpose of this is so that continue will go to the next of the statements, and break will go to the end of the statements.</source>
          <target state="translated">Цель этого заключается в том,чтобы перейти к следующему заявлению,а перерыв перейдет к концу заявления.</target>
        </trans-unit>
        <trans-unit id="1651c6e27b3326d67f792a155dd955abdff9b39f" translate="yes" xml:space="preserve">
          <source>The qualifier template from the given type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Шаблон классификатора из заданного типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e09036cabacde1d4e95f44667e0017f4b4c08158" translate="yes" xml:space="preserve">
          <source>The qualifiers of the affix are not always the same as the qualifiers of the argument. This is because the affixes are not part of the data itself, but instead are just</source>
          <target state="translated">Ограничители аффикса не всегда совпадают с ограничителями аргумента.Это происходит потому,что аффиксы не являются частью самих данных,а просто</target>
        </trans-unit>
        <trans-unit id="0c6a006eb9560342bd14cc8557e22fb25a226fd2" translate="yes" xml:space="preserve">
          <source>The random-access range to partition.</source>
          <target state="translated">Диапазон случайного доступа к разделу.</target>
        </trans-unit>
        <trans-unit id="97092cfd186fb5b900f835cf73b9eb2468215664" translate="yes" xml:space="preserve">
          <source>The random-access range to rearrange.</source>
          <target state="translated">Диапазон случайного доступа для перестановки.</target>
        </trans-unit>
        <trans-unit id="e4ce54dd9a7b88e5f2bf201fe3fb2e94f16d9fa9" translate="yes" xml:space="preserve">
          <source>The random-access range to reorder.</source>
          <target state="translated">Диапазон случайного доступа для переупорядочивания.</target>
        </trans-unit>
        <trans-unit id="9759b91222e0376d244c7fe53ea2166dd785b989" translate="yes" xml:space="preserve">
          <source>The range API is supported for both encoding and decoding:</source>
          <target state="translated">API диапазона поддерживается как для кодирования,так и для декодирования:</target>
        </trans-unit>
        <trans-unit id="f827934761dc7cbd89045f8928d650c1c6adfe0d" translate="yes" xml:space="preserve">
          <source>The range being partitioned</source>
          <target state="translated">Разделяемый диапазон</target>
        </trans-unit>
        <trans-unit id="ff34249e986a29860f6c5d437ad8145efcb4a0b9" translate="yes" xml:space="preserve">
          <source>The range primitives that the resulting range provides depends whether or not &lt;code&gt;r&lt;/code&gt; provides them. Except the functions &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;, which also require the range to have a length as well as &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;</source>
          <target state="translated">Примитивы диапазона, которые предоставляет результирующий диапазон, зависят от того, предоставляет ли их &lt;code&gt;r&lt;/code&gt; . За исключением функций &lt;code&gt;back&lt;/code&gt; и &lt;code&gt;popBack&lt;/code&gt; , которые также требуют, чтобы диапазон имел длину, а также &lt;code&gt;back&lt;/code&gt; и &lt;code&gt;popBack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e867771f52adb05da2dc3c29c4eccce7ead17be" translate="yes" xml:space="preserve">
          <source>The range to append to.</source>
          <target state="translated">Диапазон,к которому можно прибавить.</target>
        </trans-unit>
        <trans-unit id="b8f92036ba2322967a7c304f2680091886c10a9f" translate="yes" xml:space="preserve">
          <source>The range to check.</source>
          <target state="translated">Диапазон для проверки.</target>
        </trans-unit>
        <trans-unit id="92faab42363803d3ec822fdd1af0c67c9ba8588a" translate="yes" xml:space="preserve">
          <source>The range to count.</source>
          <target state="translated">Диапазон для подсчета.</target>
        </trans-unit>
        <trans-unit id="2a5042de5707ed27e3cd38336bffdd36cd0572c7" translate="yes" xml:space="preserve">
          <source>The range to handle.</source>
          <target state="translated">Дальность действия.</target>
        </trans-unit>
        <trans-unit id="e058b4d6c31bc35cf580da1ebefcc71d18f5d1ca" translate="yes" xml:space="preserve">
          <source>The range to index.</source>
          <target state="translated">Диапазон к индексу.</target>
        </trans-unit>
        <trans-unit id="80d973acf722de6a5268aeaa4c8fc9646330d9bc" translate="yes" xml:space="preserve">
          <source>The range to permute.</source>
          <target state="translated">Диапазон для завивки.</target>
        </trans-unit>
        <trans-unit id="804c985240d645660c7de05e2788995416dc345a" translate="yes" xml:space="preserve">
          <source>The range to read from.</source>
          <target state="translated">Диапазон для чтения.</target>
        </trans-unit>
        <trans-unit id="8b4ec9a859bd18ea04f9de73b722dd789467f7e7" translate="yes" xml:space="preserve">
          <source>The range to search.</source>
          <target state="translated">Дальность поиска.</target>
        </trans-unit>
        <trans-unit id="121036e1b0b497292221a25f49b6dd27cc53e9e1" translate="yes" xml:space="preserve">
          <source>The range to sort.</source>
          <target state="translated">Диапазон для сортировки.</target>
        </trans-unit>
        <trans-unit id="cc147be5451f6cfb0b41f5b2277bb929ce23d7db" translate="yes" xml:space="preserve">
          <source>The range to subtract from &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">Диапазон вычитать из &lt;code&gt;r1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49d274ac9ff8b631f4dc3f4b09f1138c62b7ffc0" translate="yes" xml:space="preserve">
          <source>The range to write to.</source>
          <target state="translated">Диапазон,на который можно писать.</target>
        </trans-unit>
        <trans-unit id="49360fcd22b248a482a8ca2592193dd9241be2ca" translate="yes" xml:space="preserve">
          <source>The range type</source>
          <target state="translated">Тип диапазона</target>
        </trans-unit>
        <trans-unit id="802ba550fbcee32bf81ae1613d2bfa286e1456a5" translate="yes" xml:space="preserve">
          <source>The range types for &lt;code&gt;RedBlackTree&lt;/code&gt;</source>
          <target state="translated">Типы диапазонов для &lt;code&gt;RedBlackTree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a11d808dfbdf148bbb169a6a95255aca3179a47b" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;begin&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">Светильника, &lt;code&gt;front&lt;/code&gt; интервал - х &lt;code&gt;begin&lt;/code&gt; . func используется для генерации следующего &lt;code&gt;front&lt;/code&gt; при &lt;code&gt;popFront&lt;/code&gt; . Если popFirst - это &lt;code&gt;PopFirst.yes&lt;/code&gt; , то &lt;code&gt;popFront&lt;/code&gt; вызывается перед возвратом диапазона (так что &lt;code&gt;front&lt;/code&gt; - это момент времени, который генерирует func).</target>
        </trans-unit>
        <trans-unit id="2230a6c9d63e9a6e8252220108f18931ca810d49" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;end&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">&lt;code&gt;front&lt;/code&gt; диапазона - это &lt;code&gt;end&lt;/code&gt; интервала . func используется для генерации следующего &lt;code&gt;front&lt;/code&gt; при &lt;code&gt;popFront&lt;/code&gt; . Если popFirst - это &lt;code&gt;PopFirst.yes&lt;/code&gt; , то &lt;code&gt;popFront&lt;/code&gt; вызывается перед возвратом диапазона (так что &lt;code&gt;front&lt;/code&gt; - это момент времени, который генерирует func).</target>
        </trans-unit>
        <trans-unit id="bc87d893530544a1088c66c1a3ebadf8aa8d14c3" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types (i.e. &lt;code&gt;CommonType&lt;/code&gt; must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. &lt;code&gt;ForwardRange&lt;/code&gt; if &lt;code&gt;R1&lt;/code&gt; is a random-access range and &lt;code&gt;R2&lt;/code&gt; is a forward range).</source>
          <target state="translated">Диапазоны могут быть разными, но они должны иметь совместимые типы элементов (т. &lt;code&gt;CommonType&lt;/code&gt; должен существовать для двух типов элементов). Результатом является диапазон, который предлагает самые слабые возможности из двух (например, &lt;code&gt;ForwardRange&lt;/code&gt; , если &lt;code&gt;R1&lt;/code&gt; - диапазон произвольного доступа, а &lt;code&gt;R2&lt;/code&gt; - прямой диапазон).</target>
        </trans-unit>
        <trans-unit id="3f573b0cbf92f973f94497f03f6ff76a63fec72f" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all &lt;code&gt;Ranges&lt;/code&gt;.</source>
          <target state="translated">Диапазоны могут быть разными, но они должны иметь совместимые типы элементов. Результатом является диапазон, который предлагает самые слабые возможности всех &lt;code&gt;Ranges&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b730db3bfe83c0cd05e43737d06094aae7960b40" translate="yes" xml:space="preserve">
          <source>The ranges to compute the intersection for.</source>
          <target state="translated">Диапазоны для расчета пересечения.</target>
        </trans-unit>
        <trans-unit id="46baca537890237a1942208ed4eade3a2e0fe13d" translate="yes" xml:space="preserve">
          <source>The ranges to compute the union for.</source>
          <target state="translated">Диапазоны для расчета союза.</target>
        </trans-unit>
        <trans-unit id="5497d81d16c2927140f25a4c1006f37fea2563ca" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the class definition. The pointer to the vtbl[] (the array of pointers to virtual functions) is assigned. Constructors are passed fully formed objects for which virtual functions can be called. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">Исходные данные статически инициализируются с помощью значений,указанных в определении класса.Присваивается указатель на vtbl[](массив указателей на виртуальные функции).Конструкторам передаются полностью сформированные объекты,для которых можно вызывать виртуальные функции.Эта операция эквивалентна копированию памяти статического варианта объекта на вновь выделенный.</target>
        </trans-unit>
        <trans-unit id="fcae8af2965ab59e0bb8589c5d279780cbfa5e92" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the struct definition. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">Исходные данные статически инициализируются с помощью значений,представленных в определении структуры.Эта операция эквивалентна копированию памяти статического варианта объекта на вновь выделенный.</target>
        </trans-unit>
        <trans-unit id="b86128a6bd2767acc00fa6def304105cbf1e478d" translate="yes" xml:space="preserve">
          <source>The read end of the pipe.</source>
          <target state="translated">Считанный конец трубы.</target>
        </trans-unit>
        <trans-unit id="13a2374af67fe26dbb9c14a59fb5ce5f9e9d781a" translate="yes" xml:space="preserve">
          <source>The read/write mutex module provides a primitive for maintaining shared read access and mutually exclusive write access.</source>
          <target state="translated">Модуль read/write mutex предоставляет примитив для поддержания общего доступа на чтение и взаимоисключающего доступа на запись.</target>
        </trans-unit>
        <trans-unit id="1ea37ce134dc82d56b80e1186c5f0aadafbf2545" translate="yes" xml:space="preserve">
          <source>The real part of the number.</source>
          <target state="translated">Настоящая часть номера.</target>
        </trans-unit>
        <trans-unit id="d84af79636d58f1538ce03a4ef706cc4269fc0ca" translate="yes" xml:space="preserve">
          <source>The reason why local symbols are not considered by UFCS, is to avoid unexpected name conflicts. See below problematic examples.</source>
          <target state="translated">Причина,по которой локальные символы не учитываются UFCS,заключается в том,чтобы избежать неожиданных конфликтов имен.См.ниже проблемные примеры.</target>
        </trans-unit>
        <trans-unit id="6e1a9e9d57c1e11e3c0d69a36fca45727647f054" translate="yes" xml:space="preserve">
          <source>The reason why parsing the UUID string failed (if known)</source>
          <target state="translated">Причина,по которой анализ UUID-строки не удался (если известно).</target>
        </trans-unit>
        <trans-unit id="444ce1c54b9e6e4aeb187c02bb491ead21cc3157" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T.length&lt;/code&gt; is greater than one, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полученное сообщение. Если &lt;code&gt;T.length&lt;/code&gt; больше единицы, сообщение будет упаковано в &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="629439e6d0394e525c1da0e460386c227bde37f1" translate="yes" xml:space="preserve">
          <source>The recommended default type for set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. For details, see the current implementation: &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Рекомендуемый тип по умолчанию для набора &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек&lt;/a&gt; . Подробности смотрите в текущей реализации: &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1dc42bd6a98f128cb04e650caf0c66b2c441a15" translate="yes" xml:space="preserve">
          <source>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings.</source>
          <target state="translated">Рекомендуемое решение (см. Руководство по внедрению Unicode) использует многоэтапные таблицы, которые являются реализацией структуры данных &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; с целочисленными ключами и фиксированным числом этапов. В оставшейся части раздела это будет называться фиксированным. Далее описывается конкретная реализация, нацеленная на скорость доступа за счет экономии идеального размера.</target>
        </trans-unit>
        <trans-unit id="64d2cded1f6173c486fb7ad21ff19a0763451581" translate="yes" xml:space="preserve">
          <source>The recommended type of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; to represent [a, b) intervals of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. As used in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;. Any interval type should pass &lt;a href=&quot;#isIntegralPair&quot;&gt;&lt;code&gt;isIntegralPair&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Рекомендуемый тип &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; для представления [a, b) интервалов &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек&lt;/a&gt; . Как используется в &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt; . Любой тип интервала должен передавать черту &lt;a href=&quot;#isIntegralPair&quot;&gt; &lt;code&gt;isIntegralPair&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="859ae610f623e658d3afadb3f75618929c558560" translate="yes" xml:space="preserve">
          <source>The recommended use of &lt;code&gt;KRRegion&lt;/code&gt; is as a</source>
          <target state="translated">Рекомендуемое использование &lt;code&gt;KRRegion&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="388d2ad6c415253a61a360bde9d489b23f6dc8d0" translate="yes" xml:space="preserve">
          <source>The ref-ness of a function is determined from all &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body:</source>
          <target state="translated">&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;Ссылка&lt;/i&gt;&lt;/a&gt; на функцию определяется по всем &lt;i&gt;элементам ReturnStatement&lt;/i&gt; в теле функции:</target>
        </trans-unit>
        <trans-unit id="3b502b2fed948d53834e6a08aa36762dc04287b2" translate="yes" xml:space="preserve">
          <source>The reference label must match a reference defined elsewhere. This may be a D symbol in scope of the source code being documented, like &lt;code&gt;[Object]&lt;/code&gt; in the example above, or it may be an explicit reference that is defined in the same documentation comment, like &lt;code&gt;[ref]&lt;/code&gt; in the example above. In the example both instances of &lt;code&gt;[ref]&lt;/code&gt; in item &lt;code&gt;1.&lt;/code&gt; will be replaced with the URL and title text from the matching definition at the bottom of the example. The first link will read &lt;code&gt;reference link&lt;/code&gt; and the second will read &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">Метка ссылки должна соответствовать ссылке, определенной в другом месте. Это может быть символ D в области документирования исходного кода, например, &lt;code&gt;[Object]&lt;/code&gt; в приведенном выше примере, или это может быть явная ссылка, определенная в том же комментарии к документации, как &lt;code&gt;[ref]&lt;/code&gt; в приведенном выше примере. В примере оба экземпляра &lt;code&gt;[ref]&lt;/code&gt; в пункте &lt;code&gt;1.&lt;/code&gt; будут заменены URL-адресом и текстом заголовка из соответствующего определения в нижней части примера. Первая ссылка будет читать &lt;code&gt;reference link&lt;/code&gt; и второй будет читать &lt;code&gt;ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7f3a52223d62265f3e1ec0b1d084d2cc36a6550" translate="yes" xml:space="preserve">
          <source>The region only stores three pointers, corresponding to the current position in the store and the limits. One allocation entails rounding up the allocation size for alignment purposes, bumping the current pointer, and comparing it against the limit.</source>
          <target state="translated">В регионе хранятся только три указателя,соответствующие текущей позиции в магазине и лимитам.Одно распределение влечет за собой округление размера распределения для целей выравнивания,нагромождение текущего указателя и сравнение его с лимитом.</target>
        </trans-unit>
        <trans-unit id="8dfea884780d568afe3690e3e3875bf9d38d17dd" translate="yes" xml:space="preserve">
          <source>The registry does not perform synchronization, as registration is assumed to be executed serially, as is the case for C constructors.</source>
          <target state="translated">Реестр не выполняет синхронизацию,так как предполагается,что регистрация выполняется последовательно,как в случае с конструкторами C.</target>
        </trans-unit>
        <trans-unit id="323d86762a22443df4223066c5d79a8182348cc7" translate="yes" xml:space="preserve">
          <source>The rehashed associative array.</source>
          <target state="translated">Рефлексированный ассоциативный массив.</target>
        </trans-unit>
        <trans-unit id="2287a637460b49ec8f0775da73953a50ae5c2dbd" translate="yes" xml:space="preserve">
          <source>The relative path.</source>
          <target state="translated">Относительный путь.</target>
        </trans-unit>
        <trans-unit id="6288b454d7838d0a858531ccb0a8c1a5187d7261" translate="yes" xml:space="preserve">
          <source>The removed &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Удаленный &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0fe435252d4242a9ba6f628f9c2050e5381799" translate="yes" xml:space="preserve">
          <source>The replacement text is recursively scanned for more macros. If a macro is recursively encountered, with no argument or with the same argument text as the enclosing macro, it is replaced with no text. Macro invocations that cut across replacement text boundaries are not expanded. If the macro name is undefined, the replacement text has no characters in it. If a &amp;amp;dollar;(NAME) is desired to exist in the output without being macro expanded, the &amp;amp;dollar; should be &lt;a href=&quot;#punctuation_escapes&quot;&gt; backslash-escaped&lt;/a&gt;: &lt;code&gt;\$&lt;/code&gt;.</source>
          <target state="translated">Текст замены рекурсивно сканируется на наличие дополнительных макросов. Если макрос встречается рекурсивно, без аргумента или с тем же текстом аргумента, что и вмещающий макрос, он заменяется без текста. Вызовы макросов, которые пересекают границы замещающего текста, не раскрываются. Если имя макроса не определено, в тексте замены нет символов. Если в выходных данных требуется наличие символа &amp;amp; dollar; (NAME) без расширения макроса, то параметр &amp;amp; dollar; должен быть с &lt;a href=&quot;#punctuation_escapes&quot;&gt;обратной косой чертой&lt;/a&gt; : &lt;code&gt;\$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00c0559f793b29523699536174f193f79d1404f9" translate="yes" xml:space="preserve">
          <source>The representation of the passed string.</source>
          <target state="translated">Представление передаваемой строки.</target>
        </trans-unit>
        <trans-unit id="541a2ee308f80899ed39d343b6df8bc566dc23af" translate="yes" xml:space="preserve">
          <source>The requested type. The currently stored value must implicitly convert to the requested type, in fact &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt;. If an implicit conversion is not possible, throws a &lt;code&gt;VariantException&lt;/code&gt;.</source>
          <target state="translated">Запрашиваемый тип. В настоящее время хранится значение должно неявно преобразовать в запрашиваемом типа, на самом деле &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt; . Если неявное преобразование невозможно, &lt;code&gt;VariantException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb7b072c5ec5c51e2bc9f0c47309355a93d189e" translate="yes" xml:space="preserve">
          <source>The required value.</source>
          <target state="translated">Требуемое значение.</target>
        </trans-unit>
        <trans-unit id="2b92c124327023d2112fc02de9225ba21a0e356f" translate="yes" xml:space="preserve">
          <source>The rest of the EH data can be placed anywhere, it is immutable.</source>
          <target state="translated">Остальные данные EH могут быть размещены где угодно,они неизменны.</target>
        </trans-unit>
        <trans-unit id="bc76ec74ecd985115be5a95df44e330a29c95a31" translate="yes" xml:space="preserve">
          <source>The result cannot be represented exactly, so rounding occurred.</source>
          <target state="translated">Результат не может быть представлен точно,поэтому произошло округление.</target>
        </trans-unit>
        <trans-unit id="ab324d21f7bc55d7dd8b6c95008f59bdf991ab91" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">Результатом является &lt;code&gt;&quot;true&quot;&lt;/code&gt; или &lt;code&gt;&quot;false&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4130bb4d8bac0fbef0c07bb06c97970f537d8b6" translate="yes" xml:space="preserve">
          <source>The result is [s&lt;sub&gt;0&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;, ...] where s&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">В результате получается [s &lt;sub&gt;0&lt;/sub&gt; , s &lt;sub&gt;1&lt;/sub&gt; , ...] где s &lt;sub&gt;n&lt;/sub&gt; - это n-й элемент, отформатированный в формате по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2b142e927d8266a5d73b4c96f242e530946b4181" translate="yes" xml:space="preserve">
          <source>The result is reasonable even if the programmer fails to check for errors.</source>
          <target state="translated">Результат оправдан даже в том случае,если программист не проверяет на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="e6fee708ae88c1f8ca73e67b83e15b2edc455c01" translate="yes" xml:space="preserve">
          <source>The result is reasonable result even if the programmer fails to check for errors.</source>
          <target state="translated">Результат будет разумным даже в том случае,если программист не сможет проверить на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="5df04c97a049ab6feec7de9282693846423b4f8b" translate="yes" xml:space="preserve">
          <source>The result is the equivalent of what the initializer would look like for the contents of the associative array, e.g.: [&quot;red&quot; : 10, &quot;blue&quot; : 20].</source>
          <target state="translated">В результате получается эквивалент того,как инициализирующий массив будет выглядеть для содержимого ассоциативного массива,например:[&quot;красный&quot;:10,&quot;синий&quot;:20].</target>
        </trans-unit>
        <trans-unit id="08ac164a7aed36036f9bcf755150a74df3d7b24f" translate="yes" xml:space="preserve">
          <source>The result is the string converted to UTF-8. A</source>
          <target state="translated">В результате строка конвертируется в UTF-8.A</target>
        </trans-unit>
        <trans-unit id="1509a90746b95e562f0978b9e4493748f60d91cb" translate="yes" xml:space="preserve">
          <source>The result is the string returned from the class instance's &lt;b&gt;.toString()&lt;/b&gt; method. A</source>
          <target state="translated">Результатом является строка, возвращаемая методом экземпляра класса &lt;b&gt;.toString ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="778aba0a364d09c18b371bc8036e82626d093a0a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;takeExactly&lt;/code&gt; is identical to that of &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; in cases where the original range defines &lt;code&gt;length&lt;/code&gt; or is infinite.</source>
          <target state="translated">Результат &lt;code&gt;takeExactly&lt;/code&gt; идентичен результату &lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; в тех случаях, когда исходный диапазон определяет &lt;code&gt;length&lt;/code&gt; или бесконечен.</target>
        </trans-unit>
        <trans-unit id="07564cb52ad1e727fc81a3311ff06a2d773285ae" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been cleared.</source>
          <target state="translated">Результат вызова getAttr после удаления указанных битов.</target>
        </trans-unit>
        <trans-unit id="f30cfdc760b36139b0f53b5d0be507ea3d824ed7" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been set.</source>
          <target state="translated">Результат вызова getAttr после установки указанных битов.</target>
        </trans-unit>
        <trans-unit id="445b97c22b054bdd6ff54c4dae46c9df7f4357c6" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;getopt&lt;/code&gt; function.</source>
          <target state="translated">Результат функции &lt;code&gt;getopt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e35be57e8c5a96f93fd5bad1cb28bc557187a1" translate="yes" xml:space="preserve">
          <source>The result of the cast operation.</source>
          <target state="translated">Результат литья.</target>
        </trans-unit>
        <trans-unit id="83715d44bc2b7900f8b6419b6c4fbc003acad08e" translate="yes" xml:space="preserve">
          <source>The result of the comparison (negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, positive if &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the values are equal)</source>
          <target state="translated">Результат сравнения (отрицательный, если &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , положительный, если &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , если значения равны)</target>
        </trans-unit>
        <trans-unit id="b2ab3e5031cd5a46b28a9645ebcd2ff7f110159a" translate="yes" xml:space="preserve">
          <source>The result of the comparison, &lt;code&gt;true&lt;/code&gt; if the values are equal</source>
          <target state="translated">Результат сравнения &lt;code&gt;true&lt;/code&gt; , если значения равны</target>
        </trans-unit>
        <trans-unit id="0c6e42e7ac37e1c83ed4b193d1c4849e41daad91" translate="yes" xml:space="preserve">
          <source>The result of the comparison.</source>
          <target state="translated">Результат сравнения.</target>
        </trans-unit>
        <trans-unit id="6c6d52fd3aff83619b0b5496c6e3c7be89c2a3aa" translate="yes" xml:space="preserve">
          <source>The result of the expression if no exception is thrown.</source>
          <target state="translated">Результат выражения,если не выбрасывается исключение.</target>
        </trans-unit>
        <trans-unit id="0c56ce95759c8e42c05e176cc9b231a6a3180930" translate="yes" xml:space="preserve">
          <source>The result of the operation, which is the same as the built-in operator</source>
          <target state="translated">Результат операции,такой же,как и у встроенного оператора.</target>
        </trans-unit>
        <trans-unit id="5b1c264300cd8b658cc8b4e315b7758a06a23af7" translate="yes" xml:space="preserve">
          <source>The result of the operation.</source>
          <target state="translated">Результат операции.</target>
        </trans-unit>
        <trans-unit id="9d8e130938ba904bc8f047659f58c659ed670a0b" translate="yes" xml:space="preserve">
          <source>The result of this expression will be discarded. Print error messages if the operation has no side effects (and hence is meaningless).</source>
          <target state="translated">Результат этого выражения будет отброшен.Если операция не имеет побочных эффектов (а значит,бессмысленна),то будут выведены сообщения об ошибках.</target>
        </trans-unit>
        <trans-unit id="2a7cfc7639682da470adfb6b183264f1a3b8552c" translate="yes" xml:space="preserve">
          <source>The result type of an</source>
          <target state="translated">Тип результата</target>
        </trans-unit>
        <trans-unit id="4056040f4fa407b267fad8cbca77b5fc61b11543" translate="yes" xml:space="preserve">
          <source>The resulting addresses will be used in a call to &lt;code&gt;Socket.bind&lt;/code&gt;.</source>
          <target state="translated">Полученные адреса будут использованы при вызове &lt;code&gt;Socket.bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b20f209f4a7f010b51d8af08450b0f594e3ca06" translate="yes" xml:space="preserve">
          <source>The resulting center-justified string. The returned string is GC-allocated. To avoid GC allocation, use &lt;a href=&quot;#centerJustifier&quot;&gt;&lt;code&gt;centerJustifier&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Результирующая выравниваемая по центру строка. Возвращаемая строка выделяется GC. Чтобы избежать выделения GC, используйте &lt;a href=&quot;#centerJustifier&quot;&gt; &lt;code&gt;centerJustifier&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6de191dd7ab6e3535ad839e47c65dfd4fc76b1d8" translate="yes" xml:space="preserve">
          <source>The resulting index.</source>
          <target state="translated">Полученный индекс.</target>
        </trans-unit>
        <trans-unit id="3934e1c05473de8755d2bda617c6973f102e169c" translate="yes" xml:space="preserve">
          <source>The return code of the operation. The value stored in val should be used only if the return value is &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt;.</source>
          <target state="translated">Код возврата операции. Значение, хранящееся в val, следует использовать только в том случае, если возвращаемое значение - &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1da37adfbfe4961b78a217ba2c3b5022d249608b" translate="yes" xml:space="preserve">
          <source>The return expression associated with the first test expression that made the predicate yield true, or the default return expression if no test expression matched.</source>
          <target state="translated">Выражение возврата,связанное с первым тестовым выражением,которое сделало предикат yield true,или с выражением возврата по умолчанию,если ни одно из тестовых выражений не совпало.</target>
        </trans-unit>
        <trans-unit id="96d68b6363dece3bf1b664aecfe8cf00504e56f0" translate="yes" xml:space="preserve">
          <source>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</source>
          <target state="translated">Тип возврата (int или long).По умолчанию он имеет значение time_t,которое на 32-битной системе обычно составляет 32 бита,а на 64-битной-64 бита.</target>
        </trans-unit>
        <trans-unit id="205ac1a8649e05600dd566c06cc715bf690a04c6" translate="yes" xml:space="preserve">
          <source>The return type must not have unshared aliasing unless &lt;code&gt;fun&lt;/code&gt; is &lt;code&gt;pure&lt;/code&gt; or the &lt;code&gt;Task&lt;/code&gt; is executed via &lt;code&gt;executeInNewThread&lt;/code&gt; instead of using a &lt;code&gt;TaskPool&lt;/code&gt;.</source>
          <target state="translated">Тип возврата не должен иметь псевдонимов без &lt;code&gt;executeInNewThread&lt;/code&gt; если только &lt;code&gt;fun&lt;/code&gt; не является &lt;code&gt;pure&lt;/code&gt; или если &lt;code&gt;Task&lt;/code&gt; выполняется через executeInNewThread вместо использования &lt;code&gt;TaskPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e9168599ed0b4047c1160546ea0dbeb54368257" translate="yes" xml:space="preserve">
          <source>The return type of the error handler.</source>
          <target state="translated">Тип возвращаемого обработчика ошибок.</target>
        </trans-unit>
        <trans-unit id="97a463467304a89d6cd8cb9cc6d419fcfa020151" translate="yes" xml:space="preserve">
          <source>The return type of the function called by this &lt;code&gt;Task&lt;/code&gt;. This can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Тип возврата функции, вызываемой этой &lt;code&gt;Task&lt;/code&gt; . Это может быть &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5cb9f689236bc6a0892c16310f01988eb2264f8" translate="yes" xml:space="preserve">
          <source>The return type of tryVisit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">Тип возврата tryVisit выводится из функций посещения и должен быть одинаковым для всех перегрузок.</target>
        </trans-unit>
        <trans-unit id="1337a5d1a9830872413420563b85bf03297ab386" translate="yes" xml:space="preserve">
          <source>The return type of visit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">Тип обратного посещения вычитается из функций посещения и должен быть одинаковым для всех перегрузок.</target>
        </trans-unit>
        <trans-unit id="1ae63b720e25e931777a9598eac602b1cc909af8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="463c16879da8ce6d09697a58e7475146e16150d1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c060f61f5611e03952bbbab3e92b4fea17da134a" translate="yes" xml:space="preserve">
          <source>The return value of the function is cached, so the procedures described below will only be performed the first time the function is called. All subsequent runs will return the same string, regardless of whether environment variables and directory structures have changed in the meantime.</source>
          <target state="translated">Возвращаемое значение функции кэшируется,поэтому процедуры,описанные ниже,будут выполняться только при первом вызове функции.Все последующие запуски будут возвращать одну и ту же строку,независимо от того,изменились ли за это время переменные окружения и структуры каталогов.</target>
        </trans-unit>
        <trans-unit id="818fa28d06533d229f1e780afce11dd92bba71cd" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stderr&quot;&gt;&lt;code&gt;core.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; оборачивает &lt;a href=&quot;core_stdio#stderr&quot;&gt; &lt;code&gt;core.stdio.stderr&lt;/code&gt; &lt;/a&gt; , и поэтому нить глобальное. Переназначение &lt;code&gt;stderr&lt;/code&gt; другому &lt;code&gt;File&lt;/code&gt; должно выполняться в однопоточном или заблокированном контексте, чтобы избежать гонки.</target>
        </trans-unit>
        <trans-unit id="c5c6e553a95738c70b1b18bed8de44ea5bcf8eb1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdin&quot;&gt;&lt;code&gt;core.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; оборачивает &lt;a href=&quot;core_stdio#stdin&quot;&gt; &lt;code&gt;core.stdio.stdin&lt;/code&gt; &lt;/a&gt; , и поэтому нить глобальное. Переназначение &lt;code&gt;stdin&lt;/code&gt; другому &lt;code&gt;File&lt;/code&gt; должно выполняться в однопоточном или заблокированном контексте, чтобы избежать условий гонки.</target>
        </trans-unit>
        <trans-unit id="58bd0e7417109f330774ab518ccd7daa1f03d122" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdout&quot;&gt;&lt;code&gt;core.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; оборачивает &lt;a href=&quot;core_stdio#stdout&quot;&gt; &lt;code&gt;core.stdio.stdout&lt;/code&gt; &lt;/a&gt; , и поэтому нить глобальное. Переназначение &lt;code&gt;stdout&lt;/code&gt; другому &lt;code&gt;File&lt;/code&gt; должно выполняться в однопоточном или заблокированном контексте, чтобы избежать условий гонки.</target>
        </trans-unit>
        <trans-unit id="ac381e0220e927fc50320b0674e141c6fbd265c5" translate="yes" xml:space="preserve">
          <source>The returned object additionally supports &lt;a href=&quot;#unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возвращенный объект дополнительно поддерживает &lt;a href=&quot;#unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6492e8cd4172777485864f95c54fa9ab563046c6" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is by default taken to be the current working directory. If specified, &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый путь относительно &lt;code&gt;base&lt;/code&gt; , которая по умолчанию считается текущей рабочей директорией. Если указан, &lt;code&gt;base&lt;/code&gt; должен быть абсолютным путем, и всегда предполагается, что он ссылается на каталог. Если &lt;code&gt;path&lt;/code&gt; и &lt;code&gt;base&lt;/code&gt; ссылаются на один и тот же каталог, функция возвращает &lt;code&gt;.&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="27a61535d29f02d1215deba5ffbffddc1e97e7db" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is usually the current working directory. &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый путь относительно &lt;code&gt;base&lt;/code&gt; , которая обычно является текущим рабочим каталогом. &lt;code&gt;base&lt;/code&gt; должен быть абсолютным путем, и всегда предполагается, что он ссылается на каталог. Если &lt;code&gt;path&lt;/code&gt; и &lt;code&gt;base&lt;/code&gt; ссылаются на один и тот же каталог, функция возвращает &lt;code&gt;'.'&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="e221dcc2a55e6ae3990cde11462a83ddb8c59e57" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;a href=&quot;#ticksToNSecs&quot;&gt;&lt;code&gt;ticksToNSecs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реверс &lt;a href=&quot;#ticksToNSecs&quot;&gt; &lt;code&gt;ticksToNSecs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6ea2f4408254d943e5179ee3bbfade7f366fbe9" translate="yes" xml:space="preserve">
          <source>The right part of &lt;code&gt;r&lt;/code&gt; after partitioning.  If &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;. If &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in the left part of &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;.</source>
          <target state="translated">Правая часть &lt;code&gt;r&lt;/code&gt; после разбиения. Если &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt; , &lt;code&gt;partition&lt;/code&gt; сохраняет относительный порядок всех элементов &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; в &lt;code&gt;r&lt;/code&gt; , для которых &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; . Если &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt; , &lt;code&gt;partition&lt;/code&gt; сохраняет относительный порядок всех элементов &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; в левой части &lt;code&gt;r&lt;/code&gt; , для которых &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74483ebbb544d307348c8757c03b1bb648258bec" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison</source>
          <target state="translated">Правая сторона сравнения</target>
        </trans-unit>
        <trans-unit id="0e9a080e28a8d91db65b56c19e48812d639eb325" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for equality</source>
          <target state="translated">Правая сторона сравнения для равенства</target>
        </trans-unit>
        <trans-unit id="82b77c8515d584392179571806e80acab0df8e0e" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for ordering</source>
          <target state="translated">Правая сторона сравнения для заказа</target>
        </trans-unit>
        <trans-unit id="ce77342cf014dfbdd37bba884529bb7b1ea8eb76" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator</source>
          <target state="translated">Правая сторона оператора</target>
        </trans-unit>
        <trans-unit id="9e41eb8c1a87bc5b03b6c14f9d03728097407757" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator (left-hand side is &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">Правая сторона оператора (левая сторона &lt;code&gt;this&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="44c8baae8e4b1cafc92c8edb1f1a4bc6398dfd3a" translate="yes" xml:space="preserve">
          <source>The right-hand side operand</source>
          <target state="translated">Правый операнд</target>
        </trans-unit>
        <trans-unit id="ac11224128b70935424423a8a77fd6fd68210ba1" translate="yes" xml:space="preserve">
          <source>The right-hand side operand (&lt;code&gt;Rhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">Правый операнд ( &lt;code&gt;Rhs&lt;/code&gt; - первый аргумент для &lt;code&gt;Checked&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0295cf674c21bae7e541254ba48b44bd641bdb8f" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the assignment, after the operation has been computed</source>
          <target state="translated">Правый тип в задании,после расчета операции</target>
        </trans-unit>
        <trans-unit id="718e1f58f1f55d464000d479f6fd938c33906894" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the operator</source>
          <target state="translated">Введите правой кнопкой оператора</target>
        </trans-unit>
        <trans-unit id="a73d548c23060689342ba25b61016e797895c8bb" translate="yes" xml:space="preserve">
          <source>The right-hand side type involved in the operator</source>
          <target state="translated">Правый тип,участвующий в работе оператора.</target>
        </trans-unit>
        <trans-unit id="e3fed9dabe35a6b8579a8bd12124493c72510d8b" translate="yes" xml:space="preserve">
          <source>The right-hand side value in the assignment, after the operator has been evaluated</source>
          <target state="translated">Значение правой стороны в задании,после того как оператор оценен</target>
        </trans-unit>
        <trans-unit id="cd88512e1e583ed536b72443b9651f20abee0041" translate="yes" xml:space="preserve">
          <source>The routine called when a message is sent to a full mailbox.</source>
          <target state="translated">Обычная процедура вызывается,когда сообщение отправляется на полный почтовый ящик.</target>
        </trans-unit>
        <trans-unit id="b66d87a6c0e08abdd807f5a483f6da0a435298a3" translate="yes" xml:space="preserve">
          <source>The routines and algorithms are derived from the</source>
          <target state="translated">Рутины и алгоритмы выведены из</target>
        </trans-unit>
        <trans-unit id="89f0c0488274c89f59fab106ec127c844449805c" translate="yes" xml:space="preserve">
          <source>The rules for strings are the usual for literals: If it can fit in an &lt;code&gt;int&lt;/code&gt;, it is an &lt;code&gt;int&lt;/code&gt;. Otherwise, it is a &lt;code&gt;long&lt;/code&gt;. But, if the user specifically asks for a &lt;code&gt;long&lt;/code&gt; with the &lt;code&gt;L&lt;/code&gt; suffix, always give the &lt;code&gt;long&lt;/code&gt;. Give an unsigned iff it is asked for with the &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; suffix. Octals created from integers preserve the type of the passed-in integral.</source>
          <target state="translated">Правила для строк являются обычными для литералов: если он может вписываться в &lt;code&gt;int&lt;/code&gt; , то это &lt;code&gt;int&lt;/code&gt; . Иначе это &lt;code&gt;long&lt;/code&gt; . Но, если пользователь специально запрашивает &lt;code&gt;long&lt;/code&gt; с суффиксом &lt;code&gt;L&lt;/code&gt; , всегда указывайте &lt;code&gt;long&lt;/code&gt; . Дайте без знака, если он запрашивается с суффиксом &lt;code&gt;U&lt;/code&gt; или &lt;code&gt;u&lt;/code&gt; . Восьмеричные числа, созданные из целых чисел, сохраняют тип переданного интеграла.</target>
        </trans-unit>
        <trans-unit id="e0dffdc084b14542b868ac2c2fcdcfbf771ea55f" translate="yes" xml:space="preserve">
          <source>The runtime module exposes information specific to the D runtime code.</source>
          <target state="translated">Модуль времени выполнения раскрывает информацию,специфичную для кода времени выполнения D.</target>
        </trans-unit>
        <trans-unit id="1e0c7d670da430e1c2fcc83076d681bba14efcaf" translate="yes" xml:space="preserve">
          <source>The safety level of this function is faked. It shows itself as &lt;code&gt;@trusted pure nothrow&lt;/code&gt; to not break existing code.</source>
          <target state="translated">Уровень безопасности этой функции подделан. Он показывает себя как &lt;code&gt;@trusted pure nothrow&lt;/code&gt; , чтобы не нарушать существующий код.</target>
        </trans-unit>
        <trans-unit id="269ccafe0cbb6bd48c0c364d60e7c6c6e04d5947" translate="yes" xml:space="preserve">
          <source>The same applies to other &lt;code&gt;Object&lt;/code&gt; methods such as &lt;code&gt;opCmp&lt;/code&gt;, &lt;code&gt;toHash&lt;/code&gt;, etc.</source>
          <target state="translated">То же самое относится и к другим методам &lt;code&gt;Object&lt;/code&gt; , таким как &lt;code&gt;opCmp&lt;/code&gt; , &lt;code&gt;toHash&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="e9e9404807d647f780072b029fb88dbb6d89a0b9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt;, except that final functions that do not override anything are included.</source>
          <target state="translated">Так же, как &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt; , за исключением того, что включены заключительные функции, которые ничего не переопределяют.</target>
        </trans-unit>
        <trans-unit id="93baf85b2a1ff9ebbdedf5ac60d17440ac90bad4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt;, except that final functions that don't override anything return true.</source>
          <target state="translated">Так же, как &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt; , за исключением того, что конечные функции, которые ничего не переопределяют, возвращают true.</target>
        </trans-unit>
        <trans-unit id="484feea935bb2f51a17677737f5a18c29ab34260" translate="yes" xml:space="preserve">
          <source>The same is true for structs.</source>
          <target state="translated">То же самое относится и к структурам.</target>
        </trans-unit>
        <trans-unit id="daa76d61107754eb643bbf2894986cd43d9f6292" translate="yes" xml:space="preserve">
          <source>The same lookup across blocks, scripts, or binary properties, but performed at run-time. This version is provided for cases where &lt;code&gt;name&lt;/code&gt; is not known beforehand; otherwise compile-time checked &lt;a href=&quot;#opDispatch&quot;&gt;&lt;code&gt;opDispatch&lt;/code&gt;&lt;/a&gt; is typically a better choice.</source>
          <target state="translated">Тот же поиск блоков, сценариев или двоичных свойств, но выполняется во время выполнения. Эта версия предназначена для случаев, когда &lt;code&gt;name&lt;/code&gt; не известно заранее; в противном случае проверенный временем компиляции &lt;a href=&quot;#opDispatch&quot;&gt; &lt;code&gt;opDispatch&lt;/code&gt; &lt;/a&gt; обычно является лучшим выбором.</target>
        </trans-unit>
        <trans-unit id="bed255bb45839fece8e5cb2e49994a8474ab1390" translate="yes" xml:space="preserve">
          <source>The saturated result of the operator.</source>
          <target state="translated">Насыщенный результат оператора.</target>
        </trans-unit>
        <trans-unit id="44ebf5442f3ff515c11231f709e48f19fb0fd8ce" translate="yes" xml:space="preserve">
          <source>The scanner function. It should scan from p1 through p2 - 1.</source>
          <target state="translated">Функция сканера.Он должен сканировать от p1 до p2-1.</target>
        </trans-unit>
        <trans-unit id="2b5611ba00d0c5303ec080902ad8f7d6474ce6c0" translate="yes" xml:space="preserve">
          <source>The scanning function.</source>
          <target state="translated">Функция сканирования.</target>
        </trans-unit>
        <trans-unit id="6c94bc26dd8e2388a5758b02c027326a48e92c3c" translate="yes" xml:space="preserve">
          <source>The scheduling priority of this thread.</source>
          <target state="translated">Приоритет планирования этого потока.</target>
        </trans-unit>
        <trans-unit id="bce914b8aac817557e08a2a5b7b1a5b382065247" translate="yes" xml:space="preserve">
          <source>The scope characteristic is inherited, so any classes derived from a scope class are also scope.</source>
          <target state="translated">Характеристика области видимости наследуется,поэтому любые классы,производные от класса области видимости,также являются областью видимости.</target>
        </trans-unit>
        <trans-unit id="bece65d16e0da3cd8d963615575ef27d8569dde0" translate="yes" xml:space="preserve">
          <source>The second</source>
          <target state="translated">Второй</target>
        </trans-unit>
        <trans-unit id="f0aa270a7ba151a0f73151e3a972f6dc7bf0ee07" translate="yes" xml:space="preserve">
          <source>The second array to compare</source>
          <target state="translated">Второй массив для сравнения</target>
        </trans-unit>
        <trans-unit id="970cba63abb463ea9e374f88bdbe56bd7fb71605" translate="yes" xml:space="preserve">
          <source>The second form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;ref&lt;/code&gt;, and has &lt;a href=&quot;#return-ref-parameters&quot;&gt;return ref parameter&lt;/a&gt; semantics with additional &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;scope parameter&lt;/a&gt; semantics.</source>
          <target state="translated">Вторая форма присоединяет &lt;code&gt;return&lt;/code&gt; к &lt;code&gt;ref&lt;/code&gt; и имеет семантику &lt;a href=&quot;#return-ref-parameters&quot;&gt;возвращаемого параметра ref&lt;/a&gt; с дополнительной семантикой &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;параметра scope&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="061d4f927a4a2679d380b604c58cb6c22d22e3d1" translate="yes" xml:space="preserve">
          <source>The second form of this function is usually not called directly; instead, it is used via &lt;a href=&quot;std_string#format&quot;&gt;&lt;code&gt;std.string.format&lt;/code&gt;&lt;/a&gt;, as shown in the examples below. Supported format characters are 'e', 'f', 'g', 'a', and 's'.</source>
          <target state="translated">Вторая форма этой функции обычно не вызывается напрямую; вместо этого он используется через &lt;a href=&quot;std_string#format&quot;&gt; &lt;code&gt;std.string.format&lt;/code&gt; &lt;/a&gt; , как показано в примерах ниже. Поддерживаемые символы формата: &amp;laquo;e&amp;raquo;, &amp;laquo;f&amp;raquo;, &amp;laquo;g&amp;raquo;, &amp;laquo;a&amp;raquo; и &amp;laquo;s&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6175891dc518c6e785380cc43703fbdbef055ecb" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;goto default;&lt;/code&gt;, transfers to the innermost &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; of an enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Вторая форма, &lt;code&gt;goto default;&lt;/code&gt; , передает внутреннему &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; включающего &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b51588d42d45bcafc26dcdf68b259620359d8f6" translate="yes" xml:space="preserve">
          <source>The second function</source>
          <target state="translated">Вторая функция</target>
        </trans-unit>
        <trans-unit id="9a381cf5b12ec2751302d71f1f36bb254a3a2a6d" translate="yes" xml:space="preserve">
          <source>The second makes use of template mixins:</source>
          <target state="translated">Второй использует смеси шаблонов:</target>
        </trans-unit>
        <trans-unit id="b6d7d023028752f2dd5e8e8741a79baee2991163" translate="yes" xml:space="preserve">
          <source>The second portion of the time;</source>
          <target state="translated">Вторую часть времени;</target>
        </trans-unit>
        <trans-unit id="d17baa58ea7c9cb2b5fdeeba1668762e0d314080" translate="yes" xml:space="preserve">
          <source>The second range</source>
          <target state="translated">Второй диапазон</target>
        </trans-unit>
        <trans-unit id="03495ddd562bb985866c15203033cded1697fdb5" translate="yes" xml:space="preserve">
          <source>The second range to be compared.</source>
          <target state="translated">Второй диапазон для сравнения.</target>
        </trans-unit>
        <trans-unit id="17805909c78bc23c485d6d0eee55678a2626d3ec" translate="yes" xml:space="preserve">
          <source>The second range.</source>
          <target state="translated">Второй диапазон.</target>
        </trans-unit>
        <trans-unit id="b5c0d389b19e84b52a4b93582ba1ef6275bab88b" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">Второй, чтобы установить второй &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5f5f8367bfce8ad586cc8594d3c281eb469bd2" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">Второй, чтобы установить второй &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="996418c92be5b452f3de4ff986e1cee8b8da9918" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; чтобы установить в секундах этого TimeOfDay .</target>
        </trans-unit>
        <trans-unit id="fb3c67e4431bd2d01f2e0a28a1a5ab4c776bb0a0" translate="yes" xml:space="preserve">
          <source>The second type to receive the type name for</source>
          <target state="translated">Второй тип для получения имени типа для</target>
        </trans-unit>
        <trans-unit id="572604b99f4f13c97178a7bb83d0a01c9c1fdbf8" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;AutoImplement&lt;/code&gt; automatically implements &lt;code&gt;Interface&lt;/code&gt;, while deriving from &lt;code&gt;BaseClass&lt;/code&gt;.</source>
          <target state="translated">Вторая версия &lt;code&gt;AutoImplement&lt;/code&gt; автоматически реализует &lt;code&gt;Interface&lt;/code&gt; , &lt;code&gt;BaseClass&lt;/code&gt; от BaseClass .</target>
        </trans-unit>
        <trans-unit id="9922ebb56662094439fd0982652299a78a77cb79" translate="yes" xml:space="preserve">
          <source>The second version of the function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.  In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">Вторая версия функции записывает данные в &lt;code&gt;sharedLog&lt;/code&gt; в стиле &lt;code&gt;printf&lt;/code&gt; . Для того , чтобы в результате сообщения журнала , которые будут перенесены на &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;sharedLog&lt;/code&gt; и должно быть больше или равно , чем глобальная &lt;code&gt;LogLevel&lt;/code&gt; . Дополнительно &lt;code&gt;LogLevel&lt;/code&gt; должно быть больше или равно , чем &lt;code&gt;LogLevel&lt;/code&gt; в &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca00f96f63ee8d1d8ffcc6e490cc9b3f2af7ff1" translate="yes" xml:space="preserve">
          <source>The second version returns the number of times &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;haystack&lt;/code&gt;. Throws an exception if &lt;code&gt;needle.empty&lt;/code&gt;, as the count of the empty range in any range would be infinite. Overlapped counts are not considered, for example &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Вторая версия возвращает число раз &lt;code&gt;needle&lt;/code&gt; происходит в &lt;code&gt;haystack&lt;/code&gt; . Выдает исключение, если &lt;code&gt;needle.empty&lt;/code&gt; , так как количество пустых диапазонов в любом диапазоне будет бесконечным. Счетчики с перекрытием не учитываются, например, &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; равен &lt;code&gt;1&lt;/code&gt; , а не &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ad6e5d9828f85ec68413d4266b0a775c993286" translate="yes" xml:space="preserve">
          <source>The second way is to cast data to immutable. When doing so, it is up to the programmer to ensure that any mutable references to the same data are not used to modify the data after the cast.</source>
          <target state="translated">Второй способ заключается в приведении данных к непреложности.При этом программист должен убедиться,что любые мутирующие ссылки на те же самые данные не используются для модификации данных после кастинга.</target>
        </trans-unit>
        <trans-unit id="98a2a2f9f0974d5cf21ef2c42fb8d7b511ec7622" translate="yes" xml:space="preserve">
          <source>The second way is to use the precision specifier. The length comes first, followed by the pointer:</source>
          <target state="translated">Второй способ-использование спецификатора точности.Сначала идет длина,затем указатель:</target>
        </trans-unit>
        <trans-unit id="6258e42911fadc579ef629cac8b879505c815405" translate="yes" xml:space="preserve">
          <source>The second will queue readers if there are any writers queued. Writers are passed through one at a time, and once there are no writers present, all queued readers will be alerted.</source>
          <target state="translated">Второй будет ставить в очередь читателей,если в очереди есть какие-нибудь писатели.Писатели проходят по одному,и как только их нет в очереди,все стоящие в очереди читатели будут предупреждены.</target>
        </trans-unit>
        <trans-unit id="222f9be8417077b869fc4ec2ffe85613dca810b0" translate="yes" xml:space="preserve">
          <source>The selector parameter for Objective-C methods.</source>
          <target state="translated">Параметр селектора для методов Objective-C.</target>
        </trans-unit>
        <trans-unit id="c7b62a580f33ebf95a2e808ad6d0fddcde51f3ed" translate="yes" xml:space="preserve">
          <source>The semantics of a bidirectional range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">Предполагается, что семантика двунаправленного диапазона (не проверяемого во время компиляции) следующая ( &lt;code&gt;r&lt;/code&gt; - это объект типа &lt;code&gt;R&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="17817f0aec7117e53dffc5a42bb0ce81b624678f" translate="yes" xml:space="preserve">
          <source>The semantics of a forward range (not checkable during compilation) are the same as for an input range, with the additional requirement that backtracking must be possible by saving a copy of the range object with &lt;code&gt;save&lt;/code&gt; and using it later.</source>
          <target state="translated">Семантика переднего диапазона (не подлежит проверке во время компиляции) такая же, как и для входного диапазона, с дополнительным требованием, чтобы возврат был возможен путем сохранения копии объекта диапазона с &lt;code&gt;save&lt;/code&gt; и последующего использования.</target>
        </trans-unit>
        <trans-unit id="9ad7ef472479146863a20e103ea6caeaec90cbb2" translate="yes" xml:space="preserve">
          <source>The semantics of a module are not affected by what imports it.</source>
          <target state="translated">Семантика модуля не зависит от того,что его импортирует.</target>
        </trans-unit>
        <trans-unit id="1896dacb2ba5ac95d6272bdae742dc30f30d5318" translate="yes" xml:space="preserve">
          <source>The semantics of a random-access range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">Предполагается, что семантика диапазона произвольного доступа (не проверяемого во время компиляции) является следующей ( &lt;code&gt;r&lt;/code&gt; является объектом типа &lt;code&gt;R&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="a29d19e0a1c63b8d3f0187e1b535c432966dec4b" translate="yes" xml:space="preserve">
          <source>The semaphore module provides a general use semaphore for synchronization.</source>
          <target state="translated">Семафорный модуль общего назначения обеспечивает семафор для синхронизации.</target>
        </trans-unit>
        <trans-unit id="0cb8e57171fd0fa8e03b5c22f3ff466ddf864a6e" translate="yes" xml:space="preserve">
          <source>The sequence of tokens is parsed to form syntax trees.</source>
          <target state="translated">Последовательность токенов анализируется с целью формирования синтаксических деревьев.</target>
        </trans-unit>
        <trans-unit id="438ac8d829e20acc25c07ebf7273d7538987132c" translate="yes" xml:space="preserve">
          <source>The sequence to check for the &lt;code&gt;BOM&lt;/code&gt;</source>
          <target state="translated">Последовательность для проверки &lt;code&gt;BOM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aec41afa837cbb030bd78ed48712b8225ab720a9" translate="yes" xml:space="preserve">
          <source>The short symbol for this option</source>
          <target state="translated">Короткий символ для этой опции</target>
        </trans-unit>
        <trans-unit id="14ab0adc14c1851e03d1a893322666eb1605f066" translate="yes" xml:space="preserve">
          <source>The shuffled random-access range.</source>
          <target state="translated">Перепутанный диапазон случайного доступа.</target>
        </trans-unit>
        <trans-unit id="b938bafa6a37b04fed1bbf8b758bf0a54b828b83" translate="yes" xml:space="preserve">
          <source>The sign of &amp;Gamma;(x).</source>
          <target state="translated">Знак &amp;Gamma; (x).</target>
        </trans-unit>
        <trans-unit id="691fa1f516ff445955097300abb84801c17ce9af" translate="yes" xml:space="preserve">
          <source>The signature of this function should be:</source>
          <target state="translated">Подпись этой функции должна быть:</target>
        </trans-unit>
        <trans-unit id="1c551bae643970a0fd547169fd9a9d141dddbbc8" translate="yes" xml:space="preserve">
          <source>The signed type is converted to the unsigned type.</source>
          <target state="translated">Знаковый тип преобразуется в беззнаковый.</target>
        </trans-unit>
        <trans-unit id="ee800310ad7741a1c2a988b7683af21966b44816" translate="yes" xml:space="preserve">
          <source>The similarity per &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; has an issue in that it grows with the lengths of the two strings, even though the strings are not actually very similar. For example, the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; is increasingly similar with the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; as more instances of &lt;code&gt;&quot;world&quot;&lt;/code&gt; are appended. To prevent that, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; computes a normalized version of the similarity that is computed as &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt;. The function &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (a so-called normalized kernel) is bounded in &lt;code&gt;[0, 1]&lt;/code&gt;, reaches &lt;code&gt;0&lt;/code&gt; only for ranges that don't match in any position, and &lt;code&gt;1&lt;/code&gt; only for identical ranges.</source>
          <target state="translated">Сходство в &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; на gapWeightedSogeneity связано с тем, что оно увеличивается с длиной двух строк, хотя строки на самом деле не очень похожи. Например, диапазон &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; становится все более сходным с диапазоном &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; как добавляется больше экземпляров &lt;code&gt;&quot;world&quot;&lt;/code&gt; , Чтобы предотвратить это, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; вычисляет нормализованную версию сходства, которая вычисляется как &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt; .Функция &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (так называемое нормализованное ядро) ограничена в &lt;code&gt;[0, 1]&lt;/code&gt; , достигает &lt;code&gt;0&lt;/code&gt; только для диапазонов, которые не совпадают ни в одной позиции, и &lt;code&gt;1&lt;/code&gt; только для идентичных диапазонов.</target>
        </trans-unit>
        <trans-unit id="88799e576696dc3374489d7e5f75d72056dc1dfa" translate="yes" xml:space="preserve">
          <source>The simplest form of importing is to just list the modules being imported:</source>
          <target state="translated">Самая простая форма импорта-просто перечислить импортируемые модули:</target>
        </trans-unit>
        <trans-unit id="e2009ad4b4c0d89d88051ad98575cc82bbbcf921" translate="yes" xml:space="preserve">
          <source>The simplest immutable declarations use it as a storage class. It can be used to declare manifest constants.</source>
          <target state="translated">Самые простые неизменяемые декларации используют его как класс хранения.Его можно использовать для объявления манифестных констант.</target>
        </trans-unit>
        <trans-unit id="b20f562102f67ba45af181d477da8263c4656fad" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;bringToFront&lt;/code&gt; is for rotating elements in a buffer. For example:</source>
          <target state="translated">Простейшее использование метода &lt;code&gt;bringToFront&lt;/code&gt; - вращение элементов в буфере. Например:</target>
        </trans-unit>
        <trans-unit id="87bc4b882bb607c1c565d6a1ffe9da4b18a9935d" translate="yes" xml:space="preserve">
          <source>The sine and cosine of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="translated">Синус и косинус &lt;code&gt;z&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="4beb2d03043706421491257b91174cce75401dc3" translate="yes" xml:space="preserve">
          <source>The single element to check.</source>
          <target state="translated">Единственный элемент для проверки.</target>
        </trans-unit>
        <trans-unit id="e20b632a66e4a0973d296fc8dc97c6e7878340fa" translate="yes" xml:space="preserve">
          <source>The single needle to check, which may be either a single element or an input range of elements.</source>
          <target state="translated">Одиночная игла для проверки,которая может быть как отдельным элементом,так и входным диапазоном элементов.</target>
        </trans-unit>
        <trans-unit id="936e0c490ea32a66488b88e6407723c37e53055d" translate="yes" xml:space="preserve">
          <source>The size in bytes of the block to add. If sz is zero then the no operation will occur. If p is null then sz must be zero.</source>
          <target state="translated">Размер в байтах добавляемого блока.Если sz равен нулю,то операция не будет выполнена.Если p равен нулю,то sz должно быть нулевым.</target>
        </trans-unit>
        <trans-unit id="d5f548166d575892e245b5d531ead88e195d968a" translate="yes" xml:space="preserve">
          <source>The size in bytes of the extended memory block referenced by p or zero if no extension occurred.</source>
          <target state="translated">Размер в байтах расширенного блока памяти,на который ссылается p или ноль,если расширение не произошло.</target>
        </trans-unit>
        <trans-unit id="f5a5bf7ffaae9ea0e47a648c75ab38577c22cdee" translate="yes" xml:space="preserve">
          <source>The size in bytes of the memory block referenced by p or zero on error.</source>
          <target state="translated">Размер в байтах блока памяти,на который по ошибке ссылается p или ноль.</target>
        </trans-unit>
        <trans-unit id="47c428b4443aaffa87ab01d194f64c1d9938dadd" translate="yes" xml:space="preserve">
          <source>The size of each block can be selected either during compilation or at run time. Statically-known block sizes are frequent in practice and yield slightly better performance. To choose a block size statically, pass it as the &lt;code&gt;blockSize&lt;/code&gt; parameter as in &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt;. To choose a block size parameter, use &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; and pass the block size to the constructor.</source>
          <target state="translated">Размер каждого блока можно выбрать во время компиляции или во время выполнения. Статически известные размеры блоков часто встречаются на практике и дают немного лучшую производительность. Чтобы статически выбрать размер блока, передайте его как параметр &lt;code&gt;blockSize&lt;/code&gt; , как в &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt; . Чтобы выбрать параметр размера блока, используйте &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; и передайте размер блока конструктору.</target>
        </trans-unit>
        <trans-unit id="a8db79a8cc24d1fb50ebc2a5392b4de19bea96fb" translate="yes" xml:space="preserve">
          <source>The size of each chunk</source>
          <target state="translated">Размер каждого кусочка</target>
        </trans-unit>
        <trans-unit id="812d083ae4b6202df6ef9285312c396838fbce8c" translate="yes" xml:space="preserve">
          <source>The size of file in bytes.</source>
          <target state="translated">Размер файла в байтах.</target>
        </trans-unit>
        <trans-unit id="5299bf2c3bb77629866128b69aa3cd98cc936e97" translate="yes" xml:space="preserve">
          <source>The size of the allocated length at the end depends on the block size:</source>
          <target state="translated">Размер выделенной длины в конце зависит от размера блока:</target>
        </trans-unit>
        <trans-unit id="a507a2fd30a698197eb87aec60496407de2cc9b4" translate="yes" xml:space="preserve">
          <source>The size of the buffer to store the evaluated elements.</source>
          <target state="translated">Размер буфера для хранения вычисленных элементов.</target>
        </trans-unit>
        <trans-unit id="f51f328cc82fa5e1146c1bcd8d39f77ba7f1a772" translate="yes" xml:space="preserve">
          <source>The size of the chunks</source>
          <target state="translated">Размер кусков</target>
        </trans-unit>
        <trans-unit id="f95ddc1cb4621988d676a326385232a6d69ff6df" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buf&lt;/code&gt; containing the formatted string.</source>
          <target state="translated">Кусочек &lt;code&gt;buf&lt;/code&gt; содержащий отформатированную строку.</target>
        </trans-unit>
        <trans-unit id="c76fb8fffafacca9cf978997fee5c7ec6adb0669" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buffer&lt;/code&gt; containing the data that was actually read. This will be shorter than &lt;code&gt;buffer&lt;/code&gt; if EOF was reached before the buffer could be filled.</source>
          <target state="translated">Часть &lt;code&gt;buffer&lt;/code&gt; содержащая данные, которые были фактически прочитаны. Это будет короче &lt;code&gt;buffer&lt;/code&gt; если EOF был достигнут до того, как буфер мог быть заполнен.</target>
        </trans-unit>
        <trans-unit id="25175c4c04d78f4f21e72598ea69bd88d569188a" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;target&lt;/code&gt; containing the copied elements.</source>
          <target state="translated">Кусочек &lt;code&gt;target&lt;/code&gt; содержащий скопированные элементы.</target>
        </trans-unit>
        <trans-unit id="ad4934ab24ff890e3942dd0930dacb128284b747" translate="yes" xml:space="preserve">
          <source>The slice of buffer containing the decoded result.</source>
          <target state="translated">Кусочек буфера,содержащий декодированный результат.</target>
        </trans-unit>
        <trans-unit id="2493c4fc7b08258cd8cb15270e3f883e67df77ba" translate="yes" xml:space="preserve">
          <source>The slice of buffer that contains the encoded string.</source>
          <target state="translated">Кусочек буфера,содержащий закодированную строку.</target>
        </trans-unit>
        <trans-unit id="ad35a55effab17cdb298d4bb62b7946a0a05ee95" translate="yes" xml:space="preserve">
          <source>The slice on the left and any slices on the right must not overlap. All operands are evaluated exactly once, even if the array slice has zero elements in it.</source>
          <target state="translated">Фрагмент слева и любые фрагменты справа не должны перекрываться.Все операнды вычисляются ровно один раз,даже если в массиве срез имеет нулевые элементы.</target>
        </trans-unit>
        <trans-unit id="7d8c2f61d4c506e7a291057e4bc000a710aed4c4" translate="yes" xml:space="preserve">
          <source>The slice's usable size will not match the block size. Use &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; to retrieve actual usable capacity.</source>
          <target state="translated">Полезный размер среза не будет соответствовать размеру блока. Используйте &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; чтобы получить фактическую полезную емкость.</target>
        </trans-unit>
        <trans-unit id="bba8f7aecbe8029037e1ea79aca03fd651b20234" translate="yes" xml:space="preserve">
          <source>The smallest size that can be allocated is two words (16 bytes on 64-bit systems, 8 bytes on 32-bit systems). This is because the free list management needs two words (one for the length, the other for the next pointer in the singly-linked list).</source>
          <target state="translated">Наименьший размер,который может быть выделен,-два слова (16 байт на 64-битных системах,8 байт на 32-битных).Это связано с тем,что для свободного управления списками необходимо два слова (одно для длины,другое для следующего указателя в односвязанном списке).</target>
        </trans-unit>
        <trans-unit id="c8f2935f9d51846f40ce3a8ff14ea8411e17c417" translate="yes" xml:space="preserve">
          <source>The so-called &quot;all-lengths gap-weighted string kernel&quot; computes a similarity measure between &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; based on all of their common subsequences of all lengths. Gapped subsequences are also included.</source>
          <target state="translated">Так называемое &amp;laquo;строковое ядро ​​со взвешиванием на всю длину&amp;raquo; вычисляет меру подобия между &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;t&lt;/code&gt; на основе всех их общих подпоследовательностей всех длин. Гапсовые подпоследовательности также включены.</target>
        </trans-unit>
        <trans-unit id="b69c2f4a1b196deb3a8f2c9757a25cc977da4151" translate="yes" xml:space="preserve">
          <source>The solution is to use exception handling to report errors. All errors are objects derived from abstract class &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;Error&lt;/code&gt; has a pure virtual function called toString() which produces a &lt;code&gt;string&lt;/code&gt; with a human readable description of the error.</source>
          <target state="translated">Решение состоит в том, чтобы использовать обработку исключений для сообщения об ошибках. Все ошибки являются объектами, производными от абстрактного класса &lt;code&gt;Error&lt;/code&gt; . &lt;code&gt;Error&lt;/code&gt; имеет чисто виртуальную функцию toString (), которая создает &lt;code&gt;string&lt;/code&gt; с понятным для человека описанием ошибки.</target>
        </trans-unit>
        <trans-unit id="869eb1c2ddd5095ece630ff3cd9aa908770a28d3" translate="yes" xml:space="preserve">
          <source>The sorted alias sequence</source>
          <target state="translated">Сортированная последовательность псевдонимов</target>
        </trans-unit>
        <trans-unit id="5890e22a27a487c3d84b74c6aadd83e7f574f4f1" translate="yes" xml:space="preserve">
          <source>The sorted, left-hand side of the random access range to be sorted.</source>
          <target state="translated">Сортировка с левой стороны случайного диапазона доступа,который должен быть отсортирован.</target>
        </trans-unit>
        <trans-unit id="327825eee250d31d85788280f6649c7f91900518" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;Tuple&lt;/code&gt; to assign from. Each element of the source &lt;code&gt;Tuple&lt;/code&gt; must be implicitly assignable to each respective element of the target &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">Исходный &lt;code&gt;Tuple&lt;/code&gt; для назначения. Каждый элемент исходного &lt;code&gt;Tuple&lt;/code&gt; должен быть неявно назначен каждому соответствующему элементу целевого &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5030b9b136204dc20df5dd72c92bea98a422bbd5" translate="yes" xml:space="preserve">
          <source>The source file is checked to see what character set it is, and the appropriate scanner is loaded. ASCII and UTF formats are accepted.</source>
          <target state="translated">Проверяется исходный файл,чтобы узнать,какой это набор символов,и загружается соответствующий сканер.Принимаются форматы ASCII и UTF.</target>
        </trans-unit>
        <trans-unit id="dfdc9b54ae3eba8ba8704bc6e8f6a3bd3398e870" translate="yes" xml:space="preserve">
          <source>The source file is divided up into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="translated">Исходный файл разбит на последовательность токенов. &lt;a href=&quot;lex#specialtokens&quot;&gt;Специальные токены&lt;/a&gt; заменяются другими токенами. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; s обрабатываются и удаляются.</target>
        </trans-unit>
        <trans-unit id="81874a58d9273e37ffa0ff4c91450536e1226f36" translate="yes" xml:space="preserve">
          <source>The source file name of the caller.</source>
          <target state="translated">Имя исходного файла вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="63c931360a6dacfd65be2e57e259c4c016ac5c72" translate="yes" xml:space="preserve">
          <source>The source file of the caller.</source>
          <target state="translated">Исходный файл звонящего.</target>
        </trans-unit>
        <trans-unit id="5e1d1c43260b49fce3e8356d81c8f39a6eaf6f86" translate="yes" xml:space="preserve">
          <source>The source location.</source>
          <target state="translated">Местоположение источника.</target>
        </trans-unit>
        <trans-unit id="57597d8f1413ea294f9a97a53e7900b691ef6e36" translate="yes" xml:space="preserve">
          <source>The source object</source>
          <target state="translated">Объект-источник</target>
        </trans-unit>
        <trans-unit id="a8df6910eb6a7836cdf1dd95711fe44c7f692e87" translate="yes" xml:space="preserve">
          <source>The source of the cast</source>
          <target state="translated">Источник литья</target>
        </trans-unit>
        <trans-unit id="79f7b5f01174bbbd5d3e9abcd1ae8cab2d28d824" translate="yes" xml:space="preserve">
          <source>The source range.</source>
          <target state="translated">Диапазон источников.</target>
        </trans-unit>
        <trans-unit id="139f7114b9b6fbeefdd429dfd8ce09ec26e9b7ae" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, all followed by &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Исходный текст декодируется из его исходного представления в Unicode , &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;символы&lt;/i&gt;&lt;/a&gt; с. В &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Символьном&lt;/i&gt;&lt;/a&gt; ы далее разделен на: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;пробельный&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;комментарий&lt;/i&gt;&lt;/a&gt; с, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; ы, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;маркера&lt;/i&gt;&lt;/a&gt; с, а затем все &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;ENDOFFILE&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21e734d8ecbd4a33f2c2bfd5df8fb1b69390624d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch technique, i.e., the lexical analyzer makes the longest token it can. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="translated">Исходный текст разбивается на токены с использованием техники максимального жевания, т. Е. Лексический анализатор создает самый длинный токен, какой только может. Например, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; - токен сдвига вправо, а не два больше токенов. Есть два исключения из этого правила:</target>
        </trans-unit>
        <trans-unit id="262fd934f3ad11cda48e320770c23b6cbce4d978" translate="yes" xml:space="preserve">
          <source>The source text is terminated by whichever comes first.</source>
          <target state="translated">Исходный текст завершается в зависимости от того,что наступит раньше.</target>
        </trans-unit>
        <trans-unit id="81738bf1b1d3def6ac2869102bc650c16fdd9cf9" translate="yes" xml:space="preserve">
          <source>The source type in the conversion or comparison</source>
          <target state="translated">Тип источника при преобразовании или сравнении</target>
        </trans-unit>
        <trans-unit id="7363cb9e0bea89a84f2ef7322159cb48984847e8" translate="yes" xml:space="preserve">
          <source>The specific &lt;code&gt;LogLevel&lt;/code&gt; used for logging the log message.</source>
          <target state="translated">Определенный &lt;code&gt;LogLevel&lt;/code&gt; , используемый для регистрации сообщения журнала.</target>
        </trans-unit>
        <trans-unit id="02d763555333f9cf77c0541a37bf5b34481db397" translate="yes" xml:space="preserve">
          <source>The specification for the form of embedded documentation comments only specifies how information is to be presented to the compiler. It is implementation-defined how that information is used and the form of the final presentation. Whether the final presentation form is an HTML web page, a man page, a PDF file, etc. is not specified as part of the D Programming Language.</source>
          <target state="translated">В спецификации формы встроенных комментариев к документации указано только то,как информация должна быть представлена компилятору.Она определяет реализацию-как эта информация используется и форму конечного представления.Является ли конечная форма представления HTML веб-страницей,man-страницей,PDF-файлом и т.д.,не указывается как часть языка программирования D.</target>
        </trans-unit>
        <trans-unit id="c631213db2c74550b3a422d0caf42968e12b014d" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Квадратный корень из &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b54a2e145a2a6ad88bd2025575b8d9841ee25294" translate="yes" xml:space="preserve">
          <source>The squared modulus of &lt;code&gt;z&lt;/code&gt;. For genericity, if called on a real number, returns its square.</source>
          <target state="translated">Модуль квадрата &lt;code&gt;z&lt;/code&gt; . Для универсальности, если вызывается на действительное число, возвращает его квадрат.</target>
        </trans-unit>
        <trans-unit id="d04cf6152ee5948faeb5107c99bbd4c4ee9e3f00" translate="yes" xml:space="preserve">
          <source>The stack and/or registers are being scanned.</source>
          <target state="translated">Стек и/или регистры сканируются.</target>
        </trans-unit>
        <trans-unit id="7f3ea7f5b668b927908903c59ab3b69fcb5af861" translate="yes" xml:space="preserve">
          <source>The stack size for this fiber.</source>
          <target state="translated">Размер стопки для этого волокна.</target>
        </trans-unit>
        <trans-unit id="d77b689dcb1ab13845e33f5ac0d239d2be984a77" translate="yes" xml:space="preserve">
          <source>The stack size for this thread.</source>
          <target state="translated">Размер стопки для этой нити.</target>
        </trans-unit>
        <trans-unit id="1902c662d9b13b82fe81369d128dde4e10ffcdaa" translate="yes" xml:space="preserve">
          <source>The stack trace of where the error happened. This is an opaque object that can either be converted to &lt;code&gt;string&lt;/code&gt;, or iterated over with &lt;code&gt; foreach&lt;/code&gt; to extract the items in the stack trace (as strings).</source>
          <target state="translated">Трассировка стека, где произошла ошибка. Это непрозрачный объект, который можно преобразовать в &lt;code&gt;string&lt;/code&gt; или перебрать с помощью &lt;code&gt; foreach&lt;/code&gt; для извлечения элементов в трассировке стека (в виде строк).</target>
        </trans-unit>
        <trans-unit id="9f20dc3ac3213d71596e365d3a32376deda65355" translate="yes" xml:space="preserve">
          <source>The stack variables referenced by a nested function are still valid even after the function exits (this is different from D 1.0). This is called a</source>
          <target state="translated">Переменные стека,на которые ссылается вложенная функция,остаются действительными даже после выхода из функции (это отличается от D 1.0).Это называется</target>
        </trans-unit>
        <trans-unit id="813353f101357b03d0b61c073a4c5ccf1975eaf3" translate="yes" xml:space="preserve">
          <source>The standard HTTP methods : &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616 Section 5.1.1&lt;/a&gt;</source>
          <target state="translated">Стандартные методы HTTP: &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616, раздел 5.1.1.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5be2cd87a2b0f4860fcc1853c1fefdfb3d5a3f6e" translate="yes" xml:space="preserve">
          <source>The standard error stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's error stream.</source>
          <target state="translated">Стандартный поток ошибок дочернего процесса. Это может быть любой &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; , открытый для записи. По умолчанию дочерний процесс наследует поток ошибок родителя.</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">Стандартный поток ошибок.</target>
        </trans-unit>
        <trans-unit id="28e8c3771deea57b1287ddecdda74142b64d7ee8" translate="yes" xml:space="preserve">
          <source>The standard input stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for reading. By default the child process inherits the parent's input stream.</source>
          <target state="translated">Стандартный поток ввода дочернего процесса. Это может быть любой &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; , открытый для чтения. По умолчанию дочерний процесс наследует входной поток родителя.</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">Стандартный входной поток.</target>
        </trans-unit>
        <trans-unit id="7f5d48c8b0f2de69f4c747237a77a2d1bfba7b08" translate="yes" xml:space="preserve">
          <source>The standard library lends a hand for comparing strings with mixed encodings (by transparently decoding, see &lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt;&lt;code&gt;std.algorithm.cmp&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;case-insensitive comparison&lt;/a&gt; and &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;normalization&lt;/a&gt;.</source>
          <target state="translated">Стандартная библиотека предоставляет возможности для сравнения строк со смешанным кодированием (путем прозрачного декодирования, см. &lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt; &lt;code&gt;std.algorithm.cmp&lt;/code&gt; &lt;/a&gt; ), &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;сравнения&lt;/a&gt; и &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;нормализации без &lt;/a&gt;учета регистра .</target>
        </trans-unit>
        <trans-unit id="d461322cb73ba656cc10ee6e78ac236193d95ae6" translate="yes" xml:space="preserve">
          <source>The standard output stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's output stream.</source>
          <target state="translated">Стандартный поток вывода дочернего процесса. Это может быть любой &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; , открытый для записи. По умолчанию дочерний процесс наследует поток вывода родителя.</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">Стандартный выходной поток.</target>
        </trans-unit>
        <trans-unit id="21e7fda428c2c6b1ed80304e44601e7fae93a662" translate="yes" xml:space="preserve">
          <source>The start tag of the element</source>
          <target state="translated">Стартовый тег элемента</target>
        </trans-unit>
        <trans-unit id="e872d9d6a6689ad057f6c088df86c8dbaa1e7c70" translate="yes" xml:space="preserve">
          <source>The starting point of the interval. It is included in the interval.</source>
          <target state="translated">Начальная точка интервала.Она включена в интервал.</target>
        </trans-unit>
        <trans-unit id="3554fc05aa3ab3a9ddf7ec9973a0bf7f4072e5a0" translate="yes" xml:space="preserve">
          <source>The starting value.</source>
          <target state="translated">Начальное значение.</target>
        </trans-unit>
        <trans-unit id="a84bd1411e0ff3c732833affc83038a36b88c2e4" translate="yes" xml:space="preserve">
          <source>The state of the sequence is stored as a &lt;code&gt;Tuple&lt;/code&gt; so it can be heterogeneous.</source>
          <target state="translated">Состояние последовательности сохраняется как &lt;code&gt;Tuple&lt;/code&gt; поэтому оно может быть неоднородным.</target>
        </trans-unit>
        <trans-unit id="a8013cbe10851e46bc860bd1d31ef9871f35e223" translate="yes" xml:space="preserve">
          <source>The state of this fiber as an enumerated value.</source>
          <target state="translated">Состояние этого волокна как перечисленное значение.</target>
        </trans-unit>
        <trans-unit id="debdb4248e291669b86fe314e231ec5f465f64cb" translate="yes" xml:space="preserve">
          <source>The std time to convert.</source>
          <target state="translated">Время конвертации.</target>
        </trans-unit>
        <trans-unit id="e0b383e1171d8d015f97f2490da3a859a852e7d9" translate="yes" xml:space="preserve">
          <source>The stored &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">Сохраненная &lt;code&gt;Logger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d23198b78726b12c064950153015ab0cde6faecb" translate="yes" xml:space="preserve">
          <source>The strategy for finding the next available block is first fit.</source>
          <target state="translated">В первую очередь подходит стратегия поиска следующего доступного блока.</target>
        </trans-unit>
        <trans-unit id="c2420fb1448496dbbd08ceea8e09dc60562adfb8" translate="yes" xml:space="preserve">
          <source>The stream to pass to INTERLEAVEFUNCTION.</source>
          <target state="translated">Поток для перехода к ВВЕДЕНИЮ.</target>
        </trans-unit>
        <trans-unit id="18822dcb8b0bc3c64136bcaebcbf45df0cd6a713" translate="yes" xml:space="preserve">
          <source>The string</source>
          <target state="translated">Струна</target>
        </trans-unit>
        <trans-unit id="e64ff94f3ecfd8fab9d37892f66980e617d6433b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;command&lt;/code&gt; is passed verbatim to the shell, and is therefore subject to its rules about command structure, argument/filename quoting and escaping of special characters. The path to the shell executable defaults to &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Строковая &lt;code&gt;command&lt;/code&gt; передается дословно в оболочку и поэтому подчиняется ее правилам о структуре команд, цитировании аргументов / имен файлов и экранировании специальных символов. Путь к исполняемому файлу оболочки по умолчанию &lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf86f45ac17363df2917e94c577fdefa4162b88" translate="yes" xml:space="preserve">
          <source>The string indicating which characters to replace and what to replace them with. It is generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Строка, указывающая, какие символы заменить и чем их заменить. Это генерируется &lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0533873999a54cfe4dbbd386fac2585e64d8e51" translate="yes" xml:space="preserve">
          <source>The string is meant to be human readable, not machine parseable (e.g. whether there is an &lt;code&gt;'s'&lt;/code&gt; on the end of the unit name usually depends on whether it's plural or not, and empty units are not included unless the Duration is &lt;code&gt;zero&lt;/code&gt;). Any code needing a specific string format should use &lt;code&gt;total&lt;/code&gt; or &lt;code&gt;split&lt;/code&gt; to get the units needed to create the desired string format and create the string itself.</source>
          <target state="translated">Строка предназначена для чтения человеком, а не для машинного анализа (например, есть ли &lt;code&gt;'s'&lt;/code&gt; в конце имени блока, обычно зависит от того, множественное оно или нет, и пустые блоки не включаются, если Duration не равен &lt;code&gt;zero&lt;/code&gt; ). Любой код, для которого требуется определенный формат строки, должен использовать &lt;code&gt;total&lt;/code&gt; или &lt;code&gt;split&lt;/code&gt; , чтобы получить единицы, необходимые для создания желаемого формата строки и создания самой строки.</target>
        </trans-unit>
        <trans-unit id="2bd07e9629d13f3f409b884d3ffac3a7eb0da845" translate="yes" xml:space="preserve">
          <source>The string literal specifies a linker directive to be embedded in the generated object file.</source>
          <target state="translated">Строковый литерал задает директиву компоновщика,которая будет встроена в сгенерированный объектный файл.</target>
        </trans-unit>
        <trans-unit id="32d9e6c3c8e59228cc1e78ece5ad6aef58df9887" translate="yes" xml:space="preserve">
          <source>The string literals are assembled as UTF-8 char arrays, and the postfix is applied to convert to wchar or dchar as necessary as a final step.</source>
          <target state="translated">Строковые литералы собираются в виде графических массивов UTF-8,а постфикс применяется для преобразования в wchar или dchar по мере необходимости в качестве последнего шага.</target>
        </trans-unit>
        <trans-unit id="e1f9801101f016db2a559c014cb349546f881701" translate="yes" xml:space="preserve">
          <source>The string representation of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">Строковое представление этого &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95ecc1c83a5bc8c9a30b488436872240eb5cf883" translate="yes" xml:space="preserve">
          <source>The string that conventionally marks the end of all options (default '--').</source>
          <target state="translated">Строка,которая условно отмечает конец всех опций (по умолчанию '--').</target>
        </trans-unit>
        <trans-unit id="a364f528b991ce1bd157c8e5da1cb5665c7d72c5" translate="yes" xml:space="preserve">
          <source>The string to be decoded</source>
          <target state="translated">Расшифровываемая строка</target>
        </trans-unit>
        <trans-unit id="a6de95ac63fa71760fd1a5b11770046f783a2524" translate="yes" xml:space="preserve">
          <source>The string to be encoded</source>
          <target state="translated">Строка,которая должна быть закодирована</target>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="translated">Строка с заглавной буквы.</target>
        </trans-unit>
        <trans-unit id="cf1478823e2820a59dba10485e438b40c5348725" translate="yes" xml:space="preserve">
          <source>The string to center</source>
          <target state="translated">Строка к центру</target>
        </trans-unit>
        <trans-unit id="2e9ccd0a631efea8fdc72a8c62875a331c029bd3" translate="yes" xml:space="preserve">
          <source>The string to demangle.</source>
          <target state="translated">Строка,чтобы распутать.</target>
        </trans-unit>
        <trans-unit id="b67968a1752f9ee5eb2c12fda8191f64a6136ec4" translate="yes" xml:space="preserve">
          <source>The string to parse</source>
          <target state="translated">Строка для разбора</target>
        </trans-unit>
        <trans-unit id="5681bac273a271a57db9a94a9ee8c1380568e850" translate="yes" xml:space="preserve">
          <source>The string to return the representation of.</source>
          <target state="translated">Строка,возвращающая представление.</target>
        </trans-unit>
        <trans-unit id="6f72b4c4ff92e79f46043b6ac90fd712bc168dfd" translate="yes" xml:space="preserve">
          <source>The string used to separate the elements of an array or associative array (default is &quot;&quot; which means the elements are separated by whitespace).</source>
          <target state="translated">Строка,используемая для разделения элементов массива или ассоциативного массива (по умолчанию &quot;&quot;,что означает,что элементы разделены пробелами).</target>
        </trans-unit>
        <trans-unit id="555d16dee4415f5ab0acc21725fda20143e994af" translate="yes" xml:space="preserve">
          <source>The strip group of functions allow stripping of either leading, trailing, or both leading and trailing elements.</source>
          <target state="translated">Группа функций полосы позволяет снимать либо ведущие,либо примыкающие,либо как ведущие,так и примыкающие элементы.</target>
        </trans-unit>
        <trans-unit id="58b660c2a16b28679d8eef710bda4717a0e26225" translate="yes" xml:space="preserve">
          <source>The structs &lt;code&gt;Yes&lt;/code&gt; and &lt;code&gt;No&lt;/code&gt; are provided as shorthand for &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; and &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; and are preferred for brevity and readability. These convenience structs mean it is usually unnecessary and counterproductive to create an alias of a &lt;code&gt;Flag&lt;/code&gt; as a way of avoiding typing out the full type while specifying the affirmative or negative options.  Passing categorical data by means of unstructured &lt;code&gt;bool&lt;/code&gt; parameters is classified under &quot;simple-data coupling&quot; by Steve McConnell in the &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;Code Complete&lt;/a&gt; book, along with three other kinds of coupling. The author argues citing several studies that coupling has a negative effect on code quality. &lt;code&gt;Flag&lt;/code&gt; offers a simple structuring method for passing yes/no flags to APIs.</source>
          <target state="translated">Структуры &amp;laquo; &lt;code&gt;Yes&lt;/code&gt; и &amp;laquo; &lt;code&gt;No&lt;/code&gt; предоставляются как сокращение для &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; и &amp;laquo; &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; и предпочтительны для краткости и удобочитаемости. Эти удобные структуры означают, что создание псевдонима &lt;code&gt;Flag&lt;/code&gt; как правило, не нужно и контрпродуктивно, чтобы избежать типизации полного типа при указании положительных или отрицательных параметров. Передача категориальных данных с помощью неструктурированных параметров &lt;code&gt;bool&lt;/code&gt; классифицируется как &amp;laquo;простое связывание данных&amp;raquo; Стивом Макконнеллом в книге &amp;laquo; &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;Полный код&amp;raquo;&lt;/a&gt; вместе с тремя другими видами связывания. Ссылаясь на несколько исследований, автор утверждает, что связывание отрицательно влияет на качество кода. &lt;code&gt;Flag&lt;/code&gt; предлагает простой метод структурирования для передачи флагов да / нет API.</target>
        </trans-unit>
        <trans-unit id="076392e866b208f90ee610d973e43efceb10e97e" translate="yes" xml:space="preserve">
          <source>The subclass of EncodingScheme to register.</source>
          <target state="translated">Подкласс EncodingScheme для регистрации.</target>
        </trans-unit>
        <trans-unit id="c1ed1f004de54db1586dcfe56503caa35fb79f44" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;sizes&lt;/code&gt; must be equal 21.</source>
          <target state="translated">Сумма &lt;code&gt;sizes&lt;/code&gt; должна быть равна 21.</target>
        </trans-unit>
        <trans-unit id="789facc231279c33347577b57e2a474fbfbd6abb" translate="yes" xml:space="preserve">
          <source>The sum of all bit lengths in one bitfield instantiation must be exactly 8, 16, 32, or 64. If padding is needed, just allocate one bitfield with an empty name.</source>
          <target state="translated">Сумма всех длин битов в одном битовом поле должна быть ровно 8,16,32 или 64.Если требуется колодка,просто выделите одно битовое поле с пустым именем.</target>
        </trans-unit>
        <trans-unit id="2cfe229a83e79df357cdfd328b79e038bc593b6f" translate="yes" xml:space="preserve">
          <source>The sum of all the elements in the range r.</source>
          <target state="translated">Сумма всех элементов в диапазоне r.</target>
        </trans-unit>
        <trans-unit id="9be88f8537261298343db1ff319dde4340861d75" translate="yes" xml:space="preserve">
          <source>The supplied code as a delegate.</source>
          <target state="translated">Поставленный код в качестве делегата.</target>
        </trans-unit>
        <trans-unit id="63d3a3cda8996c92ecd751aecdc230c95f7170d2" translate="yes" xml:space="preserve">
          <source>The swapping strategy parameter is not implemented yet; currently it is ignored.</source>
          <target state="translated">Параметр стратегии подкачки пока не реализован,на данный момент он игнорируется.</target>
        </trans-unit>
        <trans-unit id="80b980e073fe362e9683180ed237939256d93352" translate="yes" xml:space="preserve">
          <source>The swapping strategy to employ.</source>
          <target state="translated">Стратегия обмена.</target>
        </trans-unit>
        <trans-unit id="170969e1d0fabb640f8089b36d7401a205bca51c" translate="yes" xml:space="preserve">
          <source>The swapping strategy to use.</source>
          <target state="translated">Стратегия обмена.</target>
        </trans-unit>
        <trans-unit id="98e99ba24a8243b8fd6b17bc749b4554c5b7f75e" translate="yes" xml:space="preserve">
          <source>The swapping strategy.</source>
          <target state="translated">Стратегия обмена.</target>
        </trans-unit>
        <trans-unit id="48042820d83937bec0797943750b58634bf67f60" translate="yes" xml:space="preserve">
          <source>The symbol containing the &lt;code&gt;static foreach&lt;/code&gt; variables.</source>
          <target state="translated">Символ, содержащий &lt;code&gt;static foreach&lt;/code&gt; переменные foreach .</target>
        </trans-unit>
        <trans-unit id="56e1148f66671625bb0c6990da38dc2d64edea1a" translate="yes" xml:space="preserve">
          <source>The symbol this &lt;code&gt;alias this&lt;/code&gt; resolves to</source>
          <target state="translated">Символ этот &lt;code&gt;alias this&lt;/code&gt; разрешает</target>
        </trans-unit>
        <trans-unit id="dac6f5e28e8cd7e2f90032028de6bb0f0117f4f9" translate="yes" xml:space="preserve">
          <source>The symlink to create. A relative path is relative to the current working directory.</source>
          <target state="translated">Сим-ссылка для создания.Относительный путь-относительно текущей рабочей директории.</target>
        </trans-unit>
        <trans-unit id="83a33998cfc84a9e39e9f0423cfd7357619092df" translate="yes" xml:space="preserve">
          <source>The synchronization gets released even if</source>
          <target state="translated">Синхронизация освобождается,даже если</target>
        </trans-unit>
        <trans-unit id="f52720ebc8b4fb3263a1e381206af9d0efeeb0c2" translate="yes" xml:space="preserve">
          <source>The synchronized statement wraps a statement with a mutex to synchronize access among multiple threads.</source>
          <target state="translated">Синхронизированный оператор обёртывает оператор мьютексом для синхронизации доступа между несколькими потоками.</target>
        </trans-unit>
        <trans-unit id="54b1dbc833575883512c8f1664c887a121ae9fd3" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;b&gt;/c/string/&lt;/b&gt;, where &lt;b&gt;c&lt;/b&gt; is either a single character, or multiple characters separated by whitespace or commas, and &lt;b&gt;string&lt;/b&gt; is the replacement text.</source>
          <target state="translated">Синтаксис &lt;b&gt;/ c / string /&lt;/b&gt; , где &lt;b&gt;c&lt;/b&gt; - либо один символ, либо несколько символов, разделенных пробелами или запятыми, а &lt;b&gt;строка&lt;/b&gt; - это текст замены.</target>
        </trans-unit>
        <trans-unit id="d9da9fc28de038f5884f945667be4b8054f95702" translate="yes" xml:space="preserve">
          <source>The syntax trees are traversed to declare variables, load symbol tables, assign types, and in general determine the meaning of the program.</source>
          <target state="translated">Обход деревьев синтаксиса позволяет объявлять переменные,загружать таблицы символов,присваивать типы и,в общем случае,определять смысл программы.</target>
        </trans-unit>
        <trans-unit id="fa94a6e6326b720f3ede8ff8d6c4dce16a4fa303" translate="yes" xml:space="preserve">
          <source>The system clock ticks are the ticks of the system clock at the highest precision that the system provides.</source>
          <target state="translated">Клещи системных часов являются клещами системных часов с высочайшей точностью,что система обеспечивает.</target>
        </trans-unit>
        <trans-unit id="5387aa28c9051257b0dae7b093c61c8a7eb3427d" translate="yes" xml:space="preserve">
          <source>The system-provided garbage-collector allocator. This should be the default fallback allocator tapping into system memory. It offers manual &lt;code&gt;free&lt;/code&gt; and dutifully collects litter.</source>
          <target state="translated">Системный распределитель мусора. Это должен быть резервный распределитель по умолчанию, подключающийся к системной памяти. Предлагает ручную &lt;code&gt;free&lt;/code&gt; и покорно собирает мусор.</target>
        </trans-unit>
        <trans-unit id="ec81049f6e21b9ea49ff325809160b315623cf2d" translate="yes" xml:space="preserve">
          <source>The table below gives a synopsis of predefined allocator building blocks, with their respective modules. Either &lt;code&gt;import&lt;/code&gt; the needed modules individually, or &lt;code&gt;import&lt;/code&gt;&lt;code&gt;std.experimental.building_blocks&lt;/code&gt;, which imports them all &lt;code&gt;public&lt;/code&gt;ly. The building blocks can be assembled in unbounded ways and also combined with your own. For a collection of typical and useful preassembled allocators and for inspiration in defining more such assemblies, refer to &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt;&lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В таблице ниже приведен краткий обзор предварительно определенных строительных блоков распределителя с соответствующими модулями. Либо &lt;code&gt;import&lt;/code&gt; необходимые модули по отдельности, либо &lt;code&gt;import&lt;/code&gt; &lt;code&gt;std.experimental.building_blocks&lt;/code&gt; , который импортирует их все &lt;code&gt;public&lt;/code&gt; . Строительные блоки можно собирать неограниченным образом, а также комбинировать с вашими собственными. Для набора типичных и полезных предварительно собранных распределителей и для вдохновения в определении большего количества таких сборок, обратитесь к &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt; &lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d173662a2aa058963145fe71e5e20907062a55be" translate="yes" xml:space="preserve">
          <source>The target hardware does not have a floating point unit</source>
          <target state="translated">Объектное оборудование не имеет устройства с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="c5cdb1793dc5882606089de2cbe88b09e1226416" translate="yes" xml:space="preserve">
          <source>The target hardware has a floating point unit</source>
          <target state="translated">Аппаратное обеспечение цели имеет плавающую запятую</target>
        </trans-unit>
        <trans-unit id="b0979a69d6f3a7dae7324755cd1aa56f216e319b" translate="yes" xml:space="preserve">
          <source>The target object</source>
          <target state="translated">Объект,на который нацелена цель.</target>
        </trans-unit>
        <trans-unit id="0b824dcd9bca9b5db9480c831c6a63d26770ea48" translate="yes" xml:space="preserve">
          <source>The target of the search. Must be an input range. If any of &lt;code&gt;needles&lt;/code&gt; is a range with elements comparable to elements in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; such that the search can backtrack.</source>
          <target state="translated">Цель поиска. Должен быть диапазон ввода. Если какая-либо из &lt;code&gt;needles&lt;/code&gt; представляет собой диапазон с элементами, сопоставимыми с элементами в &lt;code&gt;haystack&lt;/code&gt; , то &lt;code&gt;haystack&lt;/code&gt; должен быть &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;передовым диапазоном&lt;/a&gt; , чтобы при поиске можно было вернуться назад.</target>
        </trans-unit>
        <trans-unit id="1bfc030365108c10d6974605e9bd398b8361c092" translate="yes" xml:space="preserve">
          <source>The target range to copy common elements to.</source>
          <target state="translated">Целевой диапазон для копирования общих элементов в.</target>
        </trans-unit>
        <trans-unit id="829e896e39b70090cbc3b2de79f25fe9335f1b77" translate="yes" xml:space="preserve">
          <source>The target range.</source>
          <target state="translated">Диапазон поражения.</target>
        </trans-unit>
        <trans-unit id="23350db16fa1f3e6288ccb87e5a181ba79379e10" translate="yes" xml:space="preserve">
          <source>The target supports interfacing with Objective-C</source>
          <target state="translated">Цель поддерживает взаимодействие с Цели-С.</target>
        </trans-unit>
        <trans-unit id="eac1bff04784409ef03a30482f19ef41091d6414" translate="yes" xml:space="preserve">
          <source>The target type in the conversion or comparison</source>
          <target state="translated">Целевой тип при преобразовании или сравнении</target>
        </trans-unit>
        <trans-unit id="390654f1dbf50ff204a2f1fd9ed2609258c428a9" translate="yes" xml:space="preserve">
          <source>The target type of the cast</source>
          <target state="translated">Целевой тип литья</target>
        </trans-unit>
        <trans-unit id="5431c3bccb7e8fdc6dc54d831207394bad385ccd" translate="yes" xml:space="preserve">
          <source>The target variable.</source>
          <target state="translated">Целевая переменная.</target>
        </trans-unit>
        <trans-unit id="b71a4a76d74bf9f8e3d2c97011ae3038c9fc6fff" translate="yes" xml:space="preserve">
          <source>The technical term 'Special Functions' includes several families of transcendental functions, which have important applications in particular branches of mathematics and physics.</source>
          <target state="translated">Технический термин &quot;специальные функции&quot; включает в себя несколько семейств трансцендентальных функций,которые имеют важные приложения в конкретных отраслях математики и физики.</target>
        </trans-unit>
        <trans-unit id="2b45d76d889fde617363950e6293b054095035b5" translate="yes" xml:space="preserve">
          <source>The template API is slightly more efficient. It does not have to allocate memory dynamically, all memory is allocated on the stack. The OOP API has to allocate in the finish method if no buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate, but the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; classes still have to be created using &lt;code&gt;new&lt;/code&gt; which allocates them using the GC.  The OOP API is useful to change the digest function and/or digest backend at 'runtime'. The benefit here is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.  If just one specific digest type and backend is needed, the template API is usually a good fit. In this simplest case, the template API can even be used without templates: Just use the &quot;&lt;b&gt;x&lt;/b&gt;&quot; structs directly.</source>
          <target state="translated">Шаблон API немного более эффективен. Он не должен выделять память динамически, вся память выделяется в стеке. API ООП должен выделяться в методе finish, если буфер не был предоставлен. Если вы предоставляете буфер для функции завершения API-интерфейса ООП, он не выделяется, но классы &lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt; все еще должны быть созданы с использованием &lt;code&gt;new&lt;/code&gt; , который выделяет их с помощью GC. OOP API полезен для изменения функции дайджеста и / или дайджеста-бэкенда во время выполнения. Преимущество заключается в том, что переключение, например, Phobos MD5Digest и реализация OpenSSLMD5Digest, совместимо с ABI. Если нужен только один конкретный тип дайджеста и серверная часть, шаблон API обычно подходит. В этом простейшем случае API шаблонов можно использовать даже без шаблонов: просто используйте &quot; &lt;b&gt;x&lt;/b&gt;&quot;Строит прямо.</target>
        </trans-unit>
        <trans-unit id="408001ca506523fa6af663497d5def923a607239" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;. If asking for &lt;code&gt;char&lt;/code&gt;, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</source>
          <target state="translated">Параметр шаблона &lt;code&gt;T&lt;/code&gt; указывает тип для возврата. Возможные значения: &lt;code&gt;char&lt;/code&gt; и &lt;code&gt;ubyte&lt;/code&gt; для возврата &lt;code&gt;char[]&lt;/code&gt; или &lt;code&gt;ubyte[]&lt;/code&gt; . Если запрашивать &lt;code&gt;char&lt;/code&gt; , содержимое будет преобразовано из набора символов соединения (указанного в заголовках ответа HTTP или в свойствах соединения FTP, по умолчанию оба ISO-8859-1) в UTF-8.</target>
        </trans-unit>
        <trans-unit id="3d301625295a49a8e01e8072c1823836d6260302" translate="yes" xml:space="preserve">
          <source>The template picked to instantiate is the one that is most specialized that fits the types of the</source>
          <target state="translated">Шаблон,выбранный для инстанцирования,является наиболее специализированным,который подходит для типа</target>
        </trans-unit>
        <trans-unit id="02b51510e4339a80ea7cc2a65d41d079d75e78b8" translate="yes" xml:space="preserve">
          <source>The template to instantiate.</source>
          <target state="translated">Шаблон для инстанцирования.</target>
        </trans-unit>
        <trans-unit id="e41f924354ea35f5712eb828813900cd1d5f4161" translate="yes" xml:space="preserve">
          <source>The term and concept of a 'critical region' comes from &lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono's SGen garbage collector&lt;/a&gt;.</source>
          <target state="translated">Термин и понятие &amp;laquo;критический регион&amp;raquo; происходит от &lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;сборщика мусора SGen компании Mono&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efe68f5f28809042f03e04ab3e7e40904902798b" translate="yes" xml:space="preserve">
          <source>The tested value</source>
          <target state="translated">Испытательное значение</target>
        </trans-unit>
        <trans-unit id="836717195b2e4f6e650af52f82b03152a0dc0a7a" translate="yes" xml:space="preserve">
          <source>The text from &lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;</source>
          <target state="translated">Текст из &lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="459f3d558c2480422a70a7a05484244d80510d43" translate="yes" xml:space="preserve">
          <source>The text to print at the beginning of the help output.</source>
          <target state="translated">Текст для печати в начале вывода справки.</target>
        </trans-unit>
        <trans-unit id="b43a60a00dd34982ab5b9431db8979ee331c8fcd" translate="yes" xml:space="preserve">
          <source>The text to printed at the beginning of the help output.</source>
          <target state="translated">Текст для печати в начале вывода справки.</target>
        </trans-unit>
        <trans-unit id="f99eb9686d85d18418cbec2f3108af60157b8372" translate="yes" xml:space="preserve">
          <source>The third form, &lt;code&gt;goto case;&lt;/code&gt;, transfers to the next &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Третья форма, &lt;code&gt;goto case;&lt;/code&gt; , переходит к следующему &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; самого внутреннего включающего &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d93a13c865f0a3f12bf9f0bb2248b62195335a7" translate="yes" xml:space="preserve">
          <source>The third version counts the elements for which &lt;code&gt;pred(x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Третья версия подсчитывает элементы, для которых &lt;code&gt;pred(x)&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; . Выполняет &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; ) оценки &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7f1a71c5e73a907487dd15adada9e34f7e659b3" translate="yes" xml:space="preserve">
          <source>The thread function.</source>
          <target state="translated">Функция резьбы.</target>
        </trans-unit>
        <trans-unit id="3959bc13b481b7efab32161f7b4d802658e73e9a" translate="yes" xml:space="preserve">
          <source>The thread identifier to search for.</source>
          <target state="translated">Идентификатор потока для поиска.</target>
        </trans-unit>
        <trans-unit id="5a0f4bf2e74aee3208cf1615166945a5d795e350" translate="yes" xml:space="preserve">
          <source>The thread module provides support for thread creation and management.</source>
          <target state="translated">Модуль потоков обеспечивает поддержку создания потоков и управления ими.</target>
        </trans-unit>
        <trans-unit id="d7abe70146b93589cb3df68907f1263f3d11f70c" translate="yes" xml:space="preserve">
          <source>The thread object associated with the thread identifier, null if not found.</source>
          <target state="translated">Объект потока,связанный с идентификатором потока,null,если не найден.</target>
        </trans-unit>
        <trans-unit id="ab55fec985d480d7e55fafd41bc48fa26e59c5c7" translate="yes" xml:space="preserve">
          <source>The thread object representing the calling thread. The result of deleting this object is undefined. If the current thread is not attached to the runtime, a null reference is returned.</source>
          <target state="translated">Объект потока,представляющий вызывающий поток.Результат удаления этого объекта неопределен.Если текущий поток не привязан к времени выполнения,возвращается нулевая ссылка.</target>
        </trans-unit>
        <trans-unit id="e5711fdf4eb878a460acdc3e1a74ec3adfd4c562" translate="yes" xml:space="preserve">
          <source>The thread to add.</source>
          <target state="translated">Тема для добавления.</target>
        </trans-unit>
        <trans-unit id="7d29c86c6e1877f0c1dbf42c7ab48cb432ebae10" translate="yes" xml:space="preserve">
          <source>The thread to remove.</source>
          <target state="translated">Резьба для удаления.</target>
        </trans-unit>
        <trans-unit id="d0b4719e19dcec3e27e7ac05162455919bfcbe02" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;. The semantics of the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; are identical to the regular &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Потоковая версия &lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt; . Семантика &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; идентична обычному &lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59a01b618381df97fff6e53a1c501e32c03fcf01" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;code&gt;Region&lt;/code&gt; allocator. Allocations and deallocations are lock-free based using &lt;a href=&quot;core_atomic#cas&quot;&gt;&lt;code&gt;core.atomic.cas&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поточно версия &lt;code&gt;Region&lt;/code&gt; распределителя. Распределение и освобождение осуществляются без блокировки с помощью &lt;a href=&quot;core_atomic#cas&quot;&gt; &lt;code&gt;core.atomic.cas&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa46d46c716c543c618abaaa5d085bc00056cfe" translate="yes" xml:space="preserve">
          <source>The tick of the system clock (as a &lt;code&gt;TickDuration&lt;/code&gt;) when the application started.</source>
          <target state="translated">Тик системных часов (как &lt;code&gt;TickDuration&lt;/code&gt; ) при запуске приложения.</target>
        </trans-unit>
        <trans-unit id="c9d9d06b3436a3b01b898cdc70083c5a552bbada" translate="yes" xml:space="preserve">
          <source>The tid register by name.</source>
          <target state="translated">Тид регистр по имени.</target>
        </trans-unit>
        <trans-unit id="c95778519910f76a9057566bdc33da531d73931d" translate="yes" xml:space="preserve">
          <source>The time complexity of &lt;code&gt;resolveInternalPointer&lt;/code&gt; is &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;), where &lt;code&gt;k&lt;/code&gt; is the size of the object within which the internal pointer is looked up.</source>
          <target state="translated">&lt;code&gt;resolveInternalPointer&lt;/code&gt; сложность resolInternalPointer равна &amp;Omicron; ( &lt;code&gt;k&lt;/code&gt; ), где &lt;code&gt;k&lt;/code&gt; - размер объекта, внутри которого ищется внутренний указатель.</target>
        </trans-unit>
        <trans-unit id="c6f885eba6e13ebbe7785527359e11e5b18d7b86" translate="yes" xml:space="preserve">
          <source>The time in this time zone that needs to be adjusted to UTC time.</source>
          <target state="translated">Время в этом часовом поясе,которое необходимо отрегулировать в соответствии с UTC временем.</target>
        </trans-unit>
        <trans-unit id="36444ba6ba0b4c42e3d384843ef7cb9d529fafd9" translate="yes" xml:space="preserve">
          <source>The time it takes for a collection to complete is not bounded. While in practice it is very quick, this cannot normally be guaranteed.</source>
          <target state="translated">Время,необходимое для завершения коллекции,не ограничено.На практике это происходит очень быстро,но,как правило,это невозможно гарантировать.</target>
        </trans-unit>
        <trans-unit id="de1882702ad690d9d775a9f36384bf0f0cf2e003" translate="yes" xml:space="preserve">
          <source>The time point to check for inclusion in this interval.</source>
          <target state="translated">Точка времени для проверки включения в этот интервал.</target>
        </trans-unit>
        <trans-unit id="6e148efcac14a5504ed5ebc4915f1425f4ffaad7" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is after it.</source>
          <target state="translated">Точка времени,чтобы проверить,является ли этот интервал после него.</target>
        </trans-unit>
        <trans-unit id="0af6ef24e2680b0852356a3c276c84d96252cda5" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is before it.</source>
          <target state="translated">Точка времени,чтобы проверить,является ли этот интервал перед ним.</target>
        </trans-unit>
        <trans-unit id="8a3820a8c6e406527bb35a80565a009d598d8a36" translate="yes" xml:space="preserve">
          <source>The time point to set &lt;code&gt;begin&lt;/code&gt; to.</source>
          <target state="translated">Время &lt;code&gt;begin&lt;/code&gt; установки .</target>
        </trans-unit>
        <trans-unit id="cbec4c576826e4c65a07a27c4030261f911b3fc7" translate="yes" xml:space="preserve">
          <source>The time point to set end to.</source>
          <target state="translated">Временная точка,на которую нужно установить конец.</target>
        </trans-unit>
        <trans-unit id="4e8c71e16602a3ead734892883c0297513fcb288" translate="yes" xml:space="preserve">
          <source>The time point which begins the interval.</source>
          <target state="translated">Временная точка,с которой начинается интервал.</target>
        </trans-unit>
        <trans-unit id="b2fbbe21f1348e2b8375bc085e626db9a6aa48c4" translate="yes" xml:space="preserve">
          <source>The time point which ends (but is not included in) the interval.</source>
          <target state="translated">Временная точка,которая заканчивается (но не включается)в интервал.</target>
        </trans-unit>
        <trans-unit id="78c4a788ebf74ce66cd510d9291804e7429c59df" translate="yes" xml:space="preserve">
          <source>The time point which ends the interval.</source>
          <target state="translated">Временная точка,которая заканчивает интервал.</target>
        </trans-unit>
        <trans-unit id="a07ced07ea48cf9efd3c59008997a5861e92661c" translate="yes" xml:space="preserve">
          <source>The time portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Часть времени &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eaefa3fbda7de51442bf3c3c08acb463add5f535" translate="yes" xml:space="preserve">
          <source>The time required of the base function</source>
          <target state="translated">Время,необходимое для базовой функции</target>
        </trans-unit>
        <trans-unit id="5dfcadc4d17bd6640e6259395ec434dc6bc95330" translate="yes" xml:space="preserve">
          <source>The time required of the target function</source>
          <target state="translated">Время,необходимое для выполнения целевой функции</target>
        </trans-unit>
        <trans-unit id="48cf786f30ef005c486cb7a01e2f10f8f8403d94" translate="yes" xml:space="preserve">
          <source>The time to return if the given file does not exist.</source>
          <target state="translated">Время возврата,если данный файл не существует.</target>
        </trans-unit>
        <trans-unit id="4267537c103e163837339d1b65e1d8cf5f9910a8" translate="yes" xml:space="preserve">
          <source>The time to wait.</source>
          <target state="translated">Время ждать.</target>
        </trans-unit>
        <trans-unit id="fa99618f433466483613abfd766711a1f7a82462" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;Duration&lt;/code&gt; (e.g. &lt;code&gt;&quot;days&quot;&lt;/code&gt;).</source>
          <target state="translated">Единицы времени &lt;code&gt;Duration&lt;/code&gt; (например, &lt;code&gt;&quot;days&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6cd7e80f003f95225b75b6571da8250b5085bd4" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;TickDuration&lt;/code&gt; (e.g. &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;).</source>
          <target state="translated">Единицы времени &lt;code&gt;TickDuration&lt;/code&gt; (например, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="da60824664e52c129d1706b86eb17c66b6fccefc" translate="yes" xml:space="preserve">
          <source>The time zone for the SysTime that's returned.</source>
          <target state="translated">Часовой пояс для SysTime,который возвращается.</target>
        </trans-unit>
        <trans-unit id="c438d5ef1eeaa45747297e85768ff04bc9674297" translate="yes" xml:space="preserve">
          <source>The time zone that the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; will be in (&lt;code&gt;FILETIME&lt;/code&gt;s are in UTC).</source>
          <target state="translated">Часовой пояс, в &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; будет находиться &lt;code&gt;FILETIME&lt;/code&gt; ( FILETIME в UTC).</target>
        </trans-unit>
        <trans-unit id="8ed6f652fe44fd70fdb71a9b99c39e57d001f270" translate="yes" xml:space="preserve">
          <source>The time zone that the time in the &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct is assumed to be (if the &lt;code&gt;SYSTEMTIME&lt;/code&gt; was supplied by a Windows system call, the &lt;code&gt;SYSTEMTIME&lt;/code&gt; will either be in local time or UTC, depending on the call).</source>
          <target state="translated">Часовой пояс, в &lt;code&gt;SYSTEMTIME&lt;/code&gt; предполагается время в структуре SYSTEMTIME (если &lt;code&gt;SYSTEMTIME&lt;/code&gt; был предоставлен системным вызовом Windows, &lt;code&gt;SYSTEMTIME&lt;/code&gt; будет либо по местному времени, либо по UTC, в зависимости от вызова).</target>
        </trans-unit>
        <trans-unit id="e2b1325df63f2bced3800f46b247c623c3e4272e" translate="yes" xml:space="preserve">
          <source>The time zone to convert the given time to (no conversion occurs if null).</source>
          <target state="translated">Часовой пояс для конвертации заданного времени в (если ноль,конверсия не происходит).</target>
        </trans-unit>
        <trans-unit id="07061a5295594952467858d09a80f0ac4c6b93c5" translate="yes" xml:space="preserve">
          <source>The time zone which the DOS file time is assumed to be in.</source>
          <target state="translated">Часовой пояс,в котором предполагается время в файле DOS.</target>
        </trans-unit>
        <trans-unit id="ea5d10f63e5499e351af6e045b5284865995d1c6" translate="yes" xml:space="preserve">
          <source>The time-domain signal.</source>
          <target state="translated">Сигнал временной области.</target>
        </trans-unit>
        <trans-unit id="77a3aa828967d445cff64c8dd096774ce4063dcd" translate="yes" xml:space="preserve">
          <source>The timeout duration to set. Must not be negative.</source>
          <target state="translated">Продолжительность таймаута,который нужно установить.Не должно быть отрицательной.</target>
        </trans-unit>
        <trans-unit id="d16c09d69ed3827cc0d9a393d7d97a0e7218d947" translate="yes" xml:space="preserve">
          <source>The times when endianness matters are:</source>
          <target state="translated">Время,когда эндианство имеет значение:</target>
        </trans-unit>
        <trans-unit id="e3fa37b42db66accd6b9bcd0e0be5ca501e23ea7" translate="yes" xml:space="preserve">
          <source>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the internal representation of &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Всего hnsecs с полуночи, 1 января, 1 г. н.э. Это внутреннее представление &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5851853cba4938d9ece2d746e33f63f5ccc8b6" translate="yes" xml:space="preserve">
          <source>The total number of CPU cores available on the current machine, as reported by the operating system.</source>
          <target state="translated">Общее количество процессорных ядер,доступных на текущей машине,по данным операционной системы.</target>
        </trans-unit>
        <trans-unit id="79b5fcc0a58019c01762b4288a59bbc0fed9cdab" translate="yes" xml:space="preserve">
          <source>The total number of fields minus the number of hidden fields.</source>
          <target state="translated">Общее количество полей минус количество скрытых полей.</target>
        </trans-unit>
        <trans-unit id="dc0f294e7939a4a8cc8e219285559a0f838c9d26" translate="yes" xml:space="preserve">
          <source>The total number of valid bits in the given bit array</source>
          <target state="translated">Общее количество допустимых битов в заданном битовом массиве</target>
        </trans-unit>
        <trans-unit id="df0ace455640aad44a2f2df358df6cfc839cb3dc" translate="yes" xml:space="preserve">
          <source>The total size of a static array cannot exceed 16Mb.</source>
          <target state="translated">Общий размер статического массива не может превышать 16 Мб.</target>
        </trans-unit>
        <trans-unit id="976a549fe53e07ee95927e3a3f5dc68542025ca7" translate="yes" xml:space="preserve">
          <source>The traditional C way of detecting and reporting errors is not traditional, it is ad-hoc and varies from function to function, including:</source>
          <target state="translated">Традиционный способ обнаружения и сообщения об ошибках на языке C не является традиционным,он является специальным и варьируется от функции к функции,в том числе:</target>
        </trans-unit>
        <trans-unit id="67c33a524b8d09894199c567d354a8e0cb98ab34" translate="yes" xml:space="preserve">
          <source>The trailing end of the sub-format string following the specifier for each item is interpreted as the array delimiter, and is therefore omitted following the last array item. The &lt;b&gt;%|&lt;/b&gt; delimiter specifier may be used to indicate where the delimiter begins, so that the portion of the format string prior to it will be retained in the last array element:</source>
          <target state="translated">Конечный конец строки подформата, следующий за спецификатором для каждого элемента, интерпретируется как разделитель массива и поэтому опускается после последнего элемента массива. &lt;b&gt;% | &lt;/b&gt;Спецификатор разделителя может использоваться, чтобы указать, где начинается разделитель, так что часть строки формата до него будет сохранена в последнем элементе массива:</target>
        </trans-unit>
        <trans-unit id="ba1799b6274ed3732b914694e0713f19f1425685" translate="yes" xml:space="preserve">
          <source>The transformation target</source>
          <target state="translated">Цель преобразования</target>
        </trans-unit>
        <trans-unit id="dc8b213c861da206308d6e24e6eb30fbdfae1604" translate="yes" xml:space="preserve">
          <source>The transformation to apply.</source>
          <target state="translated">Трансформация для применения.</target>
        </trans-unit>
        <trans-unit id="b1e46c489c0f174beeea6508fe063266ccec2c4d" translate="yes" xml:space="preserve">
          <source>The transversal assumes, without verifying, that the elements of a range of ranges have all the same length. This option is useful if checking was already done from the outside of the range.</source>
          <target state="translated">Трансверсальное предполагает,без проверки,что элементы диапазона имеют одинаковую длину.Эта опция полезна,если проверка уже была выполнена снаружи диапазона.</target>
        </trans-unit>
        <trans-unit id="c892e981eb5136632b424a66b388d449fc7ea3de" translate="yes" xml:space="preserve">
          <source>The transversal enforces that the elements of a range of ranges have all the same length (e.g. an array of arrays, all having the same length). Checking is done once upon construction of the transversal range.</source>
          <target state="translated">Трансверсальное усиливает то,что элементы диапазона имеют одинаковую длину (например,массив массивов,все имеют одинаковую длину).Проверка выполняется один раз при построении поперечного диапазона.</target>
        </trans-unit>
        <trans-unit id="39be873b141578a1b5b94098b6cdd594b486bf6c" translate="yes" xml:space="preserve">
          <source>The try/catch/finally statements look a lot nicer than endless if (error) goto errorhandler; statements.</source>
          <target state="translated">Операторы try/catch/finally выглядят намного приятнее,чем бесконечные операторы if (error)goto errorhandler;операторы.</target>
        </trans-unit>
        <trans-unit id="2180bb589eb009453566d9091bc41a602b56f38e" translate="yes" xml:space="preserve">
          <source>The tuple passes in a range closed to the left and open to the right (consistent with built-in slices), e.g. &lt;code&gt;tuple(1, 3)&lt;/code&gt; means indices &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; but not &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Кортеж проходит в диапазоне, закрытом слева и открытом справа (в соответствии со встроенными слайсами), например, &lt;code&gt;tuple(1, 3)&lt;/code&gt; означает индексы &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;2&lt;/code&gt; , но не &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a7ad5d5f1c875f8f019e5586ed049f63bb8fa1" translate="yes" xml:space="preserve">
          <source>The two functions are almost identical semantically. The expressions in the first are lowered to contract blocks that look almost exactly like the second, except that a separate block is created for each expression in the first, thus avoiding shadowing variable names.</source>
          <target state="translated">Эти две функции почти идентичны по семантике.Выражения в первой опускаются до блоков контрактов,которые выглядят почти точно так же,как и во второй,за исключением того,что для каждого выражения в первой создается отдельный блок,что позволяет избежать затенения имён переменных.</target>
        </trans-unit>
        <trans-unit id="28b3f8f71ef0f4ce43325479aa6cdea23771283e" translate="yes" xml:space="preserve">
          <source>The two sockets are indistinguishable.</source>
          <target state="translated">Две розетки неразличимы.</target>
        </trans-unit>
        <trans-unit id="61509f7d94291812c28aff0f194b21e094315464" translate="yes" xml:space="preserve">
          <source>The type being allocated embeds no pointers. Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt; Tuple!(int, float)&lt;/code&gt;. The implicit conservative assumption is that the type has members with indirections so it needs to be scanned if garbage collected. Example of types with pointers: &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)&lt;/code&gt;.</source>
          <target state="translated">Распределяемый тип не содержит указателей. Примеры: &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;int[]&lt;/code&gt; , &lt;code&gt; Tuple!(int, float)&lt;/code&gt; . Неявное консервативное допущение состоит в том, что тип имеет члены с косвенными ссылками, поэтому его необходимо сканировать, если выполняется сбор мусора. Пример типов с указателями: &lt;code&gt;int*[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, string)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c92e87e9681d72db37be621f13a19e6f9ccab9d8" translate="yes" xml:space="preserve">
          <source>The type being allocated is &lt;code&gt;immutable&lt;/code&gt; and has no pointers. The thread that allocated it must also deallocate it. Example: &lt;code&gt;immutable(int)&lt;/code&gt;.</source>
          <target state="translated">Распределяемый тип является &lt;code&gt;immutable&lt;/code&gt; и не имеет указателей. Поток, который выделил его, должен также освободить его. Пример: &lt;code&gt;immutable(int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e05464f951110a64f08a5f46efef5075a235c4f" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, embeds no indirections, and has fixed size.</source>
          <target state="translated">Выделяемый тип может быть разделен между потоками,не встраивает никаких ссылок и имеет фиксированный размер.</target>
        </trans-unit>
        <trans-unit id="31e0418a4ffc820d767ece7d24f4809101c1c145" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has fixed size.</source>
          <target state="translated">Выделяемый тип может быть общим для всех потоков,может встраиваться в инициалы и имеет фиксированный размер.</target>
        </trans-unit>
        <trans-unit id="6fe4cebdd8e8add445c91158cc91cb4158edec6a" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has variable size.</source>
          <target state="translated">Выделяемый тип может быть общим для всех потоков,может встраивать индендикции и иметь переменный размер.</target>
        </trans-unit>
        <trans-unit id="ddfa6b8808ffdca7214f401f8531dd3f2c5d3a94" translate="yes" xml:space="preserve">
          <source>The type can be inferred from the initializer:</source>
          <target state="translated">Тип может быть выведен из инициализатора:</target>
        </trans-unit>
        <trans-unit id="a2bca00fd97360bf19d51b245e76c8ddf38d445e" translate="yes" xml:space="preserve">
          <source>The type for a callback function. This is legacy and deprecated. It is included for historical compatibility and is not documented.</source>
          <target state="translated">Тип функции обратного вызова.Это наследие и устарело.Он включен для исторической совместимости и не документирован.</target>
        </trans-unit>
        <trans-unit id="121e0a2d6317bfb42929d38aae907c92fbe1c037" translate="yes" xml:space="preserve">
          <source>The type for a unary expression is incompatible. Print error message.</source>
          <target state="translated">Тип для унарного выражения несовместим.Сообщение об ошибке печати.</target>
        </trans-unit>
        <trans-unit id="6c3d19b0730f008ab63e19c7a8d36ffbf8fb1da1" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt; to handle.</source>
          <target state="translated">Тип &lt;code&gt;Throwable&lt;/code&gt; для обработки.</target>
        </trans-unit>
        <trans-unit id="3c9c6ef66ad21283731c4e03058407f8e8389f4f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt;s to catch. Defaults to &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;Throwable&lt;/code&gt; s, чтобы поймать. По умолчанию &lt;code&gt;Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="334019df59cb8690811d0f69b9dd1719fafb9c56" translate="yes" xml:space="preserve">
          <source>The type of a bit field can be any integral type or enumerated type. The most efficient type to store in bitfields is bool, followed by unsigned types, followed by signed types.</source>
          <target state="translated">Тип битового поля может быть любым интегральным типом или перечисляемым типом.Наиболее эффективным типом для хранения в битовых полях является bool,за которым следуют беззнаковые типы,за которыми следуют знаковые типы.</target>
        </trans-unit>
        <trans-unit id="94b6a8f2e23e23e45fa071980296e38bdaa78842" translate="yes" xml:space="preserve">
          <source>The type of a const declaration is itself const.</source>
          <target state="translated">Тип объявления const сам по себе является const.</target>
        </trans-unit>
        <trans-unit id="f092f06205403400bf68aeecbf79e12113097113" translate="yes" xml:space="preserve">
          <source>The type of a string is determined by the semantic phase of compilation. The type is one of: char[], wchar[], dchar[], and is determined by implicit conversion rules. If there are two equally applicable implicit conversions, the result is an error. To disambiguate these cases, a cast or a postfix of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; can be used:</source>
          <target state="translated">Тип строки определяется семантической фазой компиляции. Тип является одним из: char [], wchar [], dchar [] и определяется правилами неявного преобразования. Если есть два одинаково применимых неявных преобразования, результатом является ошибка. Для устранения неоднозначности этих случаев можно использовать приведение или постфикс &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; или &lt;code&gt;d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ca53c8f136489f724620c0090bfc2e63be277e6a" translate="yes" xml:space="preserve">
          <source>The type of an</source>
          <target state="translated">Тип</target>
        </trans-unit>
        <trans-unit id="31de113d851dba3763860dc7a09ef0a95ac4302d" translate="yes" xml:space="preserve">
          <source>The type of concurrency used when logical threads are created is determined by the Scheduler selected at initialization time. The default behavior is currently to create a new kernel thread per call to spawn, but other schedulers are available that multiplex fibers across the main thread or use some combination of the two approaches.</source>
          <target state="translated">Тип параллелизма,используемого при создании логических потоков,определяется Планировщиком,выбранным во время инициализации.Поведение по умолчанию в настоящее время заключается в создании нового потока ядра на вызов порождения,но доступны и другие планировщики,которые мультиплексируют волокна в главном потоке или используют некоторую комбинацию этих двух подходов.</target>
        </trans-unit>
        <trans-unit id="98b545b7a4a8236494e660dadf828715e09984c5" translate="yes" xml:space="preserve">
          <source>The type of encoding cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type.</source>
          <target state="translated">Тип кодировки не может быть выведен.Поэтому необходимо явно указать тип кодировки.</target>
        </trans-unit>
        <trans-unit id="28559fdc7fafacf56a4b4aa4caf411513cf1a53a" translate="yes" xml:space="preserve">
          <source>The type of exception to catch.</source>
          <target state="translated">Тип исключения для поимки.</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">Тип</target>
        </trans-unit>
        <trans-unit id="e2db65940bfb878a54cfaaae819d3064fa148502" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">Тип объекта &lt;code&gt;TypeInfo&lt;/code&gt; , связанный с &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fe50288d353a1cb4576b8e3e05c3c630fa3b33c" translate="yes" xml:space="preserve">
          <source>The type of the array elements</source>
          <target state="translated">Тип элементов массива</target>
        </trans-unit>
        <trans-unit id="d37e2aaad386c1ac5e9f0016c42e7b609226d289" translate="yes" xml:space="preserve">
          <source>The type of the expression.</source>
          <target state="translated">Тип выражения.</target>
        </trans-unit>
        <trans-unit id="028c1d38d3da5ded0145ae38e0f7c2dbd53920e7" translate="yes" xml:space="preserve">
          <source>The type of the integer is resolved as follows:</source>
          <target state="translated">Тип целого числа разрешается следующим образом:</target>
        </trans-unit>
        <trans-unit id="212a76fc03c17bbe0ddb79883b2541fa9887cff9" translate="yes" xml:space="preserve">
          <source>The type of the integral subject to checking.</source>
          <target state="translated">Тип интеграла,подлежащего проверке.</target>
        </trans-unit>
        <trans-unit id="c013517e503aa577ef8db2efdfe587a3e89caa97" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter.</source>
          <target state="translated">Тип выхода не может быть выведен.Поэтому необходимо явно указать кодировку в качестве параметра шаблона.</target>
        </trans-unit>
        <trans-unit id="03cbac5dfebfa2a554890fbfd9c43c204a18bfcf" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type in the template parameter.</source>
          <target state="translated">Тип выхода не может быть выведен.Поэтому в параметре шаблона необходимо явно указать тип кодировки.</target>
        </trans-unit>
        <trans-unit id="d39ec39bd451294d5515fb3a127cb955f855d7d6" translate="yes" xml:space="preserve">
          <source>The type of the previous</source>
          <target state="translated">Тип предыдущего</target>
        </trans-unit>
        <trans-unit id="033a19799f0fa5ac9cef064ceb5d1268d8f17524" translate="yes" xml:space="preserve">
          <source>The type of the resulting array elements</source>
          <target state="translated">Тип результирующих элементов массива</target>
        </trans-unit>
        <trans-unit id="81040b338b2e6abd79e9a3fdf3377720163baee6" translate="yes" xml:space="preserve">
          <source>The type of the return value.</source>
          <target state="translated">Тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="dd58ac5452c68f3b56c536830be3fca377a108cc" translate="yes" xml:space="preserve">
          <source>The type of the slice is a dynamic array of the element type of the</source>
          <target state="translated">Тип среза-это динамический массив элементов типа</target>
        </trans-unit>
        <trans-unit id="cd785b1199a8635d3d151523c5ad55526bbbd6f9" translate="yes" xml:space="preserve">
          <source>The type of the symbol.</source>
          <target state="translated">Тип символа.</target>
        </trans-unit>
        <trans-unit id="452196a4318917b63a4cfe89691bc99e9fba3c75" translate="yes" xml:space="preserve">
          <source>The type of units to add (&quot;years&quot; or &quot;months&quot;).</source>
          <target state="translated">Тип добавляемых единиц (&quot;годы&quot; или &quot;месяцы&quot;).</target>
        </trans-unit>
        <trans-unit id="f9dccb4c7e9a59ec9ebfcaaaf2ab57b17a652de7" translate="yes" xml:space="preserve">
          <source>The type returned by &lt;code&gt;takeOne&lt;/code&gt; is a random-access range with length regardless of &lt;code&gt;R&lt;/code&gt;'s capabilities, as long as it is a forward range. (another feature that distinguishes &lt;code&gt;takeOne&lt;/code&gt; from &lt;code&gt;take&lt;/code&gt;). If (D R) is an input range but not a forward range, return type is an input range with all random-access capabilities except save.</source>
          <target state="translated">Тип, возвращаемый &lt;code&gt;takeOne&lt;/code&gt; , является диапазоном произвольного доступа с длиной независимо от возможностей &lt;code&gt;R&lt;/code&gt; , если это прямой диапазон. (еще одна особенность, которая отличает &lt;code&gt;takeOne&lt;/code&gt; от &lt;code&gt;take&lt;/code&gt; ). Если (DR) - это диапазон ввода, но не прямой диапазон, тип возврата - это диапазон ввода со всеми возможностями произвольного доступа, кроме сохранения.</target>
        </trans-unit>
        <trans-unit id="df7e4abf69509dd860941f1b197de09e0d181452" translate="yes" xml:space="preserve">
          <source>The type stored inside &lt;code&gt;bomTable&lt;/code&gt;.</source>
          <target state="translated">Тип хранится внутри &lt;code&gt;bomTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6da0e0e3a59ae4f419059fd79e6a5b2efe510dd1" translate="yes" xml:space="preserve">
          <source>The type to cast from. The programmer must ensure it is legal to make this cast.</source>
          <target state="translated">Тип,от которого нужно отбрасывать.Программист должен удостовериться,что это легально.</target>
        </trans-unit>
        <trans-unit id="6fc6b3afd9d09c214bbb47deabcb3d5029a321f8" translate="yes" xml:space="preserve">
          <source>The type to cast to.</source>
          <target state="translated">Тот тип,к которому нужно отдать предпочтение.</target>
        </trans-unit>
        <trans-unit id="7a12dddb89baf93f3c8ff660933719a4552a94a9" translate="yes" xml:space="preserve">
          <source>The type to check</source>
          <target state="translated">Тип для проверки</target>
        </trans-unit>
        <trans-unit id="20caa9de7c60aa932980e2103bddf1b7c37802ff" translate="yes" xml:space="preserve">
          <source>The type to check Returns A &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">Тип для проверки Возвращает A &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="129cd5fe4646df1f906533b11f848d4c99ca621d" translate="yes" xml:space="preserve">
          <source>The type to check.</source>
          <target state="translated">Тип для проверки.</target>
        </trans-unit>
        <trans-unit id="e0884902d15a178811c08946d7f41f322c3b3c6e" translate="yes" xml:space="preserve">
          <source>The type to convert to (either an integral type or a floating point type).</source>
          <target state="translated">Тип для приведения к (либо интегральный тип,либо тип с плавающей точкой).</target>
        </trans-unit>
        <trans-unit id="731464fe86427c8aef65d3aa38988badaf10df11" translate="yes" xml:space="preserve">
          <source>The type to qualify</source>
          <target state="translated">Тип для квалификации</target>
        </trans-unit>
        <trans-unit id="d4255aeb11f7f1166da5fe91079652809cb8c332" translate="yes" xml:space="preserve">
          <source>The type to transform</source>
          <target state="translated">Тип для преобразования</target>
        </trans-unit>
        <trans-unit id="a182178d558aaac6dc8d492d1e7dc9ff9e25bdd0" translate="yes" xml:space="preserve">
          <source>The types bool, byte, ubyte, short, ushort, int, uint, pointer, Object, and interfaces are returned in EAX.</source>
          <target state="translated">В EAX возвращаются типы bool,byte,ubyte,short,ushort,int,uint,указатель,Object и интерфейсы.</target>
        </trans-unit>
        <trans-unit id="0110212887a1a5d92fbf43e56315c07c9570e0ab" translate="yes" xml:space="preserve">
          <source>The types defined will all follow the naming convention:</source>
          <target state="translated">Определенные типы будут соответствовать соглашению об именовании:</target>
        </trans-unit>
        <trans-unit id="04692c0de4f65115c6356357897fe3c8458aeb37" translate="yes" xml:space="preserve">
          <source>The types for a binary expression are incompatible. Print error message.</source>
          <target state="translated">Типы для двоичного выражения несовместимы.Сообщение об ошибке печати.</target>
        </trans-unit>
        <trans-unit id="5522b90b8401affc194c75d94ed28b129ed2edae" translate="yes" xml:space="preserve">
          <source>The types of template parameters are deduced for a particular template instantiation by comparing the template argument with the corresponding template parameter.</source>
          <target state="translated">Типы параметров шаблона вычисляются для конкретизации конкретного шаблона путем сравнения аргумента шаблона с соответствующим параметром шаблона.</target>
        </trans-unit>
        <trans-unit id="066569f5b571624866c51a31fa6ddcb337821083" translate="yes" xml:space="preserve">
          <source>The types of the &lt;code&gt;Tuple&lt;/code&gt;'s components.</source>
          <target state="translated">Типы компонентов &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c8b9bedfec2099e1aa223db3144a32e496f4931" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;FILE*&lt;/code&gt; handle is maintained in a reference-counted manner, such that as soon as the last &lt;code&gt;File&lt;/code&gt; variable bound to a given &lt;code&gt;FILE*&lt;/code&gt; goes out of scope, the underlying &lt;code&gt;FILE*&lt;/code&gt; is automatically closed.</source>
          <target state="translated">, Лежащий в основе &lt;code&gt;FILE*&lt;/code&gt; ручка поддерживаются в опорном-подсчитывал способ, таким образом, что , как только последний &lt;code&gt;File&lt;/code&gt; переменный , связанные с данным &lt;code&gt;FILE*&lt;/code&gt; выходит из области видимости, лежащий в основе &lt;code&gt;FILE*&lt;/code&gt; автоматически закрываются.</target>
        </trans-unit>
        <trans-unit id="afc75b662708321c7f89938e96034aeb600136f1" translate="yes" xml:space="preserve">
          <source>The unfilled part of target</source>
          <target state="translated">Незаполненная часть цели</target>
        </trans-unit>
        <trans-unit id="634a8a351a2208e39d6a5ada2c8d683b264478f7" translate="yes" xml:space="preserve">
          <source>The units of time to convert from.</source>
          <target state="translated">Единицы времени,из которых нужно перевести.</target>
        </trans-unit>
        <trans-unit id="ca496597d1b0052334d45f82b4d1ebb346322b8a" translate="yes" xml:space="preserve">
          <source>The units of time to convert to.</source>
          <target state="translated">Единицы времени,в которые нужно перевести.</target>
        </trans-unit>
        <trans-unit id="0be285da06571b223018436a72e418b7f4b54a74" translate="yes" xml:space="preserve">
          <source>The units of time to validate.</source>
          <target state="translated">Единицы времени для проверки.</target>
        </trans-unit>
        <trans-unit id="421844a18abe81313eecb91da7e35563552d941b" translate="yes" xml:space="preserve">
          <source>The units to add.</source>
          <target state="translated">Единицы для добавления.</target>
        </trans-unit>
        <trans-unit id="b4529f66e815e24cb45e91c0feb5284c7f7ff115" translate="yes" xml:space="preserve">
          <source>The units to add. Must be &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">Единицы, чтобы добавить. Должны быть &lt;code&gt;&quot;days&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a30f00fc7d9dabd0ab88732559ada44060afc844" translate="yes" xml:space="preserve">
          <source>The units to convert to. Accepts &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; and smaller only.</source>
          <target state="translated">Единицы для преобразования. Принимает только &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; и меньше.</target>
        </trans-unit>
        <trans-unit id="77097e55fb24c41c45ac8fd555bdb9f92cb58569" translate="yes" xml:space="preserve">
          <source>The unix time to convert.</source>
          <target state="translated">Время преобразования униксов.</target>
        </trans-unit>
        <trans-unit id="20dd814c3aa8014ba5957f08ad17be1db064e4d2" translate="yes" xml:space="preserve">
          <source>The unsorted, right-hand side of the random access range to be sorted.</source>
          <target state="translated">Несортированная,правая часть диапазона случайного доступа,который должен быть отсортирован.</target>
        </trans-unit>
        <trans-unit id="d1d3c14f93e1c2e8f53e8dab18a0c8184c6c7a98" translate="yes" xml:space="preserve">
          <source>The upper bound of the clamp.</source>
          <target state="translated">Верхняя граница зажима.</target>
        </trans-unit>
        <trans-unit id="0983ef86eb34d76a2780b35b3edfbd68c63c7dea" translate="yes" xml:space="preserve">
          <source>The url to receive content from</source>
          <target state="translated">Урлык для получения контента от</target>
        </trans-unit>
        <trans-unit id="446e2b0a1f994283348417fe7415a244c477d8c8" translate="yes" xml:space="preserve">
          <source>The use in the example above is correct because &lt;code&gt;result&lt;/code&gt; was private to &lt;code&gt;letters&lt;/code&gt; and is inaccessible in writing after the function returns. The following example shows an incorrect use of &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">Использование в приведенном выше примере является правильным, поскольку &lt;code&gt;result&lt;/code&gt; был закрыт для &lt;code&gt;letters&lt;/code&gt; и недоступен при записи после возврата из функции. В следующем примере показано неправильное использование &lt;code&gt;assumeUnique&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f765f067fdbcdb23f122179aadad4e3aab7633fe" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged - use either of &lt;a href=&quot;#matchAll&quot;&gt;&lt;code&gt;matchAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#matchFirst&quot;&gt;&lt;code&gt;matchFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Использование этой функции не рекомендуется - используйте &lt;a href=&quot;#matchAll&quot;&gt; &lt;code&gt;matchAll&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#matchFirst&quot;&gt; &lt;code&gt;matchFirst&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12cefe2def110643149592a34e2703038ffe95e9" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged, please use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">Использование этой функции не рекомендуется, пожалуйста, используйте &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; явно.</target>
        </trans-unit>
        <trans-unit id="258077ec71c841ca26961567df7573b36d2e9600" translate="yes" xml:space="preserve">
          <source>The user-defined attribute to search for</source>
          <target state="translated">Определяемый пользователем атрибут для поиска</target>
        </trans-unit>
        <trans-unit id="aef8bf31a8de472e5ee4f185e2b79cc50024f24a" translate="yes" xml:space="preserve">
          <source>The usual arithmetic conversions convert operands of binary operators to a common type. The operands must already be of arithmetic types. The following rules are applied in order, looking at the base type:</source>
          <target state="translated">Обычные арифметические приведения приводят операнды двоичных операторов к общему типу.Операнд должен быть уже арифметического типа.Следующие правила применяются по порядку,глядя на базовый тип:</target>
        </trans-unit>
        <trans-unit id="ed8ed81507c265fdc6ddf599aacfb34e442e2017" translate="yes" xml:space="preserve">
          <source>The value held internally by this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="translated">Значение, удерживаемое внутри этого &lt;code&gt;Nullable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c2cd4ec56e16370bc6d10103dd74ac049c5530" translate="yes" xml:space="preserve">
          <source>The value held previously by &lt;code&gt;here&lt;/code&gt;.</source>
          <target state="translated">Значение, проведенное ранее &lt;code&gt;here&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="758230c61eadaee99aa3c3ef284aa623718c1933" translate="yes" xml:space="preserve">
          <source>The value of 'val'.</source>
          <target state="translated">Значение &quot;Вэл&quot;.</target>
        </trans-unit>
        <trans-unit id="b06c415192563751b142dd5d437c6004b2e9459e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;expr&lt;/code&gt;, if any.</source>
          <target state="translated">Значение &lt;code&gt;expr&lt;/code&gt; , если есть.</target>
        </trans-unit>
        <trans-unit id="efa4633a9b927147870c40861701a3a66f460ac4" translate="yes" xml:space="preserve">
          <source>The value of an</source>
          <target state="translated">Стоимость</target>
        </trans-unit>
        <trans-unit id="e705d7da4d67602f093ecd07ec55976add979079" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt; is given by its &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;. If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is the first</source>
          <target state="translated">Значение &lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt; задается его &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; . Если нет &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression,&lt;/i&gt;&lt;/a&gt; и это первое</target>
        </trans-unit>
        <trans-unit id="cfdd678ef3efc50d4d19e113e22570e812ee97e8" translate="yes" xml:space="preserve">
          <source>The value of cos(y) + i sin(y).</source>
          <target state="translated">Значение cos(y)+i sin(y).</target>
        </trans-unit>
        <trans-unit id="ce228048bba4c787805c0ea9367075ff06ba1fcc" translate="yes" xml:space="preserve">
          <source>The value of cosh(y) + i sinh(y)</source>
          <target state="translated">Значение cosh(y)+i sinh(y)</target>
        </trans-unit>
        <trans-unit id="dffcef37a6c60e8c1178ac476b670c4fbdc86276" translate="yes" xml:space="preserve">
          <source>The value of the bound being violated</source>
          <target state="translated">Значение нарушаемой границы</target>
        </trans-unit>
        <trans-unit id="911671dbc78d40ead01af236d912c34ae5fc15c4" translate="yes" xml:space="preserve">
          <source>The value of the selected choice.</source>
          <target state="translated">Значение выбранного варианта.</target>
        </trans-unit>
        <trans-unit id="2079c7788ad766ba6207e480774a32436765df0d" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as a &lt;code&gt;long&lt;/code&gt;, or &lt;code&gt;long.max&lt;/code&gt;/&lt;code&gt;long.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">Значение этого &lt;code&gt;BigInt&lt;/code&gt; как &lt;code&gt;long&lt;/code&gt; или &lt;code&gt;long.max&lt;/code&gt; / &lt;code&gt;long.min&lt;/code&gt; , если оно находится за пределами представимого диапазона.</target>
        </trans-unit>
        <trans-unit id="bfb5bbd989c9054cc2b242d5eea3691758f09eed" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as an &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;int.max&lt;/code&gt;/&lt;code&gt;int.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">Значение этого &lt;code&gt;BigInt&lt;/code&gt; как &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;int.max&lt;/code&gt; / &lt;code&gt;int.min&lt;/code&gt; , если оно находится за пределами представимого диапазона.</target>
        </trans-unit>
        <trans-unit id="44a86e613513bb5b90f75505c846e4f1a8d5e443" translate="yes" xml:space="preserve">
          <source>The value of x - i * y, where i is the number of times that y can be completely subtracted from x. The result has the same sign as x.</source>
          <target state="translated">Значение x-i*y,где i-это количество раз,которое y может быть полностью вычтено из x.Результат имеет тот же знак,что и x.</target>
        </trans-unit>
        <trans-unit id="fbda37a05f283a201fa47e61f1a28829aac6ca57" translate="yes" xml:space="preserve">
          <source>The value that serves as the stopping criterion. This value is not included in the range.</source>
          <target state="translated">Значение,которое служит критерием остановки.Это значение не входит в диапазон.</target>
        </trans-unit>
        <trans-unit id="06ef9451ca2a6ddc30c31abb46ec77c558d2c434" translate="yes" xml:space="preserve">
          <source>The value to act as a proxy for all operations. It must be an lvalue.</source>
          <target state="translated">Значение,чтобы действовать в качестве прокси-сервера для всех операций.Это должно быть значение.</target>
        </trans-unit>
        <trans-unit id="c4437657364f8d6c0ea26bb67bc977fd2c3d6762" translate="yes" xml:space="preserve">
          <source>The value to add to the current value at each iteration.</source>
          <target state="translated">Значение для добавления к текущему значению на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="9ea1a4ae4b9c004c5d2afcb14b6504f978c0f7ea" translate="yes" xml:space="preserve">
          <source>The value to append.</source>
          <target state="translated">Значение,которое нужно добавить.</target>
        </trans-unit>
        <trans-unit id="3e27e971fbf5a179f864e36ffcc71eeed5543b79" translate="yes" xml:space="preserve">
          <source>The value to be reference counted</source>
          <target state="translated">Значение для ссылки подсчитывается</target>
        </trans-unit>
        <trans-unit id="48cc3d885cf27d16c55ff2638b8883795263bff6" translate="yes" xml:space="preserve">
          <source>The value to bind to.</source>
          <target state="translated">Значение,к которому нужно привязать.</target>
        </trans-unit>
        <trans-unit id="a802e0b8a3a2b83e804f3a0f0ce8a9cba9671bc8" translate="yes" xml:space="preserve">
          <source>The value to cast. It must be of type &lt;code&gt;From&lt;/code&gt;, otherwise a compile-time error is emitted.</source>
          <target state="translated">Значение для приведения. Он должен иметь тип &lt;code&gt;From&lt;/code&gt; , в противном случае выдается ошибка времени компиляции.</target>
        </trans-unit>
        <trans-unit id="62da9509e3333e477d714ba7dbd138814897fd19" translate="yes" xml:space="preserve">
          <source>The value to clamp.</source>
          <target state="translated">Значение для зажима.</target>
        </trans-unit>
        <trans-unit id="4ad7684bb8903fcc2f377acbdab0d055ec3933a5" translate="yes" xml:space="preserve">
          <source>The value to convert.</source>
          <target state="translated">Значение для конвертации.</target>
        </trans-unit>
        <trans-unit id="50f2da1a55629d14637add94e8f4d0df9b3b3315" translate="yes" xml:space="preserve">
          <source>The value to divide from this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">Значение, которое нужно разделить с этой &lt;code&gt;TickDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a1bf08b423c514be4510f8c180b0baca8c3ce06" translate="yes" xml:space="preserve">
          <source>The value to divide from this duration.</source>
          <target state="translated">Значение,которое необходимо разделить с этой длительностью.</target>
        </trans-unit>
        <trans-unit id="1354007d97f6ba4733c332273819ddc621808569" translate="yes" xml:space="preserve">
          <source>The value to exchange.</source>
          <target state="translated">Значение для обмена.</target>
        </trans-unit>
        <trans-unit id="1212730d5cf61a8236b91aa2562728d9cffb815c" translate="yes" xml:space="preserve">
          <source>The value to initialize this &lt;code&gt;Nullable&lt;/code&gt; with.</source>
          <target state="translated">Значение для инициализации этого &lt;code&gt;Nullable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9870b988dc93826e41d9e14caae258236099356" translate="yes" xml:space="preserve">
          <source>The value to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">Значение для умножения этой &lt;code&gt;Duration&lt;/code&gt; на.</target>
        </trans-unit>
        <trans-unit id="b63d59c749f4e3c4e27b5c62bc54fa60f14460d7" translate="yes" xml:space="preserve">
          <source>The value to multiply/divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">Значение для умножения / деления этой &lt;code&gt;Duration&lt;/code&gt; на.</target>
        </trans-unit>
        <trans-unit id="5f9706fe37a21ebb4f5356314e9dbb0f193612de" translate="yes" xml:space="preserve">
          <source>The value to search for.</source>
          <target state="translated">Значение для поиска.</target>
        </trans-unit>
        <trans-unit id="26611747ab051faf83da9bb9d7c2556f3251cdff" translate="yes" xml:space="preserve">
          <source>The value to store.</source>
          <target state="translated">Стоимость для хранения.</target>
        </trans-unit>
        <trans-unit id="572affcd555e45a118ca8c255703b01188667dc6" translate="yes" xml:space="preserve">
          <source>The value to test.</source>
          <target state="translated">Значение для проверки.</target>
        </trans-unit>
        <trans-unit id="19051782b6b3c278237f01645d39c916e236a933" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
          <target state="translated">Значение для записи.</target>
        </trans-unit>
        <trans-unit id="ed8375fc18b2f2889a5d8178e1f4e71c024e1115" translate="yes" xml:space="preserve">
          <source>The value to yield.</source>
          <target state="translated">Стоимость к доходности.</target>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="translated">Значение.</target>
        </trans-unit>
        <trans-unit id="d9c7ac0f2459cf0fcaba3e1a3c53a1114b6dd604" translate="yes" xml:space="preserve">
          <source>The values of the statistics. Has the same length as &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">Значения статистики. Имеет ту же длину, что и &lt;code&gt;opts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73dba46e865b8a15dc63f7dc2a467e9bb9da631f" translate="yes" xml:space="preserve">
          <source>The values to compare the value to.</source>
          <target state="translated">Значения для сравнения.</target>
        </trans-unit>
        <trans-unit id="c472612eda8a57b671db853841e452b39218b0df" translate="yes" xml:space="preserve">
          <source>The values to select the maximum from. At least two arguments must be passed.</source>
          <target state="translated">Значения для выбора максимального из них.Должно быть передано как минимум два аргумента.</target>
        </trans-unit>
        <trans-unit id="7a965cfb58b4af69ed40e336a152e8e938e3ae5e" translate="yes" xml:space="preserve">
          <source>The values to select the minimum from. At least two arguments must be passed, and they must be comparable with &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">Значения для выбора минимума из. По крайней мере два аргумента должны быть переданы, и они должны быть сопоставимы с &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c4b476e00d554e5b462693564ced434266700cc" translate="yes" xml:space="preserve">
          <source>The vararg module is intended to facilitate vararg manipulation in D. It should be interface compatible with the C module &quot;stdarg,&quot; and the two modules may share a common implementation if possible (as is done here).</source>
          <target state="translated">Модуль vararg предназначен для облегчения манипуляций с vararg в D.Он должен быть интерфейсом,совместимым с модулем C &quot;stdarg&quot;,и оба модуля могут иметь общую реализацию,если это возможно (как это сделано здесь).</target>
        </trans-unit>
        <trans-unit id="e58c51068f71cad0c83773e1d40394fdd897c493" translate="yes" xml:space="preserve">
          <source>The variable to initialize</source>
          <target state="translated">Переменная для инициализации</target>
        </trans-unit>
        <trans-unit id="da94a792f23c83ccf884c163bc10a13c232be367" translate="yes" xml:space="preserve">
          <source>The variadic arguments are normally consumed in order. POSIX-style &lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt; positional parameter syntax&lt;/a&gt; is also supported. Each argument is formatted into a sequence of chars according to the format specification, and the characters are passed to &lt;code&gt;w&lt;/code&gt;. As many arguments as specified in the format string are consumed and formatted. If there are fewer arguments than format specifiers, a &lt;code&gt;FormatException&lt;/code&gt; is thrown. If there are more remaining arguments than needed by the format specification, they are ignored but only if at least one argument was formatted.</source>
          <target state="translated">Вариативные аргументы обычно расходуются по порядку. &lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt;Синтаксис позиционных параметров в&lt;/a&gt; стиле POSIX также поддерживается. Каждый аргумент форматируется в последовательность символов в соответствии со спецификацией формата, а символы передаются в &lt;code&gt;w&lt;/code&gt; . Столько аргументов, сколько указано в строке формата, используется и форматируется. Если аргументов формата меньше, чем спецификаторов формата, &lt;code&gt;FormatException&lt;/code&gt; . Если оставшихся аргументов больше, чем необходимо для спецификации формата, они игнорируются, но только если форматирован хотя бы один аргумент</target>
        </trans-unit>
        <trans-unit id="fa8f9f636d8a6045425f97a32a164b87a688ed99" translate="yes" xml:space="preserve">
          <source>The variadic part is converted to a dynamic array and the rest is the same as for non-variadic functions.</source>
          <target state="translated">Вариадическая часть преобразуется в динамический массив,а остальное то же самое,что и для не вариадических функций.</target>
        </trans-unit>
        <trans-unit id="4280e8c5fae666595a22ad15b85940850cfe38e7" translate="yes" xml:space="preserve">
          <source>The vector extensions are currently implemented for the OS X 32 bit target, and all 64 bit targets.</source>
          <target state="translated">Векторные расширения в настоящее время реализованы для 32-битной цели OS X и всех 64-битных целей.</target>
        </trans-unit>
        <trans-unit id="9a3f2a8776586397a6e7f50b19626acf584f35ca" translate="yes" xml:space="preserve">
          <source>The vendor specific version number, as in version_major.version_minor</source>
          <target state="translated">Номер версии для конкретного производителя,как в версии_major.version_minor.</target>
        </trans-unit>
        <trans-unit id="00e7fe40797e665c537b4d388116b4be59e896ff" translate="yes" xml:space="preserve">
          <source>The version of the D Programming Language Specification supported by the compiler.</source>
          <target state="translated">Версия спецификации языка программирования D,поддерживаемая компилятором.</target>
        </trans-unit>
        <trans-unit id="349a4c5870066cd09694037d969de8543ecfc287" translate="yes" xml:space="preserve">
          <source>The version specification makes it straightforward to group a set of features under one major version, for example:</source>
          <target state="translated">Спецификация версии позволяет,например,сгруппировать набор функций под одной основной версией:</target>
        </trans-unit>
        <trans-unit id="8bd1d61a79fbe94ca1f6332082364d1be24742ef" translate="yes" xml:space="preserve">
          <source>The vtable consists of:</source>
          <target state="translated">Стол состоит из</target>
        </trans-unit>
        <trans-unit id="f3b5820f28d3bae10a6ec27f163ae2a69ac3fe29" translate="yes" xml:space="preserve">
          <source>The way the type of</source>
          <target state="translated">Способ,которым тип</target>
        </trans-unit>
        <trans-unit id="0fcc6679e5070c2e4f446305491364698920c76a" translate="yes" xml:space="preserve">
          <source>The way to read this is: start with negative meaning that all numbers smaller then the next one are not present in this set (and positive - the contrary). Then switch positive/negative after each number passed from left to right.</source>
          <target state="translated">Способ прочтения:начните с отрицательного,имея в виду,что всех чисел,меньших по размеру,чем следующее,в этом наборе нет (а положительное-наоборот).Затем переключайте положительное/отрицательное после каждого числа,переданного слева направо.</target>
        </trans-unit>
        <trans-unit id="ee95d5338e2cc507c044af212b980a2ccdb0be06" translate="yes" xml:space="preserve">
          <source>The week that each time point in the range will be.</source>
          <target state="translated">Неделя,в течение которой каждый момент времени будет в диапазоне.</target>
        </trans-unit>
        <trans-unit id="ccaf69d731f86b374a2484d6db7113668b98a057" translate="yes" xml:space="preserve">
          <source>The worker treads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by the &lt;code&gt;taskPool&lt;/code&gt; property are daemon by default. The worker threads of manually instantiated task pools are non-daemon by default.</source>
          <target state="translated">Рабочие шаги в экземпляре &lt;code&gt;TaskPool&lt;/code&gt; , возвращаемые свойством &lt;code&gt;taskPool&lt;/code&gt; , по умолчанию являются демонами . Рабочие потоки созданных вручную пулов задач по умолчанию не являются демонами.</target>
        </trans-unit>
        <trans-unit id="032848bfda222930e013953265615c3e0ccbd961" translate="yes" xml:space="preserve">
          <source>The working directory for the new process. By default the child process inherits the parent's working directory.</source>
          <target state="translated">Рабочий каталог нового процесса.По умолчанию дочерний процесс наследует рабочую директорию родителя.</target>
        </trans-unit>
        <trans-unit id="5b0246698510343503660da61604a3af0a5e9947" translate="yes" xml:space="preserve">
          <source>The wrapped statement.</source>
          <target state="translated">Завернутое заявление.</target>
        </trans-unit>
        <trans-unit id="83d3fe39ddb643ccc2434ee8c1b4b3abc6a78d80" translate="yes" xml:space="preserve">
          <source>The wrapped type for which Nullable provides a null value.</source>
          <target state="translated">Тип обертки,для которого Nullable дает нулевое значение.</target>
        </trans-unit>
        <trans-unit id="52054c2c6d64acc406d7bd018817d7a8a1e5c5bf" translate="yes" xml:space="preserve">
          <source>The write end of the pipe.</source>
          <target state="translated">Письменный конец трубы.</target>
        </trans-unit>
        <trans-unit id="d72f5499f6b8ab39b36f3e5d6ad25d6e2121747c" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">Год до нашей эры, чтобы установить год этой &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70438f0b3fdbdd369345e88c2fd45090d92cb7e3" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">Год до нашей эры, для которого необходимо установить год &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="744d36d482072547f2d6e876741e0a75ffde2547" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">Год до нашей эры, чтобы установить год этого &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90ffac4afd7dedd0db0cf62512494ecd5d03ce9b" translate="yes" xml:space="preserve">
          <source>The year of the day to validate.</source>
          <target state="translated">Год дня для подтверждения.</target>
        </trans-unit>
        <trans-unit id="6a632533914c1a4222f015d798cec051375cb6c9" translate="yes" xml:space="preserve">
          <source>The year portion of the date.</source>
          <target state="translated">Годовая часть даты.</target>
        </trans-unit>
        <trans-unit id="674f0ed2625d2fbf8d46e126ee7509b07e39337e" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">Год, в который нужно установить год &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b3d4944643d10e9690ce8b16f07cee0b861543" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">Год для установки этого года в &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="938c9fb56ce9737aba86f7a255d511c39f3f1219" translate="yes" xml:space="preserve">
          <source>The year to set this Date's year to.</source>
          <target state="translated">Год,на который назначена эта дата.</target>
        </trans-unit>
        <trans-unit id="25dac3542e9629d3c6f770b554d3c9420550d89e" translate="yes" xml:space="preserve">
          <source>The year to to be tested.</source>
          <target state="translated">Год,который будет проверяться.</target>
        </trans-unit>
        <trans-unit id="b05a3a1416ac42134535e13e8cceef19ad3efbf2" translate="yes" xml:space="preserve">
          <source>The ~= operator. It can have one of the following operators:</source>
          <target state="translated">Оператор ~=.Он может иметь один из следующих операторов:</target>
        </trans-unit>
        <trans-unit id="483dc9258037e4ea0f71ce99febdf439cc645ac7" translate="yes" xml:space="preserve">
          <source>Then each of the arguments whose type does not match that of the delegate is converted to a delegate.</source>
          <target state="translated">Затем каждый из аргументов,тип которых не совпадает с типом делегата,преобразуется в делегата.</target>
        </trans-unit>
        <trans-unit id="4ef903eb9cd7218e2998c6f06dec42c64cb3057d" translate="yes" xml:space="preserve">
          <source>ThenStatement</source>
          <target state="translated">ThenStatement</target>
        </trans-unit>
        <trans-unit id="cffa55acb530a469e1c0e72f460da047941e3e1e" translate="yes" xml:space="preserve">
          <source>There are advantages to storing bookkeeping data separated from the payload (as opposed to e.g. using &lt;code&gt;AffixAllocator&lt;/code&gt; to store metadata together with each allocation). The layout is more compact (overhead is one bit per block), searching for a free block during allocation enjoys better cache locality, and deallocation does not touch memory around the payload being deallocated (which is often cold).</source>
          <target state="translated">Существуют преимущества хранения данных бухгалтерского учета отдельно от полезной нагрузки (в отличие, например, от использования &lt;code&gt;AffixAllocator&lt;/code&gt; для хранения метаданных вместе с каждым распределением). Компоновка является более компактной (накладные расходы составляют один бит на блок), поиск свободного блока во время выделения имеет лучшую локальность кэша, и освобождение не затрагивает память вокруг освобождаемой полезной нагрузки (которая часто является холодной).</target>
        </trans-unit>
        <trans-unit id="71da829c4cc0769086794220605ec04ef8da0ce9" translate="yes" xml:space="preserve">
          <source>There are eight usable logging level. These level are</source>
          <target state="translated">Есть восемь полезных уровней лесозаготовок.Эти уровни</target>
        </trans-unit>
        <trans-unit id="88bbdd16439c34d51b5285ff9a938ae545ede756" translate="yes" xml:space="preserve">
          <source>There are four kinds of arrays:</source>
          <target state="translated">Есть четыре вида массивов:</target>
        </trans-unit>
        <trans-unit id="e137971ce6d07a865f890bb2bb72e21617522984" translate="yes" xml:space="preserve">
          <source>There are four overloads of this function. The first two take an array of strings, &lt;code&gt;args&lt;/code&gt;, which should contain the program name as the zeroth element and any command-line arguments in subsequent elements. The third and fourth versions are included for convenience, and may be used when there are no command-line arguments. They take a single string, &lt;code&gt;program&lt;/code&gt;, which specifies the program name.</source>
          <target state="translated">Есть четыре перегрузки этой функции. Первые два принимают массив строк, &lt;code&gt;args&lt;/code&gt; , который должен содержать имя программы в качестве нулевого элемента и любые аргументы командной строки в последующих элементах. Третья и четвертая версии включены для удобства и могут использоваться, когда нет аргументов командной строки. Они берут одну строку, &lt;code&gt;program&lt;/code&gt; , которая указывает название программы.</target>
        </trans-unit>
        <trans-unit id="72dc9dd21f6b2060d2cd40a0fb38433822ac81cb" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">В этом модуле есть вспомогательные функции, которые генерируют общие делегаты для передачи в &lt;code&gt;bwdRange&lt;/code&gt; . Их документация начинается с &amp;laquo;Функция генерации диапазона&amp;raquo;, что делает их легко доступными для поиска.</target>
        </trans-unit>
        <trans-unit id="b5dd0af54e988a94be1d9ad088b9582f13489afd" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">В этом модуле есть вспомогательные функции, которые генерируют общие делегаты для передачи в &lt;code&gt;bwdRange&lt;/code&gt; . Их документация начинается с &amp;laquo;Функция генерации диапазона&amp;raquo;, чтобы их можно было легко найти.</target>
        </trans-unit>
        <trans-unit id="7d94c1629b0bd4094ede841815962ed80d0586ef" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">В этом модуле есть вспомогательные функции, которые генерируют общие делегаты для передачи в &lt;code&gt;fwdRange&lt;/code&gt; . Их документация начинается с &amp;laquo;Функция генерации диапазона&amp;raquo;, что делает их легко доступными для поиска.</target>
        </trans-unit>
        <trans-unit id="4b9f6a69e089c92a07a88022f54475869259bbc2" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">В этом модуле есть вспомогательные функции, которые генерируют общие делегаты для передачи в &lt;code&gt;fwdRange&lt;/code&gt; . Их документация начинается с &amp;laquo;Функция генерации диапазона&amp;raquo;, чтобы их можно было легко найти.</target>
        </trans-unit>
        <trans-unit id="fd1414ed61178080af45a1f5ca51914c6e9d26e1" translate="yes" xml:space="preserve">
          <source>There are many articles available that can bolster understanding ranges:</source>
          <target state="translated">Существует множество статей,которые могут расширить диапазон понимания:</target>
        </trans-unit>
        <trans-unit id="c2d037a1149b17d68159307022f28fe56d8f92d3" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt;&lt;/a&gt;, or other such C &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;extended type modifiers&lt;/a&gt; in D. These are handled by &lt;a href=&quot;attribute#linkage&quot;&gt;linkage attributes&lt;/a&gt;, such as &lt;code&gt;extern (C)&lt;/code&gt;.</source>
          <target state="translated">Там нет &lt;code&gt;__cdecl&lt;/code&gt; , &lt;code&gt;__far&lt;/code&gt; , &lt;code&gt;__stdcall&lt;/code&gt; , &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt; &lt;/a&gt; , или другие подобные C &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;расширены модификаторы типов&lt;/a&gt; в D. Они обрабатываются &lt;a href=&quot;attribute#linkage&quot;&gt;атрибуты сцепления&lt;/a&gt; , такие как &lt;code&gt;extern (C)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b9f66c209295069e84d0b1adcf2cd5cdb6933de" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;code&gt;__declspec&lt;/code&gt;, or other such nonstandard C++ extensions in D.</source>
          <target state="translated">Там нет &lt;code&gt;__cdecl&lt;/code&gt; , &lt;code&gt;__far&lt;/code&gt; , &lt;code&gt;__stdcall&lt;/code&gt; , &lt;code&gt;__declspec&lt;/code&gt; , или другие подобные нестандартные C ++ расширения в D.</target>
        </trans-unit>
        <trans-unit id="b1bbd1ded800fb7f0f4f094477d38ab432c667c3" translate="yes" xml:space="preserve">
          <source>There are no volatile type modifiers in D.</source>
          <target state="translated">В D нет модификаторов переменного типа.</target>
        </trans-unit>
        <trans-unit id="bf7de3e93eae097ffa9c0cf65d8e97655fc5a893" translate="yes" xml:space="preserve">
          <source>There are other web resources on regular expressions to help newcomers, and a good &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;reference with tutorial&lt;/a&gt; can easily be found.</source>
          <target state="translated">Существуют и другие веб-ресурсы по регулярным выражениям, помогающие новичкам, и можно легко найти хорошую &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;ссылку с руководством&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c5539350a7f6635346ecf0167abeb30fa2fea73" translate="yes" xml:space="preserve">
          <source>There are several forms of the</source>
          <target state="translated">Существует несколько форм</target>
        </trans-unit>
        <trans-unit id="6bdc06ec8e2f529ede508fc3fd01087470669fa0" translate="yes" xml:space="preserve">
          <source>There are several things going on here:</source>
          <target state="translated">Здесь происходит несколько вещей:</target>
        </trans-unit>
        <trans-unit id="06fc1953f9bbd669c6940d581b7a118ebf65b6cd" translate="yes" xml:space="preserve">
          <source>There are several workarounds for this limitation:</source>
          <target state="translated">Существует несколько обходных путей для этого ограничения:</target>
        </trans-unit>
        <trans-unit id="83683e99bdd11374a698bc33993ac450a4156b31" translate="yes" xml:space="preserve">
          <source>There are three categories of functions from the perspective of memory safety:</source>
          <target state="translated">С точки зрения безопасности памяти существует три категории функций:</target>
        </trans-unit>
        <trans-unit id="eebb936bce7d3ae26cde36cf7bb35604dacc5791" translate="yes" xml:space="preserve">
          <source>There are three kinds of comments:</source>
          <target state="translated">Есть три вида комментариев:</target>
        </trans-unit>
        <trans-unit id="0ec3b7350c3966a7a5f315773f8a0d6461bc2b7c" translate="yes" xml:space="preserve">
          <source>There are two APIs for digests: The template API and the OOP API. The template API uses structs and template helpers like &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;. The OOP API implements digests as classes inheriting the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; interface. All digests are named so that the template API struct is called &quot;&lt;b&gt;x&lt;/b&gt;&quot; and the OOP API class is called &quot;&lt;b&gt;x&lt;/b&gt;Digest&quot;. For example we have &lt;code&gt;MD5&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt;, &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt;, etc.</source>
          <target state="translated">Существует два API для дайджестов: API шаблонов и OOP API. Шаблон API использует структуры и помощники шаблонов, такие как &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; . OOP API реализует дайджесты как классы, наследующие интерфейс &lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt; . Все дайджесты названы так, что структура API шаблона называется &amp;laquo; &lt;b&gt;x&lt;/b&gt; &amp;raquo;, а класс API ООП - &amp;laquo; &lt;b&gt;x&lt;/b&gt; Digest&amp;raquo;. Например, у нас есть &lt;code&gt;MD5&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt; , &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="f36743287cbe9730e4d00f520be725403f6d9245" translate="yes" xml:space="preserve">
          <source>There are two broad kinds of operations to do on an array - affecting the handle to the array, and affecting the contents of the array.</source>
          <target state="translated">Существует два больших типа операций над массивом-воздействие на дескриптор массива и воздействие на содержимое массива.</target>
        </trans-unit>
        <trans-unit id="2f32e0774371c9709a85def64d98a62e794b8e4d" translate="yes" xml:space="preserve">
          <source>There are two options for handlers. The &lt;code&gt;bool&lt;/code&gt; version is deprecated but will be kept for legacy support. Returning &lt;code&gt;true&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.pass&lt;/code&gt; from the extended version. Returning &lt;code&gt;false&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.fail&lt;/code&gt; from the extended version.</source>
          <target state="translated">Есть два варианта для обработчиков. Версия &lt;code&gt;bool&lt;/code&gt; устарела, но будет сохранена для устаревшей поддержки. Возвращение &lt;code&gt;true&lt;/code&gt; из обработчика эквивалентно возвращению &lt;code&gt;UnitTestResult.pass&lt;/code&gt; из расширенной версии. Возвращение &lt;code&gt;false&lt;/code&gt; из обработчика эквивалентно возвращению &lt;code&gt;UnitTestResult.fail&lt;/code&gt; из расширенной версии.</target>
        </trans-unit>
        <trans-unit id="2ba98a9e569b41d605493fc4327d51d93311f773" translate="yes" xml:space="preserve">
          <source>There are two ways of using tilde expansion in a path. One involves using the tilde alone or followed by a path separator. In this case, the tilde will be expanded with the value of the environment variable &lt;code&gt;HOME&lt;/code&gt;. The second way is putting a username after the tilde (i.e. &lt;code&gt;~john/Mail&lt;/code&gt;). Here, the username will be searched for in the user database (i.e. &lt;code&gt;/etc/passwd&lt;/code&gt; on Unix systems) and will expand to whatever path is stored there. The username is considered the string after the tilde ending at the first instance of a path separator.</source>
          <target state="translated">Существует два способа использования расширения тильды в пути. Один включает использование тильды отдельно или с последующим разделителем пути. В этом случае тильда будет расширена значением переменной среды &lt;code&gt;HOME&lt;/code&gt; . Второй способ - поставить имя пользователя после тильды (например, &lt;code&gt;~john/Mail&lt;/code&gt; ). Здесь имя пользователя будет искать в базе данных пользователей (например, &lt;code&gt;/etc/passwd&lt;/code&gt; в системах Unix) и будет расширяться до любого пути, который там хранится. Имя пользователя считается строкой после окончания тильды в первом экземпляре разделителя пути.</target>
        </trans-unit>
        <trans-unit id="4751b63f33932c16045492e8c9d0524f058f4c0a" translate="yes" xml:space="preserve">
          <source>There are two ways to declarate a symbol as member of a namespace: &lt;code&gt;Nspace&lt;/code&gt; and &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt;. The former creates a scope for the symbol, and inject them in the parent scope at the same time. The later, this class, has no semantic implications and is only used for mangling. Additionally, this class allows one to use reserved identifiers (D keywords) in the namespace.</source>
          <target state="translated">Есть два способа объявить символ как член пространства имен: &lt;code&gt;Nspace&lt;/code&gt; и &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; . Первый создает область для символа и одновременно внедряет их в родительскую область. Позднее этот класс не имеет семантического значения и используется только для искажения. Кроме того, этот класс позволяет использовать зарезервированные идентификаторы (ключевые слова D) в пространстве имен.</target>
        </trans-unit>
        <trans-unit id="87bb5bc4a10799fcef3cdb638af33c37c5ac5274" translate="yes" xml:space="preserve">
          <source>There can be any number of unit test functions in a module, including within struct, union and class declarations. They are executed in lexical order.</source>
          <target state="translated">В модуле может быть любое количество функций юнит-тестирования,в том числе в рамках деклараций структур,союзов и классов.Они выполняются в лексическом порядке.</target>
        </trans-unit>
        <trans-unit id="ed108d2e4ffaebbc3cca03de1cfa2dee10188c4a" translate="yes" xml:space="preserve">
          <source>There can be more than one invariant declared per class or struct.</source>
          <target state="translated">Для каждого класса или структуры может быть объявлено более одного инварианта.</target>
        </trans-unit>
        <trans-unit id="07b99c3830a2a4bb0228e8b9b17dd7669ccd56c2" translate="yes" xml:space="preserve">
          <source>There can be multiple documented unittests and they can appear in any order. They will be attached to the last non-unittest declaration:</source>
          <target state="translated">Могут быть задокументированы несколько юнит-тестов,и они могут появиться в любом порядке.Они будут приложены к последнему неюнит-тесту:</target>
        </trans-unit>
        <trans-unit id="a95e25d0165fbf5408fd68a513879e3e08629026" translate="yes" xml:space="preserve">
          <source>There can be multiple static constructors and static destructors within one module. The static constructors are run in lexical order, the static destructors are run in reverse lexical order.</source>
          <target state="translated">В пределах одного модуля может быть несколько статических конструкторов и статических деструкторов.Статические конструкторы выполняются в лексическом порядке,статические деструкторы выполняются в обратном лексическом порядке.</target>
        </trans-unit>
        <trans-unit id="079786d2cc065de51998cade65524ac448945bab" translate="yes" xml:space="preserve">
          <source>There can be only one destructor per class, the destructor does not have any parameters, and has no attributes. It is always virtual.</source>
          <target state="translated">В каждом классе может быть только один деструктор,деструктор не имеет параметров и атрибутов.Он всегда виртуальный.</target>
        </trans-unit>
        <trans-unit id="a32fb137b8708f3a1060842effbe53862ee224b5" translate="yes" xml:space="preserve">
          <source>There can be only zero or one</source>
          <target state="translated">Может быть только ноль или один</target>
        </trans-unit>
        <trans-unit id="e54e87553bcbc89bb92a0dbc881f7633b6a68acf" translate="yes" xml:space="preserve">
          <source>There has been a great deal of discussion in the D newsgroups over this, and several implementations:  &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;signal slots library&lt;/a&gt;</source>
          <target state="translated">В группах новостей D было много дискуссий по этому поводу и несколько реализаций: &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;библиотека сигнальных слотов&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb4241af492e556aa6aed9941d820f825c722aec" translate="yes" xml:space="preserve">
          <source>There have been several D implementations of Signals and Slots. This version makes use of several new features in D, which make using it simpler and less error prone. In particular, it is no longer necessary to instrument the slots.</source>
          <target state="translated">Существует несколько D реализаций Сигналов и Слотов.Эта версия использует несколько новых функций в D,которые делают использование ее более простым и менее склонным к ошибкам.В частности,отпала необходимость в инструментировании слотов.</target>
        </trans-unit>
        <trans-unit id="137e54850bfef26233dbe4876142a62cdeee9d88" translate="yes" xml:space="preserve">
          <source>There is a hierarchy of allocation kinds. When an allocator is implemented for a given combination of flags, it is used. Otherwise, the next down the list is chosen.</source>
          <target state="translated">Существует иерархия видов распределения.Когда аллокатор реализован для заданной комбинации флагов,он используется.В противном случае выбирается следующий по списку.</target>
        </trans-unit>
        <trans-unit id="fb4bb1493d0166938db3cf214276bbc597f0dc3b" translate="yes" xml:space="preserve">
          <source>There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;, respectively. Other functions that have a wider generality than just strings can be found in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Существует богатый набор функций для обработки строк, определенных в других модулях. Функции, связанные с Unicode и ASCII, находятся в &lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;std_ascii&quot;&gt; &lt;code&gt;std.ascii&lt;/code&gt; &lt;/a&gt; , соответственно. Другие функции, которые имеют более широкую общность, чем просто строки, можно найти в &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="567058ffed748f85071d989bbf1a314374e793b2" translate="yes" xml:space="preserve">
          <source>There is a special type of array which acts as a wildcard that can hold arrays of any kind, declared as &lt;code&gt;void[]&lt;/code&gt;. Void arrays are used for low-level operations where some kind of array data is being handled, but the exact type of the array elements are unimportant. The &lt;code&gt;.length&lt;/code&gt; of a void array is the length of the data in bytes, rather than the number of elements in its original type. Array indices in indexing and slicing operations are interpreted as byte indices.</source>
          <target state="translated">Существует специальный тип массива, который действует как подстановочный знак, который может содержать массивы любого вида, объявленный как &lt;code&gt;void[]&lt;/code&gt; . Пустые массивы используются для низкоуровневых операций, когда обрабатываются некоторые виды данных массива, но точный тип элементов массива не важен. Длина &lt;code&gt;.length&lt;/code&gt; void - это длина данных в байтах, а не количество элементов в исходном типе. Индексы массива в операциях индексирования и среза интерпретируются как байтовые индексы.</target>
        </trans-unit>
        <trans-unit id="33cea21ca6b34b343eb25bbde6ebec03ec759bdc" translate="yes" xml:space="preserve">
          <source>There is currently only one special token sequence, &lt;code&gt;#line&lt;/code&gt;.</source>
          <target state="translated">В настоящее время существует только одна специальная последовательность токенов, &lt;code&gt;#line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef49fac97d8d2e188e2b78d1a813470cc50ed39b" translate="yes" xml:space="preserve">
          <source>There is currently work in progress to make the runtime library free of GC heap allocations, to allow its use in scenarios where the use of GC infrastructure is not possible.</source>
          <target state="translated">В настоящее время ведется работа над тем,чтобы сделать библиотеку исполнения свободной от выделения кучи GC,чтобы ее можно было использовать в сценариях,когда использование инфраструктуры GC невозможно.</target>
        </trans-unit>
        <trans-unit id="4d933b4164fe170e150ab2367873a597423583d2" translate="yes" xml:space="preserve">
          <source>There is no more need to translate error codes into human readable strings, the correct string is generated by the error detection code, not the error recovery code. This also leads to consistent error messages for the same error between applications.</source>
          <target state="translated">Больше нет необходимости транслировать коды ошибок в читаемые человеком строки,правильная строка генерируется кодом обнаружения ошибок,а не кодом восстановления ошибок.Это также приводит к согласованным сообщениям об одной и той же ошибке между приложениями.</target>
        </trans-unit>
        <trans-unit id="f17b623fe683ff68f6ed189b8d0d74d5452c95d7" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">Нет перегрузки для &lt;code&gt;merge&lt;/code&gt; которое принимает &lt;code&gt;NegInfInterval&lt;/code&gt; , потому что интервал от отрицательной бесконечности до положительной бесконечности невозможен.</target>
        </trans-unit>
        <trans-unit id="e26153f4d19858ed80c05ff7d79d4191b5074d49" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">Нет перегрузки для &lt;code&gt;merge&lt;/code&gt; которое принимает &lt;code&gt;PosInfInterval&lt;/code&gt; , потому что интервал от отрицательной бесконечности до положительной бесконечности невозможен.</target>
        </trans-unit>
        <trans-unit id="5f100a7a77aee94633ec1e2fffc1096ce477240e" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">Нет перегрузки для &lt;code&gt;span&lt;/code&gt; который принимает &lt;code&gt;NegInfInterval&lt;/code&gt; , потому что интервал от отрицательной бесконечности до положительной бесконечности невозможен.</target>
        </trans-unit>
        <trans-unit id="5ac7b0e8d9f0ebf981b0a2590d75065c28e84b23" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">Нет перегрузки для &lt;code&gt;span&lt;/code&gt; который принимает &lt;code&gt;PosInfInterval&lt;/code&gt; , потому что интервал от отрицательной бесконечности до положительной бесконечности невозможен.</target>
        </trans-unit>
        <trans-unit id="f2973bc2fd6add6e6231856c6dedc987f0924540" translate="yes" xml:space="preserve">
          <source>There is no remove command functionality. Do a &lt;a href=&quot;#clearCommands&quot;&gt;&lt;code&gt;clearCommands&lt;/code&gt;&lt;/a&gt; and set the needed commands instead.</source>
          <target state="translated">Нет команды удаления команды. Сделайте &lt;a href=&quot;#clearCommands&quot;&gt; &lt;code&gt;clearCommands&lt;/code&gt; &lt;/a&gt; и установите необходимые команды вместо этого.</target>
        </trans-unit>
        <trans-unit id="5030f2329ed730fd9eebd4cf5437fa2be5db1b38" translate="yes" xml:space="preserve">
          <source>There is no remove header functionality. Do a &lt;a href=&quot;#clearRequestHeaders&quot;&gt;&lt;code&gt;clearRequestHeaders&lt;/code&gt;&lt;/a&gt; and set the needed headers instead.</source>
          <target state="translated">Нет функции удаления заголовка. Сделайте &lt;a href=&quot;#clearRequestHeaders&quot;&gt; &lt;code&gt;clearRequestHeaders&lt;/code&gt; &lt;/a&gt; и установите вместо него необходимые заголовки.</target>
        </trans-unit>
        <trans-unit id="97b11eff895aae8a00d7fa461823417d322a76c8" translate="yes" xml:space="preserve">
          <source>There is no virtual table.</source>
          <target state="translated">Виртуального стола нет.</target>
        </trans-unit>
        <trans-unit id="5dac0a061658caed895ea08b3637f43c40d7da9d" translate="yes" xml:space="preserve">
          <source>There is no volatile type modifier in D. To declare a C function that uses volatile, just drop the keyword from the declaration.</source>
          <target state="translated">В D нет модификатора типа volatile.Чтобы объявить функцию C,использующую volatile,просто опустите ключевое слово из объявления.</target>
        </trans-unit>
        <trans-unit id="2434d329704768f135cc60da2cb84c7ba22ac13f" translate="yes" xml:space="preserve">
          <source>There is one exception to the fact that the new type is not related to the old type. &lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;Pseudo-member&lt;/a&gt; functions are usable with the new type; they will be forwarded on to the proxied value.</source>
          <target state="translated">Есть одно исключение из того факта, что новый тип не связан со старым типом. &lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;Псевдо-&lt;/a&gt; функции можно использовать с новым типом; они будут перенаправлены на прокси-значение.</target>
        </trans-unit>
        <trans-unit id="ba21f8033d033a747c90b386e1729af20f18ceb8" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a class. They are applied in lexical order.</source>
          <target state="translated">В классе может быть несколько инвариантов.Они применяются в лексическом порядке.</target>
        </trans-unit>
        <trans-unit id="9a039cc903df4604c54902450e403871fe046481" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a struct. They are applied in lexical order.</source>
          <target state="translated">В структуре может быть несколько инвариантов.Они применяются в лексическом порядке.</target>
        </trans-unit>
        <trans-unit id="d77d0c2b7a22ee08dcc65faf1983734627d5bea1" translate="yes" xml:space="preserve">
          <source>There may be one or more callable entities (&lt;code&gt;functions&lt;/code&gt; argument) to apply.</source>
          <target state="translated">Может применяться одна или несколько вызываемых сущностей ( аргумент &lt;code&gt;functions&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="32ca8690590fc77f40e2a27fd064159d0d52468b" translate="yes" xml:space="preserve">
          <source>There must be at least one non-variadic parameter declared.</source>
          <target state="translated">Должен быть объявлен как минимум один неизменяемый параметр.</target>
        </trans-unit>
        <trans-unit id="60b895f637fb0461c08aa3c29c276b9513bb30e3" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a function symbol.</source>
          <target state="translated">Должно быть одно &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression,&lt;/i&gt;&lt;/a&gt; и оно должно вычисляться во время компиляции для символа функции.</target>
        </trans-unit>
        <trans-unit id="ed59ba7f34618cfcf4f2f62b488d49f3556f524b" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a string literal.</source>
          <target state="translated">Должно быть одно &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression,&lt;/i&gt;&lt;/a&gt; и оно должно вычисляться во время компиляции в строковый литерал.</target>
        </trans-unit>
        <trans-unit id="9800621b870999653a584633cd52d141e5fbaea7" translate="yes" xml:space="preserve">
          <source>There's only one instance of each module, and it is statically allocated.</source>
          <target state="translated">Есть только один экземпляр каждого модуля,и он статически выделен.</target>
        </trans-unit>
        <trans-unit id="2acf8c215fcf96c4f44ab4510da81603fd6cc2b3" translate="yes" xml:space="preserve">
          <source>Therefore, it is the programmer's responsibility to ensure that &lt;code&gt;opCmp&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; are consistent with each other. If &lt;code&gt;opEquals&lt;/code&gt; is not specified, the compiler provides a default version that does member-wise comparison. If this suffices, one may define only &lt;code&gt;opCmp&lt;/code&gt; to customize the behaviour of the inequality operators. But if not, then a custom version of &lt;code&gt;opEquals&lt;/code&gt; should be defined as well, in order to preserve consistent semantics between the two kinds of comparison operators.</source>
          <target state="translated">Таким образом, программист несет ответственность за обеспечение соответствия &lt;code&gt;opCmp&lt;/code&gt; и &lt;code&gt;opEquals&lt;/code&gt; друг другу. Если &lt;code&gt;opEquals&lt;/code&gt; не указан, компилятор предоставляет версию по умолчанию, которая выполняет сравнение по элементам. Если этого достаточно, можно определить только &lt;code&gt;opCmp&lt;/code&gt; , чтобы настроить поведение операторов неравенства. Но если нет, то должна быть также определена пользовательская версия &lt;code&gt;opEquals&lt;/code&gt; , чтобы сохранить согласованную семантику между двумя видами операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="f6272f7f8273a14bd5544dddbcb1b98032093e68" translate="yes" xml:space="preserve">
          <source>These allow you to construct a &lt;code&gt;Duration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">Это позволяет вам построить &lt;code&gt;Duration&lt;/code&gt; из заданных единиц времени с заданной продолжительностью.</target>
        </trans-unit>
        <trans-unit id="da7cf3cb33f506c60b3bae2d7621731fe8a25b5a" translate="yes" xml:space="preserve">
          <source>These are a temporary means of providing a GC hook for DLL use. They may be replaced with some other similar functionality later.</source>
          <target state="translated">Это временное средство обеспечения крюка GC для использования DLL.Позже они могут быть заменены другими аналогичными функциональными возможностями.</target>
        </trans-unit>
        <trans-unit id="6b408f5f827798e4336b44c606a3a8049fa5f385" translate="yes" xml:space="preserve">
          <source>These are convenience aliases for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the SHA implementation.</source>
          <target state="translated">Это псевдонимы удобства для &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; ,&lt;/a&gt; использующего реализацию SHA.</target>
        </trans-unit>
        <trans-unit id="cc11c250252b92e0b68a712fc50db2f954bbf31e" translate="yes" xml:space="preserve">
          <source>These are found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt/&lt;/a&gt;.</source>
          <target state="translated">Они найдены в Druntime's RT &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d82964c86f7448130324ef200af867ae90f45f65" translate="yes" xml:space="preserve">
          <source>These are mostly undocumented, as documentation for the functions these declarations provide bindings to can be found on external resources.</source>
          <target state="translated">В основном они не документированы,так как документация по функциям,которые эти декларации обеспечивают привязки,может быть найдена на внешних ресурсах.</target>
        </trans-unit>
        <trans-unit id="a0b799b4059387b1ffa81eb5e832597a15aaf9ea" translate="yes" xml:space="preserve">
          <source>These are not directly overloadable, but instead are rewritten in terms of the ++</source>
          <target state="translated">Они не перегружаются напрямую,а переписываются в терминах &quot;++&quot;.</target>
        </trans-unit>
        <trans-unit id="684251477ee92646066796884e053236894cc9d8" translate="yes" xml:space="preserve">
          <source>These are not to be conflated with atomic operations. They do not guarantee any atomicity. This may be provided by coincidence as a result of the instructions used on the target, but this should not be relied on for portable programs. Further, no memory fences are implied by these functions. They should not be used for communication between threads. They may be used to guarantee a write or read cycle occurs at a specified address.</source>
          <target state="translated">Они не должны сочетаться с атомными операциями.Они не гарантируют никакой атомарности.Это может быть обеспечено случайным совпадением в результате инструкций,используемых на цели,но на это не следует полагаться для переносимых программ.Кроме того,эти функции не подразумевают никаких ограждений памяти.Их не следует использовать для связи между потоками.Они могут использоваться для гарантии того,что цикл записи или чтения будет происходить по указанному адресу.</target>
        </trans-unit>
        <trans-unit id="ebd50df5a290d3b9f19a683a307dc1ce5e6fed02" translate="yes" xml:space="preserve">
          <source>These are of type &lt;code&gt;bool&lt;/code&gt; and when cast to another integral type become the values 1 and 0, respectively.</source>
          <target state="translated">Они имеют тип &lt;code&gt;bool&lt;/code&gt; и при приведении к другому целочисленному типу становятся значениями 1 и 0 соответственно.</target>
        </trans-unit>
        <trans-unit id="812c2acf872ebe10657aaa2bbdf1807e2d587d11" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-debug=&lt;/code&gt;</source>
          <target state="translated">Предположительно они устанавливаются командной строкой как &lt;code&gt;-debug=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c1d2e1e32630d5e744bf290c6e49eb16fa04f9" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-version=n&lt;/code&gt; and &lt;code&gt;-version=identifier&lt;/code&gt;.</source>
          <target state="translated">Предположительно они устанавливаются командной строкой как &lt;code&gt;-version=n&lt;/code&gt; и &lt;code&gt;-version=identifier&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2ddfd41f42add825e0e95354286885963260165" translate="yes" xml:space="preserve">
          <source>These are the return codes for the seek callbacks</source>
          <target state="translated">Это коды возврата для обратных вызовов на поиск.</target>
        </trans-unit>
        <trans-unit id="402db899657981891e40b75b734371cded453058" translate="yes" xml:space="preserve">
          <source>These are the same kinds of scenarios where different optimization settings affect the results.</source>
          <target state="translated">Это одни и те же сценарии,в которых разные настройки оптимизации влияют на результаты.</target>
        </trans-unit>
        <trans-unit id="1b6a4816df5dd7b7abf0b558eca9229ade75c78d" translate="yes" xml:space="preserve">
          <source>These arrays are statically allocated when they appear in global scope. Otherwise, they need to be marked with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; storage classes to make them statically allocated arrays.</source>
          <target state="translated">Эти массивы статически выделяются, когда они появляются в глобальной области видимости. В противном случае, они должны быть помечены &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;static&lt;/code&gt; хранения классов , чтобы сделать их статически распределенные массивы.</target>
        </trans-unit>
        <trans-unit id="89a145122969b840110b2fc3e84b6ee09c611afa" translate="yes" xml:space="preserve">
          <source>These attributes may appear after the formal parameter list, in which case they apply either to a method's &lt;code&gt;this&lt;/code&gt; parameter, or to a free function's first parameter</source>
          <target state="translated">Эти атрибуты могут появляться после списка формальных параметров, и в этом случае они применяются либо к параметру &lt;code&gt;this&lt;/code&gt; метода , либо к первому параметру свободной функции</target>
        </trans-unit>
        <trans-unit id="a7f7fc51e48ac814a4df7b5cf79166bee33de381" translate="yes" xml:space="preserve">
          <source>These attributes may be inferred when the compiler has the function body available, such as with templates.</source>
          <target state="translated">Эти атрибуты могут быть выведены,когда компилятор имеет доступное тело функции,например,с шаблонами.</target>
        </trans-unit>
        <trans-unit id="2c92e5f8eec2fac65821b6ee901edef5b0d32346" translate="yes" xml:space="preserve">
          <source>These behaviors may be specified when a mailbox is full.</source>
          <target state="translated">Такое поведение может быть указано,когда почтовый ящик переполнен.</target>
        </trans-unit>
        <trans-unit id="36131b1e9db1f47f4a6ae00babc38af51f8234a5" translate="yes" xml:space="preserve">
          <source>These characters are not normally used in isolation unless they are being described. They include such characters as accents, diacritics, Hebrew points, Arabic vowel signs, and Indic matras.</source>
          <target state="translated">Обычно эти символы не используются по отдельности,если только они не описываются.Они включают такие символы,как акценты,диакритические знаки,иврит,арабские гласные знаки и индикаторные матры.</target>
        </trans-unit>
        <trans-unit id="5af07f8dc23a2ff314c5b53d75ac93fc8390edf4" translate="yes" xml:space="preserve">
          <source>These compound format specifiers may be nested in the case of a nested array argument:</source>
          <target state="translated">Эти составные спецификаторы формата могут быть вложены в случае вложенного аргумента массива:</target>
        </trans-unit>
        <trans-unit id="636ef2d434aea6975bee7e2e69eaea244d21ce1f" translate="yes" xml:space="preserve">
          <source>These constraints are addressed by techniques outlined in &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;Memory Management&lt;/a&gt;, including the mechanisms provided by D to control allocations outside the GC heap.</source>
          <target state="translated">Эти ограничения устраняются методами, описанными в &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;управлении памятью&lt;/a&gt; , включая механизмы, предоставляемые D для управления выделениями за пределами кучи GC.</target>
        </trans-unit>
        <trans-unit id="ce5525a7da98014873ce5f20228128913e88d54f" translate="yes" xml:space="preserve">
          <source>These declarations are transformed into templates:</source>
          <target state="translated">Эти декларации преобразуются в шаблоны:</target>
        </trans-unit>
        <trans-unit id="cd87aa675633720f30baafcf6365c73aa7dc6850" translate="yes" xml:space="preserve">
          <source>These directories are recognized by some tools, like the Objective-C compiler and linker, to be frameworks. To link with a framework from DMD, use the following flags:</source>
          <target state="translated">Эти каталоги распознаются некоторыми инструментами,такими как компилятор Objective-C и компоновщик связей,как фреймворки.Для связи с фреймворком из DMD используйте следующие флаги:</target>
        </trans-unit>
        <trans-unit id="2db5010283f3eff8277b4bb683d65dd36da0605f" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_HTTP_VERSION option.</source>
          <target state="translated">Эти перечисления предназначены для использования с опцией CURLOPT_HTTP_VERSION.</target>
        </trans-unit>
        <trans-unit id="66b51419f8ca45e5302436f93fca4afec04366fd" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_NETRC option.</source>
          <target state="translated">Эти перечисления предназначены для использования с опцией CURLOPT_NETRC.</target>
        </trans-unit>
        <trans-unit id="792d4e3a997f4a55954321b6a67c17e920eebf88" translate="yes" xml:space="preserve">
          <source>These equivalents hold for most C compilers. The C standard does not pin down the sizes of the types, so some care is needed.</source>
          <target state="translated">Эти эквиваленты есть в большинстве компиляторов Си.Стандарт Си не определяет размеры типов,поэтому требуется некоторое внимание.</target>
        </trans-unit>
        <trans-unit id="dd5b42710c6e5261013fdb1ae53fc4cbc41fd9bf" translate="yes" xml:space="preserve">
          <source>These equivalents hold when the D and C++ compilers used are companions on the host platform.</source>
          <target state="translated">Эти эквиваленты встречаются,когда используемые компиляторы D и C++являются компаньонами на хостовой платформе.</target>
        </trans-unit>
        <trans-unit id="90ade43ed5cb1a3092e67126f0f81a88dfd49b38" translate="yes" xml:space="preserve">
          <source>These extensions can be pretty-printed by &lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt;. The &lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt; debugger supports them.</source>
          <target state="translated">Эти расширения могут быть напечатаны с помощью &lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt; . &lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt; отладчик поддерживает их.</target>
        </trans-unit>
        <trans-unit id="ad13d21d22689769fb2cd4c608e9e8fc232324fc" translate="yes" xml:space="preserve">
          <source>These field were added in CURLVERSION_FOURTH. Same as 'libiconv_version' if built with HAVE_ICONV</source>
          <target state="translated">Эти поля были добавлены в CURLVERSION_FOURTH.То же самое,что и 'libiconv_version',если собрано с HAVE_ICONV</target>
        </trans-unit>
        <trans-unit id="507497a0514f5bd17890a554cbbbf16c831493b7" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent a complex attribute.</source>
          <target state="translated">Эти флаги могут быть побитовыми OR-ed вместе для представления сложного атрибута.</target>
        </trans-unit>
        <trans-unit id="0046ed397526fe785a54f9113f894289f9d20106" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent complex storage class.</source>
          <target state="translated">Эти флаги могут быть растровыми OR-ed вместе для представления сложного класса хранения.</target>
        </trans-unit>
        <trans-unit id="91bde2af8a3dc4b91f2f8c73ebb091513ee7a69a" translate="yes" xml:space="preserve">
          <source>These flags can be set/reset via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">Эти флаги можно установить / сбросить с помощью функций в &lt;code&gt;core.stdc.fenv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10b77f7a0eebb3e7a656fbdfd23d4cee9e1bc0e6" translate="yes" xml:space="preserve">
          <source>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</source>
          <target state="translated">Эти флаги указывают на то,что произошло исключительное состояние с плавающей точкой.Они указывают на то,что был создан NaN или бесконечность,что результат был неточным или что была встречена сигнализация NaN.Если исключения с плавающей точкой разрешены (размаскированы),вместо установки этих флагов будет сгенерировано аппаратное исключение.</target>
        </trans-unit>
        <trans-unit id="e250dcdba1c724b4c5950d43225e8f190c1411c5" translate="yes" xml:space="preserve">
          <source>These functions allow getting and setting the OS scheduling priority of the worker threads in this &lt;code&gt;TaskPool&lt;/code&gt;. They forward to &lt;code&gt;core.thread.Thread.priority&lt;/code&gt;, so a given priority value here means the same thing as an identical priority value in &lt;code&gt;core.thread&lt;/code&gt;.</source>
          <target state="translated">Эти функции позволяют получать и устанавливать приоритет планирования ОС рабочих потоков в этом &lt;code&gt;TaskPool&lt;/code&gt; . Они пересылаются в &lt;code&gt;core.thread.Thread.priority&lt;/code&gt; , поэтому данное значение приоритета здесь означает то же самое, что и идентичное значение приоритета в &lt;code&gt;core.thread&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563010f17028868ed8865c10ee72ad70b45bdc1f" translate="yes" xml:space="preserve">
          <source>These functions allow the creation of &lt;code&gt;Task&lt;/code&gt; objects on the stack rather than the GC heap. The lifetime of a &lt;code&gt;Task&lt;/code&gt; created by &lt;code&gt;scopedTask&lt;/code&gt; cannot exceed the lifetime of the scope it was created in.</source>
          <target state="translated">Эти функции позволяют создавать объекты &lt;code&gt;Task&lt;/code&gt; в стеке, а не в куче GC. Срок действия &lt;code&gt;Task&lt;/code&gt; созданной &lt;code&gt;scopedTask&lt;/code&gt; , не может превышать срок действия области, в которой она была создана.</target>
        </trans-unit>
        <trans-unit id="4c3aa616b64e71a662b37e0ffc58b47e53c7d7a0" translate="yes" xml:space="preserve">
          <source>These functions are defined by</source>
          <target state="translated">Эти функции определяются</target>
        </trans-unit>
        <trans-unit id="64a3eca56341ef165f9199f2a7eb38f22c9f31d6" translate="yes" xml:space="preserve">
          <source>These functions are only available if &lt;code&gt;hasPeek!T&lt;/code&gt; is true.</source>
          <target state="translated">Эти функции доступны, только если &lt;code&gt;hasPeek!T&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="ca1095cd637088fb9ac4b341f976f96ce873e4a7" translate="yes" xml:space="preserve">
          <source>These functions are only supported on POSIX platforms, as the Windows operating systems do not provide the ability to overwrite the current process image with another. In single-threaded programs it is possible to approximate the effect of &lt;code&gt;execv*&lt;/code&gt; by using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and terminating the current process once the child process has returned. For example:</source>
          <target state="translated">Эти функции поддерживаются только на платформах POSIX, поскольку операционные системы Windows не позволяют перезаписать текущий образ процесса другим. В однопоточных программах можно аппроксимировать эффект &lt;code&gt;execv*&lt;/code&gt; , используя &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; и завершая текущий процесс после возвращения дочернего процесса. Например:</target>
        </trans-unit>
        <trans-unit id="536f51437dc16a03b75f3b412228393928fdac5c" translate="yes" xml:space="preserve">
          <source>These functions are recognized by the compiler, and calls to them are guaranteed to not be removed (as dead assignment elimination or presumed to have no effect) or reordered in the same thread.</source>
          <target state="translated">Эти функции распознаются компилятором,а вызовы к ним гарантированно не удаляются (как мертвое удаление присваивания или предполагаемое отсутствие эффекта)и не переупорядочиваются в том же потоке.</target>
        </trans-unit>
        <trans-unit id="1689bc1bc5afab34bd94fef9d049d296d24218eb" translate="yes" xml:space="preserve">
          <source>These functions find the first occurrence of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and then split &lt;code&gt;haystack&lt;/code&gt; as follows.</source>
          <target state="translated">Эти функции находят первое появление &lt;code&gt;needle&lt;/code&gt; в &lt;code&gt;haystack&lt;/code&gt; а затем разделяют &lt;code&gt;haystack&lt;/code&gt; следующим образом.</target>
        </trans-unit>
        <trans-unit id="4b1cfbf3893f882218472af28278eb2e9814bf0e" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Эти функции могут быть использованы для вычисления произвольных экстремумов, если выбрать подходящий &lt;code&gt;pred&lt;/code&gt; . Для corrrect функционирования, &lt;code&gt;pred&lt;/code&gt; должен быть строгим частичным порядком, т.е. транзитивно (если &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; , то &lt;code&gt;pred(a, c)&lt;/code&gt; ) и иррефлексивное ( &lt;code&gt;pred(a, a)&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e60755fe688a68024196bc269a7db2354557a4c9" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). The trichotomy property of inequality is not required: these algoritms consider elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal (for the purpose of counting) if &lt;code&gt;pred&lt;/code&gt; puts them in the same equivalence class, i.e. &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">Эти функции могут быть использованы для вычисления произвольных экстремумов, если выбрать подходящий &lt;code&gt;pred&lt;/code&gt; . Для corrrect функционирования, &lt;code&gt;pred&lt;/code&gt; должен быть строгим частичным порядком, т.е. транзитивно (если &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; , то &lt;code&gt;pred(a, c)&lt;/code&gt; ) и иррефлексивное ( &lt;code&gt;pred(a, a)&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; ). Свойство трихотомии неравенства не требуется: эти алгоритмы считают элементы &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; равными (для целей подсчета), если &lt;code&gt;pred&lt;/code&gt; помещает их в один и тот же класс эквивалентности, то есть &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="4885c55c8f009fc55e3ded5c636baed4e8b1027a" translate="yes" xml:space="preserve">
          <source>These functions must be defined for any D program linked against this library.</source>
          <target state="translated">Эти функции должны быть определены для любой D программы,связанной с этой библиотекой.</target>
        </trans-unit>
        <trans-unit id="863522dc2f55e2bd3557bec461908ee54bfe9148" translate="yes" xml:space="preserve">
          <source>These functions substitute for dynamic_cast. dynamic_cast does not work on earlier versions of gcc.</source>
          <target state="translated">Эти функции заменяют dynamic_cast.dynamic_cast не работает на более ранних версиях gcc.</target>
        </trans-unit>
        <trans-unit id="a6f52bdfe03bd9c3b6aa669ea2216cab6aa5652c" translate="yes" xml:space="preserve">
          <source>These functions will, when possible, do the load/store as a single operation. In general, this is possible when the size of the operation is less than or equal to &lt;code&gt;(void*).sizeof&lt;/code&gt;, although some targets may support larger operations. If the load/store cannot be done as a single operation, multiple smaller operations will be used.</source>
          <target state="translated">Эти функции по возможности выполняют загрузку / сохранение как одну операцию. В общем, это возможно, когда размер операции меньше или равен &lt;code&gt;(void*).sizeof&lt;/code&gt; , хотя некоторые цели могут поддерживать более крупные операции. Если загрузка / сохранение не может быть выполнена как одна операция, будут использоваться несколько меньших операций.</target>
        </trans-unit>
        <trans-unit id="aa2712a3447962365aa53a08ef19b228a050bafc" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to provide virtual function-based wrappers around input ranges with element type E. This is useful where a well-defined binary interface is required, such as when a DLL function or virtual function needs to accept a generic range as a parameter. Note that &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt; and friends check for conformance to structural interfaces not for implementation of these &lt;code&gt;interface&lt;/code&gt; types.</source>
          <target state="translated">Эти интерфейсы предназначены для предоставления виртуальных функций-оберток вокруг входных диапазонов с типом элемента E. Это полезно, когда требуется четко определенный двоичный интерфейс, например, когда функция DLL или виртуальная функция должна принять общий диапазон в качестве параметра , Обратите внимание, что &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt; и friends проверяют соответствие структурным интерфейсам, а не реализацию этих типов &lt;code&gt;interface&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7b0ea076cc1a10005c1bfd351e1967a3ff3876c" translate="yes" xml:space="preserve">
          <source>These interfaces are not capable of forwarding &lt;code&gt;ref&lt;/code&gt; access to elements.</source>
          <target state="translated">Эти интерфейсы не способны передавать &lt;code&gt;ref&lt;/code&gt; - доступ к элементам.</target>
        </trans-unit>
        <trans-unit id="8fa26313291d5018e0a3e59f0f8f336286abcb0a" translate="yes" xml:space="preserve">
          <source>These issues also apply to appending arrays with the ~= operator. Concatenation using the ~ operator is not affected since it always reallocates.</source>
          <target state="translated">Эти проблемы также применимы к добавляемым массивам с оператором ~=.Сосредоточение с помощью оператора ~ не затрагивается,так как он всегда перераспределяется.</target>
        </trans-unit>
        <trans-unit id="b9ff0eb99086639c464f06ffda166431e591559b" translate="yes" xml:space="preserve">
          <source>These members are populated when one of the following functions are called successfully:</source>
          <target state="translated">Эти члены заполняются при успешном вызове одной из следующих функций:</target>
        </trans-unit>
        <trans-unit id="e69f6a6ea64238818e57857e50d3b4e6fac28582" translate="yes" xml:space="preserve">
          <source>These methods return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Эти методы возвращают &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2f532d1b48edcd9143f50919e4b67ad8068e5c5" translate="yes" xml:space="preserve">
          <source>These policies may be used alone, e.g. &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; defines a &lt;code&gt;uint&lt;/code&gt;-like type that reaches a stable NaN state for all erroneous operations. They may also be &quot;stacked&quot; on top of each other, owing to the property that a checked integral emulates an actual integral, which means another checked integral can be built on top of it. Some combinations of interest include:</source>
          <target state="translated">Эти политики могут использоваться отдельно, например, &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; определяет тип , похожий на &lt;code&gt;uint&lt;/code&gt; , который достигает стабильного состояния NaN для всех ошибочных операций. Они также могут быть &amp;laquo;сложены&amp;raquo; друг на друга, благодаря свойству, что проверенный интеграл эмулирует фактический интеграл, что означает, что поверх него может быть построен другой проверенный интеграл. Некоторые комбинации интересов включают в себя:</target>
        </trans-unit>
        <trans-unit id="7368ecff3f3d439be72be4fcfde0947c1e9f8e58" translate="yes" xml:space="preserve">
          <source>These prefix instructions do not appear in the same statement as the instructions they prefix; they appear in their own statement. For example:</source>
          <target state="translated">Эти инструкции с префиксом не появляются в том же самом утверждении,что и инструкции с префиксом;они появляются в их собственном утверждении.Например:</target>
        </trans-unit>
        <trans-unit id="9636b646d702390220bc4fa38bc7bba209069d1d" translate="yes" xml:space="preserve">
          <source>These properties can be used to set and get this &lt;code&gt;Logger&lt;/code&gt;. Every modification to this &lt;code&gt;Logger&lt;/code&gt; will only be visible in the thread the modification has been done from.</source>
          <target state="translated">Эти свойства могут быть использованы для установки и получения этого &lt;code&gt;Logger&lt;/code&gt; . Каждая модификация этого &lt;code&gt;Logger&lt;/code&gt; будет видна только в потоке, из которого была сделана модификация.</target>
        </trans-unit>
        <trans-unit id="d0c185c1fb708b1056aa4da779b1949039005b7f" translate="yes" xml:space="preserve">
          <source>These properties control whether the worker threads are daemon threads. A daemon thread is automatically terminated when all non-daemon threads have terminated. A non-daemon thread will prevent a program from terminating as long as it has not terminated.</source>
          <target state="translated">Эти свойства контролируют,являются ли рабочие потоки демоническими.Поток демона автоматически завершается,когда все недемон-потоки завершаются.Поток,не являющийся демоническим,не позволит программе завершить свою работу до тех пор,пока она не будет завершена.</target>
        </trans-unit>
        <trans-unit id="15376758dabe755dcb87d082399d9c18e9269e9e" translate="yes" xml:space="preserve">
          <source>These properties get and set the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by &lt;code&gt;taskPool&lt;/code&gt;. The default value is &lt;code&gt;totalCPUs&lt;/code&gt; - 1. Calling the setter after the first call to &lt;code&gt;taskPool&lt;/code&gt; does not changes number of worker threads in the instance returned by &lt;code&gt;taskPool&lt;/code&gt;.</source>
          <target state="translated">Эти свойства получают и устанавливают количество рабочих потоков в экземпляре &lt;code&gt;TaskPool&lt;/code&gt; , возвращаемое &lt;code&gt;taskPool&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;totalCPUs&lt;/code&gt; - 1. Вызов установщика после первого вызова &lt;code&gt;taskPool&lt;/code&gt; не меняет количество рабочих потоков в экземпляре, возвращаемом &lt;code&gt;taskPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="980ecd42d3382da4165c5745d3e514950a686c39" translate="yes" xml:space="preserve">
          <source>These pseudo ops are for inserting raw data directly into the code. &lt;code&gt;db&lt;/code&gt; is for bytes, &lt;code&gt;ds&lt;/code&gt; is for 16 bit words, &lt;code&gt;di&lt;/code&gt; is for 32 bit words, &lt;code&gt;dl&lt;/code&gt; is for 64 bit words, &lt;code&gt;df&lt;/code&gt; is for 32 bit floats, &lt;code&gt;dd&lt;/code&gt; is for 64 bit doubles, and &lt;code&gt;de&lt;/code&gt; is for 80 bit extended reals. Each can have multiple operands. If an operand is a string literal, it is as if there were</source>
          <target state="translated">Эти псевдооперации предназначены для вставки необработанных данных непосредственно в код. &lt;code&gt;db&lt;/code&gt; - для байтов, &lt;code&gt;ds&lt;/code&gt; - для 16-битных слов, &lt;code&gt;di&lt;/code&gt; - для 32-битных слов, &lt;code&gt;dl&lt;/code&gt; - для 64-битных слов, &lt;code&gt;df&lt;/code&gt; - для 32-битных чисел с плавающей запятой, &lt;code&gt;dd&lt;/code&gt; - для 64-битных двойных, а &lt;code&gt;de&lt;/code&gt; - для 80-битных расширенных чисел. Каждый может иметь несколько операндов. Если операнд является строковым литералом, это как если бы</target>
        </trans-unit>
        <trans-unit id="dc738e7762e036039780916cbdd5404d3269d8a0" translate="yes" xml:space="preserve">
          <source>These reordering guarantees are only made with regards to other operations done through these functions; the compiler is free to reorder regular loads/stores with regards to loads/stores done through these functions.</source>
          <target state="translated">Эти гарантии переупорядочивания выполняются только в отношении других операций,выполняемых с помощью этих функций;компилятор может переупорядочивать регулярные загрузки/сохранения в отношении загрузок/сохранений,выполняемых с помощью этих функций.</target>
        </trans-unit>
        <trans-unit id="59c337390b522d2f745f8ff19e4af335466b8d80" translate="yes" xml:space="preserve">
          <source>These rules exist to ensure that D source code can be tokenized independently of syntactic or semantic analysis.</source>
          <target state="translated">Эти правила существуют для того,чтобы гарантировать,что исходный код в формате D может быть токенирован независимо от синтаксического или семантического анализа.</target>
        </trans-unit>
        <trans-unit id="0c76e41e867d53b374fa782852a104df9aca82b4" translate="yes" xml:space="preserve">
          <source>These tokens are replaced with other tokens according to the following table:</source>
          <target state="translated">Эти маркеры заменяются другими маркерами в соответствии со следующей таблицей:</target>
        </trans-unit>
        <trans-unit id="d0bdde0a231ee1346d31198eca44ed30c45d180a" translate="yes" xml:space="preserve">
          <source>These two functions are publicly imported by &lt;a href=&quot;std_string&quot;&gt;&lt;code&gt;std.string&lt;/code&gt;&lt;/a&gt; to be easily available.</source>
          <target state="translated">Эти две функции публично импортируются &lt;a href=&quot;std_string&quot;&gt; &lt;code&gt;std.string&lt;/code&gt; ,&lt;/a&gt; чтобы быть легко доступными.</target>
        </trans-unit>
        <trans-unit id="d116b35a1d1eb38f8d6deaebff517f7281edce29" translate="yes" xml:space="preserve">
          <source>These two methods set and get the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Эти два метода устанавливают и получают &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31bee48bf9882a765ab31f12d60d8852693f17b" translate="yes" xml:space="preserve">
          <source>These two were added to Bionic in Lollipop.</source>
          <target state="translated">Эти двое были добавлены в Бионик в Леденце.</target>
        </trans-unit>
        <trans-unit id="51b1a7127ec2cda2b11c1f4d950a66756e0a424a" translate="yes" xml:space="preserve">
          <source>These types and operations will be the ones defined for the architecture the compiler is targeting. If a particular CPU family has varying support for vector types, an additional runtime check may be necessary. The compiler does not emit runtime checks; those must be done by the programmer.</source>
          <target state="translated">Эти типы и операции будут теми,которые будут определены для архитектуры,на которую нацелен компилятор.Если определенное семейство процессоров имеет различную поддержку векторных типов,может потребоваться дополнительная проверка времени исполнения.Компилятор не излучает проверки времени исполнения,они должны выполняться программистом.</target>
        </trans-unit>
        <trans-unit id="6f060e83954cb7bb657a24fc206a36f49a7d93ba" translate="yes" xml:space="preserve">
          <source>These variadic functions have a special local variable declared for them, &lt;code&gt;_argptr&lt;/code&gt;, which is a &lt;code&gt;core.vararg&lt;/code&gt; reference to the first of the variadic arguments. To access the arguments, &lt;code&gt;_argptr&lt;/code&gt; must be used in conjuction with &lt;code&gt;va_arg&lt;/code&gt;:</source>
          <target state="translated">Для этих функций с переменными значениями объявлена ​​специальная локальная переменная &lt;code&gt;_argptr&lt;/code&gt; , которая является ссылкой &lt;code&gt;core.vararg&lt;/code&gt; на первый из параметров переменной. Для доступа к аргументам необходимо использовать &lt;code&gt;_argptr&lt;/code&gt; вместе с &lt;code&gt;va_arg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="234027e68858253217a4940ca8276de49e1921e6" translate="yes" xml:space="preserve">
          <source>They cannot be accessed directly, but can be when converted to an array type:</source>
          <target state="translated">Прямой доступ к ним невозможен,но может быть получен при преобразовании в тип массива:</target>
        </trans-unit>
        <trans-unit id="221e10b06207df21853c30ac081dc011d76ee4a6" translate="yes" xml:space="preserve">
          <source>Things that are reliable and can be done:</source>
          <target state="translated">Вещи,которые надежны и могут быть сделаны:</target>
        </trans-unit>
        <trans-unit id="3c0e4517dcdbca852a34fee2578fdfec0c6193f9" translate="yes" xml:space="preserve">
          <source>This 6-digit (24 bits) hexadecimal number does not show pre-release number, and it is always a greater number in a more recent release. It makes comparisons with greater than and less than work.</source>
          <target state="translated">Это 6-значное (24-битное)шестнадцатеричное число не показывает номер пре-релиза,и в более позднем релизе оно всегда больше.Оно делает сравнения с большим и меньшим,чем работа.</target>
        </trans-unit>
        <trans-unit id="229cd848f340b1059ab841306649066eb2235f02" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt;&lt;code&gt;NSLog&lt;/code&gt;&lt;/a&gt; function prints a message to the System Log facility, i.e. to stderr and Console.</source>
          <target state="translated">Эта функция &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt; &lt;code&gt;NSLog&lt;/code&gt; &lt;/a&gt; выводит сообщение в системный журнал, т. Е. В stderr и консоль.</target>
        </trans-unit>
        <trans-unit id="d3784623518bf5135672133e5b2128ce4da1e03a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; implementation writes log messages to the associated file. The name of the file has to be passed on construction time. If the file is already present new log messages will be append at its end.</source>
          <target state="translated">Эта реализация &lt;code&gt;Logger&lt;/code&gt; записывает сообщения журнала в связанный файл. Имя файла должно быть передано во время строительства. Если файл уже присутствует, новые сообщения журнала будут добавлены в его конец.</target>
        </trans-unit>
        <trans-unit id="713e6c7267281da115b32a479fb632b10a4676bf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; is called by the free standing log functions. This allows to create thread local redirections and still use the free standing log functions.</source>
          <target state="translated">Этот &lt;code&gt;Logger&lt;/code&gt; вызывается автономными функциями журнала. Это позволяет создавать локальные перенаправления потоков и по-прежнему использовать автономные функции журнала.</target>
        </trans-unit>
        <trans-unit id="e1905487aa2f3222c1f92ca85d42ee6ef82cec0b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;delegate&lt;/code&gt; is called in case a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; gets logged.</source>
          <target state="translated">Этот &lt;code&gt;delegate&lt;/code&gt; вызывается в случае, если сообщение журнала с &lt;code&gt;LogLevel.fatal&lt;/code&gt; будет зарегистрировано.</target>
        </trans-unit>
        <trans-unit id="742a25561151a973ba133d1f0c2d43dea4909a81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as a template argument to functions which compare file names, and determines whether the comparison is case sensitive or not.</source>
          <target state="translated">Это &lt;code&gt;enum&lt;/code&gt; используется в качестве аргумента шаблона для функций, которые сравнивают имена файлов, и определяет, является ли сравнение чувствительным к регистру.</target>
        </trans-unit>
        <trans-unit id="5b6a1b7ec8e15b4671a0723320a6b157081a9b40" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used to select the primitives of the range to handle by the &lt;a href=&quot;#handle&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/a&gt; range wrapper. The values of the &lt;code&gt;enum&lt;/code&gt; can be &lt;code&gt;OR&lt;/code&gt;'d to select multiple primitives to be handled.</source>
          <target state="translated">Это &lt;code&gt;enum&lt;/code&gt; используется для выбора примитивов диапазона для обработки оболочкой диапазона &lt;a href=&quot;#handle&quot;&gt; &lt;code&gt;handle&lt;/code&gt; &lt;/a&gt; . Значения &lt;code&gt;enum&lt;/code&gt; могут быть &lt;code&gt;OR&lt;/code&gt; 'd, чтобы выбрать несколько примитивов для обработки.</target>
        </trans-unit>
        <trans-unit id="60302f8f7437eabfe1118a9f0d4373fe741b982e" translate="yes" xml:space="preserve">
          <source>This &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, U)(U rhs)</source>
          <target state="translated">Это &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (строка op, U) (U rhs)</target>
        </trans-unit>
        <trans-unit id="0844f4e216523548601b41cd5d7151c085ad2d4f" translate="yes" xml:space="preserve">
          <source>This Element is stored inside the &lt;code&gt;MultiLogger&lt;/code&gt; and associates a &lt;code&gt;Logger&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Этот элемент хранится внутри &lt;code&gt;MultiLogger&lt;/code&gt; и связывает &lt;code&gt;Logger&lt;/code&gt; со &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f3ba7f1176ff2dafbb0e0f64e80accd29320699" translate="yes" xml:space="preserve">
          <source>This Exception is thrown if something goes wrong when encoding or decoding a URI.</source>
          <target state="translated">Это исключение выбрасывается,если что-то пойдет не так при кодировании или декодировании URI.</target>
        </trans-unit>
        <trans-unit id="7f52bee84df158d351adbe607d7ed92c29a830ca" translate="yes" xml:space="preserve">
          <source>This access can span multiple nesting levels:</source>
          <target state="translated">Этот доступ может охватывать несколько уровней гнездования:</target>
        </trans-unit>
        <trans-unit id="6b73948545ca0a17466100c56872304c05fd8262" translate="yes" xml:space="preserve">
          <source>This advice applies only to static references or references embedded inside other objects. There is not much point for such stored on the stack to be nulled because new stack frames are initialized anyway.</source>
          <target state="translated">Эта рекомендация относится только к статическим ссылкам или ссылкам,встроенным в другие объекты.Нет особого смысла обнулять такие хранимые в стеке,так как новые кадры стека все равно инициализируются.</target>
        </trans-unit>
        <trans-unit id="b180cae02977110add927a1c4e0c64f40292d64f" translate="yes" xml:space="preserve">
          <source>This algorithm is lazy, doing work progressively as elements are pulled off the result.  Time complexity is proportional to the sum of element counts over all inputs.  If all inputs have the same element type and offer it by &lt;code&gt;ref&lt;/code&gt;, output becomes a range with mutable &lt;code&gt;front&lt;/code&gt; (and &lt;code&gt;back&lt;/code&gt; where appropriate) that reflects in the original inputs.  If any of the inputs &lt;code&gt;rs&lt;/code&gt; is infinite so is the result (&lt;code&gt;empty&lt;/code&gt; being always &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Этот алгоритм ленив, прогрессивно работает, когда элементы извлекаются из результата. Сложность по времени пропорциональна сумме подсчетов элементов по всем входам. Если все входы имеют одинаковый тип элемента и предлагают его как &lt;code&gt;ref&lt;/code&gt; , выходной сигнал становится диапазоном с изменяемой &lt;code&gt;front&lt;/code&gt; частью (и &lt;code&gt;back&lt;/code&gt; где это необходимо), которая отражается в исходных входных данных. Если какой-либо из входных данных &lt;code&gt;rs&lt;/code&gt; бесконечен, таков и результат ( &lt;code&gt;empty&lt;/code&gt; всегда &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="17ac7dad87e44aee326cfad5b437dc8fb209353e" translate="yes" xml:space="preserve">
          <source>This allocator sits on top of &lt;code&gt;ParentAllocator&lt;/code&gt; and quantizes allocation sizes, usually from arbitrary positive numbers to a small set of round numbers (e.g. powers of two, page sizes etc). This technique is commonly used to:</source>
          <target state="translated">Этот распределитель расположен поверх &lt;code&gt;ParentAllocator&lt;/code&gt; и квантует размеры выделения, обычно от произвольных положительных чисел до небольшого набора круглых чисел (например, степеней двойки, размеров страниц и т. Д.). Этот метод обычно используется для:</target>
        </trans-unit>
        <trans-unit id="c92308ef13d80d3dc1f8f963c2ddd3981e8c6bde" translate="yes" xml:space="preserve">
          <source>This allows you to construct a &lt;code&gt;TickDuration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">Это позволяет вам построить &lt;code&gt;TickDuration&lt;/code&gt; из заданных единиц времени с заданной длиной.</target>
        </trans-unit>
        <trans-unit id="75add17a5265c1c86eea3c10773eb85a2a082611" translate="yes" xml:space="preserve">
          <source>This also checks if T passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Это также проверяет, проходит ли T &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21d1b39871e7f1893df45ac1736d0defe8bdb68b" translate="yes" xml:space="preserve">
          <source>This approach to sorting is akin to the &lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform&lt;/a&gt;, also known as the decorate-sort-undecorate pattern in Python and Lisp. The complexity is the same as that of the corresponding &lt;code&gt;sort&lt;/code&gt;, but &lt;code&gt;schwartzSort&lt;/code&gt; evaluates &lt;code&gt;transform&lt;/code&gt; only &lt;code&gt;r.length&lt;/code&gt; times (less than half when compared to regular sorting). The usage can be best illustrated with an example.</source>
          <target state="translated">Этот подход к сортировке похож на &lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;преобразование Шварца&lt;/a&gt; , также известный как шаблон decorate-sort-undecorate в Python и Lisp. Сложность такая же, как и у соответствующего &lt;code&gt;sort&lt;/code&gt; , но &lt;code&gt;schwartzSort&lt;/code&gt; оценивает &lt;code&gt;transform&lt;/code&gt; только на &lt;code&gt;r.length&lt;/code&gt; раз (меньше половины по сравнению с обычной сортировкой). Использование может быть лучше всего проиллюстрировано на примере.</target>
        </trans-unit>
        <trans-unit id="5d88f963aa92f920cdc8aeb7a00bc154db20bbb5" translate="yes" xml:space="preserve">
          <source>This array can be used by a precise GC to avoid false pointers.</source>
          <target state="translated">Этот массив может быть использован точным GC,чтобы избежать ложных указателей.</target>
        </trans-unit>
        <trans-unit id="c35154b2193fa21859ceac41f1d4b9a67330be66" translate="yes" xml:space="preserve">
          <source>This attack can also be mitigated via rate limiting and banning IPs which have too many rejected requests. However, this does not completely solve the problem, as the attacker could be in control of a bot net. To fully defend against the timing attack, rate limiting, banning IPs, and using this function should be used together.</source>
          <target state="translated">Эту атаку также можно смягчить с помощью ограничения скорости и запрета IP-адресов,у которых слишком много отклоненных запросов.Однако,это не решает проблему полностью,так как атакующий может контролировать бот-сеть.Для полной защиты от временных атак,следует использовать функции ограничения скорости,запрета IP-адресов,а также использовать эту функцию совместно.</target>
        </trans-unit>
        <trans-unit id="0a9127e0dd3d0b5214532b99c1123e71d947a773" translate="yes" xml:space="preserve">
          <source>This binary operator returns a narrower, built-in integer type where applicable, according to the following table.</source>
          <target state="translated">Этот двоичный оператор возвращает более узкий,встроенный целочисленный тип,где это применимо,согласно следующей таблице.</target>
        </trans-unit>
        <trans-unit id="37d90ec49bcad1514fffff07ef5725f0a4ce3b52" translate="yes" xml:space="preserve">
          <source>This block contains the info to allow appending.</source>
          <target state="translated">Этот блок содержит информацию,позволяющую добавлять.</target>
        </trans-unit>
        <trans-unit id="bf616d2c8bb18a1f79e9b94bb01fac01a9f85e97" translate="yes" xml:space="preserve">
          <source>This block is guaranteed to have a pointer to its base while it is alive. Interior pointers can be safely ignored. This attribute is useful for eliminating false pointers in very large data structures and is only implemented for data structures at least a page in size.</source>
          <target state="translated">В этом блоке гарантированно есть указатель на его основание,пока он жив.Внутренние указатели можно безопасно игнорировать.Данный атрибут полезен для устранения ложных указателей в очень больших структурах данных и реализован только для структур данных размером не менее страницы.</target>
        </trans-unit>
        <trans-unit id="bf3bcec7830ceded3b9368b09e74254cb38823f2" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. It's highly platform dependent.</source>
          <target state="translated">Это разбивает тип на &quot;более простые&quot; типы,которые могут быть переданы функции в регистрах,и возвращены в регистрах.Это сильно зависит от платформы.</target>
        </trans-unit>
        <trans-unit id="c8f37b58b4d0486e147bae447382fe4c40e89ace" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. This is the implementation for the x86_64 System V ABI (not used for Win64), based on &lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf.&lt;/a&gt;</source>
          <target state="translated">Это разбивает тип на &amp;laquo;более простые&amp;raquo; типы, которые могут быть переданы функции в регистрах и возвращены в регистрах. Это реализация для x86_64 System V ABI (не используется для Win64), основанная на &lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0bd70fd848ca13dea85fa0c9ed45a1bd7458ccab" translate="yes" xml:space="preserve">
          <source>This can be a useful function to place in a chain, after functions that have expensive evaluation, as a lazy alternative to &lt;a href=&quot;std_array#array&quot;&gt;&lt;code&gt;std.array.array&lt;/code&gt;&lt;/a&gt;. In particular, it can be placed after a call to &lt;a href=&quot;#map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, or before a call &lt;a href=&quot;std_range#filter&quot;&gt;&lt;code&gt;std.range.filter&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range#tee&quot;&gt;&lt;code&gt;std.range.tee&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Это может быть полезной функцией для размещения в цепочке после функций с дорогой оценкой, как ленивая альтернатива &lt;a href=&quot;std_array#array&quot;&gt; &lt;code&gt;std.array.array&lt;/code&gt; &lt;/a&gt; . В частности, его можно разместить после вызова &lt;a href=&quot;#map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; или перед вызовом &lt;a href=&quot;std_range#filter&quot;&gt; &lt;code&gt;std.range.filter&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;std_range#tee&quot;&gt; &lt;code&gt;std.range.tee&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b2e989aa67544fd1198815cd532b63a0f766b8f" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = File.readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">Это может быть быстрее, чем &lt;code&gt;line = File.readln()&lt;/code&gt; потому что вы можете повторно использовать буфер для каждого вызова. Обратите внимание, что повторное использование буфера означает, что вы должны скопировать предыдущее содержимое, если хотите сохранить его.</target>
        </trans-unit>
        <trans-unit id="9135461de3ded4b1c69a8c8663d6dc1b7b1298f3" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">Это может быть быстрее, чем &lt;code&gt;line = readln()&lt;/code&gt; потому что вы можете повторно использовать буфер для каждого вызова. Обратите внимание, что повторное использование буфера означает, что вы должны скопировать предыдущее содержимое, если хотите сохранить его.</target>
        </trans-unit>
        <trans-unit id="a112b2327f090d0fc1bf3af12645c6807ea32f38" translate="yes" xml:space="preserve">
          <source>This can be used to manually allocate arrays. Initial slice size is 0.</source>
          <target state="translated">Это может быть использовано для ручного выделения массивов.Начальный размер среза-0.</target>
        </trans-unit>
        <trans-unit id="77b164cf465602d02b3ffc40b53faf3928b97c45" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;_init&lt;/code&gt; to its original state.</source>
          <target state="translated">Это можно использовать для восстановления состояния, установленного &lt;code&gt;_init&lt;/code&gt; , в исходное состояние.</target>
        </trans-unit>
        <trans-unit id="fd9b6c28efb844ef78e5e1874ec7103f9aedb900" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;builtin_init&lt;/code&gt; to its original state.</source>
          <target state="translated">Это можно использовать для восстановления состояния, установленного &lt;code&gt;builtin_init&lt;/code&gt; в исходное состояние.</target>
        </trans-unit>
        <trans-unit id="bf855a97cfb23a3029962fde96c07063d751f784" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initDMD&lt;/code&gt; to its original state. Useful if there's a need for multiple sessions of the DMD compiler in the same application.</source>
          <target state="translated">Это можно использовать для восстановления состояния, установленного &lt;code&gt;initDMD&lt;/code&gt; , в исходное состояние. Полезно, если в одном приложении требуется несколько сеансов компилятора DMD.</target>
        </trans-unit>
        <trans-unit id="8b9d5f27029fa9824ee5b1d78b90c2ec7ef5fd1e" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initialize&lt;/code&gt; to its original state.</source>
          <target state="translated">Это может быть использовано для восстановления состояния, установленного путем &lt;code&gt;initialize&lt;/code&gt; в исходное состояние.</target>
        </trans-unit>
        <trans-unit id="ab6e2c03932762345b65936a6392947f9f7fc40e" translate="yes" xml:space="preserve">
          <source>This causes the array to be reallocated in place, and the existing contents copied over to the new array. If the new array length is shorter, the array is not reallocated, and no data is copied. It is equivalent to slicing the array:</source>
          <target state="translated">Это приводит к переопределению массива и копированию существующего содержимого в новый массив.Если новая длина массива меньше,то массив не перераспределяется,и данные не копируются.Это эквивалентно перерезанию массива:</target>
        </trans-unit>
        <trans-unit id="2dc8c51a26f6ef694173726a55aa90d7d6530cc8" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a read lock for the enclosing mutex.</source>
          <target state="translated">Этот класс может рассматриваться как мьютекс сам по себе,и используется для согласования блокировки чтения для вложенного мьютекса.</target>
        </trans-unit>
        <trans-unit id="c087ce5411ffc17188818ec319892aeaf2de87df" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a write lock for the enclosing mutex.</source>
          <target state="translated">Этот класс может рассматриваться как мьютекс сам по себе,и используется для согласования блокировки записи для вложенного мьютекса.</target>
        </trans-unit>
        <trans-unit id="e6fa3f3a70f061e4c741e7043e9f128e38434b5c" translate="yes" xml:space="preserve">
          <source>This class contains only static methods, and cannot be instantiated. See below for examples of use.</source>
          <target state="translated">Данный класс содержит только статические методы и не может быть инстанцирован.Примеры использования см.ниже.</target>
        </trans-unit>
        <trans-unit id="e74dd67572321fcf836dd082da1156043102db48" translate="yes" xml:space="preserve">
          <source>This class encapsulates a task queue and a set of worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that executes the &lt;code&gt;Task&lt;/code&gt; at the front of the queue when one is available and sleeps when the queue is empty.</source>
          <target state="translated">Этот класс инкапсулирует очередь задач и набор рабочих потоков. Его цель - эффективно отобразить большое количество &lt;code&gt;Task&lt;/code&gt; на меньшее количество потоков. Очередь задач - это очередь FIFO объектов &lt;code&gt;Task&lt;/code&gt; , которые были отправлены в &lt;code&gt;TaskPool&lt;/code&gt; и ожидают выполнения. Рабочий поток - это поток, который выполняет Задачу в &lt;code&gt;Task&lt;/code&gt; очереди, когда она доступна, и бездействует, когда очередь пуста.</target>
        </trans-unit>
        <trans-unit id="cb7ed7def5fa337d461b92cc10d68f83905440de" translate="yes" xml:space="preserve">
          <source>This class encapsulates all threading functionality for the D programming language. As thread manipulation is a required facility for garbage collection, all user threads should derive from this class, and instances of this class should never be explicitly deleted. A new thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">Этот класс инкапсулирует всю функциональность потоков для языка программирования D.Так как манипулирование потоками является необходимым средством для сбора мусора,все пользовательские потоки должны быть извлечены из этого класса,и экземпляры этого класса никогда не должны быть явно удалены.Новый поток может быть создан с использованием как производной,так и композиции,как в следующем примере.</target>
        </trans-unit>
        <trans-unit id="060824159317cc2ae0b94150653daf83c3c520fb" translate="yes" xml:space="preserve">
          <source>This class is Windows-Only.</source>
          <target state="translated">Этот класс-&quot;Только для окон&quot;.</target>
        </trans-unit>
        <trans-unit id="74950bb501f7c21fc01a4eeb41b151e182fd4b25" translate="yes" xml:space="preserve">
          <source>This class is intended to simplify certain common programming techniques.</source>
          <target state="translated">Данный класс предназначен для упрощения некоторых распространенных техник программирования.</target>
        </trans-unit>
        <trans-unit id="23197b76b4ee940fb447d39ecd365edbbb4617e7" translate="yes" xml:space="preserve">
          <source>This class is the base of every logger. In order to create a new kind of logger a deriving class needs to implement the &lt;code&gt;writeLogMsg&lt;/code&gt; method. By default this is not thread-safe.</source>
          <target state="translated">Этот класс является основой каждого регистратора. Чтобы создать новый тип регистратора, производный класс должен реализовать метод &lt;code&gt;writeLogMsg&lt;/code&gt; . По умолчанию это не потокобезопасно.</target>
        </trans-unit>
        <trans-unit id="5087e482a877ae3c12085be27794a8883c7a901f" translate="yes" xml:space="preserve">
          <source>This class provides a cooperative concurrency mechanism integrated with the threading and garbage collection functionality. Calling a fiber may be considered a blocking operation that returns when the fiber yields (via Fiber.yield()). Execution occurs within the context of the calling thread so synchronization is not necessary to guarantee memory visibility so long as the same thread calls the fiber each time. Please note that there is no requirement that a fiber be bound to one specific thread. Rather, fibers may be freely passed between threads so long as they are not currently executing. Like threads, a new fiber thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">Этот класс обеспечивает кооперативный механизм параллелизма,интегрированный с функциями потоковой обработки и сбора мусора.Вызов волокна может рассматриваться как операция блокировки,которая возвращается,когда волокно выходит (через Fiber.yield()).Выполнение происходит в контексте вызывающего потока,поэтому синхронизация не требуется,чтобы гарантировать видимость памяти до тех пор,пока один и тот же поток каждый раз вызывает волокно.Обратите внимание,что не требуется привязывать волокно к одному конкретному потоку.Скорее,волокна могут свободно передаваться между потоками,если они в данный момент не выполняются.Как и в случае с нитями,новое волокно может быть создано с использованием либо производного,либо композиционного состава,как в следующем примере.</target>
        </trans-unit>
        <trans-unit id="82a75ec7718c8b6f47e4366c93dbe98cf77e29de" translate="yes" xml:space="preserve">
          <source>This class represents a barrier across which threads may only travel in groups of a specific size.</source>
          <target state="translated">Этот класс представляет собой барьер,через который потоки могут путешествовать только в группах определенного размера.</target>
        </trans-unit>
        <trans-unit id="766ad20f64361ee3b240dfaf608ee851aeb433ae" translate="yes" xml:space="preserve">
          <source>This class represents a condition variable as conceived by C.A.R. Hoare. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">Этот класс представляет собой условную переменную,как ее задумал К.А.Р.Хоар.Однако,согласно мониторам типа Mesa,&quot;сигнал&quot; был заменен на &quot;уведомление&quot;,чтобы показать,что управление не передается официанту при отправке уведомления.</target>
        </trans-unit>
        <trans-unit id="4ebd970226df03dbe75e13571a9e96c6ff81d3f8" translate="yes" xml:space="preserve">
          <source>This class represents a general counting semaphore as concieved by Edsger Dijkstra. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">Этот класс представляет собой общий счетный семафор,как считает Эдсгер Дийкстра.Однако,согласно мониторам типа Mesa,&quot;сигнал&quot; был заменен на &quot;уведомление&quot;,чтобы показать,что управление не передается официанту при отправке уведомления.</target>
        </trans-unit>
        <trans-unit id="c8cd845734952865e5a8f06563815740028af34a" translate="yes" xml:space="preserve">
          <source>This class represents a general purpose, recursive mutex.</source>
          <target state="translated">Этот класс представляет собой рекурсивный мьютекс общего назначения.</target>
        </trans-unit>
        <trans-unit id="59a28f2816234c02947ecfa7c34d28fcd7aff787" translate="yes" xml:space="preserve">
          <source>This class represents a mutex that allows any number of readers to enter, but when a writer enters, all other readers and writers are blocked.</source>
          <target state="translated">Этот класс представляет собой мьютекс,который позволяет любому количеству читателей войти,но когда записывающее устройство входит,все остальные читатели и записывающее устройство блокируются.</target>
        </trans-unit>
        <trans-unit id="869079d3acf8bad41ab545f5cd5b6ff38c3d966c" translate="yes" xml:space="preserve">
          <source>This class should usually be used via the global instantiation available via the &lt;a href=&quot;std_parallelism#taskPool&quot;&gt;&lt;code&gt;std.parallelism.taskPool&lt;/code&gt;&lt;/a&gt; property. Occasionally it is useful to explicitly instantiate a &lt;code&gt;TaskPool&lt;/code&gt;:</source>
          <target state="translated">Этот класс обычно следует использовать через глобальную реализацию, доступную через свойство &lt;a href=&quot;std_parallelism#taskPool&quot;&gt; &lt;code&gt;std.parallelism.taskPool&lt;/code&gt; &lt;/a&gt; . Иногда полезно явно создать экземпляр &lt;code&gt;TaskPool&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67a778401b8293f4ab050d1d10ec2027dc2c3143" translate="yes" xml:space="preserve">
          <source>This class uses a high-performance counter. On Windows systems, it uses &lt;code&gt;QueryPerformanceCounter&lt;/code&gt;, and on Posix systems, it uses &lt;code&gt;clock_gettime&lt;/code&gt; if available, and &lt;code&gt;gettimeofday&lt;/code&gt; otherwise.</source>
          <target state="translated">Этот класс использует высокопроизводительный счетчик. В системах Windows он использует &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; , а в системах Posix он использует &lt;code&gt;clock_gettime&lt;/code&gt; , если доступно, и &lt;code&gt;gettimeofday&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="aaa98a68eef2ad7cd1dc56f0e12cad2e4ff0ed1d" translate="yes" xml:space="preserve">
          <source>This code handles backtrace generation using DWARF debug_line section in ELF and Mach-O files for Posix.</source>
          <target state="translated">Данный код обрабатывает генерацию бэктрейсов с использованием секции DWARF debug_line в ELF и Mach-O файлах для Posix.</target>
        </trans-unit>
        <trans-unit id="6140309682aaa69b6ff498f8a25796d0edfd215e" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">Этот код обрабатывает декодирование UTF-строк для форач-цикликов.Существует 6 комбинаций преобразования между char,wchar и dchar,и по 2 из них.</target>
        </trans-unit>
        <trans-unit id="982470496432064145436b3b7c81c481f591fd15" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach_reverse loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">Данный код обрабатывает декодирование UTF-строк для foreach_reverse циклов.Существует 6 комбинаций преобразования между char,wchar и dchar,и по 2 из них.</target>
        </trans-unit>
        <trans-unit id="e76eacdedc4fa73ee336ac22c18ef834f35805af" translate="yes" xml:space="preserve">
          <source>This code reads ELF files and sections using memory mapped IO.</source>
          <target state="translated">Этот код читает ELF-файлы и секции,используя отображенный в памяти IO.</target>
        </trans-unit>
        <trans-unit id="db89b4b4bb5b2f93ea6d6ff02b4131b5059932ab" translate="yes" xml:space="preserve">
          <source>This combining of the environment and the function is called a</source>
          <target state="translated">Это сочетание среды и функции называется</target>
        </trans-unit>
        <trans-unit id="f04a03c616b5e70e398965fd9e6bb2d3b0919b13" translate="yes" xml:space="preserve">
          <source>This command-line parameter does not affect custom unit test handlers.</source>
          <target state="translated">Этот параметр командной строки не влияет на работу пользовательских обработчиков модульных тестов.</target>
        </trans-unit>
        <trans-unit id="230aa360bfc55c5cf21e968f489f8b1241790aa2" translate="yes" xml:space="preserve">
          <source>This compile-time flag is &lt;code&gt;true&lt;/code&gt; if logging is not statically disabled.</source>
          <target state="translated">Этот флаг времени компиляции имеет значение &lt;code&gt;true&lt;/code&gt; , если регистрация не статически отключена.</target>
        </trans-unit>
        <trans-unit id="d82eb07cfddf77181a4fa8aca621ce6591fd7ca9" translate="yes" xml:space="preserve">
          <source>This constructor is only called when we figured out which function template to instantiate.</source>
          <target state="translated">Этот конструктор вызывается только тогда,когда мы выяснили,какой шаблон функции нужно инстанцировать.</target>
        </trans-unit>
        <trans-unit id="aa95214feed626f5e6eebb5c6959ff1d8bcafc67" translate="yes" xml:space="preserve">
          <source>This constructor is the inverse of &lt;a href=&quot;#opCast&quot;&gt;&lt;code&gt;opCast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот конструктор является обратным к &lt;a href=&quot;#opCast&quot;&gt; &lt;code&gt;opCast&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8fcfb06ab6c25d2bbe46e5cfe782e5b576ac2d4" translate="yes" xml:space="preserve">
          <source>This contains the copyright notice. The macro COPYRIGHT is set to the contents of the section when it documents the module declaration. The copyright section only gets this special treatment when it is for the module declaration.</source>
          <target state="translated">Здесь содержится уведомление об авторских правах.Макрос КОПИРАЙТ устанавливается в соответствии с содержанием раздела при документировании декларации модуля.Раздел авторских прав получает эту специальную обработку только в том случае,если он предназначен для модульной декларации.</target>
        </trans-unit>
        <trans-unit id="822ca8d08b221bc29495c95da9984e8cee76c282" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage decoding buffers.</source>
          <target state="translated">Этот удобный метод избавляет от необходимости вручную управлять декодирующими буферами.</target>
        </trans-unit>
        <trans-unit id="cf045283f89baa3e44e42e507f01aa06b96bde31" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage output buffers.</source>
          <target state="translated">Этот удобный метод избавляет от необходимости вручную управлять выходными буферами.</target>
        </trans-unit>
        <trans-unit id="16b88e43157a2f6f2c5142b90b7d5fe45695bbef" translate="yes" xml:space="preserve">
          <source>This created a new Fiber for the supplied op and adds it to the dispatch list.</source>
          <target state="translated">Это создало новое оптоволокно для поставляемой операции и добавляет его в список рассылки.</target>
        </trans-unit>
        <trans-unit id="fdc94e4392e59112302f3c3212c7174cb2489e38" translate="yes" xml:space="preserve">
          <source>This creates a new Fiber for the supplied op and then starts the dispatcher.</source>
          <target state="translated">При этом создается новое оптоволокно для поставляемой операции,а затем запускается диспетчер.</target>
        </trans-unit>
        <trans-unit id="af45f3f128eb584feb53ad796c2bd75a57d5180c" translate="yes" xml:space="preserve">
          <source>This defines a new type &lt;code&gt;X&lt;/code&gt; which has values &lt;code&gt;X.A=0&lt;/code&gt;, &lt;code&gt;X.B=1&lt;/code&gt;, &lt;code&gt;X.C=2&lt;/code&gt;:</source>
          <target state="translated">Это определяет новый тип &lt;code&gt;X&lt;/code&gt; , который имеет значения &lt;code&gt;X.A=0&lt;/code&gt; , &lt;code&gt;X.B=1&lt;/code&gt; , &lt;code&gt;X.C=2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d27799b2bf9fed9292a027676e909387c978ddb" translate="yes" xml:space="preserve">
          <source>This definition of mutable functions is more general than the one traditionally employed by pure functional languages because it allows a D pure function to use state mutation, as long as all state is created internally or reachable through its arguments. In particular, a pure function may allocate memory by means of e.g. &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; without these being special cases. A pure function is allowed to loop indefinitely or terminate the program.</source>
          <target state="translated">Это определение изменяемых функций является более общим, чем определение, традиционно используемое чисто функциональными языками, поскольку оно позволяет чистой функции D использовать мутацию состояний, если все состояния создаются внутри или достижимы посредством своих аргументов. В частности, чистая функция может выделять память, например, с помощью &lt;code&gt;new&lt;/code&gt; или &lt;code&gt;malloc&lt;/code&gt; , без особых случаев. Чистая функция может бесконечно зацикливаться или завершать программу.</target>
        </trans-unit>
        <trans-unit id="524100fdceb69609090212fc4caf6a68ca169c00" translate="yes" xml:space="preserve">
          <source>This deletes the key e1 from the associative array e2</source>
          <target state="translated">При этом ключ e1 удаляется из ассоциативного массива e2.</target>
        </trans-unit>
        <trans-unit id="e594f9c668086e01075383fb67708b16f0e2344d" translate="yes" xml:space="preserve">
          <source>This describes the OOP API. To understand when to use the template API and when to use the OOP API, see the module documentation at the top of this page.</source>
          <target state="translated">Это описывает ООП API.Чтобы понять,когда использовать шаблонное API и когда использовать ООП API,смотрите документацию по модулю в верхней части этой страницы.</target>
        </trans-unit>
        <trans-unit id="3007dc64e992f88997b93bf75939ee91b3bf45cf" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;code&gt;x86&lt;/code&gt; and &lt;code&gt;x86_64&lt;/code&gt; implementations of the inline assembler. The inline assembler platform support that a compiler provides is indicated by the &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; and &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; version identifiers, respectively.</source>
          <target state="translated">В этом документе описываются реализации встроенного ассемблера &lt;code&gt;x86&lt;/code&gt; и &lt;code&gt;x86_64&lt;/code&gt; . Поддержка встроенной платформы ассемблера, предоставляемая компилятором, указывается идентификаторами версий &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; и &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="569cf1450215141639c3396e75fe3e0e30e8cd78" translate="yes" xml:space="preserve">
          <source>This document is the reference manual for the D Programming Language. For more information and other documents, see &lt;a href=&quot;https://dlang.org/&quot;&gt;The D Language Website&lt;/a&gt;.</source>
          <target state="translated">Этот документ является справочным руководством по языку программирования D. Для получения дополнительной информации и других документов см &lt;a href=&quot;https://dlang.org/&quot;&gt;. Веб-сайт The D Language&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b76c1da48d91edda64500d21af760a6ce3c2286" translate="yes" xml:space="preserve">
          <source>This document specifies how to interface with C++ directly.</source>
          <target state="translated">Этот документ описывает,как непосредственно взаимодействовать с C++.</target>
        </trans-unit>
        <trans-unit id="4eaa9b84c7822b2e3e77fa7e5df36263689f6cc9" translate="yes" xml:space="preserve">
          <source>This documents the general structure of a Digest in the template API. All digest implementations should implement the following members and therefore pass the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test.</source>
          <target state="translated">Это документирует общую структуру дайджеста в шаблоне API. Все реализации дайджеста должны реализовывать следующие члены и, следовательно, проходить тест &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac0dd62d84db23b0de6fee189b1020c75493d355" translate="yes" xml:space="preserve">
          <source>This does not assign the pointer of &lt;code&gt;rhs&lt;/code&gt; to this &lt;code&gt;RefRange&lt;/code&gt;. Rather it assigns the range pointed to by &lt;code&gt;rhs&lt;/code&gt; to the range pointed to by this &lt;code&gt;RefRange&lt;/code&gt;. This is because</source>
          <target state="translated">Это не присваивает указатель &lt;code&gt;rhs&lt;/code&gt; этому &lt;code&gt;RefRange&lt;/code&gt; . Скорее он назначает диапазон, на который указывает &lt;code&gt;rhs&lt;/code&gt; , диапазон, на который указывает этот &lt;code&gt;RefRange&lt;/code&gt; . Это потому что</target>
        </trans-unit>
        <trans-unit id="e81812302527d63ee87960159e6a1b9dd25fb020" translate="yes" xml:space="preserve">
          <source>This does not include any time during which the StopWatch was stopped but does include</source>
          <target state="translated">Это не включает в себя любое время,в течение которого секундомер был остановлен,но включает в себя</target>
        </trans-unit>
        <trans-unit id="c432390e6bbf7d9fb981f314323bac09cd4ec391" translate="yes" xml:space="preserve">
          <source>This does not mean, however, that one can change the data:</source>
          <target state="translated">Однако это не означает,что данные можно изменять:</target>
        </trans-unit>
        <trans-unit id="1d63844eee394540a61e05092a78018f8dcdacad" translate="yes" xml:space="preserve">
          <source>This doesn't include '\n', '\r', \t' and other non-space &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;. For commonly used less strict semantics see &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это не включает '\ n', '\ r', \ t 'и другие непробельные &lt;a href=&quot;#Character&quot;&gt;символы&lt;/a&gt; . Для часто используемых менее строгой семантики см. &lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b899c5918773ae82ab7898c96cd3e0a68f5b5e5e" translate="yes" xml:space="preserve">
          <source>This doesn't work for TLS memory, though.</source>
          <target state="translated">Но это не работает для TLS-памяти.</target>
        </trans-unit>
        <trans-unit id="add950f77c9072c48dcd0ff96facedd547735caa" translate="yes" xml:space="preserve">
          <source>This easy handle has completed. 'result' contains the CURLcode of the transfer</source>
          <target state="translated">Эта простая ручка закончена.Результат&quot; содержит CURL-код переноса.</target>
        </trans-unit>
        <trans-unit id="ef5d8951fd69c70c7d61e2bd1231248df49b6d3e" translate="yes" xml:space="preserve">
          <source>This example creates a DOM (Document Object Model) tree from an XML file.</source>
          <target state="translated">Этот пример создает дерево DOM (Document Object Model)из XML файла.</target>
        </trans-unit>
        <trans-unit id="74ec60c9c14341e9d9e5373aa773d98804f76f30" translate="yes" xml:space="preserve">
          <source>This example does much the same thing, except that the file is deconstructed and reconstructed by hand. This is more work, but the techniques involved offer vastly more power.</source>
          <target state="translated">Этот пример делает то же самое,за исключением того,что файл деконструируется и восстанавливается вручную.Это более трудоемкая работа,но используемые приемы дают гораздо больше мощности.</target>
        </trans-unit>
        <trans-unit id="7a4cbb05cb72419e58f855fffb51071ca39f119b" translate="yes" xml:space="preserve">
          <source>This example encodes the input data one byte at a time.</source>
          <target state="translated">В данном примере входные данные кодируются по одному байту за раз.</target>
        </trans-unit>
        <trans-unit id="efc529b5b8a635fe0248f0e1b5570f3e5c62ec50" translate="yes" xml:space="preserve">
          <source>This example encodes the input one line at a time.</source>
          <target state="translated">Этот пример кодирует вход по одной строке за раз.</target>
        </trans-unit>
        <trans-unit id="709f6883e08535336d0975187381366956732f0d" translate="yes" xml:space="preserve">
          <source>This example of template foo has a value parameter that is specialized for 10:</source>
          <target state="translated">Этот пример шаблона foo имеет параметр значения,специализированный на 10:</target>
        </trans-unit>
        <trans-unit id="0c7fc0bf8d7d58bae3c653e435da196f5834dccc" translate="yes" xml:space="preserve">
          <source>This example shows decoding one byte at a time.</source>
          <target state="translated">В данном примере показано декодирование по одному байту за раз.</target>
        </trans-unit>
        <trans-unit id="ca9412e6a6a265cc25cdadaa2feca886b99350b4" translate="yes" xml:space="preserve">
          <source>This example shows decoding over a range of input data lines.</source>
          <target state="translated">В данном примере показано декодирование по целому ряду входных линий данных.</target>
        </trans-unit>
        <trans-unit id="3ca157dc5296c9dbda3b67885000d1a3d169c64b" translate="yes" xml:space="preserve">
          <source>This example uses a mixin to implement a generic Duff's device for an arbitrary statement (in this case, the arbitrary statement is in bold). A nested function is generated as well as a delegate literal, these can be inlined by the compiler:</source>
          <target state="translated">В этом примере используется смесь для реализации универсального устройства Даффа для произвольного утверждения (в данном случае произвольное утверждение выделено жирным шрифтом).Генерируется вложенная функция,а также делегатский литерал,которые могут быть вложены компилятором:</target>
        </trans-unit>
        <trans-unit id="9fd04b9d165e95a5b5d46f431bdbd8794b151b29" translate="yes" xml:space="preserve">
          <source>This example will create an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;, and log the message using &lt;code&gt;NSLog&lt;/code&gt; to stderr.</source>
          <target state="translated">Этот пример создаст строку Objective C, &lt;code&gt;NSString&lt;/code&gt; , и зарегистрирует сообщение, используя &lt;code&gt;NSLog&lt;/code&gt; для stderr.</target>
        </trans-unit>
        <trans-unit id="5b44fd2927053fecf7f02a805bef21a73969e7c8" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an error occurs when parsing a UUID from a string.</source>
          <target state="translated">Это исключение выбрасывается,если при разборе UUID из строки возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="83cf2ca3dac976d4903c104f6cecb54eca32e9c0" translate="yes" xml:space="preserve">
          <source>This exists in order to find where &lt;code&gt;STC.maybescope&lt;/code&gt; is getting turned off.</source>
          <target state="translated">Это существует для того, чтобы найти, где &lt;code&gt;STC.maybescope&lt;/code&gt; отключается.</target>
        </trans-unit>
        <trans-unit id="ec12e985e5f97029a4fdcc178a312496ababfe99" translate="yes" xml:space="preserve">
          <source>This fiber must be in state HOLD.</source>
          <target state="translated">Это волокно должно быть в состоянии ДЕРЖАТЬ.</target>
        </trans-unit>
        <trans-unit id="050dfac3109c2719a43b56525c7b1b2f0f5442dd" translate="yes" xml:space="preserve">
          <source>This fiber must be in state TERM or HOLD.</source>
          <target state="translated">Это волокно должно быть в состоянии TERM или HOLD.</target>
        </trans-unit>
        <trans-unit id="8069d75e504b5df60eaae8b05121a6dfce90e592" translate="yes" xml:space="preserve">
          <source>This field has been deprecated. Please use &lt;code&gt;cacheLevels&lt;/code&gt; instead.</source>
          <target state="translated">Это поле устарело. Пожалуйста, используйте вместо этого &lt;code&gt;cacheLevels&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a88f12f8698a93effebf4b21ac2fcaaf1ed6557e" translate="yes" xml:space="preserve">
          <source>This field is populated when using &lt;a href=&quot;#csvReader&quot;&gt;&lt;code&gt;csvReader&lt;/code&gt;&lt;/a&gt; but not by &lt;a href=&quot;#csvNextToken&quot;&gt;&lt;code&gt;csvNextToken&lt;/code&gt;&lt;/a&gt; as this data will have already been fed to the output range.</source>
          <target state="translated">Это поле заполняется при использовании &lt;a href=&quot;#csvReader&quot;&gt; &lt;code&gt;csvReader&lt;/code&gt; ,&lt;/a&gt; но не &lt;a href=&quot;#csvNextToken&quot;&gt; &lt;code&gt;csvNextToken&lt;/code&gt; ,так&lt;/a&gt; как эти данные уже будут переданы в выходной диапазон.</target>
        </trans-unit>
        <trans-unit id="00b3ae505bfa7b5877d4290b9bf62b73f3526eab" translate="yes" xml:space="preserve">
          <source>This field was added in CURLVERSION_THIRD</source>
          <target state="translated">Это поле было добавлено в CURLVERSION_THIRD</target>
        </trans-unit>
        <trans-unit id="ded4afb1457e0f04e1bc6ce625b9a154f7bfa729" translate="yes" xml:space="preserve">
          <source>This flag has no effect on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот флаг не влияет на &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="translated">Данная функция</target>
        </trans-unit>
        <trans-unit id="63a837cbc01e12716c2a63542540dfd3d20ec868" translate="yes" xml:space="preserve">
          <source>This function allocates memory.</source>
          <target state="translated">Эта функция выделяет память.</target>
        </trans-unit>
        <trans-unit id="92814a3bf729ba0c96c36e96433e5f0d828849bd" translate="yes" xml:space="preserve">
          <source>This function allows user-defined subclasses of EncodingScheme to be declared in other modules.</source>
          <target state="translated">Данная функция позволяет декларировать пользовательские подклассы EncodingScheme в других модулях.</target>
        </trans-unit>
        <trans-unit id="471f7413c5ebea16f57422410a8bf930e30c75d3" translate="yes" xml:space="preserve">
          <source>This function also decomposes hangul syllables as prescribed by the standard.</source>
          <target state="translated">Эта функция также разлагает ангальские слоги,как это предписано стандартом.</target>
        </trans-unit>
        <trans-unit id="534457dcd59761dcb843df10d6fcec190ed3b4c4" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. The variadic overload is guaranteed to only perform a single allocation, as is the range version if &lt;code&gt;paths&lt;/code&gt; is a forward range.</source>
          <target state="translated">Эта функция всегда выделяет память для хранения полученного пути. Variadic overload гарантированно выполняет только одно распределение, как и версия диапазона, если &lt;code&gt;paths&lt;/code&gt; - прямой диапазон.</target>
        </trans-unit>
        <trans-unit id="bd9256b25c3dea2b100b91fc151d4d49aa057003" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#asNormalizedPath&quot;&gt;&lt;code&gt;asNormalizedPath&lt;/code&gt;&lt;/a&gt; to not allocate memory.</source>
          <target state="translated">Эта функция всегда выделяет память для хранения полученного пути. Используйте &lt;a href=&quot;#asNormalizedPath&quot;&gt; &lt;code&gt;asNormalizedPath&lt;/code&gt; ,&lt;/a&gt; чтобы не выделять память.</target>
        </trans-unit>
        <trans-unit id="187779b43f44c34c6b32550dd282a3cd2f13a1e6" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#buildNormalizedPath&quot;&gt;&lt;code&gt;buildNormalizedPath&lt;/code&gt;&lt;/a&gt; to allocate memory and return a string.</source>
          <target state="translated">Эта функция всегда выделяет память для хранения полученного пути. Используйте &lt;a href=&quot;#buildNormalizedPath&quot;&gt; &lt;code&gt;buildNormalizedPath&lt;/code&gt; &lt;/a&gt; для выделения памяти и возврата строки.</target>
        </trans-unit>
        <trans-unit id="565ae089ae893ce04d0723fbc06da8efba3b5449" translate="yes" xml:space="preserve">
          <source>This function calls &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt;&lt;code&gt;FlushFileBuffers&lt;/code&gt;&lt;/a&gt; on Windows and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt;&lt;code&gt;fsync&lt;/code&gt;&lt;/a&gt; on POSIX for the file handle.</source>
          <target state="translated">Эта функция вызывает &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt; &lt;code&gt;FlushFileBuffers&lt;/code&gt; &lt;/a&gt; в Windows и &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt; &lt;code&gt;fsync&lt;/code&gt; &lt;/a&gt; в POSIX для дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="f8c2e50367d22c68b1ef6bf70b530cf16359f88a" translate="yes" xml:space="preserve">
          <source>This function can allocate if the &lt;code&gt;Yes.allocateGC&lt;/code&gt; flag is passed. This has the benefit of have better complexity than the &lt;code&gt;Yes.allocateGC&lt;/code&gt; option. However, this option is only available for ranges whose equality can be determined via each element's &lt;code&gt;toHash&lt;/code&gt; method. If customized equality is needed, then the &lt;code&gt;pred&lt;/code&gt; template parameter can be passed, and the function will automatically switch to the non-allocating algorithm. See &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; for more details on how to define &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Эта функция может выделять, если &lt;code&gt;Yes.allocateGC&lt;/code&gt; флаг Yes.allocateGC . Это имеет преимущество в том, что сложнее, чем опция &lt;code&gt;Yes.allocateGC&lt;/code&gt; . Однако этот параметр доступен только для диапазонов, равенство которых можно определить с помощью метода &lt;code&gt;toHash&lt;/code&gt; каждого элемента . Если требуется настраиваемое равенство, то можно передать параметр шаблона &lt;code&gt;pred&lt;/code&gt; , и функция автоматически переключится на алгоритм невыделения. Смотрите &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; для более подробной информации о том, как определить &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b1f8d9be7c40727aeac47ccfd7444f517f04172" translate="yes" xml:space="preserve">
          <source>This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">Эта функция может быть &lt;code&gt;@trusted&lt;/code&gt; , если соответствующий конструктор &lt;code&gt;T&lt;/code&gt; равен &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="287c25734ab50e3ae9a7c39776861bb5646f4c1c" translate="yes" xml:space="preserve">
          <source>This function can perform a case-sensitive or a case-insensitive comparison. This is controlled through the &lt;code&gt;cs&lt;/code&gt; template parameter which, if not specified, is given by &lt;a href=&quot;#CaseSensitive&quot;&gt;&lt;code&gt;CaseSensitive&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.osDefault&lt;/code&gt;.</source>
          <target state="translated">Эта функция может выполнять сравнение с учетом регистра или без учета регистра. Это контролируется с помощью параметра шаблона &lt;code&gt;cs&lt;/code&gt; , который, если не указан, задается &lt;a href=&quot;#CaseSensitive&quot;&gt; &lt;code&gt;CaseSensitive&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.osDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e873b6c5b5805640016d4214ee3463e370b995d" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt; the POSIX requirements for the 'basename' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">Эта функция соответствует &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt;требованиям POSIX для утилиты оболочки 'basename'&lt;/a&gt; (с подходящей адаптацией для путей Windows).</target>
        </trans-unit>
        <trans-unit id="271fe9a4358104e29e9baaf0f70ca7697a626f35" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt; the POSIX requirements for the 'dirname' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">Эта функция соответствует &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt;требованиям POSIX для утилиты оболочки 'dirname'&lt;/a&gt; (с подходящей адаптацией для путей Windows).</target>
        </trans-unit>
        <trans-unit id="f911814cd134bf58a8ba7e68aae37ec618511b50" translate="yes" xml:space="preserve">
          <source>This function consumes the input. After each call the input will start with either a delimiter or record break (\n, \r\n, \r) which must be removed for subsequent calls.</source>
          <target state="translated">Эта функция потребляет вход.После каждого вызова вход начнется либо с разделителя,либо с перерыва в записи (\n,\r\n,\r),который необходимо удалить для последующих вызовов.</target>
        </trans-unit>
        <trans-unit id="82adca51d2d89c2e52168f23c5014dcf4b09b7e3" translate="yes" xml:space="preserve">
          <source>This function creates a complete DOM (Document Object Model) tree.</source>
          <target state="translated">Эта функция создает полное дерево DOM (Document Object Model).</target>
        </trans-unit>
        <trans-unit id="34f7e14685f9dc1d8824f48b2307f8cd989b3e43" translate="yes" xml:space="preserve">
          <source>This function decodes the entities &amp;amp;amp;, &amp;amp;quot;, &amp;amp;apos;, &amp;amp;lt; and &amp;amp;gt, as well as decimal and hexadecimal entities such as &amp;amp;#x20AC;</source>
          <target state="translated">Эта функция декодирует объекты &amp;amp; amp ;, &amp;amp; quot ;, &amp;amp; amp ;, &amp;amp; lt; и &amp;amp; gt, а также десятичные и шестнадцатеричные объекты, такие как &amp;amp; # x20AC;</target>
        </trans-unit>
        <trans-unit id="37bc9985a8792341b2d7a8d50dc7ab55bd1e93ad" translate="yes" xml:space="preserve">
          <source>This function defends against this attack by always comparing every single item in the array if the two arrays are the same length. Therefore, this function is always &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) for ranges of the same length.</source>
          <target state="translated">Эта функция защищает от этой атаки, всегда сравнивая каждый элемент массива, если два массива имеют одинаковую длину. Следовательно, эта функция всегда &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; ) для диапазонов одинаковой длины.</target>
        </trans-unit>
        <trans-unit id="07fbd70f1f7940fca06c0a8a3c74b8aabe9ac979" translate="yes" xml:space="preserve">
          <source>This function does not provide overloads for wstring and dstring, as there's no clear answer on how that should be implemented. It could be argued, that string, wstring and dstring input should have the same output, but that wouldn't be compatible with Boost, which generates different output for strings and wstrings. It's always possible to pass wstrings and dstrings by using the ubyte[] function overload (but be aware of endianness issues!).</source>
          <target state="translated">Эта функция не предоставляет перегрузок для wstring и dstring,так как нет четкого ответа,как это должно быть реализовано.Можно утверждать,что входные данные для строк,wstring и dstring должны иметь один и тот же вывод,но это не будет совместимо с Boost,который генерирует разные выводы для строк и wstrings.Передача строк и строк всегда возможна при перегрузке функции ubyte[](но будьте внимательны к проблемам с эндианностью!).</target>
        </trans-unit>
        <trans-unit id="a7eab1a520623d1ac5e68ed2c102542d0c568c2a" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units The code units are stored in a user-supplied fixed-size array, which must be passed by reference.</source>
          <target state="translated">Данная функция кодирует одну точку кода в один или несколько единиц кода Единицы кода хранятся в пользовательском массиве фиксированного размера,который должен передаваться по ссылке.</target>
        </trans-unit>
        <trans-unit id="a4dfecb064dc08682e5d5f6ff6e2a923d6c06c55" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. It returns a string containing those code units.</source>
          <target state="translated">Данная функция кодирует одну точку кода в один или несколько единиц кода.Она возвращает строку,содержащую эти единицы кода.</target>
        </trans-unit>
        <trans-unit id="d23af3939d6f49cb27a211fdfb01f49551cd4f68" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. The code units are passed one at a time to the supplied delegate.</source>
          <target state="translated">Данная функция кодирует одну точку кода в один или несколько единиц кода.Единицы кода передаются по одной на поставляемого делегата.</target>
        </trans-unit>
        <trans-unit id="fd5007482279246870e612a2f7b9d7848a9ec8a9" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more ubytes. The supplied buffer must be code unit aligned. (For example, UTF-16LE or UTF-16BE must be wchar-aligned, UTF-32LE or UTF-32BE must be dchar-aligned, etc.)</source>
          <target state="translated">Данная функция кодирует одну точку кода в один или несколько миллиардов.Поставляемый буфер должен быть выровнен по единицам кода.(Например,UTF-16LE или UTF-16BE должны быть выровнены по wchar,UTF-32LE или UTF-32BE должны быть выровнены по dchar и т.д.).</target>
        </trans-unit>
        <trans-unit id="5a399e2ee90c7d22546000e946a9cf8427b4a082" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">Эта функция существует для того, чтобы упростить преобразование &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; в строку для кода, который не заботится о том, что является точным форматом - просто он представляет информацию в ясной форме. Это также позволяет легко преобразовать &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; в строку, когда используются такие функции, как &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; или &lt;code&gt;writeln&lt;/code&gt; , которые используют toString для преобразования пользовательских типов. Таким образом, маловероятно, что большая часть кода будет напрямую вызывать toString.</target>
        </trans-unit>
        <trans-unit id="1c7ed4f81f0a82e13d48bb2e31cd6ec82cd2b86c" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">Эта функция существует для того, чтобы упростить преобразование &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; в строку для кода, который не заботится о точном формате - просто он представляет информацию в ясной форме. Это также позволяет легко преобразовать &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; в строку, когда используются такие функции, как &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; или &lt;code&gt;writeln&lt;/code&gt; , которые используют toString для преобразования пользовательских типов. Таким образом, маловероятно, что большая часть кода будет напрямую вызывать toString.</target>
        </trans-unit>
        <trans-unit id="6a64dc24e50c98de86395100f53371f383577cde" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">Эта функция существует для того, чтобы упростить преобразование &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; в строку для кода, который не заботится о точном формате - просто он представляет информацию в четкой форме. Это также упрощает преобразование &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; в строку при использовании таких функций, как &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; или &lt;code&gt;writeln&lt;/code&gt; , которые используют toString для преобразования пользовательских типов. Таким образом, маловероятно, что большая часть кода будет напрямую вызывать toString.</target>
        </trans-unit>
        <trans-unit id="14f41e253b823f745b15c2cc550803f474f520f9" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">Эта функция существует для того, чтобы упростить преобразование &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; в строку для кода, который не заботится о точном формате - просто он представляет информацию в четкой форме. Это также упрощает преобразование &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; в строку при использовании таких функций, как &lt;code&gt;to!string&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; или &lt;code&gt;writeln&lt;/code&gt; , которые используют toString для преобразования пользовательских типов. Таким образом, маловероятно, что большая часть кода будет напрямую вызывать toString.</target>
        </trans-unit>
        <trans-unit id="1148e69f156783aee95aaac3af378446a842c947" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 3) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">Эта функция генерирует UUID на основе имени (версия 3) из UUID пространства имен и имени. Если UUID пространства имен не был передан, используется пустой UUID &lt;code&gt;UUID.init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66eef894e5457f79fe590d4b75d5bdb426faba8d" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 5) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">Эта функция генерирует UUID на основе имени (версия 5) из UUID пространства имен и имени. Если UUID пространства имен не был передан, используется пустой UUID &lt;code&gt;UUID.init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebad38cdc822b58300e9d455ffae98ef3b8355b1" translate="yes" xml:space="preserve">
          <source>This function generates a random number based UUID from a random number generator.</source>
          <target state="translated">Эта функция генерирует UUID на основе случайных чисел из генератора случайных чисел.</target>
        </trans-unit>
        <trans-unit id="f6f7c9706e6dcaec3dbc1161d8b30b320ab44ea3" translate="yes" xml:space="preserve">
          <source>This function has high relative accuracy for values of x far from zero. (For values near zero, use erf(x)).</source>
          <target state="translated">Эта функция имеет высокую относительную точность для значений x вдали от нуля.(Для значений,близких к нулю,используйте erf(x)).</target>
        </trans-unit>
        <trans-unit id="e015cb774f65ac50bf4cc869720d1f86b5a714ec" translate="yes" xml:space="preserve">
          <source>This function is #1 on the list of functions that eat cpu time. Be very, very careful about slowing it down.</source>
          <target state="translated">Эта функция №1 в списке функций,которые едят время процессора.Будьте очень,очень осторожны,чтобы замедлить ее.</target>
        </trans-unit>
        <trans-unit id="3d30b43ff787a8dfba63ef7540785dda2309b0ec" translate="yes" xml:space="preserve">
          <source>This function is &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">Эта функция &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="60a203a8ffe09817c002b043b4f7c89faa37bc5d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;@safe&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">Эта функция является &lt;code&gt;@safe&lt;/code&gt; , если соответствующий конструктор &lt;code&gt;T&lt;/code&gt; равен &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f04b8551bbda2b81d8696beac9a1b771dca8c71" translate="yes" xml:space="preserve">
          <source>This function is Posix-Only.</source>
          <target state="translated">Эта функция-Posix-Only.</target>
        </trans-unit>
        <trans-unit id="fbf60467a7efe2e24827c64edfe554cec3d53403" translate="yes" xml:space="preserve">
          <source>This function is Windows-Only.</source>
          <target state="translated">Эта функция только для окон.</target>
        </trans-unit>
        <trans-unit id="103c72135b781967b4b7d6c0026bb26f7259605d" translate="yes" xml:space="preserve">
          <source>This function is also useful in checking for the existence of an environment variable.</source>
          <target state="translated">Эта функция также полезна при проверке существования переменной окружения.</target>
        </trans-unit>
        <trans-unit id="ff6b0b14fd4304f9c34b27c03cced94d986e4033" translate="yes" xml:space="preserve">
          <source>This function is character-range specific and, contrary to &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt;, runs of whitespace will be merged together (no empty tokens will be produced).</source>
          <target state="translated">Эта функция зависит от диапазона символов и, в отличие от &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt; , пробелы будут объединены (пустые токены не будут созданы).</target>
        </trans-unit>
        <trans-unit id="65b5ee7f9fec25cbb593bdce1cbdc98ea5f973e1" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and calls &lt;code&gt;deallocateAll&lt;/code&gt; for them in turn.</source>
          <target state="translated">Эта функция определяется только в том случае, если ее определяют оба распределителя и по очереди вызывает &lt;code&gt;deallocateAll&lt;/code&gt; для них.</target>
        </trans-unit>
        <trans-unit id="8e12c13033743e308c93ef7b1af47f1c5b48d3a7" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and forwards appropriately depending on &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">Эта функция определяется только в том случае, если ее определяют оба распределителя, и пересылается соответствующим образом в зависимости от &lt;code&gt;b.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd4634555bf7b1d8d38cdad8559fbd72f2f0cbb" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and returns the conjunction of &lt;code&gt;empty&lt;/code&gt; calls for the two.</source>
          <target state="translated">Эта функция определяется только в том случае, если ее определяют оба распределителя, и возвращает соединение &lt;code&gt;empty&lt;/code&gt; вызовов для двух.</target>
        </trans-unit>
        <trans-unit id="72987efb86a1c65d967d861a8683d92ed7f13b9d" translate="yes" xml:space="preserve">
          <source>This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead.</source>
          <target state="translated">Эта функция обычно не очень полезна;почти всегда лучше использовать более быстрые функции nextUp()или nextDown().</target>
        </trans-unit>
        <trans-unit id="e7e3e7b8bfa4b21481d77f68ea65de0d9b8237c1" translate="yes" xml:space="preserve">
          <source>This function is not supported at compile time.</source>
          <target state="translated">Эта функция не поддерживается на этапе компиляции.</target>
        </trans-unit>
        <trans-unit id="1569b54f86e9b2550627b7e8e8f05e326ad676e8" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe!</source>
          <target state="translated">Эта функция не является потокобезопасной!</target>
        </trans-unit>
        <trans-unit id="41af9d14cc682c76550081ea13492c59097f2bca" translate="yes" xml:space="preserve">
          <source>This function is only aware of EncodingSchemes which have been registered with the register() function.</source>
          <target state="translated">Эта функция знает только о EncodingSchemes,которые были зарегистрированы в функции register().</target>
        </trans-unit>
        <trans-unit id="290ee1b0991973abcaa58bca7c5f6871e5deb008" translate="yes" xml:space="preserve">
          <source>This function is only implemented to 80 bit precision.</source>
          <target state="translated">Эта функция реализована с точностью до 80 бит.</target>
        </trans-unit>
        <trans-unit id="ee429d1ffe9a170a1a75d5b4a2ff165cd4f65550" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, all elements of tiargs won't be modified.</source>
          <target state="translated">Эта функция возвращается при возникновении ошибки.Если возвращается false,то все элементы tiargs не будут изменены.</target>
        </trans-unit>
        <trans-unit id="a118a63c84fce3cf7c06f5f8756bac60c7cca3ac" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, any members of this object won't be modified, and repetition call will reproduce same error.</source>
          <target state="translated">Эта функция возвращается при возникновении ошибки.Если возвращается false,то любой член этого объекта не будет изменен,а повторный вызов будет воспроизводить ту же ошибку.</target>
        </trans-unit>
        <trans-unit id="45e502c95c63dd3997ac1ae57545286a53eaf26c" translate="yes" xml:space="preserve">
          <source>This function is supported in CTFE code. Note that error messages caused by a malformed UUID parsed at compile time can be cryptic, but errors are detected and reported at compile time.</source>
          <target state="translated">Эта функция поддерживается в коде CTFE.Обратите внимание,что сообщения об ошибках,вызванных неправильным разбором UUID во время компиляции,могут быть загадочными,но ошибки обнаруживаются и сообщаются во время компиляции.</target>
        </trans-unit>
        <trans-unit id="5bb3aca496547a19019cbfbd46c1d03c7dd418c6" translate="yes" xml:space="preserve">
          <source>This function is tentatively defined as &lt;code&gt;nothrow&lt;/code&gt; to prevent &lt;code&gt;opPostMove&lt;/code&gt; from being defined without &lt;code&gt;nothrow&lt;/code&gt;, which would allow for possibly confusing changes in program flow.</source>
          <target state="translated">Эта функция предварительно определена как &lt;code&gt;nothrow&lt;/code&gt; для предотвращения &lt;code&gt;opPostMove&lt;/code&gt; от определяемого без &lt;code&gt;nothrow&lt;/code&gt; , что позволило бы , возможно , путая изменения в процессе выполнения программы.</target>
        </trans-unit>
        <trans-unit id="185d734d5fc912e0041185bf79a2b6f944b2db35" translate="yes" xml:space="preserve">
          <source>This function is used to (re)initialize the digest. It must be called before using the digest and it also works as a 'reset' function if the digest has already processed data.</source>
          <target state="translated">Эта функция используется для (пере)инициализации дайджеста.Она должна быть вызвана перед использованием дайджеста,а также работает как функция &quot;сброса&quot;,если дайджест уже обработал данные.</target>
        </trans-unit>
        <trans-unit id="99071cc1c1c24be1d51b7e6eda1e08791479ed2b" translate="yes" xml:space="preserve">
          <source>This function is used to read the content of DFLAGS. Flags are separated based on spaces and tabs.</source>
          <target state="translated">Эта функция используется для чтения содержимого DFLAGS.Флаги разделены на основании пробелов и вкладок.</target>
        </trans-unit>
        <trans-unit id="2d39d375bb67b5bea56b7ea75d0a2e4ee34a5fe2" translate="yes" xml:space="preserve">
          <source>This function is useful for maintaining worker-local resources.</source>
          <target state="translated">Эта функция полезна для поддержания рабочих мест.</target>
        </trans-unit>
        <trans-unit id="c37fe60667a42f9d7da86b803e8b5052d66d498d" translate="yes" xml:space="preserve">
          <source>This function is, in particular, meant to help maintain garbage collector invariants when a lock is not used.</source>
          <target state="translated">Эта функция,в частности,предназначена для помощи в поддержании инвариантов сборщика мусора,когда замок не используется.</target>
        </trans-unit>
        <trans-unit id="aa18c6da596117f8b9e11fbedcdfb9a943118fde" translate="yes" xml:space="preserve">
          <source>This function logs data in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">Эта функция регистрирует данные в стиле &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77ac69a4b95956005ebe3b90c8e1ca91567efe01" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">Эта функция записывает данные в &lt;code&gt;sharedLog&lt;/code&gt; в стиле &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98febaf749a97b9336fc523ba35aa7fdcff34cf1" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;, optionally depending on a condition.</source>
          <target state="translated">Эта функция записывает данные в &lt;code&gt;stdThreadLocalLog&lt;/code&gt; , необязательно в зависимости от условия.</target>
        </trans-unit>
        <trans-unit id="eda414e04cca7c9801e1364601be4f243d02a0be" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; в зависимости от условия с &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; в стиле &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66789021f1f75fa2b910c0e9aaed002765517585" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; зависимости от условия.</target>
        </trans-unit>
        <trans-unit id="ea29ac02cb23a3225768859acfa66ad70cf0ae39" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a explicitly passed condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; в зависимости от явно переданного условия с &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a8c9b909022c7e8d9e73cb0c216e864ba19a51" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; в стиле &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="628f5766ea3ce125dda3efbe604aac9ecda078eb" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; and depending on a condition in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; с определенным &lt;code&gt;LogLevel&lt;/code&gt; и в зависимости от условия в стиле &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f75a8e8d5f3578debc1682e9b8a4e7729b3c532e" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; с определенным &lt;code&gt;LogLevel&lt;/code&gt; в стиле &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca804d9917691f26fc7fe486237e02550749abb2" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; с определенным &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca01c9755ef83db66052e862db8bfa8416b4a46" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Эта функция записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; с помощью &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32b20bbe0e9053ff439b8531776b44b5d48b2b21" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Эта функция записывает данные на используемый &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de4891742f4a098eab831566cf8b20847dcaef47" translate="yes" xml:space="preserve">
          <source>This function logs data.</source>
          <target state="translated">Эта функция регистрирует данные.</target>
        </trans-unit>
        <trans-unit id="f6a6f2512cc3b6d3cec5f7eabcb2475f26f787b9" translate="yes" xml:space="preserve">
          <source>This function modifies &lt;code&gt;inp&lt;/code&gt; and thus &lt;code&gt;inp&lt;/code&gt; must be an L-value.</source>
          <target state="translated">Эта функция изменяет &lt;code&gt;inp&lt;/code&gt; и, следовательно, &lt;code&gt;inp&lt;/code&gt; должна быть L-значением.</target>
        </trans-unit>
        <trans-unit id="e7aa3a07169729c5a673fe4e99d00fd959fedfe3" translate="yes" xml:space="preserve">
          <source>This function normally allocates a new string (the possible exception being the case when path is immutable and doesn't already have an extension).</source>
          <target state="translated">Обычно эта функция выделяет новую строку (возможным исключением является случай,когда путь является неизменяемым и уже не имеет расширения).</target>
        </trans-unit>
        <trans-unit id="7c7d082480a49d72cdaa9587898253b55870d5fe" translate="yes" xml:space="preserve">
          <source>This function only handles 1:1 &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; mapping and thus is not sufficient for certain alphabets like German, Greek and few others.</source>
          <target state="translated">Эта функция обрабатывает только отображение &lt;a href=&quot;#Code%20point&quot;&gt;кодовой точки&lt;/a&gt; 1: 1 и, следовательно, не подходит для некоторых алфавитов, таких как немецкий, греческий и некоторые другие.</target>
        </trans-unit>
        <trans-unit id="4d4c84cebd7adfe7f4082a2a17dcc09bc723efd3" translate="yes" xml:space="preserve">
          <source>This function performs several memory allocations.</source>
          <target state="translated">Эта функция выполняет несколько назначений памяти.</target>
        </trans-unit>
        <trans-unit id="36f6f15315bfa28fc8956871508424ecedf0dc3c" translate="yes" xml:space="preserve">
          <source>This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="translated">Эта функция выбирает наиболее подходящий движок регулярных выражений в зависимости от свойств шаблона.</target>
        </trans-unit>
        <trans-unit id="34bd902809c0b5255b567c50dd18197e0b398a33" translate="yes" xml:space="preserve">
          <source>This function prints the passed &lt;code&gt;Option&lt;/code&gt;s and text in an aligned manner on &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Эта функция печатает переданные &lt;code&gt;Option&lt;/code&gt; и текст в &lt;code&gt;stdout&lt;/code&gt; выровненным способом .</target>
        </trans-unit>
        <trans-unit id="770ded5804f61f67694592c9314c6c39ad348096" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the end of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">Данная функция удаляет одну или несколько единиц кода из конца строки и возвращает декодированную точку кода,которую эти единицы кода представляют.</target>
        </trans-unit>
        <trans-unit id="63d27ce6c5e48781869a5f906f514c111b2ab498" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the start of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">Данная функция удаляет одну или несколько единиц кода из начала строки и возвращает декодированную кодовую точку,которую эти единицы кода представляют.</target>
        </trans-unit>
        <trans-unit id="991bbd196cea9f8531404b722484d52c7268693c" translate="yes" xml:space="preserve">
          <source>This function removes one or more ubytes from the start of an array, and returns the decoded code point which those ubytes represent.</source>
          <target state="translated">Функция удаляет один или более ubytes из начала массива и возвращает декодированную кодовую точку,которую представляют эти ubytes.</target>
        </trans-unit>
        <trans-unit id="bd8d3ae1218b20b89d6f5e7ab875d1f322ea2c00" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; on Windows, &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; on POSIX, and &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; on Android.</source>
          <target state="translated">Эта функция возвращает &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; в Windows, &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; в POSIX и &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; в Android.</target>
        </trans-unit>
        <trans-unit id="cfc5056dabba79a946af25fc1dd8feac3fe04895" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to a static copy of the version info struct. See above.</source>
          <target state="translated">Эта функция возвращает указатель на статическую копию информационной структуры версии.См.выше.</target>
        </trans-unit>
        <trans-unit id="bb8f6db61ab479424f86bd4d40e2eb70c3733a62" translate="yes" xml:space="preserve">
          <source>This function returns a thread unique &lt;code&gt;Logger&lt;/code&gt;, that by default propergates all data logged to it to the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">Эта функция возвращает поток уникальный &lt;code&gt;Logger&lt;/code&gt; , что по умолчанию propergates все данные записываются в него в &lt;code&gt;sharedLog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85a54448d469e795c947752c78a6d4cb2de70c6f" translate="yes" xml:space="preserve">
          <source>This function searches with policy &lt;code&gt;sp&lt;/code&gt; to find the largest right subrange on which &lt;code&gt;pred(value, x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly greater than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция выполняет поиск с помощью политики &lt;code&gt;sp&lt;/code&gt; , чтобы найти самый большой правый поддиапазон, для которого &lt;code&gt;pred(value, x)&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;x&lt;/code&gt; (например, если &lt;code&gt;pred&lt;/code&gt; &amp;laquo;меньше чем&amp;raquo;, возвращает часть диапазона с элементами, строго превышающими &lt;code&gt;value&lt;/code&gt; ). Расписание поиска и его сложность задокументированы в &lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86863ccd0cc5913a3769149726c682b13dc136f9" translate="yes" xml:space="preserve">
          <source>This function sets an association in the multi handle between the given socket and a private pointer of the application. This is (only) useful for curl_multi_socket uses.</source>
          <target state="translated">Эта функция устанавливает ассоциацию в мульти-ручке между данным гнездом и частным указателем приложения.Это (только)полезно для использования curl_multi_socket.</target>
        </trans-unit>
        <trans-unit id="45ebc1498e7faf85df00e384f08e7ba59324aaf5" translate="yes" xml:space="preserve">
          <source>This function should be used for expensive functions, as waiting on a condition variable introduces latency, but avoids wasted CPU cycles.</source>
          <target state="translated">Эту функцию следует использовать для дорогостоящих функций,так как ожидание на условной переменной приводит к задержке,но позволяет избежать пустых циклов процессора.</target>
        </trans-unit>
        <trans-unit id="1e6634f9a998d963ab6d1c10d0d15ad19ccda248" translate="yes" xml:space="preserve">
          <source>This function should be used when you expect the result of the &lt;code&gt;Task&lt;/code&gt; to be available on a timescale shorter than that of an OS context switch.</source>
          <target state="translated">Эту функцию следует использовать, когда вы ожидаете, что результат &lt;code&gt;Task&lt;/code&gt; будет доступен в более короткие сроки, чем при переключении контекста ОС.</target>
        </trans-unit>
        <trans-unit id="84d0dda7f69c92e937d2c85cb930b35b5906bc64" translate="yes" xml:space="preserve">
          <source>This function simply returns the &lt;code&gt;Rebindable&lt;/code&gt; object passed in. It's useful in generic programming cases when a given object may be either a regular &lt;code&gt;class&lt;/code&gt; or a &lt;code&gt;Rebindable&lt;/code&gt;.</source>
          <target state="translated">Эта функция просто возвращает &lt;code&gt;Rebindable&lt;/code&gt; объект Rebindable . Это полезно в общих случаях программирования, когда данный объект может быть либо обычным &lt;code&gt;class&lt;/code&gt; либо &lt;code&gt;Rebindable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75bbfb153afd3973808d9088100797f6903e565d" translate="yes" xml:space="preserve">
          <source>This function supercedes &lt;a href=&quot;#toUCSindex&quot;&gt;&lt;code&gt;toUCSindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция &lt;a href=&quot;#toUCSindex&quot;&gt; &lt;code&gt;toUCSindex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82566e279c83708bdcc5beef2341e2cb52b9d496" translate="yes" xml:space="preserve">
          <source>This function supersedes &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt;.</source>
          <target state="translated">Эта функция заменяет &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8a982375de1de2eaf1b0bfc6ef749e37da8e235" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode(), however, note that the function codePoints() supersedes it more conveniently.</source>
          <target state="translated">Эта функция заменяет std.utf.decode(),однако обратите внимание,что функция codePoints()заменяет ее более удобно.</target>
        </trans-unit>
        <trans-unit id="3610464c0d3095b814b50eec2269b0b83ec7dc6a" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode().</source>
          <target state="translated">Эта функция заменяет std.utf.decode().</target>
        </trans-unit>
        <trans-unit id="3ed87f3ac177989d1d591be6e146c6a7ad9b003c" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently.</source>
          <target state="translated">Эта функция заменяет std.utf.encode(),однако обратите внимание,что функция codeUnits()заменяет ее более удобно.</target>
        </trans-unit>
        <trans-unit id="98db0a10ff6e0809060d25a9c9ccbac61cd894c8" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode().</source>
          <target state="translated">Эта функция заменяет std.utf.encode().</target>
        </trans-unit>
        <trans-unit id="6581afa2c255deba8c9a51b34c12340690fe56e5" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and std.utf.toUTF32() (but note that to!() supersedes it more conveniently).</source>
          <target state="translated">Эта функция заменяет std.utf.toUTF8(),std.utf.toUTF16()и std.utf.toUTF32()(но обратите внимание,что функция to!()заменяет ее более удобно).</target>
        </trans-unit>
        <trans-unit id="b48f04fdfd63524d418640a2544c0d752dc1f11b" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTFindex().</source>
          <target state="translated">Эта функция заменяет std.utf.toUTFindex().</target>
        </trans-unit>
        <trans-unit id="463c192ee5d4e01c6f9684913be662a0a7946d01" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.validate(), however note that this function returns a bool indicating whether the input was valid or not, whereas the older function would throw an exception.</source>
          <target state="translated">Эта функция заменяет std.utf.validate(),однако обратите внимание,что эта функция возвращает bool,указывая,был ли вход действительным или нет,в то время как более старая функция бросала бы исключение.</target>
        </trans-unit>
        <trans-unit id="b42d760296ed5ca95af88ffb26c20168d2a48b77" translate="yes" xml:space="preserve">
          <source>This function takes a non-scope delegate, meaning it can be used with closures. If you can't allocate a closure due to objects on the stack that have scoped destruction, see &lt;code&gt;scopedTask&lt;/code&gt;, which takes a scope delegate.</source>
          <target state="translated">Эта функция принимает делегат без области видимости, что означает, что она может использоваться с замыканиями. Если вы не можете выделить замыкание из-за объектов в стеке, которые имеют уничтоженную область действия, смотрите &lt;code&gt;scopedTask&lt;/code&gt; , который принимает делегат области действия.</target>
        </trans-unit>
        <trans-unit id="df71b7c251663548a0f5121464d05a78978a7d9e" translate="yes" xml:space="preserve">
          <source>This function takes a set of path segments, given as an input range of string elements or as a set of string arguments, and concatenates them with each other. Directory separators are inserted between segments if necessary. If any of the path segments are absolute (as defined by &lt;a href=&quot;#isAbsolute&quot;&gt;&lt;code&gt;isAbsolute&lt;/code&gt;&lt;/a&gt;), the preceding segments will be dropped.</source>
          <target state="translated">Эта функция принимает набор сегментов пути, заданных в качестве входного диапазона строковых элементов или в виде набора строковых аргументов, и объединяет их друг с другом. Разделители каталогов вставляются между сегментами при необходимости. Если какой-либо из сегментов пути является абсолютным (как определено &lt;a href=&quot;#isAbsolute&quot;&gt; &lt;code&gt;isAbsolute&lt;/code&gt; &lt;/a&gt; ), предыдущие сегменты будут удалены .</target>
        </trans-unit>
        <trans-unit id="3df6f1df50a9028bb24157314b57114720f745cc" translate="yes" xml:space="preserve">
          <source>This function template needs be between the compiler and a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">Этот шаблон функции должен находиться между компилятором и более старым хуком времени выполнения, который обошел проверки безопасности, чистоты и проверки на отказоустойчивость. Во избежание взлома существующего кода этот шаблон функции временно объявляется &lt;code&gt;@trusted pure&lt;/code&gt; до тех пор, пока реализация не будет приведена в соответствие с современными ожиданиями D.</target>
        </trans-unit>
        <trans-unit id="c911ca2b3e26ac7f7502675d63ee542618ab2fa0" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure nothrow&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">Этот шаблон функции был перенесен из гораздо более раннего хука среды выполнения, который обошел проверки безопасности, чистоты и проверки на отказоустойчивость. Во избежание взлома существующего кода этот шаблон функции временно объявляется &lt;code&gt;@trusted pure nothrow&lt;/code&gt; , пока реализация не будет приведена в соответствие с современными ожиданиями D.</target>
        </trans-unit>
        <trans-unit id="9fd88572c57bc63342adb7e4bba717ecc664649b" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">Этот шаблон функции был перенесен из гораздо более раннего хука среды выполнения, который обошел проверки безопасности, чистоты и проверки на отказоустойчивость. Во избежание взлома существующего кода этот шаблон функции временно объявляется &lt;code&gt;@trusted pure&lt;/code&gt; до тех пор, пока реализация не будет приведена в соответствие с современными ожиданиями D.</target>
        </trans-unit>
        <trans-unit id="54aa9e4c989c8754e09bfc948cb90d22fd4c28bf" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">Этот шаблон функции был перенесен из гораздо более раннего хука среды выполнения, который обошел проверки безопасности, чистоты и проверки на отказоустойчивость. Чтобы предотвратить нарушение существующего кода, этот шаблон функции временно объявляется &lt;code&gt;@trusted&lt;/code&gt; , пока реализация не будет приведена в соответствие с современными ожиданиями D.</target>
        </trans-unit>
        <trans-unit id="c6faa363e2dc5b5097ffda67002301974586de4b" translate="yes" xml:space="preserve">
          <source>This function transforms &lt;code&gt;decimal&lt;/code&gt; value into a value in the factorial number system stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="translated">Эта функция преобразует &lt;code&gt;decimal&lt;/code&gt; значение в значение в системе факторных чисел, сохраненной в &lt;code&gt;fac&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8756d8490c0c80f8a3d6e17d81badb070e1ac3c5" translate="yes" xml:space="preserve">
          <source>This function uses a search with policy &lt;code&gt;sp&lt;/code&gt; to find the largest left subrange on which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly smaller than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция использует поиск с политикой &lt;code&gt;sp&lt;/code&gt; , чтобы найти самый большой левый поддиапазон, для которого &lt;code&gt;pred(x, value)&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;x&lt;/code&gt; (например, если &lt;code&gt;pred&lt;/code&gt; &quot;меньше чем&quot;, возвращает часть диапазона с элементами, строго меньшими &lt;code&gt;value&lt;/code&gt; ). Расписание поиска и его сложность задокументированы в &lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4d6e17a7f140767c7776fa94ca98edbcfe8ab26" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded array as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">Эта функция будет принимать на вход неверно закодированный массив.Если в начале строки найдена некорректная последовательность,то данная функция удалит ее и вернет значение INVALID_SEQUENCE.</target>
        </trans-unit>
        <trans-unit id="b3cc6b0a88ba3b96758bad3549ef80853faeb94e" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded string as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">Эта функция будет принимать на вход некорректно закодированную строку.Если в начале строки найдена некорректная последовательность,то данная функция удалит ее и вернет значение INVALID_SEQUENCE.</target>
        </trans-unit>
        <trans-unit id="b4c790e3c00edf06c3c523e9a96acaa7028222ba" translate="yes" xml:space="preserve">
          <source>This function will also strip &lt;code&gt;\n\r&lt;/code&gt;.</source>
          <target state="translated">Эта функция также удалит &lt;code&gt;\n\r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b84c3cd64925b3bc63cc6da8970f088bb9f6ed" translate="yes" xml:space="preserve">
          <source>This function will be called when an exception is constructed. The user-supplied trace handler will be called if one has been supplied, otherwise no trace will be generated.</source>
          <target state="translated">Эта функция будет вызвана при построении исключения.Пользовательский обработчик трасс будет вызван,если одна из них была поставлена,иначе никакая трасса не будет сгенерирована.</target>
        </trans-unit>
        <trans-unit id="5d78c169d84f9e0fc354575058eb3e604cfbfdad" translate="yes" xml:space="preserve">
          <source>This function will be called with elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="translated">Эта функция будет вызываться с элементами &lt;code&gt;inputRange&lt;/code&gt; постепенно по мере продолжения итерации.</target>
        </trans-unit>
        <trans-unit id="68ba6b0b259ab19a35f9197082fe2ab6d70f5d70" translate="yes" xml:space="preserve">
          <source>This function will generate a module called &lt;code&gt;__entrypoint&lt;/code&gt;, and set the globals &lt;code&gt;entrypoint&lt;/code&gt; and &lt;code&gt;rootHasMain&lt;/code&gt;.</source>
          <target state="translated">Эта функция сгенерирует модуль с именем &lt;code&gt;__entrypoint&lt;/code&gt; и установит глобальную &lt;code&gt;entrypoint&lt;/code&gt; и &lt;code&gt;rootHasMain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc2b9580fcf2b39177541158722d4ae408a87a59" translate="yes" xml:space="preserve">
          <source>This function works by splitting the range to be reduced into work units, which are slices to be reduced in parallel. Once the results from all work units are computed, a final serial reduction is performed on these results to compute the final answer. Therefore, care must be taken to choose the seed value appropriately.</source>
          <target state="translated">Эта функция работает путем разделения диапазона,который должен быть сокращен,на рабочие блоки,которые являются срезами,которые должны быть сокращены параллельно.После расчета результатов по всем рабочим единицам,на этих результатах выполняется окончательное последовательное уменьшение,чтобы рассчитать окончательный ответ.Поэтому следует позаботиться о правильном выборе значения посевного материала.</target>
        </trans-unit>
        <trans-unit id="d3aad905401dc04f581b2c6077d97923bbd2a8dd" translate="yes" xml:space="preserve">
          <source>This function writes the passed text and &lt;code&gt;Option&lt;/code&gt; into an output range in the manner described in the documentation of function &lt;code&gt;defaultGetoptPrinter&lt;/code&gt;.</source>
          <target state="translated">Эта функция записывает переданный текст и &lt;code&gt;Option&lt;/code&gt; в выходной диапазон способом, описанным в документации к функции &lt;code&gt;defaultGetoptPrinter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="055b5453fa39d56b283008b9edaf05dd119fac56" translate="yes" xml:space="preserve">
          <source>This functions is equivalent to &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt;.</source>
          <target state="translated">Эта функция эквивалентна &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3de8acad7b682bb3660ea91b4edba8b390f1f531" translate="yes" xml:space="preserve">
          <source>This functions is used at runtime to determine if a &lt;code&gt;LogLevel&lt;/code&gt; is active. The same previously defined version statements are used to disable certain levels. Again the version statements are associated with a compile unit and can therefore not disable logging in other compile units. pure bool isLoggingEnabled()(LogLevel ll) @safe nothrow @nogc</source>
          <target state="translated">Эта функция используется во время выполнения, чтобы определить, &lt;code&gt;LogLevel&lt;/code&gt; ли LogLevel . Те же ранее определенные операторы версии используются для отключения определенных уровней. Опять же, операторы версии связаны с модулем компиляции и поэтому не могут отключить ведение журнала в других модулях компиляции. чистый бул isLoggingEnabled () (LogLevel ll) @safe nothrow @nogc</target>
        </trans-unit>
        <trans-unit id="9f907426d2ef951648d87f5cd993e54c9a2f733d" translate="yes" xml:space="preserve">
          <source>This functions returns a trace handler, allowing to inspect the current stack trace.</source>
          <target state="translated">Эта функция возвращает обработчик трассы,позволяя проверить текущую трассу стека.</target>
        </trans-unit>
        <trans-unit id="84eb391f18a28223816cf561bff30465c4000886" translate="yes" xml:space="preserve">
          <source>This gets replaced by the number of local bytes in the local stack frame. It is most handy when the &lt;code&gt;naked&lt;/code&gt; is invoked and a custom stack frame is programmed.</source>
          <target state="translated">Это заменяется количеством локальных байтов в кадре локального стека. Это наиболее удобно, когда вызывается &amp;laquo; &lt;code&gt;naked&lt;/code&gt; и программируется пользовательский кадр стека.</target>
        </trans-unit>
        <trans-unit id="e8e4bebddf13552333bc85ebe7b11a4e7247c831" translate="yes" xml:space="preserve">
          <source>This handle is used to specify the process in OS-specific APIs. On POSIX, this function returns a &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; with the same value as &lt;a href=&quot;#Pid.processID&quot;&gt;&lt;code&gt;Pid.processID&lt;/code&gt;&lt;/a&gt;, while on Windows it returns a &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt;.</source>
          <target state="translated">Этот дескриптор используется для указания процесса в специфичных для ОС API. В POSIX эта функция возвращает &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; с тем же значением, что и &lt;a href=&quot;#Pid.processID&quot;&gt; &lt;code&gt;Pid.processID&lt;/code&gt; &lt;/a&gt; , а в Windows возвращает &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33c852a0522cad2c2b4928299e850452d227ef5f" translate="yes" xml:space="preserve">
          <source>This handler overrides any legacy module unit tester set by the moduleUnitTester property.</source>
          <target state="translated">Этот обработчик переопределяет любой унаследованный тестер модулей,установленный свойством moduleUnitTester.</target>
        </trans-unit>
        <trans-unit id="c35e1bd5e0e6a04521fa5520ade57041fbf6240b" translate="yes" xml:space="preserve">
          <source>This hasher is compatible with the &lt;code&gt;Digest&lt;/code&gt; API:</source>
          <target state="translated">Этот хешер совместим с &lt;code&gt;Digest&lt;/code&gt; API:</target>
        </trans-unit>
        <trans-unit id="3993e1a9197061dc1bf704959d048cb51b8578f3" translate="yes" xml:space="preserve">
          <source>This implements a standard critical section.</source>
          <target state="translated">Здесь реализуется стандартная критическая секция.</target>
        </trans-unit>
        <trans-unit id="e2f62226ce4de7b0f3cba225bd19bb063907d826" translate="yes" xml:space="preserve">
          <source>This initialization is done before any constructors are called.</source>
          <target state="translated">Эта инициализация выполняется до того,как будут вызваны какие-либо конструкторы.</target>
        </trans-unit>
        <trans-unit id="2e9f56ef2bea3abd9b78b212cb634ac700d5b66a" translate="yes" xml:space="preserve">
          <source>This instance needs an identifier for name mangling purposes. Create one by taking the template declaration name and adding the type signature for it.</source>
          <target state="translated">Этому экземпляру нужен идентификатор для целей искажения имени.Создайте его,взяв имя шаблонного объявления и добавив для него подпись типа.</target>
        </trans-unit>
        <trans-unit id="912f09d79c05dc09ba32bc17497f7cccd43f92de" translate="yes" xml:space="preserve">
          <source>This is a D version 2 compiler</source>
          <target state="translated">Это компилятор D версии 2</target>
        </trans-unit>
        <trans-unit id="e5c32108063ea48a95f2ccade44899e02af1ccaa" translate="yes" xml:space="preserve">
          <source>This is a best-effort implementation of &lt;code&gt;length&lt;/code&gt; for any kind of range.</source>
          <target state="translated">Это наилучшая реализация &lt;code&gt;length&lt;/code&gt; для любого диапазона.</target>
        </trans-unit>
        <trans-unit id="05c823d62e8c286f879871b1e12c6f9007211866" translate="yes" xml:space="preserve">
          <source>This is a compiler magic function - it doesn't behave like regular D functions.</source>
          <target state="translated">Это волшебная функция компилятора-она ведет себя не так,как обычные функции D.</target>
        </trans-unit>
        <trans-unit id="b09964b15b26c39a9ce61274e2f775777d6323e9" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC32 implementation.</source>
          <target state="translated">Это псевдоним удобства для &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; ,&lt;/a&gt; использующего реализацию CRC32.</target>
        </trans-unit>
        <trans-unit id="512068cf15e63810e132140770d7648100089a8e" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ECMA implementation.</source>
          <target state="translated">Это псевдоним удобства для &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; ,&lt;/a&gt; использующего реализацию CRC64-ECMA.</target>
        </trans-unit>
        <trans-unit id="b3d4ec4ec88de63e322958e6b0d979a689b11d53" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the MD5 implementation.</source>
          <target state="translated">Это псевдоним удобства для &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; ,&lt;/a&gt; использующего реализацию MD5.</target>
        </trans-unit>
        <trans-unit id="bd636dcefd273f520355be9a0afa2783ad66dbef" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the RIPEMD160 implementation.</source>
          <target state="translated">Это псевдоним удобства для &lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; ,&lt;/a&gt; использующего реализацию RIPEMD160.</target>
        </trans-unit>
        <trans-unit id="29b73ef07a42490f2884582abd8be259990a85c2" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ISO implementation.</source>
          <target state="translated">Это псевдоним удобства для &lt;a href=&quot;std_digest_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest.digest&lt;/code&gt; ,&lt;/a&gt; использующего реализацию CRC64-ISO.</target>
        </trans-unit>
        <trans-unit id="69463742eb10b8885c85b63b60e71b70ccfdbb6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function similar to &lt;a href=&quot;#digest&quot;&gt;&lt;code&gt;digest&lt;/code&gt;&lt;/a&gt;, but it returns the string representation of the hash. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">Это удобная функция, похожая на &lt;a href=&quot;#digest&quot;&gt; &lt;code&gt;digest&lt;/code&gt; &lt;/a&gt; , но она возвращает строковое представление хэша. Каждый дайджест, прошедший тест &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; ,&lt;/a&gt; может использоваться с этой функцией.</target>
        </trans-unit>
        <trans-unit id="d797c320e5f08f4ede0b091329f09c40bcd4c23b" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate a hash using the template API. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">Это удобная функция для вычисления хэша с использованием шаблона API. Каждый дайджест, прошедший тест &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; ,&lt;/a&gt; может использоваться с этой функцией.</target>
        </trans-unit>
        <trans-unit id="c5b7feb30ef91eb966259d553831f946792e76d5" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate the hash of a value using the OOP API.</source>
          <target state="translated">Это удобная функция для вычисления хэша значения с помощью ООП API.</target>
        </trans-unit>
        <trans-unit id="3fbe8b98c7fb42d7985a89e6cebbca4b22e50702" translate="yes" xml:space="preserve">
          <source>This is a convenience function which returns an initialized digest, so it's not necessary to call start manually.</source>
          <target state="translated">Это удобная функция,которая возвращает инициализированный дайджест,поэтому нет необходимости вызывать запуск вручную.</target>
        </trans-unit>
        <trans-unit id="b07fdbfd8e90c114315c0c22212b8f6590899cf6" translate="yes" xml:space="preserve">
          <source>This is a dmd specific setting.</source>
          <target state="translated">Это настройка,специфичная для dmd.</target>
        </trans-unit>
        <trans-unit id="87a04bae60dfddd5f321bbf38e370a4d6f98d8c6" translate="yes" xml:space="preserve">
          <source>This is a full list of Unicode properties accessible through &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; with specific helpers per category nested within. Consult the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR utility&lt;/a&gt; when in doubt about the contents of a particular set.</source>
          <target state="translated">Это полный список свойств Юникода, доступных через &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; с конкретными помощниками для каждой категории, вложенной в нее. Проконсультируйтесь с &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;утилитой CLDR,&lt;/a&gt; если сомневаетесь в содержании определенного набора.</target>
        </trans-unit>
        <trans-unit id="3c8f19a42bba7727a8ce8284636a08320c4e65f1" translate="yes" xml:space="preserve">
          <source>This is a general replacement tool that construct a new string by replacing matches of pattern &lt;code&gt;re&lt;/code&gt; in the &lt;code&gt;input&lt;/code&gt;. Unlike the other overload there is no format string instead captures are passed to to a user-defined functor &lt;code&gt;fun&lt;/code&gt; that returns a new string to use as replacement.</source>
          <target state="translated">Это общий инструмент замены, который создает новую строку путем замены совпадений pattern &lt;code&gt;re&lt;/code&gt; во &lt;code&gt;input&lt;/code&gt; . В отличие от другой перегрузки нет строка формата , а не захватывает передаются в определенный пользователем функтор &lt;code&gt;fun&lt;/code&gt; , что возвращает новую строку для использования в качестве замены.</target>
        </trans-unit>
        <trans-unit id="48a52f467fdd89c347f6d4a8f50f81ff656d5562" translate="yes" xml:space="preserve">
          <source>This is a great way to implement simple circular buffers.</source>
          <target state="translated">Это отличный способ реализации простых круговых буферов.</target>
        </trans-unit>
        <trans-unit id="02adbf08da9a4c46841118c88fd0ba75eb2c489f" translate="yes" xml:space="preserve">
          <source>This is a less strict parser compared to the parser used in the UUID constructor. It enforces the following rules:</source>
          <target state="translated">Это менее строгий парсер по сравнению с парсером,используемым в конструкторе UUID.Он обеспечивает соблюдение следующих правил:</target>
        </trans-unit>
        <trans-unit id="ecac55bd6998bb669ca8527fad92e747f31aecf4" translate="yes" xml:space="preserve">
          <source>This is a low-level messaging API upon which more structured or restrictive APIs may be built. The general idea is that every messageable entity is represented by a common handle type called a Tid, which allows messages to be sent to logical threads that are executing in both the current process and in external processes using the same interface. This is an important aspect of scalability because it allows the components of a program to be spread across available resources with few to no changes to the actual implementation.</source>
          <target state="translated">Это низкоуровневый API для обмена сообщениями,на основе которого могут быть построены более структурированные или ограничительные API.Общая идея заключается в том,что каждая сущность сообщения представлена общим типом handle,называемым Tid,который позволяет посылать сообщения логическим потокам,выполняющимся как в текущем процессе,так и во внешних процессах с помощью одного и того же интерфейса.Это важный аспект масштабируемости,так как позволяет распределить компоненты программы по доступным ресурсам с минимальными изменениями фактической реализации.</target>
        </trans-unit>
        <trans-unit id="c99b5a617247c271e1cb66e28acf2ff8127a04e2" translate="yes" xml:space="preserve">
          <source>This is a magic return code for the write callback that, when returned, will signal libcurl to pause receiving on the current transfer.</source>
          <target state="translated">Это волшебный код возврата для письменного обратного вызова,который при возвращении будет сигнализировать libcurl о приостановке приема на текущей передаче.</target>
        </trans-unit>
        <trans-unit id="8a547f3bc057670af878d63b618663f30d9c888a" translate="yes" xml:space="preserve">
          <source>This is a number that uniquely identifies the process on the operating system, for at least as long as the process is running. Once &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; has been called on the &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt;, this method will return an invalid (negative) process ID.</source>
          <target state="translated">Это число, которое однозначно идентифицирует процесс в операционной системе, по крайней мере, в течение всего процесса. Как только &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; было &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; , этот метод возвратит недопустимый (отрицательный) идентификатор процесса.</target>
        </trans-unit>
        <trans-unit id="2ba143cb17d230b35dd3e77b4d46b42bf59cd667" translate="yes" xml:space="preserve">
          <source>This is a port of &lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt; boost.uuid&lt;/a&gt; from the Boost project with some minor additions and API changes for a more D-like API.</source>
          <target state="translated">Это порт &lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt;boost.uuid&lt;/a&gt; из проекта Boost с некоторыми незначительными дополнениями и изменениями API для более D-подобного API.</target>
        </trans-unit>
        <trans-unit id="3639c2b895158186c93cfc3d4a942fd3a8a4bcfc" translate="yes" xml:space="preserve">
          <source>This is a public domain version of qsort.d. All it does is call C's qsort().</source>
          <target state="translated">Это общедоступная версия qsort.d.Все,что он делает,это вызывает C's qsort().</target>
        </trans-unit>
        <trans-unit id="2506c523fc3fb4d236735f105644ec414dfd3b6c" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will const signal libcurl to pause sending data on the current transfer.</source>
          <target state="translated">Это код возврата для прочитанного обратного вызова,который при возврате будет вызывать сигнал libcurl,чтобы приостановить отправку данных о текущей передаче.</target>
        </trans-unit>
        <trans-unit id="a5f3cb2b8bae68d0d790adf6bf0c62982e12ad3f" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will signal libcurl to immediately abort the current transfer.</source>
          <target state="translated">Это код возврата для прочитанного обратного вызова,который при возвращении будет сигнализировать libcurl о немедленном прерывании текущей передачи.</target>
        </trans-unit>
        <trans-unit id="0df6a7dff27cb6ce3775bea09f58211a06e0fa4d" translate="yes" xml:space="preserve">
          <source>This is a shell around a back end symbol</source>
          <target state="translated">Это оболочка вокруг символа задней части</target>
        </trans-unit>
        <trans-unit id="dc048af9db69350bf7d515c9bc813c09c6660d30" translate="yes" xml:space="preserve">
          <source>This is a shell containing a TraitsExp that can be either resolved to a type or to a symbol.</source>
          <target state="translated">Это оболочка,содержащая TraitsExp,которая может быть преобразована в тип или в символ.</target>
        </trans-unit>
        <trans-unit id="5ad2832faed57297a9408dcd8abe79e66f2c28ae" translate="yes" xml:space="preserve">
          <source>This is a simplified declaration of the &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt;&lt;code&gt;NSString&lt;/code&gt;&lt;/a&gt; class. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt; method allocates an instance of the class. The &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt;&lt;code&gt;initWithUTF8String:&lt;/code&gt;&lt;/a&gt; method will be used to convert a C string in UTF-8 to an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; method is used to release an deallocate the string. Since D doesn't support &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; it's needed to manually release Objective-C instances.</source>
          <target state="translated">Это упрощенное объявление класса &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt; &lt;code&gt;NSString&lt;/code&gt; &lt;/a&gt; . Метод &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; выделяет экземпляр класса. &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt; &lt;code&gt;initWithUTF8String:&lt;/code&gt; &lt;/a&gt; метод будет использоваться для преобразования строки C в UTF-8 в строку Objective-C, &lt;code&gt;NSString&lt;/code&gt; . Метод &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; используется для освобождения освобождения строки. Поскольку D не поддерживает &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; , необходимо вручную выпускать экземпляры Objective-C.</target>
        </trans-unit>
        <trans-unit id="9b885a66018a314237093b8fb5cb095cdbb3b8c2" translate="yes" xml:space="preserve">
          <source>This is a special compiler recognized attribute, it has several requirements, which all will be enforced by the compiler:</source>
          <target state="translated">Это специальный распознаваемый компилятором атрибут,у него есть несколько требований,которые все будут выполняться компилятором:</target>
        </trans-unit>
        <trans-unit id="ae39fd6f553ae7cbf7dc06cf4c01bdb3470af4ef" translate="yes" xml:space="preserve">
          <source>This is a speed optimization, a good guess at the maximum size of the resulting buffer will improve performance by eliminating reallocations and copying.</source>
          <target state="translated">Это оптимизация скорости,хорошая догадка при максимальном размере результирующего буфера улучшит производительность за счет устранения релокаций и копирования.</target>
        </trans-unit>
        <trans-unit id="35d1d3de86a677e769796c4bc667e5033e36cade" translate="yes" xml:space="preserve">
          <source>This is a strict parser. It only accepts the pattern above. It doesn't support any leading or trailing characters. It only accepts characters used for hex numbers and the string must have hyphens exactly like above.</source>
          <target state="translated">Это строгий парсер.Он принимает только вышеприведенный образец.Он не поддерживает ни ведущие,ни следящие символы.Он принимает только символы,используемые для шестнадцатеричных чисел,и строка должна иметь дефисы в точности такие же,как и выше.</target>
        </trans-unit>
        <trans-unit id="5ae5fdcefc9284313dd41ba3b8a3e36e9a73a45c" translate="yes" xml:space="preserve">
          <source>This is a subclass of ElementParser. Most of the useful functions are documented there.</source>
          <target state="translated">Это подкласс ElementParser.Там документировано большинство полезных функций.</target>
        </trans-unit>
        <trans-unit id="f2e662785d1d5993dfe200ed0cd32d243953366c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic algorithms that implement set operations.</source>
          <target state="translated">Это подмодуль &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; . Он содержит универсальные алгоритмы, которые реализуют операции над множествами.</target>
        </trans-unit>
        <trans-unit id="e1b41f495bf4c79d2ddcbf0100179c8d893eed73" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic comparison algorithms.</source>
          <target state="translated">Это подмодуль &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; . Он содержит общие алгоритмы сравнения.</target>
        </trans-unit>
        <trans-unit id="7b5ed9bdf36ce4d3eb2f4fa31e710341bfe1a347" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic iteration algorithms.</source>
          <target state="translated">Это подмодуль &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; . Он содержит общие итерационные алгоритмы.</target>
        </trans-unit>
        <trans-unit id="a1ca49a48babc2bf7a88dc2f9edada29da0b74aa" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic mutation algorithms.</source>
          <target state="translated">Это подмодуль &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; . Он содержит общие алгоритмы мутации.</target>
        </trans-unit>
        <trans-unit id="9256c3179b28cb98f2ccafcbf01fa1114c7ffabd" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic searching algorithms.</source>
          <target state="translated">Это подмодуль &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; . Содержит общие алгоритмы поиска.</target>
        </trans-unit>
        <trans-unit id="d621cd2fb3907321fd3307426e0197b19ae1cd6c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic sorting algorithms.</source>
          <target state="translated">Это подмодуль &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; . Содержит общие алгоритмы сортировки.</target>
        </trans-unit>
        <trans-unit id="1a6a835a510bef24f9a4d09ad766e6b4789c5a10" translate="yes" xml:space="preserve">
          <source>This is accessible via the ClassData, but since it is frequently needed directly (like for rtti comparisons), make it directly accessible.</source>
          <target state="translated">Это доступно через ClassData,но так как это часто необходимо напрямую (как для сравнения rtti),сделайте это напрямую доступным.</target>
        </trans-unit>
        <trans-unit id="7c814acc56ca032045c3a40a509dc625dc91c4d4" translate="yes" xml:space="preserve">
          <source>This is actually what &lt;a href=&quot;#byLine&quot;&gt;&lt;code&gt;byLine&lt;/code&gt;&lt;/a&gt; does internally, so its usage is recommended if you want to process a complete file.</source>
          <target state="translated">Это фактически то, что делает &lt;a href=&quot;#byLine&quot;&gt; &lt;code&gt;byLine&lt;/code&gt; &lt;/a&gt; внутри, поэтому его использование рекомендуется, если вы хотите обработать полный файл.</target>
        </trans-unit>
        <trans-unit id="43e213b7894a106692ed41475e921810e2f2ef96" translate="yes" xml:space="preserve">
          <source>This is an</source>
          <target state="translated">Это</target>
        </trans-unit>
        <trans-unit id="d562af56401d0e00dc584df85564d362806b263a" translate="yes" xml:space="preserve">
          <source>This is an advanced type manipulation necessary e.g. for replacing the placeholder type &lt;code&gt;This&lt;/code&gt; in &lt;a href=&quot;std_variant#Algebraic&quot;&gt;&lt;code&gt;std.variant.Algebraic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это расширенная манипуляция с типом, необходимая, например, для замены типа заполнителя &lt;code&gt;This&lt;/code&gt; в &lt;a href=&quot;std_variant#Algebraic&quot;&gt; &lt;code&gt;std.variant.Algebraic&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3325f1bf2305c77a1849c9f8a9c2843663095726" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt;, see there for more information.</source>
          <target state="translated">Это псевдоним для &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt; , смотрите там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="991e65c6e6968487ccb7bb69ca7320b94e4ca93f" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt;, see there for more information.</source>
          <target state="translated">Это псевдоним для &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt; , смотрите там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b4ce5ff6ecd05c751170313d80d40096c853a878" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt;, see there for more information.</source>
          <target state="translated">Это псевдоним для &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt; , см. Там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d9558990a88eaad4533f53210d24e334b473686d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt;, see there for more information.</source>
          <target state="translated">Это псевдоним для &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt; , смотрите там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="57c783fecd68424a831ee827a2afa820a6eb2e72" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt;, see there for more information.</source>
          <target state="translated">Это псевдоним для &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt; , смотрите там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c0181596da443b5ba169ba47d5e2dd20f026611e" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt;, see there for more information.</source>
          <target state="translated">Это псевдоним для &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt; , смотрите там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7d3c5e22d15f79f627e001b482acc6838518ff93" translate="yes" xml:space="preserve">
          <source>This is an example Scheduler that mirrors the default scheduling behavior of creating one kernel thread per call to spawn. It is fully functional and may be instantiated and used, but is not a necessary part of the default functioning of this module.</source>
          <target state="translated">Это пример Scheduler,который зеркально отражает поведение планирования по умолчанию создания одного потока ядра на вызов порождения.Он полностью функционален и может быть инстанцирован и использован,но не является необходимой частью работы этого модуля по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6ff549d63c3ff212a46a7da946a73dffb4f080d9" translate="yes" xml:space="preserve">
          <source>This is an example scheduler that creates a new Fiber per call to spawn and multiplexes the execution of all fibers within the main thread.</source>
          <target state="translated">Это пример планировщика,который создает новый Fiber per call to spawn и мультиплексирует выполнение всех волокон внутри основного потока.</target>
        </trans-unit>
        <trans-unit id="9b07c47f7921db818ae08b3487fd61d30861252d" translate="yes" xml:space="preserve">
          <source>This is an infinite range, so it is never empty.</source>
          <target state="translated">Это бесконечный диапазон,так что он никогда не бывает пустым.</target>
        </trans-unit>
        <trans-unit id="12f3a1e35d9244804e6a51ca5a2db8f208c379f7" translate="yes" xml:space="preserve">
          <source>This is an interface to the libcurl library.</source>
          <target state="translated">Это интерфейс к библиотеке libcurl.</target>
        </trans-unit>
        <trans-unit id="0ecf41c17b4ddd40e8365245329f080912127dd4" translate="yes" xml:space="preserve">
          <source>This is an overload of &lt;code&gt;translate&lt;/code&gt; which takes an existing buffer to write the contents to.</source>
          <target state="translated">Это перегрузка &lt;code&gt;translate&lt;/code&gt; , которая использует существующий буфер для записи содержимого.</target>
        </trans-unit>
        <trans-unit id="1ecb65db27289cae51fc17448747e90751d9751d" translate="yes" xml:space="preserve">
          <source>This is by design. During construction the &lt;code&gt;Variant&lt;/code&gt; needs static type information about the type being held, so as to store a pointer to function for fast retrieval.</source>
          <target state="translated">Это по замыслу. Во время построения &lt;code&gt;Variant&lt;/code&gt; требуется статическая информация о типе, который хранится, чтобы хранить указатель на функцию для быстрого поиска.</target>
        </trans-unit>
        <trans-unit id="60ab54d413619310ad332327e4504502f2306f23" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.compare(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">Это называется TypeInfo.compare(p1,p2).Если структура не поддерживает сравнение const объектов,то во время выполнения будет выброшена ошибка &quot;not implemented&quot;.</target>
        </trans-unit>
        <trans-unit id="c89ac618e64974e5137c2fd8360adb505768057f" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.equals(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">Это называется TypeInfo.equals(p1,p2).Если структура не поддерживает сравнение const объектов,то во время выполнения будет выброшена ошибка &quot;not implemented&quot;.</target>
        </trans-unit>
        <trans-unit id="165808d159b6f286bb50d6195dc7d22725a89812" translate="yes" xml:space="preserve">
          <source>This is called for a delete statement where the value being deleted is a pointer to a struct with a destructor but doesn't have an overloaded delete operator.</source>
          <target state="translated">Вызывается оператор delete,в котором удаляемое значение является указателем на структуру с деструктором,но не имеет перегруженного оператора delete.</target>
        </trans-unit>
        <trans-unit id="252a57647acdf0a645523b6daf74e75444387572" translate="yes" xml:space="preserve">
          <source>This is designed for efficient memory reuse with some value-semantics structs, eg. &lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt;&lt;code&gt;std.bigint.BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это разработано для эффективного повторного использования памяти с некоторыми структурами семантики значения, например. &lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt; &lt;code&gt;std.bigint.BigInt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06ae0b36fee3b8fd0ea0e39cba211a57066e0aad" translate="yes" xml:space="preserve">
          <source>This is done by matching the C compiler's data types, layouts, and function call/return sequences.</source>
          <target state="translated">Это делается путем сопоставления типов данных C-компилятора,компоновок и последовательностей вызова/возврата функций.</target>
        </trans-unit>
        <trans-unit id="11029a896ea23a30143fb56e21fe3c178f1a4a41" translate="yes" xml:space="preserve">
          <source>This is especially useful for adding/removing attributes to/from types in generic code, where the actual type name cannot be spelt out.</source>
          <target state="translated">Это особенно полезно для добавления/удаления атрибутов к/от типов в общем коде,где реальное имя типа не может быть прописано.</target>
        </trans-unit>
        <trans-unit id="b13063fd35605a68f66f22b807caf15b21927ce2" translate="yes" xml:space="preserve">
          <source>This is especially useful when used with inheritance. For example, you might want to implement a final base method which returns a derived class type. Typically you would return a base type, but this won't allow you to call or access derived properties of the type:</source>
          <target state="translated">Это особенно полезно при использовании с наследством.Например,можно реализовать конечный базовый метод,который возвращает тип производного класса.Обычно вы возвращаете базовый тип,но это не позволяет вызывать или получать доступ к производным свойствам этого типа:</target>
        </trans-unit>
        <trans-unit id="33a5219de6733b72248cb459ae3c108de0b27b6d" translate="yes" xml:space="preserve">
          <source>This is for cases where you need a value representing the OS at runtime. If you're doing something which should compile differently on different OSes, then please use &lt;code&gt;version (Windows)&lt;/code&gt;, &lt;code&gt;version (linux)&lt;/code&gt;, etc.</source>
          <target state="translated">Это для случаев, когда вам нужно значение, представляющее ОС во время выполнения. Если вы делаете что-то, что должно по-разному компилироваться в разных ОС, тогда, пожалуйста, используйте &lt;code&gt;version (Windows)&lt;/code&gt; , &lt;code&gt;version (linux)&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="9085623d5748a41a60ced02ac9ea7374a5eb5654" translate="yes" xml:space="preserve">
          <source>This is generally fine, and by its very nature, converting from system ticks to any type of seconds (hnsecs, nsecs, etc.) will introduce rounding errors, but if code needs to avoid any of the small rounding errors introduced by conversion, then it needs to use MonoTime's &lt;code&gt;ticks&lt;/code&gt; property and keep all calculations in ticks rather than using &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как правило, это нормально, и по самой своей природе преобразование системных тиков в любой тип секунд (hnsecs, nsecs и т. Д.) Приведет к ошибкам округления, но если в коде необходимо избежать каких-либо небольших ошибок округления, возникающих при преобразовании, то он должен использовать свойство &lt;code&gt;ticks&lt;/code&gt; MonoTime и хранить все расчеты в тиках, а не использовать &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88fe60e9205a837e1c893e74b0d472fd048224ed" translate="yes" xml:space="preserve">
          <source>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of x is exactly 0.5. If using the default rounding mode (ties round to even integers) lrint(4.5) == 4, lrint(5.5)==6.</source>
          <target state="translated">Обычно это самый быстрый метод преобразования числа с плавающей точкой в целое число.Обратите внимание,что результаты этой функции зависят от режима округления,если дробная часть x точно равна 0.5.Если используется режим округления по умолчанию (связывает округление с четными целыми числами)lrint(4.5)==4,lrint(5.5)==6.</target>
        </trans-unit>
        <trans-unit id="f53ca66b2923ca36935e7ce2bb35685de87690d9" translate="yes" xml:space="preserve">
          <source>This is intended for cases where you need to deal with endianness at runtime. If you're doing something which should compile differently depending on whether you're compiling on a big endian or little endian machine, then please use &lt;code&gt;version (BigEndian)&lt;/code&gt; and &lt;code&gt;version (LittleEndian)&lt;/code&gt;.</source>
          <target state="translated">Это предназначено для случаев, когда вам нужно иметь дело с порядком байтов во время выполнения. Если вы делаете что-то, что должно компилироваться по-разному, в зависимости от того, выполняете ли вы компиляцию на машине с &lt;code&gt;version (BigEndian)&lt;/code&gt; или маленьким порядком байтов, пожалуйста, используйте версию (BigEndian) и &lt;code&gt;version (LittleEndian)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b3b92fb9499542d848207397387795d022c0de6" translate="yes" xml:space="preserve">
          <source>This is intended to be called at the start of the program to yield all scheduling to the active Scheduler instance. This is necessary for schedulers that explicitly dispatch threads rather than simply relying on the operating system to do so, and so start should always be called within main() to begin normal program execution.</source>
          <target state="translated">Это предназначено для вызова при запуске программы,чтобы уступить все планирование активному экземпляру Scheduler.Это необходимо для планировщиков,которые явно распределяют потоки,а не просто полагаются на операционную систему,поэтому для начала нормального выполнения программы start всегда должен вызываться в main().</target>
        </trans-unit>
        <trans-unit id="168edfe34c09b55f1deed4c37990e3c71a1ca3c1" translate="yes" xml:space="preserve">
          <source>This is more efficient than testing each bit in a sparsely populated bit set. Note that the first bit in the bit set would be bit 0.</source>
          <target state="translated">Это более эффективно,чем тестирование каждого бита в малонаселенном наборе битов.Обратите внимание,что первым битом в наборе битов будет бит 0.</target>
        </trans-unit>
        <trans-unit id="8fcde002524d5c331c8548b6dca27a95656e7bce" translate="yes" xml:space="preserve">
          <source>This is most handy when the array indices are given by enums:</source>
          <target state="translated">Это наиболее удобно,когда индексы массивов задаются перечислениями:</target>
        </trans-unit>
        <trans-unit id="c31ac80c96aa26f46ec6ee9192e9e74924da45e0" translate="yes" xml:space="preserve">
          <source>This is needed because AssignExp rewrites CommaExp, hence it needs to trigger the deprecation.</source>
          <target state="translated">Это необходимо,потому что AssignExp переписывает CommaExp,а значит,он должен инициировать депрессию.</target>
        </trans-unit>
        <trans-unit id="e7738cc186f07169467da57ea636fc910ff8ff41" translate="yes" xml:space="preserve">
          <source>This is not recursive; it will not search for symbols within symbols such as nested structs or unions.</source>
          <target state="translated">Это не рекурсивное средство;оно не будет искать символы внутри символов,таких как вложенные структуры или союзы.</target>
        </trans-unit>
        <trans-unit id="79018f9004b6204ff482d1449a187f60021b161a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;takeWhile&lt;/code&gt; in other languages.</source>
          <target state="translated">Это похоже на &lt;code&gt;takeWhile&lt;/code&gt; на других языках.</target>
        </trans-unit>
        <trans-unit id="da1506be46b53535dcad92fb4d88063b66606cfa" translate="yes" xml:space="preserve">
          <source>This is so we can slice a TypeTuple</source>
          <target state="translated">Это для того,чтобы мы могли нарезать кортеж TypeTuple.</target>
        </trans-unit>
        <trans-unit id="1ea183190e1a8d4a5c65894e3d7aa69b999c8015" translate="yes" xml:space="preserve">
          <source>This is the D way, and is used consistently in the D runtime library and examples.</source>
          <target state="translated">Это путь D,и он последовательно используется в библиотеке времени исполнения D и в примерах.</target>
        </trans-unit>
        <trans-unit id="b87f9cb349c407cc69c74e007c81d9397e42baeb" translate="yes" xml:space="preserve">
          <source>This is the FILE * or void * the regular output should be written to.</source>
          <target state="translated">Это ФАЙЛ*или пустота *,в который должен быть записан регулярный вывод.</target>
        </trans-unit>
        <trans-unit id="e03f57cd49f977fe295ada31586860acb7b55e0d" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the socket callback</source>
          <target state="translated">Это аргумент,переданный на обратный вызов сокета.</target>
        </trans-unit>
        <trans-unit id="be469fab3c85ca74b768977fadfadf33a82814bf" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the timer callback</source>
          <target state="translated">Это аргумент,переданный на обратный вызов таймера.</target>
        </trans-unit>
        <trans-unit id="47d1ba0ce023e632a01bb533e80836298674478a" translate="yes" xml:space="preserve">
          <source>This is the date and time when the full source package was created. The timestamp is not stored in git, as the timestamp is properly set in the tarballs by the maketgz script.</source>
          <target state="translated">Это дата и время,когда был создан полный исходный пакет.Временная метка не хранится в git'е,так как она правильно установлена в тарталлах скриптом maketgz.</target>
        </trans-unit>
        <trans-unit id="bcb4b4d07cd24ad03f4d73cf2a834d60bf057434" translate="yes" xml:space="preserve">
          <source>This is the global package copyright</source>
          <target state="translated">Это глобальный пакет авторских прав</target>
        </trans-unit>
        <trans-unit id="00bd1884cd8f1f3700cdc8b2d576c08ba85d63de" translate="yes" xml:space="preserve">
          <source>This is the length in bytes of the hash value which is returned by &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;. It's also the required size of a buffer passed to &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это длина в байтах значения хеша, которое возвращается при &lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt; . Это также необходимый размер буфера, переданного для &lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="629c1787bf8dac085ebe6f000afbc79766608202" translate="yes" xml:space="preserve">
          <source>This is the most specific allocation policy: the memory being allocated is thread local, has no indirections at all, and will not be reallocated. Examples of types fitting this description: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">Это наиболее специфическая политика выделения: выделяемая память является локальной для потока, не имеет никаких косвенных адресов и не будет перераспределена. Примеры типов, подходящих под это описание: &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;Tuple!(int, long)&lt;/code&gt; , но не &lt;code&gt;Tuple!(int, string)&lt;/code&gt; , который содержит косвенное указание.</target>
        </trans-unit>
        <trans-unit id="1d53bdfa25144b5efcd12699a648c0b943568037" translate="yes" xml:space="preserve">
          <source>This is the numeric version of the libcurl version number, meant for easier parsing and comparions by programs. The LIBCURL_VERSION_NUM define will always follow this syntax:</source>
          <target state="translated">Это числовой вариант номера версии libcurl,предназначенный для более легкого разбора и сравнения программ.Определение LIBCURL_VERSION_NUM всегда будет следовать этому синтаксису:</target>
        </trans-unit>
        <trans-unit id="f516424ebe0c21d1c77be3938d4dc4c573211582" translate="yes" xml:space="preserve">
          <source>This is the old ctor sorting algorithm that does not find all cycles.</source>
          <target state="translated">Это старый алгоритм сортировки кторов,который не находит все циклы.</target>
        </trans-unit>
        <trans-unit id="6e92c9060948634b2691b12a3f666bd6c1016991" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;getTimes&lt;/code&gt; except that it also gives you the file creation time - which isn't possible on Posix systems.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;getTimes&lt;/code&gt; , за исключением того, что оно также дает вам время создания файла - что невозможно в системах Posix.</target>
        </trans-unit>
        <trans-unit id="d8bc2540cd8cdfdea3a8a5b982374faccf0dd6c1" translate="yes" xml:space="preserve">
          <source>This is the socket callback function pointer</source>
          <target state="translated">Это указатель на функцию обратного вызова гнезда.</target>
        </trans-unit>
        <trans-unit id="61598e1f6a7ec5d30e11d3aead7284998d0c4762" translate="yes" xml:space="preserve">
          <source>This is the timer callback function pointer</source>
          <target state="translated">Это указатель функции обратного вызова таймера.</target>
        </trans-unit>
        <trans-unit id="c718912a86bcbf8011f76f57098fa90f1498a69a" translate="yes" xml:space="preserve">
          <source>This is the version number of the libcurl package from which this header file origins:</source>
          <target state="translated">Это номер версии пакета libcurl,откуда берется этот заголовочный файл:</target>
        </trans-unit>
        <trans-unit id="a98c5dbd73e5200bae0821dc0199531a02a94575" translate="yes" xml:space="preserve">
          <source>This is to support compiling expressions within the context of a function.</source>
          <target state="translated">Речь идет о поддержке компиляции выражений в контексте функции.</target>
        </trans-unit>
        <trans-unit id="1f258032a2e34908ad83c367bba4f67f9bf0d8fc" translate="yes" xml:space="preserve">
          <source>This is true even if the</source>
          <target state="translated">Это правда,даже если</target>
        </trans-unit>
        <trans-unit id="915f3d07336b61352341e4f59f1cdec1c322cabb" translate="yes" xml:space="preserve">
          <source>This is useful for:</source>
          <target state="translated">Это полезно:</target>
        </trans-unit>
        <trans-unit id="fcc8360025ee8f837157968edcf3a60c6d678ceb" translate="yes" xml:space="preserve">
          <source>This is useful in cases where the user is expected to type in one of a known set of strings, and the program will helpfully auto-complete the string once sufficient characters have been entered that uniquely identify it.</source>
          <target state="translated">Это полезно в тех случаях,когда от пользователя ожидается ввод одного из известных наборов строк,и программа с пользой выполнит автозаполнение строки после ввода достаточного количества символов,однозначно идентифицирующих ее.</target>
        </trans-unit>
        <trans-unit id="e4e34d37acfaa90ff5c5cdca9c0444e2392c7b7c" translate="yes" xml:space="preserve">
          <source>This is useful when dealing with memory-mapped I/O (MMIO) where a store can have an effect other than just writing a value, or where sequential loads with no intervening stores can retrieve different values from the same location due to external stores to the location.</source>
          <target state="translated">Это полезно при работе с отображенными на карту памяти входами/выходами (MMIO),когда хранилище может иметь эффект,отличный от простой записи значения,или когда последовательные нагрузки без вмешательства магазинов могут получать различные значения из одного и того же места из-за внешних хранилищ в это место.</target>
        </trans-unit>
        <trans-unit id="130a13f443489357f62d68edb3556823f7774c09" translate="yes" xml:space="preserve">
          <source>This is usually the default diagnostic reporter.</source>
          <target state="translated">Обычно это диагностический отчет по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6b8bd52c73d65472e04e60bf842e33bc426a473d" translate="yes" xml:space="preserve">
          <source>This is very useful as a template constraint (see examples)</source>
          <target state="translated">Это очень полезно в качестве ограничения шаблона (см.примеры).</target>
        </trans-unit>
        <trans-unit id="c9c38689ba29d74fc53f435aaf473866b312b836" translate="yes" xml:space="preserve">
          <source>This is, however, NOT equivalent to POSIX' &lt;code&gt;execv*&lt;/code&gt;. For one thing, the executed program is started as a separate process, with all this entails. Secondly, in a multithreaded program, other threads will continue to do work while the current thread is waiting for the child process to complete.  A better option may sometimes be to terminate the current program immediately after spawning the child process. This is the behaviour exhibited by the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt;&lt;code&gt;__exec&lt;/code&gt;&lt;/a&gt; functions in Microsoft's C runtime library, and it is how D's now-deprecated Windows &lt;code&gt;execv*&lt;/code&gt; functions work. Example:</source>
          <target state="translated">Это, однако, НЕ эквивалентно POSIX ' &lt;code&gt;execv*&lt;/code&gt; . Во-первых, исполняемая программа запускается как отдельный процесс, и все это влечет за собой. Во-вторых, в многопоточной программе другие потоки будут продолжать работать, пока текущий поток ожидает завершения дочернего процесса. Иногда лучшим вариантом может быть прекращение текущей программы сразу после запуска дочернего процесса. Это поведение, демонстрируемое функциями &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt; &lt;code&gt;__exec&lt;/code&gt; &lt;/a&gt; в библиотеке времени выполнения Microsoft Microsoft C, и то, как работают устаревшие функции &lt;code&gt;execv*&lt;/code&gt; Windows . Пример:</target>
        </trans-unit>
        <trans-unit id="86cd963d96c400e127b41fb5e1c683fd1645332a" translate="yes" xml:space="preserve">
          <source>This level is used to display information about the program.</source>
          <target state="translated">Этот уровень используется для отображения информации о программе.</target>
        </trans-unit>
        <trans-unit id="7bd1213d23d1dea834726c3d604226e3f0bd7985" translate="yes" xml:space="preserve">
          <source>This library provides a mechanism whereby other modules may add &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for any other encoding.</source>
          <target state="translated">Эта библиотека предоставляет механизм, посредством которого другие модули могут добавлять подклассы &lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt; для любой другой кодировки.</target>
        </trans-unit>
        <trans-unit id="a3c0ccf8cf8329e21b5b2e67a76439bedab69306" translate="yes" xml:space="preserve">
          <source>This library provides full Level 1 support* according to &lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt;. Specifically:</source>
          <target state="translated">Эта библиотека обеспечивает полную поддержку уровня 1 * в соответствии с &lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt; . В частности:</target>
        </trans-unit>
        <trans-unit id="4904626a5781bdaca7da93c6ed4103629917781b" translate="yes" xml:space="preserve">
          <source>This library supplies &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for ASCII, ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251, WINDOWS-1252, UTF-8, and (on little-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE.</source>
          <target state="translated">Эта библиотека предоставляет подклассы &lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt; для ASCII, ISO-8859-1 (также известный как LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251, WINDOWS-1252, UTF-8 и (на архитектурах с прямым порядком байтов) UTF-16LE и UTF-32LE; или (на архитектурах с прямым порядком байтов) UTF-16BE и UTF-32BE.</target>
        </trans-unit>
        <trans-unit id="2ab23006d99b3e64b2eb41b8a2440b3e86ff5b16" translate="yes" xml:space="preserve">
          <source>This library uses a remarkably common ECMAScript syntax flavor with the following extensions:</source>
          <target state="translated">Эта библиотека использует удивительно распространенный синтаксис ECMAScript со следующими расширениями:</target>
        </trans-unit>
        <trans-unit id="1d7d527b40f488b0b076be50f2a630625a4b71d6" translate="yes" xml:space="preserve">
          <source>This library will supply your function with a new instance of ElementHandler, which may be used to parse inside the element whose start tag was just found, or to identify the tag attributes of the element, etc.  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; and &amp;lt;br/&amp;gt;.</source>
          <target state="translated">Эта библиотека предоставит вашей функции новый экземпляр ElementHandler, который можно использовать для анализа внутри элемента, начальный тег которого был только что найден, или для идентификации атрибутов тега элемента и т. Д. Обратите внимание, что ваша функция будет вызываться для обоих начать теги и пустые теги. То есть мы не делаем различий между &amp;lt;br&amp;gt; &amp;lt;/br&amp;gt; и &amp;lt;br/&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="5bcb738af6294ebb159f7ef50c2f4ed098badaa1" translate="yes" xml:space="preserve">
          <source>This macro below was added in 7.16.3 to push users who recompile to use the new curl_multi_socket_action() instead of the old curl_multi_socket()</source>
          <target state="translated">Этот макрос,приведенный ниже,был добавлен в 7.16.3,чтобы подтолкнуть пользователей,которые перекомпилируют,к использованию новой функции curl_multi_socket_action()вместо старой функции curl_multi_socket().</target>
        </trans-unit>
        <trans-unit id="05317d0fb9b73229e7a4b236f6860aa4bc992df1" translate="yes" xml:space="preserve">
          <source>This makes the intent clearer, because the first statement can easily be misread as the following code:</source>
          <target state="translated">Это делает намерение более ясным,так как первое утверждение может быть легко неверно истолковано как следующий код:</target>
        </trans-unit>
        <trans-unit id="4d0a27a35faef1bf1f6ffad88638e7121e05700e" translate="yes" xml:space="preserve">
          <source>This means that pointers to elements of an &lt;code&gt;Array&lt;/code&gt; will become dangling as soon as the element is removed from the &lt;code&gt;Array&lt;/code&gt;. On the other hand the memory allocated by an &lt;code&gt;Array&lt;/code&gt; will be scanned by the GC and GC managed objects referenced from an &lt;code&gt;Array&lt;/code&gt; will be kept alive.</source>
          <target state="translated">Это означает, что указатели на элементы &lt;code&gt;Array&lt;/code&gt; станут висящими, как только элемент будет удален из &lt;code&gt;Array&lt;/code&gt; . С другой стороны, память, выделенная &lt;code&gt;Array&lt;/code&gt; будет сканироваться GC, а управляемые объекты GC, на которые есть ссылки из &lt;code&gt;Array&lt;/code&gt; будут сохранены.</target>
        </trans-unit>
        <trans-unit id="604c9cc6344fc7f1b954e8b21d2a6ca0c3ac4133" translate="yes" xml:space="preserve">
          <source>This member holds all &lt;code&gt;Logger&lt;/code&gt;s stored in the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">Этот член содержит все &lt;code&gt;Logger&lt;/code&gt; , хранящиеся в &lt;code&gt;MultiLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2222d90d3dcd66aaa74b009940ed8d8638bced76" translate="yes" xml:space="preserve">
          <source>This memoizes all values of &lt;code&gt;fact&lt;/code&gt; up to the largest argument. To only cache the final result, move &lt;code&gt;memoize&lt;/code&gt; outside the function as shown below.</source>
          <target state="translated">Это запоминает все ценности &lt;code&gt;fact&lt;/code&gt; до самого большого аргумента. Чтобы кэшировать только конечный результат, переместите &lt;code&gt;memoize&lt;/code&gt; за пределы функции, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="3a167a300836fdd4ab2e0e008d931c833538789e" translate="yes" xml:space="preserve">
          <source>This method allows expansion within the respective bucket range. It succeeds if both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;b.length + delta&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;.</source>
          <target state="translated">Этот метод позволяет расширение в пределах соответствующего диапазона ковша. &lt;code&gt;b.length&lt;/code&gt; если b.length и &lt;code&gt;b.length + delta&lt;/code&gt; попадают в диапазон вида &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4461edb18d36faaf19bc846025f3b95c67801b6c" translate="yes" xml:space="preserve">
          <source>This method allows forwarding log entries from one logger to another.</source>
          <target state="translated">Этот метод позволяет пересылать записи журнала из одного логгера в другой.</target>
        </trans-unit>
        <trans-unit id="3816a6346828017f335a6081c798a8a0dd6de4dd" translate="yes" xml:space="preserve">
          <source>This method allows reallocation within the respective bucket range. If both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;, then reallocation is in place. Otherwise, reallocation with moving is attempted.</source>
          <target state="translated">Этот метод позволяет перераспределение в пределах соответствующего диапазона сегментов. Если оба &lt;code&gt;b.length&lt;/code&gt; и &lt;code&gt;size&lt;/code&gt; падения в диапазоне от вида &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; , то перераспределение на месте. В противном случае происходит перераспределение с перемещением.</target>
        </trans-unit>
        <trans-unit id="b9a458cd0b30230c45418803529ca936bac85057" translate="yes" xml:space="preserve">
          <source>This method can be more efficient than the one in the previous example because &lt;code&gt;stdin.readln(buf)&lt;/code&gt; reuses (if possible) memory allocated for &lt;code&gt;buf&lt;/code&gt;, whereas &lt;code&gt;line = stdin.readln()&lt;/code&gt; makes a new memory allocation for every line.  For even better performance you can help &lt;code&gt;readln&lt;/code&gt; by passing in a large buffer to avoid memory reallocations. This can be done by reusing the largest buffer returned by &lt;code&gt;readln&lt;/code&gt;:</source>
          <target state="translated">Этот метод может быть более эффективным, чем в предыдущем примере, потому что &lt;code&gt;stdin.readln(buf)&lt;/code&gt; повторно использует (если возможно) память, выделенную для &lt;code&gt;buf&lt;/code&gt; , тогда как &lt;code&gt;line = stdin.readln()&lt;/code&gt; производит новое выделение памяти для каждой строки. Для еще большей производительности вы можете помочь &lt;code&gt;readln&lt;/code&gt; , передав большой буфер, чтобы избежать перераспределения памяти. Это можно сделать, повторно используя самый большой буфер, возвращаемый &lt;code&gt;readln&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f7c9ac03db99dc39088ab7814b92a020b0c3ad1" translate="yes" xml:space="preserve">
          <source>This method inserts a new Logger into the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">Этот метод вставляет новый Logger в &lt;code&gt;MultiLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e456631bd1026dc4c8384262111ee00c2ae6280" translate="yes" xml:space="preserve">
          <source>This method is defined if both allocators define it, and forwards to &lt;code&gt;SmallAllocator&lt;/code&gt; or &lt;code&gt;LargeAllocator&lt;/code&gt; appropriately.</source>
          <target state="translated">Этот метод определяется, если его определяют оба распределителя, и пересылает его в &lt;code&gt;SmallAllocator&lt;/code&gt; или &lt;code&gt;LargeAllocator&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="29c6c590b7cd5abdf60b16e55a89efa8f2694069" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it, and work similarly to &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">Этот метод определяется только в том случае, если его определяет хотя бы один из распределителей и работает аналогично &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c403891dca13c06af654365809bbef8d64860536" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt;. If &lt;code&gt; LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Этот метод определяется, только если его определяет хотя бы один из распределителей. Если &lt;code&gt;SmallAllocator&lt;/code&gt; определяет &lt;code&gt;expand&lt;/code&gt; и &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt; , вызов перенаправляется в &lt;code&gt;SmallAllocator&lt;/code&gt; . Если &lt;code&gt; LargeAllocator&lt;/code&gt; определяет &lt;code&gt;expand&lt;/code&gt; и &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt; , вызов перенаправляется в &lt;code&gt;LargeAllocator&lt;/code&gt; . В противном случае вызов возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc308051788a72be786da5419b09693d8595fa4d" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;reallocate&lt;/code&gt; and &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; SmallAllocator&lt;/code&gt;. If &lt;code&gt;LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Этот метод определяется, только если его определяет хотя бы один из распределителей. Если &lt;code&gt;SmallAllocator&lt;/code&gt; определяет &lt;code&gt;reallocate&lt;/code&gt; и &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt; , то вызов будет переадресован на &lt;code&gt; SmallAllocator&lt;/code&gt; . Если &lt;code&gt;LargeAllocator&lt;/code&gt; определяет &lt;code&gt;expand&lt;/code&gt; и &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt; , вызов перенаправляется в &lt;code&gt; LargeAllocator&lt;/code&gt; . В противном случае вызов возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620e46438ddff127931a59ae1ef3a8f250fd07f0" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. The good allocation size is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise. (If one of the allocators does not define &lt;code&gt;goodAllocSize&lt;/code&gt;, the default implementation in this module applies.)</source>
          <target state="translated">Этот метод определяется, только если его определяет хотя бы один из распределителей. Хороший размер выделения получается из &lt;code&gt;SmallAllocator&lt;/code&gt; , если &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt; , или &lt;code&gt;LargeAllocator&lt;/code&gt; в противном случае. (Если один из распределителей не определяет &lt;code&gt;goodAllocSize&lt;/code&gt; , применяется реализация по умолчанию в этом модуле.)</target>
        </trans-unit>
        <trans-unit id="d239e7b226a63994c92bb5f28f2af2cc148e0855" translate="yes" xml:space="preserve">
          <source>This method is defined only if both allocators define it. The call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt; LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">Этот метод определяется, только если оба распределителя определяют его. Вызов переадресовывается на &lt;code&gt;SmallAllocator&lt;/code&gt; , если &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt; , или &lt;code&gt; LargeAllocator&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="b5f2a8f9e894a52f7a4a03fd41c115c5a28e5d48" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;</source>
          <target state="translated">Этот метод доступен, только если базовый диапазон является &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fd044a02e3e694fc797ffa7b6155202b89056a3" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;.</source>
          <target state="translated">Этот метод доступен, только если базовый диапазон является &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;прямым диапазоном&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="832bf9b6aa94575865959f7e42866388acb50190" translate="yes" xml:space="preserve">
          <source>This method is only defined if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">Этот метод определен только , если &lt;code&gt;Allocator&lt;/code&gt; определяет &lt;code&gt;deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d110cb43a292fbf904825bc3d4bb27446be41655" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; deallocateAll&lt;/code&gt;, and calls it for each bucket in turn. Returns &lt;code&gt;true&lt;/code&gt; if all allocators could deallocate all.</source>
          <target state="translated">Этот метод определяется, только если все задействованные распределители определяют &lt;code&gt; deallocateAll&lt;/code&gt; и вызывают его для каждого сегмента по очереди. Возвращает &lt;code&gt;true&lt;/code&gt; , если все распределители могут освободить все.</target>
        </trans-unit>
        <trans-unit id="39358dd310cc162f2c05e4b4ad0f8504cf1a91af" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; resolveInternalPointer&lt;/code&gt;, and tries it for each bucket in turn.</source>
          <target state="translated">Этот метод определяется, только если все задействованные распределители определяют &lt;code&gt; resolveInternalPointer&lt;/code&gt; и пробуют его для каждого сегмента по очереди.</target>
        </trans-unit>
        <trans-unit id="9dbdb0a556e3c7305bbb92177faa9a39d0b98a27" translate="yes" xml:space="preserve">
          <source>This method logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the this &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">Этот метод записывает данные в используемый &lt;code&gt;Logger&lt;/code&gt; с &lt;code&gt;LogLevel&lt;/code&gt; этого &lt;code&gt;Logger&lt;/code&gt; в стиле &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f8a28a408a1ebec1b43e9856020fe703ce80ce" translate="yes" xml:space="preserve">
          <source>This method logs data with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Этот метод регистрирует данные с помощью &lt;code&gt;LogLevel&lt;/code&gt; используемого &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1dde3d6319c6f9ff98c98c06a035679376bc16" translate="yes" xml:space="preserve">
          <source>This method removes a Logger from the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">Этот метод удаляет Logger из &lt;code&gt;MultiLogger&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
