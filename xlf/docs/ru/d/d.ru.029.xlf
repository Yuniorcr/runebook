<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="d8b561572b4c6d9af712780047246b7bc740a0d4" translate="yes" xml:space="preserve">
          <source>Time condition enumeration as an alias of &lt;a href=&quot;etc_c_curl#CurlTimeCond&quot;&gt;&lt;code&gt;etc.c.curl.CurlTimeCond&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Перечисление временного условия как псевдоним &lt;a href=&quot;etc_c_curl#CurlTimeCond&quot;&gt; &lt;code&gt;etc.c.curl.CurlTimeCond&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4aa3d14f701bba1ce181f3ec53ab695e0ade4da" translate="yes" xml:space="preserve">
          <source>Time the file was created.</source>
          <target state="translated">Время создания файла.</target>
        </trans-unit>
        <trans-unit id="e359a0b0bd880a8c9076e3b462259fa4ca22d2f6" translate="yes" xml:space="preserve">
          <source>Time the file was last accessed.</source>
          <target state="translated">Время последнего доступа к файлу.</target>
        </trans-unit>
        <trans-unit id="36c7dbef3cde666059933c227164a5d18726f66b" translate="yes" xml:space="preserve">
          <source>Time the file was last modified.</source>
          <target state="translated">Время последнего изменения файла.</target>
        </trans-unit>
        <trans-unit id="27cd174e9f8cc698cbd69056f98a77a3a55cb471" translate="yes" xml:space="preserve">
          <source>Time the file/folder was last accessed.</source>
          <target state="translated">Время последнего доступа к файлу/папке.</target>
        </trans-unit>
        <trans-unit id="4f227039843bc9b22d4f838b81ed18e54bb7b1a9" translate="yes" xml:space="preserve">
          <source>Time the file/folder was last modified.</source>
          <target state="translated">Время последнего изменения файла/папки.</target>
        </trans-unit>
        <trans-unit id="1ea7cebe3f6da97aa7f2b8e66e161d60c16635c8" translate="yes" xml:space="preserve">
          <source>Time to set (will be saved as DosFileTime, which is less accurate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5f4600d3071981a08116aeac1a782767d2276f" translate="yes" xml:space="preserve">
          <source>Time to use with the above condition. Specified in number of seconds since 1 Jan 1970</source>
          <target state="translated">Время использования с указанным выше условием.Указано в количестве секунд с 1 января 1970 года.</target>
        </trans-unit>
        <trans-unit id="d4cc22c8986572ffe1c232ea2044aac4c6d79f91" translate="yes" xml:space="preserve">
          <source>Time units</source>
          <target state="translated">Единицы времени</target>
        </trans-unit>
        <trans-unit id="27745ce39165b24aa9162930c4465ce642154b42" translate="yes" xml:space="preserve">
          <source>Time zone is irrelevant when comparing &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Часовой пояс не имеет значения при сравнении &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="9699f4eda399b03a7b8d7d0af76df9f2a6323ecf" translate="yes" xml:space="preserve">
          <source>Time zone offsets will be in the form +HH:MM or -HH:MM.</source>
          <target state="translated">Смещения часового пояса будут в виде +HH:MM или -HH:MM.</target>
        </trans-unit>
        <trans-unit id="cbdea8478f6e24b16a22dfabfcf393abc2b6f5b4" translate="yes" xml:space="preserve">
          <source>Time zone offsets will be in the form +HHMM or -HHMM.</source>
          <target state="translated">Смещения часового пояса будут в виде +HHMM или -HHMM.</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">Временные зоны</target>
        </trans-unit>
        <trans-unit id="25ea0fb6ef66b02b90f259085a72c5aa3a1cb38b" translate="yes" xml:space="preserve">
          <source>Time-out connect operations after this amount of seconds, if connects are OK within this time, then fine... This only aborts the connect phase. [Only works on unix-style/SIGALRM operating systems]</source>
          <target state="translated">Тайм-аут операций подключения по истечении этого количества секунд,если подключения в течение этого времени в порядке,то прекрасно....Это только прерывает фазу подключения.[Работает только на операционных системах в стиле unix/SIGALRM].</target>
        </trans-unit>
        <trans-unit id="7898ff5a29bdccadbf6ffe3af05c0479d1dfccc9" translate="yes" xml:space="preserve">
          <source>Time-out the read operation after this amount of seconds</source>
          <target state="translated">Тайм-аут операции считывания после этого количества секунд.</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="931ede6287bc0e0bd7fe601fddba6e76758a6ca6" translate="yes" xml:space="preserve">
          <source>TimeOfDay &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">TimeOfDay &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1555a6cfeedd9ca84067267bcd651953c04210d9" translate="yes" xml:space="preserve">
          <source>TimeOfDay &lt;code&gt;tod&lt;/code&gt;</source>
          <target state="translated">TimeOfDay &lt;code&gt;tod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab9bed73cb84a17cfdff14b6f7c15cb12325d572" translate="yes" xml:space="preserve">
          <source>TimeZone &lt;code&gt;timezone&lt;/code&gt;</source>
          <target state="translated">TimeZone &lt;code&gt;timezone&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fda33f37c23c6bf9d7fa6e3c06b399f2722e4e9" translate="yes" xml:space="preserve">
          <source>TimeZone &lt;code&gt;tz&lt;/code&gt;</source>
          <target state="translated">TimeZone &lt;code&gt;tz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="a05f35aebea6d90bfd4a149a3c110d0ba93cf063" translate="yes" xml:space="preserve">
          <source>Timestamp for the condition  &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25&quot;&gt;RFC2616 Section 14.25&lt;/a&gt;</source>
          <target state="translated">Метка времени для условия &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25&quot;&gt;RFC2616 Раздел 14.25&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="791214dda21a45673e6a00a407416e403372c00e" translate="yes" xml:space="preserve">
          <source>Timezones</source>
          <target state="translated">Timezones</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="c554ef7e0f768a7921e2d8ca33350a8183049302" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;cache&lt;/code&gt; is eager when evaluating elements. If calling front on the underlying range has a side effect, it will be observable before calling front on the actual cached range.  Furthermore, care should be taken composing &lt;code&gt;cache&lt;/code&gt; with &lt;a href=&quot;std_range#take&quot;&gt;&lt;code&gt;std.range.take&lt;/code&gt;&lt;/a&gt;. By placing &lt;code&gt;take&lt;/code&gt; before &lt;code&gt;cache&lt;/code&gt;, then &lt;code&gt;cache&lt;/code&gt; will be &quot;aware&quot; of when the range ends, and correctly stop caching elements when needed. If calling front has no side effect though, placing &lt;code&gt;take&lt;/code&gt; after &lt;code&gt;cache&lt;/code&gt; may yield a faster range.  Either way, the resulting ranges will be equivalent, but maybe not at the same cost or side effects.</source>
          <target state="translated">Совет: &lt;code&gt;cache&lt;/code&gt; стремится к оценке элементов. Если вызов front в базовом диапазоне имеет побочный эффект, он будет заметен перед вызовом front в реальном кэшированном диапазоне. Кроме того, следует соблюдать осторожность при создании &lt;code&gt;cache&lt;/code&gt; с помощью &lt;a href=&quot;std_range#take&quot;&gt; &lt;code&gt;std.range.take&lt;/code&gt; &lt;/a&gt; . Поместив &lt;code&gt;take&lt;/code&gt; перед &lt;code&gt;cache&lt;/code&gt; , &lt;code&gt;cache&lt;/code&gt; будет &amp;laquo;знать&amp;raquo; о завершении диапазона и корректно останавливать элементы кэширования при необходимости. Если вызывающий фронт не имеет побочных эффектов, размещение &lt;code&gt;take&lt;/code&gt; after &lt;code&gt;cache&lt;/code&gt; может привести к более быстрому диапазону. В любом случае, результирующие диапазоны будут эквивалентны, но, возможно, не с той же стоимостью или побочными эффектами.</target>
        </trans-unit>
        <trans-unit id="a22acb5aeb0a04605632e4e842da9793f03544b7" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;equal&lt;/code&gt; can itself be used as a predicate to other functions. This can be very useful when the element type of a range is itself a range. In particular, &lt;code&gt;equal&lt;/code&gt; can be its own predicate, allowing range of range (of range...) comparisons.</source>
          <target state="translated">Совет: &lt;code&gt;equal&lt;/code&gt; может быть использован как предикат для других функций. Это может быть очень полезно, когда тип элемента диапазона сам по себе является диапазоном. В частности, &lt;code&gt;equal&lt;/code&gt; может быть собственный предикат, позволяющий сравнивать диапазон (диапазона) ...</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="c5a0e0828626901459115ce06aafb77df7b91db7" translate="yes" xml:space="preserve">
          <source>Titlecase_Letter</source>
          <target state="translated">Titlecase_Letter</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="6494691e25f78cf9ccf69f1c60778c2c794c2372" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="108e81f625c0fab42d496ad348b5d4bf286b22ec" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">К &lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551da37cf37171dc3ce54406334d09a8cfda8b37" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">To &lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64a71b7026dcf6ae8a460197932fea36a34976f6" translate="yes" xml:space="preserve">
          <source>To access members of an aggregate, given a pointer to the aggregate is in a register, use the &lt;code&gt;.offsetof&lt;/code&gt; property of the qualified name of the member:</source>
          <target state="translated">Чтобы получить доступ к членам агрегата, если указатель на агрегат находится в реестре, используйте свойство &lt;code&gt;.offsetof&lt;/code&gt; квалифицированного имени члена:</target>
        </trans-unit>
        <trans-unit id="acccbbe3599b947ae29100cb34a4d4f21d373721" translate="yes" xml:space="preserve">
          <source>To access them, the following import is required:</source>
          <target state="translated">Для доступа к ним необходим следующий импорт:</target>
        </trans-unit>
        <trans-unit id="e706ae3f9491e98dd5256ff2e4c4957c44c28316" translate="yes" xml:space="preserve">
          <source>To alias more than one thing at once, use &lt;a href=&quot;#AliasSeq&quot;&gt;&lt;code&gt;AliasSeq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;a href=&quot;#AliasSeq&quot;&gt; &lt;code&gt;AliasSeq&lt;/code&gt; &lt;/a&gt; псевдоним более чем одновременно, используйте AliasSeq .</target>
        </trans-unit>
        <trans-unit id="39e9b604b80a0ec5108d41826ff96040f90f8ef1" translate="yes" xml:space="preserve">
          <source>To allocate multidimensional arrays, the declaration reads in the same order as the prefix array declaration order.</source>
          <target state="translated">Для выделения многомерных массивов декларация считывается в том же порядке,что и префиксное объявление массива.</target>
        </trans-unit>
        <trans-unit id="6af61f245522dedf48b1b3d8a204655196724e93" translate="yes" xml:space="preserve">
          <source>To allocate the nested arrays, multiple arguments can be used:</source>
          <target state="translated">Для выделения вложенных массивов можно использовать несколько аргументов:</target>
        </trans-unit>
        <trans-unit id="bf5996d93a7b5a9d8df4050814c45a9661fdd6d1" translate="yes" xml:space="preserve">
          <source>To avoid dynamic binding on member function call, insert base class name before the member function name. For example:</source>
          <target state="translated">Чтобы избежать динамической привязки при вызове членской функции,вставьте имя базового класса перед именем членской функции.Например:</target>
        </trans-unit>
        <trans-unit id="df138afd646bec9cd5ef16ca5a7a9ffa6dca6b3a" translate="yes" xml:space="preserve">
          <source>To avoid performance overhead, &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bi-directionality&lt;/a&gt; is only available when &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; are true.</source>
          <target state="translated">Чтобы избежать &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt; производительности, &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;двунаправленность&lt;/a&gt; доступна только в том случае, если значения std.range.primitives.hasSlicing и &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt; имеют значение true.</target>
        </trans-unit>
        <trans-unit id="e1b64ed586a51e4f5bb9e2b8e69de6ea4cbf1eb9" translate="yes" xml:space="preserve">
          <source>To avoid this from happening, either</source>
          <target state="translated">Чтобы этого не случилось.</target>
        </trans-unit>
        <trans-unit id="fb6c2b246e5caf09e7ad4ac345e30c3e0c4946f9" translate="yes" xml:space="preserve">
          <source>To consider the base class's functions in the overload resolution process, use an</source>
          <target state="translated">Для рассмотрения функций базового класса в процессе разрешения перегрузки используйте параметр</target>
        </trans-unit>
        <trans-unit id="3cb5d4aaed3b2fe5d4443f21b6ff9f49e40d7fc2" translate="yes" xml:space="preserve">
          <source>To copy at most &lt;code&gt;n&lt;/code&gt; elements from a range, you may want to use &lt;a href=&quot;std_range#take&quot;&gt;&lt;code&gt;std.range.take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы скопировать не более &lt;code&gt;n&lt;/code&gt; элементов из диапазона, вы можете использовать &lt;a href=&quot;std_range#take&quot;&gt; &lt;code&gt;std.range.take&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d66375110d390ecdb959eb48abc4793e5606ed6b" translate="yes" xml:space="preserve">
          <source>To copy just those elements from a range that satisfy a predicate, use &lt;a href=&quot;#filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы скопировать только те элементы из диапазона, которые соответствуют предикату, используйте &lt;a href=&quot;#filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a57c46e45190814579474a4cac7131c8e3ca8e36" translate="yes" xml:space="preserve">
          <source>To create a documented unit test just add three forward slashes before the unittest block, like this:</source>
          <target state="translated">Для создания документированного юнит-теста просто добавьте три передних косых черты перед юнит-тестовым блоком,например,вот так:</target>
        </trans-unit>
        <trans-unit id="eeb898e0497caa20850f724cd4cb92b13730b597" translate="yes" xml:space="preserve">
          <source>To create a horizontal rule with hyphens, add spaces between the hyphens. Without the spaces they would be treated as the start or end of an &lt;a href=&quot;#embedded_code&quot;&gt;embedded code block&lt;/a&gt;. Note that any horizontal rule may contain spaces:</source>
          <target state="translated">Чтобы создать горизонтальное правило с дефисами, добавьте пробелы между дефисами. Без пробелов они будут рассматриваться как начало или конец &lt;a href=&quot;#embedded_code&quot;&gt;встроенного блока кода&lt;/a&gt; . Обратите внимание, что любое горизонтальное правило может содержать пробелы:</target>
        </trans-unit>
        <trans-unit id="bc19837608d956da40f53510498a517f1210860d" translate="yes" xml:space="preserve">
          <source>To customize the &lt;code&gt;Logger&lt;/code&gt; behavior, create a new &lt;code&gt;class&lt;/code&gt; that inherits from the abstract &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;class&lt;/code&gt;, and implements the &lt;code&gt;writeLogMsg&lt;/code&gt; method.</source>
          <target state="translated">Чтобы настроить поведение &lt;code&gt;Logger&lt;/code&gt; , создайте новый &lt;code&gt;class&lt;/code&gt; который наследуется от абстрактного &lt;code&gt;class&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; , и реализует метод &lt;code&gt;writeLogMsg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2abc1d47025179e8b25ad0d252e787e5f2f4b0e4" translate="yes" xml:space="preserve">
          <source>To deal with these possible errors, tedious error handling code must be added to each function call. If an error happened, code must be written to recover from the error, and the error must be reported to the user in some user friendly fashion. If an error cannot be handled locally, it must be explicitly propagated back to its caller. The long list of errno values needs to be converted into appropriate text to be displayed. Adding all the code to do this can consume a large part of the time spent coding a project - and still, if a new errno value is added to the runtime system, the old code can not properly display a meaningful error message.</source>
          <target state="translated">Для того чтобы справиться с этими возможными ошибками,необходимо добавлять к каждому вызову функции утомительный код обработки ошибок.Если произошла ошибка,код должен быть написан для восстановления после ошибки,и об ошибке необходимо сообщить пользователю в удобной для пользователя форме.Если ошибка не может быть обработана локально,она должна быть явно передана обратно вызывающему абоненту.Длинный список значений errno должен быть преобразован в соответствующий текст для отображения.Добавление всего кода для этого может занять большую часть времени,потраченного на кодирование проекта-и тем не менее,если в систему исполнения добавлено новое значение errno,старый код не сможет корректно отобразить значимое сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="0840e11f513cf9d6a67586541ed4c39bc7f43411" translate="yes" xml:space="preserve">
          <source>To define how one type can be cast to another, define the &lt;code&gt;opCast&lt;/code&gt; template method, which is used as follows:</source>
          <target state="translated">Чтобы определить, как один тип может быть приведен к другому, определите &lt;code&gt;opCast&lt;/code&gt; шаблона opCast , который используется следующим образом:</target>
        </trans-unit>
        <trans-unit id="69db67f87737bda086a681af3ab5a4a2b512d66e" translate="yes" xml:space="preserve">
          <source>To distinguish between the type of the back reference a look-up of the back referenced character is necessary: An identifier back reference always points to a digit &lt;b&gt;0&lt;/b&gt; to &lt;b&gt;9&lt;/b&gt;, while a type back reference always points to a letter.</source>
          <target state="translated">Чтобы различать тип обратной ссылки, необходим поиск обратного ссылочного символа: идентификатор обратной ссылки всегда указывает на цифру от &lt;b&gt;0&lt;/b&gt; до &lt;b&gt;9&lt;/b&gt; , в то время как обратная ссылка типа всегда указывает на букву.</target>
        </trans-unit>
        <trans-unit id="04d9771dcd4d104db6559e0305a6f19443a680de" translate="yes" xml:space="preserve">
          <source>To do them all en masse:</source>
          <target state="translated">Сделать их все массово:</target>
        </trans-unit>
        <trans-unit id="dcfefb9ac665ea68efebc3194f27ebac0436a51d" translate="yes" xml:space="preserve">
          <source>To ease debugging, in a &lt;a href=&quot;version#ConditionalStatement&quot;&gt;&lt;i&gt;ConditionalStatement&lt;/i&gt;&lt;/a&gt; controlled by a &lt;a href=&quot;version#DebugCondition&quot;&gt;&lt;i&gt;DebugCondition&lt;/i&gt;&lt;/a&gt;&lt;code&gt;@nogc&lt;/code&gt; functions can call functions that are not &lt;code&gt;@nogc&lt;/code&gt;.</source>
          <target state="translated">Для облегчения отладки в &lt;a href=&quot;version#ConditionalStatement&quot;&gt;&lt;i&gt;ConditionalStatement,&lt;/i&gt;&lt;/a&gt; управляемом &lt;a href=&quot;version#DebugCondition&quot;&gt;&lt;i&gt;DebugCondition,&lt;/i&gt;&lt;/a&gt; функции &lt;code&gt;@nogc&lt;/code&gt; могут вызывать функции, которые не являются &lt;code&gt;@nogc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4c7d82f37671d49bf06ba7162803fca2ebe085" translate="yes" xml:space="preserve">
          <source>To experiment with alternative allocators, set &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt; for the current thread. For example, consider an application that allocates many 8-byte objects. These are not well supported by the default allocator, so a &lt;a href=&quot;std_experimental_allocator_building_blocks_free_list&quot;&gt;free list allocator&lt;/a&gt; would be recommended. To install one in &lt;code&gt;main&lt;/code&gt;, the application would use:</source>
          <target state="translated">Чтобы поэкспериментировать с альтернативными распределителями, установите &lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; &lt;/a&gt; для текущего потока. Например, рассмотрим приложение, которое выделяет много 8-байтовых объектов. Они плохо поддерживаются распределителем по умолчанию, поэтому рекомендуется использовать &lt;a href=&quot;std_experimental_allocator_building_blocks_free_list&quot;&gt;свободный распределитель списков&lt;/a&gt; . Чтобы установить его в &lt;code&gt;main&lt;/code&gt; , приложение будет использовать:</target>
        </trans-unit>
        <trans-unit id="8d9e12dc536b1565bc9fda436c93ff675e8dc213" translate="yes" xml:space="preserve">
          <source>To find the last occurrence of &lt;code&gt;needle&lt;/code&gt; in a &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional&lt;/a&gt;&lt;code&gt;haystack&lt;/code&gt;, call &lt;code&gt;find(retro(haystack), needle)&lt;/code&gt;. See &lt;a href=&quot;std_range#retro&quot;&gt;&lt;code&gt;std.range.retro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы найти последнее появление &lt;code&gt;needle&lt;/code&gt; в &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;двунаправленном &lt;/a&gt; &lt;code&gt;haystack&lt;/code&gt; , вызовите &lt;code&gt;find(retro(haystack), needle)&lt;/code&gt; . Смотрите &lt;a href=&quot;std_range#retro&quot;&gt; &lt;code&gt;std.range.retro&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="940d35064ca2c064467578facb6ad445a27bab6b" translate="yes" xml:space="preserve">
          <source>To gain more precise control over the logging process, additionally to overriding the &lt;code&gt;writeLogMsg&lt;/code&gt; method the methods &lt;code&gt;beginLogMsg&lt;/code&gt;, &lt;code&gt;logMsgPart&lt;/code&gt; and &lt;code&gt;finishLogMsg&lt;/code&gt; can be overridden.</source>
          <target state="translated">Для того, чтобы получить более точный контроль над процессом регистрации, дополнительно к переопределению &lt;code&gt;writeLogMsg&lt;/code&gt; метод метода &lt;code&gt;beginLogMsg&lt;/code&gt; , &lt;code&gt;logMsgPart&lt;/code&gt; и &lt;code&gt;finishLogMsg&lt;/code&gt; может быть переопределена.</target>
        </trans-unit>
        <trans-unit id="266f2a903ad8aca0a8023659715c707ee628d78a" translate="yes" xml:space="preserve">
          <source>To get a &lt;code&gt;PosixTimeZone&lt;/code&gt;, call &lt;code&gt;PosixTimeZone.getTimeZone&lt;/code&gt; (which allows specifying the location the time zone files).</source>
          <target state="translated">Чтобы получить &lt;code&gt;PosixTimeZone&lt;/code&gt; , вызовите &lt;code&gt;PosixTimeZone.getTimeZone&lt;/code&gt; (который позволяет указать местоположение файлов часового пояса).</target>
        </trans-unit>
        <trans-unit id="2ed14e678985f0d95b56a32019f42872453c2e19" translate="yes" xml:space="preserve">
          <source>To get a &lt;code&gt;WindowsTimeZone&lt;/code&gt;, call &lt;code&gt;WindowsTimeZone.getTimeZone&lt;/code&gt;.</source>
          <target state="translated">Чтобы получить &lt;code&gt;WindowsTimeZone&lt;/code&gt; , вызовите &lt;code&gt;WindowsTimeZone.getTimeZone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a52fa8889b7712f63349220576c00248419ac6ec" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">Чтобы получить разницу в годах, вычтите свойство года из двух &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; . Чтобы получить разницу в днях или неделях, &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; сами &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; и используйте полученный результат core.time.Duration . Поскольку для преобразования между месяцами и меньшими единицами требуется конкретная дата (которой нет в &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; s), для получения разницы в месяцах требуется некоторая математика с использованием свойств года и месяца, так что это удобная функция для получения разница в месяцах.</target>
        </trans-unit>
        <trans-unit id="611f6f04377a68cee3f9ad63b2b1775dac313cf8" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">Чтобы получить разницу в годах, вычтите свойство year из двух объектов &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . Чтобы получить разницу в днях или неделях, &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; сами &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; и используйте полученный результат core.time.Duration . Поскольку для преобразования между месяцами и меньшими единицами требуется конкретная дата (которой нет в &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; s), для получения разницы в месяцах требуется некоторая математика с использованием свойств года и месяца, так что это удобная функция для получения разница в месяцах.</target>
        </trans-unit>
        <trans-unit id="ca114625afe6909751302b60256cce50a6455f6b" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">Чтобы получить разницу в годах, &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; свойство year двух SysTime s. Чтобы получить разницу в днях или неделях, &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; сами значения SysTime и используйте &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; результат core.time.Duration . Поскольку для преобразования между месяцами и меньшими единицами требуется конкретная дата (которой нет в &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; s), для получения разницы в месяцах требуется некоторая математика с использованием свойств года и месяца, так что это удобная функция для получения разница в месяцах.</target>
        </trans-unit>
        <trans-unit id="9044e06c13b847070ef5dcf4834092817fbca12b" translate="yes" xml:space="preserve">
          <source>To guarantee copying behavior, use the .dup property to ensure a unique array that can be resized. Also, one may use the &lt;code&gt;.capacity&lt;/code&gt; property to determine how many elements can be appended to the array without reallocating.</source>
          <target state="translated">Чтобы гарантировать поведение при копировании, используйте свойство .dup, чтобы гарантировать уникальный массив, размер которого можно изменить. Кроме того, можно использовать свойство &lt;code&gt;.capacity&lt;/code&gt; , чтобы определить, сколько элементов можно добавить в массив без перераспределения.</target>
        </trans-unit>
        <trans-unit id="233d724da932399f4e00f061e832a34896042f59" translate="yes" xml:space="preserve">
          <source>To implement the different containers both struct and class based approaches have been used. &lt;a href=&quot;std_container_util#make&quot;&gt;&lt;code&gt;std.container.util.make&lt;/code&gt;&lt;/a&gt; allows for uniform construction with either approach.</source>
          <target state="translated">Для реализации различных контейнеров были использованы как структурные, так и классовые подходы. &lt;a href=&quot;std_container_util#make&quot;&gt; &lt;code&gt;std.container.util.make&lt;/code&gt; &lt;/a&gt; допускает однородную конструкцию с любым подходом.</target>
        </trans-unit>
        <trans-unit id="ee9b559376db4a1e8468c6848a3ba5a71bc8dfb5" translate="yes" xml:space="preserve">
          <source>To improve the speed of the factorial function,</source>
          <target state="translated">Для повышения скорости работы факториальной функции,</target>
        </trans-unit>
        <trans-unit id="4e375b9e257d51069f4250fe3867302e9a258fcf" translate="yes" xml:space="preserve">
          <source>To link D functions and libraries into C programs, it's necessary to only require the C runtime library to be linked in. This is accomplished by defining a subset of D that fits this requirement, called &lt;b&gt;BetterC&lt;/b&gt;.</source>
          <target state="translated">Чтобы связать функции и библиотеки D с программами на C, необходимо только связать библиотеку времени выполнения C. Это достигается путем определения подмножества D, которое соответствует этому требованию, называемого &lt;b&gt;BetterC&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="418e30d51bb596772e9d5629c8d43dd500ddc9a6" translate="yes" xml:space="preserve">
          <source>To maintain accuracy at values of x near 1.0, use normalDistribution(x) = 1.0 - normalDistribution(-x).</source>
          <target state="translated">Для поддержания точности при значениях x,близких к 1.0,используйте normalDistribution(x)=1.0-normalDistribution(-x).</target>
        </trans-unit>
        <trans-unit id="5b3b3d7bbc8b8e87f34fef0c04e823aed7dd8943" translate="yes" xml:space="preserve">
          <source>To make a D function accessible from C++, give it C++ linkage:</source>
          <target state="translated">Чтобы сделать функцию D доступной из C++,дайте ей ссылку C++:</target>
        </trans-unit>
        <trans-unit id="85053099cfb1e1260b205f5910c452e424126760" translate="yes" xml:space="preserve">
          <source>To make a copy of a container, use the &lt;code&gt;c.dup&lt;/code&gt; container primitive.</source>
          <target state="translated">Чтобы сделать копию контейнера, используйте &lt;code&gt;c.dup&lt;/code&gt; контейнера c.dup .</target>
        </trans-unit>
        <trans-unit id="4330151dd0a4b250164d66c145c77b530d3ed205" translate="yes" xml:space="preserve">
          <source>To make both the return type and the method immutable, you can write:</source>
          <target state="translated">Чтобы сделать и тип возврата,и метод неизменяемыми,можно написать:</target>
        </trans-unit>
        <trans-unit id="57e902cb18fc9ae8488bd57a41a216b45b84b7c6" translate="yes" xml:space="preserve">
          <source>To make the return type immutable, you need to surround the return type with parentheses:</source>
          <target state="translated">Чтобы сделать тип возврата неизменяемым,необходимо окружить тип возврата круглыми скобками:</target>
        </trans-unit>
        <trans-unit id="eb050bb6aba36c3b829cdba22de5651eceed94cb" translate="yes" xml:space="preserve">
          <source>To match the Objective-C semantics, &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; methods are virtual. &lt;code&gt;static&lt;/code&gt; methods are overridable as well.</source>
          <target state="translated">Для соответствия семантике Objective C &lt;code&gt;static&lt;/code&gt; и &lt;code&gt;final&lt;/code&gt; методы являются виртуальными. &lt;code&gt;static&lt;/code&gt; методы также могут быть переопределены.</target>
        </trans-unit>
        <trans-unit id="399f378b17e04ab3e088842cfc946bfa37190fec" translate="yes" xml:space="preserve">
          <source>To maximize efficiency, the runtime always tries to resize the array in place to avoid extra copying. It will always do a copy if the new size is larger and the array was not allocated via the new operator or resizing in place would overwrite valid data in the array. For example:</source>
          <target state="translated">Для достижения максимальной эффективности во время выполнения всегда пытаются изменить размер массива на месте,чтобы избежать дополнительного копирования.Она всегда будет делать копию,если размер new больше и массив не был выделен через оператор new,или изменение размера массива перезапишет корректные данные в массиве.Например:</target>
        </trans-unit>
        <trans-unit id="6e630a6f0fbc69f96409d719fe2bf8debbee2ea5" translate="yes" xml:space="preserve">
          <source>To memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call. For example, to transform the exponential-time Fibonacci implementation into a linear-time computation:</source>
          <target state="translated">Чтобы запомнить рекурсивную функцию,просто вставьте запомненный вызов вместо обычного рекурсивного вызова.Например,чтобы преобразовать реализацию Фибоначчи в экспоненциальное время в вычисление линейного времени:</target>
        </trans-unit>
        <trans-unit id="3516e14bd92ad99d31558a33d40a58c99908579a" translate="yes" xml:space="preserve">
          <source>To output a backslash, simply use two backslashes in a row: &lt;code&gt;\\&lt;/code&gt;. Note that backslashes inside embedded or inline code do &lt;em&gt;not&lt;/em&gt; escape punctuation and are included in the output as-is. Backslashes before non-punctation are also included in the output as-is. For example, &lt;code&gt;C:\dmd2\bin\dmd.exe&lt;/code&gt; does not require escaping its embedded backslashes.</source>
          <target state="translated">Чтобы вывести обратную косую черту, просто используйте две обратные косые черты подряд: &lt;code&gt;\\&lt;/code&gt; . Обратите внимание, что обратные слэши во встроенном или встроенном коде &lt;em&gt;не&lt;/em&gt; исключают пунктуации и включаются в вывод как есть. Обратные косые черты перед непунктуацией также включаются в вывод как есть. Например, &lt;code&gt;C:\dmd2\bin\dmd.exe&lt;/code&gt; не требует экранирования встроенной обратной косой черты.</target>
        </trans-unit>
        <trans-unit id="8f1374001cf71d8c7f16d7eec671343030bcedf0" translate="yes" xml:space="preserve">
          <source>To overload &lt;code&gt;a[]&lt;/code&gt;, simply define &lt;code&gt;opIndex&lt;/code&gt; with no parameters:</source>
          <target state="translated">Чтобы перегрузить &lt;code&gt;a[]&lt;/code&gt; , просто определите &lt;code&gt;opIndex&lt;/code&gt; без параметров:</target>
        </trans-unit>
        <trans-unit id="15d95aac44624f17ec16bbbfbc71490c6fbf287e" translate="yes" xml:space="preserve">
          <source>To overload array indexing of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Перегрузить индексирование массива формы &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="000e88e7e58bbba47a3e6a8c3ea25f6d7d08d6b5" translate="yes" xml:space="preserve">
          <source>To parallelize the copying of a range with expensive to evaluate elements to an array, pass an identity function (a function that just returns whatever argument is provided to it) to &lt;code&gt;amap&lt;/code&gt;.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside the map functions, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All currently executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown from any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">Чтобы распараллелить копирование диапазона с дорогостоящими для оценки элементами в массив, передайте функции идентификации (функцию, которая просто возвращает любой аргумент, предоставленный ей) для &lt;code&gt;amap&lt;/code&gt; . &lt;b&gt;Обработка исключений&lt;/b&gt; : Когда по крайней мере одно исключение выдается из функций карты, отправка дополнительных объектов &lt;code&gt;Task&lt;/code&gt; прекращается как можно скорее недетерминированным способом. Все выполняемые в настоящее время или поставленные в очередь рабочие блоки могут быть завершены. Затем все исключения, которые были &lt;code&gt;Throwable.next&lt;/code&gt; из любого рабочего модуля, объединяются в цепочку с помощью Throwable.next и перебрасываются. Порядок цепочки исключений является недетерминированным.</target>
        </trans-unit>
        <trans-unit id="87b4b285bca7df049293dca955a7cff806c39c54" translate="yes" xml:space="preserve">
          <source>To perform the mapping operation in place, provide the same range for the input and output range.</source>
          <target state="translated">Для выполнения операции нанесения на карту на месте необходимо обеспечить одинаковый диапазон для входного и выходного диапазонов.</target>
        </trans-unit>
        <trans-unit id="b6f84739ea0309b309811ceae01cf81f2836b095" translate="yes" xml:space="preserve">
          <source>To prevent mutation, D offers the &lt;code&gt;immutable&lt;/code&gt; type qualifier. If all of a &lt;code&gt;pure&lt;/code&gt; function's parameters are &lt;code&gt;immutable&lt;/code&gt; or copied values without any indirections (e.g. &lt;code&gt;int&lt;/code&gt;), the type system guarantees no side effects.</source>
          <target state="translated">Чтобы предотвратить мутацию, D предлагает &lt;code&gt;immutable&lt;/code&gt; квалификатор типа. Если все параметры &lt;code&gt;pure&lt;/code&gt; функции являются &lt;code&gt;immutable&lt;/code&gt; или скопированными значениями без каких-либо косвенных указаний (например, &lt;code&gt;int&lt;/code&gt; ), система типов гарантирует отсутствие побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="510e8a37c94f1fddd48f494b45f9c445ac13386e" translate="yes" xml:space="preserve">
          <source>To replace all matches use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы заменить все совпадения, используйте &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32637bfed038dc3b07de78cef61a544d88ceed68" translate="yes" xml:space="preserve">
          <source>To replace only the first match use &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для замены только первого совпадения используйте &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d699e84d4ef2358f78c4907449972ca3c8ecaf0" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;color&lt;/code&gt; to &lt;code&gt;Color.yes&lt;/code&gt;, invoke the program with either &lt;code&gt;--color=yes&lt;/code&gt; or &lt;code&gt;--color yes&lt;/code&gt;.</source>
          <target state="translated">Чтобы установить &lt;code&gt;color&lt;/code&gt; в &lt;code&gt;Color.yes&lt;/code&gt; , запустите программу с &lt;code&gt;--color=yes&lt;/code&gt; или &lt;code&gt;--color yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bda9df29c966af1a72e8a5182df74509b8e721a" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, invoke the program with either &lt;code&gt;--timeout=5&lt;/code&gt; or &lt;code&gt;--timeout 5&lt;/code&gt;.</source>
          <target state="translated">Чтобы установить время &lt;code&gt;timeout&lt;/code&gt; на &lt;code&gt;5&lt;/code&gt; , запустите программу с &lt;code&gt;--timeout=5&lt;/code&gt; или &lt;code&gt;--timeout 5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd8216ab7d939932ec00d9d6f5006763dd329753" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, use either of the following: &lt;code&gt;--timeout=5&lt;/code&gt;, &lt;code&gt;--timeout 5&lt;/code&gt;, &lt;code&gt;--t=5&lt;/code&gt;, &lt;code&gt;--t 5&lt;/code&gt;, &lt;code&gt;-t5&lt;/code&gt;, or &lt;code&gt;-t 5&lt;/code&gt;. Forms such as &lt;code&gt;-timeout=5&lt;/code&gt; will be not accepted.  For more details about short options, refer also to the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7233a698292e0a276de835ff862d037b155c9056" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, use either of the following: &lt;code&gt;--timeout=5&lt;/code&gt;, &lt;code&gt;--timeout 5&lt;/code&gt;, &lt;code&gt;--t=5&lt;/code&gt;, &lt;code&gt;--t 5&lt;/code&gt;, or &lt;code&gt;-t5&lt;/code&gt;. Forms such as &lt;code&gt;-t 5&lt;/code&gt; and &lt;code&gt;-timeout=5&lt;/code&gt; will be not accepted.  For more details about short options, refer also to the next section.</source>
          <target state="translated">Чтобы установить время &lt;code&gt;timeout&lt;/code&gt; на &lt;code&gt;5&lt;/code&gt; , используйте одно из следующих: - &lt;code&gt;--timeout=5&lt;/code&gt; , &lt;code&gt;--timeout 5&lt;/code&gt; , &lt;code&gt;--t=5&lt;/code&gt; , &lt;code&gt;--t 5&lt;/code&gt; или &lt;code&gt;-t5&lt;/code&gt; . Такие формы, как &lt;code&gt;-t 5&lt;/code&gt; и &lt;code&gt;-timeout=5&lt;/code&gt; , не будут приняты. Подробнее о коротких опциях см. Также в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="ddaae0a344d10b36be801991a765088949e60549" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;verbose&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, invoke the program with either &lt;code&gt;--verbose&lt;/code&gt; or &lt;code&gt;--verbose=true&lt;/code&gt;.  To set &lt;code&gt;debugging&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, invoke the program with &lt;code&gt;--debugging=false&lt;/code&gt;.</source>
          <target state="translated">Чтобы установить для &lt;code&gt;verbose&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; , вызовите программу с помощью &lt;code&gt;--verbose&lt;/code&gt; или &lt;code&gt;--verbose=true&lt;/code&gt; . Чтобы установить для &lt;code&gt;debugging&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;--debugging=false&lt;/code&gt; программу с параметром --debugging = false .</target>
        </trans-unit>
        <trans-unit id="90aeb9b368ec13053b28da39579d017a147e76dd" translate="yes" xml:space="preserve">
          <source>To solve the fragile base class problem, instance variables in Objective-C has a dynamic offset. That means that the base class can change (add or remove instance variables) without the subclasses needing to recompile or relink. Thanks to this feature it's not necessary to declare instance variables when creating bindings to Objective-C classes.</source>
          <target state="translated">Для решения хрупкой проблемы базового класса,переменные экземпляра в Objective-C имеют динамическое смещение.Это означает,что базовый класс может изменяться (добавлять или удалять переменные экземпляра)без необходимости перекомпиляции или перекомпоновки подклассов.Благодаря этому нет необходимости объявлять переменные экземпляра при создании привязки к классам Objective-C.</target>
        </trans-unit>
        <trans-unit id="120e7e0cecbea01188056698938dba51c73d2ca2" translate="yes" xml:space="preserve">
          <source>To understand what &lt;code&gt;gapWeightedSimilarity(s, t, lambda)&lt;/code&gt; computes, consider first the case &lt;code&gt;lambda = 1&lt;/code&gt; and the strings &lt;code&gt;s = [&quot;Hello&quot;, &quot;brave&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; and &lt;code&gt;t = [&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt;. In that case, &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; counts the following matches:</source>
          <target state="translated">Чтобы понять, что &lt;code&gt;gapWeightedSimilarity(s, t, lambda)&lt;/code&gt; , рассмотрим сначала случай &lt;code&gt;lambda = 1&lt;/code&gt; и строки &lt;code&gt;s = [&quot;Hello&quot;, &quot;brave&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; и &lt;code&gt;t = [&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; . В этом случае &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; считает следующие совпадения:</target>
        </trans-unit>
        <trans-unit id="94904fa76d4f11340da03fec0a15c494a85ffea1" translate="yes" xml:space="preserve">
          <source>To units</source>
          <target state="translated">К подразделениям</target>
        </trans-unit>
        <trans-unit id="b3ba6419dc9ea2b78f83db771b45536f87338e59" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;isInstanceOf&lt;/code&gt; to check the identity of a template while inside of said template, use &lt;a href=&quot;#TemplateOf&quot;&gt;&lt;code&gt;TemplateOf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы использовать &lt;code&gt;isInstanceOf&lt;/code&gt; для проверки идентичности шаблона внутри указанного шаблона, используйте &lt;a href=&quot;#TemplateOf&quot;&gt; &lt;code&gt;TemplateOf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ccc24a097574057226e86500cf33d397fb42f61" translate="yes" xml:space="preserve">
          <source>To use a different comparison than &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;, pass a different operator string that can be used by &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, or pass in a function, delegate, functor, or any type where &lt;code&gt;less(a, b)&lt;/code&gt; results in a &lt;code&gt;bool&lt;/code&gt; value.</source>
          <target state="translated">Чтобы использовать другой , чем сравнение &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; , передать другую строку оператора , который может быть использован &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; , или передать в функции, делегат, функтор, или любого типа , где &lt;code&gt;less(a, b)&lt;/code&gt; приводит к &lt;code&gt;bool&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="ec17d2b0393d701bb378fb92b5f34cc43ec1456a" translate="yes" xml:space="preserve">
          <source>To use it:</source>
          <target state="translated">Чтобы использовать его:</target>
        </trans-unit>
        <trans-unit id="ccbeeee07e1df8ffe8c8184d16795dcbbad96d59" translate="yes" xml:space="preserve">
          <source>To use the registered GC, it's name must be specified gcopt runtime option, e.g. by passing &lt;em&gt;, --DRT-gcopt=gc:my_gc_name&lt;/em&gt; as application argument.</source>
          <target state="translated">Чтобы использовать зарегистрированный GC, в его имени должна быть указана опция времени выполнения gcopt, например, путем передачи &lt;em&gt;--DRT-gcopt = gc: my_gc_name в&lt;/em&gt; качестве аргумента приложения.</target>
        </trans-unit>
        <trans-unit id="66efb9234157955b960a3139060c665ce5882658" translate="yes" xml:space="preserve">
          <source>To use this template, it must first be instantiated with a specific type:</source>
          <target state="translated">Чтобы использовать этот шаблон,его необходимо сначала инстанцировать определенным типом:</target>
        </trans-unit>
        <trans-unit id="0773afb54ea37c47bd380cce3db76b12cb278887" translate="yes" xml:space="preserve">
          <source>To use, put the line: response_expand(&amp;amp;argc,&amp;amp;argv); as the first executable statement in main(int argc, char **argv). argc and argv are adjusted to be the new command line arguments after response file expansion.</source>
          <target state="translated">Чтобы использовать, поместите строку: response_expand (&amp;amp; argc, &amp;amp; argv); как первый исполняемый оператор в main (int argc, char ** argv). argc и argv корректируются, чтобы быть новыми аргументами командной строки после расширения файла ответов.</target>
        </trans-unit>
        <trans-unit id="6054d88f6fd53a5005771519db583793dcab79e9" translate="yes" xml:space="preserve">
          <source>To what precision is x equal to y?</source>
          <target state="translated">С какой точностью x равен y?</target>
        </trans-unit>
        <trans-unit id="fdebf667212089ea7017a4b5425a561bdb3a30b0" translate="yes" xml:space="preserve">
          <source>Todo</source>
          <target state="translated">Todo</target>
        </trans-unit>
        <trans-unit id="fca57aee253e291d0ee9aa5ecbb555afdc35567c" translate="yes" xml:space="preserve">
          <source>Token Strings</source>
          <target state="translated">Строки жетонов</target>
        </trans-unit>
        <trans-unit id="fed427b1f3d3ef7e65fc5054b2e5e854301b06b4" translate="yes" xml:space="preserve">
          <source>Token strings open with the characters &lt;code&gt;q&lt;/code&gt;&lt;code&gt;{&lt;/code&gt; and close with the token &lt;code&gt;}&lt;/code&gt;. In between must be valid D tokens. The &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens nest. The string is formed of all the characters between the opening and closing of the token string, including comments.</source>
          <target state="translated">Строки токена открываются символами &lt;code&gt;q&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; и закрываются токеном &lt;code&gt;}&lt;/code&gt; . Между ними должны быть действительные D токены. &lt;code&gt;{&lt;/code&gt; И &lt;code&gt;}&lt;/code&gt; жетоны гнездо. Строка состоит из всех символов между открытием и закрытием строки токена, включая комментарии.</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="052c92ab74e0edce8a8ddb051550d404ed7fea5b" translate="yes" xml:space="preserve">
          <source>Total Number Of Rows Modified</source>
          <target state="translated">Общее количество модифицированных рядов</target>
        </trans-unit>
        <trans-unit id="acfc1c14180f3c75b37d492cbf0679b8f5397d5e" translate="yes" xml:space="preserve">
          <source>Trace handler</source>
          <target state="translated">Обработчик трассировки</target>
        </trans-unit>
        <trans-unit id="339bd194ea0514f6931ef3cb54a8ab0164d4cdd4" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;core_internal_array_concat#d_arraycatnTX&quot;&gt;&lt;code&gt;core.internal.array.concat.d_arraycatnTX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обертка TraceGC вокруг &lt;a href=&quot;core_internal_array_concat#d_arraycatnTX&quot;&gt; &lt;code&gt;core.internal.array.concat.d_arraycatnTX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e0642895405b7e1549bc202853dc5cb0187b5b" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;core_internal_array_core.internal.array.capacity#d_arraysetlengthT&quot;&gt;&lt;code&gt;core.internal.array.core.internal.array.capacity.d_arraysetlengthT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обертка TraceGC вокруг &lt;a href=&quot;core_internal_array_core.internal.array.capacity#d_arraysetlengthT&quot;&gt; &lt;code&gt;core.internal.array.core.internal.array.capacity.d_arraysetlengthT&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b368b80c6345f7eb3fde3e057ff304366850fb39" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;rt_array_appending_d_arrayappendctximpl#d_arrayappendcTX&quot;&gt;&lt;code&gt;rt.array.appending.d_arrayappendcTXImpl.d_arrayappendcTX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обертка TraceGC вокруг &lt;a href=&quot;rt_array_appending_d_arrayappendctximpl#d_arrayappendcTX&quot;&gt; &lt;code&gt;rt.array.appending.d_arrayappendcTXImpl.d_arrayappendcTX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80dd4794746522d5a6319b62ffeb07ebb7212a09" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;rt_array_appending_d_arrayappendtimpl#d_arrayappendT&quot;&gt;&lt;code&gt;rt.array.appending.d_arrayappendTImpl.d_arrayappendT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обертка TraceGC вокруг &lt;a href=&quot;rt_array_appending_d_arrayappendtimpl#d_arrayappendT&quot;&gt; &lt;code&gt;rt.array.appending.d_arrayappendTImpl.d_arrayappendT&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75a5d485e29e7339691a82c35666d01ee9e99be8" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around runtime hook &lt;code&gt;Hook&lt;/code&gt;.</source>
          <target state="translated">Обертка TraceGC вокруг крючка времени выполнения &lt;code&gt;Hook&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="968e231f347833476137cde0bb130f49fd1066a0" translate="yes" xml:space="preserve">
          <source>TraceHandler &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">TraceHandler &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40795f513f85788543dae6b9a0f0c645b802b300" translate="yes" xml:space="preserve">
          <source>TraceHandler &lt;strong id=&quot;rt_getTraceHandler&quot;&gt;rt_getTraceHandler&lt;/strong&gt;();</source>
          <target state="translated">TraceHandler &lt;strong id=&quot;rt_getTraceHandler&quot;&gt;rt_getTraceHandler&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="3ff2cf2928371330c202528a4ec623af7dd4183d" translate="yes" xml:space="preserve">
          <source>TraceInfo &lt;strong id=&quot;info&quot;&gt;info&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;info&quot;&gt;Информация&lt;/strong&gt; TraceInfo ;</target>
        </trans-unit>
        <trans-unit id="97acc1b59f9ec17c88715b436c8c28883bd4892f" translate="yes" xml:space="preserve">
          <source>Tracing And Profiling Functions</source>
          <target state="translated">Функции трассировки и профилирования</target>
        </trans-unit>
        <trans-unit id="21b475fc378b9dfe253f756130d92a38d32baa27" translate="yes" xml:space="preserve">
          <source>Tracked Pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e37088abead19a42acc6c17545cb5db3148d64" translate="yes" xml:space="preserve">
          <source>Tracking progress:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f99f0c420682f802c163b96d0a0feb063b02f8" translate="yes" xml:space="preserve">
          <source>Tracking the ownership status of a pointer can be safely extended by adding the capability of temporarilly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94fe6610b8c5aab12f91b0905d8d39edb892d87" translate="yes" xml:space="preserve">
          <source>Tracks bytes currently allocated by this allocator. This number goes up and down as memory is allocated and deallocated, and is zero if the allocator currently has no active allocation.</source>
          <target state="translated">Отслеживает байты,выделенные в настоящее время этим аллокатором.Это число идет вверх и вниз по мере выделения и перераспределения памяти,и является нулевым,если аллокатор в настоящее время не имеет активного выделения.</target>
        </trans-unit>
        <trans-unit id="3ec8a086c7378a608bd7ab5887414689898832b0" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all &lt;code&gt;b.length - s&lt;/code&gt; with &lt;code&gt;b.length &amp;gt; s&lt;/code&gt; in calls of the form &lt;code&gt;realloc(b, s)&lt;/code&gt; that succeed (return &lt;code&gt;true&lt;/code&gt;). In per-call statistics, also unambiguously counts the bytes deallocated with &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">Отслеживает сумму всех &lt;code&gt;b.length - s&lt;/code&gt; с &lt;code&gt;b.length &amp;gt; s&lt;/code&gt; в вызовах вида &lt;code&gt;realloc(b, s)&lt;/code&gt; которые завершаются успешно (возвращают &lt;code&gt;true&lt;/code&gt; ). В статистике по каждому вызову также однозначно подсчитываются байты, освобожденные с помощью &lt;code&gt;deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b241e803ff9fd9ce02dd41f6d962d259eca7d1cc" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all &lt;code&gt;delta&lt;/code&gt; values in calls of the form &lt;code&gt;expand(b, delta)&lt;/code&gt; that succeed (return &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">Отслеживает сумму всех &lt;code&gt;delta&lt;/code&gt; значений в вызовах &lt;code&gt;expand(b, delta)&lt;/code&gt; формы (b, delta), которые завершаются успешно (возвращает &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5008e18d38dabcd09c748f97cdb5eb01dccc1e39" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all bytes NOT moved as result of calls to &lt;code&gt;realloc&lt;/code&gt; that managed to reallocate in place. A large number (relative to &lt;code&gt; bytesAllocated&lt;/code&gt;) indicates that the application is expansion-intensive and is saving a good amount of moves. However, if this number is relatively small and &lt;code&gt;bytesSlack&lt;/code&gt; is high, it means the application is overallocating for little benefit.</source>
          <target state="translated">Отслеживает сумму всех байтов, НЕ перемещенных в результате обращений к &lt;code&gt;realloc&lt;/code&gt; , которым удалось перераспределить на месте. Большое число (относительно &lt;code&gt; bytesAllocated&lt;/code&gt; ) указывает на то, что приложение интенсивно разворачивается и сохраняет большое количество перемещений. Однако, если это число относительно мало, а значение &lt;code&gt;bytesSlack&lt;/code&gt; высокое, это означает, что приложение перераспределяется для получения небольшой выгоды.</target>
        </trans-unit>
        <trans-unit id="7955ac7f466b43052c0744fbaca4b335f62263c8" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all bytes moved as a result of calls to &lt;code&gt;realloc&lt;/code&gt; that were unable to reallocate in place. A large number (relative to &lt;code&gt; bytesAllocated&lt;/code&gt;) indicates that the application should use larger preallocations.</source>
          <target state="translated">Отслеживает сумму всех байтов, перемещенных в результате обращений к &lt;code&gt;realloc&lt;/code&gt; , которые не смогли перераспределить на месте. Большое число (относительно &lt;code&gt; bytesAllocated&lt;/code&gt; ) указывает, что приложение должно использовать большие предварительные выделения.</target>
        </trans-unit>
        <trans-unit id="faf9f30dc9aae03a78ac2b0d759eee7f02feabde" translate="yes" xml:space="preserve">
          <source>Tracks total cumulative bytes allocated by means of &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, and &lt;code&gt;reallocate&lt;/code&gt; (when resulting in an expansion). This number always grows and indicates allocation traffic. To compute bytes deallocated cumulatively, subtract &lt;code&gt;bytesUsed&lt;/code&gt; from &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">Отслеживает общее количество накопленных байтов, выделенных с помощью функции &lt;code&gt;allocate&lt;/code&gt; , &lt;code&gt;expand&lt;/code&gt; и &lt;code&gt;reallocate&lt;/code&gt; (когда происходит расширение). Это число всегда растет и указывает на распределение трафика. Чтобы вычислить накопленные байты накопленным образом, &lt;code&gt;bytesUsed&lt;/code&gt; из &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05e8d1a3538b3e90690cad906240b5fa54e138df" translate="yes" xml:space="preserve">
          <source>Trademarks</source>
          <target state="translated">Trademarks</target>
        </trans-unit>
        <trans-unit id="09fffdd1f186dcf09acdfe5f33b486db93c4b362" translate="yes" xml:space="preserve">
          <source>Traditionally, programs accepted single-letter options preceded by only one dash (e.g. &lt;code&gt;-t&lt;/code&gt;). &lt;code&gt;getopt&lt;/code&gt; accepts such parameters seamlessly. When used with a double-dash (e.g. &lt;code&gt;--t&lt;/code&gt;), a single-letter option behaves the same as a multi-letter option. When used with a single dash, a single-letter option is accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65c761b81d8b95898721c08b732f21414baa36d" translate="yes" xml:space="preserve">
          <source>Traditionally, programs accepted single-letter options preceded by only one dash (e.g. &lt;code&gt;-t&lt;/code&gt;). &lt;code&gt;getopt&lt;/code&gt; accepts such parameters seamlessly. When used with a double-dash (e.g. &lt;code&gt;--t&lt;/code&gt;), a single-letter option behaves the same as a multi-letter option. When used with a single dash, a single-letter option is accepted. If the option has a parameter, that must be &quot;stuck&quot; to the option without any intervening space or &quot;=&quot;:</source>
          <target state="translated">Традиционно программы принимали однобуквенные опции, перед которыми стоит только одна черта (например, &lt;code&gt;-t&lt;/code&gt; ). &lt;code&gt;getopt&lt;/code&gt; принимает такие параметры без проблем. При использовании с двойной чертой (например, &lt;code&gt;--t&lt;/code&gt; ) опция с одной буквой ведет себя так же, как опция с несколькими буквами. При использовании с одним тире допускается использование одной буквы. Если в параметре есть параметр, он должен быть &amp;laquo;привязан&amp;raquo; к параметру без пробела или &amp;laquo;=&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="32a79a3c4d4b7259d08b26cc56e7bb87a9fe9843" translate="yes" xml:space="preserve">
          <source>Trailing template parameters can be given default values:</source>
          <target state="translated">Параметрам шаблона трейлинга можно дать значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="c05d0571a965a586c4e7efe02429db2afdc8c356" translate="yes" xml:space="preserve">
          <source>Trailing_Jamo</source>
          <target state="translated">Trailing_Jamo</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="3eb508881f4d401ebe62236f9dc8c80c61228925" translate="yes" xml:space="preserve">
          <source>Traits are extensions to the language to enable programs, at compile time, to get at information internal to the compiler. This is also known as compile time reflection. It is done as a special, easily extended syntax (similar to Pragmas) so that new capabilities can be added as required.</source>
          <target state="translated">Трейты-это расширения языка,позволяющие программам во время компиляции получать информацию,внутреннюю для компилятора.Это также известно как отражение времени компиляции.Это сделано в виде специального,легко расширяемого синтаксиса (по аналогии с Pragmas),чтобы при необходимости можно было добавлять новые возможности.</target>
        </trans-unit>
        <trans-unit id="45ce7caaed05d2b5c0efd3ebab2b970cdb17b248" translate="yes" xml:space="preserve">
          <source>TraitsExp &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt;;</source>
          <target state="translated">TraitsExp &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="776df5d3d02b2f2502c0ba9fde683a6ac4564118" translate="yes" xml:space="preserve">
          <source>Transfer ownership from a &lt;code&gt;Unique&lt;/code&gt; of a type that is convertible to our type.</source>
          <target state="translated">Передача права собственности от &lt;code&gt;Unique&lt;/code&gt; типа, который можно преобразовать в наш тип.</target>
        </trans-unit>
        <trans-unit id="b3f957b52d56c1cbf2d25e123eda610314928a9b" translate="yes" xml:space="preserve">
          <source>Transfer ownership to a &lt;code&gt;Unique&lt;/code&gt; rvalue. Nullifies the current contents. Same as calling std.algorithm.move on it.</source>
          <target state="translated">Передать право собственности на &lt;code&gt;Unique&lt;/code&gt; . Обнуляет текущее содержимое. То же, что и вызов std.algorithm.move для него.</target>
        </trans-unit>
        <trans-unit id="1f1886aabb4342f3629dbcd769504a41bfa676c8" translate="yes" xml:space="preserve">
          <source>Transfers execution to this fiber object. The calling context will be suspended until the fiber calls Fiber.yield() or until it terminates via an unhandled exception.</source>
          <target state="translated">Переводит выполнение на этот волоконный объект.Вызовной контекст будет приостановлен до тех пор,пока волокно не вызовет Fiber.yield()или пока оно не завершится через необработанное исключение.</target>
        </trans-unit>
        <trans-unit id="31251528682bcb8b77a91ffbd3b05ea524c5340e" translate="yes" xml:space="preserve">
          <source>Transfers ownership of the buffer to the caller.</source>
          <target state="translated">Передает право собственности на буфер вызывающему абоненту.</target>
        </trans-unit>
        <trans-unit id="188eeca51b370b3f079cb0e0ef0721398bd7bd93" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;path&lt;/code&gt; into a path relative to &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Преобразует &lt;code&gt;path&lt;/code&gt; в путь относительно &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00ded035b85d9ff7c01b323b06df130cfc1720ab" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;path&lt;/code&gt; into an absolute path.</source>
          <target state="translated">Превращает &lt;code&gt;path&lt;/code&gt; в абсолютный путь.</target>
        </trans-unit>
        <trans-unit id="34fc8e092bab0ba38ba7f911f332353c9a7c0772" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;string&lt;/code&gt; representing an expression into a binary function. The &lt;code&gt;string&lt;/code&gt; must either use symbol names &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as the parameters or provide the symbols via the &lt;code&gt;parm1Name&lt;/code&gt; and &lt;code&gt;parm2Name&lt;/code&gt; arguments.</source>
          <target state="translated">Преобразует &lt;code&gt;string&lt;/code&gt; представляющую выражение, в двоичную функцию. В &lt;code&gt;string&lt;/code&gt; символьных имен должны либо использовать &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; в качестве параметров или предоставить символы через &lt;code&gt;parm1Name&lt;/code&gt; и &lt;code&gt;parm2Name&lt;/code&gt; аргументов.</target>
        </trans-unit>
        <trans-unit id="5e4574331dd9213dff75e0c56ce82cdfa938b199" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;string&lt;/code&gt; representing an expression into a unary function. The &lt;code&gt;string&lt;/code&gt; must either use symbol name &lt;code&gt;a&lt;/code&gt; as the parameter or provide the symbol via the &lt;code&gt;parmName&lt;/code&gt; argument.</source>
          <target state="translated">Преобразует &lt;code&gt;string&lt;/code&gt; представляющую выражение, в унарную функцию. &lt;code&gt;string&lt;/code&gt; должна либо имя использование символа в качестве параметра или предоставить символ через &lt;code&gt;parmName&lt;/code&gt; аргумент. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b88afb73f270a00af5effe51e0f8272f4aa3e3a" translate="yes" xml:space="preserve">
          <source>Translate init to an &lt;code&gt;Expression&lt;/code&gt; in order to infer the type.</source>
          <target state="translated">Переведите init в &lt;code&gt;Expression&lt;/code&gt; , чтобы вывести тип.</target>
        </trans-unit>
        <trans-unit id="959a6d1def925aa5efa951960e2388ce3ff0f34b" translate="yes" xml:space="preserve">
          <source>Translate init to an &lt;code&gt;Expression&lt;/code&gt;.</source>
          <target state="translated">Переведите init в &lt;code&gt;Expression&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b87d9bdcb57690f52a1f26d8df3d98e87cf8b7e" translate="yes" xml:space="preserve">
          <source>Translates &lt;code&gt;path&lt;/code&gt; into a relative path.</source>
          <target state="translated">Переводит &lt;code&gt;path&lt;/code&gt; в относительный путь.</target>
        </trans-unit>
        <trans-unit id="98dc0425ab3f9caa6b04fd152b154f235170a331" translate="yes" xml:space="preserve">
          <source>Translation to D of Linux's melf.h</source>
          <target state="translated">Перевод на русский язык Linux's melf.h</target>
        </trans-unit>
        <trans-unit id="a4f515edfc4806822304c5e5ba93f1584400280b" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol</source>
          <target state="translated">Протокол управления передачей</target>
        </trans-unit>
        <trans-unit id="65ee3b2fd39b9602bb0e6c467c899854326f9080" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol level</source>
          <target state="translated">Уровень протокола управления передачей</target>
        </trans-unit>
        <trans-unit id="392746932775e052b533e7404ac34fc0d43420a8" translate="yes" xml:space="preserve">
          <source>Transport And Map Symbols</source>
          <target state="translated">Символы транспорта и карты</target>
        </trans-unit>
        <trans-unit id="bb1493e21daf9bc01d2c8bbab57c14f37d6e777e" translate="yes" xml:space="preserve">
          <source>Transposed!(RangeOfRanges, opt) &lt;strong id=&quot;transposed&quot;&gt;transposed&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr)</source>
          <target state="translated">Транспонировано! (RangeOfRanges, opt) &lt;strong id=&quot;transposed&quot;&gt;транспонировано&lt;/strong&gt; (TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges) (RangeOfRanges rr)</target>
        </trans-unit>
        <trans-unit id="2cb4af12ae00a70b772cd041efc803dad1d5d955" translate="yes" xml:space="preserve">
          <source>Transposes a range of ranges.</source>
          <target state="translated">Перевозит различные диапазоны.</target>
        </trans-unit>
        <trans-unit id="4bca179998de8185466d7b4948059e2b6d46a32a" translate="yes" xml:space="preserve">
          <source>Transversal!(RangeOfRanges, opt) &lt;strong id=&quot;transversal&quot;&gt;transversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr, size_t n);</source>
          <target state="translated">Transversal! (RangeOfRanges, opt) &lt;strong id=&quot;transversal&quot;&gt;transversal&lt;/strong&gt; (TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges) (RangeOfRanges rr, size_t n);</target>
        </trans-unit>
        <trans-unit id="89cf6770d26bcadaba07c91c703d1d100d7ecf19" translate="yes" xml:space="preserve">
          <source>Treap container for internal usage.</source>
          <target state="translated">Контейнер для внутреннего использования.</target>
        </trans-unit>
        <trans-unit id="0a9f92517de5b94ca2202e73bfb4ff1ae0e96219" translate="yes" xml:space="preserve">
          <source>Treat wildcard bind as AF_INET6-only</source>
          <target state="translated">Обращайтесь к wildcard связке только как AF_INET6</target>
        </trans-unit>
        <trans-unit id="2b931f6f03ddf3f11b6a931c301cd688e5837818" translate="yes" xml:space="preserve">
          <source>Treatment of invalid UTF encodings is implementation defined.</source>
          <target state="translated">Определена реализация обработки недействительных кодировок UTF.</target>
        </trans-unit>
        <trans-unit id="7ca6b4d5d472cc8ae3e80819b582f65c3b7ce26a" translate="yes" xml:space="preserve">
          <source>Triangular numbers, using function in lambda form:</source>
          <target state="translated">Треугольные числа,использующие функцию в лямбда-форме:</target>
        </trans-unit>
        <trans-unit id="9b543ca20b4da0104d2324c842cb2ec287022816" translate="yes" xml:space="preserve">
          <source>Trie</source>
          <target state="translated">Trie</target>
        </trans-unit>
        <trans-unit id="80d0235fc8480eef2ad4552832fe178049a6c3b3" translate="yes" xml:space="preserve">
          <source>Tries to receive but will give up if no matches arrive within duration. Won't wait at all if provided &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; is negative.</source>
          <target state="translated">Пытается получить, но сдается, если в течение продолжительного времени не будет найдено ни одного матча Не буду ждать вообще, если предоставлено &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; является отрицательным.</target>
        </trans-unit>
        <trans-unit id="c45198e3a1cef5be9e9ea6378e5c328265a866c6" translate="yes" xml:space="preserve">
          <source>Trigger Name Table Name</source>
          <target state="translated">Имя триггера Имя таблицы Имя</target>
        </trans-unit>
        <trans-unit id="bcd455ee5ad5e27e2fed7e5f2b4d193ba5b2dc98" translate="yes" xml:space="preserve">
          <source>Trigonometric functions on complex numbers.</source>
          <target state="translated">Тригонометрические функции на комплексных числах.</target>
        </trans-unit>
        <trans-unit id="89225146f512abd9863323c7f96ee652306f95de" translate="yes" xml:space="preserve">
          <source>Trigonometry</source>
          <target state="translated">Trigonometry</target>
        </trans-unit>
        <trans-unit id="9324b1be3eab89aaa4331826e321fe950cd6f28d" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type directly embedded in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate assignment. Elaborate assignments are introduced by defining &lt;code&gt;opAssign(typeof(this))&lt;/code&gt; or &lt;code&gt;opAssign(ref typeof(this))&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt; or when there is a compiler-generated &lt;code&gt;opAssign&lt;/code&gt;.</source>
          <target state="translated">Истинно, если &lt;code&gt;S&lt;/code&gt; или любой тип, непосредственно встроенный в представление &lt;code&gt;S&lt;/code&gt; , определяет сложное присваивание. Сложные назначения вводятся путем определения &lt;code&gt;opAssign(typeof(this))&lt;/code&gt; или &lt;code&gt;opAssign(ref typeof(this))&lt;/code&gt; для &lt;code&gt;struct&lt;/code&gt; или при наличии сгенерированного компилятором &lt;code&gt;opAssign&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="435f68d9ae71393e298d71580ab5403b39c6eeb4" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type directly embedded in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate destructor. Elaborate destructors are introduced by defining &lt;code&gt;~this()&lt;/code&gt; for a &lt;code&gt; struct&lt;/code&gt;.</source>
          <target state="translated">Истинно, если &lt;code&gt;S&lt;/code&gt; или любой другой тип, непосредственно встроенный в представление &lt;code&gt;S&lt;/code&gt; , определяет сложный деструктор. Сложные деструкторы вводятся путем определения &lt;code&gt;~this()&lt;/code&gt; для &lt;code&gt; struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a05d6bcd95b9d55e986b0af7bf4aba60806b34ed" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type embedded directly in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate copy constructor. Elaborate copy constructors are introduced by defining &lt;code&gt;this(this)&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Истинно, если &lt;code&gt;S&lt;/code&gt; или любой другой тип, встроенный непосредственно в представление &lt;code&gt;S&lt;/code&gt; , определяет сложный конструктор копирования. Сложные конструкторы копирования вводятся путем определения &lt;code&gt;this(this)&lt;/code&gt; для &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db144774838df48d1aab2237df1c1431f648dde1" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type embedded directly in the representation of &lt;code&gt;S&lt;/code&gt; defines elaborate move semantics. Elaborate move semantics are introduced by defining &lt;code&gt;opPostMove(ref typeof(this))&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Истинно, если &lt;code&gt;S&lt;/code&gt; или любой другой тип, встроенный непосредственно в представление &lt;code&gt;S&lt;/code&gt; , определяет сложную семантику перемещения. &lt;code&gt;opPostMove(ref typeof(this))&lt;/code&gt; семантика перемещения вводится путем определения opPostMove (ref typeof (this)) для &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83286feea43cbdff092efa76ecf7b71ba2f88e52" translate="yes" xml:space="preserve">
          <source>True if output is already ordered</source>
          <target state="translated">Верно,если выход уже заказан</target>
        </trans-unit>
        <trans-unit id="a07b7fa9f3e40c77f1c67f20db579672485bc6b7" translate="yes" xml:space="preserve">
          <source>True if the element existed and was successfully removed, false otherwise.</source>
          <target state="translated">Верно,если элемент существовал и был успешно удален,неверно,иначе.</target>
        </trans-unit>
        <trans-unit id="9ce4971f7bab09ad8525733035042183aaa85004" translate="yes" xml:space="preserve">
          <source>True if the instance is stopped. A stopped instance is not usable.</source>
          <target state="translated">Верно,если экземпляр остановлен.Остановленный экземпляр не может быть использован.</target>
        </trans-unit>
        <trans-unit id="a4d0aeb9232f48bb1fab12af59602ee0a168f2c0" translate="yes" xml:space="preserve">
          <source>True if this object contains valid extended grapheme cluster. Decoding primitives of this module always return a valid &lt;code&gt;Grapheme&lt;/code&gt;.</source>
          <target state="translated">Истинно, если этот объект содержит допустимый расширенный кластер графем. Примитивы декодирования этого модуля всегда возвращают правильную &lt;code&gt;Grapheme&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="741d78e7c1f0bffb06939bcb7022d56f2f3604a6" translate="yes" xml:space="preserve">
          <source>True if this set doesn't contain any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">Истинно, если этот набор не содержит &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7044bfa031ab131bad87130e1755ca8c06a8fda" translate="yes" xml:space="preserve">
          <source>True when the archive is in Zip64 format.</source>
          <target state="translated">Верно,когда архив в формате Zip64.</target>
        </trans-unit>
        <trans-unit id="874ffa7aabdfbf0f6814728e49d1e00d8b409174" translate="yes" xml:space="preserve">
          <source>True when the archive is in Zip64 format. Set this to true to force building a Zip64 archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1974cd2786d3cb97b6da102856265950ee454dc" translate="yes" xml:space="preserve">
          <source>True, when a format specifier is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcab3708f7050161a4f235596fffc4adce59593e" translate="yes" xml:space="preserve">
          <source>True, when the archive is forced to be build in Zip64 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97e9325300bbea12fb2d470b8ed9009e1a25de0" translate="yes" xml:space="preserve">
          <source>True, when the archive is in Zip64 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9be005b0435403e870851df7d4131f3a0109ac9" translate="yes" xml:space="preserve">
          <source>Trusted Functions</source>
          <target state="translated">Надежные функции</target>
        </trans-unit>
        <trans-unit id="40f12844940629afacea122912b44fee54a96dc6" translate="yes" xml:space="preserve">
          <source>Trusted functions are covariant with safe or system functions.</source>
          <target state="translated">Доверенные функции являются ковариантными с безопасными или системными функциями.</target>
        </trans-unit>
        <trans-unit id="b81cf6c642ef243859e62c2673b1273c1506df41" translate="yes" xml:space="preserve">
          <source>Trusted functions are guaranteed to not exhibit any undefined behavior if called by a safe function. Furthermore, calls to trusted functions cannot lead to undefined behavior in &lt;code&gt;@safe&lt;/code&gt; code that is executed afterwards. It is the responsibility of the programmer to ensure that these guarantees are upheld.</source>
          <target state="translated">Доверенные функции гарантированно не будут показывать неопределенного поведения при вызове безопасной функцией. Кроме того, вызовы доверенных функций не могут привести к неопределенному поведению в коде &lt;code&gt;@safe&lt;/code&gt; , который выполняется впоследствии. Программист несет ответственность за обеспечение соблюдения этих гарантий.</target>
        </trans-unit>
        <trans-unit id="e99ece345b7d4461848926cc1472e577d410e5e4" translate="yes" xml:space="preserve">
          <source>Trusted functions are marked with the &lt;code&gt;@trusted&lt;/code&gt; attribute.</source>
          <target state="translated">Доверенные функции отмечены атрибутом &lt;code&gt;@trusted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44bf3c1616a6357f7a131b6c0a39fc313c94e84c" translate="yes" xml:space="preserve">
          <source>Trusted functions may call safe, trusted, or system functions.</source>
          <target state="translated">Доверенные функции могут вызывать безопасные,доверенные или системные функции.</target>
        </trans-unit>
        <trans-unit id="459c8d9a1e6d3847007459ddd42920c4db61b906" translate="yes" xml:space="preserve">
          <source>Truth table for logical operations</source>
          <target state="translated">Таблица правды для логических операций</target>
        </trans-unit>
        <trans-unit id="13da7fbcb3f25e75b715c9fd87fc1fcc65959500" translate="yes" xml:space="preserve">
          <source>Try Statement</source>
          <target state="translated">Попробуйте заявление о проверке</target>
        </trans-unit>
        <trans-unit id="1ed4257452c884a8b0797028299d6b533a605ed8" translate="yes" xml:space="preserve">
          <source>Try to canonically compose 2 &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;. Returns the composed &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; if they do compose and dchar.init otherwise.</source>
          <target state="translated">Попробуйте канонически составить 2 &lt;a href=&quot;#Character&quot;&gt;символа&lt;/a&gt; . Возвращает составной &lt;a href=&quot;#Character&quot;&gt;символ,&lt;/a&gt; если он создает, и dchar.init в противном случае.</target>
        </trans-unit>
        <trans-unit id="af1dc631a797cf3323aa1ab6b455b4f41ff959a7" translate="yes" xml:space="preserve">
          <source>Try to compose hangul syllable out of a leading consonant (&lt;code&gt;lead&lt;/code&gt;), a &lt;code&gt;vowel&lt;/code&gt; and optional &lt;code&gt;trailing&lt;/code&gt; consonant jamos.</source>
          <target state="translated">Попытайтесь составить слог хангыль из ведущего согласного ( &lt;code&gt;lead&lt;/code&gt; ), &lt;code&gt;vowel&lt;/code&gt; и необязательного &lt;code&gt;trailing&lt;/code&gt; согласного джамо.</target>
        </trans-unit>
        <trans-unit id="2f882d1c819b2be8fca22d9247747ab281b24bcf" translate="yes" xml:space="preserve">
          <source>Try to get arg as a type.</source>
          <target state="translated">Попробуй поспорить,как тип.</target>
        </trans-unit>
        <trans-unit id="4cb5c2463fdeee729189be2318f4a45f82417dad" translate="yes" xml:space="preserve">
          <source>Try to run semantic routines. If they fail, return NULL.</source>
          <target state="translated">Попробуй выполнить семантические упражнения.Если они провалятся,верни NULL.</target>
        </trans-unit>
        <trans-unit id="2e3437da5d7c211579a17d9d89d77ab06ca5cfe0" translate="yes" xml:space="preserve">
          <source>Try to stop forgetting to remove the breakpoints from release builds.</source>
          <target state="translated">Попробуйте перестать забывать удалять точки останова из сборки релиза.</target>
        </trans-unit>
        <trans-unit id="bd89ac0e2f8d21f48d2dd844d0cfaadc52595afa" translate="yes" xml:space="preserve">
          <source>TryFinallyStatement &lt;strong id=&quot;tf&quot;&gt;tf&lt;/strong&gt;;</source>
          <target state="translated">TryFinallyStatement &lt;strong id=&quot;tf&quot;&gt;tf&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="7b1fdcae82a3bda8500a782276a90907df015b0b" translate="yes" xml:space="preserve">
          <source>TryStatement</source>
          <target state="translated">TryStatement</target>
        </trans-unit>
        <trans-unit id="db36ec316b7f2d3519063434cfdeb6b15e62e78d" translate="yes" xml:space="preserve">
          <source>Trying to use returned value will result in a &quot;Symbol Undefined&quot; error at link time.</source>
          <target state="translated">Попытка использовать возвращаемое значение приведет к ошибке &quot;Symbol Undefined&quot; во время соединения.</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="81493a4efae126007a86642029f330ea19b00d39" translate="yes" xml:space="preserve">
          <source>Tuple containing the remainder portions of r1 and r2 that were not swapped</source>
          <target state="translated">Кортеж,содержащий оставшиеся части r1 и r2,которые не были заменены.</target>
        </trans-unit>
        <trans-unit id="0334a3ee71c30886045ce944919d843672b82a98" translate="yes" xml:space="preserve">
          <source>Tuple of result identifier (possibly null) and statement. This is used to store out contracts: out(id){ ensure }</source>
          <target state="translated">Кортеж идентификатора результата (возможно,нулевой)и оператора.Используется для хранения контрактов:out(id){гарантировать }.</target>
        </trans-unit>
        <trans-unit id="fe605913e40c1b2d66822716dc9acacaef59b4a5" translate="yes" xml:space="preserve">
          <source>Tuple of values, for example &lt;code&gt;Tuple!(int, string)&lt;/code&gt; is a record that stores an &lt;code&gt;int&lt;/code&gt; and a &lt;code&gt;string&lt;/code&gt;. &lt;code&gt;Tuple&lt;/code&gt; can be used to bundle values together, notably when returning multiple values from a function. If &lt;code&gt;obj&lt;/code&gt; is a &lt;code&gt;Tuple&lt;/code&gt;, the individual members are accessible with the syntax &lt;code&gt;obj[0]&lt;/code&gt; for the first field, &lt;code&gt;obj[1]&lt;/code&gt; for the second, and so on.</source>
          <target state="translated">Кортеж значений, например, &lt;code&gt;Tuple!(int, string)&lt;/code&gt; - это запись, в которой хранятся &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;string&lt;/code&gt; . &lt;code&gt;Tuple&lt;/code&gt; можно использовать для объединения значений, особенно при возврате нескольких значений из функции. Если &lt;code&gt;obj&lt;/code&gt; является &lt;code&gt;Tuple&lt;/code&gt; , отдельные члены доступны с синтаксисом &lt;code&gt;obj[0]&lt;/code&gt; для первого поля, &lt;code&gt;obj[1]&lt;/code&gt; для второго и т. Д.</target>
        </trans-unit>
        <trans-unit id="0a9986e9aa2ae5162b29264e46abc7e827c1fef4" translate="yes" xml:space="preserve">
          <source>Tuple with the first element being the minimal amount of edits to transform s into t and the second element being the sequence of edits to effect this transformation.  Allocates GC memory for the returned EditOp[] array.</source>
          <target state="translated">Кортеж,в котором первый элемент представляет собой минимальное количество правок для преобразования s в t,а второй элемент-последовательность правок для осуществления этого преобразования.Выделяет GC память для возвращаемого массива EditOp[].</target>
        </trans-unit>
        <trans-unit id="ca82eca51bdda72eb0ed74065cca566ee0b72807" translate="yes" xml:space="preserve">
          <source>Tuple!(ElementType!Range, size_t) &lt;strong id=&quot;maxCount&quot;&gt;maxCount&lt;/strong&gt;(alias pred = &quot;a &amp;lt; b&quot;, Range)(Range range)</source>
          <target state="translated">Tuple! (ElementType! Range, size_t) &lt;strong id=&quot;maxCount&quot;&gt;maxCount&lt;/strong&gt; (псевдоним &lt;strong id=&quot;maxCount&quot;&gt;pred&lt;/strong&gt; = &quot;a &amp;lt;b&quot;, Range) (диапазон Range)</target>
        </trans-unit>
        <trans-unit id="c94a9ad6dc26bde095208b9742dea8d55cd74e36" translate="yes" xml:space="preserve">
          <source>Tuple!(ElementType!Range, size_t) &lt;strong id=&quot;minCount&quot;&gt;minCount&lt;/strong&gt;(alias pred = &quot;a &amp;lt; b&quot;, Range)(Range range)</source>
          <target state="translated">Tuple! (ElementType! Range, size_t) &lt;strong id=&quot;minCount&quot;&gt;minCount&lt;/strong&gt; (псевдоним &lt;strong id=&quot;minCount&quot;&gt;pred&lt;/strong&gt; = &quot;a &amp;lt;b&quot;, Range) (диапазон Range)</target>
        </trans-unit>
        <trans-unit id="5b8d3e9bf7e07ed5d350fa5b6dce75fa73629a67" translate="yes" xml:space="preserve">
          <source>Tuple!(InputRange1, InputRange2) &lt;strong id=&quot;moveSome&quot;&gt;moveSome&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">Кортеж! (InputRange1, InputRange2) &lt;strong id=&quot;moveSome&quot;&gt;moveSome&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 src, InputRange2 tgt)</target>
        </trans-unit>
        <trans-unit id="06252b12aadc6855e3f6a48094435d5ba0fef2ac" translate="yes" xml:space="preserve">
          <source>Tuple!(InputRange1, InputRange2) &lt;strong id=&quot;swapRanges&quot;&gt;swapRanges&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 r1, InputRange2 r2)</source>
          <target state="translated">Кортеж! (InputRange1, InputRange2) &lt;strong id=&quot;swapRanges&quot;&gt;swapRanges&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 r1, InputRange2 r2)</target>
        </trans-unit>
        <trans-unit id="bce2cc2678db91fbec2284d40957048f616f80c5" translate="yes" xml:space="preserve">
          <source>Tuple!(Module, &quot;module_&quot;, Diagnostics, &quot;diagnostics&quot;) &lt;strong id=&quot;parseModule&quot;&gt;parseModule&lt;/strong&gt;(AST = ASTCodegen)(const(char)[] fileName, const(char)[] code = null, DiagnosticReporter diagnosticReporter = defaultDiagnosticReporter);</source>
          <target state="translated">Tuple! (Модуль, &quot;module_&quot;, Диагностика, &quot;диагностика&quot;) &lt;strong id=&quot;parseModule&quot;&gt;parseModule&lt;/strong&gt; (AST = ASTCodegen) (const (char) [] имя_файла, const (char) [] код = ноль, DiagnosticReporter DiagnosticReporter = defaultDiagnosticReporter);</target>
        </trans-unit>
        <trans-unit id="ecf8ee3baa7b9c5aeb7e04fdf957e2203fbab0aa" translate="yes" xml:space="preserve">
          <source>Tuple!(Range, size_t) &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range, Ranges...)(Range haystack, Ranges needles)</source>
          <target state="translated">Кортеж! (Range, size_t) &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; (псевдоним pred = &quot;a == b&quot;, Range, Ranges ...) (Стог сена, Range, иглы)</target>
        </trans-unit>
        <trans-unit id="95cc77bd73a8dcdc8783b1903366dc167f6f0405" translate="yes" xml:space="preserve">
          <source>Tuple!(Range1, Range2) &lt;strong id=&quot;mismatch&quot;&gt;mismatch&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range1, Range2)(Range1 r1, Range2 r2)</source>
          <target state="translated">Кортеж! (Range1, Range2) &lt;strong id=&quot;mismatch&quot;&gt;несоответствие&lt;/strong&gt; (псевдоним = пред &quot;A == B&quot;, Range1, Range2) (Range1 r1, r2 Range2)</target>
        </trans-unit>
        <trans-unit id="000cf2a61823c3534d53f39458b33b8bdccf2670" translate="yes" xml:space="preserve">
          <source>Tuple!(T, &quot;x&quot;, Unqual!(ReturnType!DF), &quot;y&quot;, T, &quot;error&quot;) &lt;strong id=&quot;findLocalMin&quot;&gt;findLocalMin&lt;/strong&gt;(T, DF)(scope DF f, in T ax, in T bx, in T relTolerance = sqrt(T.epsilon), in T absTolerance = sqrt(T.epsilon))</source>
          <target state="translated">Tuple! (T, &quot;x&quot;, Unqual! (ReturnType! DF), &quot;y&quot;, T, &quot;error&quot;) &lt;strong id=&quot;findLocalMin&quot;&gt;findLocalMin&lt;/strong&gt; (T, DF) (область действия DF f, в T ax, в T bx, в T relTolerance = sqrt (T.epsilon), в T absTolerance = sqrt (T.epsilon))</target>
        </trans-unit>
        <trans-unit id="840acdf57ba98e4920f2fbec545eb130df4593a8" translate="yes" xml:space="preserve">
          <source>Tuple!(T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, R, DF)(scope DF f, in T ax, in T bx, in R fax, in R fbx);</source>
          <target state="translated">Tuple! (T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt; (T, R, DF) (область видимости DF f, в T ax, в T bx, в R fax, в R fbx);</target>
        </trans-unit>
        <trans-unit id="51994771db6a3d28fa759af046d2c850390305a5" translate="yes" xml:space="preserve">
          <source>Tuple!(T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, R, DF, DT)(scope DF f, in T ax, in T bx, in R fax, in R fbx, scope DT tolerance)</source>
          <target state="translated">Tuple! (T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt; (T, R, DF, DT) (область DF f, по оси T, по T bx, по R-факсу, по R fbx, допуск по области DT)</target>
        </trans-unit>
        <trans-unit id="639ddd2f21c13c7af4c3fc3a46fe3e1d7b82673a" translate="yes" xml:space="preserve">
          <source>Tuple!(size_t, EditOp[]) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;(alias equals = (a, b) =&amp;gt; a == b, Range1, Range2)(Range1 s, Range2 t)</source>
          <target state="translated">Кортеж! (Size_t, EditOp []) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt; (псевдоним равен = (a, b) =&amp;gt; a == b, Range1, Range2) (Range1 s, Range2 t)</target>
        </trans-unit>
        <trans-unit id="c0c86644914e59cf3e95dc2d9e3358d7adb8b024" translate="yes" xml:space="preserve">
          <source>Tuple!(size_t, EditOp[]) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;(alias equals = (a, b) =&amp;gt; a == b, Range1, Range2)(auto ref Range1 s, auto ref Range2 t)</source>
          <target state="translated">Кортеж! (Size_t, EditOp []) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt; (псевдоним равен = (a, b) =&amp;gt; a == b, Range1, Range2) (автоматическая ссылка Range1 s, автоматическая ссылка Range2 t)</target>
        </trans-unit>
        <trans-unit id="b4ce998808efbe7007c7ba094a0ff589456afbc6" translate="yes" xml:space="preserve">
          <source>TupleDeclaration &lt;strong id=&quot;isAliasThisTuple&quot;&gt;isAliasThisTuple&lt;/strong&gt;(Expression e);</source>
          <target state="translated">TupleDeclaration &lt;strong id=&quot;isAliasThisTuple&quot;&gt;isAliasThisTuple&lt;/strong&gt; (выражение e);</target>
        </trans-unit>
        <trans-unit id="80678cb1445455517d232f6976a2ee0f4da0533a" translate="yes" xml:space="preserve">
          <source>TupleForeachRet!(isStatic, isDecl) &lt;strong id=&quot;makeTupleForeach&quot;&gt;makeTupleForeach&lt;/strong&gt;(bool isStatic, bool isDecl)(Scope* sc, ForeachStatement fs, TupleForeachArgs!(isStatic, isDecl) args);</source>
          <target state="translated">TupleForeachRet! (IsStatic, isDecl) &lt;strong id=&quot;makeTupleForeach&quot;&gt;makeTupleForeach&lt;/strong&gt; (bool isStatic, bool isDecl) (Scope * sc, ForeachStatement fs, TupleForeachArgs! (IsStatic, isDecl) args);</target>
        </trans-unit>
        <trans-unit id="6584111cad42d4105dd8e9be93a1310902d91e92" translate="yes" xml:space="preserve">
          <source>Tuples of two integral offsets can be used to remove an indices range:</source>
          <target state="translated">Кортежи двух интегральных смещений могут быть использованы для удаления диапазона индексов:</target>
        </trans-unit>
        <trans-unit id="d9a474dda4f883ffd7fcbe2488c48bb66a58fbd7" translate="yes" xml:space="preserve">
          <source>Turn DT_azeros into DTcommon</source>
          <target state="translated">Превратите DT_azeros в DTcommon</target>
        </trans-unit>
        <trans-unit id="b124a21a659b94416124a0c6d11837b408eec822" translate="yes" xml:space="preserve">
          <source>Turn StringExp into Symbol.</source>
          <target state="translated">Превратите StringExp в символ.</target>
        </trans-unit>
        <trans-unit id="e5fc19e75828d2a9872def0cc347c568479bfe06" translate="yes" xml:space="preserve">
          <source>Turn bundling off (default)</source>
          <target state="translated">Выключить комплектацию (по умолчанию)</target>
        </trans-unit>
        <trans-unit id="bba5b8eb4f9f33288234c4eea8f1ef87433a4f05" translate="yes" xml:space="preserve">
          <source>Turn bundling on</source>
          <target state="translated">Включить пакетирование</target>
        </trans-unit>
        <trans-unit id="902547bf87091225cc20e88f552ffa5d6f0ad9d8" translate="yes" xml:space="preserve">
          <source>Turn case sensitivity off (default)</source>
          <target state="translated">Выключить чувствительность к регистру (по умолчанию)</target>
        </trans-unit>
        <trans-unit id="62ba7010a40283d77918d8073bba5d1ed5b505cc" translate="yes" xml:space="preserve">
          <source>Turn case sensitivity on</source>
          <target state="translated">Включить чувствительность корпуса</target>
        </trans-unit>
        <trans-unit id="74f2dbf84af28045a37d376cd4e1edd3fa01e659" translate="yes" xml:space="preserve">
          <source>Turn next token in buffer into a token.</source>
          <target state="translated">Превратите следующий токен в буфер в токен.</target>
        </trans-unit>
        <trans-unit id="5e3e0a4844ec64b01594e006a743ab91237a31f0" translate="yes" xml:space="preserve">
          <source>Turn off &lt;code&gt;STC.maybescope&lt;/code&gt; for variable &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Выключите &lt;code&gt;STC.maybescope&lt;/code&gt; для переменной &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84cccbe55a872601d865bab8ec58d82539ff0a07" translate="yes" xml:space="preserve">
          <source>Turn on wildcard matching</source>
          <target state="translated">Включить подстановочный символ</target>
        </trans-unit>
        <trans-unit id="a87d900130ba3c16a326f82759f1060e5ae35223" translate="yes" xml:space="preserve">
          <source>Turn symbol &lt;code&gt;s&lt;/code&gt; into the expression it represents.</source>
          <target state="translated">Превратите символ &lt;code&gt;s&lt;/code&gt; в выражение, которое он представляет.</target>
        </trans-unit>
        <trans-unit id="e5a454f3b1345dd58c63efa8e881a860cfb32111" translate="yes" xml:space="preserve">
          <source>Two adjacent separators are considered to surround an empty element in the split range. Use &lt;code&gt;filter!(a =&amp;gt; !a.empty)&lt;/code&gt; on the result to compress empty elements.</source>
          <target state="translated">Считается, что два соседних разделителя окружают пустой элемент в диапазоне разделения. Используйте &lt;code&gt;filter!(a =&amp;gt; !a.empty)&lt;/code&gt; для результата, чтобы сжать пустые элементы.</target>
        </trans-unit>
        <trans-unit id="e3ed11541d2964198473ed0a82426d9b49c8d63f" translate="yes" xml:space="preserve">
          <source>Two format specifiers are supported:</source>
          <target state="translated">Поддерживаются два спецификатора формата:</target>
        </trans-unit>
        <trans-unit id="f728c436a5d60ae7a74a1fb01d9c670443ddbdc1" translate="yes" xml:space="preserve">
          <source>Two functions have been added for convenience:</source>
          <target state="translated">Для удобства были добавлены две функции:</target>
        </trans-unit>
        <trans-unit id="241f31fb40e72ec287fecd2a2aa243010af09b63" translate="yes" xml:space="preserve">
          <source>Two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in different contexts, but outer context is indirectly accessible from innter context, so nested template instance &lt;code&gt;sum!(a, b)&lt;/code&gt; will capture only inner context.</source>
          <target state="translated">Две локальные переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; находятся в разных контекстах, но внешний контекст косвенно доступен из внутреннего контекста, поэтому &lt;code&gt;sum!(a, b)&lt;/code&gt; вложенного экземпляра шаблона ! ( A , b) будет охватывать только внутренний контекст.</target>
        </trans-unit>
        <trans-unit id="7344649ec3349339576b149dc016e926290914de" translate="yes" xml:space="preserve">
          <source>Two or more non-infinite forward ranges</source>
          <target state="translated">Два или более неограниченных прямых диапазона</target>
        </trans-unit>
        <trans-unit id="541bef60f707acc034ee30fb6ceb5b604a068f40" translate="yes" xml:space="preserve">
          <source>Two versions of programs are commonly built, a release build and a debug build. The debug build includes extra error checking code, test harnesses, pretty-printing code, etc. The debug statement conditionally compiles in its statement body. It is D's way of what in C is done with &lt;code&gt;#ifdef DEBUG&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; pairs.</source>
          <target state="translated">Обычно создаются две версии программ: сборка релиза и отладочная сборка. Сборка отладки включает дополнительный код проверки ошибок, тестовые наборы, симпатичный код для печати и т. Д. Оператор отладки условно компилируется в теле оператора. Это способ D того, что в C делается с парами &lt;code&gt;#ifdef DEBUG&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="96e4f0ac6a824b3c4a6ad224979d9909d711bd86" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;T&lt;/code&gt; can be one of:</source>
          <target state="translated">Тип &lt;code&gt;T&lt;/code&gt; может быть одним из:</target>
        </trans-unit>
        <trans-unit id="074961b98338169a77631354ecc98de531ee94fd" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;itype&lt;/code&gt;</source>
          <target state="translated">Введите &lt;code&gt;itype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abcae8ebd4b965d368a249e36f4d23c1e65f3bc6" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;mt&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;mt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96b17264511c000a8d2d312a068c77228139ea5b" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;stype&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;stype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b088eef787c263bc72b35d7bf8bffb02250f35af" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t1&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;t1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dce03ad43b5e48ad6926eff66da1dc0fbd992e8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t2&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;t2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f8a5d9f738e3ec7573a4c3d2bfa71c9dab55055" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c297c055e8021da1038d32c6451a431dc0cd79a4" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tfrom&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;tfrom&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be5260cde80d2a83f5fa8c9f051bba7fb9b67140" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;torig&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;torig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="265bebeeaa74df34bb2463a7ccd6495a2fd2b3e7" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tthis&lt;/code&gt;</source>
          <target state="translated">Введите &lt;code&gt;tthis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d90e13e3fed6c33599ffe3adfef07d6fecfb113f" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tto&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;tto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac37939248da7ca7fc509e594e3e1162b28e7f03" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa75b76e3b4d199eb5bf1cbe330006d90e593043" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;addStorageClass&quot;&gt;addStorageClass&lt;/strong&gt;(StorageClass stc);</source>
          <target state="translated">Тип &lt;strong id=&quot;addStorageClass&quot;&gt;addStorageClass&lt;/strong&gt; (StorageClass stc);</target>
        </trans-unit>
        <trans-unit id="d84d22937a28d260576af02a61a011cb7b2b2cc5" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;compileTypeMixin&quot;&gt;compileTypeMixin&lt;/strong&gt;(TypeMixin tm, Loc loc, Scope* sc);</source>
          <target state="translated">Тип &lt;strong id=&quot;compileTypeMixin&quot;&gt;compileTypeMixin&lt;/strong&gt; (TypeMixin tm, Loc loc, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="c24f3c59131a7c5a8bc5e783fc5e665af1b32a5e" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;getIndirection&quot;&gt;getIndirection&lt;/strong&gt;(Type t);</source>
          <target state="translated">Тип &lt;strong id=&quot;getIndirection&quot;&gt;getIndirection&lt;/strong&gt; (Тип t);</target>
        </trans-unit>
        <trans-unit id="c2b92e082fd5a3ac4a7a6baf60cbd699edacc254" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;getTypeInfoType&quot;&gt;getTypeInfoType&lt;/strong&gt;(Loc loc, Type t, Scope* sc);</source>
          <target state="translated">Тип &lt;strong id=&quot;getTypeInfoType&quot;&gt;getTypeInfoType&lt;/strong&gt; (Loc loc, Тип t, Область * sc);</target>
        </trans-unit>
        <trans-unit id="7988a8b265a00347de81079da3fe4590a68ee7ca" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;isLazyArray&quot;&gt;isLazyArray&lt;/strong&gt;();</source>
          <target state="translated">Тип &lt;strong id=&quot;isLazyArray&quot;&gt;isLazyArray&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="f4d3b40b91dc28c4e5940a35bf69a0bbb241540d" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;merge&quot;&gt;merge&lt;/strong&gt;(Type type);</source>
          <target state="translated">Тип &lt;strong id=&quot;merge&quot;&gt;слияния&lt;/strong&gt; (Type type);</target>
        </trans-unit>
        <trans-unit id="35806f9ee47f3dd812d869bb49adecc56fab810b" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;nextOf&quot;&gt;nextOf&lt;/strong&gt;();</source>
          <target state="translated">Тип &lt;strong id=&quot;nextOf&quot;&gt;nextOf&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="87e0a9680f0eea47764ac3ffa10dd8d73e88aeee" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;parameterType&quot;&gt;parameterType&lt;/strong&gt;(Parameter p);</source>
          <target state="translated">Тип &lt;strong id=&quot;parameterType&quot;&gt;параметрType&lt;/strong&gt; (параметр p);</target>
        </trans-unit>
        <trans-unit id="7016ea73ad39a852ab2478cb095dfe5d455408a3" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;stype&quot;&gt;stype&lt;/strong&gt;;</source>
          <target state="translated">Тип &lt;strong id=&quot;stype&quot;&gt;стайп&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="deae4e726d62ba433ff0fa85c1e57f1770faea08" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;tintro&quot;&gt;tintro&lt;/strong&gt;;</source>
          <target state="translated">Тип &lt;strong id=&quot;tintro&quot;&gt;тинтро&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1eadd5370543a51dcc388d2fe2066cef28052c13" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;toBasetype&quot;&gt;toBasetype&lt;/strong&gt;();</source>
          <target state="translated">Тип &lt;strong id=&quot;toBasetype&quot;&gt;toBasetype&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="a8533c3e5233456fb672ac9c547f329a114136e2" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;toHeadMutable&quot;&gt;toHeadMutable&lt;/strong&gt;();</source>
          <target state="translated">Тип &lt;strong id=&quot;toHeadMutable&quot;&gt;toHeadMutable&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="96b0f23e070ede5bec63f5e83cdeac74f8089165" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;typeSemantic&quot;&gt;typeSemantic&lt;/strong&gt;(Type t, Loc loc, Scope* sc);</source>
          <target state="translated">Тип &lt;strong id=&quot;typeSemantic&quot;&gt;typeSemantic&lt;/strong&gt; (Тип t, Loc loc, Область действия * sc);</target>
        </trans-unit>
        <trans-unit id="5d4688f5531e8a08ef8e0ff730f862cace988d3d" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;va_listType&quot;&gt;va_listType&lt;/strong&gt;();</source>
          <target state="translated">Тип &lt;strong id=&quot;va_listType&quot;&gt;va_listType&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="4f59c6d42771bbb84c27a2121ad3681f0bb72d20" translate="yes" xml:space="preserve">
          <source>Type AST node</source>
          <target state="translated">Узел типа АСТ</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">Преобразование типа</target>
        </trans-unit>
        <trans-unit id="c6b7ec08c1e42e9023620d7d964ae0eef2d20644" translate="yes" xml:space="preserve">
          <source>Type Mangling</source>
          <target state="translated">Изменение типа</target>
        </trans-unit>
        <trans-unit id="264ee4dfa69c98ad557b3342fe8cc1e2b97db3e7" translate="yes" xml:space="preserve">
          <source>Type Qualifiers</source>
          <target state="translated">Квалификаторы типа</target>
        </trans-unit>
        <trans-unit id="edc9c0e21717c816a5ec56b1e42647baf2336f1d" translate="yes" xml:space="preserve">
          <source>Type Qualifiers vs. Storage Classes</source>
          <target state="translated">Квалификаторы типа по сравнению с классом хранения</target>
        </trans-unit>
        <trans-unit id="931cf893dd7787c77998acad492a0ecb55e589ff" translate="yes" xml:space="preserve">
          <source>Type behaviours</source>
          <target state="translated">Типовое поведение</target>
        </trans-unit>
        <trans-unit id="25bae51139cada12199444a9e1b243f934dd5a35" translate="yes" xml:space="preserve">
          <source>Type checking can be done when fmt is known at compile-time:</source>
          <target state="translated">Проверка типов может быть выполнена,когда fmt известен во время компиляции:</target>
        </trans-unit>
        <trans-unit id="e3ba04dc56b4f38a8765f8f4d22b580ca485aa27" translate="yes" xml:space="preserve">
          <source>Type constructor for final (aka head-const) variables.</source>
          <target state="translated">Конструктор типов для конечных переменных (также известный как head-const).</target>
        </trans-unit>
        <trans-unit id="5bf7d2b202fca4883a92f0548ad74fcbd4972ddc" translate="yes" xml:space="preserve">
          <source>Type constructors for scoped variables, ref counted types, etc.</source>
          <target state="translated">Конструкторы типов для scoped-переменных,подсчитанных типов ref и т.д.</target>
        </trans-unit>
        <trans-unit id="8b9b79043e64613a9793b392102a5c4ae4b65fe0" translate="yes" xml:space="preserve">
          <source>Type containing symbol &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">Тип, содержащий символ- &lt;code&gt;member&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb30eafbd228209766b8a8bef60c18b615f0e87b" translate="yes" xml:space="preserve">
          <source>Type for the &lt;code&gt;va_list&lt;/code&gt; type for the target.</source>
          <target state="translated">Введите для типа &lt;code&gt;va_list&lt;/code&gt; для цели.</target>
        </trans-unit>
        <trans-unit id="ef47c7ac43e7255929d6c306077f07f47b722eec" translate="yes" xml:space="preserve">
          <source>Type of Trie generated by codepointSetTrie function.</source>
          <target state="translated">Тип Trie,генерируемый функцией codepointSetTrie.</target>
        </trans-unit>
        <trans-unit id="4dccd7a2bbd9b94a92f0a8c92cf9c4faa4852cf6" translate="yes" xml:space="preserve">
          <source>Type of a factory object that returns new allocators on a need basis. For an object &lt;code&gt;sweatshop&lt;/code&gt; of type &lt;code&gt;Factory&lt;/code&gt;, &lt;code&gt;sweatshop(n)&lt;/code&gt; should return an allocator able to allocate at least &lt;code&gt;n&lt;/code&gt; bytes (i.e. &lt;code&gt;Factory&lt;/code&gt; must define &lt;code&gt;opCall(size_t)&lt;/code&gt; to return an allocator object). Usually the capacity of allocators created should be much larger than &lt;code&gt;n&lt;/code&gt; such that an allocator can be used for many subsequent allocations. &lt;code&gt;n&lt;/code&gt; is passed only to ensure the minimum necessary for the next allocation. The factory object is allowed to hold state, which will be stored inside &lt;code&gt;AllocatorList&lt;/code&gt; as a direct &lt;code&gt;public&lt;/code&gt; member called &lt;code&gt;factory&lt;/code&gt;.</source>
          <target state="translated">Тип объекта фабрики, который возвращает новые распределители по мере необходимости. Для объекта &lt;code&gt;sweatshop&lt;/code&gt; типа &lt;code&gt;Factory&lt;/code&gt; , &lt;code&gt;sweatshop(n)&lt;/code&gt; должен возвращать аллокатор возможности выделять по меньшей мере , &lt;code&gt;n&lt;/code&gt; байты (т.е. &lt;code&gt;Factory&lt;/code&gt; должен определить &lt;code&gt;opCall(size_t)&lt;/code&gt; , чтобы вернуть объект распределителя). Обычно емкость созданных распределителей должна быть намного больше, чем &lt;code&gt;n&lt;/code&gt; , чтобы распределитель мог использоваться для многих последующих распределений. &lt;code&gt;n&lt;/code&gt; передается только для обеспечения минимума, необходимого для следующего распределения. Заводскому объекту разрешено хранить состояние, которое будет храниться внутри &lt;code&gt;AllocatorList&lt;/code&gt; как прямой &lt;code&gt;public&lt;/code&gt; Член вызвал &lt;code&gt;factory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53b3c45deaab965f30fbaf51880e1afc49233e18" translate="yes" xml:space="preserve">
          <source>Type of hook to report to accumulate</source>
          <target state="translated">Тип крюка,чтобы сообщить о накоплении</target>
        </trans-unit>
        <trans-unit id="15e383896d707844d0eca91f8b6889d73b97fbb0" translate="yes" xml:space="preserve">
          <source>Type of proxy</source>
          <target state="translated">Тип прокси-сервера</target>
        </trans-unit>
        <trans-unit id="c83110b1d2db2259adf4200ec37888cbc9846639" translate="yes" xml:space="preserve">
          <source>Type of tag</source>
          <target state="translated">Тип метки</target>
        </trans-unit>
        <trans-unit id="d3fa4f954ab06add7bd749b7bdea58934c993aaa" translate="yes" xml:space="preserve">
          <source>Type of the object being created.</source>
          <target state="translated">Тип создаваемого объекта.</target>
        </trans-unit>
        <trans-unit id="a0daf2f1b22dd08dc29f641bae271010f9baf166" translate="yes" xml:space="preserve">
          <source>Type parameter deduction is not influenced by the order of function arguments.</source>
          <target state="translated">На вычитание параметров типа не влияет порядок аргументов функции.</target>
        </trans-unit>
        <trans-unit id="6589b7ca4f64019c13d806f181e6e2f0d2a12efe" translate="yes" xml:space="preserve">
          <source>Type qualifer and storage classes are distinct.</source>
          <target state="translated">Классы определения типа и хранения различаются.</target>
        </trans-unit>
        <trans-unit id="6be815ee4e71cdcd2fdc1b9f5a931c3396cc2ae9" translate="yes" xml:space="preserve">
          <source>Type qualifiers modify a type by applying a &lt;a href=&quot;declaration#TypeCtor&quot;&gt;&lt;i&gt;TypeCtor&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;declaration#TypeCtor&quot;&gt;&lt;i&gt;Спецификаторы&lt;/i&gt;&lt;/a&gt; типов изменяют тип, применяя &lt;i&gt;TypeCtor&lt;/i&gt; .</target>
        </trans-unit>
        <trans-unit id="a70515f861481e8dc4615de28615ff7366fcc202" translate="yes" xml:space="preserve">
          <source>Type representing the DOS file date/time format.</source>
          <target state="translated">Тип,представляющий формат даты/времени файла DOS.</target>
        </trans-unit>
        <trans-unit id="8707ce3b635eb9df5d025d3f0450b4a8fd3eb48d" translate="yes" xml:space="preserve">
          <source>Type sequences can also be deduced from the type of a delegate or function parameter list passed as a function argument:</source>
          <target state="translated">Последовательности типов также могут быть выведены из типа списка параметров делегата или функции,переданного в качестве аргумента функции:</target>
        </trans-unit>
        <trans-unit id="733ee898e1598d12bae36c91271af1529e4fcaa2" translate="yes" xml:space="preserve">
          <source>Type sequences can be deduced from the trailing parameters of an implicitly instantiated function template:</source>
          <target state="translated">Последовательности типов могут быть выведены из параметров трейлинга неявно инстанцированного шаблона функции:</target>
        </trans-unit>
        <trans-unit id="a8e4656cb8d277115469c8e6ecd03e51fd9b8df7" translate="yes" xml:space="preserve">
          <source>Type to check</source>
          <target state="translated">Тип для проверки</target>
        </trans-unit>
        <trans-unit id="f741a0744a1572f9886a07067ea02acc1834b951" translate="yes" xml:space="preserve">
          <source>Type to check against existing types</source>
          <target state="translated">Тип для сравнения с существующими типами</target>
        </trans-unit>
        <trans-unit id="de396937e60ad29356ea188a9c5d9ea651e367c0" translate="yes" xml:space="preserve">
          <source>Type tuple with 0, 1 or 2 types in it.</source>
          <target state="translated">Тип кортежа с 0,1 или 2 типами.</target>
        </trans-unit>
        <trans-unit id="011c9eabb9ffe20e7e22482cfbe2286b6120bfa9" translate="yes" xml:space="preserve">
          <source>Type* &lt;code&gt;pt&lt;/code&gt;</source>
          <target state="translated">Тип * &lt;code&gt;pt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58d77e6f74277f79b951803afbe1ddf1b35734df" translate="yes" xml:space="preserve">
          <source>TypeCtor</source>
          <target state="translated">TypeCtor</target>
        </trans-unit>
        <trans-unit id="ac9e1cc0b26d4033ad5c959b5f820850ea93475b" translate="yes" xml:space="preserve">
          <source>TypeCtors</source>
          <target state="translated">TypeCtors</target>
        </trans-unit>
        <trans-unit id="3928ee67b003a61e2825045ee7c6856586fe197b" translate="yes" xml:space="preserve">
          <source>TypeDotIdExp</source>
          <target state="translated">TypeDotIdExp</target>
        </trans-unit>
        <trans-unit id="0019be4cb34cff2695b5aff262952fd301c46685" translate="yes" xml:space="preserve">
          <source>TypeFunction &lt;code&gt;tf&lt;/code&gt;</source>
          <target state="translated">TypeFunction &lt;code&gt;tf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db700355f8924fab7eada69ef0fe0e550c49d3a6" translate="yes" xml:space="preserve">
          <source>TypeFunction which holds parameter.</source>
          <target state="translated">Функция TypeFunction,которая содержит параметр.</target>
        </trans-unit>
        <trans-unit id="5ca2910cf68fdd66a12e3e8220178f8b4cc5a0db" translate="yes" xml:space="preserve">
          <source>TypeIdentifier &lt;strong id=&quot;getException&quot;&gt;getException&lt;/strong&gt;();</source>
          <target state="translated">TypeIdentifier &lt;strong id=&quot;getException&quot;&gt;getException&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="42f5b285fc85964089e7dc297caf59c7103f1888" translate="yes" xml:space="preserve">
          <source>TypeIdentifier &lt;strong id=&quot;getThrowable&quot;&gt;getThrowable&lt;/strong&gt;();</source>
          <target state="translated">TypeIdentifier &lt;strong id=&quot;getThrowable&quot;&gt;getThrowable&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="f9d611bfddd3405f459de10a0cf6d218aa6287a1" translate="yes" xml:space="preserve">
          <source>TypeIdentifier corresponding to &lt;code&gt;object.Exception&lt;/code&gt;</source>
          <target state="translated">TypeIdentifier, соответствующий &lt;code&gt;object.Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea8bcbfb0a4687ca07a5f9448fa2692699ee114" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;info&lt;/code&gt;</source>
          <target state="translated">ТипИнфо &lt;code&gt;info&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1b8e2e2628fbdb6b877b9991519908026efcaf7" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;keyti&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;keyti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dec97b284949d704d7ee4541006a5521ba97794" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;ti&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;ti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67c22ded6663e84767a53e56d998760516256038" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;source&quot;&gt;source&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;source&quot;&gt;source&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c1278db525adc97eab488999431f521bd14cee3e" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;target&quot;&gt;target&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;target&quot;&gt;target&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="79ae15533fd627996ea193ee400334ad48f0ffa1" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;ti&quot;&gt;ti&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;ti&quot;&gt;ti&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="472c2c18b4ef0579bcce9fff2441baed8006d608" translate="yes" xml:space="preserve">
          <source>TypeInfo and ModuleInfo</source>
          <target state="translated">ТипИнфо и МодульИнфо</target>
        </trans-unit>
        <trans-unit id="60e117687bb5baf0fd5a823fd99cc2045df9bbdf" translate="yes" xml:space="preserve">
          <source>TypeInfo for some class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93be7833a3f5791fae09a639aee73a46e387e3c" translate="yes" xml:space="preserve">
          <source>TypeInfo for the associative array</source>
          <target state="translated">TypeInfo для ассоциативного массива</target>
        </trans-unit>
        <trans-unit id="7c7bfccff9046ef36445ee4c709ff7d995d70ab8" translate="yes" xml:space="preserve">
          <source>TypeInfo for the key</source>
          <target state="translated">TypeInfo для ключа</target>
        </trans-unit>
        <trans-unit id="23d395400e74ed54a9281933209acee2f90cbe4e" translate="yes" xml:space="preserve">
          <source>TypeInfo for this member</source>
          <target state="translated">TypeInfo для этого члена</target>
        </trans-unit>
        <trans-unit id="6cae780f43ad1913cc11d46eaafdb1d914a0fecd" translate="yes" xml:space="preserve">
          <source>TypeInfo operations</source>
          <target state="translated">Операции TypeInfo</target>
        </trans-unit>
        <trans-unit id="0c903e4430a6af28fc4a701dcf89fccf74b52c8e" translate="yes" xml:space="preserve">
          <source>TypeInfo support code.</source>
          <target state="translated">Код поддержки TypeInfo.</target>
        </trans-unit>
        <trans-unit id="7bac08fb0ecc35c0c1645fa9688ec0c7cbb7320b" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the full memory block. The GC might use this information to improve scanning for pointers or to call finalizers.</source>
          <target state="translated">TypeInfo для описания полного блока памяти.ГК может использовать эту информацию для улучшения сканирования указателей или для вызова финализаторов.</target>
        </trans-unit>
        <trans-unit id="e6a910dc0d5bf54bb8bb28b4e2782c2fac837ad2" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers</source>
          <target state="translated">TypeInfo для описания памяти.ГК может использовать эту информацию для улучшения сканирования указателей или для вызова финализаторов.</target>
        </trans-unit>
        <trans-unit id="8c13cb9891545ae558cb22a55266091cadf68bb8" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers.</source>
          <target state="translated">TypeInfo для описания памяти.ГК может использовать эту информацию для улучшения сканирования указателей или для вызова финализаторов.</target>
        </trans-unit>
        <trans-unit id="aff0fe6a2bf6b7e4ef9a8e4a029e01a4aeb8762f" translate="yes" xml:space="preserve">
          <source>TypeInfo_AssociativeArray &lt;code&gt;ti&lt;/code&gt;</source>
          <target state="translated">TypeInfo_AssociativeArray &lt;code&gt;ti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ddf3891d5ae85f580f981341a31916f1fc360a8" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;code&gt;child&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25e4540ada3cc921bdd8d8fd0d8e1e7b7781066" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;strong id=&quot;base&quot;&gt;base&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo_Class &lt;strong id=&quot;base&quot;&gt;base&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9239ac5fb46ce2e24e9298817e7012c20bc78405" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;strong id=&quot;classinfo&quot;&gt;classinfo&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo_Class &lt;strong id=&quot;classinfo&quot;&gt;classinfo&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2bd0ed90864a622e90192ec41cb245073bc3a096" translate="yes" xml:space="preserve">
          <source>TypeMixin &lt;code&gt;tm&lt;/code&gt;</source>
          <target state="translated">TypeMixin &lt;code&gt;tm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="773e0bc0cc8840334c10f79e302767527cb23cf4" translate="yes" xml:space="preserve">
          <source>TypeSeq</source>
          <target state="translated">TypeSeq</target>
        </trans-unit>
        <trans-unit id="2485569c283c3e15dcdf66b2941cf2585cfbb0fb" translate="yes" xml:space="preserve">
          <source>TypeSpecialization</source>
          <target state="translated">TypeSpecialization</target>
        </trans-unit>
        <trans-unit id="d5bc30e762df0213573cbaddbf2be54ecff91c7a" translate="yes" xml:space="preserve">
          <source>TypeTuple &lt;strong id=&quot;toArgTypes&quot;&gt;toArgTypes&lt;/strong&gt;(Type t);</source>
          <target state="translated">TypeTuple &lt;strong id=&quot;toArgTypes&quot;&gt;toArgTypes&lt;/strong&gt; (Type t);</target>
        </trans-unit>
        <trans-unit id="0a55489e3ecfb05595ff8f54b93c8573e3ce85a8" translate="yes" xml:space="preserve">
          <source>TypeTuple &lt;strong id=&quot;toArgTypes_sysv_x64&quot;&gt;toArgTypes_sysv_x64&lt;/strong&gt;(Type t);</source>
          <target state="translated">TypeTuple &lt;strong id=&quot;toArgTypes_sysv_x64&quot;&gt;toArgTypes_sysv_x64&lt;/strong&gt; (Type t);</target>
        </trans-unit>
        <trans-unit id="e642a3765f89fbde01f0a2276d7abdf9b70ab3cf" translate="yes" xml:space="preserve">
          <source>Typed alias parameters</source>
          <target state="translated">Типизированные параметры псевдонима</target>
        </trans-unit>
        <trans-unit id="b30db53a60d0c35c43aeee9bc4f602733c935e33" translate="yes" xml:space="preserve">
          <source>Typedef creates a new type</source>
          <target state="translated">Typedef создает новый тип</target>
        </trans-unit>
        <trans-unit id="6201a322fae660c45cd9849605bc8c759be0c5b0" translate="yes" xml:space="preserve">
          <source>Typeid Expressions</source>
          <target state="translated">Выражения типа</target>
        </trans-unit>
        <trans-unit id="bf3662203dcf0ffc0db3cb9a25590ff39043990d" translate="yes" xml:space="preserve">
          <source>Typeof</source>
          <target state="translated">Typeof</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="98208c2d7d35bb6c2bec43c9c9c8b3b514bcabb3" translate="yes" xml:space="preserve">
          <source>Types &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">Типы &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad7fbb5ff653b4fb1310a106afd7d4d247c60fc4" translate="yes" xml:space="preserve">
          <source>Types &lt;strong id=&quot;expand&quot;&gt;expand&lt;/strong&gt;;</source>
          <target state="translated">Типы &lt;strong id=&quot;expand&quot;&gt;расширяются&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d33ff32e1c661c88ebc3ad3634169408689bdb2c" translate="yes" xml:space="preserve">
          <source>Types affected</source>
          <target state="translated">Пострадавшие типы</target>
        </trans-unit>
        <trans-unit id="8b8ed26fa191ff295582e384bddd39585a3f8db2" translate="yes" xml:space="preserve">
          <source>Types are mangled using a simple linear scheme:</source>
          <target state="translated">Типы искажаются с помощью простой линейной схемы:</target>
        </trans-unit>
        <trans-unit id="056fa98818fde905c87d68b5a8122d7a217fa627" translate="yes" xml:space="preserve">
          <source>Types for C Debuggers</source>
          <target state="translated">Типы для отладчиков C</target>
        </trans-unit>
        <trans-unit id="a317ddf00723db3897d96406a7af0777748b751e" translate="yes" xml:space="preserve">
          <source>Typesafe PIMPL idiom so we can keep CompiledCtfeFunction private.</source>
          <target state="translated">Типичная PIMPL идиома,так что мы можем держать CompiledCtfeFunction приватным.</target>
        </trans-unit>
        <trans-unit id="8c1a6486831bba104b5c93d116efda5decae0955" translate="yes" xml:space="preserve">
          <source>Typesafe Variadic Functions</source>
          <target state="translated">Типовые безопасные вариадические функции</target>
        </trans-unit>
        <trans-unit id="9c18f7085ca663e2eeeb1ab419e11c946cc281e9" translate="yes" xml:space="preserve">
          <source>Typesafe variadic functions</source>
          <target state="translated">Типезоподобные вариадические функции</target>
        </trans-unit>
        <trans-unit id="c158adeb6705f4b21c628caabe72dc1f58ae0f9b" translate="yes" xml:space="preserve">
          <source>Typesafe variadic functions are used when the variable argument portion of the arguments are used to construct an array or class object.</source>
          <target state="translated">Типичные вариадические функции используются,когда переменная часть аргументов используется для построения массива или объекта класса.</target>
        </trans-unit>
        <trans-unit id="e6941e6087f5c747e81f3548ced3b053ce9e7b28" translate="yes" xml:space="preserve">
          <source>Typically updating a value in an associative array is simply done with an assign statement.</source>
          <target state="translated">Обычно обновление значения в ассоциативном массиве выполняется просто с помощью оператора присваивания.</target>
        </trans-unit>
        <trans-unit id="db183258f807139f91ca3be4ce6506a44b76a64e" translate="yes" xml:space="preserve">
          <source>Typically used to transfer a &lt;code&gt;Unique&lt;/code&gt; rvalue of derived type to a &lt;code&gt;Unique&lt;/code&gt; of base type.</source>
          <target state="translated">Обычно используется для передачи &lt;code&gt;Unique&lt;/code&gt; значения производного типа в &lt;code&gt;Unique&lt;/code&gt; базового типа.</target>
        </trans-unit>
        <trans-unit id="733f934ae56c1f7d0fdf7d7b634f135f6d1638cd" translate="yes" xml:space="preserve">
          <source>Typically, &lt;code&gt;assumeUnique&lt;/code&gt; is used to return arrays from functions that have allocated and built them.</source>
          <target state="translated">Как правило, &lt;code&gt;assumeUnique&lt;/code&gt; используется для возврата массивов из функций, которые их разместили и создали.</target>
        </trans-unit>
        <trans-unit id="22c79bf41fa01646983d0e1c75126cd457c1bd02" translate="yes" xml:space="preserve">
          <source>Typically, the abbreviation (generally 3 or 4 letters) for the time zone when DST</source>
          <target state="translated">Обычно аббревиатура (обычно 3 или 4 буквы)для часового пояса,когда DST</target>
        </trans-unit>
        <trans-unit id="b795aa6d3d9c14054ccb6a6aea11b3269a8595b3" translate="yes" xml:space="preserve">
          <source>Typically, the abbreviation (generally 3 or 4 letters) for the time zone when DST is</source>
          <target state="translated">Обычно аббревиатура (обычно 3 или 4 буквы)для часового пояса,когда DST является</target>
        </trans-unit>
        <trans-unit id="b7f34bb41388ea7e3fb767468d24019362880e11" translate="yes" xml:space="preserve">
          <source>Typically, the first element of &lt;code&gt;argv&lt;/code&gt; is the command being executed, i.e. &lt;code&gt;argv[0] == pathname&lt;/code&gt;. The 'p' versions of &lt;code&gt;exec&lt;/code&gt; search the PATH environment variable for &lt;code&gt; pathname&lt;/code&gt;. The 'e' versions additionally take the new process' environment variables as an array of strings of the form key=value.</source>
          <target state="translated">Как правило, первый элемент &lt;code&gt;argv&lt;/code&gt; - это выполняемая команда, т.е. &lt;code&gt;argv[0] == pathname&lt;/code&gt; . Версии 'p' &lt;code&gt;exec&lt;/code&gt; ищут переменную окружения PATH по &lt;code&gt; pathname&lt;/code&gt; . Версии 'e' дополнительно принимают переменные окружения нового процесса в виде массива строк вида ключ = значение.</target>
        </trans-unit>
        <trans-unit id="de16dec91e0419147faeea7cdd994e0d6a8f8d25" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;another&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;another&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fb667fdcab211117158dd3ce9d3203d725af2f1" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;argument&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;argument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="697f0c45a847f453216f051a5a6ee69d25e04ed2" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63a11922fe248c81fbee9848ffa1f8b4dfbc12bd" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23c55c60a22ed27e0af35760d8416c17c4c523be" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;reference&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dcf3fde6cc76619903303aa59a8ee79c73ff4f" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd1523b1327c39f05597e30713c7dff5a3ff10c0" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;stuff&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;stuff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14d2ebb04ddb126790e90698955610cc1aa2858f" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;update&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;update&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fa4864c90d6d362e77a889c4b5d08bf8651a60b" translate="yes" xml:space="preserve">
          <source>U &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt;(U, this _)()</source>
          <target state="translated">U &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt; (U, это _) ()</target>
        </trans-unit>
        <trans-unit id="dc24734c978d9bb3d649f59ea57f6fbfebb04938" translate="yes" xml:space="preserve">
          <source>UDAs can be extracted into an expression tuple using &lt;code&gt;__traits&lt;/code&gt;:</source>
          <target state="translated">UDA могут быть извлечены в кортеж выражения с помощью &lt;code&gt;__traits&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8c9a445b357a8879b87fe2a26129a13cff925174" translate="yes" xml:space="preserve">
          <source>UDAs cannot be attached to template parameters.</source>
          <target state="translated">UDA не могут быть прикреплены к параметрам шаблона.</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="c05d8b4022a5b33bdfe1da8ac44209fadee29acb" translate="yes" xml:space="preserve">
          <source>UIntType &lt;code&gt;x0&lt;/code&gt;</source>
          <target state="translated">UIntType &lt;code&gt;x0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1134895e9b29127e491e75b96f85825dd4e274" translate="yes" xml:space="preserve">
          <source>UNIX 98 requires that errno be set to ENOMEM upon failure. &lt;a href=&quot;https://linux.die.net/man/3/malloc&quot;&gt;https://linux.die.net/man/3/malloc&lt;/a&gt; However, this is irrelevant for DMD's purposes, and best practice protocol for using errno is to treat it as an &lt;code&gt;out&lt;/code&gt; parameter, and not something with state that can be relied on across function calls. So, we'll ignore it.</source>
          <target state="translated">UNIX 98 требует, чтобы errno был установлен в ENOMEM в случае сбоя. &lt;a href=&quot;https://linux.die.net/man/3/malloc&quot;&gt;https://linux.die.net/man/3/malloc&lt;/a&gt; Тем не менее, это не имеет значения для целей DMD, и протокол наилучшей практики для использования errno должен рассматривать его как &lt;code&gt;out&lt;/code&gt; параметр, а не что-то с состоянием, на которое можно положиться через вызовы функций. Итак, мы будем игнорировать это.</target>
        </trans-unit>
        <trans-unit id="beccb674b27af0ddeedf12b4de67513a39156f03" translate="yes" xml:space="preserve">
          <source>UNIX 98 requires that errno be set to ENOMEM upon failure. Purity is achieved by saving and restoring the value of &lt;code&gt;errno&lt;/code&gt;, thus behaving as if it were never changed.</source>
          <target state="translated">UNIX 98 требует, чтобы errno был установлен в ENOMEM в случае сбоя. Чистота достигается за счет сохранения и восстановления значения &lt;code&gt;errno&lt;/code&gt; , которое ведет себя так, как будто оно никогда не менялось.</target>
        </trans-unit>
        <trans-unit id="fd4c42e93b798f843e95525ca51904fccdadcf92" translate="yes" xml:space="preserve">
          <source>UNIX(7)</source>
          <target state="translated">UNIX(7)</target>
        </trans-unit>
        <trans-unit id="f9fc2ebde19b1bdca47e809441ff08ef908d85ea" translate="yes" xml:space="preserve">
          <source>UTF Byte Order Marks</source>
          <target state="translated">UTF байтовые ордерные знаки</target>
        </trans-unit>
        <trans-unit id="9f8129fc3aa0089cfcf72b031ad3d481df53b04d" translate="yes" xml:space="preserve">
          <source>UTF character support is restricted to &lt;code&gt;'\u0000' &amp;lt;= character &amp;lt;= '\U0010FFFF'&lt;/code&gt;.</source>
          <target state="translated">Поддержка символов UTF ограничена значением &lt;code&gt;'\u0000' &amp;lt;= character &amp;lt;= '\U0010FFFF'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f9afa06e54090c43e842aa15b3fe3611896ff8c" translate="yes" xml:space="preserve">
          <source>UTF sequences that cannot be converted to the specified encoding are either replaced by U+FFFD per &quot;5.22 Best Practice for U+FFFD Substitution&quot; of the Unicode Standard 6.2 or result in a thrown UTFException. Hence byUTF is not symmetric. This algorithm is lazy, and does not allocate memory. &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;-ity, &lt;code&gt;nothrow&lt;/code&gt;, and &lt;code&gt;@safe&lt;/code&gt;-ty are inferred from the &lt;code&gt;r&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5411953a4d42cf12809bd4464e6d4db7776d601" translate="yes" xml:space="preserve">
          <source>UTF sequences that cannot be converted to the specified encoding are replaced by U+FFFD per &quot;5.22 Best Practice for U+FFFD Substitution&quot; of the Unicode Standard 6.2. Hence byUTF is not symmetric. This algorithm is lazy, and does not allocate memory. &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;-ity, &lt;code&gt;nothrow&lt;/code&gt;, and &lt;code&gt;@safe&lt;/code&gt;-ty are inferred from the &lt;code&gt;r&lt;/code&gt; parameter.</source>
          <target state="translated">Последовательности UTF, которые не могут быть преобразованы в указанное кодирование, заменяются на U + FFFD в соответствии с &amp;laquo;5.22 Наилучшая практика для замены U + FFFD&amp;raquo; стандарта Unicode 6.2. Следовательно, UTF не является симметричным. Этот алгоритм ленив и не выделяет память. &lt;code&gt;@nogc&lt;/code&gt; , &lt;code&gt;pure&lt;/code&gt; -ity, &lt;code&gt;nothrow&lt;/code&gt; и &lt;code&gt;@safe&lt;/code&gt; -ty выводятся из параметра &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="815b5d137b049f840a84ea779942f380fee2d1b2" translate="yes" xml:space="preserve">
          <source>UTF-16 sequence</source>
          <target state="translated">последовательность UTF-16</target>
        </trans-unit>
        <trans-unit id="de4a45e716017695cfee4bc84f1a4e0c8e1e9b9a" translate="yes" xml:space="preserve">
          <source>UTF-16BE</source>
          <target state="translated">UTF-16BE</target>
        </trans-unit>
        <trans-unit id="6af12beb19d40aa853839c482e864ce703f4d2a9" translate="yes" xml:space="preserve">
          <source>UTF-16LE</source>
          <target state="translated">UTF-16LE</target>
        </trans-unit>
        <trans-unit id="9e4d8d4f017185a065b570c771eb332a1c842bec" translate="yes" xml:space="preserve">
          <source>UTF-32BE</source>
          <target state="translated">UTF-32BE</target>
        </trans-unit>
        <trans-unit id="35cabe85c31dfe3f6b86974de33fef51a0f7276a" translate="yes" xml:space="preserve">
          <source>UTF-32LE</source>
          <target state="translated">UTF-32LE</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="f9496a431551e339492736948b4e238922bacdef" translate="yes" xml:space="preserve">
          <source>UTF-8 sequence</source>
          <target state="translated">последовательность UTF-8</target>
        </trans-unit>
        <trans-unit id="877994f4b4067d2a1f1f0f6bd6384f2638fcb6f8" translate="yes" xml:space="preserve">
          <source>UTF-8 string to convert.</source>
          <target state="translated">UTF-8 строка для преобразования.</target>
        </trans-unit>
        <trans-unit id="4ec698a623934218d006f758f60cc65200b7e5d5" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;(Range)(ref Range uuidRange)</source>
          <target state="translated">UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt; (Range) (ссылка Range uuidRange)</target>
        </trans-unit>
        <trans-unit id="67faabd33b533aa2705b030a23deec418ddc4531" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;(T)(T uuidString)</source>
          <target state="translated">UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt; (T) (T uuidString)</target>
        </trans-unit>
        <trans-unit id="cc9e30340d1753d3d85fd300f0e9b269c9de763e" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;randomUUID&quot;&gt;randomUUID&lt;/strong&gt;(RNG)(ref RNG randomGen)</source>
          <target state="translated">UUID &lt;strong id=&quot;randomUUID&quot;&gt;randomUUID&lt;/strong&gt; (RNG) (ref RNG randomGen)</target>
        </trans-unit>
        <trans-unit id="a772ba2e5a42ae80f2c9272ebcf1178fcfb9d897" translate="yes" xml:space="preserve">
          <source>UUID namespaces</source>
          <target state="translated">пространства имён UUID</target>
        </trans-unit>
        <trans-unit id="5138cdf5aa51c8e0f95889706fc9ee1e7f17902c" translate="yes" xml:space="preserve">
          <source>UUID uses a 16-ubyte representation for the UUID data. RFC 4122 defines a UUID as a special structure in big-endian format. These 16-ubytes always equal the big-endian structure defined in RFC 4122.</source>
          <target state="translated">UUID использует 16-пубковое представление для данных UUID.RFC 4122 определяет UUID как специальную структуру в формате big-endian.Эти 16-байт всегда равны биг-ендианской структуре,определенной в RFC 4122.</target>
        </trans-unit>
        <trans-unit id="97f3c3a3c12b841a2a4769e7f1a5d3a8268ab30f" translate="yes" xml:space="preserve">
          <source>UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify rows or records in order to ensure that they are unique across different databases, or for publication/subscription services. Network messages may be identified with a UUID to ensure that different parts of a message are put back together again. Distributed computing may use UUIDs to identify a remote procedure call. Transactions and classes involved in serialization may be identified by UUIDs. Microsoft's component object model (COM) uses UUIDs to distinguish different software component interfaces. UUIDs are inserted into documents from Microsoft Office programs. UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are also a basis for OIDs (object identifiers), and URNs (uniform resource name).</source>
          <target state="translated">UUID имеют множество приложений.Ниже приведены некоторые примеры:Базы данных могут использовать UUID для идентификации строк или записей,чтобы обеспечить их уникальность для различных баз данных или для служб публикации/подписки.Сетевые сообщения могут быть идентифицированы с помощью UUID,чтобы гарантировать,что различные части сообщения снова соединяются вместе.Распределенные вычисления могут использовать UUID для идентификации удаленного вызова процедуры.Транзакции и классы,участвующие в сериализации,могут быть идентифицированы с помощью UUID.Объектная модель компонентов (COM)компании Microsoft использует UUID для различения интерфейсов различных программных компонентов.UUID-ы вставляются в документы из программ Microsoft Office.UUID-адреса идентифицируют аудио-или видеопотоки в расширенном системном формате (ASF).UUID также являются основой для OID (идентификаторов объектов)и URN (единого имени ресурса).</target>
        </trans-unit>
        <trans-unit id="7cfb32627383e93254e644d1ee41cde2752bcfaa" translate="yes" xml:space="preserve">
          <source>U[] &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">U [] &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5a8724faaa7b7c394cdf13e24050e05ae9df5e7" translate="yes" xml:space="preserve">
          <source>U[n] &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">U [n] &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="translated">Ugaritic</target>
        </trans-unit>
        <trans-unit id="b338855e51e0be5b8018fcc6c3c8f1fb58ef1ed1" translate="yes" xml:space="preserve">
          <source>UnaExp &lt;code&gt;ue&lt;/code&gt;</source>
          <target state="translated">UnaExp &lt;code&gt;ue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7362d38845d769ab9292607291056855e2183b1" translate="yes" xml:space="preserve">
          <source>Unable to open the database file</source>
          <target state="translated">Невозможно открыть файл базы данных</target>
        </trans-unit>
        <trans-unit id="33bd9ce85f04d2d2b0510e3bbb94561d4ef14386" translate="yes" xml:space="preserve">
          <source>Unary Expressions</source>
          <target state="translated">Унарные выражения</target>
        </trans-unit>
        <trans-unit id="591cb6d4ab93ebc2d2043b2cb411e0fb42e0f3f7" translate="yes" xml:space="preserve">
          <source>Unary Operator Overloading</source>
          <target state="translated">Перегрузка оператора</target>
        </trans-unit>
        <trans-unit id="f513f3dda804c19713470f3838e16096aa4d57eb" translate="yes" xml:space="preserve">
          <source>Unary SIMD instructions.</source>
          <target state="translated">Унарные инструкции SIMD.</target>
        </trans-unit>
        <trans-unit id="d4b656c31bdca61d3708bf6436103a5e4c87af7f" translate="yes" xml:space="preserve">
          <source>UnaryExpression</source>
          <target state="translated">UnaryExpression</target>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="translated">Unassigned</target>
        </trans-unit>
        <trans-unit id="eb5d4c5516fc1c059de7a6392f9c37511d73768b" translate="yes" xml:space="preserve">
          <source>Unavailable Features</source>
          <target state="translated">Недоступные особенности</target>
        </trans-unit>
        <trans-unit id="68af9ad2189921beb26a800d338b2a6b4e676cf3" translate="yes" xml:space="preserve">
          <source>Unclosed comment</source>
          <target state="translated">Незакрытый комментарий</target>
        </trans-unit>
        <trans-unit id="f6243a69cb62441fa6d87afa14c8d5e89b20730a" translate="yes" xml:space="preserve">
          <source>Unclosed quoted string</source>
          <target state="translated">Незакрытая цитируемая строка</target>
        </trans-unit>
        <trans-unit id="0646f4afd90c8fdb87bbcb57b63ee1911f5a9a46" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="translated">Undefined</target>
        </trans-unit>
        <trans-unit id="bf324c3d5f2f1b78051107d12302e948c629d468" translate="yes" xml:space="preserve">
          <source>Underlying ranges</source>
          <target state="translated">Нижележащие диапазоны</target>
        </trans-unit>
        <trans-unit id="83480b867507019f42179ab37987dcdb4c62cd97" translate="yes" xml:space="preserve">
          <source>Unescapes URL encoding in strings (converts all %XX codes to their 8bit versions). This function returns a new allocated string or NULL if an error occurred. Conversion Note: On non-ASCII platforms the ASCII %XX codes are converted into the host encoding.</source>
          <target state="translated">Unescapes кодировка URL в строках (преобразует все %XX коды в их 8-ми битные версии).Эта функция возвращает новую выделенную строку или NULL,если произошла ошибка.Примечание по преобразованию:На не-ASCII-платформах коды ASCII %XX преобразуются в кодировку хоста.</target>
        </trans-unit>
        <trans-unit id="1043e7d94fb950dfc41b004ced60f3e79b56ed17" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no way to do it on Windows using the TZ Database name, so this function only exists on Posix systems.</source>
          <target state="translated">К сожалению,в Windows нет возможности сделать это с помощью имени базы данных TZ,поэтому эта функция существует только на системах Posix.</target>
        </trans-unit>
        <trans-unit id="c7e823b88e4feebda781e31901fb8ed6b6646bbd" translate="yes" xml:space="preserve">
          <source>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252</source>
          <target state="translated">Юникод 5.0,ASCII,ISO-8859-1,ISO-8859-2,WINDOWS-1250,WINDOWS-1251,WINDOWS-1252</target>
        </trans-unit>
        <trans-unit id="b81efb17a923e74f971664cf6551b29e3911eb7f" translate="yes" xml:space="preserve">
          <source>Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252</source>
          <target state="translated">Юникод 5.0,ASCII,ISO-8859-1,WINDOWS-1252</target>
        </trans-unit>
        <trans-unit id="9efb04e249cf52e825a2ae577ec002967cfd9907" translate="yes" xml:space="preserve">
          <source>Unicode character U+</source>
          <target state="translated">символ Юникода U+</target>
        </trans-unit>
        <trans-unit id="86d5346f841497e1a9a9e132b4794f45dbdd869c" translate="yes" xml:space="preserve">
          <source>Unicode character decomposition type.</source>
          <target state="translated">Тип разложения символов в уникоде.</target>
        </trans-unit>
        <trans-unit id="85292ebf0b3cae013871cb556874cf9db932ca12" translate="yes" xml:space="preserve">
          <source>Unicode integrity is not preserved:</source>
          <target state="translated">Целостность Юникода не сохраняется:</target>
        </trans-unit>
        <trans-unit id="3ec807b074593d04a3ef86db0a4d24fa457b2e5f" translate="yes" xml:space="preserve">
          <source>Unicode properties</source>
          <target state="translated">Свойства Юникода</target>
        </trans-unit>
        <trans-unit id="5be5c9fefc535768d2b96dd8780acd22043ffcf7" translate="yes" xml:space="preserve">
          <source>Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.</source>
          <target state="translated">Свойства Юникода,такие как Scripts,Blocks и общие двоичные свойства,такие как Alphabetic,White_Space,Hex_Digit и др.</target>
        </trans-unit>
        <trans-unit id="4247bd31bdb74c5074c844a1f51c93a859ff8578" translate="yes" xml:space="preserve">
          <source>Unicode support</source>
          <target state="translated">Поддержка Юникода</target>
        </trans-unit>
        <trans-unit id="b82773bc5411a43a67f701a9ac627a06c1cb6db2" translate="yes" xml:space="preserve">
          <source>Unicode v6.2</source>
          <target state="translated">Юникод v6.2</target>
        </trans-unit>
        <trans-unit id="7e2aea9a1091a65f50509009229ce4d23b5ee960" translate="yes" xml:space="preserve">
          <source>Unicode(tm) is a trademark of Unicode, Inc.</source>
          <target state="translated">Unicode(tm)является торговой маркой Unicode,Inc.</target>
        </trans-unit>
        <trans-unit id="91c29c138dfa854b43a9c50a2f9ff956dcfd1401" translate="yes" xml:space="preserve">
          <source>Unified Canadian Aboriginal Syllabics</source>
          <target state="translated">Объединенные канадские аборигенные учебные программы</target>
        </trans-unit>
        <trans-unit id="0f85f583bbf512091ad1e17cda1699402ef799e1" translate="yes" xml:space="preserve">
          <source>Unified Canadian Aboriginal Syllabics Extended</source>
          <target state="translated">Расширенная учебная программа для аборигенов Канады.</target>
        </trans-unit>
        <trans-unit id="4f290c277dbce6544950d95c7ffc983b5b870a4c" translate="yes" xml:space="preserve">
          <source>Unified_Ideograph</source>
          <target state="translated">Unified_Ideograph</target>
        </trans-unit>
        <trans-unit id="5ea2f727e179d06cc6c0064064aea5ee05d170fa" translate="yes" xml:space="preserve">
          <source>Uniform Function Call Syntax (UFCS)</source>
          <target state="translated">Синтаксис унифицированных вызовов функций (UFCS)</target>
        </trans-unit>
        <trans-unit id="367b834ab9bc6ea15eef6f05af78776738e3081a" translate="yes" xml:space="preserve">
          <source>Uniform construction syntax for built-in scalar types</source>
          <target state="translated">Равномерный синтаксис построения для встроенных скалярных типов</target>
        </trans-unit>
        <trans-unit id="bf061382e10d6798c2517c28e31d8d381de29d04" translate="yes" xml:space="preserve">
          <source>Uniform sampling</source>
          <target state="translated">Равномерная выборка</target>
        </trans-unit>
        <trans-unit id="14c21961b2726c16163dc7492f677c46d510610a" translate="yes" xml:space="preserve">
          <source>UniformRNG &lt;code&gt;rng&lt;/code&gt;</source>
          <target state="translated">UniformRNG &lt;code&gt;rng&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dc2d8aa43cf4b7523681bf7a9d62b6503ab053" translate="yes" xml:space="preserve">
          <source>UniformRandomNumberGenerator &lt;code&gt;urng&lt;/code&gt;</source>
          <target state="translated">UniformRandomNumberGenerator &lt;code&gt;urng&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e68b9abd8444d542ee7ea49339a9fa1aecc4ff1" translate="yes" xml:space="preserve">
          <source>Union Constructors</source>
          <target state="translated">Союз строителей</target>
        </trans-unit>
        <trans-unit id="b97025b5c9cabc7c40bfa14c6e38d256fa91fedc" translate="yes" xml:space="preserve">
          <source>Union of all data types. Storage allocated must be the right size of the data on the TARGET, not the host.</source>
          <target state="translated">Объединение всех типов данных.Хранилище должно быть правильного размера для данных на наблюдаемом устройстве,а не для хоста.</target>
        </trans-unit>
        <trans-unit id="7fb0a0c24f714a3c6908f62d1750b60678074165" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;code&gt;ue&lt;/code&gt;</source>
          <target state="translated">UnionExp &lt;code&gt;ue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40c214e69699ab35dd26f2aea53893c65df5da1a" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;strong id=&quot;changeArrayLiteralLength&quot;&gt;changeArrayLiteralLength&lt;/strong&gt;(ref const Loc loc, TypeArray arrayType, Expression oldval, size_t oldlen, size_t newlen);</source>
          <target state="translated">UnionExp &lt;strong id=&quot;changeArrayLiteralLength&quot;&gt;changeArrayLiteralLength&lt;/strong&gt; (ref const Loc loc, TypeArray arrayType, выражение oldval, size_t oldlen, size_t newlen);</target>
        </trans-unit>
        <trans-unit id="1331c179350671227b2059c060f0fb6cc96a01f6" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;strong id=&quot;voidInitLiteral&quot;&gt;voidInitLiteral&lt;/strong&gt;(Type t, VarDeclaration var);</source>
          <target state="translated">UnionExp &lt;strong id=&quot;voidInitLiteral&quot;&gt;voidInitLiteral&lt;/strong&gt; (Тип t, VarDeclaration var);</target>
        </trans-unit>
        <trans-unit id="573f8fc1579ee858b3690058c2822e4646fa3070" translate="yes" xml:space="preserve">
          <source>UnionExp* &lt;code&gt;pue&lt;/code&gt;</source>
          <target state="translated">UnionExp * &lt;code&gt;pue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01e4d3a9b6c2a2f384ce5dac1eab2350dbb93588" translate="yes" xml:space="preserve">
          <source>Unions and Special Member Functions</source>
          <target state="translated">Профсоюзы и специальные функции членов</target>
        </trans-unit>
        <trans-unit id="a0102ec82c0bb90d78b643d15cf3fa6be00c6e25" translate="yes" xml:space="preserve">
          <source>Unions are a variation on structs.</source>
          <target state="translated">Профсоюзы-это вариация на структурах.</target>
        </trans-unit>
        <trans-unit id="a62d59993aea7f6e6c355a91c3f289c9e8b350b1" translate="yes" xml:space="preserve">
          <source>Unions are by default initialized to whatever the &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; for the first field is, and if none is supplied, to the default initializer for the first field's type.</source>
          <target state="translated">Объединения по умолчанию инициализируются тем, каким является &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Инициализатор&lt;/i&gt;&lt;/a&gt; для первого поля, и, если ничего не указано, инициализатором по умолчанию для типа первого поля.</target>
        </trans-unit>
        <trans-unit id="4a6e457080b0b859845bccdbe95da2d70fb71565" translate="yes" xml:space="preserve">
          <source>Unions are constructed in the same way as structs.</source>
          <target state="translated">Профсоюзы строятся так же,как и структуры.</target>
        </trans-unit>
        <trans-unit id="f20d83de9444f44397049b15f04bc93ca6fb349d" translate="yes" xml:space="preserve">
          <source>Unions are initialized similarly to structs, except that only one initializer is allowed.</source>
          <target state="translated">Профсоюзы инициализируются аналогично структурам,за исключением того,что разрешен только один инициализатор.</target>
        </trans-unit>
        <trans-unit id="0b47874cdb794bfd2c5c4b866c3d58b4a7e2e1c5" translate="yes" xml:space="preserve">
          <source>Unions may have fields that have destructors. However, a union itself never has a destructor. When a union goes out of scope, destructors for it's fields are not called. If those calls are desired, they must be inserted explicitly by the programmer:</source>
          <target state="translated">У союзов могут быть поля с деструкторами.Однако,само объединение никогда не имеет деструктора.Когда объединение выходит за рамки,деструкторы для его полей не вызываются.Если эти вызовы желательны,то они должны быть вставлены явно программистом:</target>
        </trans-unit>
        <trans-unit id="2269a14097f76a4ebedc600cc449a6625817e305" translate="yes" xml:space="preserve">
          <source>Unions may have fields that have postblits. However, a union itself never has a postblit. Copying a union does not result in postblit calls for any fields. If those calls are desired, they must be inserted explicitly by the programmer:</source>
          <target state="translated">У союзов могут быть поля с постоблитами.Однако,в самом профсоюзе никогда не бывает постоблитов.Копирование профсоюза не влечет за собой постоблитовых призывов к заполнению каких-либо полей.Если эти вызовы желательны,то они должны быть вставлены явно программистом:</target>
        </trans-unit>
        <trans-unit id="b87fbd8e5787af83ccbd207ba527d5b29aa8f496" translate="yes" xml:space="preserve">
          <source>Unions may not have postblits, destructors, or invariants.</source>
          <target state="translated">Союзы не могут иметь постблитов,деструкторов или инвариантов.</target>
        </trans-unit>
        <trans-unit id="8298d2824bd021c0211d1ca231e5f2a363ecb036" translate="yes" xml:space="preserve">
          <source>Uniprocessor Garbage Collector Techniques</source>
          <target state="translated">Унипроцессорная техника сбора мусора</target>
        </trans-unit>
        <trans-unit id="27f5b1d97be4caf26df5cfa5ab8e2560a4fec6a2" translate="yes" xml:space="preserve">
          <source>Unique &lt;strong id=&quot;release&quot;&gt;release&lt;/strong&gt;();</source>
          <target state="translated">Уникальный &lt;strong id=&quot;release&quot;&gt;релиз&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="4be5d0f640b96963a935995d6fcf68492057bc00" translate="yes" xml:space="preserve">
          <source>Unique Expression</source>
          <target state="translated">Уникальное выражение</target>
        </trans-unit>
        <trans-unit id="5ff1a5fc9718890c18a9173ea983ebaa427e76cf" translate="yes" xml:space="preserve">
          <source>Unique!T &lt;strong id=&quot;create&quot;&gt;create&lt;/strong&gt;(A...)(auto ref A args)</source>
          <target state="translated">Уникальный! T &lt;strong id=&quot;create&quot;&gt;create&lt;/strong&gt; (A ...) (автореф. A args)</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">Единичные испытания</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">Единичные тесты</target>
        </trans-unit>
        <trans-unit id="3db9bdfab0f022f13a4bb48d254cae9da8cb6639" translate="yes" xml:space="preserve">
          <source>Unit separator</source>
          <target state="translated">Сепаратор агрегата</target>
        </trans-unit>
        <trans-unit id="b3da7cee02b824a66bc3ea485a41f342035764bb" translate="yes" xml:space="preserve">
          <source>Unit tests are a builtin framework of test cases applied to a module to determine if it is working properly. A D program can be run with unit tests enabled or disabled.</source>
          <target state="translated">Модульные тесты представляют собой встроенный каркас тестовых случаев,применяемый к модулю для определения его корректной работы.Программа D может быть запущена с включенным или выключенным модульным тестированием.</target>
        </trans-unit>
        <trans-unit id="fefa6220ed6b9dc9a0e4d5cb4616b291bfab064b" translate="yes" xml:space="preserve">
          <source>Unit tests are a special function defined like:</source>
          <target state="translated">Единичные тесты-это специальная функция,определенная как:</target>
        </trans-unit>
        <trans-unit id="ad9b402c3f3372b26a20431c0ca8997a9ad0b7f1" translate="yes" xml:space="preserve">
          <source>Unit tests are run in the lexical order in which they appear within a module.</source>
          <target state="translated">Юнит-тесты выполняются в лексическом порядке,в котором они появляются внутри модуля.</target>
        </trans-unit>
        <trans-unit id="a5c1e04fbed64b862e97e53f2641fe2ab46a7d9e" translate="yes" xml:space="preserve">
          <source>Unit tests, when enabled, are run after all static initialization is complete and before the &lt;code&gt;main()&lt;/code&gt; function is called.</source>
          <target state="translated">Модульные тесты, если они включены, запускаются после завершения статической инициализации и до &lt;code&gt;main()&lt;/code&gt; функции main () .</target>
        </trans-unit>
        <trans-unit id="055cf0570e66f2eea5181aa00a5c52d90e010552" translate="yes" xml:space="preserve">
          <source>UnitTestResult &lt;strong id=&quot;runModuleUnitTests&quot;&gt;runModuleUnitTests&lt;/strong&gt;();</source>
          <target state="translated">UnitTestResult &lt;strong id=&quot;runModuleUnitTests&quot;&gt;runModuleUnitTests&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="277414d40589e8e43fb1bb639e3eda546d3a39fa" translate="yes" xml:space="preserve">
          <source>Universally-unique identifiers for resources in distributed systems.</source>
          <target state="translated">Универсально-уникальные идентификаторы ресурсов в распределенных системах.</target>
        </trans-unit>
        <trans-unit id="b65181ba4f28882f88c26feebc5a1054a0622a74" translate="yes" xml:space="preserve">
          <source>Unknown opcode in sqlite3_file_control()</source>
          <target state="translated">Неизвестный опкод в sqlite3_file_control()</target>
        </trans-unit>
        <trans-unit id="1931c3a0db3408e15d30035b5b64b4f6292dfc44" translate="yes" xml:space="preserve">
          <source>Unknown version</source>
          <target state="translated">Неизвестная версия</target>
        </trans-unit>
        <trans-unit id="33daa36ae00d362b5c2c8e9facf98bab576abcff" translate="yes" xml:space="preserve">
          <source>Unless a directory is specified in &lt;code&gt;args[0]&lt;/code&gt; or &lt;code&gt;program&lt;/code&gt;, &lt;code&gt;spawnProcess&lt;/code&gt; will search for the program in a platform-dependent manner. On POSIX systems, it will look for the executable in the directories listed in the PATH environment variable, in the order they are listed. On Windows, it will search for the executable in the following sequence:</source>
          <target state="translated">Если каталог не указан в &lt;code&gt;args[0]&lt;/code&gt; или &lt;code&gt;program&lt;/code&gt; , &lt;code&gt;spawnProcess&lt;/code&gt; будет искать программу в зависимости от платформы. В системах POSIX он ищет исполняемый файл в каталогах, перечисленных в переменной среды PATH, в порядке их перечисления. В Windows он будет искать исполняемый файл в следующей последовательности:</target>
        </trans-unit>
        <trans-unit id="b365da39577f92d7cfe9d00eec2c0518ddb0e1eb" translate="yes" xml:space="preserve">
          <source>Unless marked as &lt;code&gt;@trusted&lt;/code&gt; or &lt;code&gt;@safe&lt;/code&gt;, artifacts in this module allow implicit data sharing between threads and cannot guarantee that client code is free from low level data races.</source>
          <target state="translated">Если они не помечены как &lt;code&gt;@trusted&lt;/code&gt; или &lt;code&gt;@safe&lt;/code&gt; , артефакты в этом модуле допускают неявный обмен данными между потоками и не могут гарантировать, что клиентский код свободен от гонок данных низкого уровня.</target>
        </trans-unit>
        <trans-unit id="2fa828ccd66084db8a03f15b05f0b611fac7ce01" translate="yes" xml:space="preserve">
          <source>Unless the child process inherits the standard input/output/error streams of its parent, one almost always wants the streams closed in the parent when &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; returns. Therefore, by default, this is done. If this is not desirable, pass any of these options to spawnProcess.</source>
          <target state="translated">Если дочерний процесс не наследует стандартные потоки ввода / вывода / ошибки своего родителя, почти всегда требуется, чтобы потоки были закрыты в родительском процессе при &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; . Поэтому по умолчанию это сделано. Если это нежелательно, передайте любой из этих параметров spawnProcess.</target>
        </trans-unit>
        <trans-unit id="0408692a5b5d8444ca9b8f0092ac439bf7234efa" translate="yes" xml:space="preserve">
          <source>Unless your system's local time zone deals with leap seconds (which is highly unlikely), then the only way to get a time zone which takes leap seconds into account is to use &lt;code&gt;PosixTimeZone&lt;/code&gt; with a time zone whose name starts with &quot;right/&quot;. Those time zone files do include leap seconds, and &lt;code&gt;PosixTimeZone&lt;/code&gt; will take them into account (though posix systems which use a &quot;right/&quot; time zone as their local time zone will</source>
          <target state="translated">Если местный часовой пояс вашей системы не имеет дело с дополнительными секундами (что весьма маловероятно), то единственный способ получить часовой пояс, который учитывает дополнительные секунды, - это использовать &lt;code&gt;PosixTimeZone&lt;/code&gt; с часовым поясом, имя которого начинается с &amp;laquo;right /&amp;raquo;. Эти файлы часовых поясов включают в себя дополнительные секунды, и &lt;code&gt;PosixTimeZone&lt;/code&gt; примет их во внимание (хотя системы posix, которые используют часовой пояс &amp;laquo;вправо /&amp;raquo; в качестве своего местного часового пояса,</target>
        </trans-unit>
        <trans-unit id="64deb7f976a8cd98e26158b9c8e43cd6ab842a23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;evenChunks&lt;/code&gt; takes a chunk count (not size). The returned range will contain zero or more &lt;code&gt;source.length / chunkCount + 1&lt;/code&gt; elements followed by &lt;code&gt;source.length / chunkCount&lt;/code&gt; elements. If &lt;code&gt;source.length &amp;lt; chunkCount&lt;/code&gt;, some chunks will be empty.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;evenChunks&lt;/code&gt; принимает количество чанков (не размер). Возвращаемый диапазон будет содержать ноль или более &lt;code&gt;source.length / chunkCount + 1&lt;/code&gt; за которыми следуют элементы &lt;code&gt;source.length / chunkCount&lt;/code&gt; . Если &lt;code&gt;source.length &amp;lt; chunkCount&lt;/code&gt; , некоторые чанки будут пустыми.</target>
        </trans-unit>
        <trans-unit id="dcac2deafdbf1d1c8f905ae685dd247664bd1125" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#environment.opIndex&quot;&gt;&lt;code&gt;environment.opIndex&lt;/code&gt;&lt;/a&gt;, this function never throws on Posix.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#environment.opIndex&quot;&gt; &lt;code&gt;environment.opIndex&lt;/code&gt; &lt;/a&gt; , эта функция никогда не вызывает Posix.</target>
        </trans-unit>
        <trans-unit id="78c9b1ecfc17a2d5366ab58d22803f6df68d29c3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#popFrontN&quot;&gt;&lt;code&gt;popFrontN&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;popFrontExactly&lt;/code&gt; will assume that the range holds at least &lt;code&gt;n&lt;/code&gt; elements. This makes &lt;code&gt;popFrontExactly&lt;/code&gt; faster than &lt;code&gt;popFrontN&lt;/code&gt;, but it also means that if &lt;code&gt;range&lt;/code&gt; does not contain at least &lt;code&gt;n&lt;/code&gt; elements, it will attempt to call &lt;code&gt;popFront&lt;/code&gt; on an empty range, which is undefined behavior. So, only use &lt;code&gt;popFrontExactly&lt;/code&gt; when it is guaranteed that &lt;code&gt;range&lt;/code&gt; holds at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#popFrontN&quot;&gt; &lt;code&gt;popFrontN&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;popFrontExactly&lt;/code&gt; будет предполагать, что диапазон содержит не менее &lt;code&gt;n&lt;/code&gt; элементов. Это делает &lt;code&gt;popFrontExactly&lt;/code&gt; быстрее, чем &lt;code&gt;popFrontN&lt;/code&gt; , но это также означает, что если &lt;code&gt;range&lt;/code&gt; не содержит хотя бы &lt;code&gt;n&lt;/code&gt; элементов, он попытается вызвать &lt;code&gt;popFront&lt;/code&gt; для пустого диапазона, что является неопределенным поведением. Поэтому используйте &lt;code&gt;popFrontExactly&lt;/code&gt; только тогда, когда гарантируется, что &lt;code&gt;range&lt;/code&gt; содержит не менее &lt;code&gt;n&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="ca26f78b889208702d57ff1d787f37620c2c7d92" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, however, it is illegal to pass a range with less than &lt;code&gt;n&lt;/code&gt; elements to &lt;code&gt;takeExactly&lt;/code&gt;; this will cause an assertion failure.</source>
          <target state="translated">Однако, в отличие от &lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; , в &lt;code&gt;takeExactly&lt;/code&gt; нельзя передавать диапазон с менее чем &lt;code&gt;n&lt;/code&gt; элементами ; это приведет к ошибке подтверждения.</target>
        </trans-unit>
        <trans-unit id="59fe163f287d88736da3589233f0c4e6d80fde94" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;take&lt;/code&gt; does not require that there are &lt;code&gt;n&lt;/code&gt; or more elements in &lt;code&gt;input&lt;/code&gt;. As a consequence, length information is not applied to the result unless &lt;code&gt;input&lt;/code&gt; also has length information.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;take&lt;/code&gt; не требует наличия &lt;code&gt;n&lt;/code&gt; или более элементов на &lt;code&gt;input&lt;/code&gt; . Как следствие, информация о длине не применяется к результату, если &lt;code&gt;input&lt;/code&gt; содержит информацию о длине.</target>
        </trans-unit>
        <trans-unit id="b8426ded2da3debb58d04add3a4a2ee0a01cedef" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s,</source>
          <target state="translated">В отличие от &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; s,</target>
        </trans-unit>
        <trans-unit id="3c0a127638c1aa0ed774f4d832ca5f66eb374213" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt;, underscores (&lt;code&gt;_&lt;/code&gt;) are not supported for emphasizing text because it would break snake_case names and underscore prefix processing in &lt;a href=&quot;#emphasis&quot;&gt;identifier emphasis&lt;/a&gt;.</source>
          <target state="translated">В отличие от &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt; , подчеркивания ( &lt;code&gt;_&lt;/code&gt; ) не поддерживаются для &lt;a href=&quot;#emphasis&quot;&gt;выделения&lt;/a&gt; текста, потому что это сломало бы имена snake_case и подчеркивало префиксную обработку при выделении идентификатора .</target>
        </trans-unit>
        <trans-unit id="62d6e6c303937f42cfdcfdeece835bc7d820f2ce" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;dropExactly&lt;/code&gt; will assume that the range holds at least &lt;code&gt;n&lt;/code&gt; elements. This makes &lt;code&gt;dropExactly&lt;/code&gt; faster than &lt;code&gt;drop&lt;/code&gt;, but it also means that if &lt;code&gt;range&lt;/code&gt; does not contain at least &lt;code&gt;n&lt;/code&gt; elements, it will attempt to call &lt;code&gt;popFront&lt;/code&gt; on an empty range, which is undefined behavior. So, only use &lt;code&gt;popFrontExactly&lt;/code&gt; when it is guaranteed that &lt;code&gt;range&lt;/code&gt; holds at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">В отличие от &lt;code&gt;drop&lt;/code&gt; , &lt;code&gt;dropExactly&lt;/code&gt; будет предполагать, что диапазон содержит не менее &lt;code&gt;n&lt;/code&gt; элементов. Это делает &lt;code&gt;dropExactly&lt;/code&gt; быстрее, чем &lt;code&gt;drop&lt;/code&gt; , но это также означает, что если &lt;code&gt;range&lt;/code&gt; не содержит хотя бы &lt;code&gt;n&lt;/code&gt; элементов, он попытается вызвать &lt;code&gt;popFront&lt;/code&gt; для пустого диапазона, что является неопределенным поведением. Поэтому используйте &lt;code&gt;popFrontExactly&lt;/code&gt; только тогда, когда гарантируется, что &lt;code&gt;range&lt;/code&gt; содержит не менее &lt;code&gt;n&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="2dc495b4828660cfb1a6c926b761c16a9be27525" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;isSorted&lt;/code&gt;, &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; does not allow for equal values, i.e. values for which both &lt;code&gt;less(a, b)&lt;/code&gt; and &lt;code&gt;less(b, a)&lt;/code&gt; are false.</source>
          <target state="translated">В отличие от &lt;code&gt;isSorted&lt;/code&gt; , &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; не допускает одинаковые значения, то есть значения, для которых оба &lt;code&gt;less(a, b)&lt;/code&gt; и &lt;code&gt;less(b, a)&lt;/code&gt; являются ложными.</target>
        </trans-unit>
        <trans-unit id="d9f03ddd3a521372a8aeb68d3750dc19aca654fd" translate="yes" xml:space="preserve">
          <source>Unlike C, there is no global 'errno' variable. Consequently, almost all of these functions are pure nothrow.</source>
          <target state="translated">В отличие от C,глобальной переменной 'errno' нет.Следовательно,почти все эти функции являются чистыми.</target>
        </trans-unit>
        <trans-unit id="48065da6c19826224a06652b7752de447906d1e2" translate="yes" xml:space="preserve">
          <source>Unlike a template instantiation, a template mixin's body is evaluated within the scope where the mixin appears, not where the template declaration is defined. It is analogous to cutting and pasting the body of the template into the location of the mixin into a &lt;a href=&quot;#mixin_scope&quot;&gt;nested scope&lt;/a&gt;. It is useful for injecting parameterized &amp;lsquo;boilerplate&amp;rsquo; code, as well as for creating templated nested functions, which is not possible with template instantiations.</source>
          <target state="translated">В отличие от создания шаблона, тело шаблонного миксина оценивается в области, в которой он присутствует, а не там, где определено объявление шаблона. Это аналогично вырезанию и вставке тела шаблона в расположение миксина во &lt;a href=&quot;#mixin_scope&quot;&gt;вложенную область видимости&lt;/a&gt; . Это полезно для внедрения параметризованного &amp;laquo;шаблонного&amp;raquo; кода, а также для создания шаблонных вложенных функций, что невозможно при создании экземпляров шаблона.</target>
        </trans-unit>
        <trans-unit id="b78dd4d0c28721d6f33da60e8a9c5d426e8812c8" translate="yes" xml:space="preserve">
          <source>Unlike classes and interfaces with D linkage, &lt;code&gt;extern (C++)&lt;/code&gt; classes and interfaces are not rooted in &lt;code&gt;Object&lt;/code&gt; and cannot be used with &lt;code&gt;typeid&lt;/code&gt;.</source>
          <target state="translated">В отличие от классов и интерфейсов с D-связью, классы и интерфейсы &lt;code&gt;extern (C++)&lt;/code&gt; не имеют &lt;code&gt;typeid&lt;/code&gt; в &lt;code&gt;Object&lt;/code&gt; и не могут использоваться с typeid .</target>
        </trans-unit>
        <trans-unit id="c4a06fb407933b874e0e43772b69d5b66b0d98d0" translate="yes" xml:space="preserve">
          <source>Unlike module level declarations, declarations within function scope are processed in order. This means that two nested functions cannot mutually call each other:</source>
          <target state="translated">В отличие от деклараций модульного уровня,декларации в пределах функционального диапазона обрабатываются по порядку.Это означает,что две вложенные функции не могут взаимно вызывать друг друга:</target>
        </trans-unit>
        <trans-unit id="1e921c8f35a8b97ca5f6203bfbaa7a401ab85c77" translate="yes" xml:space="preserve">
          <source>Unlike other functional programming languages, D's &lt;code&gt;pure&lt;/code&gt; functions allow modification of the caller state through their mutable parameters.</source>
          <target state="translated">В отличие от других функциональных языков программирования, &lt;code&gt;pure&lt;/code&gt; функции D позволяют изменять состояние вызывающей стороны через их изменяемые параметры.</target>
        </trans-unit>
        <trans-unit id="0b036ee20c8407122782725738b7cc625cbeaae0" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;shared&lt;/code&gt; attribute, &lt;code&gt;__gshared&lt;/code&gt; provides no safe-guards against data races or other multi-threaded synchronization issues. It is the responsibility of the programmer to ensure that access to variables marked &lt;code&gt;__gshared&lt;/code&gt; is synchronized correctly.</source>
          <target state="translated">В отличие от &lt;code&gt;shared&lt;/code&gt; атрибута, &lt;code&gt;__gshared&lt;/code&gt; не обеспечивает защиты от скачек данных или других проблем многопоточной синхронизации. Программист несет ответственность за правильную синхронизацию доступа к переменным, отмеченным &lt;code&gt;__gshared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c04836bfb0781712a35902e55ee66bab09a7b952" translate="yes" xml:space="preserve">
          <source>Unlike the allocators for the C and C++ programming languages, which manage the allocated size internally, these allocators require that the client maintains (or knows</source>
          <target state="translated">В отличие от аллокаторов для языков программирования C и C++,которые управляют выделенным размером внутренне,эти аллокаторы требуют,чтобы клиент поддерживал (или знает</target>
        </trans-unit>
        <trans-unit id="4328a809b4119b5d1cdcaad1f63f238165209f39" translate="yes" xml:space="preserve">
          <source>Unlike the other modules in std.datetime, this module is not currently publicly imported in std.datetime.package, because the old versions of this functionality which use &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt; are in std.datetime.package and would conflict with the symbols in this module. After the old symbols have gone through the deprecation cycle and have been fully removed, then this module will be publicly imported in std.datetime.package. The old, deprecated symbols are currently scheduled to be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">В отличие от других модулей в std.datetime, этот модуль в настоящее время публично не импортируется в std.datetime.package, потому что старые версии этой функции, которые используют &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; ,&lt;/a&gt; находятся в std.datetime.package и будут конфликтовать с символами в этом модуле. После того, как старые символы прошли цикл устаревания и были полностью удалены, этот модуль будет публично импортирован в std.datetime.package. Старые устаревшие символы в настоящее время планируется удалить из документации в октябре 2018 года и полностью удалить из Фобоса в октябре 2019 года.</target>
        </trans-unit>
        <trans-unit id="2e44048ada6dc1ea0f3431423758e0f9238ad67a" translate="yes" xml:space="preserve">
          <source>Unlike the other modules in std.datetime, this module is not currently publicly imported in std.datetime.package, because the old versions of this functionality which use &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt; are in std.datetime.package and would conflict with the symbols in this module. After the old symbols have gone through the deprecation cycle and have been fully removed, then this module will be publicly imported in std.datetime.package. The old, deprecated symbols has been removed from the documentation in December 2019 and currently scheduled to be fully removed from Phobos after 2.094.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a96be23bb834e45b7c6ec859f0a33bbc2f1ea04" translate="yes" xml:space="preserve">
          <source>Unlike the other overloads of &lt;a href=&quot;#translate&quot;&gt;&lt;code&gt;translate&lt;/code&gt;&lt;/a&gt;, this one does not take an AA. Rather, it takes a &lt;code&gt;string&lt;/code&gt; generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В отличие от других перегрузок &lt;a href=&quot;#translate&quot;&gt; &lt;code&gt;translate&lt;/code&gt; &lt;/a&gt; , этот не требует AA. Скорее, он принимает &lt;code&gt;string&lt;/code&gt; сгенерированную &lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e414f9a9014ee44b7edd2f5c74b2ba99d64ccc" translate="yes" xml:space="preserve">
          <source>Unlike the rint functions, nearbyint does not raise the FE_INEXACT exception.</source>
          <target state="translated">В отличие от функций rint,близлежащийint не поднимает исключение FE_INEXACT.</target>
        </trans-unit>
        <trans-unit id="57cc5a44978b2a56fd0b72e29be98d16b0472af0" translate="yes" xml:space="preserve">
          <source>Unloads the dynamic library referenced by p. If this library contains a D runtime then any necessary finalization or cleanup of that runtime will be performed.</source>
          <target state="translated">Выгружает динамическую библиотеку,на которую ссылается p.Если эта библиотека содержит время выполнения D,то будет произведена любая необходимая доработка или очистка этого времени выполнения.</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">Уведомление о разблокировке</target>
        </trans-unit>
        <trans-unit id="664d16b3bbd5ce740428335dc91179d8203f0409" translate="yes" xml:space="preserve">
          <source>Unpacks the content of a &lt;code&gt;Nullable&lt;/code&gt;, performs an operation and packs it again. Does nothing if isNull.</source>
          <target state="translated">Распаковывает содержимое &lt;code&gt;Nullable&lt;/code&gt; , выполняет операцию и упаковывает ее снова. Ничего не делает, если isNull.</target>
        </trans-unit>
        <trans-unit id="cc345a9119374c547d811f8c7da41c9ef92ad2fe" translate="yes" xml:space="preserve">
          <source>Unpadded variation of Base64 encoding that is safe for use in URLs and filenames, as used in RFCs 4648 and 7515 (JWS/JWT/JWE).</source>
          <target state="translated">Некорректное изменение кодировки Base64,безопасное для использования в URL и именах файлов,как в RFC 4648 и 7515 (JWS/JWT/JWE).</target>
        </trans-unit>
        <trans-unit id="f88d720623b583f1cffc913373fdcc3a60ba2726" translate="yes" xml:space="preserve">
          <source>Unqual!(ElementEncodingType!R)[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(Allocator, R)(auto ref Allocator alloc, R range)</source>
          <target state="translated">Unqual! (ElementEncodingType! R) [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (Allocator, R) (автоматическая ссылка Allocator alloc, R range)</target>
        </trans-unit>
        <trans-unit id="3c02fdbec5f33d0e592b953502081d961d449bb0" translate="yes" xml:space="preserve">
          <source>Unqual!(Largest!(F, H)) &lt;strong id=&quot;powmod&quot;&gt;powmod&lt;/strong&gt;(F, G, H)(F x, G n, H m)</source>
          <target state="translated">Unqual! (Самый большой! (F, H)) &lt;strong id=&quot;powmod&quot;&gt;Powmod&lt;/strong&gt; (F, G, H) (F x, G n, H m)</target>
        </trans-unit>
        <trans-unit id="2bcb32fecdb532acd729e7486f0232969b7c3e9c" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(alias rfunc = rint, F)(const F val, const F unit)</source>
          <target state="translated">Unqual! F &lt;strong id=&quot;quantize&quot;&gt;квантование&lt;/strong&gt; (псевдоним rfunc = rint, F) (const F val, const F unit)</target>
        </trans-unit>
        <trans-unit id="9a98f2e85574e76d68401f4ce73c39509c4a2933" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(real base, alias rfunc = rint, F, E)(const F val, const E exp)</source>
          <target state="translated">Unqual! F &lt;strong id=&quot;quantize&quot;&gt;квантовать&lt;/strong&gt; (действительное основание, псевдоним rfunc = rint, F, E) (const F val, const E exp)</target>
        </trans-unit>
        <trans-unit id="1e2635e37463787b5dba88522830617f525b628d" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(real base, long exp = 1, alias rfunc = rint, F)(const F val)</source>
          <target state="translated">Unqual! F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt; (действительная база, long exp = 1, псевдоним rfunc = rint, F) (const F val)</target>
        </trans-unit>
        <trans-unit id="5a8d3ca0e300be0d25c318a263a03af4f2fff63d" translate="yes" xml:space="preserve">
          <source>Unqualified data has unqualified affixes.</source>
          <target state="translated">Неквалифицированные данные имеют безоговорочные аффиксы.</target>
        </trans-unit>
        <trans-unit id="c723d38c4fa3b7930c545d9e405d1f146212a63e" translate="yes" xml:space="preserve">
          <source>Unrestricted use of compile-time features</source>
          <target state="translated">Неограниченное использование возможностей времени компиляции</target>
        </trans-unit>
        <trans-unit id="80cfb4a037726fdae410bbf6df144554bff220d4" translate="yes" xml:space="preserve">
          <source>Unsafe function that wraps an existing &lt;code&gt;FILE*&lt;/code&gt;. The resulting &lt;code&gt;File&lt;/code&gt; never takes the initiative in closing the file. Note that the created file has no &lt;a href=&quot;#name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Небезопасная функция, которая упаковывает существующий &lt;code&gt;FILE*&lt;/code&gt; . Получающийся &lt;code&gt;File&lt;/code&gt; никогда не берет на себя инициативу в закрытии файла. Обратите внимание, что созданный файл не имеет &lt;a href=&quot;#name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65422cb666169d3f3987078a0c14c3573d3c2445" translate="yes" xml:space="preserve">
          <source>Unsigned long divide.</source>
          <target state="translated">Неподписанное длинное разделение.</target>
        </trans-unit>
        <trans-unit id="0b87e9858f088c1c3ef7326a4daa7bc92af7a7dd" translate="yes" xml:space="preserve">
          <source>Unsigned or signed integers to strings.</source>
          <target state="translated">Беззнаковые или подписанные целые числа к строкам.</target>
        </trans-unit>
        <trans-unit id="7dd2dae7076eed8003f9916d0a11ef6b86330446" translate="yes" xml:space="preserve">
          <source>Unsigned types are forwarded</source>
          <target state="translated">Пересылаются неподписанные типы</target>
        </trans-unit>
        <trans-unit id="db264537a77391b4d1ffa4ba5078dbd65e89c632" translate="yes" xml:space="preserve">
          <source>Unsigned!T &lt;strong id=&quot;absUnsign&quot;&gt;absUnsign&lt;/strong&gt;(T)(T x)</source>
          <target state="translated">Без &lt;strong id=&quot;absUnsign&quot;&gt;знака&lt;/strong&gt; ! T &lt;strong id=&quot;absUnsign&quot;&gt;absUnsign&lt;/strong&gt; (T) (T x)</target>
        </trans-unit>
        <trans-unit id="ee28505eeae48ed21fb9c1a0cf9d2afe5eb71525" translate="yes" xml:space="preserve">
          <source>Unspecified address family</source>
          <target state="translated">Неопределенная адресная семья</target>
        </trans-unit>
        <trans-unit id="12a25d56dc3fd00254d1725dedadf02ca44b6632" translate="yes" xml:space="preserve">
          <source>Until!(pred, Range, Sentinel) &lt;strong id=&quot;until&quot;&gt;until&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range, Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = Yes.openRight)</source>
          <target state="translated">До! (Пред, Range, Страж) &lt;strong id=&quot;until&quot;&gt;до&lt;/strong&gt; (псевдоним = пред &quot;A == B&quot;, Range, Страж) (диапазон Range, Страж дозорного, OpenRight openRight = Yes.openRight)</target>
        </trans-unit>
        <trans-unit id="4b4508b4a6bcff851bf86982a2055c2003b1fa47" translate="yes" xml:space="preserve">
          <source>Until!(pred, Range, void) &lt;strong id=&quot;until&quot;&gt;until&lt;/strong&gt;(alias pred, Range)(Range range, OpenRight openRight = Yes.openRight);</source>
          <target state="translated">До! (Pred, Range, void) &lt;strong id=&quot;until&quot;&gt;до&lt;/strong&gt; (псевдоним pred, Range) (Диапазон диапазона, OpenRight openRight = Yes.openRight);</target>
        </trans-unit>
        <trans-unit id="9c59dea84fd569db02119fea1a063859bf29b83a" translate="yes" xml:space="preserve">
          <source>Untyped array of bytes read.</source>
          <target state="translated">Незапечатанный массив прочитанных байт.</target>
        </trans-unit>
        <trans-unit id="4136979d06ff082f9f315b1eebb740ff6c03f3f6" translate="yes" xml:space="preserve">
          <source>Unused</source>
          <target state="translated">Unused</target>
        </trans-unit>
        <trans-unit id="b6935e98e40b6e21b32a31ee8441a03644c81e5c" translate="yes" xml:space="preserve">
          <source>Update real environment with our copy.</source>
          <target state="translated">Обновите реальную среду с помощью нашей копии.</target>
        </trans-unit>
        <trans-unit id="9bfdc7ffd31c3f1d9f8a46b9030a47cb21f4a6a6" translate="yes" xml:space="preserve">
          <source>Upload file from local files system using the HTTP or FTP protocol.</source>
          <target state="translated">Загрузка файла из локальной файловой системы по протоколу HTTP или FTP.</target>
        </trans-unit>
        <trans-unit id="d92a94252ae6e6e7308555bfab068876b651496a" translate="yes" xml:space="preserve">
          <source>Upon a correct comparison, returns the result of the comparison. Otherwise, the function terminates the application so it never returns.</source>
          <target state="translated">При правильном сравнении возвращает результат сравнения.В противном случае функция завершает работу приложения и никогда не возвращает результат.</target>
        </trans-unit>
        <trans-unit id="635a8d59b65d6fe6e79727c2b607e63e7021a7fc" translate="yes" xml:space="preserve">
          <source>Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it throws a &lt;code&gt;Throw.CheckedFailure&lt;/code&gt; exception.</source>
          <target state="translated">При ошибочном сравнении, таком как &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; , функция никогда не возвращается, поскольку выдает исключение &lt;code&gt;Throw.CheckedFailure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa0a038d12e10d6ea11977030e0079027d88a558" translate="yes" xml:space="preserve">
          <source>Upon deallocation, the deallocated block is inserted in the internally maintained free tree (not returned to the parent). The free tree is not kept balanced. Instead, it has a last-in-first-out flavor because newly inserted blocks are rotated to the root of the tree. That way allocations are cache friendly and also frequently used sizes are more likely to be found quickly, whereas seldom used sizes migrate to the leaves of the tree.</source>
          <target state="translated">При распределении сделок блок с распределением вставляется во внутренне поддерживаемое свободное дерево (не возвращается родителю).Свободное дерево не поддерживается в равновесии.Вместо этого,дерево имеет последний в своем роде вкус,потому что вновь вставленные блоки поворачиваются к корню дерева.Таким образом,назначения дружелюбны к кэш-памяти,а также часто используемые размеры быстрее находят,в то время как редко используемые размеры мигрируют к листьям дерева.</target>
        </trans-unit>
        <trans-unit id="5f1bf936fc97a8f0474440921cf17c9bca92dd9a" translate="yes" xml:space="preserve">
          <source>Upper case letters</source>
          <target state="translated">заглавные буквы</target>
        </trans-unit>
        <trans-unit id="83087183cf2fc461034d823bb990cf31750aea63" translate="yes" xml:space="preserve">
          <source>Uppercase</source>
          <target state="translated">Uppercase</target>
        </trans-unit>
        <trans-unit id="7a4164382331e68559c0554c6d69676b3cadeb03" translate="yes" xml:space="preserve">
          <source>Uppercase_Letter</source>
          <target state="translated">Uppercase_Letter</target>
        </trans-unit>
        <trans-unit id="c697647e510548f93776f9aafa822873da30eacb" translate="yes" xml:space="preserve">
          <source>UprExpression</source>
          <target state="translated">UprExpression</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="607204c2f99f603cd34be761bcbeaa8343288f47" translate="yes" xml:space="preserve">
          <source>Usage is otherwise identical to &lt;code&gt;task&lt;/code&gt;.</source>
          <target state="translated">В остальном использование идентично &lt;code&gt;task&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47d7700c39adc856cd703ac849cd6f7a58cd58a0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#DigestType&quot;&gt;&lt;code&gt;DigestType&lt;/code&gt;&lt;/a&gt; to obtain the actual return type.</source>
          <target state="translated">Используйте &lt;a href=&quot;#DigestType&quot;&gt; &lt;code&gt;DigestType&lt;/code&gt; &lt;/a&gt; для получения фактического типа возврата.</target>
        </trans-unit>
        <trans-unit id="adbbdb084a9fb0ec3254af6094f4eb6c04b801eb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#digestLength&quot;&gt;&lt;code&gt;digestLength&lt;/code&gt;&lt;/a&gt; to obtain the length of the ubyte array.</source>
          <target state="translated">Используйте &lt;a href=&quot;#digestLength&quot;&gt; &lt;code&gt;digestLength&lt;/code&gt; ,&lt;/a&gt; чтобы получить длину массива ubyte.</target>
        </trans-unit>
        <trans-unit id="b3231f8622cd090ef9e587f5edbb465aca7b09c8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#feqrel&quot;&gt;&lt;code&gt;feqrel&lt;/code&gt;&lt;/a&gt; to get the number of equal bits in the mantissa.</source>
          <target state="translated">Используйте &lt;a href=&quot;#feqrel&quot;&gt; &lt;code&gt;feqrel&lt;/code&gt; ,&lt;/a&gt; чтобы получить количество равных битов в мантиссе.</target>
        </trans-unit>
        <trans-unit id="6d9307c326b8942333b6c398ebd4c07ddf71f566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#isFunctionPointer&quot;&gt;&lt;code&gt;isFunctionPointer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#isDelegate&quot;&gt;&lt;code&gt;isDelegate&lt;/code&gt;&lt;/a&gt; for detecting those types respectively.</source>
          <target state="translated">Используйте &lt;a href=&quot;#isFunctionPointer&quot;&gt; &lt;code&gt;isFunctionPointer&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#isDelegate&quot;&gt; &lt;code&gt;isDelegate&lt;/code&gt; &lt;/a&gt; для обнаружения этих типов соответственно.</target>
        </trans-unit>
        <trans-unit id="05ceeae1c0ec5acb33be5d48da2dcb40fadf69b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt; этого используйте makeTransTable .</target>
        </trans-unit>
        <trans-unit id="f0a91d81a9ba5ac4e99ca49d89974cc7a9058e19" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;std_range#only&quot;&gt;&lt;code&gt;std.range.only&lt;/code&gt;&lt;/a&gt; to find single elements:</source>
          <target state="translated">Используйте &lt;a href=&quot;std_range#only&quot;&gt; &lt;code&gt;std.range.only&lt;/code&gt; ,&lt;/a&gt; чтобы найти отдельные элементы:</target>
        </trans-unit>
        <trans-unit id="48dd858d3ce799ecfe17031cfb5c7e47121b6231" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Yes.keepTerminator&lt;/code&gt; to include the terminator at the end of each line.</source>
          <target state="translated">Используйте &lt;code&gt;Yes.keepTerminator&lt;/code&gt; , чтобы включить терминатор в конце каждой строки.</target>
        </trans-unit>
        <trans-unit id="8b6c1674d2f204c22694f576b979cd1814df2141" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fold&lt;/code&gt; instead of &lt;code&gt;reduce&lt;/code&gt; to use the seed version in a UFCS chain.</source>
          <target state="translated">Используйте &lt;code&gt;fold&lt;/code&gt; вместо &lt;code&gt;reduce&lt;/code&gt; чтобы использовать начальную версию в цепочке UFCS.</target>
        </trans-unit>
        <trans-unit id="ffd1556b516ef1f66dbe93c932b16f01c4bc9667" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ptrdiff_t&lt;/code&gt; as an alias for a signed integral type that can span the address space. A type representing the difference between two pointers should be of type &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;ptrdiff_t&lt;/code&gt; в качестве псевдонима для целочисленного типа со знаком, который может охватывать адресное пространство. Тип, представляющий разницу между двумя указателями, должен иметь тип &lt;code&gt;ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fdf440fcaae93b5efe254ec61870d973ace818a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;size_t&lt;/code&gt; as an alias for an unsigned integral type that can span the address space. Array indices should be of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;size_t&lt;/code&gt; в качестве псевдонима для целого типа без знака, который может охватывать адресное пространство. Индексы массива должны иметь тип &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c8e53d39e2a0f98ecbcc400dea4845b6223508c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;t.expand&lt;/code&gt; for a &lt;code&gt;Tuple&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to expand it into its components. The result of &lt;code&gt;expand&lt;/code&gt; acts as if the &lt;code&gt;Tuple&lt;/code&gt;'s components were listed as a list of values. (Ordinarily, a &lt;code&gt;Tuple&lt;/code&gt; acts as a single value.)</source>
          <target state="translated">Используйте &lt;code&gt;t.expand&lt;/code&gt; для &lt;code&gt;Tuple&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; , чтобы развернуть его в его компоненты. Результат &lt;code&gt;expand&lt;/code&gt; действует так, как если бы компоненты &lt;code&gt;Tuple&lt;/code&gt; были перечислены в виде списка значений. (Обычно &lt;code&gt;Tuple&lt;/code&gt; действует как единое значение.)</target>
        </trans-unit>
        <trans-unit id="48d884b7ca15aa475ec50789ca2ff3e23d86c484" translate="yes" xml:space="preserve">
          <source>Use EnumMembers to generate a switch statement using static foreach.</source>
          <target state="translated">Используйте EnumMember,чтобы сгенерировать оператор переключения со статического foreach.</target>
        </trans-unit>
        <trans-unit id="ea3185b41d0b5eef9ea7299e9eaac7a36af0572e" translate="yes" xml:space="preserve">
          <source>Use a delegate:</source>
          <target state="translated">Используйте делегата:</target>
        </trans-unit>
        <trans-unit id="0c1e0d0bf9ac652eb81fddab0fdf99124b593eff" translate="yes" xml:space="preserve">
          <source>Use a lambda to get the thrown object.</source>
          <target state="translated">Используйте лямбда,чтобы получить брошенный объект.</target>
        </trans-unit>
        <trans-unit id="873a141220012e552838fdcfee0dd363789fe021" translate="yes" xml:space="preserve">
          <source>Use a range for splitting</source>
          <target state="translated">Используйте диапазон для разделения</target>
        </trans-unit>
        <trans-unit id="743a812236b290eb42a4bbf575f256526d81c48f" translate="yes" xml:space="preserve">
          <source>Use a separate mutex when init blocks on another thread that might also call initOnce.</source>
          <target state="translated">Используйте отдельный мьютекс,когда блоки init на другом потоке,который также может вызвать initOnce.</target>
        </trans-unit>
        <trans-unit id="b175392fd564ac3cefbc17dfb5b685defa989e44" translate="yes" xml:space="preserve">
          <source>Use a union to share storage with a pointer:</source>
          <target state="translated">Используйте профсоюз,чтобы поделиться хранением с указателем:</target>
        </trans-unit>
        <trans-unit id="b01dba754a5979101f473d00f0a72b08eaa453e0" translate="yes" xml:space="preserve">
          <source>Use an automated tool such as SWIG to construct a C wrapper.</source>
          <target state="translated">Используйте автоматический инструмент,такой как SWIG,для создания C-обертки.</target>
        </trans-unit>
        <trans-unit id="391314ce9442e0f12875856e20c62869fdd57c69" translate="yes" xml:space="preserve">
          <source>Use an existing socket handle.</source>
          <target state="translated">Используйте существующую ручку-розетку.</target>
        </trans-unit>
        <trans-unit id="a7f84b37a52370f02dd55991fe07b971f3630397" translate="yes" xml:space="preserve">
          <source>Use bitwise OR to combine flags.</source>
          <target state="translated">Используйте побитовое &quot;ИЛИ&quot; для объединения флагов.</target>
        </trans-unit>
        <trans-unit id="d8684aed3619612b2b8756065eb3877a3a2f839f" translate="yes" xml:space="preserve">
          <source>Use dynamic arrays for larger arrays.</source>
          <target state="translated">Используйте динамические массивы для больших массивов.</target>
        </trans-unit>
        <trans-unit id="666b47896c954d06222547665bcbfad2b613e2cd" translate="yes" xml:space="preserve">
          <source>Use dynamic arrays instead of pointers to arrays as much as practical. Indexing of dynamic arrays are bounds checked, avoiding buffer underflow and overflow problems.</source>
          <target state="translated">Используйте динамические массивы вместо указателей на массивы,насколько это практично.Индексация динамических массивов-это проверка границ,позволяющая избежать проблем с переполнением буфера и переполнением.</target>
        </trans-unit>
        <trans-unit id="7d2098c363acbeebbd0189589ce87c1539461b35" translate="yes" xml:space="preserve">
          <source>Use exceptions when input has incorrect CSV.</source>
          <target state="translated">Используйте исключения,если на входе есть неправильное CSV.</target>
        </trans-unit>
        <trans-unit id="4f7a702bd6e584b41d91d0f760813b556c810824" translate="yes" xml:space="preserve">
          <source>Use instead:</source>
          <target state="translated">Используй вместо этого:</target>
        </trans-unit>
        <trans-unit id="a0bd8b9fd1352e9a7ee83b86e96f850112dd5cf1" translate="yes" xml:space="preserve">
          <source>Use leading zeros to pad rather than spaces (except for the floating point values &lt;code&gt;nan&lt;/code&gt; and &lt;code&gt;infinity&lt;/code&gt;). Ignore if there's a</source>
          <target state="translated">Используйте начальные нули для заполнения, а не пробелов (за исключением значений с плавающей точкой &lt;code&gt;nan&lt;/code&gt; и &lt;code&gt;infinity&lt;/code&gt; ). Игнорировать, если есть</target>
        </trans-unit>
        <trans-unit id="e9eb0693d837d691dc401377d0b5f372d6ba7c76" translate="yes" xml:space="preserve">
          <source>Use native byte order</source>
          <target state="translated">Использовать родной порядок байт</target>
        </trans-unit>
        <trans-unit id="494d644b4cea82b0f2a11f12d31fe2c2c6340bb0" translate="yes" xml:space="preserve">
          <source>Use of this facility may invalidate grapheme cluster, see also &lt;a href=&quot;#Grapheme.valid&quot;&gt;&lt;code&gt;Grapheme.valid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Использование этого средства может сделать недействительным кластер графем, см. Также &lt;a href=&quot;#Grapheme.valid&quot;&gt; &lt;code&gt;Grapheme.valid&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b875251d6eb81c5967bf6e62329a54f26bfa6687" translate="yes" xml:space="preserve">
          <source>Use of this facility may invalidate grapheme cluster, see also &lt;code&gt;valid&lt;/code&gt;.</source>
          <target state="translated">Использование этого средства может сделать недействительным кластер графем, см. Также &lt;code&gt;valid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="884a243fefd8e60fe323817fec2a996c8bebbfbc" translate="yes" xml:space="preserve">
          <source>Use of void initializers is rarely useful for individual local variables, as a modern optimizer will remove the dead store of its initialization if it is initialized later.</source>
          <target state="translated">Использование пустых инициализаторов редко полезно для отдельных локальных переменных,так как современный оптимизатор при последующей инициализации удалит мертвое хранилище своей инициализации.</target>
        </trans-unit>
        <trans-unit id="5f23be35fdcc7ad601fb3afd85d59caa262fe40f" translate="yes" xml:space="preserve">
          <source>Use of with object symbols that shadow local symbols with the same identifier are not allowed. This is to reduce the risk of inadvertent breakage of with statements when new members are added to the object declaration.</source>
          <target state="translated">Использование с символами объектов,что теневые локальные символы с одним и тем же идентификатором не допускаются.Это делается для того,чтобы снизить риск случайного разрыва с утверждениями при добавлении новых членов в объявление объекта.</target>
        </trans-unit>
        <trans-unit id="191654677e98da602653c371d9dfd799ee8ada8a" translate="yes" xml:space="preserve">
          <source>Use only if you have waited on every &lt;code&gt;Task&lt;/code&gt; and therefore know the queue is empty, or if you speculatively executed some tasks and no longer need the results.</source>
          <target state="translated">Используйте только в том случае, если вы ожидали выполнения каждой &lt;code&gt;Task&lt;/code&gt; и, следовательно, знаете, что очередь пуста, или если вы спекулятивно выполнили некоторые задачи и вам больше не нужны результаты.</target>
        </trans-unit>
        <trans-unit id="6a3134f25820d6e9b99efcc040afa78a19060e81" translate="yes" xml:space="preserve">
          <source>Use opSlice() from now on.</source>
          <target state="translated">Теперь используйте opSlice().</target>
        </trans-unit>
        <trans-unit id="0f7ce138690e71e3a3dfa4ced6f5458ab1f5899d" translate="yes" xml:space="preserve">
          <source>Use splitter without a separator</source>
          <target state="translated">Используйте разделитель без разделителя</target>
        </trans-unit>
        <trans-unit id="18386a6712ddd2e90ccdfcddd96ef23c786f1142" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#RangePrimitive&quot;&gt;&lt;code&gt;RangePrimitive&lt;/code&gt;&lt;/a&gt; enum to specify which primitives to handle. Multiple range primitives can be handled at once by using the &lt;code&gt;OR&lt;/code&gt; operator or the pseudo-primitives &lt;code&gt;RangePrimitive.access&lt;/code&gt; and &lt;code&gt;RangePrimitive.pop&lt;/code&gt;. All handled primitives must have return types or values compatible with the user-supplied handler.</source>
          <target state="translated">Используйте перечисление &lt;a href=&quot;#RangePrimitive&quot;&gt; &lt;code&gt;RangePrimitive&lt;/code&gt; ,&lt;/a&gt; чтобы указать, какие примитивы нужно обрабатывать. Примитивы с несколькими диапазонами могут обрабатываться одновременно с помощью оператора &lt;code&gt;OR&lt;/code&gt; или псевдопримитивов &lt;code&gt;RangePrimitive.access&lt;/code&gt; и &lt;code&gt;RangePrimitive.pop&lt;/code&gt; . Все обработанные примитивы должны иметь возвращаемые типы или значения, совместимые с предоставленным пользователем обработчиком.</target>
        </trans-unit>
        <trans-unit id="0b5f27af6328268d2605eb68f81d45548b5054bd" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#dur&quot;&gt;&lt;code&gt;dur&lt;/code&gt;&lt;/a&gt; function or one of its non-generic aliases to create &lt;code&gt;Duration&lt;/code&gt;s.</source>
          <target state="translated">Используйте функцию &lt;a href=&quot;#dur&quot;&gt; &lt;code&gt;dur&lt;/code&gt; &lt;/a&gt; или один из ее неуниверсальных псевдонимов для создания &lt;code&gt;Duration&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="78a059e1d81c669061770e6ebc73b731a6af9efd" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;arrayPtr&lt;/code&gt; overload of &lt;a href=&quot;#appender&quot;&gt;&lt;code&gt;appender&lt;/code&gt;&lt;/a&gt; for construction with type-inference.</source>
          <target state="translated">Используйте &lt;code&gt;arrayPtr&lt;/code&gt; перегрузку &lt;a href=&quot;#appender&quot;&gt; &lt;code&gt;appender&lt;/code&gt; &lt;/a&gt; для строительства с типом-вывода.</target>
        </trans-unit>
        <trans-unit id="d09a4630f154886909155b3e1ae35f59cb094891" translate="yes" xml:space="preserve">
          <source>Use the ForwardingScopeDsymbol as the parent symbol for members.</source>
          <target state="translated">Используйте ForwardingScopeDsymbol в качестве родительского символа для членов.</target>
        </trans-unit>
        <trans-unit id="225bd24669abe9be158ae39e2ef06005821005b8" translate="yes" xml:space="preserve">
          <source>Use the SOCKS5 protocol but pass along the host name rather than the IP address. added in 7.18.0</source>
          <target state="translated">Используйте протокол SOCKS5,но передавайте имя хоста,а не IP-адрес,добавленный в 7.18.0.</target>
        </trans-unit>
        <trans-unit id="5ad265a5408a557c8739bbf477749f03fe8edee2" translate="yes" xml:space="preserve">
          <source>Use the attributes &lt;code&gt;@nogc&lt;/code&gt; as much as possible on the &lt;code&gt;toHash&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; overrides.</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; используйте атрибуты @nogc в переопределениях &lt;code&gt;toHash&lt;/code&gt; и &lt;code&gt;opEquals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa837e971bab06ebe9fa8cced0faa302241fa259" translate="yes" xml:space="preserve">
          <source>Use the attributes &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; as much as possible on the &lt;code&gt;toHash&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; overrides.</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt; используйте атрибуты @safe , &lt;code&gt;@nogc&lt;/code&gt; , &lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; и &lt;code&gt;scope&lt;/code&gt; в переопределениях &lt;code&gt;toHash&lt;/code&gt; и &lt;code&gt;opEquals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73f4ee5c163a4b03bed0243fb0edd865f02a04da" translate="yes" xml:space="preserve">
          <source>Use the coarse clock, not the normal one (e.g. on Linux, that would be &lt;code&gt;CLOCK_REALTIME_COARSE&lt;/code&gt; instead of &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; for &lt;code&gt;clock_gettime&lt;/code&gt; if a function is using the realtime clock). It's generally faster to get the time with the coarse clock than the normal clock, but it's less precise (e.g. 1 msec instead of 1 usec or 1 nsec). Howeover, it</source>
          <target state="translated">Используйте грубые часы, а не нормальные (например, в Linux, это будет &lt;code&gt;CLOCK_REALTIME_COARSE&lt;/code&gt; вместо &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; для &lt;code&gt;clock_gettime&lt;/code&gt; , если функция использует часы реального времени). Как правило, быстрее получить время с грубыми часами, чем с обычными часами, но это менее точно (например, 1 мсек вместо 1 мксек или 1 нсек). Но как же</target>
        </trans-unit>
        <trans-unit id="b5e0f9bdfa9016956fef4c6395c40953244dbc05" translate="yes" xml:space="preserve">
          <source>Use the faster compile-time overload</source>
          <target state="translated">Используйте более быструю перегрузку по времени компиляции</target>
        </trans-unit>
        <trans-unit id="003ec607e3d7cca9e027c3ee29178ae85ad8baeb" translate="yes" xml:space="preserve">
          <source>Use the most visible overload to check visibility. Later perform an access check on the resolved overload. This function is similar to overloadApply, but doesn't recurse nor resolve aliases because protection/visibility is an attribute of the alias not the aliasee.</source>
          <target state="translated">Используйте наиболее заметную перегрузку для проверки видимости.Позже выполните проверку доступа к разрешенной перегрузке.Эта функция похожа на overloadApply,но не рекурсирует и не разрешает псевдонимы,потому что защита/видимость-это атрибут псевдонима,а не псевдонима.</target>
        </trans-unit>
        <trans-unit id="ecea27e7268c13a18f824b4741edffcbd21384fd" translate="yes" xml:space="preserve">
          <source>Use the normal clock.</source>
          <target state="translated">Используйте обычные часы.</target>
        </trans-unit>
        <trans-unit id="2decee5fdcb2e6abe0efae775d6d245ceb48d907" translate="yes" xml:space="preserve">
          <source>Use the optional &lt;code&gt;cookie&lt;/code&gt; argument to create different types of the same base type</source>
          <target state="translated">Используйте необязательный аргумент &lt;code&gt;cookie&lt;/code&gt; для создания разных типов одного базового типа.</target>
        </trans-unit>
        <trans-unit id="199dc20b591ee68d927b26f24f29015b8587604c" translate="yes" xml:space="preserve">
          <source>Use the two operand form of the instruction format;</source>
          <target state="translated">Используйте двухоперационную форму формата инструкции;</target>
        </trans-unit>
        <trans-unit id="95a7b20ad88258a006cdce3eb4a48069b1dcaa41" translate="yes" xml:space="preserve">
          <source>Use this attribute to attach an Objective-C selector to a method.</source>
          <target state="translated">Используйте этот атрибут для прикрепления селектора &quot;Цель-С&quot; к методу.</target>
        </trans-unit>
        <trans-unit id="4bb2c79967fecc4182a145b06d47c0f4b49f6ef8" translate="yes" xml:space="preserve">
          <source>Use this attribute to declare an ABI tag on a C++ symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7ee948a98daed0fa240ed47144ff4132b6001e" translate="yes" xml:space="preserve">
          <source>Use this constructor for string mixins.</source>
          <target state="translated">Используйте этот конструктор для строковых миксов.</target>
        </trans-unit>
        <trans-unit id="5b498b0856e978dcbbf4e0ffb7b97a34e638161a" translate="yes" xml:space="preserve">
          <source>Use this expression for error recovery. It should behave as a 'sink' to prevent further cascaded error messages.</source>
          <target state="translated">Используйте это выражение для устранения ошибок.Оно должно вести себя как &quot;раковина&quot;,чтобы предотвратить дальнейшие каскадные сообщения об ошибках.</target>
        </trans-unit>
        <trans-unit id="bd06c192db7792c4cf00ede209798b786767b1ca" translate="yes" xml:space="preserve">
          <source>Use this for multipart formpost building</source>
          <target state="translated">Используйте это для многокомпонентного строительства форм-постов</target>
        </trans-unit>
        <trans-unit id="7c6ab14342528c5b12e30f0b33b6f65a5c654581" translate="yes" xml:space="preserve">
          <source>Use this instead of creating new instances for commonly used literals such as 0 or 1.</source>
          <target state="translated">Используйте это вместо того,чтобы создавать новые экземпляры для часто используемых литералов,таких как 0 или 1.</target>
        </trans-unit>
        <trans-unit id="f3c0cff7dd757ca5c15bd47e9f720de6ca2a6e5e" translate="yes" xml:space="preserve">
          <source>Use this module to test out new functionality for &lt;a href=&quot;std_typecons#wrap&quot;&gt;&lt;code&gt;std.typecons.wrap&lt;/code&gt;&lt;/a&gt; which allows for a struct to be wrapped against an interface; the implementation in &lt;a href=&quot;std_typecons&quot;&gt;&lt;code&gt;std.typecons&lt;/code&gt;&lt;/a&gt; only allows for classes to use the wrap functionality.</source>
          <target state="translated">Используйте этот модуль для проверки новой функциональности для &lt;a href=&quot;std_typecons#wrap&quot;&gt; &lt;code&gt;std.typecons.wrap&lt;/code&gt; ,&lt;/a&gt; которая позволяет обернуть структуру в интерфейс; реализация в &lt;a href=&quot;std_typecons&quot;&gt; &lt;code&gt;std.typecons&lt;/code&gt; &lt;/a&gt; позволяет только классам использовать функциональность переноса .</target>
        </trans-unit>
        <trans-unit id="a95cb1b3a079b5ec85c4f5f432209f3bba70e39c" translate="yes" xml:space="preserve">
          <source>Use this only when it is certain there are no elements in use beyond the array in the memory block. If there are, those elements will be overwritten by appending to this array.</source>
          <target state="translated">Используйте это только в том случае,если уверены,что за пределами массива в блоке памяти нет элементов,которые можно использовать.Если они есть,то эти элементы будут перезаписаны добавлением в этот массив.</target>
        </trans-unit>
        <trans-unit id="a582381933463d5deb51e05bf545416141895fa5" translate="yes" xml:space="preserve">
          <source>Use this template to get the type which is returned by a digest's &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Используйте этот шаблон, чтобы получить тип, который возвращается методом &lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt; дайджеста .</target>
        </trans-unit>
        <trans-unit id="f759a1693042701634c4658a13cab1e8618f57f7" translate="yes" xml:space="preserve">
          <source>Use this to check if a type is a digest. See &lt;a href=&quot;#ExampleDigest&quot;&gt;&lt;code&gt;ExampleDigest&lt;/code&gt;&lt;/a&gt; to see what a type must provide to pass this check.</source>
          <target state="translated">Используйте это, чтобы проверить, является ли тип дайджестом. Посмотрите &lt;a href=&quot;#ExampleDigest&quot;&gt; &lt;code&gt;ExampleDigest&lt;/code&gt; ,&lt;/a&gt; чтобы увидеть, что тип должен предоставить, чтобы пройти эту проверку.</target>
        </trans-unit>
        <trans-unit id="dc036b8b38f636a8da26f31247bb9aaf42862d52" translate="yes" xml:space="preserve">
          <source>Use this to feed the digest with data. Also implements the &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;&lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt;&lt;/a&gt; interface for &lt;code&gt;ubyte&lt;/code&gt; and &lt;code&gt;const(ubyte)[]&lt;/code&gt;.</source>
          <target state="translated">Используйте это, чтобы заполнить дайджест данными. Также реализует интерфейс &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt; &lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;ubyte&lt;/code&gt; и &lt;code&gt;const(ubyte)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4716d195c3662fddb3b8f04d5d336c547d5e1633" translate="yes" xml:space="preserve">
          <source>Use this to feed the digest with data. Also implements the &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;&lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt;&lt;/a&gt; interface for &lt;code&gt;ubyte&lt;/code&gt; and &lt;code&gt;const(ubyte)[]&lt;/code&gt;. The following usages of &lt;code&gt;put&lt;/code&gt; must work for any type which passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Используйте это, чтобы заполнить дайджест данными. Также реализует интерфейс &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt; &lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;ubyte&lt;/code&gt; и &lt;code&gt;const(ubyte)[]&lt;/code&gt; . Следующее использование &lt;code&gt;put&lt;/code&gt; должно работать для любого типа, который передает &lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f0c5e9e55d90ec5f58114e5393a0956447e2f3df" translate="yes" xml:space="preserve">
          <source>Use tuples as ranges</source>
          <target state="translated">Используйте кортежи в качестве диапазонов</target>
        </trans-unit>
        <trans-unit id="27f93c20b3a083f74d82c63db067812d27ea3722" translate="yes" xml:space="preserve">
          <source>Use when we prefer the default initializer to be a literal, rather than a global immutable variable.</source>
          <target state="translated">Используется,когда мы предпочитаем,чтобы инициализатор по умолчанию был буквальным,а не глобальной неизменяемой переменной.</target>
        </trans-unit>
        <trans-unit id="8d5ca1642ce1a35cb57a7b97089dfc54c5486ae4" translate="yes" xml:space="preserve">
          <source>Use with care as the sub-matcher won't match any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; that have encoded length that doesn't belong to the selected set of lengths. Also the sub-matcher object references the parent matcher and must not be used past the liftetime of the latter.</source>
          <target state="translated">Используйте с осторожностью, так как субсоответствие не будет соответствовать никаким &lt;a href=&quot;#Code%20point&quot;&gt;кодовым точкам&lt;/a&gt; с кодированной длиной, которые не принадлежат выбранному набору длин. Кроме того, объект sub-matcher ссылается на родительский matcher и не должен использоваться после времени жизни последнего.</target>
        </trans-unit>
        <trans-unit id="83af243aeee73279b4357b44c2865c0c312de9ce" translate="yes" xml:space="preserve">
          <source>Use with care for relatively small or regular sets. It could end up being slower then just using multi-staged tables.</source>
          <target state="translated">Используйте с осторожностью относительно небольшие или обычные наборы.В конечном итоге он может работать медленнее,чем при использовании многоступенчатых таблиц.</target>
        </trans-unit>
        <trans-unit id="868aa913da6e64ffd3178348ee39c40b6cb76409" translate="yes" xml:space="preserve">
          <source>UseReplacementDchar.yes means replace invalid UTF with &lt;code&gt;replacementDchar&lt;/code&gt;, UseReplacementDchar.no means throw &lt;code&gt;UTFException&lt;/code&gt; for invalid UTF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c271740e0ce7eb2e00647fa4da41721ca1e00a1" translate="yes" xml:space="preserve">
          <source>Used as a way to import a set of functions from another scope into this one.</source>
          <target state="translated">Используется как способ импортирования набора функций из другой области применения в эту область.</target>
        </trans-unit>
        <trans-unit id="9aff366f8817a8d85016a5af2ffa72cb41c12ea4" translate="yes" xml:space="preserve">
          <source>Used by PRAGMA temp_store_directory</source>
          <target state="translated">Используется директорией temp_store_store_PRAGMA</target>
        </trans-unit>
        <trans-unit id="c0d28c0a10bf62a3760e12afc8a7ed5df5261d7b" translate="yes" xml:space="preserve">
          <source>Used by StopWatch to indicate whether it should start immediately upon construction.</source>
          <target state="translated">Используется StopWatch для указания,следует ли начинать работу сразу же после постройки.</target>
        </trans-unit>
        <trans-unit id="d77cd63df95be5f8257fdd3b6685af113cfcac98" translate="yes" xml:space="preserve">
          <source>Used by scp/sftp to do public/private key authentication</source>
          <target state="translated">Используется scp/sftp для аутентификации по публичному/частному ключу</target>
        </trans-unit>
        <trans-unit id="62d064b18e4792e174e1c38c7f164d4b65412e06" translate="yes" xml:space="preserve">
          <source>Used for empty tags</source>
          <target state="translated">Используется для пустых меток</target>
        </trans-unit>
        <trans-unit id="948c35e8d2024f482ef61469edc1997c031e7684" translate="yes" xml:space="preserve">
          <source>Used for end tags</source>
          <target state="translated">Используется для концевых меток</target>
        </trans-unit>
        <trans-unit id="6de76570eb43640d4d9e5b45038a00acc6b2bb9d" translate="yes" xml:space="preserve">
          <source>Used for reordering elem trees to minimize register usage.</source>
          <target state="translated">Используется для переупорядочивания элемовых деревьев с целью минимизации использования регистра.</target>
        </trans-unit>
        <trans-unit id="f4030c3289de70676f4cc6c0e214e32db123298d" translate="yes" xml:space="preserve">
          <source>Used for start tags</source>
          <target state="translated">Используется для стартовых меток</target>
        </trans-unit>
        <trans-unit id="522e09bb5920f3c467bc6428b962e366709a3220" translate="yes" xml:space="preserve">
          <source>Used to (re)initialize the MD5 digest.</source>
          <target state="translated">Используется для (ре)инициализации дайджеста MD5.</target>
        </trans-unit>
        <trans-unit id="d8ae013d8b394207c78281137c668f2dfc3c43cf" translate="yes" xml:space="preserve">
          <source>Used to (re)initialize the RIPEMD160 digest.</source>
          <target state="translated">Используется для (ре)инициализации дайджеста RIPEMD160.</target>
        </trans-unit>
        <trans-unit id="f62bf8f2aca98cad054cf426c5476cfd425e9977" translate="yes" xml:space="preserve">
          <source>Used to check if a digest supports the &lt;code&gt;peek&lt;/code&gt; method. Peek has exactly the same function signatures as finish, but it doesn't reset the digest's internal state.</source>
          <target state="translated">Используется для проверки, поддерживает ли дайджест метод &lt;code&gt;peek&lt;/code&gt; . Peek имеет те же сигнатуры функций, что и Finish, но не сбрасывает внутреннее состояние дайджеста.</target>
        </trans-unit>
        <trans-unit id="b2ca2eff17dd582e5ff65726409ecb0158897554" translate="yes" xml:space="preserve">
          <source>Used to convert a hash value (a static or dynamic array of ubytes) to a string. Can be used with the OOP and with the template API.</source>
          <target state="translated">Используется для преобразования хэш-значения (статического или динамического массива в ubytes)в строку.Может использоваться с ООП и API шаблона.</target>
        </trans-unit>
        <trans-unit id="46222499a18dfe951ecc78e1c9590456d26ad7e4" translate="yes" xml:space="preserve">
          <source>Used to convert the argument to a lazy parameter.</source>
          <target state="translated">Используется для преобразования аргумента в ленивый параметр.</target>
        </trans-unit>
        <trans-unit id="65abc6a52a7ca50f9b90aca875b02f4b756c4a7a" translate="yes" xml:space="preserve">
          <source>Used to get the metaclass of an Objective-C class, &lt;code&gt;NSObject.Class&lt;/code&gt;.</source>
          <target state="translated">Используется для получения метакласса класса Objective C, &lt;code&gt;NSObject.Class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87b79b0e524609461d16e79324d5b506d0bd2f97" translate="yes" xml:space="preserve">
          <source>Used to indicate whether &lt;code&gt;popFront&lt;/code&gt; should be called immediately upon creating a range. The idea is that for some functions used to generate a range for an interval, &lt;code&gt;front&lt;/code&gt; is not necessarily a time point which would ever be generated by the range (e.g. if the range were every Sunday within an interval, but the interval started on a Monday), so there needs to be a way to deal with that. To get the first time point in the range to match what the function generates, then use &lt;code&gt;PopFirst.yes&lt;/code&gt; to indicate that the range should have &lt;code&gt;popFront&lt;/code&gt; called on it before the range is returned so that &lt;code&gt;front&lt;/code&gt; is a time point which the function would generate. To let the first time point not match the generator function, use &lt;code&gt;PopFront.no&lt;/code&gt;.</source>
          <target state="translated">Используется для указания того, должен ли &lt;code&gt;popFront&lt;/code&gt; вызываться сразу после создания диапазона. Идея состоит в том, что для некоторых функций, используемых для генерации диапазона для интервала, &lt;code&gt;front&lt;/code&gt; не обязательно является точкой времени, которая когда-либо будет генерироваться диапазоном (например, если диапазон был каждое воскресенье в пределах интервала, но интервал начинался в понедельник ), поэтому должен быть способ справиться с этим. Чтобы получить первую временную точку в диапазоне, совпадающую с тем, что генерирует функция, используйте &lt;code&gt;PopFirst.yes&lt;/code&gt; , чтобы указать, что диапазон должен &lt;code&gt;popFront&lt;/code&gt; до того, как диапазон будет возвращен, так что &lt;code&gt;front&lt;/code&gt; - это точка времени, которую сгенерирует функция. Чтобы первая временная точка не соответствовала функции генератора, используйте &lt;code&gt;PopFront.no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="401f8606923b6b90d5e6990af08c1ea19653cfb5" translate="yes" xml:space="preserve">
          <source>Used to initialize the CRC32 digest.</source>
          <target state="translated">Используется для инициализации дайджеста CRC32.</target>
        </trans-unit>
        <trans-unit id="9956d500692d633ff2d3c01404cd742cd7a59cd4" translate="yes" xml:space="preserve">
          <source>Used to specify the lock type for &lt;code&gt;File.lock&lt;/code&gt; and &lt;code&gt;File.tryLock&lt;/code&gt;.</source>
          <target state="translated">Используется для указания типа блокировки для &lt;code&gt;File.lock&lt;/code&gt; и &lt;code&gt;File.tryLock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="063f3cd8cbb18d78d982d0fe8406f2b8aad31844" translate="yes" xml:space="preserve">
          <source>Used to work around syntactic limitations of D with regard to instantiating a template from an alias sequence (e.g. &lt;code&gt;T[0]!(...)&lt;/code&gt; is not valid) or a template returning another template (e.g. &lt;code&gt;Foo!(Bar)!(Baz)&lt;/code&gt; is not allowed).</source>
          <target state="translated">Используется для обхода синтаксических ограничений D в отношении создания шаблона из последовательности псевдонимов (например, &lt;code&gt;T[0]!(...)&lt;/code&gt; недопустимо) или шаблона, возвращающего другой шаблон (например, &lt;code&gt;Foo!(Bar)!(Baz)&lt;/code&gt; не допускается).</target>
        </trans-unit>
        <trans-unit id="9c84f45b498b0d39f128dcbb45ac2921760d01ee" translate="yes" xml:space="preserve">
          <source>Used when the data to be compressed is not all in one buffer.</source>
          <target state="translated">Используется,когда данные,подлежащие сжатию,не все находятся в одном буфере.</target>
        </trans-unit>
        <trans-unit id="5bb82bdca5155ef6b15ec62c178c8aa8ec5a96b1" translate="yes" xml:space="preserve">
          <source>Used when the data to be decompressed is not all in one buffer.</source>
          <target state="translated">Используется,когда данные,подлежащие распаковке,не все находятся в одном буфере.</target>
        </trans-unit>
        <trans-unit id="c12660b5a95dd9583c836ce084d3eaa0c55a6813" translate="yes" xml:space="preserve">
          <source>Useful for converting the result to a string after doing operations on graphemes.</source>
          <target state="translated">Полезен для преобразования результата в строку после выполнения операций над графемами.</target>
        </trans-unit>
        <trans-unit id="7652b35b91d37f1b6a3e33d8a155a1f2c6064611" translate="yes" xml:space="preserve">
          <source>Useful for doing string manipulation that needs to be aware of graphemes.</source>
          <target state="translated">Полезно для выполнения манипуляций со строками,которые должны знать графемы.</target>
        </trans-unit>
        <trans-unit id="314d8fb768e706877d004a50cc06fd222bca9e32" translate="yes" xml:space="preserve">
          <source>Useful for error messages</source>
          <target state="translated">Полезно для сообщений об ошибках</target>
        </trans-unit>
        <trans-unit id="6dc0953ee871790fa8f35a1a09d04c414cbf0ea7" translate="yes" xml:space="preserve">
          <source>Useful for using &lt;code&gt;foreach&lt;/code&gt; with an index loop variable:</source>
          <target state="translated">Полезно для использования &lt;code&gt;foreach&lt;/code&gt; с переменной цикла индекса:</target>
        </trans-unit>
        <trans-unit id="4db4c19014a191f09a1cb0e5ee4b594d36a17fa5" translate="yes" xml:space="preserve">
          <source>Useful when a single value or multiple disconnected values must be passed to an algorithm expecting a range, without having to perform dynamic memory allocation.</source>
          <target state="translated">Полезно,когда одно или несколько отключенных значений должны быть переданы алгоритму,ожидающему диапазон,без необходимости выполнять динамическое выделение памяти.</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">Данные пользователя для функций</target>
        </trans-unit>
        <trans-unit id="0ada253ac93105524488fa0636dd4f599ad803cd" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol</source>
          <target state="translated">протокол датаграмм пользователя</target>
        </trans-unit>
        <trans-unit id="663967dca54d1f5a78a7cc7579aff26c92ec0848" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol level</source>
          <target state="translated">Уровень протокола датаграмм пользователя</target>
        </trans-unit>
        <trans-unit id="7f12f4404ca8d6331a7dda600211516b88689808" translate="yes" xml:space="preserve">
          <source>User Defined Logger</source>
          <target state="translated">Заданный пользователем журнал</target>
        </trans-unit>
        <trans-unit id="41b70159aa80a814a1c6708051f3c2cd54f55274" translate="yes" xml:space="preserve">
          <source>User defined attributes look like: @foo(args, ...) @(args, ...)</source>
          <target state="translated">Определенные пользователем атрибуты выглядят так:@foo(args,...)@(args,...)</target>
        </trans-unit>
        <trans-unit id="6911ae8d9122e09ba3672b9fc7a2f5a03117c4b5" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes</source>
          <target state="translated">Определяемые пользователем атрибуты</target>
        </trans-unit>
        <trans-unit id="53dcd43d2037ced97e920ab7c52c6c2b3f1d4b5b" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes (UDA) are compile-time expressions that can be attached to a declaration. These attributes can then be queried, extracted, and manipulated at compile time. There is no runtime component to them.</source>
          <target state="translated">Определенные пользователем атрибуты (UDA)-это выражения времени компиляции,которые могут быть прикреплены к декларации.Затем эти атрибуты могут быть запрошены,извлечены и обработаны во время компиляции.Для них нет компонента времени исполнения.</target>
        </trans-unit>
        <trans-unit id="79c69632c5bdcde773a2213887dfa8de28b97fcd" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes for Parameters</source>
          <target state="translated">Определенные пользователем атрибуты для параметров</target>
        </trans-unit>
        <trans-unit id="f97038e5aef05b8d6da775ac91f3df3186383a15" translate="yes" xml:space="preserve">
          <source>User-Defined Properties</source>
          <target state="translated">Определяемые пользователем свойства</target>
        </trans-unit>
        <trans-unit id="a481ec805686b1111f45e923c0482b9b383bb80f" translate="yes" xml:space="preserve">
          <source>User-Defined Types</source>
          <target state="translated">Определяемые пользователем типы</target>
        </trans-unit>
        <trans-unit id="df398272c254dd9772b28c77026104de0cb4813e" translate="yes" xml:space="preserve">
          <source>User-defined properties can be created using &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">Пользовательские свойства могут быть созданы с помощью &lt;a href=&quot;function#property-functions&quot;&gt;функций свойств&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad57ad15c0703a0e0107ec919b23c65c4cb01b03" translate="yes" xml:space="preserve">
          <source>User-defined type names</source>
          <target state="translated">Имена типов,задаваемые пользователем</target>
        </trans-unit>
        <trans-unit id="e276f7847775a88fc2abcad4667b89c9759a4155" translate="yes" xml:space="preserve">
          <source>User-defined types that support comparison with &amp;lt; are supported.</source>
          <target state="translated">Определяемые пользователем типы, которые поддерживают сравнение с &amp;lt;, поддерживаются.</target>
        </trans-unit>
        <trans-unit id="e23e2a8ab594792759d1b60610fa3c8b02dd3e4d" translate="yes" xml:space="preserve">
          <source>User-provided store backing up the region. If &lt;code&gt; ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, memory is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">Предоставленный пользователем магазин резервного копирования региона. Если &lt;code&gt; ParentAllocator&lt;/code&gt; отличается от &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , предполагается, что память была выделена с помощью &lt;code&gt;ParentAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5092e979a5a593d67b4e82f9d2bbd095571e3d50" translate="yes" xml:space="preserve">
          <source>User-provided store backing up the region. If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, memory is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">Предоставленный пользователем магазин резервного копирования региона. Если &lt;code&gt;ParentAllocator&lt;/code&gt; отличается от &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , предполагается, что память была выделена с помощью &lt;code&gt;ParentAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e82338a943d21a1789251b44a5bd82afdadd9523" translate="yes" xml:space="preserve">
          <source>Users should prefer &lt;a href=&quot;object#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; to explicitly finalize objects, and only resort to &lt;a href=&quot;core_memory#_delete&quot;&gt;&lt;code&gt;core.memory._delete&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;object_#destroy&quot;&gt;&lt;code&gt;object.destroy&lt;/code&gt;&lt;/a&gt; wouldn't be a feasible option.</source>
          <target state="translated">Пользователи должны предпочесть &lt;a href=&quot;object#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; ,&lt;/a&gt; чтобы явно завершить объекты, и прибегать к &lt;a href=&quot;core_memory#_delete&quot;&gt; &lt;code&gt;core.memory._delete&lt;/code&gt; &lt;/a&gt; только тогда, когда &lt;a href=&quot;object_#destroy&quot;&gt; &lt;code&gt;object.destroy&lt;/code&gt; &lt;/a&gt; не будет выполнимым вариантом.</target>
        </trans-unit>
        <trans-unit id="b4005d61c7d8ff0cb653333de46ae3789f1d31fe" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8z34s9c6(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_malloc&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">Использует &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt; в Posix и &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8z34s9c6(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_malloc&lt;/code&gt; &lt;/a&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="431691e401faf58fb8c19131908c69ff710b059d" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_BOOTTIME&lt;/code&gt;.</source>
          <target state="translated">Использует &lt;code&gt;CLOCK_BOOTTIME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a50d919e60bef0f60af91bbb8d114a0afe4665d" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_MONOTONIC_RAW&lt;/code&gt;.</source>
          <target state="translated">Использует &lt;code&gt;CLOCK_MONOTONIC_RAW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="668062aef7777a80761a341372c3e3e366c83d67" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt;.</source>
          <target state="translated">Использует &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6a765f3682873a0a6c777b9f9c93d6e30d47aa" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_THREAD_CPUTIME_ID&lt;/code&gt;.</source>
          <target state="translated">Использует &lt;code&gt;CLOCK_THREAD_CPUTIME_ID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a32c41537d0762601fcb3b8547ba1c5f0e90c61b" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME&lt;/code&gt;.</source>
          <target state="translated">Использует &lt;code&gt;CLOCK_UPTIME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d155d55219e59719f96afbc402b6fce30fe7decd" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME_FAST&lt;/code&gt;.</source>
          <target state="translated">Использует &lt;code&gt;CLOCK_UPTIME_FAST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32cbdb3659578d385f11021d0324dc0968ef7d2b" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME_PRECISE&lt;/code&gt;.</source>
          <target state="translated">Использует &lt;code&gt;CLOCK_UPTIME_PRECISE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21b474dd996ab465a4609dacd8af3f0c2c6b9e0a" translate="yes" xml:space="preserve">
          <source>Uses Horner's rule A(x) = a&lt;sub&gt;0&lt;/sub&gt; + x(a&lt;sub&gt;1&lt;/sub&gt; + x(a&lt;sub&gt;2&lt;/sub&gt; + x(a&lt;sub&gt;3&lt;/sub&gt; + ...)))</source>
          <target state="translated">Использует правило Хорнера A (x) = a &lt;sub&gt;0&lt;/sub&gt; + x (a &lt;sub&gt;1&lt;/sub&gt; + x (a &lt;sub&gt;2&lt;/sub&gt; + x (a &lt;sub&gt;3&lt;/sub&gt; + ...)))</target>
        </trans-unit>
        <trans-unit id="89865df2ae553e13ce078a7680590fe066489642" translate="yes" xml:space="preserve">
          <source>Uses OS features not supported on host</source>
          <target state="translated">Использует функции ОС,не поддерживаемые на хосте</target>
        </trans-unit>
        <trans-unit id="d43174ab3f2c7ceb67637889035614b690710449" translate="yes" xml:space="preserve">
          <source>Uses a clock that has a precision of one second (contrast to the coarse clock, which has sub-second precision like the normal clock does).</source>
          <target state="translated">Использует часы,которые имеют точность в одну секунду (в отличие от грубых часов,которые имеют суб-секунды точности,как это делают обычные часы).</target>
        </trans-unit>
        <trans-unit id="660abbaeae3754fa828725fdd746d4c8c7d904f7" translate="yes" xml:space="preserve">
          <source>Uses a more precise clock than the normal one (which is already very precise), but it takes longer to get the time. Similarly to &lt;code&gt;ClockType.coarse&lt;/code&gt;, if it's used on a system that does not support a more precise clock than the normal one, it's treated as equivalent to &lt;code&gt;ClockType.normal&lt;/code&gt;.</source>
          <target state="translated">Использует более точные часы, чем обычные (которые уже очень точны), но для получения времени требуется больше времени. Аналогично &lt;code&gt;ClockType.coarse&lt;/code&gt; , если он используется в системе, которая не поддерживает более точные часы, чем обычные, он рассматривается как эквивалент &lt;code&gt;ClockType.normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4810f4cffe0fe4e539877249a5f80a146a9437e8" translate="yes" xml:space="preserve">
          <source>Uses an algorithm based on TOMS748, which uses inverse cubic interpolation whenever possible, otherwise reverting to parabolic or secant interpolation. Compared to TOMS748, this implementation improves worst-case performance by a factor of more than 100, and typical performance by a factor of 2. For 80-bit reals, most problems require 8 to 15 calls to &lt;code&gt;f(x)&lt;/code&gt; to achieve full machine precision. The worst-case performance (pathological cases) is approximately twice the number of bits.</source>
          <target state="translated">Использует алгоритм, основанный на TOMS748, который использует обратную кубическую интерполяцию, когда это возможно, в противном случае возвращается к параболической или секущей интерполяции. По сравнению с TOMS748, эта реализация повышает производительность в худшем случае более чем в 100 раз, а типичную производительность - в 2 раза. Для 80-битных реалов большинство проблем требуют от 8 до 15 вызовов &lt;code&gt;f(x)&lt;/code&gt; для достижения полной машины точность. Производительность в худшем случае (патологические случаи) примерно вдвое превышает число битов.</target>
        </trans-unit>
        <trans-unit id="4498cdd81a3af92be5d71f0feb7499f91526eda6" translate="yes" xml:space="preserve">
          <source>Uses static address range/handler tables. It is not compatible with the ELF/Mach-O exception handling tables. The stack is walked assuming it uses the EBP/RBP stack frame convention. The EBP/RBP convention must be used for every function that has an associated EH (Exception Handler) table.</source>
          <target state="translated">Использует статические таблицы диапазона адресов/таблицы обработчиков.Он не совместим с таблицами обработки исключений ELF/Mach-O.Стек проходит,предполагая,что он использует соглашение фрейма стека EBP/RBP.Соглашение EBP/RBP должно использоваться для каждой функции,которая имеет ассоциированную таблицу обработчика исключений EH (Exception Handler).</target>
        </trans-unit>
        <trans-unit id="29fa78ad0c4fcffa6a248e751ed5f9b54e278c81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;delete&lt;/code&gt; to free memory not allocated by the garbage collector.</source>
          <target state="translated">Использование &lt;code&gt;delete&lt;/code&gt; для освобождения памяти, не выделенной сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="dbc2fb498947c6d15c4f030eec28a604eed13c66" translate="yes" xml:space="preserve">
          <source>Using Allocators without &lt;code&gt;IAllocator&lt;/code&gt;</source>
          <target state="translated">Использование &lt;code&gt;IAllocator&lt;/code&gt; без IAllocator</target>
        </trans-unit>
        <trans-unit id="f74c7aa68c43b38fd906d3d9eab694820f7c02be" translate="yes" xml:space="preserve">
          <source>Using C++ Classes From D</source>
          <target state="translated">Использование классов С++от D</target>
        </trans-unit>
        <trans-unit id="5d2653c4926bb52d976ff78e98c04428994e66ea" translate="yes" xml:space="preserve">
          <source>Using Classes as the KeyType</source>
          <target state="translated">Использование Классов в качестве KeyType</target>
        </trans-unit>
        <trans-unit id="42a76c4e6e5c83e56266b53307bd6eb59b5b616d" translate="yes" xml:space="preserve">
          <source>Using D Classes From C++</source>
          <target state="translated">Использование классов D от C++</target>
        </trans-unit>
        <trans-unit id="5de7af94f529ff0a340538c931f4aeeba8137b89" translate="yes" xml:space="preserve">
          <source>Using Ddoc for other Documentation</source>
          <target state="translated">Использование Ddoc для другой документации</target>
        </trans-unit>
        <trans-unit id="a452f39b71d34befc0278e622c50c8e1b7016ce7" translate="yes" xml:space="preserve">
          <source>Using Ddoc to generate examples from unit tests</source>
          <target state="translated">Использование Ddoc для генерации примеров из юнит-тестов</target>
        </trans-unit>
        <trans-unit id="ffcf84b5292979d6d33051f4fd30a1a26f6708e4" translate="yes" xml:space="preserve">
          <source>Using Existing C Libraries</source>
          <target state="translated">Использование существующих библиотек на языке С</target>
        </trans-unit>
        <trans-unit id="ca7da0d401d332ac17ab9ac27d6baa37cb6bed49" translate="yes" xml:space="preserve">
          <source>Using Structs or Unions as the KeyType</source>
          <target state="translated">Использование Structs или Unions в качестве KeyType</target>
        </trans-unit>
        <trans-unit id="ac95e41bbb29ad991114a19ec2ec8a9eb2e7d8d1" translate="yes" xml:space="preserve">
          <source>Using UUIDs</source>
          <target state="translated">Использование UUID</target>
        </trans-unit>
        <trans-unit id="5fa5d3e48800cfb7875c91e382ef8e4590ba92ea" translate="yes" xml:space="preserve">
          <source>Using a struct with modified delimiter:</source>
          <target state="translated">Использование структуры с модифицированным разделителем:</target>
        </trans-unit>
        <trans-unit id="04602bc03bbc945a58891e81ee57c8cb19c96764" translate="yes" xml:space="preserve">
          <source>Using alias template parameter in &lt;code&gt;how&lt;/code&gt; and/or &lt;code&gt;what&lt;/code&gt; may cause strange compile error. Use template tuple parameter instead to workaround this problem. [&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=4217&quot;&gt;Bugzilla 4217&lt;/a&gt;]</source>
          <target state="translated">Использование параметра шаблона псевдонима в &lt;code&gt;how&lt;/code&gt; и / или &lt;code&gt;what&lt;/code&gt; может вызвать странную ошибку компиляции. Вместо этого используйте параметр шаблона кортежа, чтобы обойти эту проблему. [ &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=4217&quot;&gt;Bugzilla 4217&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="8be6b00f614d8a1cd2c1ef5b4a6f7e1192591421" translate="yes" xml:space="preserve">
          <source>Using allocatedInCurrentThread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2607c615db72ef7bb05726a2cf4b245712b98a0" translate="yes" xml:space="preserve">
          <source>Using an uninitialized struct-based container will work, because the struct intializes itself upon use; however, up to this point the container will not have an identity and assignment does not create two references to the same data.</source>
          <target state="translated">Использование неинициализированного контейнера,основанного на структуре,будет работать,так как структура инициализируется при использовании;однако до этого момента контейнер не будет иметь идентичности и назначение не создаст двух ссылок на одни и те же данные.</target>
        </trans-unit>
        <trans-unit id="35a44b902e18d805798c2c1e89fd00d153fbd20b" translate="yes" xml:space="preserve">
          <source>Using asNormalizedPath on empty paths will always return an empty path.</source>
          <target state="translated">Использование asNormalizedPath на пустых путях всегда возвращает пустой путь.</target>
        </trans-unit>
        <trans-unit id="0290f4a41ecd4a75dc3439f50553b7b4b3cab521" translate="yes" xml:space="preserve">
          <source>Using buildNormalizedPath on null paths will always return null.</source>
          <target state="translated">Использование buildNormalizedPath на нулевых путях всегда возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="6805f8dde5047fa0a76de0b0a48672e08cbc9fdb" translate="yes" xml:space="preserve">
          <source>Using builtin &lt;code&gt;typeof&lt;/code&gt; on a property function yields the types of the property value, not of the property function itself. Still, &lt;code&gt;FunctionTypeOf&lt;/code&gt; is able to obtain function types of properties.</source>
          <target state="translated">Использование встроенной функции &lt;code&gt;typeof&lt;/code&gt; в функции свойства позволяет получить типы значения свойства, а не самой функции свойства. Тем не менее, &lt;code&gt;FunctionTypeOf&lt;/code&gt; может получать функциональные типы свойств.</target>
        </trans-unit>
        <trans-unit id="7eb690c3ef3a1529c909411cf3d35c20b241fbf3" translate="yes" xml:space="preserve">
          <source>Using exceptions to handle errors leads to another issue - how to write exception safe programs. &lt;a href=&quot;https://dlang.org/exception-safe.html&quot;&gt;Here's how&lt;/a&gt;.</source>
          <target state="translated">Использование исключений для обработки ошибок приводит к другой проблеме - как писать безопасные для исключений программы. &lt;a href=&quot;https://dlang.org/exception-safe.html&quot;&gt;Вот как&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48badfbf8cc430bc5e24fa5412476d41eda3ceaf" translate="yes" xml:space="preserve">
          <source>Using functions and more types than the template:</source>
          <target state="translated">Использование функций и больше типов,чем в шаблоне:</target>
        </trans-unit>
        <trans-unit id="4eca2488380272881b9de30c76f64561c55803ca" translate="yes" xml:space="preserve">
          <source>Using group, an associative array can be easily generated with the count of each unique element in the range.</source>
          <target state="translated">С помощью группы можно легко создать ассоциативный массив с учетом количества каждого уникального элемента в диапазоне.</target>
        </trans-unit>
        <trans-unit id="e894da306300d7264b04f9bbeb317a07ad4c4216" translate="yes" xml:space="preserve">
          <source>Using the above flag, the linker will search in the standard framework paths. The standard search paths for frameworks are:</source>
          <target state="translated">Используя вышеуказанный флаг,компоновщик будет осуществлять поиск по стандартным путям фреймворка.Стандартные пути поиска для фреймворков:</target>
        </trans-unit>
        <trans-unit id="e137a8793cb9aa11c5797755fd5b985067bcda9f" translate="yes" xml:space="preserve">
          <source>Using the range returned by this function in a parallel foreach loop will not work because buffers may be overwritten while the task that processes them is in queue. This is checked for at compile time and will result in a static assertion failure.</source>
          <target state="translated">Использование диапазона,возвращаемого этой функцией в параллельном форач-цикле,не будет работать,так как буферы могут быть перезаписаны в то время,как задача,которая их обрабатывает,находится в очереди.Это проверяется во время компиляции и приводит к сбою статического утверждения.</target>
        </trans-unit>
        <trans-unit id="b6ed578893f11c816c086498ada4c56ae14083de" translate="yes" xml:space="preserve">
          <source>Using this delegate allows iteration over successive time points which are all the same day of the week. e.g. passing &lt;code&gt;DayOfWeek.mon&lt;/code&gt; to &lt;code&gt;everyDayOfWeek&lt;/code&gt; would result in a delegate which could be used to iterate over all of the Mondays in a range.</source>
          <target state="translated">Использование этого делегата позволяет выполнять итерации по последовательным временным точкам, которые являются одним и тем же днем ​​недели. например, передача &lt;code&gt;DayOfWeek.mon&lt;/code&gt; в &lt;code&gt;everyDayOfWeek&lt;/code&gt; приведет к делегату, который может быть использован для итерации по всем понедельникам в диапазоне.</target>
        </trans-unit>
        <trans-unit id="01e4a295ee1f89ba313532d06753451f037e5d2d" translate="yes" xml:space="preserve">
          <source>Using this delegate allows iteration over successive time points which are apart by the given duration e.g. passing &lt;code&gt;dur!&quot;days&quot;(3)&lt;/code&gt; to &lt;code&gt;everyDuration&lt;/code&gt; would result in a delegate which could be used to iterate over a range of days which are each 3 days apart.</source>
          <target state="translated">Использование этого делегата позволяет выполнять итерации по последовательным временным точкам, которые отличаются друг от друга заданной продолжительностью, например, передача &lt;code&gt;dur!&quot;days&quot;(3)&lt;/code&gt; &lt;code&gt;everyDuration&lt;/code&gt; &quot; (3) в everyDuration приведет к получению делегата, который можно использовать для итерации в диапазоне дней, каждый из которых разделен на 3 дня. ,</target>
        </trans-unit>
        <trans-unit id="c6ec51f5ced2a1c1be894f86e670f88f6e1b3f63" translate="yes" xml:space="preserve">
          <source>Using this module is not necessary in typical D code. It is mostly useful when doing low-level memory management.</source>
          <target state="translated">Использование этого модуля не требуется в типичном D-коде.В основном он полезен при управлении низкоуровневой памятью.</target>
        </trans-unit>
        <trans-unit id="631bc23f5ec2b24f0267b7cee38a13c6b70e0b32" translate="yes" xml:space="preserve">
          <source>Using unit tests in conjuction with coverage testing (such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt;) is effective.</source>
          <target state="translated">Использование модульных тестов в сочетании с тестированием покрытия (например, &lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt; ) эффективно.</target>
        </trans-unit>
        <trans-unit id="4a52cd6fd741b2e0850db631fed27601b7a4f5f6" translate="yes" xml:space="preserve">
          <source>Using unit tests in conjunction with coverage testing (such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt;) is effective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d387cfce482bd0157645391025dc0dab84b81bed" translate="yes" xml:space="preserve">
          <source>Using with void handlers:</source>
          <target state="translated">Используется с пустыми обработчиками:</target>
        </trans-unit>
        <trans-unit id="9d57966a5fe4d9e61b9bd2b025a52cea4116ac88" translate="yes" xml:space="preserve">
          <source>Usual Arithmetic Conversions</source>
          <target state="translated">обычные арифметические преобразования</target>
        </trans-unit>
        <trans-unit id="375fab11fc70c98c677eac17e0744c53564be0ee" translate="yes" xml:space="preserve">
          <source>Usual decimal notation</source>
          <target state="translated">обычная десятичная запись</target>
        </trans-unit>
        <trans-unit id="189e13a83ee98c7852ba58517289e900a3678612" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;CAllocatorImpl&lt;/code&gt; is used indirectly by calling &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;CAllocatorImpl&lt;/code&gt; используется косвенно, вызывая &lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3ab50d8476aca67a9de9d6b2f04749ce4d85ba" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; is used indirectly by calling &lt;a href=&quot;#processAllocator&quot;&gt;&lt;code&gt;processAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; используется косвенно, вызывая &lt;a href=&quot;#processAllocator&quot;&gt; &lt;code&gt;processAllocator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcec0c4180b39c4ca2dae249c28eee53727aacb0" translate="yes" xml:space="preserve">
          <source>Usually one would use &lt;code&gt;expression.checkDeprecated(scope, aliasthis)&lt;/code&gt; to check if &lt;code&gt;expression&lt;/code&gt; uses a deprecated &lt;code&gt;aliasthis&lt;/code&gt;, but this calls &lt;code&gt;toPrettyChars&lt;/code&gt; which lead to the following message: &quot;Deprecation: alias this &lt;code&gt;fullyqualified.aggregate.__anonymous&lt;/code&gt; is deprecated&quot;</source>
          <target state="translated">Обычно можно использовать &lt;code&gt;expression.checkDeprecated(scope, aliasthis)&lt;/code&gt; чтобы проверить, использует ли &lt;code&gt;expression&lt;/code&gt; устаревший &lt;code&gt;aliasthis&lt;/code&gt; , но при этом вызывается &lt;code&gt;toPrettyChars&lt;/code&gt; , что приводит к следующему сообщению: &amp;laquo;Устаревание: псевдоним this &lt;code&gt;fullyqualified.aggregate.__anonymous&lt;/code&gt; устарело&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="56e90d07707b3458a805a4bacd63daec2c432b02" translate="yes" xml:space="preserve">
          <source>Utf8Matcher</source>
          <target state="translated">Utf8Matcher</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="7ad38c788cc45a5074b9ffb9432c47c67a220b54" translate="yes" xml:space="preserve">
          <source>Utilities for manipulating files and scanning directories. Functions in this module handle files as a unit, e.g., read or write one file at a time. For opening files and manipulating them via handles refer to module &lt;a href=&quot;std_stdio&quot;&gt;&lt;code&gt;std.stdio&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Утилиты для работы с файлами и сканирования каталогов. Функции в этом модуле обрабатывают файлы как единое целое, например, чтение или запись по одному файлу за раз. Для открытия файлов и управления ими с помощью дескрипторов обратитесь к модулю &lt;a href=&quot;std_stdio&quot;&gt; &lt;code&gt;std.stdio&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb76eeaae4889cbc133d348ffc75221ffb8b4b7" translate="yes" xml:space="preserve">
          <source>Utility and ancillary artifacts of &lt;code&gt;std.experimental.allocator&lt;/code&gt;. This module shouldn't be used directly; its functionality will be migrated into more appropriate parts of &lt;code&gt;std&lt;/code&gt;.</source>
          <target state="translated">Полезные и вспомогательные артефакты &lt;code&gt;std.experimental.allocator&lt;/code&gt; . Этот модуль не должен использоваться напрямую; его функциональность будет перенесена в более подходящие части стандартного &lt;code&gt;std&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9867d3a9c49162da041043a50cf7008b982e4ef" translate="yes" xml:space="preserve">
          <source>Utility to build a function call out of this reference and argument.</source>
          <target state="translated">Утилита для построения вызова функции из этой ссылки и аргумента.</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="6cf0c0c7f5bb0a5a5c7282f8cd30993e76deb2f0" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;exchangeWith&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;exchangeWith&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="996b87ed0fe8487bff29a2dec4722ab527ea5a40" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;maxAbsDiff&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;maxAbsDiff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58e6f841de246b5933aae9d3dc5868627507c120" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;maxRelDiff&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;maxRelDiff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20db17f1551f67285ce8cf2eb53ceb553508099d" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;newval&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf6b2708f752f3849720cb5f4bb150990c142ea" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; V</target>
        </trans-unit>
        <trans-unit id="ceb0d7dbc0e1ba5c877e451af696f96367121e3f" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;writeThis&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7aa9428cf99ed21c9b2d50259bb210fc9c6653b" translate="yes" xml:space="preserve">
          <source>V &lt;strong id=&quot;loadUnaligned&quot;&gt;loadUnaligned&lt;/strong&gt;(V)(const V* p)</source>
          <target state="translated">V &lt;strong id=&quot;loadUnaligned&quot;&gt;loadUnaligned&lt;/strong&gt; (V) (постоянный V * p)</target>
        </trans-unit>
        <trans-unit id="ea4bf31a65b803e6d5e8754862432a804bcf1f21" translate="yes" xml:space="preserve">
          <source>V &lt;strong id=&quot;storeUnaligned&quot;&gt;storeUnaligned&lt;/strong&gt;(V)(V* p, V value)</source>
          <target state="translated">V &lt;strong id=&quot;storeUnaligned&quot;&gt;storeUnaligned&lt;/strong&gt; (V) (V * p, значение V)</target>
        </trans-unit>
        <trans-unit id="942a90c9bec88d5207a1a5060881571e2b1fe393" translate="yes" xml:space="preserve">
          <source>V* &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">V * &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3bd3be2bbc21bec248542658e53653f18b36f05" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;ifThis&lt;/code&gt;</source>
          <target state="translated">V1, &lt;code&gt;ifThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="049a85cf151f96bcc540c68c5cd2d1eea3c1509d" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">V1 &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4053c68a54663b4758120d92e86ef8bfc8c214a" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;newval&lt;/code&gt;</source>
          <target state="translated">V1 &lt;code&gt;newval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94d860f8b520a6cee844237c3ad2d206fa305d0f" translate="yes" xml:space="preserve">
          <source>V1 ifThis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d2c6ab8c00acf411a44e6002c81ee87fc3e301" translate="yes" xml:space="preserve">
          <source>V1* &lt;code&gt;ifThis&lt;/code&gt;</source>
          <target state="translated">V1 * &lt;code&gt;ifThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40135827f1648afd73698821e7495e8c2df48b20" translate="yes" xml:space="preserve">
          <source>V2 &lt;code&gt;writeThis&lt;/code&gt;</source>
          <target state="translated">V2 &lt;code&gt;writeThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27b474c7b076d7d30fee8040c56c7c2a561bd720" translate="yes" xml:space="preserve">
          <source>V2 writeThis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025198e42a319f7e1b7d4e566d6832369521d744" translate="yes" xml:space="preserve">
          <source>VFS only</source>
          <target state="translated">только VFS</target>
        </trans-unit>
        <trans-unit id="76bc45e6071b6bf840834c3190d06cac0f7b7fac" translate="yes" xml:space="preserve">
          <source>V[K] &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="translated">V [K] &lt;code&gt;aa&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84f91d8df4169488a6e5b0c8d99b4bcf85ff79ce" translate="yes" xml:space="preserve">
          <source>V[K] &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;(T : V[K], K, V)(T aa);</source>
          <target state="translated">V [K] &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; (T: V [K], K, V) (T aa);</target>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="translated">Vai</target>
        </trans-unit>
        <trans-unit id="83f96f97d6bbb741686c832649fe36d1655e12f1" translate="yes" xml:space="preserve">
          <source>Validates an email address according to RFCs 5321, 5322 and others.</source>
          <target state="translated">Проверяет адрес электронной почты в соответствии с RFC 5321,5322 и др.</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="cde694e20f6f1970e02f61b4fe4c250aab2573eb" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">Значение &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40e4777c3c9339aee0e1471542316f607e20c0b4" translate="yes" xml:space="preserve">
          <source>Value getter for &lt;code&gt;JSONType.array&lt;/code&gt;. Unlike &lt;code&gt;array&lt;/code&gt;, this retrieves the array by value and can be used in @safe code.</source>
          <target state="translated">&lt;code&gt;JSONType.array&lt;/code&gt; значения для JSONType.array . В отличие от &lt;code&gt;array&lt;/code&gt; , он извлекает массив по значению и может использоваться в коде @safe.</target>
        </trans-unit>
        <trans-unit id="debaeee666e351d6eab3b4f3c90b3aa9118a0ea0" translate="yes" xml:space="preserve">
          <source>Value getter for &lt;code&gt;JSONType.object&lt;/code&gt;. Unlike &lt;code&gt;object&lt;/code&gt;, this retrieves the object by value and can be used in @safe code.</source>
          <target state="translated">&lt;code&gt;JSONType.object&lt;/code&gt; значения для JSONType.object . В отличие от &lt;code&gt;object&lt;/code&gt; , он извлекает объект по значению и может использоваться в коде @safe.</target>
        </trans-unit>
        <trans-unit id="0d34b60081d5920e95d26de3b14e5976c483a6c8" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.array&lt;/code&gt; / установщик значения для JSONType.array .</target>
        </trans-unit>
        <trans-unit id="06d88a23659d2106a272fc3c2a0cbf425061e548" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.float_&lt;/code&gt;. Note that despite the name, this is a &lt;b&gt;64&lt;/b&gt;-bit &lt;code&gt;double&lt;/code&gt;, not a 32-bit &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.float_&lt;/code&gt; / установщик значения для JSONType.float_ . Обратите внимание , что , несмотря на название, это &lt;b&gt;64&lt;/b&gt; - битный &lt;code&gt;double&lt;/code&gt; , а не 32-бит с &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="682193cf221d6f67ac3388d98af6c6643d6280c0" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.integer&lt;/code&gt; / установщик значения для JSONType.integer .</target>
        </trans-unit>
        <trans-unit id="b856cf95a7918cf8c4713730d8144e2773a78ad5" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.object&lt;/code&gt; / установщик значения для JSONType.object .</target>
        </trans-unit>
        <trans-unit id="f77315c89ea8901db907f7202a186401d954a3ab" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.string&lt;/code&gt; / установщик значения для JSONType.string .</target>
        </trans-unit>
        <trans-unit id="04d25aeadd95822d75f9e6c63a59113dd6ae997a" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.uinteger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.uinteger&lt;/code&gt; / установщик значения для JSONType.uinteger .</target>
        </trans-unit>
        <trans-unit id="c903c7f6e0c9717a3204ee2e6392ffb91a1e532e" translate="yes" xml:space="preserve">
          <source>Value getter/setter for boolean stored in JSON.</source>
          <target state="translated">Получение/установка значения для булевых файлов,хранящихся в JSON.</target>
        </trans-unit>
        <trans-unit id="f6a96ca6f671cd62067e2694b2efd9807e5523cb" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;f(ax)&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;f(ax)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f84944c7f8eab7774fddf4925d08c76461c466b" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;f(bx)&lt;/code&gt;. &lt;code&gt;fax&lt;/code&gt; and &lt;code&gt;fbx&lt;/code&gt; should have opposite signs. (&lt;code&gt;f(ax)&lt;/code&gt; and &lt;code&gt;f(bx)&lt;/code&gt; are commonly known in advance.)</source>
          <target state="translated">Значение &lt;code&gt;f(bx)&lt;/code&gt; . &lt;code&gt;fax&lt;/code&gt; и &lt;code&gt;fbx&lt;/code&gt; должны иметь противоположные знаки. ( &lt;code&gt;f(ax)&lt;/code&gt; и &lt;code&gt;f(bx)&lt;/code&gt; обычно известны заранее.)</target>
        </trans-unit>
        <trans-unit id="d1610fa402b56db1bc6c44e14091878669be03b2" translate="yes" xml:space="preserve">
          <source>Value that collectExceptionMsg returns when it catches an exception with an empty exception message.</source>
          <target state="translated">Значение,которое collectExceptionMsg возвращает,когда он ловит исключение с пустым сообщением об исключении.</target>
        </trans-unit>
        <trans-unit id="35127929f685cd18a15efc62a6a5cd564850b329" translate="yes" xml:space="preserve">
          <source>Value to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640fc9d1038f173d9ff4e515bd951053c5419590" translate="yes" xml:space="preserve">
          <source>Value to return from &lt;code&gt;onSend&lt;/code&gt;/&lt;code&gt;onReceive&lt;/code&gt; delegates in order to pause a request</source>
          <target state="translated">Значение, возвращаемое &lt;code&gt;onSend&lt;/code&gt; / &lt;code&gt;onReceive&lt;/code&gt; для приостановки запроса</target>
        </trans-unit>
        <trans-unit id="436caeedb105a260006f5d9f53f71e6eb7af184e" translate="yes" xml:space="preserve">
          <source>Value to return from onSend delegate in order to abort a request</source>
          <target state="translated">Значение для возврата от onSend делегата для прерывания запроса</target>
        </trans-unit>
        <trans-unit id="ed85e45d389cbb4acbbfe9be4b8d5516228b0f43" translate="yes" xml:space="preserve">
          <source>Value type demonstration</source>
          <target state="translated">Демонстрация типа значения</target>
        </trans-unit>
        <trans-unit id="ad0bdabc6c843c169a4bd7ec05f40c7999e6699f" translate="yes" xml:space="preserve">
          <source>Value value</source>
          <target state="translated">Стоимость</target>
        </trans-unit>
        <trans-unit id="5fb5308fe6160bec01a01fc2fea5f665d1701122" translate="yes" xml:space="preserve">
          <source>ValueSeq</source>
          <target state="translated">ValueSeq</target>
        </trans-unit>
        <trans-unit id="80e79fa2f03b848be57a9426e000a580cab24a28" translate="yes" xml:space="preserve">
          <source>Value[Key] &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff7efaccf1f82a33020670f421492cb87dbc329" translate="yes" xml:space="preserve">
          <source>Values &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">Значения &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e66a2fd88968dd1905cd7e88ccfa7f4decf710b7" translate="yes" xml:space="preserve">
          <source>Values for Tflags:</source>
          <target state="translated">Ценности для Тфлагов:</target>
        </trans-unit>
        <trans-unit id="d65dbad78909b2a5a1065f983fcd9dc730699c3f" translate="yes" xml:space="preserve">
          <source>Values representing all properties for floating point types</source>
          <target state="translated">Значения,представляющие все свойства для типов с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="f93686df732b3fd8135c18d6d396b9ab2d76ddbc" translate="yes" xml:space="preserve">
          <source>Values that have no mutable indirections (including structs that don't contain any field with mutable indirections) can be implicitly converted across</source>
          <target state="translated">Значения,не имеющие мутируемых индендикаций (включая структуры,не содержащие ни одного поля с мутируемыми индендикциями),могут неявно преобразовываться через</target>
        </trans-unit>
        <trans-unit id="6dae52b6d63731f1974b82b7571f6c94a8ffe05e" translate="yes" xml:space="preserve">
          <source>Values to initialize the &lt;code&gt;Tuple&lt;/code&gt; with. The &lt;code&gt;Tuple&lt;/code&gt;'s type will be inferred from the types of the values given.</source>
          <target state="translated">Значения для инициализации &lt;code&gt;Tuple&lt;/code&gt; . Тип &lt;code&gt;Tuple&lt;/code&gt; будет определяться по типам данных значений.</target>
        </trans-unit>
        <trans-unit id="a08087f5493c6ce5a8e9b48863d20de7128f05b2" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">VarDeclaration &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a1466d563df21a998ae094ed1211927a8bb608" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;copyToTemp&quot;&gt;copyToTemp&lt;/strong&gt;(StorageClass stc, const char* name, Expression e);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;copyToTemp&quot;&gt;copyToTemp&lt;/strong&gt; (StorageClass stc, const char * name, Expression e);</target>
        </trans-unit>
        <trans-unit id="8b0928059a3c63031609334a2150b3e8d06084c2" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;expToVariable&quot;&gt;expToVariable&lt;/strong&gt;(Expression e);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;expToVariable&quot;&gt;expToVariable&lt;/strong&gt; (Выражение e);</target>
        </trans-unit>
        <trans-unit id="90f8642275d9fc08bf7503b4c8af023eb923bdfb" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;lastVar&quot;&gt;lastVar&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;lastVar&quot;&gt;lastVar&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="93a7a74d06aa15956fd41f9b3c8c0f88bdfeb09e" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;makeThis2Argument&quot;&gt;makeThis2Argument&lt;/strong&gt;(ref const Loc loc, Scope* sc, FuncDeclaration fd);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;makeThis2Argument&quot;&gt;makeThis2Argument&lt;/strong&gt; (ссылка на Loc, Scope * sc, FuncDeclaration fd);</target>
        </trans-unit>
        <trans-unit id="f8436ac83c71ac8d42475febc7871f32c710c99c" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;nrvo_var&quot;&gt;nrvo_var&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;nrvo_var&quot;&gt;nrvo_var&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="18c616e0fbbc261b725f83621064accc3a1deeea" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;selectorParameter&quot;&gt;selectorParameter&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;selectorParameter&quot;&gt;selectorParameter&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="12d50a347dabe7e15bb22e20811c56593e1bcae1" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;v_argptr&quot;&gt;v_argptr&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;v_argptr&quot;&gt;v_argptr&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="f56d1a786ffb7ff06d7bb5bfa04d51b1b21ab644" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;v_arguments&quot;&gt;v_arguments&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;v_arguments&quot;&gt;v_arguments&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="876239d27c5e57e358e8556afab8f0538d5c97fc" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;var&quot;&gt;var&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;var&quot;&gt;var&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="42355f26f4ab9b91101680194f5be4e62a6fe977" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;vresult&quot;&gt;vresult&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;vresult&quot;&gt;vresult&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2e565c7d36ce463afb9fc418f5d295a5bbc339dc" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;vthis&quot;&gt;vthis&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;vthis&quot;&gt;vthis&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cbb4632d198d84986be1df6e34c6a01f8e53f3c6" translate="yes" xml:space="preserve">
          <source>VarDeclaration[] &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">VarDeclaration [] &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cd372ff99770eda36a8d3e2dcd3e16f4cd0b425" translate="yes" xml:space="preserve">
          <source>VarDeclarations &lt;strong id=&quot;closureVars&quot;&gt;closureVars&lt;/strong&gt;;</source>
          <target state="translated">VarDeclarations &lt;strong id=&quot;closureVars&quot;&gt;closureVars&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d1b9876e8a834a3e9b9e89838f595256e4706851" translate="yes" xml:space="preserve">
          <source>VarDeclarations* &lt;code&gt;vars&lt;/code&gt;</source>
          <target state="translated">VarDeclarations * &lt;code&gt;vars&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d65fd05a8f0de9525a8aab22e9d373bb1f9c2e" translate="yes" xml:space="preserve">
          <source>VarDeclarations* &lt;strong id=&quot;parameters&quot;&gt;parameters&lt;/strong&gt;;</source>
          <target state="translated">VarDeclarations * &lt;strong id=&quot;parameters&quot;&gt;параметры&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="8de05a295df0a022b8c2f74c1c4b8846fa725f50" translate="yes" xml:space="preserve">
          <source>Variable Templates</source>
          <target state="translated">Переменные шаблоны</target>
        </trans-unit>
        <trans-unit id="9ac503641226541343accfe90a0e5126b2011089" translate="yes" xml:space="preserve">
          <source>Variable declarations with the storage class &lt;code&gt;extern&lt;/code&gt; are not allocated storage within the module. They must be defined in some other object file with a matching name which is then linked in.</source>
          <target state="translated">Объявления переменных с классом хранения &lt;code&gt;extern&lt;/code&gt; не выделяются для хранения внутри модуля. Они должны быть определены в каком-то другом объектном файле с соответствующим именем, которое затем будет связано.</target>
        </trans-unit>
        <trans-unit id="f86354cce64b43ba4bcdfcfa863ee091b56ebec5" translate="yes" xml:space="preserve">
          <source>Variadic Function Arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d65e9595c5fe8cf9c55be3b01afd1c068462a4a" translate="yes" xml:space="preserve">
          <source>Variadic Function Templates can have parameters with default values. These parameters are always set to their default value in case of IFTI.</source>
          <target state="translated">Шаблоны переменных функций могут иметь параметры со значениями по умолчанию.В случае IFTI эти параметры всегда устанавливаются на их значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="816e535fd41b8ae59e68e3a0203deed34e57e3f0" translate="yes" xml:space="preserve">
          <source>Variadic Functions</source>
          <target state="translated">вариадические функции</target>
        </trans-unit>
        <trans-unit id="3ce44260db47b27a0765a58fa46f6799200c7452" translate="yes" xml:space="preserve">
          <source>Variadic argument list.</source>
          <target state="translated">Вариадический список аргументов.</target>
        </trans-unit>
        <trans-unit id="7587c77875817ada8a5026c856c2f1518162a905" translate="yes" xml:space="preserve">
          <source>Variadic argument lists &lt;a href=&quot;https://dlang.org/spec/function.html#variadic&quot;&gt;https://dlang.org/spec/function.html#variadic&lt;/a&gt;</source>
          <target state="translated">Списки аргументов Variadic &lt;a href=&quot;https://dlang.org/spec/function.html#variadic&quot;&gt;https://dlang.org/spec/function.html#variadic&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2baf171f268c7ff8a5516278ea308ebe744eee6a" translate="yes" xml:space="preserve">
          <source>Variadic arguments to constructors are not forwarded to super.</source>
          <target state="translated">Вариадические аргументы к конструкторам не передаются на супер.</target>
        </trans-unit>
        <trans-unit id="032728a05fbda40894355d391ba66d41db7dfa0b" translate="yes" xml:space="preserve">
          <source>Variadic constructor</source>
          <target state="translated">вариадический конструктор</target>
        </trans-unit>
        <trans-unit id="399c0cba694f3cc4563013462fe2f380391903d2" translate="yes" xml:space="preserve">
          <source>Variadic functions with argument and type info are declared as taking a parameter of ... after the required function parameters. It has D linkage, and need not have any non-variadic parameters declared:</source>
          <target state="translated">Вариадические функции с информацией об аргументе и типе объявляются как принимающие параметр ...после требуемых параметров функции.Она имеет D-связь и не обязана объявлять никаких не-вариантных параметров:</target>
        </trans-unit>
        <trans-unit id="e4ee6519876a792c801d55be8e1784d8bf29d4ef" translate="yes" xml:space="preserve">
          <source>Variadic functions with type info</source>
          <target state="translated">Вариадические функции с информацией о типе</target>
        </trans-unit>
        <trans-unit id="5d2a300261f6a90712ba60d1554b5378b1469844" translate="yes" xml:space="preserve">
          <source>Variadic list of arguments to format into returned string.</source>
          <target state="translated">Переменный список аргументов для форматирования в возвращаемую строку.</target>
        </trans-unit>
        <trans-unit id="b8a1599a54086f4276bc080b191b81748f1fd35d" translate="yes" xml:space="preserve">
          <source>Variadic list of function pointers and delegates. Entries in this list must not occlude later entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea010a54d25304f176a7f8d1fba33099d2a6ac09" translate="yes" xml:space="preserve">
          <source>Variadic list of types to be received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cacd55c63e5681b498a2a8e79b74af695379b94" translate="yes" xml:space="preserve">
          <source>Variadic skipOver</source>
          <target state="translated">Вариадический скипОвер</target>
        </trans-unit>
        <trans-unit id="3ec54f528a04bfb78ded9b978c3382ebd1084d0f" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;message&quot;&gt;message&lt;/strong&gt;;</source>
          <target state="translated">Вариант &lt;strong id=&quot;message&quot;&gt;сообщения&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="32ee207e01c00b2bfe4113ac9e48d0adc0d9a6ad" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;opIndexAssign&quot;&gt;opIndexAssign&lt;/strong&gt;(T, N)(T value, N i);</source>
          <target state="translated">Вариант &lt;strong id=&quot;opIndexAssign&quot;&gt;opIndexAssign&lt;/strong&gt; (T, N) (значение T, N i);</target>
        </trans-unit>
        <trans-unit id="39996f79d077e561bfc7c4efc30631527277acc7" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;opIndexOpAssign&quot;&gt;opIndexOpAssign&lt;/strong&gt;(string op, T, N)(T value, N i);</source>
          <target state="translated">Вариант &lt;strong id=&quot;opIndexOpAssign&quot;&gt;opIndexOpAssign&lt;/strong&gt; (строка op, T, N) (значение T, N i);</target>
        </trans-unit>
        <trans-unit id="54c59e2064d684bcdbd701d33a0bcca0d124521f" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opAssign&quot;&gt;opAssign&lt;/strong&gt;(T)(T rhs);</source>
          <target state="translated">ВариантN &lt;strong id=&quot;opAssign&quot;&gt;opAssign&lt;/strong&gt; (T) (T rhs);</target>
        </trans-unit>
        <trans-unit id="a89006b66590fbcedb1cf804abc7dcc4a7855324" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, T)(T rhs)</source>
          <target state="translated">ВариантN &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (строка op, T) (T rhs)</target>
        </trans-unit>
        <trans-unit id="d50bd63e988142a8ed68771d6708dd3a3ef38a9f" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt;(string op, T)(T lhs)</source>
          <target state="translated">ВариантN &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt; (строка op, T) (T lhs)</target>
        </trans-unit>
        <trans-unit id="dcf8ce2200e09370d71e1c6c556f440c7178243e" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, T)(T rhs);</source>
          <target state="translated">ВариантN &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt; (строка op, T) (T rhs);</target>
        </trans-unit>
        <trans-unit id="61d3a42cae9e2aa7a2127354c8d2a82e31e5f69f" translate="yes" xml:space="preserve">
          <source>Variant[] &lt;strong id=&quot;variantArray&quot;&gt;variantArray&lt;/strong&gt;(T...)(T args);</source>
          <target state="translated">Variant [] &lt;strong id=&quot;variantArray&quot;&gt;variableArray&lt;/strong&gt; (T ...) (T args);</target>
        </trans-unit>
        <trans-unit id="901dc81724f513c6e370e0d8b34b4fa85efd9490" translate="yes" xml:space="preserve">
          <source>Variation Selectors</source>
          <target state="translated">Вариационные селекторы</target>
        </trans-unit>
        <trans-unit id="c842f577712c9ce569d8ca8213f4583b78433b04" translate="yes" xml:space="preserve">
          <source>Variation Selectors Supplement</source>
          <target state="translated">Дополнение к селекторам вариаций</target>
        </trans-unit>
        <trans-unit id="66283c9058f793e57afbf6f12f5f67c2782019ef" translate="yes" xml:space="preserve">
          <source>Variation of Base64 encoding that is safe for use in URLs and filenames.</source>
          <target state="translated">Вариант кодировки Base64,безопасный для использования в URL и именах файлов.</target>
        </trans-unit>
        <trans-unit id="85213404cd60884f4a897dfadd72c6565a384b83" translate="yes" xml:space="preserve">
          <source>Variation_Selector</source>
          <target state="translated">Variation_Selector</target>
        </trans-unit>
        <trans-unit id="37d044e9653fde1af3399c03c94f78dbe8624404" translate="yes" xml:space="preserve">
          <source>Various different debug builds can be built with a parameter to debug:</source>
          <target state="translated">Различные отладочные сборки могут быть собраны с параметром для отладки:</target>
        </trans-unit>
        <trans-unit id="fdc4922db0ff01d0b7edd8e9b629bfcad196b8fd" translate="yes" xml:space="preserve">
          <source>Various different version builds can be built with a parameter to version:</source>
          <target state="translated">Различные сборки версий могут быть собраны с параметром от версии к версии:</target>
        </trans-unit>
        <trans-unit id="e63f884e9cb15e3080b00623367fb3234dfb09e6" translate="yes" xml:space="preserve">
          <source>Various functions take a string (or strings) to represent a unit of time (e.g. &lt;code&gt;convert!(&quot;days&quot;, &quot;hours&quot;)(numDays)&lt;/code&gt;). The valid strings to use with such functions are &quot;years&quot;, &quot;months&quot;, &quot;weeks&quot;, &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;, &quot;seconds&quot;, &quot;msecs&quot; (milliseconds), &quot;usecs&quot; (microseconds), &quot;hnsecs&quot; (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There are a few functions that also allow &quot;nsecs&quot;, but very little actually has precision greater than hnsecs.</source>
          <target state="translated">Различные функции принимают строку (или строки) для представления единицы времени (например, &lt;code&gt;convert!(&quot;days&quot;, &quot;hours&quot;)(numDays)&lt;/code&gt; ). Допустимые строки для использования с такими функциями: &amp;laquo;годы&amp;raquo;, &amp;laquo;месяцы&amp;raquo;, &amp;laquo;недели&amp;raquo;, &amp;laquo;дни&amp;raquo;, &amp;laquo;часы&amp;raquo;, &amp;laquo;минуты&amp;raquo;, &amp;laquo;секунды&amp;raquo;, &amp;laquo;мсек&amp;raquo; (миллисекунды), &amp;laquo;юзекс&amp;raquo; (микросекунды) , &quot;hnsecs&quot; (гекто-наносекунды - то есть 100 нс) или некоторые их подмножества. Есть несколько функций, которые также допускают &amp;laquo;nsecs&amp;raquo;, но на самом деле очень немногие имеют точность выше, чем hnsecs.</target>
        </trans-unit>
        <trans-unit id="0e7432cf190c6da3860c9d822a4eb7ba1045ce6c" translate="yes" xml:space="preserve">
          <source>Vector Extensions</source>
          <target state="translated">Векторные удлинители</target>
        </trans-unit>
        <trans-unit id="10629e605ca0729fbf04887a08544de5fca2798c" translate="yes" xml:space="preserve">
          <source>Vector Operation Intrinsics</source>
          <target state="translated">Векторная хирургическая интриника</target>
        </trans-unit>
        <trans-unit id="c92e264e05e71f98aeb7e123b045932363360044" translate="yes" xml:space="preserve">
          <source>Vector Type Properties</source>
          <target state="translated">Свойства векторного типа</target>
        </trans-unit>
        <trans-unit id="2e86fbb68d6a32b094e97ddedce6b62c4721cb9e" translate="yes" xml:space="preserve">
          <source>Vector Types</source>
          <target state="translated">векторные типы</target>
        </trans-unit>
        <trans-unit id="07181b72545f73b7288ae34baa8a686beb32c758" translate="yes" xml:space="preserve">
          <source>Vector types and operations are introduced by importing &lt;a href=&quot;https://dlang.org/phobos/core_simd.html&quot;&gt;&lt;code&gt;core.simd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Векторные типы и операции вводятся путем импорта &lt;a href=&quot;https://dlang.org/phobos/core_simd.html&quot;&gt; &lt;code&gt;core.simd&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c049990f0c907a0b35a257826bc00e0b75b1e2f2" translate="yes" xml:space="preserve">
          <source>Vector types have the property:</source>
          <target state="translated">Векторные типы имеют свойство:</target>
        </trans-unit>
        <trans-unit id="b74915db3cd649e1a4f2705d1b61481a4f84d736" translate="yes" xml:space="preserve">
          <source>Vector types of the same size can be implicitly converted among each other. Vector types can be cast to their &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Векторные типы одинакового размера могут быть неявно преобразованы друг в друга. Векторные типы могут быть приведены к их &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18c53b8bedaa759385d9a1d0719db45a3122d467" translate="yes" xml:space="preserve">
          <source>Vedic Extensions</source>
          <target state="translated">Ведические расширения</target>
        </trans-unit>
        <trans-unit id="1414b2c627a4af94b45e0a6f7329a9caaa64d766" translate="yes" xml:space="preserve">
          <source>Vendor Specific Pragmas</source>
          <target state="translated">Прагмы,специфические для поставщиков</target>
        </trans-unit>
        <trans-unit id="643648d81a8af7bf6b4f73a64885b12b7476a866" translate="yes" xml:space="preserve">
          <source>Vendor specific pragma</source>
          <target state="translated">Прагма конкретного поставщика</target>
        </trans-unit>
        <trans-unit id="9200d77a5dd8fafeec19ec715fa8db6a41135a49" translate="yes" xml:space="preserve">
          <source>Vendor specific string naming the compiler, for example: &quot;Digital Mars D&quot;.</source>
          <target state="translated">Например,именование компилятора по конкретной строке от производителя:&quot;Цифровой Марс D&quot;.</target>
        </trans-unit>
        <trans-unit id="db3cbc01da600701b9fe4a497fe328e71fa7022f" translate="yes" xml:space="preserve">
          <source>Version 1</source>
          <target state="translated">Версия 1</target>
        </trans-unit>
        <trans-unit id="57ce28f628abe360a4bb4a57891d0472e82ed0fe" translate="yes" xml:space="preserve">
          <source>Version 2</source>
          <target state="translated">Версия 2</target>
        </trans-unit>
        <trans-unit id="075d8b625649c8aff29ec9c2a1b5610d7c109764" translate="yes" xml:space="preserve">
          <source>Version 3 (Name based + MD5)</source>
          <target state="translated">Версия 3 (на основе имени+MD5)</target>
        </trans-unit>
        <trans-unit id="ddcc753d5e82e42538acd5fc16f4473c5257f4b4" translate="yes" xml:space="preserve">
          <source>Version 4 (Random)</source>
          <target state="translated">Версия 4 (Случайный)</target>
        </trans-unit>
        <trans-unit id="319868a4751c2b346e9dfe64ab6429818b302223" translate="yes" xml:space="preserve">
          <source>Version 5 (Name based + SHA-1)</source>
          <target state="translated">Версия 5 (на основе имени+SHA-1)</target>
        </trans-unit>
        <trans-unit id="e66316ca12a840f1988c4b94ab525a7f42bae2cc" translate="yes" xml:space="preserve">
          <source>Version Condition</source>
          <target state="translated">Состояние версии</target>
        </trans-unit>
        <trans-unit id="4d10083d98ea26e265f0014436dbfce2fa1927ba" translate="yes" xml:space="preserve">
          <source>Version Specification</source>
          <target state="translated">Спецификация версии</target>
        </trans-unit>
        <trans-unit id="60cbe77612285f77722795eaf486e9077345ff6b" translate="yes" xml:space="preserve">
          <source>Version identifiers are in their own unique name space, they do not conflict with debug identifiers or other symbols in the module. Version identifiers defined in one module have no influence over other imported modules.</source>
          <target state="translated">Идентификаторы версий находятся в собственном уникальном пространстве имен,они не конфликтуют с отладочными идентификаторами или другими символами в модуле.Идентификаторы версий,определенные в одном модуле,не влияют на другие импортируемые модули.</target>
        </trans-unit>
        <trans-unit id="8452f9b655098d440b8bbfefe1781b61039f888f" translate="yes" xml:space="preserve">
          <source>Version identifiers or levels may not be forward referenced:</source>
          <target state="translated">Идентификаторы версий или уровни не могут перенаправляться:</target>
        </trans-unit>
        <trans-unit id="8639bd1e7277675ae42f2185af060f18565b1cba" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;task&lt;/code&gt; usable from &lt;code&gt;@safe&lt;/code&gt; code. Usage mechanics are identical to the non-@safe case, but safety introduces some restrictions:</source>
          <target state="translated">Версия &lt;code&gt;task&lt;/code&gt; используемая из кода &lt;code&gt;@safe&lt;/code&gt; . Механика использования идентична небезопасному случаю, но безопасность вводит некоторые ограничения:</target>
        </trans-unit>
        <trans-unit id="9f49127025fb5873ad1bd738867c76e3725ffeaa" translate="yes" xml:space="preserve">
          <source>Version:</source>
          <target state="translated">Version:</target>
        </trans-unit>
        <trans-unit id="8ba6c0ad00aab5da97cc5e9d2ce6ef4a16d6e35f" translate="yes" xml:space="preserve">
          <source>VersionCondition</source>
          <target state="translated">VersionCondition</target>
        </trans-unit>
        <trans-unit id="d5945a6259445f6d607383ec1208b7b2bf5b1920" translate="yes" xml:space="preserve">
          <source>VersionSpecification</source>
          <target state="translated">VersionSpecification</target>
        </trans-unit>
        <trans-unit id="7870ecf513f546adaa9964ca9e10d00cc0c279a8" translate="yes" xml:space="preserve">
          <source>VersionSymbol's happen for statements like: version = identifier; version = integer;</source>
          <target state="translated">VersionSymbol's происходит для таких выражений как:version=идентификатор;version=целое число;</target>
        </trans-unit>
        <trans-unit id="3f4a4fcd926f6c485e563d96d221a73c6f637a3b" translate="yes" xml:space="preserve">
          <source>Versions enable multiple versions of a module to be implemented with a single source file.</source>
          <target state="translated">Версии позволяют реализовать несколько версий модуля в одном исходном файле.</target>
        </trans-unit>
        <trans-unit id="6fd4c427e710fed77db57126b79deded3402ad4f" translate="yes" xml:space="preserve">
          <source>Vertical Forms</source>
          <target state="translated">Вертикальные формы</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">Вертикальная вкладка</target>
        </trans-unit>
        <trans-unit id="783de7e5b7d2118dade416730da300df060f3cbb" translate="yes" xml:space="preserve">
          <source>Vertical tab (U+000B).</source>
          <target state="translated">Вертикальная вкладка (U+000B).</target>
        </trans-unit>
        <trans-unit id="b5a83b3d5b0ebbd94dda9282d36df61edd71daee" translate="yes" xml:space="preserve">
          <source>Very good at doing absolutely nothing. A good starting point for defining other allocators or for studying the API.</source>
          <target state="translated">Очень хорош в том,чтобы ничего не делать.Хорошая отправная точка для определения других аллокаторов или для изучения API.</target>
        </trans-unit>
        <trans-unit id="83b6b08c6edd1287fdcd6c32741f985b4501a4d1" translate="yes" xml:space="preserve">
          <source>View Name NULL</source>
          <target state="translated">Просмотр Название NULL</target>
        </trans-unit>
        <trans-unit id="7661d9e884510184f3115feaa61daa7fb90ab554" translate="yes" xml:space="preserve">
          <source>Virtual File System Objects</source>
          <target state="translated">Объекты виртуальной файловой системы</target>
        </trans-unit>
        <trans-unit id="b0befb20b7c19afcab0b8606b1eb82ff57c76c58" translate="yes" xml:space="preserve">
          <source>Virtual Function Pointer Table Layout</source>
          <target state="translated">Макет таблицы виртуальных указателей функций</target>
        </trans-unit>
        <trans-unit id="7dcd32ac0fb832374c32b25d413091959d3ff701" translate="yes" xml:space="preserve">
          <source>Virtual Functions</source>
          <target state="translated">Виртуальные функции</target>
        </trans-unit>
        <trans-unit id="0f4f4c40c9b657d040c9a5a3549b3c5d32fbc234" translate="yes" xml:space="preserve">
          <source>Virtual Table Configuration Options</source>
          <target state="translated">Опции конфигурации виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="d3cabefe217e8ae9513576669d0630c721003893" translate="yes" xml:space="preserve">
          <source>Virtual Table Cursor Object</source>
          <target state="translated">Объект виртуального столового курсора</target>
        </trans-unit>
        <trans-unit id="02d05d9b66c15b554ca60cadbe6ddd8d5a77642f" translate="yes" xml:space="preserve">
          <source>Virtual Table Indexing Information</source>
          <target state="translated">Виртуальная таблица Индексирование Информация</target>
        </trans-unit>
        <trans-unit id="80548cb099ad243dfef606537d8cb425cbe7b21c" translate="yes" xml:space="preserve">
          <source>Virtual Table Instance Object</source>
          <target state="translated">Объект виртуальной табличной инстанции</target>
        </trans-unit>
        <trans-unit id="c7613e2461269638f02a689a01bdfb20ef96932a" translate="yes" xml:space="preserve">
          <source>Virtual Table Object</source>
          <target state="translated">Объект виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="aff3c69afbe7a90d7ffde690777408380726fb5f" translate="yes" xml:space="preserve">
          <source>Virtual functions all have a hidden parameter called the</source>
          <target state="translated">Все виртуальные функции имеют скрытый параметр,называемый</target>
        </trans-unit>
        <trans-unit id="e1c58c4269e8592749612ae3da0cd7b360ba819a" translate="yes" xml:space="preserve">
          <source>Virtual functions are functions that are called indirectly through a function pointer table, called a vtbl[], rather than directly. All &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; member functions which are non-static and are not templatized are virtual unless the compiler can determine that they will never be overridden (e.g. they are marked with &lt;code&gt;final&lt;/code&gt; and do not override any functions in a base class), in which case, it will make them non-virtual. Static or &lt;code&gt;final&lt;/code&gt; functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage are virtual as well. This results in fewer bugs caused by not declaring a function virtual and then overriding it anyway.</source>
          <target state="translated">Виртуальные функции - это функции, которые вызываются косвенно через таблицу указателей на функции, называемую vtbl [], а не напрямую. Все &lt;code&gt;public&lt;/code&gt; и &lt;code&gt;protected&lt;/code&gt; функции-члены, которые не являются статичными и не шаблонизированы, являются виртуальными, если только компилятор не может определить, что они никогда не будут переопределены (например, они помечены как &lt;code&gt;final&lt;/code&gt; и не переопределяют никакие функции в базовом классе), и в этом случае , это сделает их не виртуальными. Статические или &lt;code&gt;final&lt;/code&gt; функции со связью &lt;code&gt;Objective-C&lt;/code&gt; также являются виртуальными. Это приводит к меньшему количеству ошибок, вызванных тем, что функция не объявляется виртуальной, а затем переопределяется.</target>
        </trans-unit>
        <trans-unit id="14cc5cce0a54264b12497e056c1917afd19e7eb7" translate="yes" xml:space="preserve">
          <source>Virtual interface member functions do not have implementations. Interfaces are expected to implement static or final functions.</source>
          <target state="translated">Функции членов виртуального интерфейса не имеют реализаций.Интерфейсы должны реализовывать статические или конечные функции.</target>
        </trans-unit>
        <trans-unit id="23ecb6a10d1b99be3019a63076a2464bbfbb2301" translate="yes" xml:space="preserve">
          <source>Virtual table of this cursor</source>
          <target state="translated">Виртуальная таблица этого курсора</target>
        </trans-unit>
        <trans-unit id="1c1672376b6b5ed02995bff06fe4feb7630511fb" translate="yes" xml:space="preserve">
          <source>Visibility Attribute</source>
          <target state="translated">Видимость Атрибут</target>
        </trans-unit>
        <trans-unit id="770309d5c2e0f2778ba518ab224adafe114b41f4" translate="yes" xml:space="preserve">
          <source>Visibility is an attribute that is one of &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, or &lt;code&gt;export&lt;/code&gt;. They may be referred to as protection attributes in documents predating &lt;a href=&quot;http://wiki.dlang.org/DIP22&quot;&gt;DIP22&lt;/a&gt;.</source>
          <target state="translated">Видимость - это один из атрибутов &lt;code&gt;private&lt;/code&gt; , &lt;code&gt;package&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; , &lt;code&gt;public&lt;/code&gt; или &lt;code&gt;export&lt;/code&gt; . Они могут упоминаться как атрибуты защиты в документах, предшествующих &lt;a href=&quot;http://wiki.dlang.org/DIP22&quot;&gt;DIP22&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c05960b386f26ee3e915fac197d378f3ebcb6a8" translate="yes" xml:space="preserve">
          <source>Visibility participates in &lt;a href=&quot;module#name_lookup&quot;&gt;symbol name lookup&lt;/a&gt;.</source>
          <target state="translated">Видимость участвует в &lt;a href=&quot;module#name_lookup&quot;&gt;поиске имени символа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c92fbe0bbb759a09c0faa29208bb88b78b9b6f8" translate="yes" xml:space="preserve">
          <source>Visit each overloaded function/template in turn, and call dg(s) on it. Exit when no more, or dg(s) returns nonzero.</source>
          <target state="translated">Посетите каждую перегруженную функцию/шаблон по очереди и вызовите на них dg(s).Выход,когда больше нет,или dg(s)возвращает ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="095d4e1da0ccccf0f23cb7d7417321dea1d13b5b" translate="yes" xml:space="preserve">
          <source>Visitor &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">Посетитель &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed75e8e2064c0cf00a947caba1ce28a6fe75f18b" translate="yes" xml:space="preserve">
          <source>Visitor that implements the AST traversal logic. The nodes just accept their children.</source>
          <target state="translated">Посетитель,реализующий логику обхода АСТ.Узлы просто принимают своих детей.</target>
        </trans-unit>
        <trans-unit id="15fa187dd92efb368750787f933eb6c9f5cdd9fe" translate="yes" xml:space="preserve">
          <source>Visits this AST node using the given visitor.</source>
          <target state="translated">Посещает этот узел AST,используя данного посетителя.</target>
        </trans-unit>
        <trans-unit id="7e76fe40efd36819ad4216cae6d472d259442ebf" translate="yes" xml:space="preserve">
          <source>Void Arrays</source>
          <target state="translated">Массивы пустот</target>
        </trans-unit>
        <trans-unit id="a3b9953f805ebbaefa9422b2c296b873ff21f42c" translate="yes" xml:space="preserve">
          <source>Void Initialization</source>
          <target state="translated">Пустота инициализации</target>
        </trans-unit>
        <trans-unit id="bf3edd1e4d2a01f42d21c6548696eea61602c39b" translate="yes" xml:space="preserve">
          <source>Void Initializations</source>
          <target state="translated">Пустые инициалы</target>
        </trans-unit>
        <trans-unit id="ccfd4941fe26581cb178fed9382832c4cba184df" translate="yes" xml:space="preserve">
          <source>Void arrays can also be static if their length is known at compile-time. The length is specified in bytes:</source>
          <target state="translated">Массивы пустот также могут быть статическими,если их длина известна во время компиляции.Длина задается в байтах:</target>
        </trans-unit>
        <trans-unit id="890c294807ca10112b82fc9f040a92f0216da8fb" translate="yes" xml:space="preserve">
          <source>Void initialization</source>
          <target state="translated">Пустая инициализация</target>
        </trans-unit>
        <trans-unit id="c4b24fa2258ec7811ee9e879e6eca4832264dcda" translate="yes" xml:space="preserve">
          <source>Void initialization happens when the</source>
          <target state="translated">Пустая инициализация происходит,когда</target>
        </trans-unit>
        <trans-unit id="fb784fd125a647101103d95f3587d3eb4a57ab75" translate="yes" xml:space="preserve">
          <source>Void initializers are useful when a static array is on the stack, but may only be partially used, such as as a temporary buffer. Void initializers will potentially speed up the code, but they introduce risk, since one must ensure that array elements are always set before read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab1e006db65f1026fe412d6860f8f97f169e1e3" translate="yes" xml:space="preserve">
          <source>Void initializers are useful when a static array is on the stack, but may only be partially used, such as as a temporary buffer. Void initializers will speed up the code, but of course one must be careful that array elements are actually set before read.</source>
          <target state="translated">Пустые инициализаторы полезны,когда статический массив находится на стеке,но может использоваться только частично,например,как временный буфер.Инициализаторы Void ускорят код,но,конечно же,нужно быть внимательным,чтобы элементы массива действительно устанавливались перед чтением.</target>
        </trans-unit>
        <trans-unit id="85711bbab02376ea3639e90420334b39d180e7f3" translate="yes" xml:space="preserve">
          <source>Vowel_Jamo</source>
          <target state="translated">Vowel_Jamo</target>
        </trans-unit>
        <trans-unit id="cc18367ee9ae48793537b626dc7c6035a5dae6ff" translate="yes" xml:space="preserve">
          <source>W &lt;code&gt;sink&lt;/code&gt;</source>
          <target state="translated">W &lt;code&gt;sink&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e10e55ca871f7800c8635fe6f5905c30390e16a5" translate="yes" xml:space="preserve">
          <source>W &lt;code&gt;writer&lt;/code&gt;</source>
          <target state="translated">W &lt;code&gt;writer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="976cfcd0da2fb30c19ae7f1f66adbb80b2336434" translate="yes" xml:space="preserve">
          <source>WANTvalue, WANTexpand, or both</source>
          <target state="translated">WANT Value,WANTexpand,или и то,и другое.</target>
        </trans-unit>
        <trans-unit id="ec14f016fb7dffb13f20a17258a5682225f1c0e0" translate="yes" xml:space="preserve">
          <source>WARNING: The definition and usefulness of property functions is being reviewed, and the implementation is currently incomplete. Using property functions is not recommended until the definition is more certain and implementation more mature.</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЕ:В настоящее время проводится обзор определения и полезности функций,связанных с имуществом,и в настоящее время эта работа еще не завершена.Использование функций собственности не рекомендуется до тех пор,пока определение не станет более определенным,а реализация-более зрелой.</target>
        </trans-unit>
        <trans-unit id="b3bc723275b7f5ad79fcec381f0cb5efbff0d10d" translate="yes" xml:space="preserve">
          <source>WARNING: The postblit is considered legacy and is not recommended for new code. Code should use &lt;a href=&quot;#struct-copy-constructor&quot;&gt;copy constructors&lt;/a&gt; defined in the previous section. For backward compatibility reasons, a &lt;code&gt;struct&lt;/code&gt; that explicitly defines both a copy constructor and a postblit will only use the postblit for implicit copying. However, if the postblit is disabled, the copy constructor will be used. If a struct defines a copy constructor and has fields that define postblits, the user-defined copy constructor will have priority over the generated postblit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1993a9a26ed4c6cb9fdc78f41ef76eb1b8bc19b" translate="yes" xml:space="preserve">
          <source>WARNING: The postblit is considered legacy and is not recommended for new code. Code should use copy constructors defined in the previous section. For backward compatibility reasons, a &lt;code&gt;struct&lt;/code&gt; that defines both a copy constructor and a postblit will only use the postblit for implicit copying.</source>
          <target state="translated">ВНИМАНИЕ: постблит считается устаревшим и не рекомендуется для нового кода. Код должен использовать конструкторы копирования, определенные в предыдущем разделе. По причинам обратной совместимости &lt;code&gt;struct&lt;/code&gt; которая определяет и конструктор копирования, и постблит, будет использовать постблит только для неявного копирования.</target>
        </trans-unit>
        <trans-unit id="453d0dbab57f60df1e38422e14ddfb0ffca9751d" translate="yes" xml:space="preserve">
          <source>WASI C runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7856604c77c8c3b6db3dda073e819dddc48459eb" translate="yes" xml:space="preserve">
          <source>Wait for a socket to change status. A wait timeout of &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;TimeVal&lt;/code&gt;, may be specified; if a timeout is not specified or the &lt;code&gt;TimeVal&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the maximum timeout is used. The &lt;code&gt;TimeVal&lt;/code&gt; timeout has an unspecified value when &lt;code&gt;select&lt;/code&gt; returns.</source>
          <target state="translated">Подождите, пока сокет изменит статус. &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; аут ожидания core.time.Duration или &lt;code&gt;TimeVal&lt;/code&gt; , может быть указан; если время ожидания не указано или значение &lt;code&gt;TimeVal&lt;/code&gt; равно &lt;code&gt;null&lt;/code&gt; , используется максимальное время ожидания. &lt;code&gt;TimeVal&lt;/code&gt; тайм - аут имеет неопределенное значение , когда &lt;code&gt;select&lt;/code&gt; возвращения.</target>
        </trans-unit>
        <trans-unit id="77899536f331c4ec4bcbefe715f29e2da5bd4c54" translate="yes" xml:space="preserve">
          <source>Wait for a thread created with &lt;code&gt;createLowLevelThread&lt;/code&gt; to terminate.</source>
          <target state="translated">Дождитесь завершения потока, созданного с помощью &lt;code&gt;createLowLevelThread&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca457eefc1faa13be00867e50d6b627144102aaa" translate="yes" xml:space="preserve">
          <source>Wait for the event to be signaled with timeout.</source>
          <target state="translated">Дождитесь сигнала о событии с тайм-аутом.</target>
        </trans-unit>
        <trans-unit id="e54a6d62ec10ad64fad6d34ac9c7ea9e8f9d7cea" translate="yes" xml:space="preserve">
          <source>Wait for the event to be signaled without timeout.</source>
          <target state="translated">Дождитесь сигнала о событии без таймаута.</target>
        </trans-unit>
        <trans-unit id="2cb051846fa7c334adbe5b29a289c76659c70128" translate="yes" xml:space="preserve">
          <source>Wait for the pre-determined number of threads and then proceed.</source>
          <target state="translated">Дождитесь заранее заданного количества потоков,а затем продолжайте.</target>
        </trans-unit>
        <trans-unit id="d0970419de06465ae0edf094213021ffbd86ca8c" translate="yes" xml:space="preserve">
          <source>Wait until notified.</source>
          <target state="translated">Подожди,пока тебя не уведомят.</target>
        </trans-unit>
        <trans-unit id="0dc5e5e58f190ca8a04c28a46a3ca3a88bd55e67" translate="yes" xml:space="preserve">
          <source>Wait until room is available.</source>
          <target state="translated">Подождите,пока освободится место.</target>
        </trans-unit>
        <trans-unit id="1c463167f46a716a5b14ee22c6f2d6eefacb99a6" translate="yes" xml:space="preserve">
          <source>Wait until the current count is above zero, then atomically decrement the count by one and return.</source>
          <target state="translated">Дождитесь,пока текущий счетчик станет больше нуля,затем атоматически умножьте счет на единицу и вернитесь.</target>
        </trans-unit>
        <trans-unit id="80514bbd12242072fb7f4a1d006a0f9678d1c1b9" translate="yes" xml:space="preserve">
          <source>Waits for the process associated with &lt;code&gt;pid&lt;/code&gt; to terminate, and returns its exit status.</source>
          <target state="translated">Ожидает завершения процесса, связанного с &lt;code&gt;pid&lt;/code&gt; , и возвращает его состояние завершения.</target>
        </trans-unit>
        <trans-unit id="55b3defee5849fc459ec0c95440a420189307957" translate="yes" xml:space="preserve">
          <source>Waits for this thread to complete. If the thread terminated as the result of an unhandled exception, this exception will be rethrown.</source>
          <target state="translated">Ждет завершения этой нити.Если поток завершится в результате необработанного исключения,то это исключение будет сбрасываться заново.</target>
        </trans-unit>
        <trans-unit id="12fa1e2dd996c047a58f9ba7d2ce330199936585" translate="yes" xml:space="preserve">
          <source>Walter Bright</source>
          <target state="translated">Уолтер Брайт</target>
        </trans-unit>
        <trans-unit id="f522c8536ffcd82af51edfc249659512df045ba6" translate="yes" xml:space="preserve">
          <source>Walter Bright, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;http://www.digitalmars.com&lt;/a&gt;</source>
          <target state="translated">Уолтер Брайт, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;http://www.digitalmars.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7dd627604afd04b6f718c66c366c4eb696346e2" translate="yes" xml:space="preserve">
          <source>Walter Bright, Ernesto Castellotti</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3beee02a56826201b4e6b2b6c654d2bfeca83868" translate="yes" xml:space="preserve">
          <source>Walter Bright, Hauke Duden</source>
          <target state="translated">Уолтер Брайт,Хоук Дуден...</target>
        </trans-unit>
        <trans-unit id="5c0751740f1c6a65830f87cae86f0d0245266d3a" translate="yes" xml:space="preserve">
          <source>Walter Bright, Kenji Hara</source>
          <target state="translated">Уолтер Брайт,Кенджи Хара.</target>
        </trans-unit>
        <trans-unit id="e6586c02000f1a5a2c5731c61da55cbfe00bb69e" translate="yes" xml:space="preserve">
          <source>Walter Bright, Martin Nowak</source>
          <target state="translated">Уолтер Брайт,Мартин Новак</target>
        </trans-unit>
        <trans-unit id="f81568c929fce637f8dcc69599de31996dc7e100" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly</source>
          <target state="translated">Уолтер Брайт,Шон Келли...</target>
        </trans-unit>
        <trans-unit id="40965a02688bf098c2a388fb88729085eee06cb1" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Jeremy DeHaan</source>
          <target state="translated">Уолтер Брайт,Шон Келли,Джереми Де Хаан.</target>
        </trans-unit>
        <trans-unit id="c27d8204a1d5d67ca7d8a6317276e0e520bffe4d" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Martin Nowak</source>
          <target state="translated">Уолтер Брайт,Шон Келли,Мартин Новак...</target>
        </trans-unit>
        <trans-unit id="3d7a0c203ec613c391f709227322acbb01b99aef" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Martin Nowak, Jacob Carlborg</source>
          <target state="translated">Уолтер Брайт,Шон Келли,Мартин Новак,Джейкоб Карлборг...</target>
        </trans-unit>
        <trans-unit id="ff7b964fdcca96888f3d5a37168a6f2f95584013" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Steven Schveighoffer</source>
          <target state="translated">Уолтер Брайт,Шон Келли,Стивен Швайгхоффер...</target>
        </trans-unit>
        <trans-unit id="79a2afbbb171f6a4420b36b662391abfa68bfb53" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, the LDC team</source>
          <target state="translated">Уолтер Брайт,Шон Келли,команда LDC.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="585e372432dfe6f0fb6c193474b375e437143f90" translate="yes" xml:space="preserve">
          <source>Warning 1: If the result of &lt;code&gt;toUTFz&lt;/code&gt; equals &lt;code&gt;str.ptr&lt;/code&gt;, then if anything alters the character one past the end of &lt;code&gt;str&lt;/code&gt; (which is the &lt;code&gt;'\0'&lt;/code&gt; character terminating the string), then the string won't be zero-terminated anymore. The most likely scenarios for that are if you append to &lt;code&gt;str&lt;/code&gt; and no reallocation takes place or when &lt;code&gt;str&lt;/code&gt; is a slice of a larger array, and you alter the character in the larger array which is one character past the end of &lt;code&gt;str&lt;/code&gt;. Another case where it could occur would be if you had a mutable character array immediately after &lt;code&gt;str&lt;/code&gt; in memory (for example, if they're member variables in a user-defined type with one declared right after the other) and that character array happened to start with &lt;code&gt;'\0'&lt;/code&gt;. Such scenarios will never occur if you immediately use the zero-terminated string after calling &lt;code&gt;toUTFz&lt;/code&gt; and the C function using it doesn't keep a reference to it. Also, they are unlikely to occur even if you save the zero-terminated string (the cases above would be among the few examples of where it could happen). However, if you save the zero-terminate string and want to be absolutely certain that the string stays zero-terminated, then simply append a &lt;code&gt;'\0'&lt;/code&gt; to the string and use its &lt;code&gt;ptr&lt;/code&gt; property rather than calling &lt;code&gt;toUTFz&lt;/code&gt;.</source>
          <target state="translated">Предупреждение 1: Если результат &lt;code&gt;toUTFz&lt;/code&gt; равен &lt;code&gt;str.ptr&lt;/code&gt; , то если что-либо изменит символ на один конец после строки &lt;code&gt;str&lt;/code&gt; (то есть символ &lt;code&gt;'\0'&lt;/code&gt; заканчивающий строку), то строка больше не будет заканчиваться нулем , Наиболее вероятные сценарии для этого, если вы добавляете к &lt;code&gt;str&lt;/code&gt; и перераспределение не происходит, или когда &lt;code&gt;str&lt;/code&gt; является фрагментом большего массива, и вы изменяете символ в большем массиве, который находится на один символ после конца &lt;code&gt;str&lt;/code&gt; . Другой случай , когда это могло произойти если бы вы имели изменяемый массив символов сразу после того, как &lt;code&gt;str&lt;/code&gt; в памяти (например, если они являются переменными-членами в пользовательском типе, один из которых объявлен сразу после другого), и этот массив символов начинался с &lt;code&gt;'\0'&lt;/code&gt; . Такие сценарии никогда не произойдут, если вы сразу используете строку с нулевым символом в конце после вызова &lt;code&gt;toUTFz&lt;/code&gt; и функция C, использующая ее, не сохраняет ссылку на нее. Кроме того, они вряд ли произойдут, даже если вы сохраните строку с нулевым символом в конце (приведенные выше случаи будут одним из немногих примеров, где это может произойти). Однако, если вы сохраняете строку с нулевым символом в конце и хотите быть абсолютно уверены, что строка остается с нулевым символом в &lt;code&gt;toUTFz&lt;/code&gt; , тогда просто добавьте &lt;code&gt;'\0'&lt;/code&gt; к строке и используйте ее свойство &lt;code&gt;ptr&lt;/code&gt; вместо вызова toUTFz .</target>
        </trans-unit>
        <trans-unit id="6d5e6e458c5bbdf658e7836c9d3ff01a465d3f07" translate="yes" xml:space="preserve">
          <source>Warning 2: When passing a character pointer to a C function, and the C function keeps it around for any reason, make sure that you keep a reference to it in your D code. Otherwise, it may go away during a garbage collection cycle and cause a nasty bug when the C code tries to use it.</source>
          <target state="translated">Предупреждение 2:При передаче символьного указателя на функцию C,а функция C хранит его по любой причине,убедитесь,что вы сохранили ссылку на него в вашем D коде.В противном случае,она может исчезнуть во время цикла сбора мусора и вызвать неприятную ошибку,когда C-код попытается ее использовать.</target>
        </trans-unit>
        <trans-unit id="6223e4ea5d5725d8274391390c04b8667ffc6c34" translate="yes" xml:space="preserve">
          <source>Warning: All unmapped bits in the final word will be set to 0.</source>
          <target state="translated">Внимание:Все нераскрытые биты в последнем слове будут установлены на 0.</target>
        </trans-unit>
        <trans-unit id="acf91dcbe1badc99fc7381d39957a80e6a341170" translate="yes" xml:space="preserve">
          <source>Warning: Because &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is in hnsecs, whereas MonoTime is in system ticks, it's usually the case that this assertion will fail</source>
          <target state="translated">Предупреждение: поскольку &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; указан в hnsecs, а MonoTime - в системных тиках, обычно это утверждение не выполняется.</target>
        </trans-unit>
        <trans-unit id="27438780936e1340ac95e5da97a39dc3fbfd64bc" translate="yes" xml:space="preserve">
          <source>Warning: On some systems, the monotonic clock may stop counting when the computer goes to sleep or hibernates. So, the monotonic clock could be off if that occurs. This is known to happen on Mac OS X. It has not been tested whether it occurs on either Windows or on Linux.</source>
          <target state="translated">Внимание:На некоторых системах монотонные часы могут перестать отсчитываться,когда компьютер засыпает или впадает в спячку.Таким образом,монотонные часы могут быть выключены,если это произойдет.Известно,что это происходит на Mac OS X.Не было проверено,происходит ли это на Windows или на Linux.</target>
        </trans-unit>
        <trans-unit id="0e212f56c9e51d24ac52f320bb7b438cdfb95478" translate="yes" xml:space="preserve">
          <source>Warning: On some systems, the monotonic clock may stop counting when the computer goes to sleep or hibernates. So, the monotonic clock may indicate less time than has actually passed if that occurs. This is known to happen on Mac OS X. It has not been tested whether it occurs on either Windows or Linux.</source>
          <target state="translated">Внимание:На некоторых системах монотонные часы могут перестать отсчитываться,когда компьютер засыпает или впадает в спячку.Таким образом,монотонные часы могут указывать на меньшее время,чем прошло на самом деле,если это произойдет.Известно,что это происходит на Mac OS X.Не было проверено,происходит ли это на Windows или Linux.</target>
        </trans-unit>
        <trans-unit id="e46400427309b3b37f40efb471c7ac358834f3c4" translate="yes" xml:space="preserve">
          <source>Warning: Previously, &lt;a href=&quot;#toISOString&quot;&gt;&lt;code&gt;toISOString&lt;/code&gt;&lt;/a&gt; did the same as &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; and generated +HH:MM or -HH:MM for the time zone when it was not &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, which is not in conformance with ISO 8601 for the non-extended string format. This has now been fixed. However, for now, fromISOString will continue to accept the extended format for the time zone so that any code which has been writing out the result of toISOString to read in later will continue to work. The current behavior will be kept until July 2019 at which point, fromISOString will be fixed to be standards compliant.</source>
          <target state="translated">Предупреждение: Ранее &lt;a href=&quot;#toISOString&quot;&gt; &lt;code&gt;toISOString&lt;/code&gt; &lt;/a&gt; делал то же самое, что и &lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; ,&lt;/a&gt; и генерировал + ЧЧ: ММ или -ЧЧ: ММ для часового пояса, когда он не был &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; , что не соответствует с ISO 8601 для нерасширенного формата строки. Теперь это было исправлено. Однако на данный момент fromISOString продолжит принимать расширенный формат для часового пояса, так что любой код, записывающий результат toISOString для последующего чтения, продолжит работать. Текущее поведение будет сохраняться до июля 2019 года, после чего из ISOString будет установлено соответствие стандартам.</target>
        </trans-unit>
        <trans-unit id="d2fc166d407d5b89388cb65f2fea3db607a53956" translate="yes" xml:space="preserve">
          <source>Warning: Previously, toISOString did the same as &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; and generated +HH:MM or -HH:MM for the time zone when it was not &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, which is not in conformance with ISO 8601 for the non-extended string format. This has now been fixed. However, for now, fromISOString will continue to accept the extended format for the time zone so that any code which has been writing out the result of toISOString to read in later will continue to work. The current behavior will be kept until July 2019 at which point, fromISOString will be fixed to be standards compliant.</source>
          <target state="translated">Предупреждение: Ранее toISOString делал то же самое, что и &lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; ,&lt;/a&gt; и генерировал + HH: MM или -HH: MM для часового пояса, когда он не был &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; , что не соответствует с ISO 8601 для нерасширенного формата строки. Теперь это было исправлено. Однако на данный момент fromISOString продолжит принимать расширенный формат для часового пояса, так что любой код, записывающий результат toISOString для последующего чтения, продолжит работать. Текущее поведение будет сохраняться до июля 2019 года, после чего из ISOString будет установлено соответствие стандартам.</target>
        </trans-unit>
        <trans-unit id="fabcf756ccd01219ec37d730936c5b0173ea6da7" translate="yes" xml:space="preserve">
          <source>Warning: This field will be turned into a property in a future release.</source>
          <target state="translated">Внимание:Это поле будет превращено в свойство в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="c8c3b8d8de62f29d31349b08905db4c48193bfc9" translate="yes" xml:space="preserve">
          <source>Warning: This module is considered out-dated and not up to Phobos' current standards. It will be removed from Phobos in 2.101.0. If you still need it, go to &lt;a href=&quot;https://github.com/DigitalMars/undeaD&quot;&gt;https://github.com/DigitalMars/undeaD&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c031ade7f7344cefefb6b6bd54f1bb3fa16257" translate="yes" xml:space="preserve">
          <source>Warning: This module is considered out-dated and not up to Phobos' current standards. It will remain until we have a suitable replacement, but be aware that it will not remain long term.</source>
          <target state="translated">Внимание:Этот модуль считается устаревшим и не соответствует текущим стандартам Фобоса.Он останется до тех пор,пока мы не найдем подходящую замену,но имейте в виду,что он не останется надолго.</target>
        </trans-unit>
        <trans-unit id="92f5ff341e2b5afa18006c51adebb14319bc5d53" translate="yes" xml:space="preserve">
          <source>Warning: This trait will be deprecated as soon as it is no longer used in Phobos. For a function parameter to safely accept a type that implicitly converts to string as a string, the conversion needs to happen at the callsite; otherwise, the conversion is done inside the function, and in many cases, that means that local memory is sliced (e.g. if a static array is passed to the function, then it's copied, and the resulting dynamic array will be a slice of a local variable). So, if the resulting string escapes the function, the string refers to invalid memory, and accessing it would mean accessing invalid memory. As such, the only safe way for a function to accept types that implicitly convert to string is for the implicit conversion to be done at the callsite, and that can only occur if the parameter is explicitly typed as an array, whereas using isConvertibleToString in a template constraint would result in the conversion being done inside the function. As such, isConvertibleToString is inherently unsafe and is going to be deprecated.</source>
          <target state="translated">Внимание:Эта черта будет уничтожена,как только она перестанет использоваться в Фобос.Для того чтобы параметр функции безопасно принимал тип,который неявно преобразуется в строку,преобразование должно происходить на вызывающей стороне;в противном случае преобразование производится внутри функции,а во многих случаях это означает,что происходит нарезка локальной памяти (например,если в функцию передан статический массив,то он копируется,а результирующий динамический массив будет кусочком локальной переменной).Таким образом,если результирующая строка экранирует функцию,то она ссылается на некорректную память,и обращение к ней будет означать обращение к некорректной памяти.Таким образом,единственный безопасный способ для функции принимать типы,которые неявно преобразуются в строку,-это неявное преобразование,которое может произойти только в том случае,если параметр явно типизирован как массив,в то время как использование isConvertibleToString в шаблоне ограничения приведет к тому,что преобразование будет произведено внутри функции.Таким образом,isConvertibleToString по своей природе небезопасен и будет устаревшим.</target>
        </trans-unit>
        <trans-unit id="83b7f7c160db15d481480fd952b8bc681419f483" translate="yes" xml:space="preserve">
          <source>Warning: TickDuration will be deprecated in the near future (once all uses of it in Phobos have been deprecated). Please use &lt;a href=&quot;#MonoTime&quot;&gt;&lt;code&gt;MonoTime&lt;/code&gt;&lt;/a&gt; for the cases where a monotonic timestamp is needed and &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; when a duration is needed, rather than using TickDuration. It has been decided that TickDuration is too confusing (e.g. it conflates a monotonic timestamp and a duration in monotonic clock ticks) and that having multiple duration types is too awkward and confusing.</source>
          <target state="translated">Предупреждение: TickDuration будет объявлено устаревшим в ближайшем будущем (после того, как все его использование в Фобосе будет объявлено устаревшим). Пожалуйста, используйте &lt;a href=&quot;#MonoTime&quot;&gt; &lt;code&gt;MonoTime&lt;/code&gt; &lt;/a&gt; для случаев, когда требуется монотонная временная метка, и &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; ,&lt;/a&gt; когда требуется длительность, вместо использования TickDuration. Было решено, что TickDuration слишком запутанный (например, он объединяет монотонную метку времени и длительность в монотонных тиках часов) и что наличие нескольких типов длительности слишком неудобно и сбивает с толку.</target>
        </trans-unit>
        <trans-unit id="62b3979c53ffb9c47b3a7d545b258a9878ad87de" translate="yes" xml:space="preserve">
          <source>Warning: Using critical regions is extremely error-prone. For instance, using locks inside a critical region can easily result in a deadlock when another thread holding the lock already got suspended.</source>
          <target state="translated">Внимание:Использование критических областей крайне предрасположено к ошибкам.Например,использование замков внутри критической области может легко привести к блокировке,когда другой поток,удерживающий замок,уже был приостановлен.</target>
        </trans-unit>
        <trans-unit id="8f4c2b9f3e530a0a68edf252b1a344d7f8161a1d" translate="yes" xml:space="preserve">
          <source>Warning: unused bits in the final word up to the next word boundary may be overwritten by this operation. It does not attempt to preserve bits past the end of the array.</source>
          <target state="translated">Внимание:при выполнении данной операции могут быть перезаписаны неиспользуемые биты в последнем слове вплоть до границы следующего слова.Она не пытается сохранить биты,прошедшие через конец массива.</target>
        </trans-unit>
        <trans-unit id="9bdfd3329c5bbf822175cb2b67912d964b37f972" translate="yes" xml:space="preserve">
          <source>We can overload templates.</source>
          <target state="translated">Мы можем перегружать шаблоны.</target>
        </trans-unit>
        <trans-unit id="c6fdca2f98040562a3c5fb4c490c84d24c94cc09" translate="yes" xml:space="preserve">
          <source>We can use it in D code like:</source>
          <target state="translated">Мы можем использовать его в D-коде,как:</target>
        </trans-unit>
        <trans-unit id="507a3193c54b60247851a8ffa82864ffaffde25f" translate="yes" xml:space="preserve">
          <source>We need an opEquals for the struct if any fields has an opEquals. Generate one if a user-specified one does not exist.</source>
          <target state="translated">Нам нужен opEquals для структуры,если какие-либо поля имеют opEquals.Сгенерируйте его,если указанного пользователем не существует.</target>
        </trans-unit>
        <trans-unit id="68a72706eafc8d622298e3cdab30cee1fd24b9ba" translate="yes" xml:space="preserve">
          <source>We want the referrer field set automatically when following locations</source>
          <target state="translated">Мы хотим,чтобы поле перенаправления устанавливалось автоматически,когда следующие местоположения</target>
        </trans-unit>
        <trans-unit id="5fbe925d225346411e9eccfc0b0f243297559267" translate="yes" xml:space="preserve">
          <source>We've mistakenly parsed &lt;code&gt;t&lt;/code&gt; as a type. Redo &lt;code&gt;t&lt;/code&gt; as an Expression.</source>
          <target state="translated">Мы по ошибке проанализировали &lt;code&gt;t&lt;/code&gt; как тип. Повторить &lt;code&gt;t&lt;/code&gt; как выражение.</target>
        </trans-unit>
        <trans-unit id="845a99ed43b833e3f82d48703e30eb33f04bdd81" translate="yes" xml:space="preserve">
          <source>WeightsAA &lt;code&gt;weights&lt;/code&gt;</source>
          <target state="translated">ВесаAA &lt;code&gt;weights&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd3b500c5e4673ad9015a24bd46e94c7a25f4665" translate="yes" xml:space="preserve">
          <source>What happens for &lt;code&gt;pragma(inline, true)&lt;/code&gt; if the function cannot be inlined. An error message is typical.</source>
          <target state="translated">Что происходит с &lt;code&gt;pragma(inline, true)&lt;/code&gt; если функция не может быть встроенной. Сообщение об ошибке типично.</target>
        </trans-unit>
        <trans-unit id="adfcea932d1629853978a1cd226d5f3e53520b78" translate="yes" xml:space="preserve">
          <source>What kind of HTTP time condition to use, see defines</source>
          <target state="translated">Какое временное условие HTTP использовать,см.определения</target>
        </trans-unit>
        <trans-unit id="3eac45872ea1813c0c59c59b8e57b1a3dfaff419" translate="yes" xml:space="preserve">
          <source>What mutex is used is determined by the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;. If there is no &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, then a global mutex is created, one per such synchronized statement. Different synchronized statements will have different global mutexes.</source>
          <target state="translated">Какой мьютекс используется, определяется &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражением&lt;/i&gt;&lt;/a&gt; . Если нет &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;выражения&lt;/i&gt;&lt;/a&gt; , то создается глобальный мьютекс, по одному на каждый синхронизированный оператор. Различные синхронизированные операторы будут иметь разные глобальные мьютексы.</target>
        </trans-unit>
        <trans-unit id="3f00b0af3261ac469a497340912e30c3d784a1b3" translate="yes" xml:space="preserve">
          <source>What policy to use when closing connections when the cache is filled up</source>
          <target state="translated">Какую политику использовать при закрытии соединений,когда кэш заполнен</target>
        </trans-unit>
        <trans-unit id="a4ada23f9c4b1b5915da333f74d0432936b14fb5" translate="yes" xml:space="preserve">
          <source>What the string is expected for, will be used in error diagnostic.</source>
          <target state="translated">То,что ожидается от строки,будет использовано при диагностике ошибок.</target>
        </trans-unit>
        <trans-unit id="207bb42cfbbad5b0c396c2caf20bfb81dbfce9b3" translate="yes" xml:space="preserve">
          <source>What to look for.</source>
          <target state="translated">Что искать.</target>
        </trans-unit>
        <trans-unit id="6d65d283ddb2c53ef74d1eb3c0dd6bc21ff402bf" translate="yes" xml:space="preserve">
          <source>What type of clock to use with &lt;a href=&quot;#MonoTime&quot;&gt;&lt;code&gt;MonoTime&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;. They default to &lt;code&gt;ClockType.normal&lt;/code&gt;, and most programs do not need to ever deal with the others.</source>
          <target state="translated">Какой тип часов использовать с &lt;a href=&quot;#MonoTime&quot;&gt; &lt;code&gt;MonoTime&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; . По умолчанию они имеют значение &lt;code&gt;ClockType.normal&lt;/code&gt; , и большинству программ не нужно иметь дело с другими.</target>
        </trans-unit>
        <trans-unit id="146794bc552470dd1d6678ea93d3425d7b4f29e6" translate="yes" xml:space="preserve">
          <source>What values do a and b end up with, what order are the initializations executed in, what are the values of a and b before the initializations are run, is this a compile error, or is this a runtime error? Additional confusion comes from it not being obvious if an initializer is static or dynamic.</source>
          <target state="translated">Какими значениями заканчиваются a и b,в каком порядке выполняются инициализации,каковы значения a и b до запуска инициализаций,является ли это ошибкой компиляции,или это ошибка выполнения? Дополнительная путаница возникает из-за того,что не видно,является ли инициализатор статическим или динамическим.</target>
        </trans-unit>
        <trans-unit id="6b972ab83e5e7a76cfe2df1f21ebf933dc879011" translate="yes" xml:space="preserve">
          <source>What version to specifically try to use. See CURL_SSLVERSION defines below.</source>
          <target state="translated">Какую именно версию попробовать использовать.См.определение CURL_SSLVERSION ниже.</target>
        </trans-unit>
        <trans-unit id="a1b7a5c6bdddfaa0a24b075c10b5835662fd0054" translate="yes" xml:space="preserve">
          <source>What's needed is an error handling philosophy and methodology such that:</source>
          <target state="translated">Нужна такая философия и методология обработки ошибок:</target>
        </trans-unit>
        <trans-unit id="cfd1d82cce4f72aa99573e2ce4e60cfaf40ec308" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;BetterC&lt;/b&gt; is enabled, the predefined &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt;&lt;code&gt;D_BetterC&lt;/code&gt; can be used for conditional compilation.</source>
          <target state="translated">Когда &lt;b&gt;BetterC&lt;/b&gt; включен, предопределенная &lt;a href=&quot;version&quot;&gt;версия &lt;/a&gt; &lt;code&gt;D_BetterC&lt;/code&gt; может использоваться для условной компиляции.</target>
        </trans-unit>
        <trans-unit id="2292b06867d16283b44aae130a4f39b2ac042759" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; type, &lt;code&gt;Final&lt;/code&gt; aliases to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;immutable&lt;/code&gt; типа, &lt;code&gt;Final&lt;/code&gt; псевдонимы &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a49d575ee1d6e7e4bcca9be6bbf7c0477c415fa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;startingIndex&lt;/code&gt; is 0 the range will be fully iterated in order and in reverse order when &lt;code&gt;r.length&lt;/code&gt; is given.</source>
          <target state="translated">Когда &lt;code&gt;startingIndex&lt;/code&gt; &lt;code&gt;r.length&lt;/code&gt; равен 0, диапазон будет полностью повторяться по порядку и в обратном порядке, если задана длина r.length .</target>
        </trans-unit>
        <trans-unit id="5faf3ff2b29b975f2e5f9514d9470cfbe9751be7" translate="yes" xml:space="preserve">
          <source>When AA access requires that there must be a value corresponding to the key, a value must be constructed and inserted if not present. The &lt;code&gt;require&lt;/code&gt; function provides a means to construct a new value via a lazy argument. The lazy argument is evaluated when the key is not present. The &lt;code&gt;require&lt;/code&gt; operation avoids the need to perform multiple key lookups.</source>
          <target state="translated">Когда для доступа AA требуется наличие значения, соответствующего ключу, значение должно быть создано и вставлено, если оно отсутствует. Функция &lt;code&gt;require&lt;/code&gt; предоставляет средство для создания нового значения через ленивый аргумент. Ленивый аргумент вычисляется, когда ключ отсутствует. Операция &lt;code&gt;require&lt;/code&gt; избавляет от необходимости выполнять поиск нескольких ключей.</target>
        </trans-unit>
        <trans-unit id="58756d267efe5c990a7cc915f22119bb4ae5363b" translate="yes" xml:space="preserve">
          <source>When FTP over SSL/TLS is selected (with CURLOPT_USE_SSL), this option can be used to change libcurl's default action which is to first try &quot;AUTH SSL&quot; and then &quot;AUTH TLS&quot; in this order, and proceed when a OK response has been received.</source>
          <target state="translated">Когда выбрана опция FTP over SSL/TLS (с CURLOPT_USE_SSL),эта опция может быть использована для изменения действия по умолчанию libcurl,которое заключается в том,чтобы сначала попробовать &quot;AUTH SSL&quot;,а затем &quot;AUTH TLS&quot; в этом порядке,а затем продолжить,когда получен ответ &quot;OK&quot;.</target>
        </trans-unit>
        <trans-unit id="d4a7db22a0550dc78b003dc93c9145ff60875535" translate="yes" xml:space="preserve">
          <source>When T is mutable,</source>
          <target state="translated">Когда Т мутируется,</target>
        </trans-unit>
        <trans-unit id="5cf006f44400e65144d1b472f0ab8012be1c48f8" translate="yes" xml:space="preserve">
          <source>When UFCS rewrite is necessary, compiler searches the name on accessible module level scope, in order from the innermost scope.</source>
          <target state="translated">При необходимости перезаписи UFCS компилятор ищет имя в доступной области видимости на уровне модуля,по порядку из самой внутренней области видимости.</target>
        </trans-unit>
        <trans-unit id="a7f07e7fd86974cfaed2565e4135da3e593e6283" translate="yes" xml:space="preserve">
          <source>When UUIDs are generated by one of the defined mechanisms, they are either guaranteed to be unique, different from all other generated UUIDs (that is, it has never been generated before and it will never be generated again), or it is extremely likely to be unique (depending on the mechanism).</source>
          <target state="translated">Когда UUID-ы генерируются одним из определенных механизмов,они либо гарантированно являются уникальными,отличными от всех других генерируемых UUID-ов (т.е.никогда не генерировались и никогда не будут генерироваться снова),либо крайне вероятно,что они являются уникальными (в зависимости от механизма).</target>
        </trans-unit>
        <trans-unit id="3eca062b8fe1e4231ecb785a261c5bf72ebd25a3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Task&lt;/code&gt; that calls a delegate is being created and a closure cannot be allocated due to objects on the stack that have scoped destruction. The delegate overload of &lt;code&gt;scopedTask&lt;/code&gt; takes a &lt;code&gt;scope&lt;/code&gt; delegate.</source>
          <target state="translated">Когда создается &lt;code&gt;Task&lt;/code&gt; которая вызывает делегат, и закрытие не может быть выделено из-за объектов в стеке, которые имеют область уничтожения. Перегрузка делегата &lt;code&gt;scopedTask&lt;/code&gt; принимает делегата &lt;code&gt;scope&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b00afb911afc0a5ca26386b2a18ae6be85c2975e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Unique!T&lt;/code&gt; goes out of scope it will call &lt;code&gt;destroy&lt;/code&gt; on the resource &lt;code&gt;T&lt;/code&gt; that it manages, unless it is transferred. One important consequence of &lt;code&gt;destroy&lt;/code&gt; is that it will call the destructor of the resource &lt;code&gt;T&lt;/code&gt;. GC-managed references are not guaranteed to be valid during a destructor call, but other members of &lt;code&gt;T&lt;/code&gt;, such as file handles or pointers to &lt;code&gt;malloc&lt;/code&gt; memory, will still be valid during the destructor call. This allows the resource &lt;code&gt;T&lt;/code&gt; to deallocate or clean up any non-GC resources.</source>
          <target state="translated">Когда &lt;code&gt;Unique!T&lt;/code&gt; выходит из области видимости, он вызывает &lt;code&gt;destroy&lt;/code&gt; для ресурса &lt;code&gt;T&lt;/code&gt; , которым он управляет, если только он не передан. Одним из важных последствий &lt;code&gt;destroy&lt;/code&gt; является то , что он будет вызывать деструктор ресурса &lt;code&gt;T&lt;/code&gt; . Не гарантируется, что ссылки, управляемые GC, будут действительными во время вызова деструктора, но другие члены &lt;code&gt;T&lt;/code&gt; , такие как файловые дескрипторы или указатели на память &lt;code&gt;malloc&lt;/code&gt; , все еще будут действительны во время вызова деструктора. Это позволяет ресурсу &lt;code&gt;T&lt;/code&gt; освободить или очистить любые не-GC ресурсы.</target>
        </trans-unit>
        <trans-unit id="0b428ff9c922783f16405281044cf416efd51e62" translate="yes" xml:space="preserve">
          <source>When a chunk of memory is requested, the allocator finds a range of virtual pages that satisfy the requested size, changing their protection to read/write using OS primitives (&lt;code&gt;mprotect&lt;/code&gt; and &lt;code&gt;VirtualProtect&lt;/code&gt;, respectively). The physical memory is allocated on demand, when the pages are accessed.</source>
          <target state="translated">Когда запрашивается кусок памяти, распределитель находит диапазон виртуальных страниц, которые удовлетворяют запрошенному размеру, изменяя их защиту для чтения / записи с использованием примитивов ОС ( &lt;code&gt;mprotect&lt;/code&gt; и &lt;code&gt;VirtualProtect&lt;/code&gt; , соответственно). Физическая память выделяется по требованию при обращении к страницам.</target>
        </trans-unit>
        <trans-unit id="84377709681ba4d9986310ee001bee93cd56cf23" translate="yes" xml:space="preserve">
          <source>When a copy constructor is defined for a &lt;code&gt;struct&lt;/code&gt; (or marked &lt;code&gt;@disable&lt;/code&gt;), the compiler no longer implicitly generates default copy/blitting constructors for that &lt;code&gt;struct&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58597b4b6cb332bd69f504c1f00c607c0eb16bbc" translate="yes" xml:space="preserve">
          <source>When a copy constructor is defined for a &lt;code&gt;struct&lt;/code&gt;, all implicit blitting is disabled for that &lt;code&gt;struct&lt;/code&gt;:</source>
          <target state="translated">Когда для &lt;code&gt;struct&lt;/code&gt; определен конструктор копирования , все неявные блики для этой &lt;code&gt;struct&lt;/code&gt; отключаются :</target>
        </trans-unit>
        <trans-unit id="0a331d1a65f7b110b5273b5d7868371d3b08b9ac" translate="yes" xml:space="preserve">
          <source>When a header is provided but a matching column is not found</source>
          <target state="translated">Когда заголовок предоставлен,но соответствующий столбец не найден.</target>
        </trans-unit>
        <trans-unit id="b0b45f354df73daafacbfa28c4412f42f9090d16" translate="yes" xml:space="preserve">
          <source>When a non-static nested class is instantiated, the context pointer is assigned before the class's constructor is called, therefore the constructor has full access to the enclosing variables. A non-static nested class can only be instantiated when the necessary context pointer information is available:</source>
          <target state="translated">Когда инстанцируется нестатический вложенный класс,перед вызовом конструктора класса присваивается контекстный указатель,поэтому конструктор имеет полный доступ к закрывающим переменным.Нестатический вложенный класс может быть инстанциирован только при наличии необходимой информации по контекстному указателю:</target>
        </trans-unit>
        <trans-unit id="ef920e26f90cd5a47576ce324fd1771288bcca86" translate="yes" xml:space="preserve">
          <source>When a parameter is passed by value to a function:</source>
          <target state="translated">Когда параметр передается по значению в функцию:</target>
        </trans-unit>
        <trans-unit id="c61c979210ecf2e4589b54627f634e1037a8ddad" translate="yes" xml:space="preserve">
          <source>When a parameter is returned by value from a function and Named Returned Value Optiomization (NRVO) cannot be performed:</source>
          <target state="translated">Когда параметр возвращается по значению из функции,и оптиомизация по имени возвращаемого значения (NRVO)не может быть выполнена:</target>
        </trans-unit>
        <trans-unit id="bad8777ba790b6e52988c8133c63b2e65339ddbd" translate="yes" xml:space="preserve">
          <source>When a pointer to</source>
          <target state="translated">Когда указатель на</target>
        </trans-unit>
        <trans-unit id="1e0b2ba65ca51f0167b76facd54366bc0400933e" translate="yes" xml:space="preserve">
          <source>When a scope class reference goes out of scope, the destructor (if any) for it is automatically called. This holds true even if the scope was exited via a thrown exception.</source>
          <target state="translated">Когда ссылка на класс scope выходит за пределы области видимости,автоматически вызывается деструктор (если таковой имеется)для него.Это справедливо даже в том случае,если область видимости была закрыта с помощью брошенного исключения.</target>
        </trans-unit>
        <trans-unit id="b6bb469f2736e5b29050178fdbb45f42be341bd3" translate="yes" xml:space="preserve">
          <source>When a socket is blocking, calls to receive(), accept(), and send() will block and wait for data/action. A non-blocking socket will immediately return instead of blocking.</source>
          <target state="translated">Когда сокет блокируется,вызовы функций receive(),accept()и send()будут блокировать и ждать данных/действия.Неблокирующий сокет немедленно вернется вместо блокировки.</target>
        </trans-unit>
        <trans-unit id="5af91437874803519acee62d5c577c0e8cbfe57c" translate="yes" xml:space="preserve">
          <source>When a symbol name is used unqualified, a two-phase lookup is used. First, the module scope is searched, starting from the innermost scope. For example, in the previous example, while looking for &lt;code&gt;writeln&lt;/code&gt;, the order will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53589a36e302415933b16ff556ec6d4fa213d853" translate="yes" xml:space="preserve">
          <source>When a symbol name is used unqualified, a two-phase lookup will happen. First, the module scope will be searched, starting from the innermost scope. For example, in the previous example, while looking for &lt;code&gt;writeln&lt;/code&gt;, the order will be:</source>
          <target state="translated">Когда имя символа используется без оговорок, произойдет двухфазный поиск. Сначала ищется область модуля, начиная с самой внутренней области. Например, в предыдущем примере при поиске &lt;code&gt;writeln&lt;/code&gt; порядок будет следующим:</target>
        </trans-unit>
        <trans-unit id="25a09fb47990dfe5a4bac049451c12fdc1522cc8" translate="yes" xml:space="preserve">
          <source>When a variable is explicitly initialized:</source>
          <target state="translated">Когда переменная инициализируется явно:</target>
        </trans-unit>
        <trans-unit id="e356d7a1b95eac6faf7fe7ab10b40256f67e5d27" translate="yes" xml:space="preserve">
          <source>When an AA indexing access appears on the left side of an assignment operator, it is specially handled for setting an AA entry associated with the key.</source>
          <target state="translated">Когда доступ к индексированию AA появляется с левой стороны оператора назначения,он специально обрабатывается для установки записи AA,связанной с ключом.</target>
        </trans-unit>
        <trans-unit id="847c3c4e979270acfa06a799f042c78559833b79" translate="yes" xml:space="preserve">
          <source>When an input contains a header the &lt;code&gt;Contents&lt;/code&gt; can be specified as an associative array. Passing null to signify that a header is present.</source>
          <target state="translated">Когда вход содержит заголовок, &lt;code&gt;Contents&lt;/code&gt; может быть указано как ассоциативный массив. Передача null, чтобы указать, что заголовок присутствует.</target>
        </trans-unit>
        <trans-unit id="0d733d6c910f9784e16ad4aef1338d80a037f29e" translate="yes" xml:space="preserve">
          <source>When an instance of a struct is created, the following steps happen:</source>
          <target state="translated">Когда создается экземпляр структуры,выполняются следующие шаги:</target>
        </trans-unit>
        <trans-unit id="f9b07f7bbc9886fac959cdee6dc7290b9a45d6c3" translate="yes" xml:space="preserve">
          <source>When an output range's &lt;code&gt;put&lt;/code&gt; method only accepts elements of type &lt;code&gt;T&lt;/code&gt;, use the global &lt;code&gt;put&lt;/code&gt; to handle outputting a &lt;code&gt;T[]&lt;/code&gt; to the range or vice-versa.</source>
          <target state="translated">Когда метод &lt;code&gt;put&lt;/code&gt; выходного диапазона принимает только элементы типа &lt;code&gt;T&lt;/code&gt; , используйте глобальный &lt;code&gt;put&lt;/code&gt; для обработки вывода &lt;code&gt;T[]&lt;/code&gt; в диапазон или наоборот.</target>
        </trans-unit>
        <trans-unit id="b0d460e664066b93100c6efcc10898f6bcea3cee" translate="yes" xml:space="preserve">
          <source>When any &lt;a href=&quot;std_range&quot;&gt;range&lt;/a&gt; can be passed as an argument to a member function, the documention usually refers to the parameter's templated type as &lt;code&gt;Stuff&lt;/code&gt;.</source>
          <target state="translated">Когда любой &lt;a href=&quot;std_range&quot;&gt;диапазон&lt;/a&gt; может быть передан в качестве аргумента функции-члену, документация обычно ссылается на шаблонный тип параметра как &lt;code&gt;Stuff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e035b70c43ed4b954c78ad9443d2b0b366cee1c" translate="yes" xml:space="preserve">
          <source>When array literals are cast to another array type, each element of the array is cast to the new element type. When arrays that are not literals are cast, the array is reinterpreted as the new type, and the length is recomputed:</source>
          <target state="translated">При приведении литералов массива к другому типу массива каждый элемент массива приводится к новому типу элемента.При приведении массивов,не являющихся литералами,массив заново интерпретируется как новый тип,а длина пересчитывается:</target>
        </trans-unit>
        <trans-unit id="8bc694b68085959ea8d163c5c30c93a25f539782" translate="yes" xml:space="preserve">
          <source>When called on a &lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt; will unpack the value contained in the &lt;code&gt;Nullable&lt;/code&gt;, pass it to the function you provide and wrap the result in another &lt;code&gt;Nullable&lt;/code&gt; (if necessary). If the &lt;code&gt;Nullable&lt;/code&gt; is null, &lt;code&gt;apply&lt;/code&gt; will return null itself.</source>
          <target state="translated">При вызове для &lt;code&gt;Nullable&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; распакует значение, содержащееся в &lt;code&gt;Nullable&lt;/code&gt; , передаст его функции, которую вы предоставили, и обернет результат в другой &lt;code&gt;Nullable&lt;/code&gt; (при необходимости). Если &lt;code&gt;Nullable&lt;/code&gt; имеет значение null, &lt;code&gt;apply&lt;/code&gt; возвращает саму null.</target>
        </trans-unit>
        <trans-unit id="dc1515373d01db08ef2117bb4defaff339297545" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;recurrence&lt;/code&gt;, the function that computes the next value is specified as a template argument, and the initial values in the recurrence are passed as regular arguments. For example, in a Fibonacci sequence, there are two initial values (and therefore a state size of 2) because computing the next Fibonacci value needs the past two values.</source>
          <target state="translated">При вызове &lt;code&gt;recurrence&lt;/code&gt; функция, которая вычисляет следующее значение, указывается в качестве аргумента шаблона, а начальные значения в повторении передаются как обычные аргументы. Например, в последовательности Фибоначчи есть два начальных значения (и, следовательно, размер состояния 2), потому что для вычисления следующего значения Фибоначчи нужны два последних значения.</target>
        </trans-unit>
        <trans-unit id="18b07986b7a6997aa1e86f263e6c86015fef29b1" translate="yes" xml:space="preserve">
          <source>When comparing with &lt;a href=&quot;function#nested&quot;&gt;nested functions&lt;/a&gt;, the &lt;code&gt;function&lt;/code&gt; form is analogous to static or non-nested functions, and the &lt;code&gt;delegate&lt;/code&gt; form is analogous to non-static nested functions. In other words, a delegate literal can access stack variables in its enclosing function, a function literal cannot.</source>
          <target state="translated">При сравнении с &lt;a href=&quot;function#nested&quot;&gt;вложенными функциями&lt;/a&gt; , то &lt;code&gt;function&lt;/code&gt; форма аналогична статическим или невложенными функциями, а &lt;code&gt;delegate&lt;/code&gt; форма аналогична нестатическими вложенными функциями. Другими словами, литерал делегата может обращаться к переменным стека в своей функции включения, а литерал функции - нет.</target>
        </trans-unit>
        <trans-unit id="fd9f348ed0f84700657f1faa1882de97c9d5f215" translate="yes" xml:space="preserve">
          <source>When compiled and run, it will produce the message:</source>
          <target state="translated">При компиляции и запуске он выдаст сообщение:</target>
        </trans-unit>
        <trans-unit id="5c8b8502e98bd1b0e213cd0332618f47d50bedee" translate="yes" xml:space="preserve">
          <source>When compiled with debug mode, this function performs an extra check to make sure the return value is a valid Unicode string.</source>
          <target state="translated">При компиляции в отладочном режиме эта функция выполняет дополнительную проверку,чтобы убедиться,что возвращаемое значение является действительной строкой Юникода.</target>
        </trans-unit>
        <trans-unit id="cd356cab928423e5fd67844fa0607a2ecaf98686" translate="yes" xml:space="preserve">
          <source>When compiling for release, the invariant code is not generated, and the compiled program runs at maximum speed. The compiler is free to assume the invariant holds true, regardless of whether code is generated for it or not, and may optimize code accordingly.</source>
          <target state="translated">При компиляции для релиза инвариантный код не генерируется,а скомпилированная программа работает с максимальной скоростью.Компилятор вольен считать,что инвариант верен,независимо от того,генерируется для него код или нет,и может соответствующим образом оптимизировать код.</target>
        </trans-unit>
        <trans-unit id="f10c0d6014f2fa95b1f233b08b48cbc3b9a32b36" translate="yes" xml:space="preserve">
          <source>When compiling the application remember to link with the required libraries, in this case the Foundation framework. Example:</source>
          <target state="translated">При компиляции приложения не забудьте установить связь с нужными библиотеками,в данном случае с фреймворком Foundation.Пример:</target>
        </trans-unit>
        <trans-unit id="b62e9a626abd9a9fe60a81c2acd8e6a6e782d60a" translate="yes" xml:space="preserve">
          <source>When considering matches, a class is considered to be a match for any super classes or interfaces:</source>
          <target state="translated">При рассмотрении совпадений,класс считается совпадением для любых супер классов или интерфейсов:</target>
        </trans-unit>
        <trans-unit id="25e7aea40035f2392fc028cbab809dceedddf2af" translate="yes" xml:space="preserve">
          <source>When converting strings to numeric types, note that the D hexadecimal and binary literals are not handled. Neither the prefixes that indicate the base, nor the horizontal bar used to separate groups of digits are recognized. This also applies to the suffixes that indicate the type.  To work around this, you can specify a radix for conversions involving numbers.</source>
          <target state="translated">При преобразовании строк в числовые типы обратите внимание,что шестнадцатеричные и двоичные литералы D не обрабатываются.Не распознаются ни префиксы,указывающие на базу,ни горизонтальная полоса,используемая для разделения групп цифр.Это также относится к суффиксам,обозначающим тип.Для работы с этим можно задать радиус для преобразований с участием чисел.</target>
        </trans-unit>
        <trans-unit id="f20f2f5dc05d757ab38fb9ae4891dd9fae63b55d" translate="yes" xml:space="preserve">
          <source>When creating a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, use &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; for the negative option. When using a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, compare it against &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; or just &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">При создании значения типа &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; используйте &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; для отрицательного параметра. При использовании значения типа &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; сравните его с &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; или просто &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75b62a7e29426c0ff497e198ae5a3aa4814c266f" translate="yes" xml:space="preserve">
          <source>When creating a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, use &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt; for the affirmative option. When using a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, compare it against &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt;.</source>
          <target state="translated">При создании значения типа &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; используйте &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt; для утвердительной опции. При использовании значения типа &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; сравните его со значением &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5052cdcf10ea7a59ad8fcab69f469387e38a545c" translate="yes" xml:space="preserve">
          <source>When defining a Scheduler, an instance of this struct must be associated with each logical thread. It contains all implementation-level information needed by the internal API.</source>
          <target state="translated">При определении планировщика экземпляр этой структуры должен быть связан с каждым логическим потоком.Он содержит всю информацию уровня реализации,необходимую внутреннему API.</target>
        </trans-unit>
        <trans-unit id="a5cd9eef8c2bc9dbecfebdd3358b5fd51424da8d" translate="yes" xml:space="preserve">
          <source>When e is trivial and alwaysCopy == false, e itself is returned. Otherwise, a new VarExp is returned.</source>
          <target state="translated">Когда e тривиален и всегдаCopy ==false,возвращается сама e.В противном случае возвращается новый VarExp.</target>
        </trans-unit>
        <trans-unit id="1714fad4c54ea032f644bd0ff2725ffe944cc8e9" translate="yes" xml:space="preserve">
          <source>When examining a data structure or interface, it is very helpful to be able to easily tell which data can be expected to not change, which data might change, and who may change that data. This is done with the aid of the language typing system. Data can be marked as const or immutable, with the default being changeable (or</source>
          <target state="translated">При изучении структуры данных или интерфейса очень полезно иметь возможность легко определить,от каких данных можно ожидать,что они не изменятся,какие данные могут измениться и кто может изменить эти данные.Это делается с помощью системы языковых наборов.Данные могут быть помечены как const или immutable,по умолчанию они могут быть изменены (или</target>
        </trans-unit>
        <trans-unit id="0859e008a01c747e02b607536b15fa5d79c1fdcb" translate="yes" xml:space="preserve">
          <source>When getting the size of a member, it is not necessary for there to be a</source>
          <target state="translated">При получении размера члена,нет необходимости в том,чтобы там был</target>
        </trans-unit>
        <trans-unit id="814983e81354978a67ed413c94e9b7b6f637709d" translate="yes" xml:space="preserve">
          <source>When indexing and slicing an array, an out of bounds access will cause a runtime error, in order to prevent undefined behavior.</source>
          <target state="translated">При индексации и разрезании массива доступ вне пределов доступа приведет к ошибке во время выполнения,чтобы предотвратить неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="fc7c4dad5ca2cb8b81db522d7ceba34b23bb3cfe" translate="yes" xml:space="preserve">
          <source>When inheriting from &lt;code&gt;MultiLogger&lt;/code&gt; this member can be used to gain access to the stored &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">При наследовании от &lt;code&gt;MultiLogger&lt;/code&gt; этот член может использоваться для получения доступа к сохраненному &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b86472ecfbd7bd8b1de11ab8c34dee4b76f1d70d" translate="yes" xml:space="preserve">
          <source>When laying out a struct to match an externally defined layout, use align attributes to describe an exact match. Using a &lt;a href=&quot;version#static-assert&quot;&gt;Static Assert&lt;/a&gt; to ensure the result is as expected.</source>
          <target state="translated">При размещении структуры для соответствия внешне определенному макету используйте атрибуты выравнивания для описания точного соответствия. Использование &lt;a href=&quot;version#static-assert&quot;&gt;статического&lt;/a&gt; утверждения для обеспечения ожидаемого результата.</target>
        </trans-unit>
        <trans-unit id="c69f0de2afd3d5bd4cbff71a6a8b6010bba89573" translate="yes" xml:space="preserve">
          <source>When moving a struct instance, the compiler emits a call to this function after blitting the instance and before releasing the original instance's memory.</source>
          <target state="translated">При перемещении экземпляра структуры компилятор вызывает эту функцию после размывания экземпляра и перед освобождением памяти исходного экземпляра.</target>
        </trans-unit>
        <trans-unit id="25749d61a1b645ecb81cf7a527d2528e8b1112d5" translate="yes" xml:space="preserve">
          <source>When no delimiter is provided, strings are split into an array of words, using whitespace as delimiter. Runs of whitespace are merged together (no empty words are produced).</source>
          <target state="translated">Когда разделитель не предусмотрен,строки разбиваются на массив слов,используя в качестве разделителя пробельные символы.Пробельные символы сливаются вместе (пустые слова не создаются).</target>
        </trans-unit>
        <trans-unit id="c4c9890957dc3d440a6789767a520a3402a9a5c4" translate="yes" xml:space="preserve">
          <source>When one memory location is accessible with two different types, that aliasing is considered safe in these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24002fe90670fbadfc9a04fb282387881cb74bb4" translate="yes" xml:space="preserve">
          <source>When passing a string with unicode modifiers on characters, such as &lt;code&gt;\u0301&lt;/code&gt;, this function will not properly keep the position of the modifier. For example, reversing &lt;code&gt;ba\u0301d&lt;/code&gt; (&quot;b&amp;aacute;d&quot;) will result in d\u0301ab (&quot;d́ab&quot;) instead of &lt;code&gt;da\u0301b&lt;/code&gt; (&quot;d&amp;aacute;b&quot;).</source>
          <target state="translated">При передаче строки с модификаторами &lt;code&gt;\u0301&lt;/code&gt; на символы, такие как \ u0301 , эта функция не будет правильно сохранять позицию модификатора. Например, изменение &lt;code&gt;ba\u0301d&lt;/code&gt; (&quot;b&amp;aacute;d&quot;) приведет к d \ u0301ab (&quot;d́ab&quot;) вместо &lt;code&gt;da\u0301b&lt;/code&gt; (&quot;d&amp;aacute;b&quot;).</target>
        </trans-unit>
        <trans-unit id="4594bf9ec9e481a017a23a91d52669a9aa1fb686" translate="yes" xml:space="preserve">
          <source>When performing type conversions, &lt;a href=&quot;std_conv#ConvException&quot;&gt;&lt;code&gt;std.conv.ConvException&lt;/code&gt;&lt;/a&gt; is stored in the &lt;code&gt;next&lt;/code&gt; field.</source>
          <target state="translated">При выполнении преобразования &lt;a href=&quot;std_conv#ConvException&quot;&gt; &lt;code&gt;std.conv.ConvException&lt;/code&gt; &lt;/a&gt; в &lt;code&gt;next&lt;/code&gt; поле сохраняется исключение std.conv.ConvException .</target>
        </trans-unit>
        <trans-unit id="d930594f828ce102df70231e080c643ae6db4dfc" translate="yes" xml:space="preserve">
          <source>When reading data from an external source (like a file) written in a different endian format.</source>
          <target state="translated">При чтении данных из внешнего источника (например,файла),записанных в другом эндианском формате.</target>
        </trans-unit>
        <trans-unit id="4a9a422bd912cb28217d65422e937a7368680e06" translate="yes" xml:space="preserve">
          <source>When reading or writing individual bytes of a multibyte type like &lt;code&gt;long&lt;/code&gt;s or &lt;code&gt;double&lt;/code&gt;s.</source>
          <target state="translated">При чтении или записи отдельных байтов многобайтового типа, таких как &lt;code&gt;long&lt;/code&gt; s или &lt;code&gt;double&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="45de4a8a712e00f9f4a3855141e4d0d235915b3d" translate="yes" xml:space="preserve">
          <source>When renaming and selective importing are combined:</source>
          <target state="translated">При совмещении переименования и селективного импорта:</target>
        </trans-unit>
        <trans-unit id="7cadeab2e49ad72e63d768db3fcadd9c0cd9f7e7" translate="yes" xml:space="preserve">
          <source>When representing data, the nature of that data is generally symbolic as opposed to some other kind of data (for example, visual).</source>
          <target state="translated">При представлении данных характер этих данных,как правило,носит символический характер в отличие от некоторых других видов данных (например,визуальных).</target>
        </trans-unit>
        <trans-unit id="938265349267329f2acf92b42b29485438eaaf7b" translate="yes" xml:space="preserve">
          <source>When set to &quot;&quot;, parameters to array and associative array receivers are treated as an individual argument. That is, only one argument is appended or inserted per appearance of the option switch. If &lt;code&gt;arraySep&lt;/code&gt; is set to something else, then each parameter is first split by the separator, and the individual pieces are treated as arguments to the same option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80aa4a5b53887e0378b7c0557a102bb741248b2a" translate="yes" xml:space="preserve">
          <source>When talking about function parameters, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb193fda02d3c450532e2c4ed3ce35d59b4da16c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;maxSize&lt;/code&gt; parameter is specified, memoize will used a fixed size hash table to limit the number of cached entries.</source>
          <target state="translated">Если &lt;code&gt;maxSize&lt;/code&gt; параметр maxSize , memoize будет использовать хеш-таблицу фиксированного размера, чтобы ограничить количество кэшируемых записей.</target>
        </trans-unit>
        <trans-unit id="28be91897a1b828d9ca3bf3d37a260c8b80f7f1c" translate="yes" xml:space="preserve">
          <source>When the app thinks there's data available for curl it calls this function to read/write whatever there is right now. This returns as soon as the reads and writes are done. This function does not require that there actually is data available for reading or that data can be written, it can be called just in case. It returns the number of handles that still transfer data in the second argument's integer-pointer.</source>
          <target state="translated">Когда приложение думает,что есть данные,доступные для скручивания,оно вызывает эту функцию для чтения/записи того,что есть в данный момент.Это возвращается сразу после завершения чтения и записи.Эта функция не требует,чтобы данные действительно были доступны для чтения или чтобы данные могли быть записаны,она может быть вызвана на всякий случай.Она возвращает количество дескрипторов,которые все еще передают данные в целочисленном указателе второго аргумента.</target>
        </trans-unit>
        <trans-unit id="e0b14f32551259767f4a30407e0fff8e38d4bb8d" translate="yes" xml:space="preserve">
          <source>When the compiler sees a call to a method with Objective-C linkage it will generate a call similar to how an Objective-C compiler would call the method.</source>
          <target state="translated">Когда компилятор видит вызов метода со связью Objective-C,он генерирует вызов,аналогичный тому,как компилятор Objective-C вызывал бы этот метод.</target>
        </trans-unit>
        <trans-unit id="83c1e44b83f0f40840e69797d87e16b92208f380" translate="yes" xml:space="preserve">
          <source>When the data to be compressed doesn't fit in one buffer, use &lt;a href=&quot;#Compress&quot;&gt;&lt;code&gt;Compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#UnCompress&quot;&gt;&lt;code&gt;UnCompress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если данные для сжатия не помещаются в один буфер, используйте &lt;a href=&quot;#Compress&quot;&gt; &lt;code&gt;Compress&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#UnCompress&quot;&gt; &lt;code&gt;UnCompress&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="896539fdc3e45dd59ef48e379f0327b9c5844901" translate="yes" xml:space="preserve">
          <source>When the environment variable version is used, the path won't be modified if the environment variable doesn't exist or it is empty. When the database version is used, the path won't be modified if the user doesn't exist in the database or there is not enough memory to perform the query.</source>
          <target state="translated">При использовании версии переменной окружения путь не будет изменен,если переменная окружения не существует или пуста.При использовании версии для БД путь не будет изменен,если пользователь не существует в БД или не хватает памяти для выполнения запроса.</target>
        </trans-unit>
        <trans-unit id="7c65129fadefc530bc417ed6acb8a69dec4764f6" translate="yes" xml:space="preserve">
          <source>When the fallback type is different from the Nullable type, &lt;code&gt;get(T)&lt;/code&gt; returns the common type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb534bd82a0cc54777be5e4326d6be4e7a12f475" translate="yes" xml:space="preserve">
          <source>When the owner of the graph is no longer needed, then the graph of memory objects it points to is no longer needed and can be safely disposed of. If the owner itself is no longer in use (i.e. is no longer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2705f8c4f5d477062e59510ed5eeb511cc61cb" translate="yes" xml:space="preserve">
          <source>When the sequence is a</source>
          <target state="translated">Когда последовательность представляет собой</target>
        </trans-unit>
        <trans-unit id="0309591ed6bc783d05be62ec41369ee1fb439157" translate="yes" xml:space="preserve">
          <source>When the slice operator appears as the left-hand side of an assignment expression, it means that the contents of the array are the target of the assignment rather than a reference to the array. Array copying happens when the left-hand side is a slice, and the right-hand side is an array of or pointer to the same type.</source>
          <target state="translated">Когда в качестве левой стороны выражения присваивания появляется оператор среза,это означает,что содержимое массива является целью присваивания,а не ссылкой на массив.Копирование массива происходит,когда левая сторона является срезом,а правая-массивом или указателем на один и тот же тип.</target>
        </trans-unit>
        <trans-unit id="0d0158e3bfad8163fe4d771bd25fbc541f126c32" translate="yes" xml:space="preserve">
          <source>When the template parameters must be deduced, the eponymous members can't rely on a &lt;a href=&quot;version#StaticIfCondition&quot;&gt;&lt;code&gt;static if&lt;/code&gt;&lt;/a&gt; condition since the deduction relies on how the in members are used:</source>
          <target state="translated">Когда параметры шаблона должны быть выведены, одноименные члены не могут полагаться на &lt;a href=&quot;version#StaticIfCondition&quot;&gt; &lt;code&gt;static if&lt;/code&gt; &lt;/a&gt; условие if, поскольку вычет зависит от того, как используются элементы in:</target>
        </trans-unit>
        <trans-unit id="18a1489da8628a0eecf26996d6a9104fb7ace293" translate="yes" xml:space="preserve">
          <source>When the threads in the global task pool are waiting on a synchronization primitive (for example a mutex), and you want to parallelize the code that needs to run before these threads can be resumed.</source>
          <target state="translated">Когда потоки в глобальном пуле задач ждут примитива синхронизации (например,мьютекса),и вы хотите распараллелить код,который должен быть запущен до того,как эти потоки могут быть возобновлены.</target>
        </trans-unit>
        <trans-unit id="234c7c2ced27e46dbe44f8c1d3b942116be5d1ba" translate="yes" xml:space="preserve">
          <source>When the value that is returned by this function is destroyed, &lt;code&gt;func&lt;/code&gt; will run. &lt;code&gt;func&lt;/code&gt; is a unary function that takes a &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда значение, возвращаемое этой функцией, уничтожается, запускается &lt;code&gt;func&lt;/code&gt; . &lt;code&gt;func&lt;/code&gt; - это унарная функция, которая принимает &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3712c7b591b91ff3f87d8d90ad3ede3c54ffd11" translate="yes" xml:space="preserve">
          <source>When the virtual-table mechanism stabilizes, we will declare the interface fixed, support it indefinitely, and remove this comment.</source>
          <target state="translated">Когда механизм виртуального стола стабилизируется,мы объявим интерфейс исправленным,будем поддерживать его бесконечно и удалим этот комментарий.</target>
        </trans-unit>
        <trans-unit id="a3cf6901b7b4052fec7ad41737841bcba23193f0" translate="yes" xml:space="preserve">
          <source>When there are more than two ranges, the above conditions apply to each adjacent pair of ranges.</source>
          <target state="translated">Когда существует более двух диапазонов,вышеуказанные условия применяются к каждой смежной паре диапазонов.</target>
        </trans-unit>
        <trans-unit id="d07dc7e0a2ca5375f8d0e4ada71ece6299c4ea8d" translate="yes" xml:space="preserve">
          <source>When this function returns true, &lt;code&gt;checkValue()&lt;/code&gt; should also return true.</source>
          <target state="translated">Когда эта функция возвращает true, &lt;code&gt;checkValue()&lt;/code&gt; также должна возвращать true.</target>
        </trans-unit>
        <trans-unit id="0e32a64dc0a978025c37a0920a24a143d7cf1416" translate="yes" xml:space="preserve">
          <source>When transversed, the elements of a range of ranges are assumed to have different lengths (e.g. a jagged array).</source>
          <target state="translated">В поперечном направлении предполагается,что элементы диапазона имеют разную длину (например,зазубренный массив).</target>
        </trans-unit>
        <trans-unit id="216d54ab44b92631e631f27e0f2e599194972d30" translate="yes" xml:space="preserve">
          <source>When unit tests are enabled, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;unittest&lt;/code&gt; is predefined.</source>
          <target state="translated">Когда модульные тесты включены, &lt;a href=&quot;version#PredefinedVersions&quot;&gt;идентификатор версии &lt;/a&gt; &lt;code&gt;unittest&lt;/code&gt; предопределен.</target>
        </trans-unit>
        <trans-unit id="13ccf60a3ee5316c31b6b5b537a534e41d39ff06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Array&lt;/code&gt; with range-based functions like those in &lt;code&gt;std.algorithm&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; must be sliced to get a range (for example, use &lt;code&gt;array[].map!&lt;/code&gt; instead of &lt;code&gt;array.map!&lt;/code&gt;). The container itself is not a range.</source>
          <target state="translated">При использовании &lt;code&gt;Array&lt;/code&gt; с функциями на основе диапазона, такими как в &lt;code&gt;std.algorithm&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; должен быть разрезан, чтобы получить диапазон (например, используйте &lt;code&gt;array[].map!&lt;/code&gt; &lt;code&gt;array.map!&lt;/code&gt; Вместо array.map! ). Сам контейнер не является диапазоном.</target>
        </trans-unit>
        <trans-unit id="03cc7adf8ba709706cb35f2bb58133dcfd782ae1" translate="yes" xml:space="preserve">
          <source>When using inline assembly to correctly call a function.</source>
          <target state="translated">При использовании встроенной сборки для корректного вызова функции.</target>
        </trans-unit>
        <trans-unit id="774688ec36c97935b4687d1f1193e25cd82c07c5" translate="yes" xml:space="preserve">
          <source>When you want &lt;code&gt;TaskPool&lt;/code&gt; instances with multiple priorities, for example a low priority pool and a high priority pool.</source>
          <target state="translated">Когда вы хотите, &lt;code&gt;TaskPool&lt;/code&gt; экземпляры TaskPool имели несколько приоритетов, например, пул с низким приоритетом и пул с высоким приоритетом.</target>
        </trans-unit>
        <trans-unit id="5c533eb95b7c68ca359d852388aa63c0df13caf8" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;W&lt;/code&gt; is an &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; which accepts characters. The template type does not have to be called &lt;code&gt;W&lt;/code&gt;.  The following overloads are also accepted for legacy reasons or for use in virtual functions. It's recommended that any new code forgo these overloads if possible for speed and attribute acceptance reasons.</source>
          <target state="translated">Где &lt;code&gt;W&lt;/code&gt; - &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;выходной диапазон,&lt;/a&gt; который принимает символы. Тип шаблона не должен называться &lt;code&gt;W&lt;/code&gt; . Следующие перегрузки также принимаются по устаревшим причинам или для использования в виртуальных функциях. Рекомендуется, чтобы любой новый код воздерживался от этих перегрузок, если это возможно, по причинам скорости и принятия атрибутов.</target>
        </trans-unit>
        <trans-unit id="eb779ddbf577345f9139abf518ae6cd3c208a9cf" translate="yes" xml:space="preserve">
          <source>Where XX, YY and ZZ are the main version, release and patch numbers in hexadecimal (using 8 bits each). All three numbers are always represented using two digits. 1.2 would appear as &quot;0x010200&quot; while version 9.11.7 appears as &quot;0x090b07&quot;.</source>
          <target state="translated">Где XX,YY и ZZ-основная версия,номера выпусков и патчей в шестнадцатеричной системе (с использованием 8 бит каждая).Все три номера всегда представлены двумя цифрами.1.2 отображается как &quot;0x010200&quot;,а версия 9.11.7-как &quot;0x090b07&quot;.</target>
        </trans-unit>
        <trans-unit id="6a3d5415126b01717847c36c693a1e7515df6fdf" translate="yes" xml:space="preserve">
          <source>Where a, b are arbitrary classes, means union, set difference, symmetric set difference, and intersection respectively.</source>
          <target state="translated">Где a,b-произвольные классы,означают соответственно объединение,заданную разность,симметричную заданную разность и пересечение.</target>
        </trans-unit>
        <trans-unit id="69a17bf80e2fc04c2ef5e795e322e80f59502b94" translate="yes" xml:space="preserve">
          <source>Where if &lt;code&gt;elemsPerPage&lt;/code&gt; is a power of 2 the whole process is a handful of simple instructions and 2 array reads. Subsequent levels of the trie are introduced by recursing on this notion - the index array is treated as values. The number of bits in index is then again split into 2 parts, with pages over 'current-index' and the new 'upper-index'.</source>
          <target state="translated">Где, если &lt;code&gt;elemsPerPage&lt;/code&gt; - степень 2, весь процесс - горстка простых инструкций и 2 чтения массива. Последующие уровни дерева вводятся повторением этого понятия - массив индексов рассматривается как значения. Затем число битов в индексе снова делится на 2 части со страницами поверх &amp;laquo;current-index&amp;raquo; и нового &amp;laquo;upper-index&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ffd66cb2f4f10b47de2beafeec66ea7b60de2589" translate="yes" xml:space="preserve">
          <source>Where the identifier is set</source>
          <target state="translated">Где установлен идентификатор</target>
        </trans-unit>
        <trans-unit id="c203f2e467da276e5a5bb88a389aa547ada7fa1a" translate="yes" xml:space="preserve">
          <source>Where to copy into. The destructor, if any, is invoked before the copy is performed.</source>
          <target state="translated">Куда копировать.Деструктор,если таковой имеется,вызывается перед копированием.</target>
        </trans-unit>
        <trans-unit id="dae838c18b4d528d3dc79e9e2ab37bd9a763d468" translate="yes" xml:space="preserve">
          <source>Whereas classes are reference types, structs are value types. Structs and unions are simple aggregations of data and their associated operations on that data.</source>
          <target state="translated">В то время как классы являются типами ссылок,структуры-типами значений.Структуры и объединения-это простые совокупности данных и связанные с ними операции с этими данными.</target>
        </trans-unit>
        <trans-unit id="62176441139d7d91c6f66f0b49fc197cb19d61fc" translate="yes" xml:space="preserve">
          <source>Whereas the other constructors take in the given date/time, assume that it's in the given time zone, and convert it to hnsecs in UTC since midnight, January 1st, 1 A.D. UTC - i.e. std time - this constructor takes a std time, which is specifically already in UTC, so no conversion takes place. Of course, the various getter properties and functions will use the given time zone's conversion function to convert the results to that time zone, but no conversion of the arguments to this constructor takes place.</source>
          <target state="translated">В то время как другие конструкторы берут в заданную дату/время,предполагают,что он находится в данном часовом поясе,и преобразовывают его в hnsecs в UTC с полуночи 1 января 1 A.D.UTC-т.е.std время-этот конструктор занимает std время,которое конкретно уже находится в UTC,поэтому преобразование не происходит.Конечно,различные свойства и функции геттера будут использовать функцию преобразования данного часового пояса для преобразования результатов в этот часовой пояс,но преобразование аргументов в этот конструктор не происходит.</target>
        </trans-unit>
        <trans-unit id="5439ddebea3bcb8241b4a1b48a901c3a98dff5ec" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a control character.</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; управляющим символом.</target>
        </trans-unit>
        <trans-unit id="ac340e59aede6ee81d823a4cd6c5e84a932a655e" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a digit (0 .. 9).</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; цифрой (0 .. 9).</target>
        </trans-unit>
        <trans-unit id="7a1b20eec72209de601cdbd2eb60cdc44fe1de5c" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a digit in base 16 (0 .. 9, A .. F, a .. f).</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; цифрой в базе 16 (0 .. 9, A .. F, a .. f).</target>
        </trans-unit>
        <trans-unit id="5ef7c81488982c30dc4276356f1e35e27da46b13" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a digit in base 8 (0 .. 7).</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; цифрой в базе 8 (0 .. 7).</target>
        </trans-unit>
        <trans-unit id="485864c1a1ee3e1f67b7c0cca59c7933fd3cba6d" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a letter or a number (0 .. 9, a .. z, A .. Z).</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; буквой или цифрой (0 .. 9, a .. z, A .. Z).</target>
        </trans-unit>
        <trans-unit id="7ed8edd047ab927ee6ae7e9b404aa1611fee1ac6" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a lowercase ASCII letter (a .. z).</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; строчной буквой ASCII (a .. z).</target>
        </trans-unit>
        <trans-unit id="e45a29a9e82d832a043d4e613efe813b387b2d34" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is an ASCII letter (A .. Z, a .. z).</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; буквой ASCII (A .. Z, a .. z).</target>
        </trans-unit>
        <trans-unit id="4f95dae2edd2421032fe310301c2c8b1dfab82c9" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is an uppercase ASCII letter (A .. Z).</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; прописной буквой ASCII (A .. Z).</target>
        </trans-unit>
        <trans-unit id="7e4e8211288692290b0be6dedd54932002f12b6c" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;popFront&lt;/code&gt; should be called on the range before returning it.</source>
          <target state="translated">&lt;code&gt;popFront&lt;/code&gt; ли popFront вызываться в диапазоне перед его возвратом.</target>
        </trans-unit>
        <trans-unit id="81f48dc00dd66c921120fd6bdac04fd2154ca8fc" translate="yes" xml:space="preserve">
          <source>Whether a particular function can be inlined or not is implementation defined.</source>
          <target state="translated">Определяется,может ли конкретная функция быть инкапсулирована или нет.</target>
        </trans-unit>
        <trans-unit id="80666ab4965f448639b5b13ddb44b4b76acb3bd0" translate="yes" xml:space="preserve">
          <source>Whether a particular operation on a type is supported can be tested at compile time with:</source>
          <target state="translated">Поддерживается ли конкретная операция с типом может быть проверена при компиляции:</target>
        </trans-unit>
        <trans-unit id="b17fe9f3bccc77f51d0d6f2eb75dfb731d9293e3" translate="yes" xml:space="preserve">
          <source>Whether a path is absolute or not.</source>
          <target state="translated">Является ли путь абсолютным или нет.</target>
        </trans-unit>
        <trans-unit id="d4257757fa6c5a2c951b861ea5ebf39ab85d95e9" translate="yes" xml:space="preserve">
          <source>Whether a path starts at a root directory.  On POSIX, this function returns true if and only if the path starts with a slash (/).  On Windows, this function returns true if the path starts at the root directory of the current drive, of some other drive, or of a network drive.</source>
          <target state="translated">Начинается ли путь с корневой директории.В POSIX эта функция возвращает true только в том случае,если путь начинается со слеша (/).В Windows эта функция возвращает true,если путь начинается с корневой директории текущего диска,какого-нибудь другого диска или сетевого диска.</target>
        </trans-unit>
        <trans-unit id="47cbbb478f0753b2ad9648d6b321f84472430403" translate="yes" xml:space="preserve">
          <source>Whether a pointer is allocated memory using the GC or some other storage allocator is immaterial to OB, they are not distinguished and are handled identically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ee264abbb44915ef26b042ef0ba91b59c33f3c" translate="yes" xml:space="preserve">
          <source>Whether a type exists or not can be tested at compile time with an &lt;a href=&quot;expression#IsExpression&quot;&gt;&lt;i&gt;IsExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">Существует ли тип или нет, можно проверить во время компиляции с помощью &lt;a href=&quot;expression#IsExpression&quot;&gt;&lt;i&gt;IsExpression&lt;/i&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0d2e8298d7375b3835488873ddc1eb261222d403" translate="yes" xml:space="preserve">
          <source>Whether all of the given strings are valid units of time.</source>
          <target state="translated">Являются ли все данные строки действительными единицами времени.</target>
        </trans-unit>
        <trans-unit id="bddd6255fa5caa2472a10e52a62323219a833636" translate="yes" xml:space="preserve">
          <source>Whether duplicates should be allowed (optional, default: false)</source>
          <target state="translated">Должны ли дубликаты быть разрешены (необязательно,по умолчанию:false)</target>
        </trans-unit>
        <trans-unit id="105ee00d48f41e70c224fbb448cf13e95b6d4c14" translate="yes" xml:space="preserve">
          <source>Whether matching path name components against the base path should be case-sensitive or not.</source>
          <target state="translated">Должно ли соответствие компонентов имени пути базовому пути быть регистрозависимым или нет.</target>
        </trans-unit>
        <trans-unit id="5994712767c3b51ff98f1684ff6aac750498fbfd" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a Unicode whitespace &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;. (general Unicode category: Part of C0(tab, vertical tab, form feed, carriage return, and linefeed characters), Zs, Zl, Zp, and NEL(U+0085))</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; &lt;a href=&quot;#Character&quot;&gt;символом&lt;/a&gt; пробела Unicode . (общая категория Unicode: часть C0 (табуляция, вертикальная табуляция, подача формы, возврат каретки и символы перевода строки), Zs, Zl, Zp и NEL (U + 0085))</target>
        </trans-unit>
        <trans-unit id="e5176862b3796a64ee6f96c0f2cad977204be80c" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a printable character - including the space character.</source>
          <target state="translated">Является или нет &lt;code&gt;c&lt;/code&gt; печатным символом - включая символ пробела.</target>
        </trans-unit>
        <trans-unit id="8d275566c08c40d417a8d0c1a542e23706cfd89d" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a printable character other than the space character.</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; печатным символом, кроме символа пробела.</target>
        </trans-unit>
        <trans-unit id="0d4466d6122843433740ac1e24f53638cd058f74" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a punctuation character. That includes all ASCII characters which are not control characters, letters, digits, or whitespace.</source>
          <target state="translated">Является или нет &lt;code&gt;c&lt;/code&gt; символом пунктуации. Это включает в себя все символы ASCII, которые не являются управляющими символами, буквами, цифрами или пробелами.</target>
        </trans-unit>
        <trans-unit id="53aed4e21bd24c8a6a4ab614baedfcc7d4f4996f" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a whitespace character. That includes the space, tab, vertical tab, form feed, carriage return, and linefeed characters.</source>
          <target state="translated">Является ли &lt;code&gt;c&lt;/code&gt; символом пробела или нет . Сюда входят пробел, табуляция, вертикальная табуляция, подача формы, возврат каретки и символы перевода строки.</target>
        </trans-unit>
        <trans-unit id="b615a3fb840147ddc1a8af598703baa7a19f1868" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is in the ASCII character set - i.e. in the range 0 .. 0x7F.</source>
          <target state="translated">Находится ли &lt;code&gt;c&lt;/code&gt; в наборе символов ASCII - то есть в диапазоне 0 .. 0x7F.</target>
        </trans-unit>
        <trans-unit id="4fcdd7b41031ee1cf72b913251142382d55fe4bc" translate="yes" xml:space="preserve">
          <source>Whether or not suffix matching is case-sensitive.</source>
          <target state="translated">Сопоставление суффиксов чувствительно к регистру.</target>
        </trans-unit>
        <trans-unit id="ab7c20d3765e454b2882b3b020b5a0b203d7fc57" translate="yes" xml:space="preserve">
          <source>Whether or not to replace invalid UTF with &lt;a href=&quot;#replacementDchar&quot;&gt;&lt;code&gt;replacementDchar&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Следует ли заменить недействительный UTF на &lt;a href=&quot;#replacementDchar&quot;&gt; &lt;code&gt;replacementDchar&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e89650fbf7133e4518a40c904d03fa213351ed5" translate="yes" xml:space="preserve">
          <source>Whether some pointers can be initialized with the addresses of other functions or data.</source>
          <target state="translated">Могут ли некоторые указатели быть инициализированы адресами других функций или данными.</target>
        </trans-unit>
        <trans-unit id="46b11fa801f28347be88f3318e7531888286afa4" translate="yes" xml:space="preserve">
          <source>Whether symbolic links which point to directories should be treated as directories and their contents iterated over.</source>
          <target state="translated">Должны ли символические ссылки,указывающие на каталоги,рассматриваться как каталоги,а их содержание итериироваться.</target>
        </trans-unit>
        <trans-unit id="cf1e4687c0d3d2d1dc253d21a37e498c8e5bdf91" translate="yes" xml:space="preserve">
          <source>Whether the</source>
          <target state="translated">Будь то</target>
        </trans-unit>
        <trans-unit id="2b547c643e30d803b4436c4a2410fe11d4d71937" translate="yes" xml:space="preserve">
          <source>Whether the alias this was reported as deprecated.</source>
          <target state="translated">Был ли этот псевдоним признан устаревшим.</target>
        </trans-unit>
        <trans-unit id="64958592863f2f27ab327ee132cce3a7bd2ddc9b" translate="yes" xml:space="preserve">
          <source>Whether the attributes are values or types is up to the user, and whether later attributes accumulate or override earlier ones is also up to how the user interprets them.</source>
          <target state="translated">Являются ли атрибуты значениями или типами,зависит от пользователя,а также от того,накапливаются ли более поздние атрибуты или переопределяются более ранними,зависит также от того,как пользователь их интерпретирует.</target>
        </trans-unit>
        <trans-unit id="63cc9d04434e2b0f371df73e94c3596c4b2795d4" translate="yes" xml:space="preserve">
          <source>Whether the current year is a date in A.D.</source>
          <target state="translated">Является ли текущий год датой в округе Колумбия.</target>
        </trans-unit>
        <trans-unit id="74f48ebfb70bd542fa649d10356abbfea0c933cd" translate="yes" xml:space="preserve">
          <source>Whether the day should be allowed to overflow, causing the month to increment.</source>
          <target state="translated">Должен ли день быть разрешен на переполнение,в результате чего месяц увеличивается.</target>
        </trans-unit>
        <trans-unit id="e4d91a4b6609e830d213d95f93d157f35d7012ec" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, causing their month to increment.</source>
          <target state="translated">Должны ли дни допускаться переполнение в &lt;code&gt;begin&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; , вызывая увеличение их месяца.</target>
        </trans-unit>
        <trans-unit id="f906c90dd95bf15e29eecd5d760671025012b178" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;begin&lt;/code&gt;, causing its month to increment.</source>
          <target state="translated">Должны ли дни допускаться переполнение при &lt;code&gt;begin&lt;/code&gt; , вызывая увеличение его месяца.</target>
        </trans-unit>
        <trans-unit id="1cf8d3b77ba179bc4efd8d66d52696c2e6e3533e" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;end&lt;/code&gt;, causing its month to increment.</source>
          <target state="translated">То ли дни должны быть разрешены к переполнению на &lt;code&gt;end&lt;/code&gt; , в результате чего его месяца приращения.</target>
        </trans-unit>
        <trans-unit id="75b2be390650906e0d7fdcddcbc148b30188752c" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;end&lt;/code&gt;, causing their month to increment.</source>
          <target state="translated">То ли дни должны быть разрешены к переполнению на &lt;code&gt;end&lt;/code&gt; , в результате чего их месяца приращения.</target>
        </trans-unit>
        <trans-unit id="4f04a420fd7af3fb4659b207356841de3d274500" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow, causing the month to increment.</source>
          <target state="translated">Должны ли дни переполняться,в результате чего месяц увеличивается.</target>
        </trans-unit>
        <trans-unit id="5edf9636ede7af2a2961293554b8a7947f2de1da" translate="yes" xml:space="preserve">
          <source>Whether the directory's sub-directories should be iterated in depth-first post-order (&lt;a href=&quot;#depth&quot;&gt;&lt;code&gt;depth&lt;/code&gt;&lt;/a&gt;), depth-first pre-order (&lt;a href=&quot;#breadth&quot;&gt;&lt;code&gt;breadth&lt;/code&gt;&lt;/a&gt;), or not at all (&lt;a href=&quot;#shallow&quot;&gt;&lt;code&gt;shallow&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Подкаталоги каталога должны быть итерированы в первом порядке &lt;a href=&quot;#depth&quot;&gt; &lt;code&gt;depth&lt;/code&gt; &lt;/a&gt; ( глубина ), первом порядке глубины ( &lt;a href=&quot;#breadth&quot;&gt; &lt;code&gt;breadth&lt;/code&gt; &lt;/a&gt; ) или вообще не должны ( &lt;a href=&quot;#shallow&quot;&gt; &lt;code&gt;shallow&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e52e8a91e4b8f750e345969fb48d6af719bcad92" translate="yes" xml:space="preserve">
          <source>Whether the elements copied should be in sorted order.</source>
          <target state="translated">Должны ли копируемые элементы быть отсортированы в порядке.</target>
        </trans-unit>
        <trans-unit id="c4ed695121f4b89d56651176a0692d94b2e93e86" translate="yes" xml:space="preserve">
          <source>Whether the elements copied should be in sorted order.  The function &lt;code&gt;largestPartialIntersection&lt;/code&gt; is useful for e.g. searching an &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverted_index&quot;&gt;inverted index&lt;/a&gt; for the documents most likely to contain some terms of interest. The complexity of the search is &amp;Omicron;(&lt;code&gt;n * log(tgt.length)&lt;/code&gt;), where &lt;code&gt;n&lt;/code&gt; is the sum of lengths of all input ranges. This approach is faster than keeping an associative array of the occurrences and then selecting its top items, and also requires less memory (&lt;code&gt;largestPartialIntersection&lt;/code&gt; builds its result directly in &lt;code&gt;tgt&lt;/code&gt; and requires no extra memory).  If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all ranges and picking the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements.</source>
          <target state="translated">Должны ли скопированные элементы быть в отсортированном порядке. Функция &lt;code&gt;largestPartialIntersection&lt;/code&gt; полезна для поиска , например , в &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverted_index&quot;&gt;инвертированный индекс&lt;/a&gt; для документов , скорее всего, содержат некоторые термины , представляющие интерес. Сложность поиска составляет &amp;Omicron; ( &lt;code&gt;n * log(tgt.length)&lt;/code&gt; ), где &lt;code&gt;n&lt;/code&gt; - сумма длин всех входных диапазонов. Этот подход быстрее, чем сохранение ассоциативного массива вхождений и затем выбор его верхних элементов, а также требует меньше памяти ( &lt;code&gt;largestPartialIntersection&lt;/code&gt; создает свой результат непосредственно в &lt;code&gt;tgt&lt;/code&gt; и не требует дополнительной памяти). Если хотя бы один из диапазонов является мультимножеством, то учитываются все вхождения дублирующего элемента. Результат эквивалентен объединению всех диапазонов и выбору наиболее частых элементов &lt;code&gt;tgt.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="222aaf1e209a1d1950f86d3b862f71882791518e" translate="yes" xml:space="preserve">
          <source>Whether the given Gregorian Year is a leap year.</source>
          <target state="translated">Является ли данный григорианский год високосным.</target>
        </trans-unit>
        <trans-unit id="0960e5d381ab24794774d7641f42ed087b4e5af5" translate="yes" xml:space="preserve">
          <source>Whether the given interval is adjacent to this interval.</source>
          <target state="translated">Примыкает ли данный интервал к этому интервалу.</target>
        </trans-unit>
        <trans-unit id="2224cd32996d6b99aba1574ce1aececc83aecc58" translate="yes" xml:space="preserve">
          <source>Whether the given interval is completely within this interval.</source>
          <target state="translated">Полностью ли заданный интервал находится в пределах этого интервала.</target>
        </trans-unit>
        <trans-unit id="3eb9c7e591a9089f7aa4ef62cbadc0d86f7ab393" translate="yes" xml:space="preserve">
          <source>Whether the given interval overlaps this interval.</source>
          <target state="translated">Перекрывает ли данный интервал этот интервал.</target>
        </trans-unit>
        <trans-unit id="43cf734ed67d93278a33afc7cd0b9e0cc54e9d11" translate="yes" xml:space="preserve">
          <source>Whether the given time point is within this interval.</source>
          <target state="translated">Находится ли заданная временная точка в пределах этого интервала.</target>
        </trans-unit>
        <trans-unit id="fba0a8c883b3bbb3c817280550f713f113b648ef" translate="yes" xml:space="preserve">
          <source>Whether the given type defines all of the necessary functions for it to function as a time point.</source>
          <target state="translated">Определяет ли данный тип все необходимые ему функции для функционирования в качестве временной точки.</target>
        </trans-unit>
        <trans-unit id="7595a2da4d09354571e7d048eb2cac04b29d2b5c" translate="yes" xml:space="preserve">
          <source>Whether the input should be considered to already be in quotes</source>
          <target state="translated">Следует ли считать,что входные данные уже находятся в кавычках.</target>
        </trans-unit>
        <trans-unit id="6c405afd958614c32b310c5d0cf26f852d390597" translate="yes" xml:space="preserve">
          <source>Whether the interval's length is 0, that is, whether &lt;code&gt;begin == end&lt;/code&gt;.</source>
          <target state="translated">Является ли длина интервала 0, то есть, &lt;code&gt;begin == end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fee4c582fcbd6cb7b6d78096f397a088d57f77e8" translate="yes" xml:space="preserve">
          <source>Whether the interval's length is 0. Always returns false.</source>
          <target state="translated">Длина интервала 0.Всегда возвращается ложным.</target>
        </trans-unit>
        <trans-unit id="211f313086ef9b6b83422bb372a90c8c62b36199" translate="yes" xml:space="preserve">
          <source>Whether the last element has fewer elements than &lt;code&gt;windowSize&lt;/code&gt; it should be be ignored (&lt;code&gt;No.withPartial&lt;/code&gt;) or added (&lt;code&gt;Yes.withPartial&lt;/code&gt;)</source>
          <target state="translated">Если последний элемент имеет меньше элементов, чем &lt;code&gt;windowSize&lt;/code&gt; , его следует игнорировать ( &lt;code&gt;No.withPartial&lt;/code&gt; ) или добавлять ( &lt;code&gt;Yes.withPartial&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ba9abeb7a170a01907bd30fe75c31c8934244314" translate="yes" xml:space="preserve">
          <source>Whether the matching should be case-sensitive</source>
          <target state="translated">Должно ли соответствие быть чувствительным к регистру</target>
        </trans-unit>
        <trans-unit id="f13a37d1655eb5c02daf3aaa88f877bec24d658e" translate="yes" xml:space="preserve">
          <source>Whether the program stops on the first unit test failure, or continues running the unit tests.</source>
          <target state="translated">Останавливается ли программа при первом сбое в модульном тестировании или продолжает выполнять модульные тесты.</target>
        </trans-unit>
        <trans-unit id="16d709e5514290422fe4701b1fcb581c1cf7c0ea" translate="yes" xml:space="preserve">
          <source>Whether the symbol represented by the string, member, exists and is a static member of T.</source>
          <target state="translated">Существует ли символ,представленный строкой,членом,и является ли он статическим членом T.</target>
        </trans-unit>
        <trans-unit id="5440d07830fe58a338f1510d753f2b44ea0975da" translate="yes" xml:space="preserve">
          <source>Whether the type is modifiable</source>
          <target state="translated">является ли тип модифицируемым</target>
        </trans-unit>
        <trans-unit id="3f12e12092120abbb5facbde31d865f4ac9237a3" translate="yes" xml:space="preserve">
          <source>Whether there are more matches.</source>
          <target state="translated">Есть ли еще спички.</target>
        </trans-unit>
        <trans-unit id="79ba28ddb3b853b6d70a3013610438f23721a2fc" translate="yes" xml:space="preserve">
          <source>Whether this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in a leap year.</source>
          <target state="translated">Является ли эта &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; високосным годом.</target>
        </trans-unit>
        <trans-unit id="cfc2c65b73e5981574242c9ea69e9d9a4065c55b" translate="yes" xml:space="preserve">
          <source>Whether this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in a leap year.</source>
          <target state="translated">Будет ли этот &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; високосным годом.</target>
        </trans-unit>
        <trans-unit id="8a7bb8b28d4fed31e73e86d279c785680a5039aa" translate="yes" xml:space="preserve">
          <source>Whether this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in a leap year.</source>
          <target state="translated">Будет ли этот &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; високосным годом.</target>
        </trans-unit>
        <trans-unit id="cbeb386e746809fa0b6115a9b6ed409316553ae9" translate="yes" xml:space="preserve">
          <source>Whether this &lt;code&gt;IntervalRange&lt;/code&gt; is empty.</source>
          <target state="translated">Является ли этот &lt;code&gt;IntervalRange&lt;/code&gt; пустым.</target>
        </trans-unit>
        <trans-unit id="b64edf6a2596a02728c1746b3074d42171989fdf" translate="yes" xml:space="preserve">
          <source>Whether this &lt;code&gt;alias this&lt;/code&gt; is deprecated or not</source>
          <target state="translated">Является ли этот &lt;code&gt;alias this&lt;/code&gt; устаревшим или нет</target>
        </trans-unit>
        <trans-unit id="5f10f8b3bbf77628c34f12ea0b9275a2e7571d57" translate="yes" xml:space="preserve">
          <source>Whether this interval is after the given interval and does not intersect it.</source>
          <target state="translated">Является ли этот интервал после заданного интервала и не пересекает ли он его.</target>
        </trans-unit>
        <trans-unit id="3518cb2bbf874df4bb8421f23e69b77bffff6981" translate="yes" xml:space="preserve">
          <source>Whether this interval is after the given time point.</source>
          <target state="translated">Будет ли этот интервал после заданной временной точки.</target>
        </trans-unit>
        <trans-unit id="e8beff07475e780f798cb6bfa07a9e4e3b7aa515" translate="yes" xml:space="preserve">
          <source>Whether this interval is before the given interval and does not intersect it.</source>
          <target state="translated">Является ли этот интервал предшествующим данному интервалу и не пересекает ли он его.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
