<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="91b5a4505ff4388b543e615403e943b213e146be" translate="yes" xml:space="preserve">
          <source>Enums must have at least one member.</source>
          <target state="translated">В переписях должен быть хотя бы один член.</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">Переменные среды</target>
        </trans-unit>
        <trans-unit id="af2c16f78a14f7f4e0c19bb8444d3b5d1ddbd6bc" translate="yes" xml:space="preserve">
          <source>Eponymous Templates</source>
          <target state="translated">одноимённые шаблоны</target>
        </trans-unit>
        <trans-unit id="98960d79731e92f6a1481f64f5023d43b91903f0" translate="yes" xml:space="preserve">
          <source>Equal to &lt;a href=&quot;etc_c_curl#CURLcode&quot;&gt;&lt;code&gt;etc.c.curl.CURLcode&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Равен и т. Д. &lt;a href=&quot;etc_c_curl#CURLcode&quot;&gt; &lt;code&gt;etc.c.curl.CURLcode&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb253eb5985c5dedcf6ea0e168a624316301f2da" translate="yes" xml:space="preserve">
          <source>Equality Expressions</source>
          <target state="translated">Выражения равенства</target>
        </trans-unit>
        <trans-unit id="d0f7f003b5eae761303767b178c5b32ad771e92d" translate="yes" xml:space="preserve">
          <source>Equality comparisons (==, !=, is, !is) are permitted between all pointers, without restriction.</source>
          <target state="translated">Сравнения равенства (==,!=,is,!is)разрешены между всеми указателями,без ограничений.</target>
        </trans-unit>
        <trans-unit id="d0efd94caf98a8617b53c3b12681dbbfdad08e3c" translate="yes" xml:space="preserve">
          <source>Equality expressions compare the two operands for equality (&lt;code&gt;==&lt;/code&gt;) or inequality (&lt;code&gt;!=&lt;/code&gt;). The type of the result is &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Выражения равенства сравнивают два операнда на равенство ( &lt;code&gt;==&lt;/code&gt; ) или неравенство ( &lt;code&gt;!=&lt;/code&gt; ). Тип результата - &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a821b59480ce2414bd6165847b5c1fb14cb79065" translate="yes" xml:space="preserve">
          <source>Equivalence is defined by the predicate &lt;code&gt;pred&lt;/code&gt;, which can be either binary, which is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, or unary, which is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;. In the binary form, two range elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if &lt;code&gt;pred(a,b)&lt;/code&gt; is true. In unary form, two elements are considered equivalent if &lt;code&gt;pred(a) == pred(b)&lt;/code&gt; is true.</source>
          <target state="translated">Эквивалентность определяется предикатом &lt;code&gt;pred&lt;/code&gt; , который может быть либо двоичным, который передается в &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt; , либо унарным, который передается в &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt; . В двоичной форме два элемента диапазона &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; считаются эквивалентными, если &lt;code&gt;pred(a,b)&lt;/code&gt; имеет значение true. В унарной форме два элемента считаются эквивалентными, если &lt;code&gt;pred(a) == pred(b)&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="f3d4d9eeca49f09a17fcd8a54a0fa4787c33d0da" translate="yes" xml:space="preserve">
          <source>Equivalent elements separated by an intervening non-equivalent element will appear in separate subranges; this function only considers adjacent equivalence. Elements in the subranges will always appear in the same order they appear in the original range.</source>
          <target state="translated">Эквивалентные элементы,разделенные промежуточным неэквивалентным элементом,будут появляться в отдельных поддиапазонах;эта функция учитывает только смежную эквивалентность.Элементы в поддиапазонах всегда будут появляться в том же порядке,что и в исходном диапазоне.</target>
        </trans-unit>
        <trans-unit id="15ed9b5cca8803ef06cb9688dbc5af4fe192a4a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;file.writef(fmt, args, '\n')&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;file.writef(fmt, args, '\n')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce6d1bc952023308db732f8f94e2b34d7940aa93" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fmax(x-y, 0)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;fmax(x-y, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e86802e906e78082747bcdbd4222e541b464705" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;write(args, '\n')&lt;/code&gt;. Calling &lt;code&gt;writeln&lt;/code&gt; without arguments is valid and just prints a newline to the standard output.</source>
          <target state="translated">Эквивалент для &lt;code&gt;write(args, '\n')&lt;/code&gt; . Вызов &lt;code&gt;writeln&lt;/code&gt; без аргументов действителен и просто выводит новую строку в стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="d1a5bc7d4ab0b05ff1942fc426e894258a7dcb1a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;writef(fmt, args, '\n')&lt;/code&gt;.</source>
          <target state="translated">Эквивалент &lt;code&gt;writef(fmt, args, '\n')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f2f6a15cf8da2b27e5a4af47b58e7ad71c0b3d9" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="translated">Error</target>
        </trans-unit>
        <trans-unit id="c73f93f4b9a02f4e5a949fd11052e3a166c6f2ac" translate="yes" xml:space="preserve">
          <source>Error Codes And Messages</source>
          <target state="translated">Коды ошибок и сообщения</target>
        </trans-unit>
        <trans-unit id="7fc353a0378a6af6e63cb4e746bbbbd0e56d46cc" translate="yes" xml:space="preserve">
          <source>Error Logging Interface</source>
          <target state="translated">Интерфейс регистрации ошибок</target>
        </trans-unit>
        <trans-unit id="ebaf4b5ec788b16d6d54392acc5fde873dbc786a" translate="yes" xml:space="preserve">
          <source>Error exceptions get handled one way or another. There is nothing like a NULL pointer return indicating an error, followed by trying to use that NULL pointer.</source>
          <target state="translated">Исключения об ошибках так или иначе обрабатываются.Нет ничего похожего на возврат NULL указателя,указывающего на ошибку,с последующей попыткой использовать этот NULL указатель.</target>
        </trans-unit>
        <trans-unit id="a623c8e1a198390969227d2d0b456f83bf23e21d" translate="yes" xml:space="preserve">
          <source>Error function</source>
          <target state="translated">функция ошибки</target>
        </trans-unit>
        <trans-unit id="34d6de902e8eedf56209e7c63d5376af7cf4d10e" translate="yes" xml:space="preserve">
          <source>Error message</source>
          <target state="translated">сообщение об ошибке</target>
        </trans-unit>
        <trans-unit id="50c855f2252890155a086cc4373ee4123aab7e7a" translate="yes" xml:space="preserve">
          <source>Error message from sqlite3_mprintf()</source>
          <target state="translated">Сообщение об ошибке от sqlite3_mprintf()</target>
        </trans-unit>
        <trans-unit id="2252ea1e4cbf7755de129147ae3fdbeb59b1c86e" translate="yes" xml:space="preserve">
          <source>ErrorExp</source>
          <target state="translated">ErrorExp</target>
        </trans-unit>
        <trans-unit id="813b5f9ec8deffdd987c925d7e6501434e44711b" translate="yes" xml:space="preserve">
          <source>ErrorExp &lt;strong id=&quot;arrayOpInvalidError&quot;&gt;arrayOpInvalidError&lt;/strong&gt;(Expression e);</source>
          <target state="translated">ErrorExp &lt;strong id=&quot;arrayOpInvalidError&quot;&gt;arrayOpInvalidError&lt;/strong&gt; (Выражение e);</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="36fd0b0b802c6a97f7436e7a54204bfe482a5123" translate="yes" xml:space="preserve">
          <source>Errors are not part of the normal flow of a program. Errors are exceptional, unusual, and unexpected.</source>
          <target state="translated">Ошибки не являются частью обычного потока программы.Ошибки исключительны,необычны и неожиданны.</target>
        </trans-unit>
        <trans-unit id="e66bc34f0c40669df2318f69c4904fa255dc47c1" translate="yes" xml:space="preserve">
          <source>Errors throw a ZlibException.</source>
          <target state="translated">Ошибки бросают ЗлибЭксцепцию.</target>
        </trans-unit>
        <trans-unit id="21208fcb40762782f0bd5de0b94d3c459b091b72" translate="yes" xml:space="preserve">
          <source>Es &lt;code&gt;es&lt;/code&gt;</source>
          <target state="translated">Es &lt;code&gt;es&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="3e13e2405c74a25265ee4e281ccf78feafc5234d" translate="yes" xml:space="preserve">
          <source>Escape Sequences</source>
          <target state="translated">Побеговые последовательности</target>
        </trans-unit>
        <trans-unit id="7a8244906137fd404125079316acd1c376574734" translate="yes" xml:space="preserve">
          <source>Escapes URL strings (converts all letters consider illegal in URLs to their %XX versions). This function returns a new allocated string or NULL if an error occurred.</source>
          <target state="translated">Скрывает строки URL (преобразует все буквы,считающиеся незаконными в URL,в их версии %XX).Эта функция возвращает новую выделенную строку или NULL,если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="c62c2a45ea9630e69c7b0296a18169ca1da2c6cd" translate="yes" xml:space="preserve">
          <source>Escapes a filename to be used for shell redirection with &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Исключает имя файла, которое будет использоваться для перенаправления оболочки с &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="334839f3a4af8ebe642ad214739fca50dd79b867" translate="yes" xml:space="preserve">
          <source>Escapes an argv-style argument array to be used with &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Выход из массива аргументов в стиле argv для использования с &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c42e53a2ef68cf047319483e6444a0150025a7f7" translate="yes" xml:space="preserve">
          <source>Essentially just calls &lt;code&gt;checkNestedReference() for each variable reference in &lt;/code&gt;e`.</source>
          <target state="translated">По сути, просто вызывает &lt;code&gt;checkNestedReference() for each variable reference in &lt;/code&gt; e`.</target>
        </trans-unit>
        <trans-unit id="37eefc2536d5ec542e4520a234de4d178700f2f2" translate="yes" xml:space="preserve">
          <source>Establish a connection. If the socket is blocking, connect waits for the connection to be made. If the socket is nonblocking, connect returns immediately and the connection attempt is still in progress.</source>
          <target state="translated">Установите связь.Если розетка заблокирована,соединение ожидает выполнения соединения.Если розетка не блокируется,соединение возвращается немедленно,а попытка соединения продолжается.</target>
        </trans-unit>
        <trans-unit id="cb2a5e97585ee713b7b435ea0059ffc0b575e976" translate="yes" xml:space="preserve">
          <source>Estimated cost of using this index</source>
          <target state="translated">Сметная стоимость использования этого индекса</target>
        </trans-unit>
        <trans-unit id="4dc2b41f9f62ae24f4ee1bdb98221a2c0df13e48" translate="yes" xml:space="preserve">
          <source>Ethiopic</source>
          <target state="translated">Ethiopic</target>
        </trans-unit>
        <trans-unit id="50a8bee7f3f7f91e053f811fb77da91693c7dedd" translate="yes" xml:space="preserve">
          <source>Ethiopic Extended</source>
          <target state="translated">эфиопский расширенный</target>
        </trans-unit>
        <trans-unit id="0b1c5f04c3cf37f71157c85cf3538322e5bf9da1" translate="yes" xml:space="preserve">
          <source>Ethiopic Extended-A</source>
          <target state="translated">эфиопское расширение-A</target>
        </trans-unit>
        <trans-unit id="7c8438f345294d8ae21cfe001be4e6de5852f8b9" translate="yes" xml:space="preserve">
          <source>Ethiopic Supplement</source>
          <target state="translated">Эфиопское приложение</target>
        </trans-unit>
        <trans-unit id="ec4e1ce13e95c935383dc5219130b98c64fd292a" translate="yes" xml:space="preserve">
          <source>Evaluate &amp;gt;,&amp;lt;=, etc. Resolves slices before comparing. Returns 0 or 1</source>
          <target state="translated">Оценить&amp;gt;, &amp;lt;= и т. Д. Разрешает фрагменты перед сравнением. Возвращает 0 или 1</target>
        </trans-unit>
        <trans-unit id="63a877dc2e3925ab0262cba5e336e32067b1f868" translate="yes" xml:space="preserve">
          <source>Evaluate ==, !=. Resolves slices before comparing. Returns 0 or 1</source>
          <target state="translated">Оцените ==,!=.Решает срезы до сравнения.Возвращает 0 или 1</target>
        </trans-unit>
        <trans-unit id="b8465fee9c60fa18c66485376de57ad47eb492b1" translate="yes" xml:space="preserve">
          <source>Evaluate An SQL Statement</source>
          <target state="translated">Оценка SQL-оператора</target>
        </trans-unit>
        <trans-unit id="f0a33e70cc28b1c16a65e2ac8b3f23349a36f271" translate="yes" xml:space="preserve">
          <source>Evaluate builtin function. Return result; NULL if cannot evaluate it.</source>
          <target state="translated">Оцените встроенную функцию.Возвращает результат;NULL,если не может его оценить.</target>
        </trans-unit>
        <trans-unit id="ba342f0fe13aca65712f2259febed282817e389a" translate="yes" xml:space="preserve">
          <source>Evaluate is, !is. Resolves slices before comparing. Returns 0 or 1</source>
          <target state="translated">Оцените это.Решает срезы до сравнения.Возвращает 0 или 1</target>
        </trans-unit>
        <trans-unit id="0dfd6ef81633d9cb47cabec388bec88396961ba5" translate="yes" xml:space="preserve">
          <source>Evaluate polynomial A(x) = a&lt;sub&gt;0&lt;/sub&gt; + a&lt;sub&gt;1&lt;/sub&gt;x + a&lt;sub&gt;2&lt;/sub&gt;x&lt;sup&gt;2&lt;/sup&gt; + a&lt;sub&gt;3&lt;/sub&gt;x&lt;sup&gt;3&lt;/sup&gt;; ...</source>
          <target state="translated">Оценить полином A (x) = a &lt;sub&gt;0&lt;/sub&gt; + a &lt;sub&gt;1&lt;/sub&gt; x + a &lt;sub&gt;2&lt;/sub&gt; x &lt;sup&gt;2&lt;/sup&gt; + a &lt;sub&gt;3&lt;/sub&gt; x &lt;sup&gt;3&lt;/sup&gt; ; ...</target>
        </trans-unit>
        <trans-unit id="a5be27aeb62439a889f10e6c829e770637dd9146" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;AliasSeq!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))&lt;/code&gt;.</source>
          <target state="translated">Оценивает &lt;code&gt;AliasSeq!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9629b284d8cc44b6dfe8df63c6a3f0d4084cc53c" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;doesPointTo(x, x)&lt;/code&gt; checks whether &lt;code&gt;x&lt;/code&gt; has internal pointers. This should only be done as an assertive test, as the language is free to assume objects don't have internal pointers (TDPL 7.1.3.5).</source>
          <target state="translated">Оценка &lt;code&gt;doesPointTo(x, x)&lt;/code&gt; проверяет, есть ли у &lt;code&gt;x&lt;/code&gt; внутренние указатели. Это должно быть сделано только в качестве проверочного теста, поскольку язык может предполагать, что объекты не имеют внутренних указателей (TDPL 7.1.3.5).</target>
        </trans-unit>
        <trans-unit id="0a4344337a70f4c33150fb408f68890c00d456e4" translate="yes" xml:space="preserve">
          <source>Evaluation is</source>
          <target state="translated">Оценка является</target>
        </trans-unit>
        <trans-unit id="66a21e1a42d0f889ed11cc2d4d6f241490fc741c" translate="yes" xml:space="preserve">
          <source>Evaluation is short-circuited if a true result is encountered; the template predicate must be instantiable with one of the given items.</source>
          <target state="translated">Оценка является коротким замыканием,если встречается истинный результат;предикат шаблона должен быть инстанциозным с одним из заданных пунктов.</target>
        </trans-unit>
        <trans-unit id="4d17d4bfeca546c47272dfcbb85f447b4b26bf12" translate="yes" xml:space="preserve">
          <source>Evaluation order of options is &lt;code&gt;rt_options&lt;/code&gt;, then environment variables, then command line arguments, i.e. if command line arguments are not disabled, they can override options specified through the environment or embedded in the executable.</source>
          <target state="translated">Порядок оценки параметров: &lt;code&gt;rt_options&lt;/code&gt; , затем переменные среды, затем аргументы командной строки, т. Е. Если аргументы командной строки не отключены, они могут переопределять параметры, заданные в среде или встроенные в исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="180eef85054f4fcea96ca798ddcbe7751670c0c9" translate="yes" xml:space="preserve">
          <source>Evaluation value</source>
          <target state="translated">Оценочная стоимость</target>
        </trans-unit>
        <trans-unit id="6f02f12a41e5810b607c7f2ac63bab107ad16369" translate="yes" xml:space="preserve">
          <source>Even if template arguments are implicitly converted to the same template parameter type, they still refer to the same instance. This example uses a &lt;a href=&quot;#aggregate_templates&quot;&gt;&lt;code&gt;struct&lt;/code&gt; template&lt;/a&gt;:</source>
          <target state="translated">Даже если аргументы шаблона неявно преобразуются в один и тот же тип параметра шаблона, они все равно ссылаются на один и тот же экземпляр. В этом примере используется &lt;a href=&quot;#aggregate_templates&quot;&gt;шаблон &lt;/a&gt; &lt;code&gt;struct&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="becac2a7bbc3661ded85df34941db446bcb8fc99" translate="yes" xml:space="preserve">
          <source>Even permutations are useful for generating coordinates of certain geometric shapes. Here's a non-trivial example:</source>
          <target state="translated">Даже перестановки полезны для генерации координат определенных геометрических фигур.Вот нетривиальный пример:</target>
        </trans-unit>
        <trans-unit id="ff9e5997c4690a9137a05954ed088426938f9897" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;B.foo(int)&lt;/code&gt; is a better match than &lt;code&gt; A.foo(long)&lt;/code&gt; for &lt;code&gt;foo(1)&lt;/code&gt;, it is an error because the two matches are in different overload sets.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;B.foo(int)&lt;/code&gt; лучше, чем &lt;code&gt; A.foo(long)&lt;/code&gt; для &lt;code&gt;foo(1)&lt;/code&gt; , это ошибка, потому что два совпадения находятся в разных наборах перегрузки.</target>
        </trans-unit>
        <trans-unit id="1b34452177e48c546c9017df7b18cba01909144f" translate="yes" xml:space="preserve">
          <source>Even though a new scope is introduced, local symbol declarations cannot shadow (hide) other local symbol declarations in the same function.</source>
          <target state="translated">Несмотря на то,что вводится новая сфера применения,локальные символьные декларации не могут оттенять (скрывать)другие локальные символьные декларации в той же функции.</target>
        </trans-unit>
        <trans-unit id="b53b461e5519dc40d2d9c94f0001bf7d1b8053d1" translate="yes" xml:space="preserve">
          <source>Even trivially sub-classing an exception involves writing boilerplate code for the constructor to: 1) correctly pass in the source file and line number the exception was thrown from; 2) be usable with &lt;a href=&quot;#enforce&quot;&gt;&lt;code&gt;enforce&lt;/code&gt;&lt;/a&gt; which expects exception constructors to take arguments in a fixed order. This mixin provides that boilerplate code.</source>
          <target state="translated">Даже тривиальное подразделение исключения включает в себя написание стандартного кода для конструктора, чтобы: 1) правильно передать исходный файл и номер строки, из которой было сгенерировано исключение; 2) быть применимым с &lt;a href=&quot;#enforce&quot;&gt; &lt;code&gt;enforce&lt;/code&gt; &lt;/a&gt; которое ожидает, что конструкторы исключений будут принимать аргументы в фиксированном порядке. Этот миксин обеспечивает этот стандартный код.</target>
        </trans-unit>
        <trans-unit id="646505488568f65dc2d08be5e7c3988051fbafd1" translate="yes" xml:space="preserve">
          <source>Even worse, good error handling code is itself error prone, tends to be the least tested (and therefore buggy) part of the project, and is frequently simply omitted. The end result is likely a &quot;blue screen of death&quot; as the program failed to deal with some unanticipated error.</source>
          <target state="translated">Хуже того,хороший код обработки ошибок сам по себе склонен к ошибкам,имеет тенденцию быть наименее проверенной (и,следовательно,ошибочной)частью проекта,и часто просто пропускается.Конечный результат,скорее всего,&quot;голубой экран смерти&quot;,так как программа не справилась с какой-то неожиданной ошибкой.</target>
        </trans-unit>
        <trans-unit id="fd3204ba4b70213492f01a9c5c68e7ab2ed1ff96" translate="yes" xml:space="preserve">
          <source>EvenChunks!Source &lt;strong id=&quot;evenChunks&quot;&gt;evenChunks&lt;/strong&gt;(Source)(Source source, size_t chunkCount)</source>
          <target state="translated">EvenChunks! Source &lt;strong id=&quot;evenChunks&quot;&gt;EvenChunks&lt;/strong&gt; (Источник) (Исходный источник, size_t chunkCount)</target>
        </trans-unit>
        <trans-unit id="a4a0cc71be8cf518b622bbb5bc79c5bc5de1b789" translate="yes" xml:space="preserve">
          <source>Eventually, the attacker is able to determine the first character in the correct token because the sever takes slightly longer to return a rejection. This is due to the comparison moving on to second item in the two arrays, seeing they are different, and then sending the rejection.</source>
          <target state="translated">В конце концов,атакующий способен определить первый символ в правильной маркере,так как разрыв занимает немного больше времени,чтобы вернуть отказ.Это связано с тем,что при сравнении переходят ко второму элементу в двух массивах,видя,что они разные,и затем посылают отказ.</target>
        </trans-unit>
        <trans-unit id="f00b8f841e4cef948de65d22226c93fa103650fa" translate="yes" xml:space="preserve">
          <source>Every data logged to this &lt;code&gt;MultiLogger&lt;/code&gt; will be distributed to all the &lt;code&gt;Logger&lt;/code&gt;s inserted into it. This &lt;code&gt;MultiLogger&lt;/code&gt; implementation can hold multiple &lt;code&gt;Logger&lt;/code&gt;s with the same name. If the method &lt;code&gt;removeLogger&lt;/code&gt; is used to remove a &lt;code&gt;Logger&lt;/code&gt; only the first occurrence with that name will be removed.</source>
          <target state="translated">Каждые данные регистрируемые в этом &lt;code&gt;MultiLogger&lt;/code&gt; будет распространяться на весь &lt;code&gt;Logger&lt;/code&gt; с вставленной в него. Эта реализация &lt;code&gt;MultiLogger&lt;/code&gt; может содержать несколько &lt;code&gt;Logger&lt;/code&gt; с одним и тем же именем. Если метод &lt;code&gt;removeLogger&lt;/code&gt; используется для удаления &lt;code&gt;Logger&lt;/code&gt; , будет удалено только первое вхождение с таким именем.</target>
        </trans-unit>
        <trans-unit id="4e61dc390abff2fed88336a14c32d2472d4eb8ec" translate="yes" xml:space="preserve">
          <source>Every log message with a &lt;code&gt;LogLevel&lt;/code&gt; lower as the global &lt;code&gt;LogLevel&lt;/code&gt; will be discarded before it reaches &lt;code&gt;writeLogMessage&lt;/code&gt; method of any &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Каждое сообщение журнала с &lt;code&gt;LogLevel&lt;/code&gt; ниже глобального &lt;code&gt;LogLevel&lt;/code&gt; будет отброшено до того, как оно достигнет метода &lt;code&gt;writeLogMessage&lt;/code&gt; любого &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="299691262b0966820ccb1f9ef81cef23f22ecbaf" translate="yes" xml:space="preserve">
          <source>Every subclass of &lt;code&gt;Logger&lt;/code&gt; has to call this constructor from their constructor. It sets the &lt;code&gt;LogLevel&lt;/code&gt;, and creates a fatal handler. The fatal handler will throw an &lt;code&gt;Error&lt;/code&gt; if a log call is made with level &lt;code&gt;LogLevel.fatal&lt;/code&gt;.</source>
          <target state="translated">Каждый подкласс &lt;code&gt;Logger&lt;/code&gt; должен вызывать этот конструктор из своего конструктора. Он устанавливает &lt;code&gt;LogLevel&lt;/code&gt; и создает фатальный обработчик. Фатальный обработчик выдаст &lt;code&gt;Error&lt;/code&gt; если вызов журнала сделан с уровнем &lt;code&gt;LogLevel.fatal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6bc748f9fbc0549e63a017cd5636a311c15fde2" translate="yes" xml:space="preserve">
          <source>Every symbol, type, and expression has properties that can be queried:</source>
          <target state="translated">Каждый символ,тип и выражение имеет свойства,которые могут быть опрашиваемы:</target>
        </trans-unit>
        <trans-unit id="b71e20220eb46bc48ab7853c8f64b255dfcc7b90" translate="yes" xml:space="preserve">
          <source>Exact Alias</source>
          <target state="translated">Точный псевдоним</target>
        </trans-unit>
        <trans-unit id="8659b6d121f9dcc98345ea85f4be6011035d4e4c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n - 1&lt;/code&gt; comparisons are needed.</source>
          <target state="translated">Требуется ровно &lt;code&gt;n - 1&lt;/code&gt; сравнений.</target>
        </trans-unit>
        <trans-unit id="447595f030e16a9c11484fc6f4099975f890557c" translate="yes" xml:space="preserve">
          <source>Examine function signature for parameter p and see if the value of p can 'escape' the scope of the function. This is useful to minimize the needed annotations for the parameters.</source>
          <target state="translated">Изучите сигнатуру функции для параметра p и посмотрите,может ли значение p &quot;выходить&quot; из области действия функции.Это полезно для минимизации необходимых примечаний к параметрам.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3a8d7c39720f8b36996668ba6047e485a42fa9dc" translate="yes" xml:space="preserve">
          <source>Example for reading an existing zip archive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c98a62db0de4db40cb83954f78ce2a6a8b61f57" translate="yes" xml:space="preserve">
          <source>Example for writing files into a zip archive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57552c19fd7d2da63a30f68727e3bb36eb45b21" translate="yes" xml:space="preserve">
          <source>Example from &quot;Introduction to Algorithms&quot; Cormen et al, p 146</source>
          <target state="translated">Пример из &quot;Введения в алгоритмы&quot; Кормен с соавторами,стр.146</target>
        </trans-unit>
        <trans-unit id="71d13cfc872d9ac46d96e5966fcea949405ebbc4" translate="yes" xml:space="preserve">
          <source>Example of a simple program printing its stack trace</source>
          <target state="translated">Пример простой программы,печатающей свою трассу стека</target>
        </trans-unit>
        <trans-unit id="529363f48295f0e991d2c61b1b24a9fe1aecfa01" translate="yes" xml:space="preserve">
          <source>Example predicate that compares individual elements in reverse lexical order</source>
          <target state="translated">Пример предиката,который сравнивает отдельные элементы в обратном лексическом порядке</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="3ac96cc54ccaf408a3aa9265ec618b7d8d9688f3" translate="yes" xml:space="preserve">
          <source>Example using a custom predicate. Note that the needle appears as the second argument of the predicate.</source>
          <target state="translated">Пример использования пользовательского предиката.Обратите внимание,что в качестве второго аргумента предиката выступает игла.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7c5d41ac96fe781891640f2cc6ae31d7dac093fe" translate="yes" xml:space="preserve">
          <source>Example: in the expression &lt;code&gt;((f() * 2 &amp;amp;&amp;amp; g()) + 1) || h()&lt;/code&gt;, the smallest short-circuit expression of the subexpression &lt;code&gt;f() * 2&lt;/code&gt; is &lt;code&gt;f() * 2 &amp;amp;&amp;amp; g()&lt;/code&gt;. In the expression &lt;code&gt;(f() &amp;amp;&amp;amp; g()) + h()&lt;/code&gt;, the subexpression &lt;code&gt;h()&lt;/code&gt; has no smallest short-circuit expression.</source>
          <target state="translated">Пример: в выражении &lt;code&gt;((f() * 2 &amp;amp;&amp;amp; g()) + 1) || h()&lt;/code&gt; , наименьшее выражение короткого замыкания подвыражения &lt;code&gt;f() * 2&lt;/code&gt; есть &lt;code&gt;f() * 2 &amp;amp;&amp;amp; g()&lt;/code&gt; . В выражении &lt;code&gt;(f() &amp;amp;&amp;amp; g()) + h()&lt;/code&gt; подвыражение &lt;code&gt;h()&lt;/code&gt; не имеет наименьшего выражения короткого замыкания.</target>
        </trans-unit>
        <trans-unit id="3b6e410f2f289a8e54fbc074511ef251ffbf64e5" translate="yes" xml:space="preserve">
          <source>Example: in the statement &lt;code&gt;return f() + g() * 2;&lt;/code&gt;, the full expression of &lt;code&gt;g() * 2&lt;/code&gt; is &lt;code&gt;f() + g() * 2&lt;/code&gt;, but not the full expression of &lt;code&gt;f() + g()&lt;/code&gt; because the latter is not parsed as a subexpression.</source>
          <target state="translated">Пример: в операторе &lt;code&gt;return f() + g() * 2;&lt;/code&gt; полное выражение функции &lt;code&gt;g() * 2&lt;/code&gt; - это &lt;code&gt;f() + g() * 2&lt;/code&gt; , но не полное выражение функции &lt;code&gt;f() + g()&lt;/code&gt; поскольку последнее не анализируется как подвыражение).</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2b57735b929f758540f6f204a80a85ed5455f140" translate="yes" xml:space="preserve">
          <source>Exception Flags</source>
          <target state="translated">Исключительные флаги</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">Обработка исключений</target>
        </trans-unit>
        <trans-unit id="8e3da5af2290e454a8dda9f1e0d4340536bda871" translate="yes" xml:space="preserve">
          <source>Exception allocation, cloning, and release compiler support routines.</source>
          <target state="translated">Распределение исключений,клонирование и процедуры поддержки компилятора выпуска.</target>
        </trans-unit>
        <trans-unit id="fffb66a488035e580bbe4d9dfb0563a4cf976029" translate="yes" xml:space="preserve">
          <source>Exception containing the row and column for when an exception was thrown.</source>
          <target state="translated">Исключение,содержащее строку и столбец для случая,когда было брошено исключение.</target>
        </trans-unit>
        <trans-unit id="04ccd57adc7199b9320005b31e59d240c692ae76" translate="yes" xml:space="preserve">
          <source>Exception handling is done with the try-catch-finally statement.</source>
          <target state="translated">Исключения обрабатываются с помощью заявления о попытке поймать финал.</target>
        </trans-unit>
        <trans-unit id="5dd8fbbbac9a5ffa8a85c3407866002bfd2a943a" translate="yes" xml:space="preserve">
          <source>Exception handling is supported. Evaluates to &lt;code&gt;false&lt;/code&gt; when compiling with command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">Обработка исключений поддерживается. Оценивает в &lt;code&gt;false&lt;/code&gt; при компиляции с параметром командной строки &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7977347a7a7188c09ab63d88a93b935cd78760c4" translate="yes" xml:space="preserve">
          <source>Exception handling method</source>
          <target state="translated">Метод обработки исключений</target>
        </trans-unit>
        <trans-unit id="989c0eb85b5a41ecfef7a4557f1cdced37ec6bb0" translate="yes" xml:space="preserve">
          <source>Exception handling stack unwinding is a relatively slow process.</source>
          <target state="translated">Размотка стека является относительно медленным процессом.</target>
        </trans-unit>
        <trans-unit id="d5701a5b5f69ab1f2d7097d5d051b3d32981e410" translate="yes" xml:space="preserve">
          <source>Exception handling support for Dwarf-style portable exceptions.</source>
          <target state="translated">Поддержка исключений для портативных исключений в стиле гномов.</target>
        </trans-unit>
        <trans-unit id="9829d9ff9d8698ea752a98d4a92c4ea756a83270" translate="yes" xml:space="preserve">
          <source>Exception if it fails.</source>
          <target state="translated">Исключение,если не получится.</target>
        </trans-unit>
        <trans-unit id="a3fa8f21629b3a2bb2c1e659bd0f396554feda8e" translate="yes" xml:space="preserve">
          <source>Exception if there is an error while parsing the given XML.</source>
          <target state="translated">Исключение,если при разборе заданного XML возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="04d466ab829f02b64659284da536680cd0cead15" translate="yes" xml:space="preserve">
          <source>Exception interoperability is a work in progress.</source>
          <target state="translated">Исключительная интероперабельность-это работа,которая еще не закончена.</target>
        </trans-unit>
        <trans-unit id="ac3a987430d7002abc0aeb021e7b76ae195d4418" translate="yes" xml:space="preserve">
          <source>Exception object thrown in case of errors during regex compilation.</source>
          <target state="translated">Объект исключения,брошенный в случае ошибок при компиляции регексов.</target>
        </trans-unit>
        <trans-unit id="d3b36ed4e90f7895ab9c1f841d81e354fcc19912" translate="yes" xml:space="preserve">
          <source>Exception thrown for file I/O errors.</source>
          <target state="translated">Исключение,брошенное для ошибок файлового ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="cb3e9f844a01a0b96967f3dd6a290735d00840ed" translate="yes" xml:space="preserve">
          <source>Exception thrown on HTTP request failures, e.g. 404 Not Found.</source>
          <target state="translated">Исключение,брошенное при сбоях HTTP-запроса,например,404 Not Found.</target>
        </trans-unit>
        <trans-unit id="bfe22b35920246b957f97d99d530bac8696b368e" translate="yes" xml:space="preserve">
          <source>Exception thrown on JSON errors</source>
          <target state="translated">Исключение,брошенное на ошибки JSON</target>
        </trans-unit>
        <trans-unit id="a84a6e62adad93da512146dbeb0d45a3dc267b49" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.net.curl functions.</source>
          <target state="translated">Исключение,брошенное на ошибки в функциях std.net.curl.</target>
        </trans-unit>
        <trans-unit id="253a6febbe3430c64130d06fa5981a03478c1db8" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.string functions.</source>
          <target state="translated">Исключение,брошенное на ошибки в функциях std.string.</target>
        </trans-unit>
        <trans-unit id="da2cac7a810249d2d11cee22b4057ecee00f3eee" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.utf functions.</source>
          <target state="translated">Исключение,брошенное на ошибки в функциях std.utf.</target>
        </trans-unit>
        <trans-unit id="8b5a2ac6072f2d36ac52160e487df22a74f63da3" translate="yes" xml:space="preserve">
          <source>Exception thrown on timeout errors in std.net.curl functions.</source>
          <target state="translated">Исключение,брошенное по ошибкам таймаута в функциях std.net.curl.</target>
        </trans-unit>
        <trans-unit id="5a4bbb2d3d63ddeb86708dd8ce427adf6b7d165d" translate="yes" xml:space="preserve">
          <source>Exception thrown under different conditions based on the type of &lt;code&gt; Contents&lt;/code&gt;.</source>
          <target state="translated">Исключение выдается при различных условиях в зависимости от типа &lt;code&gt; Contents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b352a0dfd2cdf2adffdd6d799e3b32a8a9e3145" translate="yes" xml:space="preserve">
          <source>Exception thrown upon encountering Base64 encoding or decoding errors.</source>
          <target state="translated">Исключение,брошенное при столкновении с ошибками кодирования или декодирования Base64.</target>
        </trans-unit>
        <trans-unit id="66069ad3e21b6e2e8b6ef96e5b841bffb3ffeb38" translate="yes" xml:space="preserve">
          <source>Exception thrown when a Token is identified to not be completed: a quote is found in an unquoted field, data continues after a closing quote, or the quoted field was not closed before data was empty.</source>
          <target state="translated">Исключение,брошенное,когда Жетон определен как незавершенный:котировка найдена в некотируемом поле,данные продолжаются после закрывающей котировки,или котируемое поле не было закрыто до того,как данные были пустыми.</target>
        </trans-unit>
        <trans-unit id="905fb856166761ef9b7e30ba12340557f71b5efe" translate="yes" xml:space="preserve">
          <source>Exception type thrown upon any failure.</source>
          <target state="translated">Тип исключения выбрасывается при любой неудаче.</target>
        </trans-unit>
        <trans-unit id="f1d0d4844845d6b370b77234d0e77115c51b19af" translate="yes" xml:space="preserve">
          <source>Exception type to throw if the value evaluates to false.</source>
          <target state="translated">Тип исключения,который нужно бросить,если значение оценки ложно.</target>
        </trans-unit>
        <trans-unit id="f928a890db6dee56e7f09963fd1b5750c95236a4" translate="yes" xml:space="preserve">
          <source>Exception type used by core.time.</source>
          <target state="translated">Тип исключения,используемый по времени ядра.</target>
        </trans-unit>
        <trans-unit id="653b9fe3f50eddc9f59c435dd81774a198a4bfb2" translate="yes" xml:space="preserve">
          <source>Exception type used by std.datetime. It's an alias to &lt;a href=&quot;core_time#TimeException&quot;&gt;&lt;code&gt;core.time.TimeException&lt;/code&gt;&lt;/a&gt;. Either can be caught without concern about which module it came from.</source>
          <target state="translated">Тип исключения, используемый std.datetime. Это псевдоним для &lt;a href=&quot;core_time#TimeException&quot;&gt; &lt;code&gt;core.time.TimeException&lt;/code&gt; &lt;/a&gt; . Либо можно поймать, не беспокоясь о том, с какого модуля он пришел.</target>
        </trans-unit>
        <trans-unit id="15839feb51f6c7eb57eb20c2122df74004e3811b" translate="yes" xml:space="preserve">
          <source>ExceptionHeader to free</source>
          <target state="translated">ИсключениеГидер на свободе</target>
        </trans-unit>
        <trans-unit id="668deca20711f80b1c2101115452f3a6ad56520b" translate="yes" xml:space="preserve">
          <source>ExceptionHeader* &lt;code&gt;eh&lt;/code&gt;</source>
          <target state="translated">ExceptionHeader * &lt;code&gt;eh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="787a8beff59b551fcef4298de1a9187c800df51d" translate="yes" xml:space="preserve">
          <source>Exchange &lt;code&gt;exchangeWith&lt;/code&gt; with the memory referenced by &lt;code&gt;here&lt;/code&gt;. This operation is both lock-free and atomic.</source>
          <target state="translated">Обмен &lt;code&gt;exchangeWith&lt;/code&gt; с памятью, на которую ссылается &lt;code&gt;here&lt;/code&gt; . Эта операция является свободной от блокировки и атомарной.</target>
        </trans-unit>
        <trans-unit id="947665622c6a0247540f1769e4059f113b774915" translate="yes" xml:space="preserve">
          <source>Execute and wait for completion, collect output</source>
          <target state="translated">Выполнить и ждать завершения,собрать вывод</target>
        </trans-unit>
        <trans-unit id="9c247b36eae520ff5acf986006d217ce9ca4609a" translate="yes" xml:space="preserve">
          <source>Execute any unittests present. For each that fails, print the stack trace and continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf71057cfbf7879eaf07dde87aff1966a094423" translate="yes" xml:space="preserve">
          <source>Executed expressions may not reference any global or local static variables.</source>
          <target state="translated">Выполняемые выражения не могут ссылаться на глобальные или локальные статические переменные.</target>
        </trans-unit>
        <trans-unit id="6f05efa3a0f330761f283964056bd4c437269064" translate="yes" xml:space="preserve">
          <source>Executes and returns one of a collection of handlers based on the type of the switch object.</source>
          <target state="translated">Выполняет и возвращает одну из коллекций обработчиков в зависимости от типа объекта переключателя.</target>
        </trans-unit>
        <trans-unit id="b2e599dd9da60b7076bf647f704ce6535a25f893" translate="yes" xml:space="preserve">
          <source>Executes the given program or shell command and returns its exit code and output.</source>
          <target state="translated">Выполняет данную программу или команду оболочки и возвращает ее код выхода и вывод.</target>
        </trans-unit>
        <trans-unit id="67781825ef8399fa41b8bb55aee1e69bf3a817d6" translate="yes" xml:space="preserve">
          <source>Executes the supplied function in a new logical thread represented by &lt;code&gt;Tid&lt;/code&gt;. The calling thread is designated as the owner of the new thread. When the owner thread terminates an &lt;code&gt;OwnerTerminated&lt;/code&gt; message will be sent to the new thread, causing an &lt;code&gt;OwnerTerminated&lt;/code&gt; exception to be thrown on &lt;code&gt;receive()&lt;/code&gt;.</source>
          <target state="translated">Выполняет предоставленную функцию в новом логическом потоке, представленном &lt;code&gt;Tid&lt;/code&gt; . Вызывающий поток назначается владельцем нового потока. Когда поток владельца завершается, в новый поток будет отправлено сообщение &lt;code&gt;OwnerTerminated&lt;/code&gt; , в результате чего при &lt;code&gt;receive()&lt;/code&gt; будет &lt;code&gt;OwnerTerminated&lt;/code&gt; исключение OwnerTeridity .</target>
        </trans-unit>
        <trans-unit id="89a3e381c5ed655eb3aa0b9b587d8ce12bdc9bba" translate="yes" xml:space="preserve">
          <source>Executes the supplied function in a new logical thread represented by Tid. This new thread is linked to the calling thread so that if either it or the calling thread terminates a LinkTerminated message will be sent to the other, causing a LinkTerminated exception to be thrown on receive(). The owner relationship from spawn() is preserved as well, so if the link between threads is broken, owner termination will still result in an OwnerTerminated exception to be thrown on receive().</source>
          <target state="translated">Выполняет поставленную функцию в новом логическом потоке,представленном Tid.Этот новый поток связан с вызывающим потоком так,что если либо он,либо вызывающий поток завершает работу,то сообщение LinkTerminated будет отправлено другому,что вызовет бросание исключения LinkTerminated в функцию receive().Отношение владельца из функции spawn()также сохраняется,так что если связь между потоками нарушена,то завершение работы владельца все равно приведет к тому,что исключение OwnerTerminated будет брошено на функцию receive().</target>
        </trans-unit>
        <trans-unit id="9a3ee996ad5df75a0a1bb42a960cc73553d41928" translate="yes" xml:space="preserve">
          <source>Executing functions via CTFE can take considerably longer than executing it at run time. If the function goes into an infinite loop, it will hang at compile time (rather than hanging at run time).</source>
          <target state="translated">Выполнение функций через CTFE может занять значительно больше времени,чем выполнение во время выполнения.Если функция перейдет в бесконечный цикл,то во время компиляции (а не во время выполнения)она будет зависать.</target>
        </trans-unit>
        <trans-unit id="b3ad6d830cba01933bdd4eadf0962b5afcdb48bf" translate="yes" xml:space="preserve">
          <source>Execution of a single thread on thread-local and immutable memory locations is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3292962bd3ae1aa2ceee38161b97042acb69b4" translate="yes" xml:space="preserve">
          <source>Expand alias this tuples.</source>
          <target state="translated">Расширьте псевдоним,как этот кортеж.</target>
        </trans-unit>
        <trans-unit id="dfc518ef6c3dabb73461eac4a36f80d62e55ffe4" translate="yes" xml:space="preserve">
          <source>Expand any response files in command line. Response files are arguments that look like: @NAME The name is first searched for in the environment. If it is not there, it is searched for as a file name. Arguments are separated by spaces, tabs, or newlines. These can be imbedded within arguments by enclosing the argument in '' or &quot;&quot;. Recursively expands nested response files.</source>
          <target state="translated">Разверните все ответные файлы в командной строке.Ответные файлы-это аргументы,которые выглядят так:@NAME Имя сначала ищется в окружении.Если его нет,поиск выполняется как имя файла.Аргументы разделяются пробелами,вкладками или новыми строками.Их можно вписать в аргументы,заключив аргумент в '' или &quot;&quot;.Рекурсивно расширяет вложенные файлы ответа.</target>
        </trans-unit>
        <trans-unit id="39c5e7d251d329155aba4b991a2b7a09613fc576" translate="yes" xml:space="preserve">
          <source>Expand tuples.</source>
          <target state="translated">Расширить кортежи.</target>
        </trans-unit>
        <trans-unit id="308231a343f14ac3d5860b3570b1a37c81713ba1" translate="yes" xml:space="preserve">
          <source>Expanded Data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ed1860547be833e11502cb37798024cc995fdb" translate="yes" xml:space="preserve">
          <source>Expands &lt;code&gt;b&lt;/code&gt; by &lt;code&gt;delta&lt;/code&gt; bytes. If &lt;code&gt;delta == 0&lt;/code&gt;, succeeds without changing &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b is null&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt; (the null pointer cannot be expanded in place). Otherwise, &lt;code&gt;b&lt;/code&gt; must be a buffer previously allocated with the same allocator. If expansion was successful, &lt;code&gt;expand&lt;/code&gt; changes &lt;code&gt;b&lt;/code&gt;'s length to &lt;code&gt;b.length + delta&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Upon failure, the call effects no change upon the allocator object, leaves &lt;code&gt;b&lt;/code&gt; unchanged, and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Расширяет &lt;code&gt;b&lt;/code&gt; на &lt;code&gt;delta&lt;/code&gt; байты. Если &lt;code&gt;delta == 0&lt;/code&gt; , успешно без изменения &lt;code&gt;b&lt;/code&gt; . Если &lt;code&gt;b is null&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; (нулевой указатель не может быть развернут на месте). В противном случае &lt;code&gt;b&lt;/code&gt; должен быть буфером, ранее выделенным с тем же распределителем. Если расширение было успешным, &lt;code&gt;expand&lt;/code&gt; изменяет длину &lt;code&gt;b&lt;/code&gt; на &lt;code&gt;b.length + delta&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; . При сбое вызов не влияет на объект-распределитель, оставляет &lt;code&gt;b&lt;/code&gt; неизменным и возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2b86b700bfa590be9e2b589c48ee8ac8959eaae" translate="yes" xml:space="preserve">
          <source>Expands a memory block in place and returns &lt;code&gt;true&lt;/code&gt; if successful. Implementations that don't support this primitive should always return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Расширяет блок памяти на месте и возвращает &lt;code&gt;true&lt;/code&gt; в случае успеха. Реализации, которые не поддерживают этот примитив, всегда должны возвращать &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b262eee9273f1fc433f6691461d187672e0c5b45" translate="yes" xml:space="preserve">
          <source>Expands an allocated block in place. Expansion will succeed only if the block is the last allocated.</source>
          <target state="translated">Расширяет выделенный блок на месте.Расширение будет успешным только в том случае,если блок будет последним выделенным.</target>
        </trans-unit>
        <trans-unit id="626d5a99aecb87499fb1f3a504d6e69914d2e4c6" translate="yes" xml:space="preserve">
          <source>Expands an allocated block in place. Expansion will succeed only if the block is the last allocated. Defined only if &lt;code&gt;growDownwards&lt;/code&gt; is &lt;code&gt;No.growDownwards&lt;/code&gt;.</source>
          <target state="translated">Расширяет выделенный блок на месте. Расширение будет успешным, только если блок выделен последним. Определяется, только если &lt;code&gt;growDownwards&lt;/code&gt; - это &lt;code&gt;No.growDownwards&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb2e7f8c65f285e69f36d6abb516fbfe712839e3" translate="yes" xml:space="preserve">
          <source>Expands attribute declarations in members in depth first order. Calls dg(size_t symidx, Dsymbol *sym) for each member. If dg returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</source>
          <target state="translated">Глубоко расширяет объявления атрибутов в членах в первом порядке.Вызывает dg(size_t symidx,Dsymbol *sym)для каждого члена.Если dg возвращает !=0,то останавливается и возвращает это значение,иначе возвращает 0.Используйте эту функцию,чтобы избежать O(N+N^2/2)сложности вычисления дим и вызова N раз getNth.</target>
        </trans-unit>
        <trans-unit id="084a0336b3e0fa1cfbc75a4e2da9be624da8ae6d" translate="yes" xml:space="preserve">
          <source>Expands in place a buffer previously allocated by &lt;code&gt;BitmappedBlock&lt;/code&gt;. If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, the expansion fails if the new length exceeds &lt;code&gt;theBlockSize&lt;/code&gt;.</source>
          <target state="translated">Расширяет на месте буфер, ранее выделенный &lt;code&gt;BitmappedBlock&lt;/code&gt; . Если &lt;code&gt;No.multiblock&lt;/code&gt; экземпляр No.multiblock , расширение завершается неудачно, если новая длина превышает &lt;code&gt;theBlockSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="797c11627b7043dd4bdb15c59a63cf420baa3b9d" translate="yes" xml:space="preserve">
          <source>Expands in place a buffer previously allocated by &lt;code&gt;SharedBitmappedBlock&lt;/code&gt;. Expansion fails if the new length exceeds the block size.</source>
          <target state="translated">Расширяет на месте буфер, ранее выделенный &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; . Расширение не выполняется, если новая длина превышает размер блока.</target>
        </trans-unit>
        <trans-unit id="34de05ada292b06170f1d6656265bf476c629815" translate="yes" xml:space="preserve">
          <source>Expands or shrinks allocated block to an allocated size of &lt;code&gt; goodAllocSize(s)&lt;/code&gt;. Expansion occurs in place under the conditions required by &lt;code&gt;expand&lt;/code&gt;. Shrinking occurs in place if &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt;.</source>
          <target state="translated">Расширяет или уменьшает выделенный блок до выделенного размера &lt;code&gt; goodAllocSize(s)&lt;/code&gt; . Расширение происходит на месте в условиях, необходимых для &lt;code&gt;expand&lt;/code&gt; . Сжатие происходит на месте, если &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ede9dbe92d17709e10217ef41b4cbf32ac479af" translate="yes" xml:space="preserve">
          <source>Expands the interval backwards in time. Effectively, it does &lt;code&gt;begin -= duration&lt;/code&gt;.</source>
          <target state="translated">Увеличивает интервал назад во времени. По сути, это &lt;code&gt;begin -= duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b57a74d337ac5a259427e1f3ea04c84032512812" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it adds the given number of months/years to end.</source>
          <target state="translated">Расширяет интервал во времени вперед и/или назад.По сути,он добавляет заданное количество месяцев/лет до конца.</target>
        </trans-unit>
        <trans-unit id="e16a1c93e572148be3e3c1e14d575c1803a317a6" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it does &lt;code&gt;begin -= duration&lt;/code&gt; and/or &lt;code&gt;end += duration&lt;/code&gt;. Whether it expands forwards and/or backwards in time is determined by dir.</source>
          <target state="translated">Увеличивает интервал вперед и / или назад во времени. Фактически, оно &lt;code&gt;begin -= duration&lt;/code&gt; и / или &lt;code&gt;end += duration&lt;/code&gt; . Расширяется ли оно вперед и / или назад во времени, определяется dir.</target>
        </trans-unit>
        <trans-unit id="6115ade81a85a7f10953103eafa7ac7f27f7341b" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from &lt;code&gt;begin&lt;/code&gt; and adds them to &lt;code&gt;end&lt;/code&gt;. Whether it expands forwards and/or backwards in time is determined by dir.</source>
          <target state="translated">Увеличивает интервал вперед и / или назад во времени. По сути, он вычитает заданное количество месяцев / лет от &lt;code&gt;begin&lt;/code&gt; и добавляет их к &lt;code&gt;end&lt;/code&gt; . Расширяется ли оно вперед и / или назад во времени, определяется dir.</target>
        </trans-unit>
        <trans-unit id="8f900e50b202dc7b5f34257efaca3c038012cd3e" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from &lt;code&gt;begin&lt;/code&gt;.</source>
          <target state="translated">Увеличивает интервал вперед и / или назад во времени. По сути, он вычитает заданное количество месяцев / лет от &lt;code&gt;begin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="316269b9bcff090b5279a8dfef454d19bf6429c9" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards in time. Effectively, it does &lt;code&gt;end += duration&lt;/code&gt;.</source>
          <target state="translated">Увеличивает интервал вперед по времени. По сути, это &lt;code&gt;end += duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc5691de73841ad488b58382733ae62e16cc0fbb" translate="yes" xml:space="preserve">
          <source>Expands to a named anchor used for hyperlinking to a particular declaration section. Argument &amp;amp;dollar;1 expands to the qualified declaration name.</source>
          <target state="translated">Расширяется до именованного якоря, используемого для гиперссылки на определенный раздел объявления. Аргумент &amp;amp; доллар; 1 расширяется до квалифицированного имени объявления.</target>
        </trans-unit>
        <trans-unit id="076b445912ca06b9147fd4ce226d6bbff02a82c5" translate="yes" xml:space="preserve">
          <source>Expands tuples in args in depth first order. Calls dg(void *ctx, size_t argidx, Parameter *arg) for each Parameter. If dg returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</source>
          <target state="translated">Расширяет кортежи в аржах в глубину первого порядка.Вызывает dg(void *ctx,size_t argidx,Parameter *arg)для каждого параметра.Если dg возвращает !=0,то останавливается и возвращает это значение,иначе возвращает 0.Используйте эту функцию,чтобы избежать O(N+N^2/2)сложности вычисления дим и вызова N раз getNth.</target>
        </trans-unit>
        <trans-unit id="bcedc51cce47a902790753d67bea2312fe893839" translate="yes" xml:space="preserve">
          <source>Experienced FORTRAN numerics programmers know that multidimensional &quot;rectangular&quot; arrays for things like matrix operations are much faster than trying to access them via pointers to pointers resulting from &quot;array of pointers to array&quot; semantics. For example, the D syntax:</source>
          <target state="translated">Опытные программисты FORTRAN в области нумерологии знают,что многомерные &quot;прямоугольные&quot; массивы для таких вещей,как матричные операции,гораздо быстрее,чем пытаться получить к ним доступ через указатели на указатели,вытекающие из семантики &quot;массив указателей на массив&quot;.Например,синтаксис D:</target>
        </trans-unit>
        <trans-unit id="06490b0b5dc2e6f349a0c0ddde37643f5a5ac75c" translate="yes" xml:space="preserve">
          <source>Experimental network access via the File interface</source>
          <target state="translated">Экспериментальный доступ к сети через Файловый интерфейс</target>
        </trans-unit>
        <trans-unit id="15a7ffb04c4605a09649beb118c20c17de19ede4" translate="yes" xml:space="preserve">
          <source>Explains the return value of the function. If the function returns &lt;b&gt;void&lt;/b&gt;, don't redundantly document it.</source>
          <target state="translated">Объясняет возвращаемое значение функции. Если функция возвращает &lt;b&gt;void&lt;/b&gt; , не излишне документируйте это.</target>
        </trans-unit>
        <trans-unit id="08c2201d6cdd5e0c73a89bc468a1c568ad04f452" translate="yes" xml:space="preserve">
          <source>Explicit Instantiation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20774c9957e71e2e463d16df16c4cfff77b34323" translate="yes" xml:space="preserve">
          <source>Explicit Template Instantiation</source>
          <target state="translated">Явное воплощение шаблона</target>
        </trans-unit>
        <trans-unit id="fbaa54eaab210a4cb9cfc7d9c1378fcdc2b85e52" translate="yes" xml:space="preserve">
          <source>Explicit cast to bool. Useful as a shorthand for !(x.empty) in if and assert statements.</source>
          <target state="translated">Явный слепок.Полезно в качестве сокращения для !(x.empty)в if и утверждениях.</target>
        </trans-unit>
        <trans-unit id="3d8f05eb6d48b04794152e7b23638cae9f48f278" translate="yes" xml:space="preserve">
          <source>Explicit suffixes</source>
          <target state="translated">Явные суффиксы</target>
        </trans-unit>
        <trans-unit id="a78d73b55b840cefe1a0a0daca2e42e60edecac9" translate="yes" xml:space="preserve">
          <source>Exponentiation &amp;amp; Logarithms</source>
          <target state="translated">Экспонирование и логарифмы</target>
        </trans-unit>
        <trans-unit id="1cd8e8a364673d3411b700d793c596d01bc2b145" translate="yes" xml:space="preserve">
          <source>Exposes the given root Array as a standard D array.</source>
          <target state="translated">Выставляет данный корневой массив в виде стандартного массива D.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="124e31831c2789749ceb9147facc91550d3ce84a" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;arg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b421f69102c781d75346243b5587cc88f90fb6" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e0&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;e0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7007fb43c92f8963b348d85ed11e388b0552e1c3" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e1&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;e1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f394df42c68efb7c3038933322adc5a961a6b555" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e60c9324dd44b217718e5d601d55424f1b4789b" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;earg1&lt;/code&gt;</source>
          <target state="translated">Экспрессия &lt;code&gt;earg1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f910b8428605cbf862e3d1bb322d73f52f00aea1" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;elem&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;elem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f2346f54fcfa8df07417dbd8829090b55118464" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;emsg&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;emsg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cbf5e84e80504f53dddbdea7c64954b155cb357" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37aac93cf0d495815e578c5699ff35828cf6f52d" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;feaggr&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;feaggr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a953ed52efeca5916127c7919696beebfa3bd1fc" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;firstArg&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;firstArg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="793cca28c8f3f384b396f7adfd08149a1c0bf195" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;instantiated&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;instantiated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6980b81fee04c7b5a70125a6146240a73039e9" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;original&lt;/code&gt;</source>
          <target state="translated">Выражение &lt;code&gt;original&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0759ebb987367a96a51a5d1b5ffa1b699e18ec08" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;Expression_optimize&quot;&gt;Expression_optimize&lt;/strong&gt;(Expression e, int result, bool keepLvalue);</source>
          <target state="translated">Expression &lt;strong id=&quot;Expression_optimize&quot;&gt;Expression_optimize&lt;/strong&gt; (выражение e, int result, bool keepLvalue);</target>
        </trans-unit>
        <trans-unit id="e7eb0ac731fa465a7e553c45917e50e97836c4c4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;addDtorHook&quot;&gt;addDtorHook&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;addDtorHook&quot;&gt;addDtorHook&lt;/strong&gt; (Scope * sc);</target>
        </trans-unit>
        <trans-unit id="79e7a3e2a6b6bb028e3dee36c35a16bbcac64b57" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;addInvariant&quot;&gt;addInvariant&lt;/strong&gt;(ref const Loc loc, Scope* sc, AggregateDeclaration ad, VarDeclaration vthis);</source>
          <target state="translated">Выражение &lt;strong id=&quot;addInvariant&quot;&gt;addInvariant&lt;/strong&gt; (ref const Loc loc, Scope * sc, объявление AggregateDeclaration, VarDeclaration vthis);</target>
        </trans-unit>
        <trans-unit id="c7de6a20914bd0188b326ef7d4369047d4127694" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;(BinAssignExp e, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt; (BinAssignExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="38cbef71fac259fb3e5addd6010c78720766a7e4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;(BinExp e, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt; (BinExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="d05e7a6332b506aff76d8910b31057f52e8e38f0" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;basis&quot;&gt;basis&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;basis&quot;&gt;Основа&lt;/strong&gt; выражения ;</target>
        </trans-unit>
        <trans-unit id="ce914de3f03e3182cbb394d12e8e44d61e13a1f4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;binSemantic&quot;&gt;binSemantic&lt;/strong&gt;(BinExp e, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;binSemantic&quot;&gt;binSemantic&lt;/strong&gt; (BinExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="07cd4a6028fc596b40b13d6d0458444d8de8c8ab" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;build_overload&quot;&gt;build_overload&lt;/strong&gt;(ref const Loc loc, Scope* sc, Expression ethis, Expression earg, Dsymbol d);</source>
          <target state="translated">Выражение &lt;strong id=&quot;build_overload&quot;&gt;build_overload&lt;/strong&gt; (ref const Loc loc, Scope * sc, Expisis ethis, Expression earg, Dsymbol d);</target>
        </trans-unit>
        <trans-unit id="6871fa1d9cef9535c1f853ab6b02a766a657fbfb" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;castTo&quot;&gt;castTo&lt;/strong&gt;(Expression e, Scope* sc, Type t);</source>
          <target state="translated">Выражение &lt;strong id=&quot;castTo&quot;&gt;castTo&lt;/strong&gt; (Выражение e, Область действия * sc, Тип t);</target>
        </trans-unit>
        <trans-unit id="2b45466acfd0d3d2ded6118c9809d1350d706c46" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;charPromotions&quot;&gt;charPromotions&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;charPromotions&quot;&gt;charPromotions&lt;/strong&gt; (Выражение e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="3411c26ed41d2305da3a489d8bf4719326ae9f77" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;condition&quot;&gt;condition&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;condition&quot;&gt;Условие&lt;/strong&gt; выражения ;</target>
        </trans-unit>
        <trans-unit id="e6931cb91b1ae0e41a9ee765db1152dfb33ce0d4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;ctfeInterpret&quot;&gt;ctfeInterpret&lt;/strong&gt;(Expression e);</source>
          <target state="translated">Выражение &lt;strong id=&quot;ctfeInterpret&quot;&gt;ctfeInterpret&lt;/strong&gt; (Выражение e);</target>
        </trans-unit>
        <trans-unit id="f1f6d0f109e3e21ea56ab0c366d0d61e14ee4c7d" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;defaultInit&quot;&gt;defaultInit&lt;/strong&gt;(Type mt, ref const Loc loc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;defaultInit&quot;&gt;defaultInit&lt;/strong&gt; (Тип mt, ref const Loc loc);</target>
        </trans-unit>
        <trans-unit id="d97a47c0800d46fd3cd2e538e048bb178e515f0c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;defaultInitLiteral&quot;&gt;defaultInitLiteral&lt;/strong&gt;(ref const Loc loc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;defaultInitLiteral&quot;&gt;defaultInitLiteral&lt;/strong&gt; (ref const Loc loc);</target>
        </trans-unit>
        <trans-unit id="0a092a26bbbc3c916453f449b7418f845d33b41c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;doCopyOrMove&quot;&gt;doCopyOrMove&lt;/strong&gt;(Scope* sc, Expression e, Type t = null);</source>
          <target state="translated">Выражение &lt;strong id=&quot;doCopyOrMove&quot;&gt;doCopyOrMove&lt;/strong&gt; (Scope * sc, Выражение e, Тип t = null);</target>
        </trans-unit>
        <trans-unit id="34a3fc99823ccdc5563fe45ca6f4cc54c969827f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;dotExp&quot;&gt;dotExp&lt;/strong&gt;(Type mt, Scope* sc, Expression e, Identifier ident, int flag);</source>
          <target state="translated">Выражение &lt;strong id=&quot;dotExp&quot;&gt;dotExp&lt;/strong&gt; (Тип mt, Область действия * sc, Выражение e, Идентификатор идентификатора, флаг int);</target>
        </trans-unit>
        <trans-unit id="192530034d665cef7795047e56ecf307c8762064" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;eval_builtin&quot;&gt;eval_builtin&lt;/strong&gt;(Loc loc, FuncDeclaration fd, Expressions* arguments);</source>
          <target state="translated">Выражение &lt;strong id=&quot;eval_builtin&quot;&gt;eval_builtin&lt;/strong&gt; (Loc loc, FuncDeclaration fd, Выражения * аргументы);</target>
        </trans-unit>
        <trans-unit id="80a303e71b3ae3f7d7217b7e5618f20dbd2535a9" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt;;</source>
          <target state="translated">Выражение &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6eb2e3ce9ac3932da76f3de31bbf848ad262e34e" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;expandVar&quot;&gt;expandVar&lt;/strong&gt;(int result, VarDeclaration v);</source>
          <target state="translated">Выражение &lt;strong id=&quot;expandVar&quot;&gt;expandVar&lt;/strong&gt; (int, VarDeclaration v);</target>
        </trans-unit>
        <trans-unit id="dfb3029a50e65b9de4b512fbdb1d29b5615172e3" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;extractSideEffect&quot;&gt;extractSideEffect&lt;/strong&gt;(Scope* sc, const char* name, ref Expression e0, Expression e, bool alwaysCopy = false);</source>
          <target state="translated">Выражение &lt;strong id=&quot;extractSideEffect&quot;&gt;extractSideEffect&lt;/strong&gt; (Scope * sc, const char * name, ref Expression e0, Expression e, bool alwaysCopy = false);</target>
        </trans-unit>
        <trans-unit id="efcc60927be71d26c3c816535424c83c4bde8e5a" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getField&quot;&gt;getField&lt;/strong&gt;(Type type, uint offset);</source>
          <target state="translated">Выражение &lt;strong id=&quot;getField&quot;&gt;getField&lt;/strong&gt; (тип type, смещение uint);</target>
        </trans-unit>
        <trans-unit id="5c869349f6aded66c0c7140fab666e82c3d45d29" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getMaxMinValue&quot;&gt;getMaxMinValue&lt;/strong&gt;(ref const Loc loc, Identifier id);</source>
          <target state="translated">Выражение &lt;strong id=&quot;getMaxMinValue&quot;&gt;getMaxMinValue&lt;/strong&gt; (ref const Loc loc, идентификатор идентификатора);</target>
        </trans-unit>
        <trans-unit id="cf05303975b50b18a00371bfbf097a643287e833" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getProperty&quot;&gt;getProperty&lt;/strong&gt;(Type t, ref const Loc loc, Identifier ident, int flag);</source>
          <target state="translated">Выражение &lt;strong id=&quot;getProperty&quot;&gt;getProperty&lt;/strong&gt; (Тип t, ref const Loc loc, Идентификатор идентификатора, флаг int);</target>
        </trans-unit>
        <trans-unit id="1ed9d54715957ffd3217c453236ae0352ea8d40c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getTargetInfo&quot;&gt;getTargetInfo&lt;/strong&gt;(const(char)* name, ref const Loc loc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;getTargetInfo&quot;&gt;getTargetInfo&lt;/strong&gt; (const (char) * name, ref const Loc loc);</target>
        </trans-unit>
        <trans-unit id="a06617afbe33da227ef8899ec1e3a2bf9eda75fc" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getThisSkipNestedFuncs&quot;&gt;getThisSkipNestedFuncs&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, AggregateDeclaration ad, Expression e1, Type t, Dsymbol var, bool flag = false);</source>
          <target state="translated">Выражение &lt;strong id=&quot;getThisSkipNestedFuncs&quot;&gt;getThisSkipNestedFuncs&lt;/strong&gt; (ref const Loc loc, Scope * sc, Dsymbol s, AggregateDeclaration ad, Выражение e1, Тип t, Dsymbol var, bool flag = false);</target>
        </trans-unit>
        <trans-unit id="5182dc71276170cd9c912e2c20da5b0104e0baed" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;identExp&quot;&gt;identExp&lt;/strong&gt;;</source>
          <target state="translated">Выражение &lt;strong id=&quot;identExp&quot;&gt;identExp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6002f1b5688ee38493cb8bf57b584c7ad904867f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;implicitCastTo&quot;&gt;implicitCastTo&lt;/strong&gt;(Expression e, Scope* sc, Type t);</source>
          <target state="translated">Expression &lt;strong id=&quot;implicitCastTo&quot;&gt;implicitCastTo&lt;/strong&gt; (Выражение e, Scope * sc, Тип t);</target>
        </trans-unit>
        <trans-unit id="d9fbd63977c9b0f6b381d61e7486228255c3141c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Expression e, Type t, int flag = 0);</source>
          <target state="translated">Выражение &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt; (Выражение e, Тип t, int flag = 0);</target>
        </trans-unit>
        <trans-unit id="e4eed1230d55b4f7ffdb0f2946ec6b81e685c4d5" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;initializerToExpression&quot;&gt;initializerToExpression&lt;/strong&gt;(Initializer init, Type itype = null);</source>
          <target state="translated">Выражение &lt;strong id=&quot;initializerToExpression&quot;&gt;initializerToExpression&lt;/strong&gt; (инициализатор инициализации, тип itype = null);</target>
        </trans-unit>
        <trans-unit id="9fd9077340336bbdc42e5a0e55ae876cf74bf052" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;inlineCopy&quot;&gt;inlineCopy&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;inlineCopy&quot;&gt;inlineCopy&lt;/strong&gt; (Выражение e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="a93d5e116a77484a91fb6b2216ee9f2c3ab792bc" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;integralPromotions&quot;&gt;integralPromotions&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;integralPromotions&quot;&gt;IntegralPromotions&lt;/strong&gt; (Выражение e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="119f4b90e73b2490c0b337b5c2892ee45abe1b1b" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;op_overload&quot;&gt;op_overload&lt;/strong&gt;(Expression e, Scope* sc, TOK* pop = null);</source>
          <target state="translated">Выражение &lt;strong id=&quot;op_overload&quot;&gt;op_overload&lt;/strong&gt; (Выражение e, Scope * sc, TOK * pop = null);</target>
        </trans-unit>
        <trans-unit id="ce92783572475e6e71bead0fd27548b7a7fa8d60" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveLoc&quot;&gt;resolveLoc&lt;/strong&gt;(ref const Loc loc, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;resolveLoc&quot;&gt;resolLoc&lt;/strong&gt; (ref const Loc loc, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="20d217b5757071adb84549bfb94bd0bc8a5ef317" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;(Scope* sc, ArrayExp ae, Expression* pe0);</source>
          <target state="translated">Выражение &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolOpDollar&lt;/strong&gt; (Scope * sc, ArrayExp ae, Expression * pe0);</target>
        </trans-unit>
        <trans-unit id="35eac18ed0785aafed68f419dd6c566022d1d5a9" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;(Scope* sc, ArrayExp ae, IntervalExp ie, Expression* pe0);</source>
          <target state="translated">Выражение &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolOpDollar&lt;/strong&gt; (Scope * sc, ArrayExp ae, IntervalExp, т.е. Expression * pe0);</target>
        </trans-unit>
        <trans-unit id="24fb0ae31138927857d9517f368cb6748955cf0f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolvePropertiesOnly&quot;&gt;resolvePropertiesOnly&lt;/strong&gt;(Scope* sc, Expression e1);</source>
          <target state="translated">Выражение &lt;strong id=&quot;resolvePropertiesOnly&quot;&gt;resolPropertiesOnly&lt;/strong&gt; (Scope * sc, Expression e1);</target>
        </trans-unit>
        <trans-unit id="9f1dd720666b1ebbdeaf1330037ca49680382277" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveSlice&quot;&gt;resolveSlice&lt;/strong&gt;(Expression e, UnionExp* pue = null);</source>
          <target state="translated">Выражение &lt;strong id=&quot;resolveSlice&quot;&gt;resolSlice&lt;/strong&gt; (Выражение e, UnionExp * pue = null);</target>
        </trans-unit>
        <trans-unit id="399afa038530894af01c66997652832c22521978" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;scaleFactor&quot;&gt;scaleFactor&lt;/strong&gt;(BinExp be, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;scaleFactor&quot;&gt;scaleFactor&lt;/strong&gt; (BinExp be, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="79986118a4e6a934ff5fac083ee5a2d91f44d14e" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;symbolToExp&quot;&gt;symbolToExp&lt;/strong&gt;(Dsymbol s, ref const Loc loc, Scope* sc, bool hasOverloads);</source>
          <target state="translated">Выражение &lt;strong id=&quot;symbolToExp&quot;&gt;symbolToExp&lt;/strong&gt; (Dsymbol s, ref const Loc loc, Scope * sc, bool hasOverloads);</target>
        </trans-unit>
        <trans-unit id="ffc4deb0c336cdfa09b1452db6e63631f5d4122f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toAssocArrayLiteral&quot;&gt;toAssocArrayLiteral&lt;/strong&gt;(ArrayInitializer ai);</source>
          <target state="translated">Выражение &lt;strong id=&quot;toAssocArrayLiteral&quot;&gt;toAssocArrayLiteral&lt;/strong&gt; (ArrayInitializer ai);</target>
        </trans-unit>
        <trans-unit id="c6bce8f2be572a14af244cca194d546909ce6bb7" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toBoolean&quot;&gt;toBoolean&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;toBoolean&quot;&gt;toBoolean&lt;/strong&gt; (Scope * sc);</target>
        </trans-unit>
        <trans-unit id="bdb106e8f5a606a6dce675cd4ddbebbc5666068f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toDelegate&quot;&gt;toDelegate&lt;/strong&gt;(Expression e, Type t, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;toDelegate&quot;&gt;toDelegate&lt;/strong&gt; (Выражение e, Тип t, Область * sc);</target>
        </trans-unit>
        <trans-unit id="6cdc4080dafbc4371980fa1b4330711247ff8eee" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toLvalue&quot;&gt;toLvalue&lt;/strong&gt;(Scope* sc, Expression e);</source>
          <target state="translated">Expression &lt;strong id=&quot;toLvalue&quot;&gt;toLvalue&lt;/strong&gt; (Scope * sc, Expression e);</target>
        </trans-unit>
        <trans-unit id="6c7b6596f94002291db7dced4938937fd23206f2" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;trySemantic&quot;&gt;trySemantic&lt;/strong&gt;(Expression exp, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;trySemantic&quot;&gt;trySemantic&lt;/strong&gt; (Выражение exp, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="2c47e576a24251679ce842e21fa63efaeebfa5ca" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;typeCombine&quot;&gt;typeCombine&lt;/strong&gt;(BinExp be, Scope* sc);</source>
          <target state="translated">&lt;strong id=&quot;typeCombine&quot;&gt;Тип&lt;/strong&gt; выраженияCombine (BinExp be, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="590987c28b7350e9354ffa20860fe52c9ed58235" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;typeToExpression&quot;&gt;typeToExpression&lt;/strong&gt;(Type t);</source>
          <target state="translated">Выражение &lt;strong id=&quot;typeToExpression&quot;&gt;typeToExpression&lt;/strong&gt; (Тип t);</target>
        </trans-unit>
        <trans-unit id="6e7f226bf5b1c59c07426bc48bf791f755e82872" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;unaSemantic&quot;&gt;unaSemantic&lt;/strong&gt;(UnaExp e, Scope* sc);</source>
          <target state="translated">Выражение &lt;strong id=&quot;unaSemantic&quot;&gt;unaSemantic&lt;/strong&gt; (UnaExp e, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="25e7bb0649743e5711f99aca2d79a2a5b5648501" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;valueNoDtor&quot;&gt;valueNoDtor&lt;/strong&gt;(Expression e);</source>
          <target state="translated">Выражение &lt;strong id=&quot;valueNoDtor&quot;&gt;valueNoDtor&lt;/strong&gt; (Выражение e);</target>
        </trans-unit>
        <trans-unit id="bf3f22e25aac5a5716bd2ddc48521dc242830fb5" translate="yes" xml:space="preserve">
          <source>Expression Parser</source>
          <target state="translated">Экспрессионный парсер</target>
        </trans-unit>
        <trans-unit id="d9c4f2202566f51697b377f90555653846292193" translate="yes" xml:space="preserve">
          <source>Expression Statement</source>
          <target state="translated">Заявление о выражении</target>
        </trans-unit>
        <trans-unit id="eabfa2441c13d974e2af574b0d99a70f4bb9a0d6" translate="yes" xml:space="preserve">
          <source>Expression for the requested targetInfo</source>
          <target state="translated">Выражение для запрашиваемой целиИнфо</target>
        </trans-unit>
        <trans-unit id="6063917999bbfe2ce9b3fa075874599a6ebc96e5" translate="yes" xml:space="preserve">
          <source>Expression representing the &lt;code&gt;this&lt;/code&gt; for the var</source>
          <target state="translated">Выражение, представляющее &lt;code&gt;this&lt;/code&gt; для var</target>
        </trans-unit>
        <trans-unit id="df6caa2f45ca5f6946eb55c0501e737ddb8bf27f" translate="yes" xml:space="preserve">
          <source>Expression to convert</source>
          <target state="translated">Выражение в преобразовании</target>
        </trans-unit>
        <trans-unit id="cf9f917167bd00b70d460bca475535ddcbe6fc7e" translate="yes" xml:space="preserve">
          <source>Expression to determine cost of</source>
          <target state="translated">Выражение для определения стоимости</target>
        </trans-unit>
        <trans-unit id="2f055d0b3e4b8725a9090bf4d8f45363b46775b9" translate="yes" xml:space="preserve">
          <source>Expression to look at</source>
          <target state="translated">Выражение,чтобы посмотреть</target>
        </trans-unit>
        <trans-unit id="fbcc420f7af639d45c5081500755a47ce6367c0a" translate="yes" xml:space="preserve">
          <source>Expression which expected as a string</source>
          <target state="translated">Выражение,которое ожидалось как строка</target>
        </trans-unit>
        <trans-unit id="d8e5fdfc95019b0e8b971e0729223c011b90611f" translate="yes" xml:space="preserve">
          <source>Expression* &lt;code&gt;pe&lt;/code&gt;</source>
          <target state="translated">Выражение * &lt;code&gt;pe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7bc014e6d10451a8147b649b688eca472ffab8da" translate="yes" xml:space="preserve">
          <source>Expression[] &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">Выражение [] &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd7feaf7d6885e2aeae1d7088bcce98f228aa60c" translate="yes" xml:space="preserve">
          <source>Expression[] &lt;code&gt;negatives&lt;/code&gt;</source>
          <target state="translated">Выражение [] &lt;code&gt;negatives&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="17b61fb742fe0544a0738e346e8b68266f8e6c2c" translate="yes" xml:space="preserve">
          <source>Expressions and statements may create and/or consume rvalues. Such values are called</source>
          <target state="translated">Выражения и утверждения могут создавать и/или потреблять ценности.Такие значения называются</target>
        </trans-unit>
        <trans-unit id="827d05e6a3f1241aa29022321190716d0bac015a" translate="yes" xml:space="preserve">
          <source>Expressions are used to compute values with a resulting type. These values can then be assigned, tested, or ignored. Expressions can also have side effects.</source>
          <target state="translated">Выражения используются для вычисления значений с результирующим типом.Затем эти значения могут быть присвоены,протестированы или проигнорированы.Выражения также могут иметь побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="213f37939286b76ce58e9d750cb8625a9de8b877" translate="yes" xml:space="preserve">
          <source>Expressions connected by commas</source>
          <target state="translated">Выражения,связанные запятыми</target>
        </trans-unit>
        <trans-unit id="eeda38d97c1591b472912826aeaaf79dee7875cf" translate="yes" xml:space="preserve">
          <source>Expressions of the form &lt;code&gt;a != b&lt;/code&gt; are rewritten as &lt;code&gt;!(a == b)&lt;/code&gt;.</source>
          <target state="translated">Выражения вида &lt;code&gt;a != b&lt;/code&gt; переписываются как &lt;code&gt;!(a == b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9790c7ed767b515e2db3f5032fee145b7d8f3f2d" translate="yes" xml:space="preserve">
          <source>Expressions of the form &lt;code&gt;arr[&lt;/code&gt;</source>
          <target state="translated">Выражения вида &lt;code&gt;arr[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="296ed9970d463ab72dec34118964f9a6a98b21b4" translate="yes" xml:space="preserve">
          <source>Expressions that have no effect, like &lt;code&gt;(x + x)&lt;/code&gt;, are illegal as expression statements unless the are cast to void.</source>
          <target state="translated">Выражения, которые не имеют никакого эффекта, например &lt;code&gt;(x + x)&lt;/code&gt; , являются недопустимыми в качестве выражений выражений, если только они не приведены к типу void.</target>
        </trans-unit>
        <trans-unit id="13135cffec267a2714ee700a44376c037a46555b" translate="yes" xml:space="preserve">
          <source>Expressions that have no effect, like &lt;code&gt;(x + x)&lt;/code&gt;, are illegal as expression statements unless they are cast to void.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9ba85aff37987e9f1d9fafb80136e7c416676a" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;elements&lt;/code&gt;</source>
          <target state="translated">Выражения * &lt;code&gt;elements&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="137b1c280f96de72078b78ad7d25efffd1250b2a" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;exps&lt;/code&gt;</source>
          <target state="translated">Выражения * &lt;code&gt;exps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87db2601150b379b388e1556ff809504a78b747" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;fargs&lt;/code&gt;</source>
          <target state="translated">Выражения * &lt;code&gt;fargs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e0b234b24cbc1fb165bd79fe8e05526407f3b36" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;negatives&lt;/code&gt;</source>
          <target state="translated">Выражения * &lt;code&gt;negatives&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd03daa888a0e583ceb40e2e00dacb30660a10cc" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;elements&quot;&gt;elements&lt;/strong&gt;;</source>
          <target state="translated">Выражения * &lt;strong id=&quot;elements&quot;&gt;элементы&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="37783cf5e7c87b4f591a55d79dbb7ea52f941431" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;fdensureParams&quot;&gt;fdensureParams&lt;/strong&gt;;</source>
          <target state="translated">Выражения * &lt;strong id=&quot;fdensureParams&quot;&gt;fdensureParams&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="026b50f17d896e63ced46249a059380f8e6cbae1" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;fdrequireParams&quot;&gt;fdrequireParams&lt;/strong&gt;;</source>
          <target state="translated">Выражения * &lt;strong id=&quot;fdrequireParams&quot;&gt;fdrequireParams&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b7c9df0f13515170e90ad55a4b53a6f772217b57" translate="yes" xml:space="preserve">
          <source>Extend an array &lt;code&gt;px&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements. Caller must initialize those elements.</source>
          <target state="translated">Расширить массив &lt;code&gt;px&lt;/code&gt; на &lt;code&gt;n&lt;/code&gt; элементов. Вызывающий должен инициализировать эти элементы.</target>
        </trans-unit>
        <trans-unit id="f8d9ec6e863a0af2e6c6f8b6330f856c27efe720" translate="yes" xml:space="preserve">
          <source>Extend an array by n elements. Caller must initialize those elements.</source>
          <target state="translated">Расширить массив на n элементов.Звонящий должен инициализировать эти элементы.</target>
        </trans-unit>
        <trans-unit id="1b5d8573dd5bcf3e6c45847ffd98818bf7ecfc27" translate="yes" xml:space="preserve">
          <source>Extend may also be used to extend slices (or memory blocks with &lt;a href=&quot;#APPENDABLE&quot;&gt;&lt;code&gt;APPENDABLE&lt;/code&gt;&lt;/a&gt; info). However, use the return value only as an indicator of success. &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; should be used to retrieve actual usable slice capacity.</source>
          <target state="translated">Расширение также может использоваться для расширения срезов (или блоков памяти с &lt;a href=&quot;#APPENDABLE&quot;&gt; &lt;code&gt;APPENDABLE&lt;/code&gt; &lt;/a&gt; информацией). Однако используйте возвращаемое значение только как показатель успеха. &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; следует использовать для получения фактической полезной емкости среза.</target>
        </trans-unit>
        <trans-unit id="43ee2587f2dee7414c6f7fffb20316fc7cc9240d" translate="yes" xml:space="preserve">
          <source>Extend the length of the input range &lt;code&gt;r&lt;/code&gt; by padding out the end of the range with the element &lt;code&gt;e&lt;/code&gt;. The element &lt;code&gt;e&lt;/code&gt; must be of a common type with the element type of the range &lt;code&gt;r&lt;/code&gt; as defined by &lt;a href=&quot;std_traits#CommonType&quot;&gt;&lt;code&gt;std.traits.CommonType&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;n&lt;/code&gt; is less than the length of of &lt;code&gt;r&lt;/code&gt;, then the contents of &lt;code&gt;r&lt;/code&gt; are returned.</source>
          <target state="translated">Увеличьте длину входного диапазона &lt;code&gt;r&lt;/code&gt; , дополнив конец диапазона элементом &lt;code&gt;e&lt;/code&gt; . Элемент &lt;code&gt;e&lt;/code&gt; должен иметь общий тип с типом элемента диапазона &lt;code&gt;r&lt;/code&gt; , как определено в &lt;a href=&quot;std_traits#CommonType&quot;&gt; &lt;code&gt;std.traits.CommonType&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;n&lt;/code&gt; меньше длины &lt;code&gt;r&lt;/code&gt; , то возвращается содержимое &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa833620006d2c6c6571801ae931036999a293ae" translate="yes" xml:space="preserve">
          <source>Extend, shrink or allocate a new block of memory keeping the contents of an existing block</source>
          <target state="translated">Расширение,уменьшение или выделение нового блока памяти с сохранением содержимого существующего блока</target>
        </trans-unit>
        <trans-unit id="1f14c54998b149072f5f4807010db7ef4def6435" translate="yes" xml:space="preserve">
          <source>ExtendedModuleUnitTester &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">ExtendedModuleUnitTester &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9b77ddd59e96e949c32c9e07059de1e0868c54d" translate="yes" xml:space="preserve">
          <source>Extender</source>
          <target state="translated">Extender</target>
        </trans-unit>
        <trans-unit id="ca6a41cfa1be0460478758700e28ed97e69b6db4" translate="yes" xml:space="preserve">
          <source>Extends the length of the input range &lt;code&gt;r&lt;/code&gt; by padding out the start of the range with the element &lt;code&gt;e&lt;/code&gt;. The element &lt;code&gt;e&lt;/code&gt; must be of a common type with the element type of the range &lt;code&gt;r&lt;/code&gt; as defined by &lt;a href=&quot;std_traits#CommonType&quot;&gt;&lt;code&gt;std.traits.CommonType&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;n&lt;/code&gt; is less than the length of of &lt;code&gt;r&lt;/code&gt;, then &lt;code&gt;r&lt;/code&gt; is returned unmodified.</source>
          <target state="translated">Расширяет длину входного диапазона &lt;code&gt;r&lt;/code&gt; , дополняя начало диапазона элементом &lt;code&gt;e&lt;/code&gt; . Элемент &lt;code&gt;e&lt;/code&gt; должен иметь общий тип с типом элемента диапазона &lt;code&gt;r&lt;/code&gt; , как определено в &lt;a href=&quot;std_traits#CommonType&quot;&gt; &lt;code&gt;std.traits.CommonType&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;n&lt;/code&gt; меньше длины &lt;code&gt;r&lt;/code&gt; , тогда &lt;code&gt;r&lt;/code&gt; возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="006d500cd51d10312fee9a378180dd1c0dbff085" translate="yes" xml:space="preserve">
          <source>Extension to add (should not include '.')</source>
          <target state="translated">Расширение для добавления (не должно включать '').</target>
        </trans-unit>
        <trans-unit id="6482035493770d2e055c43b47e6d26c77dd6c0ef" translate="yes" xml:space="preserve">
          <source>Extern Declarations</source>
          <target state="translated">Дополнительные декларации</target>
        </trans-unit>
        <trans-unit id="d4c9ef3b0f468eee8df0924f820ebf154b375ffb" translate="yes" xml:space="preserve">
          <source>External functions don't have a function body visible to the compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3748f7f3cb478d80788fa4224db3fc0a78eefd90" translate="yes" xml:space="preserve">
          <source>ExternallyMangledName</source>
          <target state="translated">ExternallyMangledName</target>
        </trans-unit>
        <trans-unit id="346cbbedcd46a1663dd5b1cc744bd9a949537eb2" translate="yes" xml:space="preserve">
          <source>Extra characters were found after the end of the domain literal</source>
          <target state="translated">Дополнительные символы были найдены после буквенного окончания домена.</target>
        </trans-unit>
        <trans-unit id="d5c6615073da0f312632e0d30300116c3bbca0ac" translate="yes" xml:space="preserve">
          <source>Extract Metadata About A Column Of A Table</source>
          <target state="translated">Извлечь метаданные о столбце таблицы</target>
        </trans-unit>
        <trans-unit id="9faa5d876b6179e6ba25ab15280e90240372d01c" translate="yes" xml:space="preserve">
          <source>Extract an integral payload from a NAN.</source>
          <target state="translated">Извлечь из NAN встроенную полезную нагрузку.</target>
        </trans-unit>
        <trans-unit id="2c4b7673b033687b78b5842c4817a13b02fefd97" translate="yes" xml:space="preserve">
          <source>Extract information about types and symbols at compile time.</source>
          <target state="translated">Извлечение информации о типах и символах во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f06fb7685dce7967eb2226a2da1b90f2b56a47a7" translate="yes" xml:space="preserve">
          <source>Extract object previously wrapped by &lt;a href=&quot;#wrap&quot;&gt;&lt;code&gt;wrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Объект Экстракт предварительно обернутый &lt;a href=&quot;#wrap&quot;&gt; &lt;code&gt;wrap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd69f2de6f5ccb7abb3ebb23adba928b9189680b" translate="yes" xml:space="preserve">
          <source>Extracting keys or values from an associative array</source>
          <target state="translated">Извлечение ключей или значений из ассоциативного массива</target>
        </trans-unit>
        <trans-unit id="33b53849a6a696afc1cd80915cbb26c701295344" translate="yes" xml:space="preserve">
          <source>Extracts the exponent of x as a signed integral value.</source>
          <target state="translated">Извлекает экспоненту Х в виде подписанного интегрального значения.</target>
        </trans-unit>
        <trans-unit id="f72287d204f2105b0fd97e600ee98c5cba938ca4" translate="yes" xml:space="preserve">
          <source>Extracts the norm of a complex number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="92e79f4fb4307210226b4892ad6cd4e88db84d8e" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;fn&lt;/code&gt;</source>
          <target state="translated">F &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="193f1d2a7d28460babdd5dae282bd85494298779" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;fp&lt;/code&gt;</source>
          <target state="translated">F &lt;code&gt;fp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24cceb382e88b5a613ffd52b108c408d0048ef0f" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">F &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a08f0857a21894d4669365254c28abd314ff69d5" translate="yes" xml:space="preserve">
          <source>F &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;(F, uint N)(ref scope const F[N] a, ref scope const F[N] b)</source>
          <target state="translated">F &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt; (F, uint N) (ссылка сфера действия con F [N] a, ссылка сфера действия con F [N] b)</target>
        </trans-unit>
        <trans-unit id="2667ca0e687195a6570d57ab0089486c7bee46ff" translate="yes" xml:space="preserve">
          <source>F &lt;strong id=&quot;gapWeightedSimilarity&quot;&gt;gapWeightedSimilarity&lt;/strong&gt;(alias comp = &quot;a == b&quot;, R1, R2, F)(R1 s, R2 t, F lambda)</source>
          <target state="translated">F &lt;strong id=&quot;gapWeightedSimilarity&quot;&gt;gapWeightedS Similarity&lt;/strong&gt; (псевдоним comp = &quot;a == b&quot;, R1, R2, F) (R1 s, R2 t, F лямбда)</target>
        </trans-unit>
        <trans-unit id="fe6176f13577b4b75c6e15efab6754698b9c3bee" translate="yes" xml:space="preserve">
          <source>FE FF</source>
          <target state="translated">ИП ПФ</target>
        </trans-unit>
        <trans-unit id="3e02b936dfd78b3c5ebed8632cb4cc204b3750a2" translate="yes" xml:space="preserve">
          <source>FF FE</source>
          <target state="translated">ФФ ФЭ</target>
        </trans-unit>
        <trans-unit id="c498915b8f02917da6f0c028707f1c34277fe255" translate="yes" xml:space="preserve">
          <source>FF FE 00 00</source>
          <target state="translated">ФФ ФЕ 00 00</target>
        </trans-unit>
        <trans-unit id="d2a0477ef856e83464b14c113e56b5dc50816ccb" translate="yes" xml:space="preserve">
          <source>FILE* &lt;code&gt;stream&lt;/code&gt;</source>
          <target state="translated">ФАЙЛ * &lt;code&gt;stream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2605a67597f1a10f5c96696e2424ee2db911144" translate="yes" xml:space="preserve">
          <source>FILETIME* &lt;code&gt;ft&lt;/code&gt;</source>
          <target state="translated">FILETIME * &lt;code&gt;ft&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="716c88fa55348f124b797e571db1aebe854236a3" translate="yes" xml:space="preserve">
          <source>FIPS PUB180-2</source>
          <target state="translated">ФИПС PUB180-2</target>
        </trans-unit>
        <trans-unit id="1267dff51655e0a3bdc33fc1076bec75984a3f57" translate="yes" xml:space="preserve">
          <source>FLAGS /////////////////////////////////////</source>
          <target state="translated">ФЛАГИ ///////////////////////////////////////////////////</target>
        </trans-unit>
        <trans-unit id="e96a8a604f9b6179e311fa3d5f24abcd71fc841e" translate="yes" xml:space="preserve">
          <source>FNMATCH_FUNCTION user pointer</source>
          <target state="translated">Пользовательский указатель FNMATCH_FUNCTION</target>
        </trans-unit>
        <trans-unit id="cd00fd89694c9543bbff899304d998d7ecf5294f" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!double &lt;strong id=&quot;DoubleProperties&quot;&gt;DoubleProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties! Double &lt;strong id=&quot;DoubleProperties&quot;&gt;DoubleProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="0d8442da2a84281783f8838ad22bc5dbea8b7a72" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!float &lt;strong id=&quot;FloatProperties&quot;&gt;FloatProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties! Float &lt;strong id=&quot;FloatProperties&quot;&gt;FloatProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="f033c2d3e8e972e4ef1768896ccae5d11b59035e" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!real_t &lt;strong id=&quot;RealProperties&quot;&gt;RealProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties! Real_t &lt;strong id=&quot;RealProperties&quot;&gt;RealProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="33526cf6b3de29bbe86a32df97a3317f13177146" translate="yes" xml:space="preserve">
          <source>FP_ILOGB0</source>
          <target state="translated">FP_ILOGB0</target>
        </trans-unit>
        <trans-unit id="3ca2eaac7e96ce045c763f71e8ad21f82a4121ef" translate="yes" xml:space="preserve">
          <source>FP_ILOGBNAN</source>
          <target state="translated">FP_ILOGBNAN</target>
        </trans-unit>
        <trans-unit id="acb28212fba0272ee990cebd571ebe09b463312e" translate="yes" xml:space="preserve">
          <source>FTP</source>
          <target state="translated">FTP</target>
        </trans-unit>
        <trans-unit id="efd9df5bd03a5bb6ecc42cd9b76d43f3c4b84813" translate="yes" xml:space="preserve">
          <source>FTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">FTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="a156047c4af729c2fac38d529049b3b9938c1d8f" translate="yes" xml:space="preserve">
          <source>FTP Option that causes missing dirs to be created on the remote server. In 7.19.4 we introduced the convenience enums for this option using the CURLFTP_CREATE_DIR prefix.</source>
          <target state="translated">FTP Опция,вызывающая создание недостающих dirs на удаленном сервере.В 7.19.4 мы ввели удобные перечисления для этой опции,используя префикс CURLFTP_CREATE_DIR.</target>
        </trans-unit>
        <trans-unit id="fbfe183e82b68040592bf183fc081e933272629b" translate="yes" xml:space="preserve">
          <source>FTP access to the specified url.</source>
          <target state="translated">FTP доступ к указанному url.</target>
        </trans-unit>
        <trans-unit id="79d1ddd73bbfe55930046d43cf864f9b3aca2fb2" translate="yes" xml:space="preserve">
          <source>FTP client functionality.</source>
          <target state="translated">Функциональность FTP-клиента.</target>
        </trans-unit>
        <trans-unit id="296657dabd1e7526b0c3bd8986b54a229ec9f74e" translate="yes" xml:space="preserve">
          <source>FTP option that changes the timeout, in seconds, associated with getting a response. This is different from transfer timeout time and essentially places a demand on the FTP server to acknowledge commands in a timely manner.</source>
          <target state="translated">Опция FTP,которая изменяет таймаут в секундах,связанный с получением ответа.Это отличается от времени таймаута передачи и,по сути,требует от сервера FTP своевременного подтверждения команд.</target>
        </trans-unit>
        <trans-unit id="1e9d5102532c80cabb71bedd22459f048605a2a0" translate="yes" xml:space="preserve">
          <source>FUNCFLAG.xxxxx</source>
          <target state="translated">FUNCFLAG.xxxxx</target>
        </trans-unit>
        <trans-unit id="04a22d510848e72d972438b2303f4bb0f8cefe40" translate="yes" xml:space="preserve">
          <source>F[] &lt;strong id=&quot;uniformDistribution&quot;&gt;uniformDistribution&lt;/strong&gt;(F = double)(size_t n, F[] useThis = null)</source>
          <target state="translated">F [] &lt;strong id=&quot;uniformDistribution&quot;&gt;iformDistribution&lt;/strong&gt; (F = double) (size_t n, F [] useThis = null)</target>
        </trans-unit>
        <trans-unit id="885d20f30c6997f28727cb3b1c03c026a0423304" translate="yes" xml:space="preserve">
          <source>Facilities for random number generation.</source>
          <target state="translated">Удобства для генерации случайных чисел.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="9d80a11d6c9cd9d8129231038cc99dcf9cfe6c31" translate="yes" xml:space="preserve">
          <source>Fails: char[] has mutable aliasing.</source>
          <target state="translated">Ошибки:char[]имеет мутирующее псевдонимы.</target>
        </trans-unit>
        <trans-unit id="7ca23f275cf26c43dc6cb80deec7cc73ebd0d6be" translate="yes" xml:space="preserve">
          <source>Fake a struct symbol.</source>
          <target state="translated">Фальшивый символ структуры.</target>
        </trans-unit>
        <trans-unit id="f92a31e5dc809226adfcdd7266d92ffe4d097f29" translate="yes" xml:space="preserve">
          <source>Fake class which holds the thrown exception. Used for implementing exception handling.</source>
          <target state="translated">Фальшивый класс,в котором есть брошенное исключение.Используется для реализации обработки исключений.</target>
        </trans-unit>
        <trans-unit id="187b6d7e012db85d9f53b228f8b221e037e5b215" translate="yes" xml:space="preserve">
          <source>Fallback &lt;strong id=&quot;fallback&quot;&gt;fallback&lt;/strong&gt;;</source>
          <target state="translated">Резервный &lt;strong id=&quot;fallback&quot;&gt;запасной вариант&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1d00915c3eb36b1f76efd0ec12a2e2bfdb9c88e2" translate="yes" xml:space="preserve">
          <source>FallbackAllocator!(Primary, Fallback) &lt;strong id=&quot;fallbackAllocator&quot;&gt;fallbackAllocator&lt;/strong&gt;(Primary, Fallback)(auto ref Primary p, auto ref Fallback f);</source>
          <target state="translated">FallbackAllocator! (Primary, Fallback) &lt;strong id=&quot;fallbackAllocator&quot;&gt;fallbackAllocator&lt;/strong&gt; (Primary, Fallback) (автоматическая ссылка Primary p, автоматическая ссылка Fallback f);</target>
        </trans-unit>
        <trans-unit id="5d505b3f95c1c85d725f5b643bd03f8f11c638e3" translate="yes" xml:space="preserve">
          <source>Families of transcendental functions.</source>
          <target state="translated">Семьи трансцендентальных функций.</target>
        </trans-unit>
        <trans-unit id="c15afdf4366c1e5e116d4655301026b41771feaa" translate="yes" xml:space="preserve">
          <source>Family of this address.</source>
          <target state="translated">Семья этого адреса.</target>
        </trans-unit>
        <trans-unit id="9784de560abfd12a3df7edbfce43582579bd83ea" translate="yes" xml:space="preserve">
          <source>Fast Alias</source>
          <target state="translated">Быстрый псевдоним</target>
        </trans-unit>
        <trans-unit id="b30639e5d7da09380f8d189ea58cefd7706fb2d8" translate="yes" xml:space="preserve">
          <source>Fast Integer Overflow Checks</source>
          <target state="translated">Быстрые интегральные проверки на переполнение</target>
        </trans-unit>
        <trans-unit id="0b12a136aeae505dcc0b7dbbf0dd96b9dfb9b43f" translate="yes" xml:space="preserve">
          <source>Fast implementation of SHA1</source>
          <target state="translated">Быстрое внедрение SHA1</target>
        </trans-unit>
        <trans-unit id="f52bc5a79d93a586d9fd5f867d9e97fd2c1e94ed" translate="yes" xml:space="preserve">
          <source>Fast power modulus calculation for &lt;a href=&quot;#BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; operands.</source>
          <target state="translated">Быстрый расчет модуля мощности для операндов &lt;a href=&quot;#BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="5e04f2d50cdd060bbfcbfee4c55990dc2c53ebb6" translate="yes" xml:space="preserve">
          <source>Feeds a piece of data into the hash computation. This method allows the type to be used as an &lt;a href=&quot;std_range#OutputRange&quot;&gt;&lt;code&gt;std.range.OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подает часть данных в вычисление хеша. Этот метод позволяет использовать этот тип как &lt;a href=&quot;std_range#OutputRange&quot;&gt; &lt;code&gt;std.range.OutputRange&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef2e953b973aaaad728788af9fe005332250cfb9" translate="yes" xml:space="preserve">
          <source>Fetch a range that spans all the elements in the container.</source>
          <target state="translated">Возьмите диапазон,который охватывает все элементы в контейнере.</target>
        </trans-unit>
        <trans-unit id="806c6077cb7a78f983cf9f3141f3488ff76bfb62" translate="yes" xml:space="preserve">
          <source>Fetch a set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; that have the given hangul syllable type.</source>
          <target state="translated">Получите набор &lt;a href=&quot;#Code%20point&quot;&gt;кодовых точек,&lt;/a&gt; которые имеют данный тип слога хангыль.</target>
        </trans-unit>
        <trans-unit id="f82305ed0f65639966ae3ed3933a92d710f2e1b5" translate="yes" xml:space="preserve">
          <source>Fetches a portion of the container from key &lt;code&gt;a&lt;/code&gt; to key &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Извлекает часть контейнера из ключа &lt;code&gt;a&lt;/code&gt; в ключ &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25fd3d77a2c1246116e41ea65fe998403f8ec08d" translate="yes" xml:space="preserve">
          <source>Fiber which embeds a ThreadInfo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941f1ba20ae720e9df7d97f37ddc2a546949a068" translate="yes" xml:space="preserve">
          <source>Fibonacci numbers, using function in explicit form:</source>
          <target state="translated">Числа Фибоначчи,использующие функцию в явном виде:</target>
        </trans-unit>
        <trans-unit id="d046974a209aaf1dc186931ea0c33a691fda7aee" translate="yes" xml:space="preserve">
          <source>Field Properties</source>
          <target state="translated">Свойства месторождения</target>
        </trans-unit>
        <trans-unit id="107eaaea9a6cf7bffdc6f5831dadf9f4ae6e6dff" translate="yes" xml:space="preserve">
          <source>Field initialization inside a constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc4c6a8400a8c6f02130bcea08f292997d6b9f9" translate="yes" xml:space="preserve">
          <source>Field initialization inside constructor</source>
          <target state="translated">Полевая инициализация внутри конструктора</target>
        </trans-unit>
        <trans-unit id="c5a099fc15efbba12a358705f6143f4d6be98777" translate="yes" xml:space="preserve">
          <source>FieldInit[] &lt;strong id=&quot;fieldinit&quot;&gt;fieldinit&lt;/strong&gt;;</source>
          <target state="translated">FieldInit [] &lt;strong id=&quot;fieldinit&quot;&gt;fieldinit&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="0de912d25f2bf66472286b09fc92107582e1704b" translate="yes" xml:space="preserve">
          <source>Fields are by default initialized to the default initializer for their type (usually 0 for integer types and NAN for floating point types). If the field declaration has an optional &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; that will be used instead of the default.</source>
          <target state="translated">Поля по умолчанию инициализируются инициализатором по умолчанию для их типа (обычно 0 для целочисленных типов и NAN для типов с плавающей запятой). Если в объявлении поля есть дополнительный &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;инициализатор,&lt;/i&gt;&lt;/a&gt; который будет использоваться вместо значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="23cca95a6cdd188e6c7fc8755e8efb38d2d70c0e" translate="yes" xml:space="preserve">
          <source>Fields not specified in the</source>
          <target state="translated">Поля,не указанные в</target>
        </trans-unit>
        <trans-unit id="208ad1de91661d0ad0a36ff8e397f7fa368d919b" translate="yes" xml:space="preserve">
          <source>Fields of &lt;code&gt;extern(Objective-C)&lt;/code&gt; classes have a dynamic offset. That means that the base class can change (add or remove instance variables) without the subclasses needing to recompile or relink.</source>
          <target state="translated">Поля &lt;code&gt;extern(Objective-C)&lt;/code&gt; классов имеют динамическое смещение. Это означает, что базовый класс может изменяться (добавлять или удалять переменные экземпляра) без необходимости перекомпиляции или перекомпоновки подклассов.</target>
        </trans-unit>
        <trans-unit id="853d0fada94e86615dc6538f25f88964cc917132" translate="yes" xml:space="preserve">
          <source>Figure out what is being foreach'd over by looking at the ForeachAggregate.</source>
          <target state="translated">Понять,что происходит,можно,взглянув на ForeachAggregate.</target>
        </trans-unit>
        <trans-unit id="30ce9f687ac35a29ae0ceb7c01a007d763160966" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">Файл &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e98c320744b7f0c7cb60ef318110b857423c138" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">Файл &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f3f2227118512e7ca5c3ada9f680151527105c3" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/a.d&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748ef850240024ab9b9dfd885345924583894351" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/b.d&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3af95125686bb3393a41be2e1f0fecd04615870" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/package.d&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aadfe8f43e9471a7ccd0a6d9513aa2d158d8fc8" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stderr&lt;/code&gt;</source>
          <target state="translated">Файл &lt;code&gt;stderr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2d5fc4ef533b94b6bad75f0391ad7ad10de8f26" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stdin&lt;/code&gt;</source>
          <target state="translated">Файл &lt;code&gt;stdin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e9228910eade205bba9f1037b88441eb129b20" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stdout&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; файл</target>
        </trans-unit>
        <trans-unit id="9483d4c2825aba0712cc0561ced9af3cb73ecdf9" translate="yes" xml:space="preserve">
          <source>File &lt;strong id=&quot;openNetwork&quot;&gt;openNetwork&lt;/strong&gt;(string host, ushort port);</source>
          <target state="translated">Файл &lt;strong id=&quot;openNetwork&quot;&gt;openNetwork&lt;/strong&gt; (строка хоста, порт ushort);</target>
        </trans-unit>
        <trans-unit id="ce4206968eedd48fffee1e859866cc73f7755263" translate="yes" xml:space="preserve">
          <source>File descriptor to associate with this &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e536d6d6e792234f9c45a8b85837120144d1507" translate="yes" xml:space="preserve">
          <source>File name to get times for.</source>
          <target state="translated">Имя файла,чтобы получить время.</target>
        </trans-unit>
        <trans-unit id="593c7807cce6682849c08e792d67a7b54a30c7c5" translate="yes" xml:space="preserve">
          <source>File names are case insensitive</source>
          <target state="translated">Имена файлов не чувствительны к регистру</target>
        </trans-unit>
        <trans-unit id="bba1cee852025b35d3e3478cf86257fa54326950" translate="yes" xml:space="preserve">
          <source>File names are case sensitive</source>
          <target state="translated">Имена файлов чувствительны к регистру</target>
        </trans-unit>
        <trans-unit id="ddde036ce2875cbf396f907c8d72a294c865d6ee" translate="yes" xml:space="preserve">
          <source>File names on the DMD command line with the extension .ddoc are text files that are read and processed in order.</source>
          <target state="translated">Имена файлов в командной строке DMD с расширением .ddoc-это текстовые файлы,которые читаются и обрабатываются по порядку.</target>
        </trans-unit>
        <trans-unit id="7b51622761aa9ab4147a65c01ed7a2f997bd6b63" translate="yes" xml:space="preserve">
          <source>File names to dispatch</source>
          <target state="translated">Имена файлов для отправки</target>
        </trans-unit>
        <trans-unit id="ab2a2923359cc254d1142cb254fa079493ce8064" translate="yes" xml:space="preserve">
          <source>File opened that is not a database file</source>
          <target state="translated">Открытый файл,который не является файлом базы данных</target>
        </trans-unit>
        <trans-unit id="600941bc483d702b3e6700aa5c9df8eaacfc769f" translate="yes" xml:space="preserve">
          <source>File separator</source>
          <target state="translated">Файлоотделитель</target>
        </trans-unit>
        <trans-unit id="b8751b87838fad8e9c09877c3fcf2d38b742badf" translate="yes" xml:space="preserve">
          <source>File that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">Файл с именем &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6025d963ff7d5ab00dd321537b1088bcf0aa15c" translate="yes" xml:space="preserve">
          <source>File to read and split into its lines.</source>
          <target state="translated">Файл,который нужно прочитать и разделить на строки.</target>
        </trans-unit>
        <trans-unit id="4d239ce96517581903eea3ad6a5e5f8f129445d3" translate="yes" xml:space="preserve">
          <source>File to read lines from.</source>
          <target state="translated">Файл для чтения строк.</target>
        </trans-unit>
        <trans-unit id="2a39297edcbf92570f7009a9439afaa0ade4a510" translate="yes" xml:space="preserve">
          <source>File.ReadResult &lt;code&gt;readResult&lt;/code&gt;</source>
          <target state="translated">File.ReadResult &lt;code&gt;readResult&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ba5924daeca1702606731ee6e33f3d6f5d8aeff" translate="yes" xml:space="preserve">
          <source>File/Folder name to get times for.</source>
          <target state="translated">Имя файла/папки для получения времени.</target>
        </trans-unit>
        <trans-unit id="b1281649a36423bcd13a1e5734562778e5a449fb" translate="yes" xml:space="preserve">
          <source>FileBuffer &lt;strong id=&quot;readFile&quot;&gt;readFile&lt;/strong&gt;(Loc loc, const(char)* filename);</source>
          <target state="translated">FileBuffer &lt;strong id=&quot;readFile&quot;&gt;readFile&lt;/strong&gt; (Loc loc, const (char) * имя файла);</target>
        </trans-unit>
        <trans-unit id="adb0ed28c9f6c61c2c5292ae0018a0dbd403f831" translate="yes" xml:space="preserve">
          <source>FileName &lt;strong id=&quot;setOutfilename&quot;&gt;setOutfilename&lt;/strong&gt;(const(char)[] name, const(char)[] dir, const(char)[] arg, const(char)[] ext);</source>
          <target state="translated">FileName &lt;strong id=&quot;setOutfilename&quot;&gt;setOutfilename&lt;/strong&gt; (const (char) [] name, const (char) [] dir, const (char) [] arg, const (char) [] ext);</target>
        </trans-unit>
        <trans-unit id="2cdd52dc9b2dc3c92972beb5c0ac073541e5c497" translate="yes" xml:space="preserve">
          <source>Filename NULL</source>
          <target state="translated">Фамилия NULL</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="ac721011f794b0e8baf53f6a4a3ded5e6b587bdc" translate="yes" xml:space="preserve">
          <source>Files are dispatched in the various arrays (global.params.{ddocfiles,dllfiles,jsonfiles,etc...}) according to their extension. Binary files are added to libmodules.</source>
          <target state="translated">Файлы отправляются в различные массивы (global.params.{ddocfiles,dllfiles,jsonfiles,и т.д....})в соответствии с их расширением.Двоичные файлы добавляются в libmodules.</target>
        </trans-unit>
        <trans-unit id="3c458791c8711a4da04ab0a8024c24f9c4200994" translate="yes" xml:space="preserve">
          <source>Fill in new entries below here!</source>
          <target state="translated">Заполните новые записи ниже здесь!</target>
        </trans-unit>
        <trans-unit id="fec9699a2804108f414d1cbff9f937ab31b1059b" translate="yes" xml:space="preserve">
          <source>Fill in vtbl[] for base class based on member functions of class cd.</source>
          <target state="translated">Заполнить vtbl[]для базового класса на основе функций-членов класса cd.</target>
        </trans-unit>
        <trans-unit id="43d8814469e2dd06b7a4446e3a72fe3fb9b94b8b" translate="yes" xml:space="preserve">
          <source>Fill out remainder of elements[] with default initializers for fields[].</source>
          <target state="translated">Заполните оставшиеся элементы []инициализаторами по умолчанию для полей [].</target>
        </trans-unit>
        <trans-unit id="ce95d41d5dfbc8ae874f5267cf6c9192895a26f6" translate="yes" xml:space="preserve">
          <source>Fills a range (assumed uninitialized) with a value.</source>
          <target state="translated">Заполняет диапазон (предполагаемый неинициализированный)значением.</target>
        </trans-unit>
        <trans-unit id="4af7384f97004098d0ba2d1490a26bd5ae8dc06c" translate="yes" xml:space="preserve">
          <source>Fills a range with a pattern, e.g., if &lt;code&gt;a = new int[3]&lt;/code&gt;, then &lt;code&gt;fill(a, 4)&lt;/code&gt; leaves &lt;code&gt;a = [4, 4, 4]&lt;/code&gt; and &lt;code&gt;fill(a, [3, 4])&lt;/code&gt; leaves &lt;code&gt;a = [3, 4, 3]&lt;/code&gt;.</source>
          <target state="translated">Заполняет диапазон шаблоном, например, если &lt;code&gt;a = new int[3]&lt;/code&gt; , то &lt;code&gt;fill(a, 4)&lt;/code&gt; оставляет &lt;code&gt;a = [4, 4, 4]&lt;/code&gt; а &lt;code&gt;fill(a, [3, 4])&lt;/code&gt; оставляет &lt;code&gt;a = [3, 4, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58c13531d89cbfd81b826ad0e0207a8e8f855efc" translate="yes" xml:space="preserve">
          <source>Fills in properties extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, expandedData[], name[], extra[].</source>
          <target state="translated">Заполняет свойства extractVersion,флаги,сжатиеМетод,время,crc32,compressedSize,expandedSize,expandedData[],name[],extra[].</target>
        </trans-unit>
        <trans-unit id="c839d156063c44cb328b154ceff7d45b6cd1f2d8" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], diskNumber, diskStartDir, numEntries, totalEntries, and directory[]. For each ArchiveMember, fills in properties crc32, compressedSize, compressedData[].</source>
          <target state="translated">Заполняет свойства data[],diskNumber,diskStartDir,numEntries,totalEntries и directory[].Для каждого ArchiveMember заполняет свойства crc32,compressedSize,compressressedData[].</target>
        </trans-unit>
        <trans-unit id="ac430f749392cd86ab81a1eba5a5fa6084a02035" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], diskNumber, diskStartDir, numEntries, totalEntries, comment[], and directory[]. For each ArchiveMember, fills in properties madeVersion, extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, compressedData[], diskNumber, internalAttributes, externalAttributes, name[], extra[], comment[]. Use expand() to get the expanded data for each ArchiveMember.</source>
          <target state="translated">Заполняет свойства data[],diskNumber,diskStartDir,numEntries,totalEntries,comment[]и directory[].Для каждого члена ArchiveMember заполняет свойства madeVersion,extractVersion,флаги,compressionMethod,time,crc32,compressedSize,expandedSize,compressedData[],diskNumber,internalAttributes,externalAttributes,name[],extra[],comment[].Используйте функцию expand()для получения расширенных данных для каждого члена архива.</target>
        </trans-unit>
        <trans-unit id="46a5ea9f87c0b1df74d151c62691fe2ef4bb053c" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], totalEntries, and directory[]. For each ArchiveMember, fills in properties crc32, compressedSize, compressedData[].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b346bd7916857edb9b3b4a990fd8d299ee339598" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], totalEntries, comment[], and directory[]. For each ArchiveMember, fills in properties madeVersion, extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, compressedData[], internalAttributes, externalAttributes, name[], extra[], comment[]. Use expand() to get the expanded data for each ArchiveMember.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753c7b4dfb03e4b323218bfbcf8e9ce9e83fd215" translate="yes" xml:space="preserve">
          <source>Filter (higher-order function)</source>
          <target state="translated">Фильтр (функция более высокого порядка)</target>
        </trans-unit>
        <trans-unit id="e010e248c9fcbc07279b28e2d9cf39a816edeedc" translate="yes" xml:space="preserve">
          <source>Filtering Log Messages</source>
          <target state="translated">Фильтрация сообщений журнала</target>
        </trans-unit>
        <trans-unit id="b9cfd7e1924fe46ff476048bb232046b2445c30d" translate="yes" xml:space="preserve">
          <source>Filters an &lt;code&gt;AliasSeq&lt;/code&gt; using a template predicate. Returns an &lt;code&gt;AliasSeq&lt;/code&gt; of the elements which satisfy the predicate.</source>
          <target state="translated">Фильтрует &lt;code&gt;AliasSeq&lt;/code&gt; , используя предикат шаблона. Возвращает &lt;code&gt;AliasSeq&lt;/code&gt; элементов, которые удовлетворяют предикату.</target>
        </trans-unit>
        <trans-unit id="d3a871296194a1fb868a45ed782c53f0637a842f" translate="yes" xml:space="preserve">
          <source>Final Classes</source>
          <target state="translated">Заключительные классы</target>
        </trans-unit>
        <trans-unit id="c054c76415f8cf9cbfa3c705550abf7d2a659de6" translate="yes" xml:space="preserve">
          <source>Final Switch Statement</source>
          <target state="translated">Заключительное заявление о переключении</target>
        </trans-unit>
        <trans-unit id="f28c69a57fd5a00b8c460d98af841dbdfc2cf776" translate="yes" xml:space="preserve">
          <source>Final classes cannot be subclassed:</source>
          <target state="translated">Заключительные классы не могут быть подразделены на подклассы:</target>
        </trans-unit>
        <trans-unit id="ce6f1f9e3ddcc894278135e4f17b933043c105ab" translate="yes" xml:space="preserve">
          <source>Final variables cannot be directly mutated or rebound, but references reached through the variable are typed with their original mutability. It is equivalent to &lt;code&gt;final&lt;/code&gt; variables in D1 and Java, as well as &lt;code&gt;readonly&lt;/code&gt; variables in C#.</source>
          <target state="translated">Конечные переменные не могут быть напрямую изменены или восстановлены, но ссылки, достигнутые через переменную, набираются с их исходной изменчивостью. Это эквивалентно &lt;code&gt;final&lt;/code&gt; переменным в D1 и Java, а также переменным только для &lt;code&gt;readonly&lt;/code&gt; в C #.</target>
        </trans-unit>
        <trans-unit id="0e2b4800b08f795f43f812ffedaf0e687b6d6874" translate="yes" xml:space="preserve">
          <source>Final!T &lt;strong id=&quot;makeFinal&quot;&gt;makeFinal&lt;/strong&gt;(T)(T t);</source>
          <target state="translated">Final! T &lt;strong id=&quot;makeFinal&quot;&gt;makeFinal&lt;/strong&gt; (T) (T t);</target>
        </trans-unit>
        <trans-unit id="9e3e2e2f543272fd4cd5df84fdd43fdaeaef1da0" translate="yes" xml:space="preserve">
          <source>Final_Punctuation</source>
          <target state="translated">Final_Punctuation</target>
        </trans-unit>
        <trans-unit id="5651425846864705935b85d871957e1ebe78f459" translate="yes" xml:space="preserve">
          <source>Finalization hook, called FOR each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">Завершающий крюк,называемый для каждой нити.Никаких предположений о состоянии инициализации модуля делать не следует.</target>
        </trans-unit>
        <trans-unit id="3c0d51279d82c302cafb15142125c52a7d750035" translate="yes" xml:space="preserve">
          <source>Finalize A Dynamic String</source>
          <target state="translated">Завершить динамическую строку</target>
        </trans-unit>
        <trans-unit id="c5174f6c9ec806f743432561800d7fb3cdce6c10" translate="yes" xml:space="preserve">
          <source>Finalize the data in this block on collect.</source>
          <target state="translated">Завершите сбор данных в этом блоке.</target>
        </trans-unit>
        <trans-unit id="1487ab4833797a8fe86e9e688a3c4af63df81678" translate="yes" xml:space="preserve">
          <source>Finalizes the computation of the hash and returns the computed value. Note that &lt;code&gt;finish&lt;/code&gt; can be called only once and that no subsequent calls to &lt;code&gt;put&lt;/code&gt; is allowed.</source>
          <target state="translated">Завершает вычисление хэша и возвращает вычисленное значение. Обратите внимание, что &lt;code&gt;finish&lt;/code&gt; может быть вызван только один раз, и последующие вызовы на &lt;code&gt;put&lt;/code&gt; не допускаются</target>
        </trans-unit>
        <trans-unit id="edf7957cb21bb43e8c1e9e16262a7f52655c315a" translate="yes" xml:space="preserve">
          <source>Finally, any combination of integral offsets and tuples composed of two integral offsets can be passed in:</source>
          <target state="translated">Наконец,любая комбинация интегральных смещений и кортежей,состоящая из двух интегральных смещений,может быть передана внутрь:</target>
        </trans-unit>
        <trans-unit id="8318badcbf1d40a64d4bffbf97bd0efd4cae1f40" translate="yes" xml:space="preserve">
          <source>Finally, if the user-defined type is to be used as a key in the built-in associative arrays, then the programmer must ensure that the semantics of &lt;code&gt;opEquals&lt;/code&gt; and &lt;code&gt;toHash&lt;/code&gt; are consistent. If not, the associative array may not work in the expected manner.</source>
          <target state="translated">Наконец, если пользовательский тип должен использоваться в качестве ключа во встроенных ассоциативных массивах, то программист должен убедиться, что семантика &lt;code&gt;opEquals&lt;/code&gt; и &lt;code&gt;toHash&lt;/code&gt; последовательны. Если нет, ассоциативный массив может не работать ожидаемым образом.</target>
        </trans-unit>
        <trans-unit id="63ebc2a4bae0f29d985262d1e0a7882d311b33e0" translate="yes" xml:space="preserve">
          <source>Finally, it includes some convenience functions for manipulating ranges:</source>
          <target state="translated">Наконец,он включает в себя некоторые удобные функции для манипулирования диапазонами:</target>
        </trans-unit>
        <trans-unit id="957ad37fd6f0cb718a9dbc02f2623b3113168bed" translate="yes" xml:space="preserve">
          <source>Finally, there is no guarantee that using &lt;code&gt;FPTemporary!F&lt;/code&gt; will always be fastest, as the speed of floating-point calculations depends on very many factors.</source>
          <target state="translated">Наконец, нет никакой гарантии, что использование &lt;code&gt;FPTemporary!F&lt;/code&gt; всегда будет самым быстрым, поскольку скорость вычислений с плавающей запятой зависит от очень многих факторов.</target>
        </trans-unit>
        <trans-unit id="1e7650a8c491fd4a8a63008ab0b8ff54cd68ebd3" translate="yes" xml:space="preserve">
          <source>FinallyStatement</source>
          <target state="translated">FinallyStatement</target>
        </trans-unit>
        <trans-unit id="af66114eea030ebc5f2464aa23997a938e455374" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;ident&lt;/code&gt; in an array of identifiers.</source>
          <target state="translated">Найти &lt;code&gt;ident&lt;/code&gt; в массиве идентификаторов.</target>
        </trans-unit>
        <trans-unit id="88937cdca6cc08c5d7dbfa18ae72ed67be952ed2" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;value&lt;/code&gt; among &lt;code&gt;values&lt;/code&gt;, returning the 1-based index of the first matching value in &lt;code&gt;values&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;value&lt;/code&gt; is not among &lt;code&gt;values&lt;/code&gt;. The predicate &lt;code&gt;pred&lt;/code&gt; is used to compare values, and uses equality by default.</source>
          <target state="translated">Найти &lt;code&gt;value&lt;/code&gt; среди &lt;code&gt;values&lt;/code&gt; , возвращая основанный на 1 индекс первого соответствующего значения в &lt;code&gt;values&lt;/code&gt; или &lt;code&gt;0&lt;/code&gt; , если &lt;code&gt;value&lt;/code&gt; не входит в число &lt;code&gt;values&lt;/code&gt; . Предикат &lt;code&gt;pred&lt;/code&gt; используется для сравнения значений и по умолчанию использует равенство.</target>
        </trans-unit>
        <trans-unit id="545769c2d22b47615aaec611ab60b4390f1d36ac" translate="yes" xml:space="preserve">
          <source>Find The Database Handle Of A Prepared Statement</source>
          <target state="translated">Поиск в базе данных готового заявления</target>
        </trans-unit>
        <trans-unit id="8ed4d78384609c747738b51bd99d57a7cbe3bca7" translate="yes" xml:space="preserve">
          <source>Find a common root between &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;. If there is no common root, return &lt;code&gt;path&lt;/code&gt; unaltered.</source>
          <target state="translated">Найти общий корень между &lt;code&gt;path&lt;/code&gt; и &lt;code&gt;base&lt;/code&gt; . Если общего корня нет, верните &lt;code&gt;path&lt;/code&gt; без изменений.</target>
        </trans-unit>
        <trans-unit id="3cc4bdb526e48e9b0169cef3864d16c67f747c87" translate="yes" xml:space="preserve">
          <source>Find a real minimum of a real function &lt;code&gt;f(x)&lt;/code&gt; via bracketing. Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;(ax .. bx)&lt;/code&gt;, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a minimum of &lt;code&gt;f(x)&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; is never evaluted at the endpoints of &lt;code&gt;ax&lt;/code&gt; and &lt;code&gt;bx&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one minimum in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN or -Infinity, &lt;code&gt;(x, f(x), NaN)&lt;/code&gt; will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">Найти реальный минимум действительной функции &lt;code&gt;f(x)&lt;/code&gt; помощью скобок. При наличии функции &lt;code&gt;f&lt;/code&gt; и диапазона &lt;code&gt;(ax .. bx)&lt;/code&gt; возвращает значение &lt;code&gt;x&lt;/code&gt; в диапазоне, ближайшем к минимуму &lt;code&gt;f(x)&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; никогда не оценивается в конечных точках &lt;code&gt;ax&lt;/code&gt; и &lt;code&gt;bx&lt;/code&gt; . Если &lt;code&gt;f(x)&lt;/code&gt; имеет более одного минимума в диапазоне, он будет выбран произвольно. Если &lt;code&gt;f(x)&lt;/code&gt; возвращает NaN или -Infinity, будет возвращено &lt;code&gt;(x, f(x), NaN)&lt;/code&gt; ; в противном случае этот алгоритм гарантированно будет успешным.</target>
        </trans-unit>
        <trans-unit id="dc439799cd4737f8236f05600fc64a52e0bdee1d" translate="yes" xml:space="preserve">
          <source>Find a real root of a real function f(x) via bracketing.</source>
          <target state="translated">Найти реальный корень реальной функции f(x)с помощью брекетинга.</target>
        </trans-unit>
        <trans-unit id="d9ea8a7553428e4555c42a356e28f37d1f30dc20" translate="yes" xml:space="preserve">
          <source>Find all instance fields, then push them into &lt;code&gt;fields&lt;/code&gt;.</source>
          <target state="translated">Найдите все поля экземпляра, затем вставьте их в &lt;code&gt;fields&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f0f2515c2b37286fa318cf443dfdda11744bc3e" translate="yes" xml:space="preserve">
          <source>Find all variables accessed by this delegate that are in functions enclosing it.</source>
          <target state="translated">Найти все переменные,к которым обращается данный делегат и которые находятся в функциях,его окружающих.</target>
        </trans-unit>
        <trans-unit id="41ae1d4488620fcf9a1fa1a9eea694e8dd8ef394" translate="yes" xml:space="preserve">
          <source>Find function in overload list that exactly matches t.</source>
          <target state="translated">Найти функцию в списке перегрузки,которая точно совпадает с t.</target>
        </trans-unit>
        <trans-unit id="edff7cacecc816c7b2bf341caacbadeda732cdfa" translate="yes" xml:space="preserve">
          <source>Find function in overload list that matches to the 'this' modifier. There's four result types.</source>
          <target state="translated">Найти функцию в списке перегрузки,которая соответствует модификатору 'this'.Есть четыре типа результатов.</target>
        </trans-unit>
        <trans-unit id="f0c98c985999ca34facaa820a09d254832cfa98f" translate="yes" xml:space="preserve">
          <source>Find index of function in vtbl[0..dim] that this function overrides. Prefer an exact match to a covariant one.</source>
          <target state="translated">Найти индекс функции в vtbl[0...dim],который эта функция переопределяет.Предпочтителено точное совпадение с ковариантным.</target>
        </trans-unit>
        <trans-unit id="8a869c31c58148141fe2bb0252ad8f9ecb8a528b" translate="yes" xml:space="preserve">
          <source>Find last statement in a sequence of statements.</source>
          <target state="translated">Найдите последнее утверждение в последовательности утверждений.</target>
        </trans-unit>
        <trans-unit id="d69cdad0f7e718c4389bc96b6e8484b75621891a" translate="yes" xml:space="preserve">
          <source>Find root of a real function f(x) by bracketing, allowing the termination condition to be specified.</source>
          <target state="translated">Поиск корня вещественной функции f(x)с помощью скобок,позволяющих задать условие завершения.</target>
        </trans-unit>
        <trans-unit id="2fb393ab419b2e3f0988a888618d55945a606a1c" translate="yes" xml:space="preserve">
          <source>Find template declaration corresponding to template instance.</source>
          <target state="translated">Найти декларацию шаблона,соответствующую экземпляру шаблона.</target>
        </trans-unit>
        <trans-unit id="e56b93cf2f4450a7eaf19462aacfb88f33166737" translate="yes" xml:space="preserve">
          <source>Find the config file</source>
          <target state="translated">Найти файл конфигурации</target>
        </trans-unit>
        <trans-unit id="d2dd908c00ec01e1d2253d53d434daf6a1857fe3" translate="yes" xml:space="preserve">
          <source>Find the first (leftmost) slice of the &lt;code&gt;input&lt;/code&gt; that matches the pattern &lt;code&gt;re&lt;/code&gt;. This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="translated">Найдите первый (самый левый) срез &lt;code&gt;input&lt;/code&gt; который соответствует шаблону &lt;code&gt;re&lt;/code&gt; . Эта функция выбирает наиболее подходящий механизм регулярных выражений в зависимости от свойств шаблона.</target>
        </trans-unit>
        <trans-unit id="b74109ae76fb090044e9df5875f1c38828f427c5" translate="yes" xml:space="preserve">
          <source>Find the first non-comma expression.</source>
          <target state="translated">Найди первое некоммунальное выражение.</target>
        </trans-unit>
        <trans-unit id="6cc3fb2f138f676cf6a94d5a2c6b5519efc51d83" translate="yes" xml:space="preserve">
          <source>Find the last non-comma expression.</source>
          <target state="translated">Найди последнее некоммунальное выражение.</target>
        </trans-unit>
        <trans-unit id="19feb6b0e0b231038a55e2bf709f34b7a893df27" translate="yes" xml:space="preserve">
          <source>Find virtual function matching identifier and type. Used to build virtual function tables for interface implementations.</source>
          <target state="translated">Поиск совпадения идентификатора и типа виртуальной функции.Используется для построения таблиц виртуальных функций для реализации интерфейсов.</target>
        </trans-unit>
        <trans-unit id="1f779fad43ff937e8c60b5135580f17f7fea9279" translate="yes" xml:space="preserve">
          <source>Finds &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and positions &lt;code&gt;haystack&lt;/code&gt; right after the first occurrence of &lt;code&gt;needle&lt;/code&gt;.</source>
          <target state="translated">Находит &lt;code&gt;needle&lt;/code&gt; в &lt;code&gt;haystack&lt;/code&gt; и позиционирует &lt;code&gt;haystack&lt;/code&gt; сразу после первого появления &lt;code&gt;needle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dffa198dc7c767b46fa65ebc9d63a3a8195c5965" translate="yes" xml:space="preserve">
          <source>Finds &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; efficiently using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt; Boyer-Moore&lt;/a&gt; method.</source>
          <target state="translated">Эффективно находит &lt;code&gt;needle&lt;/code&gt; в &lt;code&gt;haystack&lt;/code&gt; используя метод &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Бойера-Мура&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4aab22f9bf13ade683a53be805bd158b6756b54" translate="yes" xml:space="preserve">
          <source>Finds a &lt;code&gt;dmd.conf&lt;/code&gt; and parses it for import paths. This depends on the &lt;code&gt;$DMD&lt;/code&gt; environment variable. If &lt;code&gt;$DMD&lt;/code&gt; is set to &lt;code&gt;ldmd&lt;/code&gt;, it will try to detect and parse a &lt;code&gt;ldc2.conf&lt;/code&gt; instead.</source>
          <target state="translated">Находит &lt;code&gt;dmd.conf&lt;/code&gt; и анализирует его для путей импорта. Это зависит от переменной среды &lt;code&gt;$DMD&lt;/code&gt; . Если &lt;code&gt;$DMD&lt;/code&gt; установлен в &lt;code&gt;ldmd&lt;/code&gt; , он попытается обнаружить и проанализировать &lt;code&gt;ldc2.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db4503384752d61843483992d0609b3513a269cd" translate="yes" xml:space="preserve">
          <source>Finds an individual element in an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;. Elements of &lt;code&gt;haystack&lt;/code&gt; are compared with &lt;code&gt;needle&lt;/code&gt; by using predicate &lt;code&gt;pred&lt;/code&gt; with &lt;code&gt;pred(haystack.front, needle)&lt;/code&gt;. &lt;code&gt;find&lt;/code&gt; performs &amp;Omicron;(&lt;code&gt;walkLength(haystack)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Находит отдельный элемент в &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;диапазоне ввода&lt;/a&gt; . Элементы &lt;code&gt;haystack&lt;/code&gt; сравниваются с &lt;code&gt;needle&lt;/code&gt; с помощью предиката &lt;code&gt;pred&lt;/code&gt; с &lt;code&gt;pred(haystack.front, needle)&lt;/code&gt; . &lt;code&gt;find&lt;/code&gt; выполняет &lt;code&gt;walkLength(haystack)&lt;/code&gt; ( walkLength (стог сена) ) оценки &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="494b5c575695991289f1af6c553e989e7554d283" translate="yes" xml:space="preserve">
          <source>Finds multiple attributes</source>
          <target state="translated">Находит несколько атрибутов</target>
        </trans-unit>
        <trans-unit id="dc6ca4363cb66199d14c81638ae0bacb275a040f" translate="yes" xml:space="preserve">
          <source>Finds nothing if there is no member with specific UDA</source>
          <target state="translated">Ничего не находит,если нет члена с определенным UDA.</target>
        </trans-unit>
        <trans-unit id="372b352a9faabc1d4848c96cff7df7512a64b542" translate="yes" xml:space="preserve">
          <source>Finds the mean (colloquially known as the average) of a range.</source>
          <target state="translated">Находит среднее (в разговорной форме известное как среднее)значение диапазона.</target>
        </trans-unit>
        <trans-unit id="acc839859781d1a6fe4c1aa11b5d0cad6c9f277f" translate="yes" xml:space="preserve">
          <source>Finds the quotient and remainder for the given dividend and divisor in one operation.</source>
          <target state="translated">Находит коэффициент и остаток для данного дивиденда и делителя за одну операцию.</target>
        </trans-unit>
        <trans-unit id="1f42db37e0be1957bbb7a73bd93bbacc6f6971b6" translate="yes" xml:space="preserve">
          <source>Finds two or more &lt;code&gt;needles&lt;/code&gt; into a &lt;code&gt;haystack&lt;/code&gt;. The predicate &lt;code&gt;pred&lt;/code&gt; is used throughout to compare elements. By default, elements are compared for equality.</source>
          <target state="translated">Находит две или более &lt;code&gt;needles&lt;/code&gt; в &lt;code&gt;haystack&lt;/code&gt; . Предикат &lt;code&gt;pred&lt;/code&gt; используется повсюду для сравнения элементов. По умолчанию элементы сравниваются на равенство.</target>
        </trans-unit>
        <trans-unit id="e49c750f94dfbe0f01c55cba7ce3a3fca1cb43ad" translate="yes" xml:space="preserve">
          <source>Finish and return completed data structure.</source>
          <target state="translated">Завершение и возврат завершенной структуры данных.</target>
        </trans-unit>
        <trans-unit id="910917ab298e1770af3ee0a6c87f4500d8fc3b35" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), and then attempts to associate the given Windows &lt;code&gt;HANDLE&lt;/code&gt; with the &lt;code&gt;File&lt;/code&gt;. The mode must be compatible with the access attributes of the handle. Windows only.</source>
          <target state="translated">Сначала вызывает &lt;code&gt;detach&lt;/code&gt; (выбрасывает при сбое), а затем пытается связать данный Windows &lt;code&gt;HANDLE&lt;/code&gt; с &lt;code&gt;File&lt;/code&gt; . Режим должен быть совместим с атрибутами доступа дескриптора. Только для Windows</target>
        </trans-unit>
        <trans-unit id="dcaf56d0ddc5fc561f47a3812f5bb4243cf6c321" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), and then attempts to associate the given file descriptor with the &lt;code&gt;File&lt;/code&gt;. The mode must be compatible with the mode of the file descriptor.</source>
          <target state="translated">Сначала вызывает &lt;code&gt;detach&lt;/code&gt; (выбрасывает при неудаче), а затем пытается связать данный дескриптор файла с &lt;code&gt;File&lt;/code&gt; . Режим должен быть совместим с режимом дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="7f59c090d80233a5077fc16f2881b79e76399aaf" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), then attempts to associate the given file descriptor with the &lt;code&gt;File&lt;/code&gt;, and sets the file's name to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a4e48dd9c9e9c16b3c2bdc21882e910e46f414" translate="yes" xml:space="preserve">
          <source>First checks whether there's enough slack memory preallocated for &lt;code&gt;b&lt;/code&gt; by evaluating &lt;code&gt;b.length + delta &amp;lt;= goodAllocSize(b.length)&lt;/code&gt;. If that's the case, expands &lt;code&gt;b&lt;/code&gt; in place. Otherwise, attempts to use &lt;code&gt;parent.expand&lt;/code&gt; appropriately if present.</source>
          <target state="translated">Сначала проверяется, достаточно ли &lt;code&gt;b.length + delta &amp;lt;= goodAllocSize(b.length)&lt;/code&gt; памяти выделено для &lt;code&gt;b&lt;/code&gt; , оценивая b.length + delta &amp;lt;= goodAllocSize (b.length) . Если это так, расширяется &lt;code&gt;b&lt;/code&gt; на месте. В противном случае, попытка использовать &lt;code&gt;parent.expand&lt;/code&gt; соответствующим образом, если присутствует.</target>
        </trans-unit>
        <trans-unit id="232d9e5b94637d4aff68a5613d4eb2c442d5e710" translate="yes" xml:space="preserve">
          <source>First element of range is the whole match.</source>
          <target state="translated">Первый элемент диапазона-весь матч.</target>
        </trans-unit>
        <trans-unit id="19eb5d2bea28d68e63b34cd9da02ecb96eb4de74" translate="yes" xml:space="preserve">
          <source>First element, null if *plist is null</source>
          <target state="translated">Первый элемент,ноль,если *список равен нулю.</target>
        </trans-unit>
        <trans-unit id="56336174ab5678a8f418a8043d57e8c559fdf20f" translate="yes" xml:space="preserve">
          <source>First enum member value</source>
          <target state="translated">Первое значение члена переписи</target>
        </trans-unit>
        <trans-unit id="61c434e488f86b8e6b440a94d71c3f4ce5c76af6" translate="yes" xml:space="preserve">
          <source>First item to compare.</source>
          <target state="translated">Первый пункт для сравнения.</target>
        </trans-unit>
        <trans-unit id="eb036d61b03c52aec70ded61cf94c0bb2799a5dc" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;S(1)&lt;/code&gt; and &lt;code&gt;S(2)&lt;/code&gt; are evaluated in lexical order. Per the rules, they will be destroyed at the end of the full expression and in reverse order. The comparison &lt;code&gt;S(1) == S(2)&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt;, so the right-hand side of the &lt;code&gt;||&lt;/code&gt; is evaluated causing &lt;code&gt;S(3)&lt;/code&gt; and &lt;code&gt;S(4)&lt;/code&gt; to be evaluated, also in lexical order. However, their destruction is not deferred to the end of the full expression. Instead, &lt;code&gt;S(4)&lt;/code&gt; and then &lt;code&gt;S(3)&lt;/code&gt; are destroyed at the end of the &lt;code&gt;||&lt;/code&gt; expression. Following their destruction, &lt;code&gt;S(5)&lt;/code&gt; and &lt;code&gt;S(6)&lt;/code&gt; are constructed in lexical order. Again they are not destroyed at the end of the full expression, but right at the end of the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression. Consequently, the destruction of &lt;code&gt;S(6)&lt;/code&gt; and &lt;code&gt;S(5)&lt;/code&gt; is carried before that of &lt;code&gt;S(2)&lt;/code&gt; and &lt;code&gt;S(1)&lt;/code&gt;.</source>
          <target state="translated">Сначала &lt;code&gt;S(1)&lt;/code&gt; и &lt;code&gt;S(2)&lt;/code&gt; оцениваются в лексическом порядке. Согласно правилам, они будут уничтожены в конце полного выражения и в обратном порядке. Сравнение &lt;code&gt;S(1) == S(2)&lt;/code&gt; дает &lt;code&gt;false&lt;/code&gt; , поэтому правая часть &lt;code&gt;||&lt;/code&gt; оценивается, вызывая &lt;code&gt;S(3)&lt;/code&gt; и &lt;code&gt;S(4)&lt;/code&gt; , также в лексическом порядке. Однако их уничтожение не откладывается до конца полного выражения. Вместо этого &lt;code&gt;S(4)&lt;/code&gt; а затем &lt;code&gt;S(3)&lt;/code&gt; уничтожаются в конце &lt;code&gt;||&lt;/code&gt; выражение. После их уничтожения &lt;code&gt;S(5)&lt;/code&gt; и &lt;code&gt;S(6)&lt;/code&gt; построены в лексическом порядке. Опять же, они не уничтожаются в конце полного выражения, а прямо в конце выражения &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; . Следовательно, разрушение &lt;code&gt;S(6)&lt;/code&gt; и &lt;code&gt;S(5)&lt;/code&gt; осуществляется до уничтожения &lt;code&gt;S(2)&lt;/code&gt; и &lt;code&gt;S(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35821ff9eaf82cccb4cd374c06db922677ab7c04" translate="yes" xml:space="preserve">
          <source>First, an instance of the reference-counted HTTP struct is created. Then the custom delegates are set. These will be called whenever the HTTP instance receives a header and a data buffer, respectively. In this simple example, the headers are written to stdout and the data is ignored. If the request should be stopped before it has finished then return something less than data.length from the onReceive callback. See &lt;a href=&quot;#onReceiveHeader&quot;&gt;&lt;code&gt;onReceiveHeader&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#onReceive&quot;&gt;&lt;code&gt;onReceive&lt;/code&gt;&lt;/a&gt; for more information. Finally the HTTP request is effected by calling perform(), which is synchronous.</source>
          <target state="translated">Сначала создается экземпляр подсчитанной ссылки структуры HTTP. Затем настраиваемые делегаты устанавливаются. Они будут вызываться всякий раз, когда экземпляр HTTP получает заголовок и буфер данных соответственно. В этом простом примере заголовки записываются в стандартный вывод, а данные игнорируются. Если запрос должен быть остановлен до его завершения, верните что-то меньше data.length из обратного вызова onReceive. Смотрите &lt;a href=&quot;#onReceiveHeader&quot;&gt; &lt;code&gt;onReceiveHeader&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#onReceive&quot;&gt; &lt;code&gt;onReceive&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации. Наконец, HTTP-запрос выполняется с помощью метода execute (), который является синхронным.</target>
        </trans-unit>
        <trans-unit id="ddff6cdec0a5bb1099424737e7832e8c05999395" translate="yes" xml:space="preserve">
          <source>First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done on the operands. The result type of a relational expression is &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Во-первых, &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычные арифметические преобразования&lt;/a&gt; выполняются над операндами. Тип результата реляционного выражения - &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4957bf53799feeb05b63a3d6e973fd8fa8760f6f" translate="yes" xml:space="preserve">
          <source>FirstExp</source>
          <target state="translated">FirstExp</target>
        </trans-unit>
        <trans-unit id="5613e8ed3a8c422a59b73ed2d59f778f438baaf8" translate="yes" xml:space="preserve">
          <source>Fit elements[] to the corresponding types of the struct's fields.</source>
          <target state="translated">Установите элементы[]в соответствующие типы полей структуры.</target>
        </trans-unit>
        <trans-unit id="2fdb1b8027c76adc716597ecea40dafd0a1d1761" translate="yes" xml:space="preserve">
          <source>Fixed-size allocation (unlikely to get reallocated later). Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, any &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; type. By default it is assumed that the allocation is variable-size, i.e. susceptible to later reallocation (for example all array types). This flag is advisory, i.e. in-place resizing may be attempted for &lt;code&gt;fixedSize&lt;/code&gt; allocations and may succeed. The flag is just a hint to the compiler it may use allocation strategies that work well with objects of fixed size.</source>
          <target state="translated">Распределение фиксированного размера (вряд ли будет перераспределено позже). Примеры: &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , любая &lt;code&gt;struct&lt;/code&gt; или тип &lt;code&gt;class&lt;/code&gt; . По умолчанию предполагается, что распределение имеет переменный размер, то есть подвержено последующему перераспределению (например, все типы массивов). Этот флаг носит рекомендательный характер, т. &lt;code&gt;fixedSize&lt;/code&gt; размера на месте может быть предпринято для распределения фиксированного размера и может быть успешным. Флаг - это просто подсказка компилятору, он может использовать стратегии выделения, которые хорошо работают с объектами фиксированного размера.</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="6349adf8f4924cf71432b2cc8b99298a02da104f" translate="yes" xml:space="preserve">
          <source>Flag for indicating if the isEmail function should perform a DNS check or not.</source>
          <target state="translated">Флаг для указания,должна ли функция isEmail выполнять проверку DNS или нет.</target>
        </trans-unit>
        <trans-unit id="01fd2d670ffad32f041db95fdb5fd34e662c1fd5" translate="yes" xml:space="preserve">
          <source>Flag indicating if help was requested</source>
          <target state="translated">Флаг,указывающий,была ли запрошена помощь</target>
        </trans-unit>
        <trans-unit id="4839649a06c4517e676f395e7fb017b70b5e26a6" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a search is case-sensitive.</source>
          <target state="translated">Флаг,указывающий,чувствителен ли поиск к регистру.</target>
        </trans-unit>
        <trans-unit id="728d7e2f5a2090a340dd62e4890170496eb26f90" translate="yes" xml:space="preserve">
          <source>Flag to control rethrow behavior of &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Флаг для управления повторным &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2bb64de167476df8d3672619e1590b0a282bc6b" translate="yes" xml:space="preserve">
          <source>Flag to specify whether or not an exception is thrown on error.</source>
          <target state="translated">Флаг для указания,выбрасывается ли исключение по ошибке или нет.</target>
        </trans-unit>
        <trans-unit id="c2cc357fb7c03c09f92dcb1aaffc28e51837dbc6" translate="yes" xml:space="preserve">
          <source>Flag used by &lt;a href=&quot;#resolveFuncCall&quot;&gt;&lt;code&gt;resolveFuncCall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Флаг, используемый &lt;a href=&quot;#resolveFuncCall&quot;&gt; &lt;code&gt;resolveFuncCall&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfa1ebe73458327f2f1b2331e7d2bc64bda02225" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Iterable)(auto ref Iterable r)</source>
          <target state="translated">Отметить! &quot; &lt;strong id=&quot;each&quot;&gt;Каждый&lt;/strong&gt; &quot; &lt;strong id=&quot;each&quot;&gt;каждый&lt;/strong&gt; (итерируемый)</target>
        </trans-unit>
        <trans-unit id="2e29bfd584368e0b6c450b93dff8e2b4b7d7e79b" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">Флаг! &quot; &lt;strong id=&quot;each&quot;&gt;Каждый&lt;/strong&gt; &quot; &lt;strong id=&quot;each&quot;&gt;каждый&lt;/strong&gt; (диапазон) (диапазон r)</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="a98a30dbf66202f4a1ca6fcfeff706e1cb961f9b" translate="yes" xml:space="preserve">
          <source>Flags affect formatting depending on the specifier as follows.</source>
          <target state="translated">Флаги влияют на форматирование в зависимости от спецификатора следующим образом.</target>
        </trans-unit>
        <trans-unit id="517da122a2fd8a775a91cf3934a2421fdfecad5e" translate="yes" xml:space="preserve">
          <source>Flags may be OR'ed together:</source>
          <target state="translated">Флаги могут быть вместе:</target>
        </trans-unit>
        <trans-unit id="9a817b12d43958a297fe78c774ef0aab232c3032" translate="yes" xml:space="preserve">
          <source>Flags that can be passed to &lt;a href=&quot;#pipeProcess&quot;&gt;&lt;code&gt;pipeProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; to specify which of the child process' standard streams are redirected. Use bitwise OR to combine flags.</source>
          <target state="translated">Флаги, которые можно передать в &lt;a href=&quot;#pipeProcess&quot;&gt; &lt;code&gt;pipeProcess&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; ,&lt;/a&gt; чтобы указать, какие из стандартных потоков дочернего процесса перенаправляются. Используйте побитовое ИЛИ для объединения флагов.</target>
        </trans-unit>
        <trans-unit id="d7bf08131e02f1b45b6731cfdb8ac81266998286" translate="yes" xml:space="preserve">
          <source>Flags that control how json is encoded and parsed.</source>
          <target state="translated">Флаги,которые управляют тем,как кодируется и анализируется json.</target>
        </trans-unit>
        <trans-unit id="9101e63c4b97693993f5de7e6caad68a3e230e45" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags, and note that the &lt;code&gt;retainStd...&lt;/code&gt; flags have no effect in this function.</source>
          <target state="translated">Флаги, которые контролируют процесс создания. См. &lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; для обзора доступных флагов и обратите внимание, что флаги &lt;code&gt;retainStd...&lt;/code&gt; не влияют на эту функцию.</target>
        </trans-unit>
        <trans-unit id="8fa52f42ca8ff70a9db0dc2e586798abb191d35d" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">Флаги, которые контролируют процесс создания. См. &lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; для обзора доступных флагов.</target>
        </trans-unit>
        <trans-unit id="c0978ac0b3ccfd7282e3c33d010ed6583a1755a4" translate="yes" xml:space="preserve">
          <source>Flags that control the behaviour of process creation functions in this module. Most flags only apply to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Флаги, которые управляют поведением функций создания процесса в этом модуле. Большинство флагов применяются только к &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a98c5de453c2c7c3caf6bb14f159914e55de8b90" translate="yes" xml:space="preserve">
          <source>Flags that determine which streams are redirected, and how. See &lt;a href=&quot;#Redirect&quot;&gt;&lt;code&gt;Redirect&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">Флаги, которые определяют, какие потоки перенаправляются и как. Смотрите &lt;a href=&quot;#Redirect&quot;&gt; &lt;code&gt;Redirect&lt;/code&gt; &lt;/a&gt; для обзора доступных флагов.</target>
        </trans-unit>
        <trans-unit id="b620409ddfc3fc2bb8b14e73ba7780a044ad90c9" translate="yes" xml:space="preserve">
          <source>Flatten out the scope by presenting the statement as an array of statements.</source>
          <target state="translated">Сократите объем,представив заявление в виде массива утверждений.</target>
        </trans-unit>
        <trans-unit id="69f2ec628a1c75aed5c37949245c44cc81da511d" translate="yes" xml:space="preserve">
          <source>Flips a single bit, specified by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">Зеркальные один бит, заданных &lt;code&gt;pos&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4e1ce065ff47fa12c8210de50047287b30b8075" translate="yes" xml:space="preserve">
          <source>Flips all the bits in the &lt;code&gt;BitArray&lt;/code&gt;</source>
          <target state="translated">Переворачивает все биты в &lt;code&gt;BitArray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f980f6669a99ae97aa471b598c62ac0c3e1f823b" translate="yes" xml:space="preserve">
          <source>Floating Point</source>
          <target state="translated">Плавающая точка</target>
        </trans-unit>
        <trans-unit id="a7a463a748e16b2f5b0e11e3ae1b317ccea7b0fc" translate="yes" xml:space="preserve">
          <source>Floating Point Constant Folding</source>
          <target state="translated">Постоянное складывание с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="d66cb8936a51df45efbb55e9f325e90025cbbefc" translate="yes" xml:space="preserve">
          <source>Floating Point Intermediate Values</source>
          <target state="translated">Промежуточные значения плавающей точки</target>
        </trans-unit>
        <trans-unit id="a6c4e80d19a5698157c68955c5feabc616b55ad5" translate="yes" xml:space="preserve">
          <source>Floating Point Literals</source>
          <target state="translated">Буквы с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="549c1462b87072d7712396a53e8de6f7b9f76688" translate="yes" xml:space="preserve">
          <source>Floating Point Transformations</source>
          <target state="translated">Трансформации плавающей точки</target>
        </trans-unit>
        <trans-unit id="2bed0fff60a5113135f273ef65f90946ade02e38" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters to improve readability, and which are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00848e3da3c10e7ab7937982dcd4c2d2c3dffaaa" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">Плавающие литералы могут иметь встроенные символы &amp;laquo;_&amp;raquo;, которые игнорируются.</target>
        </trans-unit>
        <trans-unit id="2f633a3ecaf3e65628ed43650f2d2e7563e4708a" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. Floating literals followed by &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; are of type &lt;code&gt;float&lt;/code&gt;, and those followed by &lt;b&gt;L&lt;/b&gt; are of type &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01668267e3349ef380ebd600403f931fc5d66ef9" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. They can be followed by one &lt;b&gt;f&lt;/b&gt;, &lt;b&gt;F&lt;/b&gt;, or &lt;b&gt;L&lt;/b&gt; suffix. The &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; suffix types it is a &lt;code&gt;float&lt;/code&gt;, and &lt;b&gt;L&lt;/b&gt; types it is a &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">Плавающие литералы без суффикса имеют тип &lt;code&gt;double&lt;/code&gt; . За ними может следовать один суффикс &lt;b&gt;f&lt;/b&gt; , &lt;b&gt;F&lt;/b&gt; или &lt;b&gt;L. &lt;/b&gt;&lt;b&gt;Е&lt;/b&gt; или &lt;b&gt;F&lt;/b&gt; типа суффиксов это &lt;code&gt;float&lt;/code&gt; , и &lt;b&gt;L&lt;/b&gt; типа это &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a4195feb88e405b4996ac5dcca713ad5c6175c1" translate="yes" xml:space="preserve">
          <source>Floating point NaN's are formatted as &lt;b&gt;nan&lt;/b&gt; if the</source>
          <target state="translated">NaN с плавающей точкой форматируются как &lt;b&gt;нано,&lt;/b&gt; если</target>
        </trans-unit>
        <trans-unit id="afa8bdea6b3525811aead9f74976b708a0d15aba" translate="yes" xml:space="preserve">
          <source>Floating point comparison operators</source>
          <target state="translated">Операторы сравнения с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="ed4b0ae6cd9ee0a107d7642401f3d58f692c98b4" translate="yes" xml:space="preserve">
          <source>Floating point comparisons</source>
          <target state="translated">Сравнения с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="51fe49d981df10fc2a3ca0c38f66d9ec597eda64" translate="yes" xml:space="preserve">
          <source>Floating point computations can be carried out at a higher precision than the size of the floating point variable can hold. Floating point algorithms should continue to work properly if precision is arbitrarily increased.</source>
          <target state="translated">Расчеты с плавающей точкой могут быть выполнены с большей точностью,чем может выдержать размер переменной с плавающей точкой.Алгоритмы вычислений с плавающей точкой должны продолжать корректно работать при произвольном увеличении точности.</target>
        </trans-unit>
        <trans-unit id="cbc0ff66a82e332f74b6f7f08625c15927132156" translate="yes" xml:space="preserve">
          <source>Floating point constants are internally represented in the implementation in at least &lt;code&gt;real&lt;/code&gt; precision, regardless of the constant's type. The extra precision is available for constant folding. Committing to the precision of the result is done as late as possible in the compilation process. For example:</source>
          <target state="translated">Константы с плавающей точкой внутренне представлены в реализации, по крайней мере, с &lt;code&gt;real&lt;/code&gt; точностью, независимо от типа константы. Дополнительная точность доступна для постоянного складывания. Принятие во внимание точности результата выполняется как можно позже в процессе компиляции. Например:</target>
        </trans-unit>
        <trans-unit id="35c2559ddef9cb0435b556f187c76ca13d0d375f" translate="yes" xml:space="preserve">
          <source>Floating point numbers</source>
          <target state="translated">Числа с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="95bc83092a43ba79dea2ddad11b46e7cfef6083c" translate="yes" xml:space="preserve">
          <source>Floating point numerics functions.</source>
          <target state="translated">Числовые функции с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="160661b47177ecb78c896bad472b47b4dfd37f9e" translate="yes" xml:space="preserve">
          <source>Floating point return values are returned on the FPU stack. These must be cleaned off by the caller, even if they are not used.</source>
          <target state="translated">Возвращаемые значения с плавающей точкой возвращаются в стек FPU.Они должны быть очищены вызывающим абонентом,даже если они не используются.</target>
        </trans-unit>
        <trans-unit id="33856b075b952fb87e57ad69006f9b871108ab99" translate="yes" xml:space="preserve">
          <source>Floating point types cannot be implicitly converted to integral types. Complex or imaginary floating point types cannot be implicitly converted to non-complex floating point types. Non-complex floating point types cannot be implicitly converted to imaginary floating point types.</source>
          <target state="translated">Типы с плавающей точкой не могут быть неявно приведены к интегральным типам.Сложные или мнимые типы с плавающей точкой не могут быть неявно приведены к несложным типам с плавающей точкой.Не сложные типы с плавающей точкой не могут быть неявно приведены к воображаемым типам с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d3a01c245469b7e18ff38a92dc5c6ea9b1ec4c23" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (cfloat, cdouble, and creal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+] [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|nan+nani|inf|-inf]</source>
          <target state="translated">Номер с плавающей точкой:(cfloat,cdouble и creal)['+'|'-']цифра(и)[.][цифра(и)][[e-|e+]цифра(и)][+][цифра(и)][[e-|e+]цифра(и)][i|f|L|Li|fi]]]или [nan|nani|nan+nani|inf|-inf].</target>
        </trans-unit>
        <trans-unit id="6d2316f26e5bf23de4ad985a49ccce2c80f4f913" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (float, double, real, ifloat, idouble, and ireal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|inf|-inf]</source>
          <target state="translated">Номер с плавающей точкой:(float,double,real,ifloat,idouble и ireal)['+'|'-']цифра(и)[.][цифра(и)][[e-|e+]цифра(и)][i|f|L|Li|fi]]]или [nan|nani|inf|-inf].</target>
        </trans-unit>
        <trans-unit id="4e439c8e69a24e7d54c5622205640014d4f59099" translate="yes" xml:space="preserve">
          <source>Floating-Point manipulation</source>
          <target state="translated">Манипуляция с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="417d3791f22357e1adf665e28ee4d505d124a89d" translate="yes" xml:space="preserve">
          <source>Floating-point operations</source>
          <target state="translated">Операции с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="e0d24bd6f36291462113f127088f35f4090a373d" translate="yes" xml:space="preserve">
          <source>Floating-point random variate of type &lt;code&gt;T&lt;/code&gt; drawn from the uniform distribution across the half-open interval [0, 1).</source>
          <target state="translated">Случайные переменные с плавающей точкой типа &lt;code&gt;T&lt;/code&gt; , взятые из равномерного распределения по полуоткрытому интервалу [0, 1).</target>
        </trans-unit>
        <trans-unit id="f2714b106a05319f2ace1ce68d8ac69bcf4f5ff7" translate="yes" xml:space="preserve">
          <source>Floating-point values are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Значения с плавающей точкой форматируются как &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6b8da4fa90bdf05e2c05a6593125f02a7d82431" translate="yes" xml:space="preserve">
          <source>Floats can be in decimal or hexadecimal format.</source>
          <target state="translated">Поплавки могут быть в десятичном или шестнадцатеричном формате.</target>
        </trans-unit>
        <trans-unit id="aee4c734dc6fd3c7a89584d7e5348d40237e1949" translate="yes" xml:space="preserve">
          <source>Flush cookie jar to disk.</source>
          <target state="translated">Промойте банку с печеньем на диск.</target>
        </trans-unit>
        <trans-unit id="7f0c95d2e99f8f6f791a3dcf13701e05342006cc" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;FILE&lt;/code&gt; buffers.</source>
          <target state="translated">Очищает буферы C &lt;code&gt;FILE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bebb80c78ce429db39d79d68feeba680b58038de" translate="yes" xml:space="preserve">
          <source>Folding White Space contains consecutive CRLF sequences</source>
          <target state="translated">Складное белое пространство содержит последовательные последовательности CRLF</target>
        </trans-unit>
        <trans-unit id="67f0ed9d72f8298bdd413ec634b75103f7a22dc1" translate="yes" xml:space="preserve">
          <source>Folding White Space ends with a CRLF sequence</source>
          <target state="translated">Складывание Белого Пространства заканчивается последовательностью CRLF</target>
        </trans-unit>
        <trans-unit id="08097cc4ab9f5b9568ed73c27e3a597381bce1b4" translate="yes" xml:space="preserve">
          <source>Following arguments works the same way as &lt;code&gt;bitfield&lt;/code&gt;'s. The bitfield must fit into the bits known to be zero because of the pointer alignment.</source>
          <target state="translated">Следующие аргументы работают так же, как &lt;code&gt;bitfield&lt;/code&gt; . Битовое поле должно соответствовать нулевым битам из-за выравнивания указателя.</target>
        </trans-unit>
        <trans-unit id="6cfe2219958a5948a49371cf65d64e832c75a6f7" translate="yes" xml:space="preserve">
          <source>Following initialization, the &lt;code&gt;HashTable&lt;/code&gt; object would consistently use its &lt;code&gt;allocator&lt;/code&gt; object for acquiring memory. Furthermore, setting &lt;code&gt;HashTable.allocator&lt;/code&gt; to point to a different allocator should be legal but only if the object is empty; otherwise, the object wouldn't be able to deallocate its existing state.</source>
          <target state="translated">После инициализации объект &lt;code&gt;HashTable&lt;/code&gt; будет последовательно использовать свой объект- &lt;code&gt;allocator&lt;/code&gt; для получения памяти. Кроме того, установка &lt;code&gt;HashTable.allocator&lt;/code&gt; для указания на другой распределитель должна быть допустимой, но только если объект пуст; в противном случае объект не сможет освободить свое существующее состояние.</target>
        </trans-unit>
        <trans-unit id="c77938fcdf67aea78282407b90406b49eb71c3e5" translate="yes" xml:space="preserve">
          <source>Follows Itanium C++ ABI 1.86 section 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt; which is where the grammar comments come from.</source>
          <target state="translated">Следует Itanium C ++ ABI 1.86, раздел 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling,&lt;/a&gt; откуда поступают комментарии по грамматике.</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="2496332383d78a1d33c27c0e38fa6de47dc78a49" translate="yes" xml:space="preserve">
          <source>For &quot;store&quot; operations of the form: op1 op= op2</source>
          <target state="translated">Для операций &quot;магазин&quot; форма:op1 op=op2</target>
        </trans-unit>
        <trans-unit id="97c9b61a869134f6120476fe4a99b3b11a45291d" translate="yes" xml:space="preserve">
          <source>For 16 bit generator, this is always a (targ_short) sign-extended value.</source>
          <target state="translated">Для 16-битного генератора это всегда знаковое расширенное значение (targ_short).</target>
        </trans-unit>
        <trans-unit id="78b280836f07395eef32226ce729d39d05fd0d6b" translate="yes" xml:space="preserve">
          <source>For 64 bit code, follows Itanium C++ ABI 1.86 Chapter 3 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</source>
          <target state="translated">Для 64-битного кода следует Itanium C ++ ABI 1.86 Глава 3 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11a5de5d335b50e0f5cf5b3413b2f30e630b28c1" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;type#basic-data-types&quot;&gt;basic data types&lt;/a&gt;, all possible bit patterns are safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23dde54b23d16d77035a1e0e2b0833121f3ea89" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; or the operation would result in an overflow, sets &lt;code&gt;v&lt;/code&gt; to &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">Для &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; если &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; или операция приведет к переполнению, множества &lt;code&gt;v&lt;/code&gt; в &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; . В остальном семантика та же, что и для встроенного оператора.</target>
        </trans-unit>
        <trans-unit id="c0328592d323a259faf0da7a348a86fd52092b62" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">Для &lt;code&gt;-&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; , если &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; возвращает &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; . В остальном семантика та же, что и для встроенного оператора.</target>
        </trans-unit>
        <trans-unit id="4e56b23a72d6de96ffb1933a70486eb64d0dea7d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;foreach&lt;/code&gt;, the elements for the array are iterated over starting at index 0 and continuing to the maximum of the array. For &lt;code&gt;foreach_reverse&lt;/code&gt;, the array elements are visited in the reverse order.</source>
          <target state="translated">Для &lt;code&gt;foreach&lt;/code&gt; элементы массива перебираются, начиная с индекса 0 и продолжаясь до максимума массива. Для &lt;code&gt;foreach_reverse&lt;/code&gt; элементы массива посещаются в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="d0ceede7c3735e19c4f9e84dfec5a98cdaa80c75" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;windowSize = 1&lt;/code&gt; it splits the range into single element groups (aka &lt;code&gt;unflatten&lt;/code&gt;) For &lt;code&gt;windowSize = 2&lt;/code&gt; it is similar to &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;windowSize = 1&lt;/code&gt; она делит диапазон на отдельные группы элементов (иначе &lt;code&gt;unflatten&lt;/code&gt; ) Для &lt;code&gt;windowSize = 2&lt;/code&gt; она похожа на &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fde640aa4409bbb47d5287c2ea78c26d39f59e9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt;: The function returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt; : функция возвращает &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ba5d0612e564fafee84b671c5c4d115f7c0b6e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt;: If &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, the function returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise it returns the normal result of the operator.</source>
          <target state="translated">Для &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt; : если &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; , функция возвращает &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; . В противном случае он возвращает нормальный результат оператора.</target>
        </trans-unit>
        <trans-unit id="d465e34c13d15e0333f8cd7f1c7c1944ae2b7911" translate="yes" xml:space="preserve">
          <source>For C++ class cd, generate an instance of _cpp_type_info_ptr and populate it with a pointer to the C++ type info.</source>
          <target state="translated">Для класса C++cd,сгенерируйте экземпляр _cpp_type_info_ptr и заполните его указателем на информацию о типе C++.</target>
        </trans-unit>
        <trans-unit id="84fc2ed3d82dfac4fe4b1db7e54128df57816954" translate="yes" xml:space="preserve">
          <source>For Posix/x86_64 this returns the type which will really be used for passing an argument of type va_list.</source>
          <target state="translated">Для Posix/x86_64 возвращается тип,который действительно будет использоваться для передачи аргумента типа va_list.</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">Для заявления</target>
        </trans-unit>
        <trans-unit id="1658d59f02098b291dd70d6afbe72baf35b0b46e" translate="yes" xml:space="preserve">
          <source>For TypeFunction, nextOf() can return NULL if the function return type is meant to be inferred, and semantic() hasn't yet ben run on the function. After semantic(), it must no longer be NULL.</source>
          <target state="translated">Для функции TypeFunction nextOf()может возвращать NULL,если предполагается,что тип возвращаемой функции является выведенным,и семантическая()еще не выполнялась в функции.После функции semantic()она больше не должна быть NULL.</target>
        </trans-unit>
        <trans-unit id="ed4c1eb6664e08f8534b1fe769460ebc44281875" translate="yes" xml:space="preserve">
          <source>For a lazy version, refer to &lt;a href=&quot;std_range#repeat&quot;&gt;&lt;code&gt;std.range.repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для ленивой версии, обратитесь к &lt;a href=&quot;std_range#repeat&quot;&gt; &lt;code&gt;std.range.repeat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8cd7374ae5703f87c90badd0385e4fb829226681" translate="yes" xml:space="preserve">
          <source>For a lazy version, see &lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt;&lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt; &lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt; &lt;/a&gt; версию смотрите в std.algorithm.iteration.joiner</target>
        </trans-unit>
        <trans-unit id="20ca13cf71a91c26b14ec6bf15dd84151e56cf9e" translate="yes" xml:space="preserve">
          <source>For a lazy, non-allocating version of these functions, see &lt;a href=&quot;#byUTF&quot;&gt;&lt;code&gt;byUTF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#byUTF&quot;&gt; &lt;code&gt;byUTF&lt;/code&gt; &lt;/a&gt; , не выделяющуюся версию этих функций смотрите в UTF .</target>
        </trans-unit>
        <trans-unit id="567c03cab3251ca5dd2f65be01f597e8de5b789b" translate="yes" xml:space="preserve">
          <source>For a less strict parser, see &lt;a href=&quot;#parseUUID&quot;&gt;&lt;code&gt;parseUUID&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для менее строгого парсера смотрите &lt;a href=&quot;#parseUUID&quot;&gt; &lt;code&gt;parseUUID&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3242f7887a56a8199a86141fd1d3d295d57af7c" translate="yes" xml:space="preserve">
          <source>For a nested class instance, the &lt;code&gt;.outer&lt;/code&gt; property is the &lt;code&gt;this&lt;/code&gt; reference for the enclosing class's instance. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would be a &lt;code&gt;void*&lt;/code&gt; to the enclosing function frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cf17cd505298c5983970817a14f4d4aa02e1a3" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; and the setter has no effect.</source>
          <target state="translated">Для пула нулевого размера получатель произвольно возвращает &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; , и установщик не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="703bdcc05cee4b856a950e3e2494d43650695c33" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns true and the setter has no effect.</source>
          <target state="translated">Для нулевого пула размера,геттер произвольно возвращает true и сеттер не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="7062424b6df58f7b0070477aac1caffce7eac347" translate="yes" xml:space="preserve">
          <source>For all assign expressions, the left operand must be a modifiable lvalue. The type of the assign expression is the type of the left operand, and the value is the value of the left operand after assignment occurs. The resulting expression is a modifiable lvalue.</source>
          <target state="translated">Для всех выражений присваивания,левый операнд должен быть модифицируемым значением l.Типом выражения присваивания является тип левого операнда,а значением-значение левого операнда после того,как происходит присваивание.Полученное в результате выражение является модифицируемым значением l.</target>
        </trans-unit>
        <trans-unit id="4c1c5870b4b89a912a0f2d752c3a6fab5551a649" translate="yes" xml:space="preserve">
          <source>For all other cases, the temporaries generated for the purpose of invoking functions are deferred to the end of the full expression. The order of destruction is inverse to the order of construction.</source>
          <target state="translated">Во всех остальных случаях временные файлы,генерируемые для вызова функций,откладываются до конца полного выражения.Порядок разрушения обратный порядку построения.</target>
        </trans-unit>
        <trans-unit id="95e2e0ca2da36fd3882b011dd82190d8d5ee7297" translate="yes" xml:space="preserve">
          <source>For an introductory look at &lt;b&gt;std.format&lt;/b&gt;'s capabilities and how to use this module see the dedicated &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki article&lt;/a&gt;.</source>
          <target state="translated">Для ознакомления с возможностями &lt;b&gt;std.format&lt;/b&gt; и с тем, как использовать этот модуль, смотрите специальную &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;статью на DWiki&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fb635d85e291212fc5e73d7b40aa121e5ce7593" translate="yes" xml:space="preserve">
          <source>For an introductory look at &lt;b&gt;std.format&lt;/b&gt;'s capabilities and how to use this module see the dedicated &lt;a href=&quot;https://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki article&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076ae6cb1419d1feff35ba4b7e6bb266176337c6" translate="yes" xml:space="preserve">
          <source>For another example:</source>
          <target state="translated">Для другого примера:</target>
        </trans-unit>
        <trans-unit id="4f7c5dea21579ef43f50bda4d8b8e7dd5ee9236e" translate="yes" xml:space="preserve">
          <source>For any given platform/compiler curl_off_t must be typedef'ed to a 64-bit wide signed integral data type. The width of this data type must remain constant and independent of any possible large file support settings.</source>
          <target state="translated">Для любой платформы/компилятора curl_off_t должен быть приведен к знаковому интегральному типу данных 64-битного размера.Ширина этого типа данных должна оставаться постоянной и не зависеть от любых возможных настроек поддержки больших файлов.</target>
        </trans-unit>
        <trans-unit id="078912245b32cd2a66bf3a96da7307acc2485fbe" translate="yes" xml:space="preserve">
          <source>For any other declaration even if &lt;code&gt;@disable&lt;/code&gt; is a syntactically valid attribute &lt;code&gt;false&lt;/code&gt; is returned because the annotation has no effect.</source>
          <target state="translated">Для любого другого объявления, даже если &lt;code&gt;@disable&lt;/code&gt; является синтаксически действительным атрибутом, возвращается &lt;code&gt;false&lt;/code&gt; , поскольку аннотация не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="701d1a14380c65e4a855899951d9d7a65d27e60f" translate="yes" xml:space="preserve">
          <source>For any values &lt;code&gt;v1&lt;/code&gt; on the right-hand side and &lt;code&gt;v2&lt;/code&gt; on the left-hand side:</source>
          <target state="translated">Для любых значений &lt;code&gt;v1&lt;/code&gt; с правой стороны и &lt;code&gt;v2&lt;/code&gt; с левой стороны:</target>
        </trans-unit>
        <trans-unit id="f1e77f1044f99821b0b2c5cfb9d3d37a079ad5ec" translate="yes" xml:space="preserve">
          <source>For applications like command line switch processing, this can lead to much more straightforward code, being clearer and less error prone. char, wchar and dchar strings are allowed.</source>
          <target state="translated">Для таких приложений,как обработка переключателей командной строки,это может привести к гораздо более прямолинейному коду,который будет более понятным и менее склонен к ошибкам.</target>
        </trans-unit>
        <trans-unit id="d1b8d2445b680cd8ee27f3fc95623cb30af7a286" translate="yes" xml:space="preserve">
          <source>For arguments of built-in types, assignment operator expressions such as</source>
          <target state="translated">Для аргументов встроенных типов,выражения оператора присваивания,такие как</target>
        </trans-unit>
        <trans-unit id="0f5d29eff2633e7fd841d0a6738a98ac739e92a9" translate="yes" xml:space="preserve">
          <source>For arrays:</source>
          <target state="translated">Для массивов:</target>
        </trans-unit>
        <trans-unit id="dc14ba04c2c4629e1d2d0d30f5dc9d2a1dddd9e2" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;a[]&lt;/code&gt; and &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Для обратной совместимости, &lt;code&gt;a[]&lt;/code&gt; и &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="542878137297059fb68730fd24d9158d8fdb95d5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;multiwayMerge&lt;/code&gt; is available under the name &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; under the name of &lt;code&gt;NWayUnion&lt;/code&gt; . Future code should use &lt;code&gt;multiwayMerge&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; as &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;NWayUnion&lt;/code&gt; will be deprecated.</source>
          <target state="translated">Для обеспечения обратной совместимости &lt;code&gt;multiwayMerge&lt;/code&gt; доступна под названием &lt;code&gt;nWayUnion&lt;/code&gt; и &lt;code&gt;MultiwayMerge&lt;/code&gt; под названием &lt;code&gt;NWayUnion&lt;/code&gt; . Код будущего должны использовать &lt;code&gt;multiwayMerge&lt;/code&gt; и &lt;code&gt;MultiwayMerge&lt;/code&gt; в &lt;code&gt;nWayUnion&lt;/code&gt; и &lt;code&gt;NWayUnion&lt;/code&gt; устареет.</target>
        </trans-unit>
        <trans-unit id="e3a3c169dbbfe63cc4460a15c98153cda1f6881e" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if rewriting &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Для обратной совместимости, если переписать &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92276f55c3cccb89a03bd28b0c6443429cb6df1c" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail and &lt;code&gt;opSliceOpAssign&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; are tried, respectively.</source>
          <target state="translated">Для обратной совместимости, если вышеприведенные перезаписи &lt;code&gt;opSliceOpAssign&lt;/code&gt; неудачно и определяется opSliceOpAssign , то перезаписываются &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; и &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="e5a6a2446de90976e232d13603325c19c48a5a94" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail to compile and &lt;code&gt;opSliceUnary&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; are tried instead, respectively.</source>
          <target state="translated">Для обратной совместимости, если вышеописанные перезаписи не &lt;code&gt;opSliceUnary&lt;/code&gt; скомпилировать и определяется opSliceUnary , то &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; перезаписи a.opSliceUnary! (Op) (i, j) и &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="757d4d7a3dccc207f58716a0eadde379a304a5d2" translate="yes" xml:space="preserve">
          <source>For binary operators, the result is as follows:</source>
          <target state="translated">Для двоичных операторов результат выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="aeea5f41f2c7d1bd01e14aae86afc3b17192c6d2" translate="yes" xml:space="preserve">
          <source>For blocks &amp;gt;= pagesize, the length is a size_t and is at the beginning of the block. The reason we have to do this is because the block can extend into more pages, so we cannot trust the block length if it sits at the end of the block, because it might have just been extended. If we can prove in the future that the block is unshared, we may be able to change this, but I'm not sure it's important.</source>
          <target state="translated">Для блоков&amp;gt; = размер страницы длина равна size_t и находится в начале блока. Причина, по которой мы должны это сделать, заключается в том, что блок может расширяться на несколько страниц, поэтому мы не можем доверять длине блока, если он находится в конце блока, потому что он мог быть только что расширен. Если мы сможем доказать в будущем, что блок не является общим, мы можем изменить это, но я не уверен, что это важно.</target>
        </trans-unit>
        <trans-unit id="6435d22c869fa126d1d0aea9e7983183ab7f918e" translate="yes" xml:space="preserve">
          <source>For both ++i and --i</source>
          <target state="translated">Как для ++i,так и для --i</target>
        </trans-unit>
        <trans-unit id="93107872cedc76cc5719158670858cf146f5ce57" translate="yes" xml:space="preserve">
          <source>For both i++ and i--</source>
          <target state="translated">как для i++,так и для i...</target>
        </trans-unit>
        <trans-unit id="c2f1745a5232cce644154e5a3850452a31978021" translate="yes" xml:space="preserve">
          <source>For both overloads, the entire value of the Duration is split among the units (rather than splitting the Duration across all units and then only providing the values for the requested units), so if only one unit is given, the result is equivalent to &lt;a href=&quot;#total&quot;&gt;&lt;code&gt;total&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для обеих перегрузок все значение Duration разделяется между единицами (вместо того, чтобы разделять Duration по всем единицам и затем только предоставлять значения для запрошенных единиц), поэтому, если задана только одна единица, результат эквивалентен &lt;a href=&quot;#total&quot;&gt; &lt;code&gt;total&lt;/code&gt; &lt;/a&gt; значению. ,</target>
        </trans-unit>
        <trans-unit id="ad0f0aabfe7ebb013586fcfb45b89ab392324a84" translate="yes" xml:space="preserve">
          <source>For built-in numerical types, accurate Knuth &amp;amp; Welford mean calculation is used. For user-defined types, element by element summation is used. Additionally an extra parameter &lt;code&gt;seed&lt;/code&gt; is needed in order to correctly seed the summation with the equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Для встроенных числовых типов используется точный расчет среднего Кнута и Уэлфорда. Для пользовательских типов используется поэлементное суммирование. Кроме того, для правильного заполнения суммирования с эквивалентом &lt;code&gt;0&lt;/code&gt; требуется дополнительный &lt;code&gt;seed&lt;/code&gt; параметр .</target>
        </trans-unit>
        <trans-unit id="a4cc9dd81eb95c3553b97b6dbcaf73ca851ceabc" translate="yes" xml:space="preserve">
          <source>For calendar-based operations that don't care about time zones, then &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; would be the type to use. For system time, use &lt;code&gt;SysTime&lt;/code&gt;.</source>
          <target state="translated">Для операций на основе календаря, которые не заботятся о часовых поясах, тогда &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; будет использоваться. Для системного времени используйте &lt;code&gt;SysTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7199c84f095b28abf14901a280827544df19151" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is known at compile-time, functions are provided for arbitrary encoding and decoding of characters, arbitrary transcoding between strings of different type, as well as validation and sanitization.</source>
          <target state="translated">Для случаев,когда кодировка известна во время компиляции,предусмотрены функции произвольной кодировки и декодирования символов,произвольного перекодирования между строками разного типа,а также валидации и дезинфекции.</target>
        </trans-unit>
        <trans-unit id="a53a545de095bd4f4e296c839d801de6e744e030" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is not known at compile-time, but is known at run-time, the abstract class &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; and its subclasses is provided. To construct a run-time encoder/decoder, one does e.g.</source>
          <target state="translated">Для случаев, когда кодирование неизвестно во время компиляции, но известно во время выполнения, предоставляется абстрактный класс &lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt; и его подклассы. Чтобы создать кодер / декодер во время выполнения, нужно сделать, например,</target>
        </trans-unit>
        <trans-unit id="d53cba26ee6cdc76a4ea74c67f57bac33bebf848" translate="yes" xml:space="preserve">
          <source>For class and struct objects, the expression &lt;code&gt;(a == b)&lt;/code&gt; is rewritten as &lt;code&gt;a.opEquals(b)&lt;/code&gt;, and &lt;code&gt;(a != b)&lt;/code&gt; is rewritten as &lt;code&gt;!a.opEquals(b)&lt;/code&gt;.</source>
          <target state="translated">Для объектов класса и структуры выражение &lt;code&gt;(a == b)&lt;/code&gt; переписывается как &lt;code&gt;a.opEquals(b)&lt;/code&gt; , а &lt;code&gt;(a != b)&lt;/code&gt; переписывается как &lt;code&gt;!a.opEquals(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6164499db4fd6a0a2e064668be7de8146561558" translate="yes" xml:space="preserve">
          <source>For class objects, identity is defined as the object references are for the same object. Null class objects can be compared with &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">Для объектов класса идентичность определяется как ссылки на объекты для одного и того же объекта. Объекты нулевого класса можно сравнить с &lt;code&gt;is&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95c093eaf464e50c213285367cf108a1f21af7e6" translate="yes" xml:space="preserve">
          <source>For class objects, the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators are intended to compare the contents of the objects, however an appropriate &lt;code&gt;opEquals&lt;/code&gt; override must be defined for this to work. The default &lt;code&gt;opEquals&lt;/code&gt; provided by the root &lt;code&gt;Object&lt;/code&gt; class is equivalent to the &lt;code&gt;is&lt;/code&gt; operator. Comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents. Use the &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt; operators instead.</source>
          <target state="translated">Для объектов класса операторы &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Предназначены для сравнения содержимого объектов, однако для этого необходимо &lt;code&gt;opEquals&lt;/code&gt; соответствующее переопределение opEquals . Стандартные &lt;code&gt;opEquals&lt;/code&gt; , предоставляемые корневым классом &lt;code&gt;Object&lt;/code&gt; , эквивалентны оператору &lt;code&gt;is&lt;/code&gt; . Сравнение с &lt;code&gt;null&lt;/code&gt; недопустимо, так как &lt;code&gt;null&lt;/code&gt; не имеет содержимого. Используйте &lt;code&gt;is&lt;/code&gt; и &lt;code&gt;!is&lt;/code&gt; операторами вместо этого.</target>
        </trans-unit>
        <trans-unit id="d5b1405cc3330cccfdcfd53a468de428485e9157" translate="yes" xml:space="preserve">
          <source>For class objects, the relational operators compare the contents of the objects. Therefore, comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents.</source>
          <target state="translated">Для объектов класса реляционные операторы сравнивают содержимое объектов. Поэтому сравнение с &lt;code&gt;null&lt;/code&gt; недопустимо, так как &lt;code&gt;null&lt;/code&gt; отсутствует.</target>
        </trans-unit>
        <trans-unit id="ab366bbd1fd34ad6f5b2cd340e858e3c25d5bb75" translate="yes" xml:space="preserve">
          <source>For class objects, the result of Object.opCmp() forms the left operand, and 0 forms the right operand. The result of the relational expression (o1 op o2) is:</source>
          <target state="translated">Для объектов класса результат Object.opCmp()формирует левый операнд,а 0-правый операнд.Результатом реляционного выражения (o1 op o2)является:</target>
        </trans-unit>
        <trans-unit id="e894f77d4bc27bedbf87e79de7b7a21550ebd3e1" translate="yes" xml:space="preserve">
          <source>For class objects:</source>
          <target state="translated">Для объектов класса:</target>
        </trans-unit>
        <trans-unit id="6ae638739525d1c55b35c525b46eec46d1197fc5" translate="yes" xml:space="preserve">
          <source>For completeness a level 1 trie is simply an array. The current implementation takes advantage of bit-packing values when the range is known to be limited in advance (such as &lt;code&gt;bool&lt;/code&gt;). See also &lt;a href=&quot;#BitPacked&quot;&gt;&lt;code&gt;BitPacked&lt;/code&gt;&lt;/a&gt; for enforcing it manually. The major size advantage however comes from the fact that multiple &lt;b&gt;identical pages on every level are merged&lt;/b&gt; by construction.</source>
          <target state="translated">Для полноты дерева уровня 1 это просто массив. Текущая реализация использует преимущества значений упаковки битов, когда известно, что диапазон заранее ограничен (например, &lt;code&gt;bool&lt;/code&gt; ). Смотрите также &lt;a href=&quot;#BitPacked&quot;&gt; &lt;code&gt;BitPacked&lt;/code&gt; &lt;/a&gt; для принудительного применения. Однако главное преимущество в размере связано с тем, что несколько &lt;b&gt;идентичных страниц на каждом уровне объединяются&lt;/b&gt; по построению.</target>
        </trans-unit>
        <trans-unit id="8ebdc89d7f40766ce711349010ffd3cd409b6e68" translate="yes" xml:space="preserve">
          <source>For complex numbers, equality is defined as equivalent to:</source>
          <target state="translated">Для комплексных чисел равенство определяется как эквивалент:</target>
        </trans-unit>
        <trans-unit id="c92d80178cde078393b89e6d6a1bab596929a28f" translate="yes" xml:space="preserve">
          <source>For consistency and predictability, there are several standard sections. None of these are required to be present.</source>
          <target state="translated">Для обеспечения последовательности и предсказуемости существует несколько стандартных разделов.Ни один из них не обязан присутствовать.</target>
        </trans-unit>
        <trans-unit id="b5df2d0a44db277a01e403815ff3d6ffbf0a4688" translate="yes" xml:space="preserve">
          <source>For console programs, &lt;code&gt;main()&lt;/code&gt; serves as the entry point. It gets called after all the module initializers are run, and after any unittests are run. After it returns, all the module destructors are run. &lt;code&gt;main()&lt;/code&gt; must be declared using one of the following forms:</source>
          <target state="translated">Для консольных программ &lt;code&gt;main()&lt;/code&gt; служит точкой входа. Он вызывается после запуска всех инициализаторов модулей и после выполнения любых тестов модулей. После возврата все деструкторы модуля запускаются. &lt;code&gt;main()&lt;/code&gt; должен быть объявлен с использованием одной из следующих форм:</target>
        </trans-unit>
        <trans-unit id="a87a16b2108087eba4cfd4c27e06f2199e9c9ea6" translate="yes" xml:space="preserve">
          <source>For convenience</source>
          <target state="translated">Для удобства</target>
        </trans-unit>
        <trans-unit id="c28923eb8e6fce56c97d1e69a2459b17db795a95" translate="yes" xml:space="preserve">
          <source>For convenience, if the seed is const, or has qualified fields, then &lt;code&gt;reduce&lt;/code&gt; will operate on an unqualified copy. If this happens then the returned type will not perfectly match &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">Для удобства, если начальное число является постоянным или имеет квалифицированные поля, то &lt;code&gt;reduce&lt;/code&gt; будет работать с неквалифицированной копией. Если это произойдет , то возвращаемый тип не будет полностью соответствовать &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db55a017e4d8880bceaa15cbff12d8e02dda2446" translate="yes" xml:space="preserve">
          <source>For convenience, this module publicly imports &lt;a href=&quot;core_time&quot;&gt;&lt;code&gt;core.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для удобства этот модуль публично импортирует &lt;a href=&quot;core_time&quot;&gt; &lt;code&gt;core.time&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0750ffdd6d85bc11bd3ef50c265df606e3d06eba" translate="yes" xml:space="preserve">
          <source>For conversion of strings to signed types, the grammar recognized is:</source>
          <target state="translated">Для преобразования строк в знаковые типы распознается грамматика:</target>
        </trans-unit>
        <trans-unit id="6d295d9ab6e17239455a68d95e6a9009da2b2b99" translate="yes" xml:space="preserve">
          <source>For conversion to unsigned types, the grammar recognized is:</source>
          <target state="translated">При преобразовании в беззнаковые типы распознается грамматика:</target>
        </trans-unit>
        <trans-unit id="7cbf49f210f0c77ac5cb0d36bff7e0a64b475c82" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal.</source>
          <target state="translated">Для правильного сравнения возвращает положительное целое число, если &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; , отрицательное целое число, если &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , если два равны.</target>
        </trans-unit>
        <trans-unit id="3eb5e30aca486d38067e5e0193c4b1bb0345617f" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal. Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it aborts the program.</source>
          <target state="translated">Для правильного сравнения возвращает положительное целое число, если &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; , отрицательное целое число, если &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , если два равны. При ошибочном сравнении, таком как &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; , функция никогда не возвращается, потому что она прерывает программу.</target>
        </trans-unit>
        <trans-unit id="fa11ef91f282359e697ab411a2105694aa1fc413" translate="yes" xml:space="preserve">
          <source>For debuggers that can be modified to accept new types, the following extensions help them fully support the types.</source>
          <target state="translated">Для отладчиков,которые могут быть модифицированы для принятия новых типов,следующие расширения помогают им полностью поддерживать типы.</target>
        </trans-unit>
        <trans-unit id="70f5609ca5e86e5be455bc08ca5f8a240497ea5a" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are always passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e9558b3c028e1d9a23d1722de151ab9342540d" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="translated">Для динамического массива и параметров объекта,которые передаются по ссылке,вход/выход/оформление применяются только к ссылке,а не к содержимому.</target>
        </trans-unit>
        <trans-unit id="26ffddfdbc1c41c2be1034e80310b3f852b74078" translate="yes" xml:space="preserve">
          <source>For each active attribute (ref/const/nogc/etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">Для каждого активного атрибута (ref / const / nogc / etc) вызовите &lt;code&gt;fp&lt;/code&gt; с void * для рабочего параметра и строковым представлением атрибута.</target>
        </trans-unit>
        <trans-unit id="8eea3bce7669308b1434c353731e136dc4b97c1c" translate="yes" xml:space="preserve">
          <source>For each active modifier (MODFlags.const_, MODFlags.immutable_, etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">Для каждого активного модификатора (MODFlags.const_, MODFlags.immutable_ и т. Д.) Вызовите &lt;code&gt;fp&lt;/code&gt; с void * для рабочего параметра и строковым представлением атрибута.</target>
        </trans-unit>
        <trans-unit id="3203682624a9b4a1635c6de69e488d06fa56e15c" translate="yes" xml:space="preserve">
          <source>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the evaluation point, similarly to creation of a usual named value initialized with an expression.</source>
          <target state="translated">Для каждой оценки,которая дает временное значение,время жизни этого временного значения начинается с точки оценки,аналогично созданию обычного именованного значения,инициализированного выражением.</target>
        </trans-unit>
        <trans-unit id="5f7caa6316d56bf976ab623e5dd0b440be2fe098" translate="yes" xml:space="preserve">
          <source>For each function &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;fun&lt;/code&gt;, the corresponding seed type &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an element of &lt;code&gt;r&lt;/code&gt;: &lt;code&gt;ElementType!R&lt;/code&gt; for ranges, and &lt;code&gt;ForeachType!R&lt;/code&gt; otherwise.</source>
          <target state="translated">Для каждой функции &lt;code&gt;f&lt;/code&gt; в &lt;code&gt;fun&lt;/code&gt; соответствующий начальный тип &lt;code&gt;S&lt;/code&gt; равен &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt; , где &lt;code&gt;e&lt;/code&gt; является элементом &lt;code&gt;r&lt;/code&gt; : &lt;code&gt;ElementType!R&lt;/code&gt; для диапазонов, а &lt;code&gt;ForeachType!R&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="89f96ba2b9022471ac4b3f99072ac57893d52c5d" translate="yes" xml:space="preserve">
          <source>For each function that has exception handlers, an EH table entry is generated.</source>
          <target state="translated">Для каждой функции,имеющей обработчики исключений,генерируется запись в EH-таблице.</target>
        </trans-unit>
        <trans-unit id="c170bc5a2dcbb7f263f34807c28c73343f6168e3" translate="yes" xml:space="preserve">
          <source>For each template parameter, the following rules are applied in order until a type is deduced for each parameter:</source>
          <target state="translated">Для каждого параметра шаблона применяются следующие правила до тех пор,пока для каждого параметра не будет выведен тип:</target>
        </trans-unit>
        <trans-unit id="de2d36eb496ad6425d4fddf01b0f74d4997c1c21" translate="yes" xml:space="preserve">
          <source>For each type &lt;code&gt;T&lt;/code&gt; on the left-hand side and each type &lt;code&gt;U&lt;/code&gt; on the right-hand side, values of type &lt;code&gt;T&lt;/code&gt; can be compared with values of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Для каждого типа &lt;code&gt;T&lt;/code&gt; на стороне левой руки и каждый типе &lt;code&gt;U&lt;/code&gt; на правой стороне, значение типа &lt;code&gt;T&lt;/code&gt; может быть сопоставлено со значениями типа &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e27d5d7f20198430510bed8d554d11950a10ed02" translate="yes" xml:space="preserve">
          <source>For each value &lt;code&gt;v1&lt;/code&gt; on the left-hand side and each value &lt;code&gt;v2&lt;/code&gt; on the right-hand side, the expression &lt;code&gt;v1 == v2&lt;/code&gt; is true.</source>
          <target state="translated">Для каждого значения &lt;code&gt;v1&lt;/code&gt; с левой стороны и каждого значения &lt;code&gt;v2&lt;/code&gt; с правой стороны выражение &lt;code&gt;v1 == v2&lt;/code&gt; является истинным.</target>
        </trans-unit>
        <trans-unit id="9025d5cca105be0e8976e2851061cc835c9a962a" translate="yes" xml:space="preserve">
          <source>For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly initialized. An UUID is empty if &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; is true. Empty UUIDs are equal to &lt;code&gt;UUID.init&lt;/code&gt;, which is a UUID with all 16 bytes set to 0. Use UUID's constructors or the UUID generator functions to get an initialized UUID.</source>
          <target state="translated">Для эффективности UUID реализован в виде структуры. UUID, следовательно, пустые, если не инициализированы явно. UUID пуст, если значение &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; равно true. Пустые UUID равны &lt;code&gt;UUID.init&lt;/code&gt; , который является UUID со всеми 16 байтами, установленными в 0. Используйте конструкторы UUID или функции генератора UUID, чтобы получить инициализированный UUID.</target>
        </trans-unit>
        <trans-unit id="62d0aac1e2c0659f1732b0c95533d24eac16f4a7" translate="yes" xml:space="preserve">
          <source>For example the primitives &lt;code&gt;c.remove(r)&lt;/code&gt; and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; both remove the sequence of elements in range &lt;code&gt;r&lt;/code&gt; from the container &lt;code&gt;c&lt;/code&gt;. The primitive &lt;code&gt;c.remove(r)&lt;/code&gt; guarantees &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;) complexity in the worst case and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; relaxes this guarantee to &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;).  Since a sequence of elements can be removed from a &lt;a href=&quot;std_container_dlist&quot;&gt;doubly linked list&lt;/a&gt; in constant time, &lt;code&gt;DList&lt;/code&gt; provides the primitive &lt;code&gt;c.remove(r)&lt;/code&gt; as well as &lt;code&gt;c.linearRemove(r)&lt;/code&gt;. On the other hand &lt;a href=&quot;std_container_array&quot;&gt;Array&lt;/a&gt; only offers &lt;code&gt;c.linearRemove(r)&lt;/code&gt;.  The following table describes the common set of primitives that containers implement. A container need not implement all primitives, but if a primitive is implemented, it must support the syntax described in the &lt;b&gt;syntax&lt;/b&gt; column with the semantics described in the &lt;b&gt;description&lt;/b&gt; column, and it must not have a worst-case complexity worse than denoted in big-O notation in the &amp;Omicron;(&lt;code&gt;&amp;middot;&lt;/code&gt;) column. Below, &lt;code&gt;C&lt;/code&gt; means a container type, &lt;code&gt;c&lt;/code&gt; is a value of container type, &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; represents the effective length of value &lt;code&gt;x&lt;/code&gt;, which could be a single element (in which case &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;), a container, or a range.</source>
          <target state="translated">Например, примитивы &lt;code&gt;c.remove(r)&lt;/code&gt; и &lt;code&gt;c.linearRemove(r)&lt;/code&gt; удаляют последовательность элементов в диапазоне &lt;code&gt;r&lt;/code&gt; из контейнера &lt;code&gt;c&lt;/code&gt; . Примитив &lt;code&gt;c.remove(r)&lt;/code&gt; гарантирует сложность &amp;Omicron; ( &lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; ) в худшем случае, а &lt;code&gt;c.linearRemove(r)&lt;/code&gt; ослабляет эту гарантию до &amp;Omicron; ( &lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; ). Поскольку последовательность элементов может быть удалена из &lt;a href=&quot;std_container_dlist&quot;&gt;двусвязного списка&lt;/a&gt; за постоянное время, &lt;code&gt;DList&lt;/code&gt; предоставляет примитив &lt;code&gt;c.remove(r)&lt;/code&gt; а также &lt;code&gt;c.linearRemove(r)&lt;/code&gt; . С другой стороны, &lt;a href=&quot;std_container_array&quot;&gt;массив&lt;/a&gt;предлагает только &lt;code&gt;c.linearRemove(r)&lt;/code&gt; . В следующей таблице описывается общий набор примитивов, которые реализуют контейнеры. Контейнеру не нужно реализовывать все примитивы, но если примитив реализован, он должен поддерживать синтаксис, описанный в столбце &lt;b&gt;синтаксиса,&lt;/b&gt; с семантикой, описанной в столбце &lt;b&gt;описания&lt;/b&gt; , и он не должен иметь сложность наихудшего случая хуже, чем обозначено в большой Обозначения в колонке &amp;Omicron; ( &lt;code&gt;&amp;middot;&lt;/code&gt; ). Ниже &lt;code&gt;C&lt;/code&gt; означает тип контейнера, &lt;code&gt;c&lt;/code&gt; является значением типа контейнера, &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; представляет эффективную длину значения &lt;code&gt;x&lt;/code&gt; , которое может быть одним элементом (в этом случае &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; является &lt;code&gt;1&lt;/code&gt; ) контейнер или диапазон.</target>
        </trans-unit>
        <trans-unit id="d00edd8f12a04d1befc302c87668dfdb2d903e2a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\U0001F603&lt;/code&gt; represents the Unicode character U+1F603 (SMILING FACE WITH OPEN MOUTH).</source>
          <target state="translated">Например, &lt;code&gt;\U0001F603&lt;/code&gt; представляет символ Unicode U + 1F603 (УЛЫБКА ЛИЦА С ОТКРЫТОЙ РОТОЙ).</target>
        </trans-unit>
        <trans-unit id="bddb2b6572ea79b1700e73180c6a9ef4a9e2c7be" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\u03B3&lt;/code&gt; represents the Unicode character &amp;gamma; (U+03B3 - GREEK SMALL LETTER GAMMA).</source>
          <target state="translated">Например, &lt;code&gt;\u03B3&lt;/code&gt; представляет символ Юникода &amp;gamma; (U + 03B3 - ГРЕЧЕСКАЯ МАЛЕНЬКАЯ ГАММА ПИСЬМА).</target>
        </trans-unit>
        <trans-unit id="e8c9021af829ec2346f217a33bffab12b0880918" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;a[index]&lt;/code&gt; is really &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;s.f&lt;/code&gt; is really &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;a[index]&lt;/code&gt; - это действительно &lt;code&gt;a&lt;/code&gt; , а &lt;code&gt;s.f&lt;/code&gt; - это &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="429a44b7b476fadc40e55c9fb2ea9f99eab49de1" translate="yes" xml:space="preserve">
          <source>For example, a programmatic equivalent of Unix's &lt;code&gt;chmod +x name&lt;/code&gt; to make a file executable is &lt;code&gt;name.setAttributes(name.getAttributes | octal!700)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee49e2b5de63bc28985d9e3f5b2391109f50868" translate="yes" xml:space="preserve">
          <source>For example, consider a class that is a container for two elements:</source>
          <target state="translated">Например,рассмотрим класс,который является контейнером для двух элементов:</target>
        </trans-unit>
        <trans-unit id="f4060213712449048c8c23e8aed13169261c66f1" translate="yes" xml:space="preserve">
          <source>For example, for the Intel Pentium:</source>
          <target state="translated">Например,для Intel Pentium:</target>
        </trans-unit>
        <trans-unit id="56a66959fa3d6d051e3f2985a858c24aef88cfec" translate="yes" xml:space="preserve">
          <source>For example, given a class &lt;code&gt;Sum&lt;/code&gt; that is used to add two values, a unit test can be given:</source>
          <target state="translated">Например, учитывая класс &lt;code&gt;Sum&lt;/code&gt; , который используется для добавления двух значений, может быть задан модульный тест:</target>
        </trans-unit>
        <trans-unit id="afa20f7fd4e06e98278c1c050fed1f04af8aa95d" translate="yes" xml:space="preserve">
          <source>For example, here is how to remove a single element from an array:</source>
          <target state="translated">Например,как удалить один элемент из массива:</target>
        </trans-unit>
        <trans-unit id="664b22b4de56d86a94d4d1f08efe5f39ea8b5955" translate="yes" xml:space="preserve">
          <source>For example, if this qualifies to 'a1.a2' and pkg - to 'a1.a2.a3', this function returns 'true'. If it is other way around or qualified package paths conflict function returns 'false'.</source>
          <target state="translated">Например,если это соответствует 'a1.a2',а pkg-'a1.a2.a3',то эта функция возвращает 'true'.Если это другой способ или квалифицированный пакетный путь,то функция возвращает 'false'.</target>
        </trans-unit>
        <trans-unit id="2f4a0bc25491ad453cd52460e2badab7db117513" translate="yes" xml:space="preserve">
          <source>For example, in order to overload the &lt;code&gt;-&lt;/code&gt; (negation) operator for struct S, and no other operator:</source>
          <target state="translated">Например, чтобы перегрузить оператор &lt;code&gt;-&lt;/code&gt; (отрицание) для структуры S, а другого оператора нет:</target>
        </trans-unit>
        <trans-unit id="1db4a09c9c6a230d99b45c4869c4f6e84c23d582" translate="yes" xml:space="preserve">
          <source>For example, one could redefine &lt;code&gt;DDOC_SUMMARY&lt;/code&gt;:</source>
          <target state="translated">Например, можно переопределить &lt;code&gt;DDOC_SUMMARY&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e5d29b3a3287b6048a7baf84989543162cfde72" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;immutable&lt;/code&gt; type qualifier can be used to create variables of immutable type, such as:</source>
          <target state="translated">Например, квалификатор &lt;code&gt;immutable&lt;/code&gt; типа может использоваться для создания переменных неизменяемого типа, таких как:</target>
        </trans-unit>
        <trans-unit id="b3a7c81f27baa62d867db8143dafce975505e522" translate="yes" xml:space="preserve">
          <source>For example, the expression &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; is permitted when &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt; are expressions yielding pointers to memory block</source>
          <target state="translated">Например, выражение &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; разрешено, когда &lt;code&gt;p1&lt;/code&gt; , &lt;code&gt;p2&lt;/code&gt; являются выражениями, дающими указатели на блок памяти</target>
        </trans-unit>
        <trans-unit id="afa193b836783a5ecabcde946cad5a9128e2b421" translate="yes" xml:space="preserve">
          <source>For example, the following function template only matches with odd values of &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">Например, следующий шаблон функции соответствует только нечетным значениям &lt;code&gt;N&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="38096dc369d1ebe6ec7ec60de5ac2d73db72feee" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\101&lt;/code&gt; represents the character with the value 65 (&lt;code&gt;'A'&lt;/code&gt;). Analogous to hexadecimal characters, the largest byte value is &lt;code&gt;\377&lt;/code&gt; (= &lt;code&gt;\xFF&lt;/code&gt; in hexadecimal or &lt;code&gt;255&lt;/code&gt; in decimal)</source>
          <target state="translated">Например: &lt;code&gt;\101&lt;/code&gt; представляет символ со значением 65 ( &lt;code&gt;'A'&lt;/code&gt; ). Аналогично шестнадцатеричным символам, наибольшее значение байта равно &lt;code&gt;\377&lt;/code&gt; (= &lt;code&gt;\xFF&lt;/code&gt; в шестнадцатеричном или &lt;code&gt;255&lt;/code&gt; в десятичном)</target>
        </trans-unit>
        <trans-unit id="8187ba92149a37ed481170300ec07180dd3c8361" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\xFF&lt;/code&gt; represents the character with the value 255.</source>
          <target state="translated">Например: &lt;code&gt;\xFF&lt;/code&gt; представляет символ со значением 255.</target>
        </trans-unit>
        <trans-unit id="4d1688fe7c391489009113fe8f20b160cce3978f" translate="yes" xml:space="preserve">
          <source>For examples see the &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">Для примеров см. &lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="79381ea951fd6aadf813123f5b529dd772681030" translate="yes" xml:space="preserve">
          <source>For finite ranges, the result of &lt;code&gt;opSlice&lt;/code&gt; must be of the same type as the original range type. If the range defines &lt;code&gt;opDollar&lt;/code&gt;, then it must support subtraction.</source>
          <target state="translated">Для конечных диапазонов результат &lt;code&gt;opSlice&lt;/code&gt; должен быть того же типа, что и исходный тип диапазона. Если диапазон определяет &lt;code&gt;opDollar&lt;/code&gt; , то он должен поддерживать вычитание.</target>
        </trans-unit>
        <trans-unit id="c77ba69b2b7b1720fb5f6b789826c71a3c605b97" translate="yes" xml:space="preserve">
          <source>For float, double, and real values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. The values &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal. If either or both operands are NAN, then &lt;code&gt;==&lt;/code&gt; returns false and &lt;code&gt;!=&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, the bit patterns of the common type are compared for equality.</source>
          <target state="translated">Для значений типа float, double и real применяются &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;обычные арифметические преобразования&lt;/a&gt; , чтобы привести их к общему типу перед сравнением. Значения &lt;code&gt;-0&lt;/code&gt; и &lt;code&gt;+0&lt;/code&gt; считаются равными. Если один или оба операнда NAN, то &lt;code&gt;==&lt;/code&gt; возвращает ложные и &lt;code&gt;!=&lt;/code&gt; Возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае битовые комбинации общего типа сравниваются на равенство.</target>
        </trans-unit>
        <trans-unit id="ec28333c5408aa27a2824def03dd893394acfa05" translate="yes" xml:space="preserve">
          <source>For floating point inputs, calculations are made in &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt; precision for &lt;code&gt;real&lt;/code&gt; inputs and in &lt;code&gt;double&lt;/code&gt; precision otherwise (Note this is a special case that deviates from &lt;code&gt;fold&lt;/code&gt;'s behavior, which would have kept &lt;code&gt;float&lt;/code&gt; precision for a &lt;code&gt;float&lt;/code&gt; range). For all other types, the calculations are done in the same type obtained from from adding two elements of the range, which may be a different type from the elements themselves (for example, in case of &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;integral promotion&lt;/a&gt;).</source>
          <target state="translated">Для входных данных с плавающей запятой вычисления выполняются с &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt; точностью для &lt;code&gt;real&lt;/code&gt; входных данных и в противном случае с &lt;code&gt;double&lt;/code&gt; точностью (обратите внимание, что это особый случай, который отличается от поведения &lt;code&gt;fold&lt;/code&gt; , которое сохраняло бы точность с &lt;code&gt;float&lt;/code&gt; запятой для диапазона с &lt;code&gt;float&lt;/code&gt; ). Для всех других типов вычисления выполняются в том же типе, который получен при добавлении двух элементов диапазона, которые могут отличаться от самих элементов (например, в случае &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;интегрального продвижения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="765c4ec4b98b1848bab9c8fba86795001e6760ec" translate="yes" xml:space="preserve">
          <source>For floating point operands, the * and / operations correspond to the IEEE 754 floating point equivalents. % is not the same as the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas for IEEE 754, remainder(15.0,10.0) == -5.0.</source>
          <target state="translated">Для операндов с плавающей точкой операции*и/соответствуют эквивалентам IEEE 754 с плавающей точкой.% не соответствует остатку IEEE 754.Например,15.0 % 10.0 ==5.0,тогда как для IEEE 754,остаток(15.0,10.0)==-5.0.</target>
        </trans-unit>
        <trans-unit id="311831dfcbe2aa85299a9b7419ec3f7edbd674b9" translate="yes" xml:space="preserve">
          <source>For floating point operations and expression intermediate values, a greater precision can be used than the type of the expression. Only the minimum precision is set by the types of the operands, not the maximum. &lt;b&gt;Implementation Note:&lt;/b&gt; On Intel x86 machines, for example, it is expected (but not required) that the intermediate calculations be done to the full 80 bits of precision implemented by the hardware.</source>
          <target state="translated">Для операций с плавающей запятой и промежуточных значений выражения можно использовать большую точность, чем тип выражения. Только минимальная точность устанавливается типами операндов, а не максимальная. &lt;b&gt;Примечание по реализации:&lt;/b&gt; Например, на машинах Intel x86 ожидается (но не обязательно), что промежуточные вычисления будут выполнены с полными 80 битами точности, реализованной аппаратными средствами.</target>
        </trans-unit>
        <trans-unit id="a8f36fac9b0314aa81c6e99d081aedbe4af658c5" translate="yes" xml:space="preserve">
          <source>For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</source>
          <target state="translated">Для флотов максимально возможная грузоподъемность-0x3F_FFFFF.Для дубликатов-0x3_FFFFF_FFFF_FFFFF.Для 80-битных или 128-битных реалов-0x3FFFF_FFFFF_FFFF_FFFF.</target>
        </trans-unit>
        <trans-unit id="f68bb29877591d4b489a9f6fff54379ee749f0f3" translate="yes" xml:space="preserve">
          <source>For forward compatibility, the CPU is compared against different microarchitectures. For 32-bit x86, comparisons are made against the Intel PPro/PII/PIII/PM family.</source>
          <target state="translated">Для обеспечения прямой совместимости процессор сравнивается с различными микроархитектурами.Для 32-разрядной архитектуры x86 проводится сравнение с семейством Intel PPro/PII/PIII/PM.</target>
        </trans-unit>
        <trans-unit id="cb68f2aaef1107ffda2b00fc87de858154352d8d" translate="yes" xml:space="preserve">
          <source>For functions which operate on Unicode characters, see &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для функций, которые работают с символами Unicode, смотрите &lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c427f88fad780106904fb230a561fe45ae8afed" translate="yes" xml:space="preserve">
          <source>For functions, the &lt;code&gt;auto&lt;/code&gt; attribute means return type inference. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">Для функций атрибут &lt;code&gt;auto&lt;/code&gt; означает вывод типа возврата. Смотрите &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Авто Функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb6e8700842932cee5fe004d021df4907ea6dd83" translate="yes" xml:space="preserve">
          <source>For further information see the the two functions defined inside of this template.</source>
          <target state="translated">Для получения более подробной информации см.две функции,определенные внутри этого шаблона.</target>
        </trans-unit>
        <trans-unit id="6d45ac630dd39944ad55493060e8c4dac92d7fc5" translate="yes" xml:space="preserve">
          <source>For garbage collected pointers and references, however, there are some restrictions. These restrictions are minor, but they are intended to enable the maximum flexibility in garbage collector design.</source>
          <target state="translated">Однако,для указателей и ссылок на собранный мусор существуют некоторые ограничения.Эти ограничения незначительны,но они призваны обеспечить максимальную гибкость при проектировании мусорных коллекторов.</target>
        </trans-unit>
        <trans-unit id="b7afa355fcaa31af2cd3f80d70dbcf199acfca98" translate="yes" xml:space="preserve">
          <source>For historical compatibility when &lt;code&gt;nbits == 192&lt;/code&gt; and &lt;code&gt;UIntType&lt;/code&gt; is &lt;code&gt;uint&lt;/code&gt; a legacy hybrid PRNG is used consisting of a 160-bit xorshift combined with a 32-bit counter. This combined generator has period equal to the least common multiple of &lt;code&gt;2^^160 - 1&lt;/code&gt; and &lt;code&gt;2^^32&lt;/code&gt;.</source>
          <target state="translated">Для исторической совместимости, когда &lt;code&gt;nbits == 192&lt;/code&gt; и &lt;code&gt;UIntType&lt;/code&gt; - &lt;code&gt;uint&lt;/code&gt; , используется унаследованный гибридный PRNG, состоящий из 160-битного сдвига xorshift в сочетании с 32-битным счетчиком. Этот комбинированный генератор имеет период, равный наименьшему общему кратному &lt;code&gt;2^^160 - 1&lt;/code&gt; и &lt;code&gt;2^^32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="184c65349a2ddaab04f57fbc0fe983f92c59a278" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worth profiling to see if the void initializer actually improves results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373d2d5153ba00f28887ffdca247e026ee396782" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worthwhile to check to see if the void initializer actually improves results before using it.</source>
          <target state="translated">Для путей горячего кода стоит проверить,действительно ли инициализатор пустоты улучшает результаты перед его использованием.</target>
        </trans-unit>
        <trans-unit id="e4f4bd7aa4cad79620e1f6020bf4450eeadc7446" translate="yes" xml:space="preserve">
          <source>For illustration purposes only, every method call results in assertion failure. Use &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; to obtain a concrete matcher for UTF-8 or UTF-16 encodings.</source>
          <target state="translated">Только для иллюстрации, каждый вызов метода приводит к ошибке подтверждения. Используйте &lt;a href=&quot;#utfMatcher&quot;&gt; &lt;code&gt;utfMatcher&lt;/code&gt; ,&lt;/a&gt; чтобы получить конкретный сопоставитель для кодировок UTF-8 или UTF-16.</target>
        </trans-unit>
        <trans-unit id="4cd5f2dc243960435d23cc958481129bcfb42bcc" translate="yes" xml:space="preserve">
          <source>For infinite ranges, when</source>
          <target state="translated">Для бесконечных диапазонов,когда</target>
        </trans-unit>
        <trans-unit id="aae2fd6469d641f1e8d553dabcf2fe7c0be1babf" translate="yes" xml:space="preserve">
          <source>For instance, if the function used to generate a range of time points generated successive Easters (i.e. you're iterating over all of the Easters within the interval), the initial date probably isn't an Easter. Using &lt;code&gt;PopFirst.yes&lt;/code&gt; would tell the function which returned the range that &lt;code&gt;popFront&lt;/code&gt; was to be called so that front would then be an Easter - the next one generated by the function (which when iterating forward would be the Easter following the original &lt;code&gt;front&lt;/code&gt;, while when iterating backward, it would be the Easter prior to the original &lt;code&gt;front&lt;/code&gt;). If &lt;code&gt;PopFirst.no&lt;/code&gt; were used, then &lt;code&gt;front&lt;/code&gt; would remain the original time point and it would not necessarily be a time point which would be generated by the range-generating function (which in many cases is exactly what is desired - e.g. if iterating over every day starting at the beginning of the interval).</source>
          <target state="translated">Например, если функция, используемая для генерации диапазона временных точек, сгенерированных последовательно Easters (т. Е. Вы перебираете все Easters в пределах интервала), начальная дата, вероятно, не Пасха. Использование &lt;code&gt;PopFirst.yes&lt;/code&gt; сообщит функции, которая возвращает диапазон, который должен &lt;code&gt;popFront&lt;/code&gt; так что front будет затем Пасхой - следующей, сгенерированной функцией (которая при итерации вперед будет Пасхой после исходного &lt;code&gt;front&lt;/code&gt; , тогда как когда итерируя в обратном направлении, это будет Пасха до первоначального &lt;code&gt;front&lt;/code&gt; ). Если использовались &lt;code&gt;PopFirst.no&lt;/code&gt; , то &lt;code&gt;front&lt;/code&gt; останется исходной временной точкой, и она не обязательно будет временной точкой, которая была бы сгенерирована функцией генерации диапазона (которая во многих случаях является именно тем, что требуется - например, если повторяться каждый день, начиная с начала интервала) ,</target>
        </trans-unit>
        <trans-unit id="1a761bf1c3bac8790220dd0e044887eeb25a2cc8" translate="yes" xml:space="preserve">
          <source>For instructions with the imm8 version: PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW, PSRLDQ, PSLLDQ</source>
          <target state="translated">Для инструкций в исполнении imm8:PSLLD,PSLLQ,PSLLW,PSRAD,PSRAW,PSRLD,PSRLQ,PSRLW,PSRLDQ,PSLLDQ</target>
        </trans-unit>
        <trans-unit id="abfb408bf733bafad2f02f380cf2ab1c7688837d" translate="yes" xml:space="preserve">
          <source>For instructions: CMPPD, CMPSS, CMPSD, CMPPS, PSHUFD, PSHUFHW, PSHUFLW, BLENDPD, BLENDPS, DPPD, DPPS, MPSADBW, PBLENDW, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS</source>
          <target state="translated">Для инструкций:CMPPD,CMPSS,CMPSD,CMPPS,PSHUFD,PSHUFHW,PSHUFLW,BLENDPD,BLENDPS,DPPD,DPPS,MPSADBW,PBLENDW,ROUNDPD,ROUNDPS,ROUNDSD,ROUNDSS</target>
        </trans-unit>
        <trans-unit id="c9f96708c73215da1e5407fa5ce762f21c941725" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2912089b8e4b5f7fb17c30aa7f29625c50f1f39a" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend. If the divisor is zero, an Exception is thrown.</source>
          <target state="translated">Для целых операндов операторов &lt;code&gt;/&lt;/code&gt; и &lt;code&gt;%&lt;/code&gt; частное округляется до нуля, а остаток имеет тот же знак, что и дивиденд. Если делитель равен нулю, создается исключение.</target>
        </trans-unit>
        <trans-unit id="00fe6a3ea358be700add2733e7f987f7657eccea" translate="yes" xml:space="preserve">
          <source>For integral operands, the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; correspond to multiply, divide, and modulus operations. For multiply, overflows are ignored and simply chopped to fit into the integral type.</source>
          <target state="translated">Для целочисленных операндов &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; и &lt;code&gt;%&lt;/code&gt; соответствуют операциям умножения, деления и модуля. Для умножения переполнения игнорируются и просто режутся, чтобы соответствовать целочисленному типу.</target>
        </trans-unit>
        <trans-unit id="f8089e9fce56a8de104b1a2fd89f78f4e3794e38" translate="yes" xml:space="preserve">
          <source>For large file support, there is also a LARGE version of the key which takes an off_t type, allowing platforms with larger off_t sizes to handle larger files. See below for INFILESIZE_LARGE.</source>
          <target state="translated">Для поддержки больших файлов существует также LARGE версия ключа,которая снимает тип off_t,позволяя платформам с большими размерами off_t обрабатывать большие файлы.Смотрите ниже для INFILESIZE_LARGE.</target>
        </trans-unit>
        <trans-unit id="4573bc72a0b35e6968fbc43281884135acda5317" translate="yes" xml:space="preserve">
          <source>For many processes, a grapheme cluster behaves as if it was a single character with the same properties as its grapheme base. Effectively, nonspacing marks apply</source>
          <target state="translated">Для многих процессов графемный кластер ведет себя так,как будто это один персонаж,обладающий теми же свойствами,что и его графемная основа.По сути,нерассеянные метки применяются</target>
        </trans-unit>
        <trans-unit id="d9d2c4569580379d483d010c37b2df4e739e00dd" translate="yes" xml:space="preserve">
          <source>For methods, it would be the class object or struct value the method is called on. For nested functions it would be the enclosing function's stack frame.</source>
          <target state="translated">Для методов это будет объект класса или значение структуры,к которому вызывается метод.Для вложенных функций это будет рамка стека вложенной функции.</target>
        </trans-unit>
        <trans-unit id="c658e43c1de6b0fdb8fb67e28199ecda730200d8" translate="yes" xml:space="preserve">
          <source>For more control than the high level functions provide, use the low level API:</source>
          <target state="translated">Для большего контроля,чем обеспечивают функции высокого уровня,используйте API низкого уровня:</target>
        </trans-unit>
        <trans-unit id="62fcc5c0c32d14129884b840a9ef5db5f9b4d71a" translate="yes" xml:space="preserve">
          <source>For more info about callbacks read the &lt;a href=&quot;function#closures&quot;&gt;closures&lt;/a&gt; section.</source>
          <target state="translated">Для получения дополнительной информации о обратных вызовах прочитайте раздел &lt;a href=&quot;function#closures&quot;&gt;замыканий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71b3018631aa22db33f776c9f67587180199aba3" translate="yes" xml:space="preserve">
          <source>For more information and a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e48b9f8da2dcff74dfa76b614f30e09e82d9357" translate="yes" xml:space="preserve">
          <source>For more information on normalization forms see the &lt;a href=&quot;#Normalization&quot;&gt;normalization section&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о формах нормализации см. &lt;a href=&quot;#Normalization&quot;&gt;Раздел нормализации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c70774a3bc49910eb2a297e31d36c248a26d7f7c" translate="yes" xml:space="preserve">
          <source>For more information please see the full section on &lt;a href=&quot;unittest#documented-unittests&quot;&gt;documented unit tests&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см полного раздел &lt;a href=&quot;unittest#documented-unittests&quot;&gt;документированных модульных тестов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4836c4e8b6fd2beb1b18962cae04c16a239752f" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;reference documentation&lt;/a&gt; and the &lt;code&gt;ld&lt;/code&gt; man page.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;Справочную документацию&lt;/a&gt; и справочную страницу &lt;code&gt;ld&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d343011cf3b0f9c5af4eccef2d47be216bb18517" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Современное программирование COM в D&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3833d3948eb765db1f448508cd33cee5954a145d" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75305c01a420c526f9930f5f2afef16712fe3db" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;Compile-time Sequences&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;Последовательности времени компиляции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="232f8923a5b9a1c36aaeed4b764cc4a027de9c86" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;template#function-templates&quot;&gt;function templates&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;template#function-templates&quot;&gt;Шаблоны функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14fe53fd058540daece4c12310ac08fab7493096" translate="yes" xml:space="preserve">
          <source>For more information, see: &lt;a href=&quot;attribute#uda&quot;&gt;User-Defined Attributes&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации см .: &lt;a href=&quot;attribute#uda&quot;&gt;Пользовательские атрибуты&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b01b147c4aa5229fbefd3dfcace458d961ffaae" translate="yes" xml:space="preserve">
          <source>For more on infering uniqueness see the &lt;b&gt;unique&lt;/b&gt; and &lt;b&gt;lent&lt;/b&gt; keywords in the &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; language.  The downside of using &lt;code&gt;assumeUnique&lt;/code&gt;'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of &lt;code&gt;assumeUnique&lt;/code&gt; is simple and rare enough to be tolerable.</source>
          <target state="translated">Подробнее о выводе уникальности смотрите &lt;b&gt;уникальные&lt;/b&gt; и &lt;b&gt;предоставленные&lt;/b&gt; ключевые слова на языке &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; . Недостатком использования соглашения на основе соглашения с &lt;code&gt;assumeUnique&lt;/code&gt; является то, что в настоящее время нет формальной проверки правильности предположения; с &lt;code&gt;assumeUnique&lt;/code&gt; стороны, идиоматическое использование acceptUnique является простым и достаточно редким, чтобы быть терпимым.</target>
        </trans-unit>
        <trans-unit id="467ee170e1f7b089ee09d2538996894e7758fd89" translate="yes" xml:space="preserve">
          <source>For more on infering uniqueness see the &lt;b&gt;unique&lt;/b&gt; and &lt;b&gt;lent&lt;/b&gt; keywords in the &lt;a href=&quot;https://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; language.  The downside of using &lt;code&gt;assumeUnique&lt;/code&gt;'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of &lt;code&gt;assumeUnique&lt;/code&gt; is simple and rare enough to be tolerable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9821fa00e5b3937536d63348fff48dbf21802af0" translate="yes" xml:space="preserve">
          <source>For most purposes, direct usage of this template is not necessary; instead, this module provides default implementations: &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt;, implementing basic Base64 encoding, and &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base64URLNoPadding&quot;&gt;&lt;code&gt;Base64URLNoPadding&lt;/code&gt;&lt;/a&gt;, that implement the Base64 variant for use in URLs and filenames, with and without padding, respectively.</source>
          <target state="translated">В большинстве случаев прямое использование этого шаблона не требуется; вместо этого этот модуль предоставляет реализации по умолчанию: &lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt; , реализующий базовую кодировку Base64, и &lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Base64URLNoPadding&quot;&gt; &lt;code&gt;Base64URLNoPadding&lt;/code&gt; &lt;/a&gt; , которые реализуют вариант Base64 для использования в URL-адресах и именах файлов, с заполнением и без заполнения, соответственно.</target>
        </trans-unit>
        <trans-unit id="1227b6928512c13bafca17372e6fc839cf749e01" translate="yes" xml:space="preserve">
          <source>For negative durations, all of the split values will be negative.</source>
          <target state="translated">Для отрицательных длительностей все значения деления будут отрицательными.</target>
        </trans-unit>
        <trans-unit id="45d1ac4eefadfd952fb52f8057a9eb1805d7b858" translate="yes" xml:space="preserve">
          <source>For non-struct types, &lt;code&gt;move&lt;/code&gt; just performs &lt;code&gt;target = source&lt;/code&gt;:</source>
          <target state="translated">Для неструктурных типов &lt;code&gt;move&lt;/code&gt; просто выполняет &lt;code&gt;target = source&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3570c921d353ad6046f6122f9d8cb40d604f2aae" translate="yes" xml:space="preserve">
          <source>For other operand types, identity is defined as being the same as equality.</source>
          <target state="translated">Для других типов операндов идентичность определяется как то же самое,что и равенство.</target>
        </trans-unit>
        <trans-unit id="c79c85aac54555c7fe4b24d5b33131b97310e7b3" translate="yes" xml:space="preserve">
          <source>For other sized structs and static arrays, the return value is stored through a hidden pointer passed as an argument to the function.</source>
          <target state="translated">Для других размерных структур и статических массивов возвращаемое значение хранится через скрытый указатель,переданный в функцию в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="c922333737093f82b45fffe13ff631745c29e34e" translate="yes" xml:space="preserve">
          <source>For other types, the argument is built with itself, as in:</source>
          <target state="translated">Для других типов аргумент строится сам с собой:</target>
        </trans-unit>
        <trans-unit id="936523f8bfb5590c510abb12f08771cbe0e0675b" translate="yes" xml:space="preserve">
          <source>For our new type 'this', which is type-constructed from t, fill in the cto, ito, sto, scto, wto shortcuts.</source>
          <target state="translated">Для нашего нового типа 'this',который построен по типу t,заполните cto,ito,sto,scto,wto ярлыки.</target>
        </trans-unit>
        <trans-unit id="4b41c44e66bd12d32d9b45595720696363ec412b" translate="yes" xml:space="preserve">
          <source>For popular C libraries, the first place to look for the corresponding D interface file is the &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt;. If it isn't there already, and you write one, please contribute it to the Deimos Project.</source>
          <target state="translated">Для популярных библиотек C первое место, где нужно найти соответствующий файл интерфейса D, - это &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;проект Deimos&lt;/a&gt; . Если его там еще нет, и вы пишете его, пожалуйста, внесите его в проект Deimos.</target>
        </trans-unit>
        <trans-unit id="dd500fbbdcecf0b15b4a7bec7168a77dbb809b02" translate="yes" xml:space="preserve">
          <source>For precise typing of that area, you can also let the compiler generate the class instance into the DATA segment for you:</source>
          <target state="translated">Для точного набора этой области можно также позволить компилятору сгенерировать экземпляр класса в сегменте DATA:</target>
        </trans-unit>
        <trans-unit id="d95500d6486dd9976894874f4bc1686c74984f1a" translate="yes" xml:space="preserve">
          <source>For pretty-printing a type.</source>
          <target state="translated">Для красивой печати.</target>
        </trans-unit>
        <trans-unit id="6beaf38011ce8934c0bf0fe14801463a84176de7" translate="yes" xml:space="preserve">
          <source>For printing two types with qualification when necessary.</source>
          <target state="translated">Для печати двух типов с квалификацией,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="b457b27aba75e0c9b673db93afc4a6454c8737c9" translate="yes" xml:space="preserve">
          <source>For ranges that do not offer random access, &lt;code&gt;SearchPolicy.linear&lt;/code&gt; is the only policy allowed (and it must be specified explicitly lest it exposes user code to unexpected inefficiencies). For random-access searches, all policies are allowed, and &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; is the default.</source>
          <target state="translated">Для диапазонов, которые не предоставляют произвольный доступ, &lt;code&gt;SearchPolicy.linear&lt;/code&gt; является единственной разрешенной политикой (и она должна быть указана явно, чтобы не подвергать пользовательский код неожиданной неэффективности). Для поиска произвольного доступа, все политики будут разрешены, и &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ed3956141d9c50632728180436f8b91fa73ece41" translate="yes" xml:space="preserve">
          <source>For reals, logGamma is equivalent to log(fabs(gamma(x))).</source>
          <target state="translated">Для реалов,logGamma эквивалентна log(fabs(gamma(x))).</target>
        </trans-unit>
        <trans-unit id="96cc49076f4a58f629be6c15f8c505a83f5ad981" translate="yes" xml:space="preserve">
          <source>For runtime testing to see if certain vector instructions are available, see the functions in &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt;.</source>
          <target state="translated">Для тестирования во время выполнения, чтобы увидеть, доступны ли определенные векторные инструкции, смотрите функции в &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0f737f02cc74529ec3e1d25c3b2fb5c37d91021" translate="yes" xml:space="preserve">
          <source>For some D implementations, such as a translator from D to C, an inline assembler makes no sense, and need not be implemented. The version statement can be used to account for this:</source>
          <target state="translated">Для некоторых реализаций D,таких как переводчик с D на C,встроенный ассемблер не имеет смысла и не нуждается в реализации.Для этого можно использовать оператор версии:</target>
        </trans-unit>
        <trans-unit id="432250ecd3da26b3dac3ea1fed77d588163ee5c7" translate="yes" xml:space="preserve">
          <source>For stateless allocators, this does nothing.</source>
          <target state="translated">Для апатридов-распределителей это ничего не значит.</target>
        </trans-unit>
        <trans-unit id="098a57b35500f4f0a012b83d59f1556df0c13332" translate="yes" xml:space="preserve">
          <source>For statements implement loops with initialization, test, and increment clauses.</source>
          <target state="translated">Для операторов реализуют циклы с клаузулами инициализации,тестирования и инкремента.</target>
        </trans-unit>
        <trans-unit id="53f702e5ced5b4f4e7dbc696e5107fe16283acd0" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, equality is defined as the lengths of the arrays matching, and all the elements are equal.</source>
          <target state="translated">Для статических и динамических массивов равенство определяется как длина совпадения массивов,при этом все элементы равны.</target>
        </trans-unit>
        <trans-unit id="fa40b68079370408167ad68be5b40bbec28bf002" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, identity is defined as referring to the same array elements and the same number of elements.</source>
          <target state="translated">Для статических и динамических массивов идентичность определяется как отношение к одним и тем же элементам массива и одинаковому количеству элементов.</target>
        </trans-unit>
        <trans-unit id="0ec6b65a9ed5b90b70c026136f3fd68edfea3f4e" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, the result of the relational op is the result of the operator applied to the first non-equal element of the array. If two arrays compare equal, but are of different lengths, the shorter array compares as &quot;less&quot; than the longer array.</source>
          <target state="translated">Для статических и динамических массивов результатом реляционной операции является результат применения оператора к первому неэквивалентному элементу массива.Если два массива сравниваются равными,но разной длины,то более короткий массив сравнивается как &quot;меньше&quot;,чем более длинный.</target>
        </trans-unit>
        <trans-unit id="f2b8a81160066cc4e2c9823b604d02970c2dda27" translate="yes" xml:space="preserve">
          <source>For static arrays:</source>
          <target state="translated">Для статических массивов:</target>
        </trans-unit>
        <trans-unit id="e3e34261f3141bf464d51f74f924244b763433b8" translate="yes" xml:space="preserve">
          <source>For struct objects and floating point values, identity is defined as the bits in the operands being identical.</source>
          <target state="translated">Для объектов структуры и значений с плавающей точкой идентичность определяется как идентичные биты в операндах.</target>
        </trans-unit>
        <trans-unit id="dacb4ed6715c30c5a9147d7fcd6915634bae0082" translate="yes" xml:space="preserve">
          <source>For struct objects, equality means the result of the &lt;a href=&quot;operatoroverloading#equals&quot;&gt;&lt;code&gt;opEquals()&lt;/code&gt; member function&lt;/a&gt;. If an &lt;code&gt;opEquals()&lt;/code&gt; is not provided, equality is defined as the logical product of all equality results of the corresponding object fields.</source>
          <target state="translated">Для объектов структуры, равенство означает результат &lt;a href=&quot;operatoroverloading#equals&quot;&gt; &lt;code&gt;opEquals()&lt;/code&gt; функции - члена&lt;/a&gt; . Если &lt;code&gt;opEquals()&lt;/code&gt; не предоставлен, равенство определяется как логическое произведение всех результатов равенства соответствующих полей объекта.</target>
        </trans-unit>
        <trans-unit id="77b81660c87ba600c859281896d0e680dc7a0639" translate="yes" xml:space="preserve">
          <source>For struct types, operator overloading for the identity assignment is allowed.</source>
          <target state="translated">Для типов структур допускается перегрузка оператора при присвоении идентификационных данных.</target>
        </trans-unit>
        <trans-unit id="7d6ebd4bd1de4cb13975d6ad6d6494f493e36039" translate="yes" xml:space="preserve">
          <source>For structs that do not define &lt;code&gt;toString&lt;/code&gt;, the conversion to string produces the list of fields.</source>
          <target state="translated">Для структур, которые не определяют &lt;code&gt;toString&lt;/code&gt; , преобразование в строку создает список полей.</target>
        </trans-unit>
        <trans-unit id="24c5ae67500605fc6fe25591d513c37d81e53fba" translate="yes" xml:space="preserve">
          <source>For the &quot;this&quot; parameter to member functions</source>
          <target state="translated">Для &quot;этого&quot; параметра для функций-членов</target>
        </trans-unit>
        <trans-unit id="1c01d80e91a2499949025f2280ab6ed6d2555900" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; objects which does not have &lt;code&gt;toString&lt;/code&gt;,</source>
          <target state="translated">Для объектов &lt;code&gt;struct&lt;/code&gt; и &lt;code&gt;union&lt;/code&gt; ,у которых нет &lt;code&gt;toString&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="4f49cbadbf80fd5534728dbb0a52da7243f0e4cf" translate="yes" xml:space="preserve">
          <source>For the class objects which have input range interface,</source>
          <target state="translated">Для объектов класса,имеющих интерфейс входного диапазона,</target>
        </trans-unit>
        <trans-unit id="3fe70e23dba2fe2f6a6436972a79f198b1023846" translate="yes" xml:space="preserve">
          <source>For the default implementation, &lt;code&gt;notifyAll&lt;/code&gt;will behave like &lt;code&gt;notify&lt;/code&gt;.</source>
          <target state="translated">Для реализации по умолчанию, &lt;code&gt;notifyAll&lt;/code&gt; будет вести себя как &lt;code&gt;notify&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a32f3e2bbec4c5b80346149779ed01edefc9b85" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, a further check is made to see if the function can be called.</source>
          <target state="translated">Для выражения &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; где &lt;code&gt;exp&lt;/code&gt; - функция &lt;code&gt;@property&lt;/code&gt; , выполняется дополнительная проверка, чтобы узнать, можно ли вызвать функцию.</target>
        </trans-unit>
        <trans-unit id="b458b5efdd66ae7f2f84dbe61163a34a752450a1" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;typeof(exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, the type is the return type of the function, rather than the type of the function.</source>
          <target state="translated">Для выражения &lt;code&gt;typeof(exp)&lt;/code&gt; где &lt;code&gt;exp&lt;/code&gt; - функция &lt;code&gt;@property&lt;/code&gt; , тип - это тип возвращаемого значения функции, а не тип функции.</target>
        </trans-unit>
        <trans-unit id="4da3489e77815a3f59254a16848fd39b736c2ccf" translate="yes" xml:space="preserve">
          <source>For the given module, perform any post parsing analysis. Certain compiler backends (ie: GDC) have special placeholder modules whose source are empty, but code gets injected immediately after loading.</source>
          <target state="translated">Для данного модуля выполните любой пост-анализ.В некоторых бэкэндах компилятора (т.е.GDC)есть специальные модули-заполнительные модули,исходный код которых пуст,но вводится код сразу после загрузки.</target>
        </trans-unit>
        <trans-unit id="eee09d9bd02ca0e040c01e0c78e4b5fbf6e37934" translate="yes" xml:space="preserve">
          <source>For this CRC32 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">Для данной реализации дайджеста CRC32 нет необходимости вызывать запуск после построения по умолчанию.Вызов запуска дайджеста необходим только для сброса дайджеста.</target>
        </trans-unit>
        <trans-unit id="cffc81d750572e8587c7a4c64f2343abc051fae9" translate="yes" xml:space="preserve">
          <source>For this MD5 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">Для этой реализации MD5 Digest не требуется запускать вызов после построения по умолчанию.Вызов запуска дайджеста необходим только для сброса дайджеста.</target>
        </trans-unit>
        <trans-unit id="ed2c37418037d9b0c7a9812c6d18534a64e6ecf7" translate="yes" xml:space="preserve">
          <source>For this RIPEMD160 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">Для этого RIPEMD160 не требует запуска дайджеста после построения по умолчанию.Вызов запуска дайджеста необходим только для сброса дайджеста.</target>
        </trans-unit>
        <trans-unit id="249161f18b734896a386ad2283f2254a90cd8dc8" translate="yes" xml:space="preserve">
          <source>For this SHA Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">Для данной реализации SHA Digest не требуется запуск вызова после сборки по умолчанию.Вызов запуска дайджеста необходим только для сброса дайджеста.</target>
        </trans-unit>
        <trans-unit id="29b834a88118650bc23043a0e1a119bc9548636a" translate="yes" xml:space="preserve">
          <source>For unary &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;onOverflow&lt;/code&gt; is called if &lt;code&gt;lhs == Lhs.min&lt;/code&gt; and &lt;code&gt;Lhs&lt;/code&gt; is a signed type. The function returns &lt;code&gt;Lhs.max&lt;/code&gt;.</source>
          <target state="translated">Для унарный &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;onOverflow&lt;/code&gt; вызывается , если &lt;code&gt;lhs == Lhs.min&lt;/code&gt; и &lt;code&gt;Lhs&lt;/code&gt; является знаковым типом. Функция возвращает &lt;code&gt;Lhs.max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3735f46e74c34d876c612b5f0d45ae5d470195b4" translate="yes" xml:space="preserve">
          <source>For unsatisfied conditions, the conditionally compiled code need only be syntactically correct. It does not have to be semantically correct.</source>
          <target state="translated">Для неудовлетворенных условий условно скомпилированный код должен быть только синтаксически корректен.Он не обязательно должен быть семантически корректным.</target>
        </trans-unit>
        <trans-unit id="cbc5de8d1ef5491a35e3c236ec7889a9c2c4a94d" translate="yes" xml:space="preserve">
          <source>For use by application</source>
          <target state="translated">Для использования по назначению</target>
        </trans-unit>
        <trans-unit id="e74c782f1ffbeab9de3e921ce4304765a91d12e2" translate="yes" xml:space="preserve">
          <source>For use by application VFS</source>
          <target state="translated">Для использования приложением VFS</target>
        </trans-unit>
        <trans-unit id="3505b0edb5eee92682026f8144fd82b24c70a4f7" translate="yes" xml:space="preserve">
          <source>For use by built-in VFS</source>
          <target state="translated">Для использования встроенной VFS</target>
        </trans-unit>
        <trans-unit id="88dbc145581c8c0573b319436a71bb181cd0808c" translate="yes" xml:space="preserve">
          <source>For use by extension VFS</source>
          <target state="translated">Для использования с расширением VFS</target>
        </trans-unit>
        <trans-unit id="230bac78e67f31568eb4729e25ce498036be0132" translate="yes" xml:space="preserve">
          <source>For user defined types. Should be equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Для пользовательских типов. Должно быть равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f2524697bf575ce5005555e479cdd81f208227" translate="yes" xml:space="preserve">
          <source>For user-defined types, assignment operator expressions are overloaded separately from the binary operator. Still the left operand must be an lvalue.</source>
          <target state="translated">Для заданных пользователем типов выражения оператора присваивания перегружаются отдельно от двоичного оператора.При этом левый операнд должен быть значением l.</target>
        </trans-unit>
        <trans-unit id="0fb758f20654c3c8f3d278d2ed2c4c22389d5933" translate="yes" xml:space="preserve">
          <source>For using time zones other than local time or UTC, use &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Posix systems (or on Windows, if providing the TZ Database files), and use &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt; on Windows systems. The time in &lt;code&gt;SysTime&lt;/code&gt; is kept internally in hnsecs from midnight, January 1st, 1 A.D. UTC. Conversion error cannot happen when changing the time zone of a &lt;code&gt;SysTime&lt;/code&gt;. &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents the local time, and &lt;code&gt;UTC&lt;/code&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents UTC. &lt;code&gt;SysTime&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; if no &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; is provided. For more details on time zones, see the documentation for &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для использования часовых поясов, отличных от местного времени или UTC, используйте &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt; в системах Posix (или в Windows, если предоставляются файлы базы данных TZ) и используйте &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt; в системах Windows. Время в &lt;code&gt;SysTime&lt;/code&gt; хранится внутри hnsecs с полуночи 1 января 1 года по Гринвичу. Ошибка преобразования не может произойти при изменении часового пояса &lt;code&gt;SysTime&lt;/code&gt; . &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; - это класс &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; ,&lt;/a&gt; который представляет местное время, а &lt;code&gt;UTC&lt;/code&gt; - это класс &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; ,&lt;/a&gt; который представляет UTC. &lt;code&gt;SysTime&lt;/code&gt; использует&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; ,&lt;/a&gt; если не&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о часовых поясах см. В документации по&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt; и&lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab8570d227afb15f540b536d5d1262c12c2ed538" translate="yes" xml:space="preserve">
          <source>For very large numbers, consider using the &lt;a href=&quot;http://gmplib.org&quot;&gt;GMP library&lt;/a&gt; instead.</source>
          <target state="translated">Для очень больших чисел рассмотрите возможность использования &lt;a href=&quot;http://gmplib.org&quot;&gt;библиотеки GMP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e95ca0b1ba53ec60e9f02c5651b3f5d4954e798d" translate="yes" xml:space="preserve">
          <source>For very large numbers, consider using the &lt;a href=&quot;https://gmplib.org&quot;&gt;GMP library&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0aaa1972b9827ddaeaa8c903dd012d64dc52a6" translate="yes" xml:space="preserve">
          <source>For very small x, expm1(x) is more accurate than exp(x)-1.</source>
          <target state="translated">Для очень маленького х,expm1(x)более точна,чем exp(x)-1.</target>
        </trans-unit>
        <trans-unit id="f6a75d7a9f98a84894db843b9fa129f7e85e4ad5" translate="yes" xml:space="preserve">
          <source>For very small x, log1p(x) will be more accurate than log(1 + x).</source>
          <target state="translated">Для очень маленького x,log1p(x)будет более точным,чем log(1+x).</target>
        </trans-unit>
        <trans-unit id="d5e2ba36b5f0fe67d03dfd60aced704179f8dc15" translate="yes" xml:space="preserve">
          <source>For virtual tables.</source>
          <target state="translated">Для виртуальных столов.</target>
        </trans-unit>
        <trans-unit id="9b2f5f01d7f036017bc44e0f5e7dd87067f218dd" translate="yes" xml:space="preserve">
          <source>For when the array has a non-zero initializer.</source>
          <target state="translated">Для случая,когда массив имеет ненулевой инициализатор.</target>
        </trans-unit>
        <trans-unit id="62235af30d4d3e83911b7f668444bdadcbf6e31f" translate="yes" xml:space="preserve">
          <source>For which &lt;code&gt;TargetOS&lt;/code&gt; the flags are applicable</source>
          <target state="translated">Для каких &lt;code&gt;TargetOS&lt;/code&gt; применяются флаги</target>
        </trans-unit>
        <trans-unit id="0512a8baa5c7d81d4b0fde3207bf25c16a72e5f5" translate="yes" xml:space="preserve">
          <source>ForStatement</source>
          <target state="translated">ForStatement</target>
        </trans-unit>
        <trans-unit id="2d317e6f14c862c7eb4252c51b1bf37d642b8a8c" translate="yes" xml:space="preserve">
          <source>ForStatements</source>
          <target state="translated">ForStatements</target>
        </trans-unit>
        <trans-unit id="809149a8ad9a0028e99b6a9d68c6c4147cc5a5e7" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by printing an error message to &lt;code&gt;stderr&lt;/code&gt; and then abort the program. &lt;code&gt;Abort&lt;/code&gt; is the default second argument for &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">Принудительно завершите все ошибки, напечатав сообщение об ошибке в &lt;code&gt;stderr&lt;/code&gt; , а затем прервите программу &lt;code&gt;Abort&lt;/code&gt; является вторым аргументом по умолчанию для &lt;code&gt;Checked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb769685cb2418f96e7eb5cd6f3bc4bc9cdba76c" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by throwing an exception of type &lt;code&gt;Throw.CheckFailure&lt;/code&gt;. The message coming with the error is similar to the one printed by &lt;code&gt;Warn&lt;/code&gt;.</source>
          <target state="translated">Принудительно завершите работу всех ошибок &lt;code&gt;Throw.CheckFailure&lt;/code&gt; исключение типа Throw.CheckFailure . Сообщение с ошибкой похоже на сообщение, напечатанное &lt;code&gt;Warn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="568ec7a75ae095d53209f55c9ce73fe37d60ef50" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;capacity&lt;/code&gt; to at least &lt;code&gt;x&lt;/code&gt; without reducing it.</source>
          <target state="translated">Вынуждает &lt;code&gt;capacity&lt;/code&gt; по крайней мере &lt;code&gt;x&lt;/code&gt; не уменьшая ее.</target>
        </trans-unit>
        <trans-unit id="19149ba839181262b9bdb188174930e36e6f0df9" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;this&lt;/code&gt; to the null state.</source>
          <target state="translated">Вынуждает &lt;code&gt;this&lt;/code&gt; к нулевому состоянию.</target>
        </trans-unit>
        <trans-unit id="a8db5e83b8a35fac9d3b32ebcc923950ddcc52de" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber and then throws obj in the calling fiber.</source>
          <target state="translated">Заставляет переключатель контекста произойти вдали от вызывающего волокна,а затем бросает объект в вызывающее волокно.</target>
        </trans-unit>
        <trans-unit id="2f48cbfa34abf44639ec829c0d55463cc9494c97" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber.</source>
          <target state="translated">Заставляет переключатель контекста произойти вдали от вызывающего волокна.</target>
        </trans-unit>
        <trans-unit id="80579a9d1e587d7b0ea440174e72821dab14c81a" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling thread.</source>
          <target state="translated">Заставляет контекстный переключатель произойти в стороне от вызывающей нити.</target>
        </trans-unit>
        <trans-unit id="13258c0abcfb4cca178a3b35d4e0664b60f42a89" translate="yes" xml:space="preserve">
          <source>Forces any data buffered by the OS to be written to disk. Call &lt;a href=&quot;#flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before calling this function to flush the C &lt;code&gt;FILE&lt;/code&gt; buffers first.</source>
          <target state="translated">Принудительно записывает любые данные, буферизованные ОС, на диск. Вызовите &lt;a href=&quot;#flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; перед вызовом этой функции, чтобы сначала очистить буферы C &lt;code&gt;FILE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23e389c62cad5bc7af8046c1d45faa80b7add735" translate="yes" xml:space="preserve">
          <source>Forces free list mode. If already in free list mode, does nothing. Otherwise, sorts the free list accumulated so far and switches strategy for future allocations to KR style.</source>
          <target state="translated">Режим свободного списка сил.Если уже находится в режиме свободного списка,ничего не делает.В противном случае сортирует накопленный до сих пор свободный список и переключается на стратегию для будущих распределений в стиле KR.</target>
        </trans-unit>
        <trans-unit id="7438f3f3f123487789d348d295cbd3a74e9f3636" translate="yes" xml:space="preserve">
          <source>Forces the number of elements in the container to &lt;code&gt;n&lt;/code&gt;. If the container ends up growing, the added elements are initialized in a container-dependent manner (usually with &lt;code&gt;T.init&lt;/code&gt;).</source>
          <target state="translated">Устанавливает количество элементов в контейнере в &lt;code&gt;n&lt;/code&gt; . Если контейнер в конечном итоге растет, добавленные элементы инициализируются в зависимости от контейнера (обычно с помощью &lt;code&gt;T.init&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="41991c2a7e01e941592d10ca1b4c7b6d194af71f" translate="yes" xml:space="preserve">
          <source>Forcibly deallocates all memory allocated by this allocator, making it available for further allocations. Does not return memory to &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">Принудительно освобождает всю память, выделенную этим распределителем, делая ее доступной для дальнейшего выделения. Не возвращает память в &lt;code&gt;ParentAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e05b71be24859a77e2790b0d8e71bc9f4dd8c1f8" translate="yes" xml:space="preserve">
          <source>Foreach</source>
          <target state="translated">Foreach</target>
        </trans-unit>
        <trans-unit id="24a9bd4ac18d7ddab41be52adbe896067b46f066" translate="yes" xml:space="preserve">
          <source>Foreach Range Methods</source>
          <target state="translated">Методы дальности действия Форач</target>
        </trans-unit>
        <trans-unit id="2c53155a2e00768b8f625193cebda30089ce0843" translate="yes" xml:space="preserve">
          <source>Foreach Range Properties</source>
          <target state="translated">Свойства хребта Форач</target>
        </trans-unit>
        <trans-unit id="45b6dd48295de07cd5e6e8af0d02a0aba0d48189" translate="yes" xml:space="preserve">
          <source>Foreach Range Statement</source>
          <target state="translated">Заявление о диапазоне Фореача</target>
        </trans-unit>
        <trans-unit id="3e61286776c3201ae4e25284f6e9997d2d997281" translate="yes" xml:space="preserve">
          <source>Foreach Ref Parameters</source>
          <target state="translated">Рефлектометрические параметры Фореача</target>
        </trans-unit>
        <trans-unit id="a6c2c1398fe7e48f653dc8f0a8caddaee072679f" translate="yes" xml:space="preserve">
          <source>Foreach Restrictions</source>
          <target state="translated">Ограничения Фореаха</target>
        </trans-unit>
        <trans-unit id="0553132dc6cdd5f87cabaeda4197e661d068c9f8" translate="yes" xml:space="preserve">
          <source>Foreach Statement</source>
          <target state="translated">Заявление Фореача</target>
        </trans-unit>
        <trans-unit id="da94ac95aa14d4788d7fd4a24d8272c7d97d35a8" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays</source>
          <target state="translated">Поверхность над массивами</target>
        </trans-unit>
        <trans-unit id="b1b911444dc098ad04d8c1492527b6551f0916f7" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays of Characters</source>
          <target state="translated">Вперед по массивам персонажей</target>
        </trans-unit>
        <trans-unit id="2a77599ec0f128dc2ac0586f465739ede0b37cd8" translate="yes" xml:space="preserve">
          <source>Foreach over Associative Arrays</source>
          <target state="translated">Форекс над ассоциативными массивами</target>
        </trans-unit>
        <trans-unit id="140fe06b456ed9f1ae3d0c4efbee66b6a7732580" translate="yes" xml:space="preserve">
          <source>Foreach over Delegates</source>
          <target state="translated">Обращаться к делегатам</target>
        </trans-unit>
        <trans-unit id="2118d2308b39d4304cee2cfe11851139c70627b5" translate="yes" xml:space="preserve">
          <source>Foreach over Sequences</source>
          <target state="translated">Форекс над последовательностями</target>
        </trans-unit>
        <trans-unit id="2f65a25f9fa525fd78d322a8ac805a6f39540fba" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with Ranges</source>
          <target state="translated">Фореч над штрихами и классы с диапазонами</target>
        </trans-unit>
        <trans-unit id="3d5dd8a83fe426ccb28e159ceb15528fef952829" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with opApply</source>
          <target state="translated">Фореч поверх струн и классов с opApply</target>
        </trans-unit>
        <trans-unit id="f667fe9347feaa7cb4e621c258d2edcbe22519e9" translate="yes" xml:space="preserve">
          <source>ForeachAggregate</source>
          <target state="translated">ForeachAggregate</target>
        </trans-unit>
        <trans-unit id="df2d328871cd71e3623bbdef344f4992bcecf2e1" translate="yes" xml:space="preserve">
          <source>ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt;;</source>
          <target state="translated">ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e19df85959b2b1a13377a372c2de5cdf84d1b37" translate="yes" xml:space="preserve">
          <source>ForeachStatement</source>
          <target state="translated">ForeachStatement</target>
        </trans-unit>
        <trans-unit id="9e64b4731b7dbeb3175b639030eb1b4587e3cf60" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;code&gt;fes&lt;/code&gt;</source>
          <target state="translated">ForeachStatement &lt;code&gt;fes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a17c7a682fe18e111c85eb3ffb6f2a4cbaae0f4" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1330e14342be598ec267758faf0b9d03bb95ce41" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;fes&quot;&gt;фес&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="856f0cb9ba209b9b76b5f3f3110e190ba107f316" translate="yes" xml:space="preserve">
          <source>ForeachType</source>
          <target state="translated">ForeachType</target>
        </trans-unit>
        <trans-unit id="9c4e220b832fdde833e953123e22e947e7b36940" translate="yes" xml:space="preserve">
          <source>ForeachType!(PointerTarget!Range)[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType! (PointerTarget! Range) [] &lt;strong id=&quot;array&quot;&gt;массив&lt;/strong&gt; (Range) (диапазон r)</target>
        </trans-unit>
        <trans-unit id="b97cbae09882028f8cf2caca90479d52c2db87df" translate="yes" xml:space="preserve">
          <source>ForeachType!Range[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType! Range [] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt; (Range) (Диапазон r)</target>
        </trans-unit>
        <trans-unit id="6c99353d4eb960ce958a85dea4dafad1de143866" translate="yes" xml:space="preserve">
          <source>ForeachTypeAttribute</source>
          <target state="translated">ForeachTypeAttribute</target>
        </trans-unit>
        <trans-unit id="7ce9ed7c2184e929a253429a20b37b4560fb165d" translate="yes" xml:space="preserve">
          <source>ForeachTypeList</source>
          <target state="translated">ForeachTypeList</target>
        </trans-unit>
        <trans-unit id="3432f720952ad1ef45f41182f803dfead87c5b2b" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Methods</source>
          <target state="translated">Методы реверсивного диапазона Foreach_reverse Range Methods</target>
        </trans-unit>
        <trans-unit id="b050df33fa944ca9312b95dbcf3146816b9fa5f7" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Properties</source>
          <target state="translated">Свойства Foreach_reverse Range</target>
        </trans-unit>
        <trans-unit id="4f7e5954df7c830e01a29a86da382389a582afe9" translate="yes" xml:space="preserve">
          <source>Form TypeTuple from the types of the expressions. Assume exps[] is already tuple expanded.</source>
          <target state="translated">Форма TypeTuple из типов выражений.Предполагается,что exps[]уже расширен кортежом.</target>
        </trans-unit>
        <trans-unit id="2d244117783206496417e62aa99112e2aad4b472" translate="yes" xml:space="preserve">
          <source>Form feed (FF) (U+000C).</source>
          <target state="translated">Форм-канал (FF)(U+000C).</target>
        </trans-unit>
        <trans-unit id="676f10eb2f485163d62fd19ea9c8545ba45ba1b3" translate="yes" xml:space="preserve">
          <source>Formally, the minimum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(a, x)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. Conversely, the maximum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(x, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; (note the swapped arguments to &lt;code&gt;pred&lt;/code&gt;).</source>
          <target state="translated">Формально минимумом является значение &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; , так что &lt;code&gt;pred(a, x)&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; для всех значений &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; . И наоборот, максимумом является значение &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; , так что &lt;code&gt;pred(x, a)&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; для всех значений &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;range&lt;/code&gt; (обратите внимание на замененные аргументы для &lt;code&gt;pred&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="150d9f841097f64a42b925806fe3290abd9bc35d" translate="yes" xml:space="preserve">
          <source>Format String</source>
          <target state="translated">Форматная строка</target>
        </trans-unit>
        <trans-unit id="683303f489ff84a56879ace6d1310dfe54be7ff4" translate="yes" xml:space="preserve">
          <source>Format a static condition as a tree-like structure, marking failed and bypassed expressions.</source>
          <target state="translated">Форматирование статического состояния в виде древовидной структуры,пометка неудачных и обходных выражений.</target>
        </trans-unit>
        <trans-unit id="51e82ebaf2db5ec167460d9fcf90c1ef8ea0f2d7" translate="yes" xml:space="preserve">
          <source>Format arguments into a string.</source>
          <target state="translated">Форматирование аргументов в строку.</target>
        </trans-unit>
        <trans-unit id="b0fb6e308cc109a50167ee0e6731cc7e72eb7494" translate="yes" xml:space="preserve">
          <source>Format arguments into buffer</source>
          <target state="translated">Форматирование аргументов в буфер</target>
        </trans-unit>
        <trans-unit id="926bb79848aace359e9158738e215805c41e663b" translate="yes" xml:space="preserve">
          <source>Format data into strings.</source>
          <target state="translated">Форматировать данные в строки.</target>
        </trans-unit>
        <trans-unit id="23e10a3db64de41eba0cd45a912f85a4b56f3f1b" translate="yes" xml:space="preserve">
          <source>Format flags for CustomFloat.</source>
          <target state="translated">Флаги форматирования для CustomFloat.</target>
        </trans-unit>
        <trans-unit id="9bc6c7decb7638f7f45249d89d49acf2bfdc2a16" translate="yes" xml:space="preserve">
          <source>Format like &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt;.</source>
          <target state="translated">Отформатируйте как &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02e42cbae72865d54225666f797f795a1b96d6bb" translate="yes" xml:space="preserve">
          <source>Format specifier</source>
          <target state="translated">Спецификатор формата</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">Строка формата.</target>
        </trans-unit>
        <trans-unit id="ee3b46d05547f4e1ed0fb6b16e92db78c1a30405" translate="yes" xml:space="preserve">
          <source>Format string. For detailed specification, see &lt;a href=&quot;#formattedWrite&quot;&gt;&lt;code&gt;formattedWrite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Строка формата. Для получения подробной спецификации см. &lt;a href=&quot;#formattedWrite&quot;&gt; &lt;code&gt;formattedWrite&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e1764b317ef266e49f202653a88a32e68ea2fd" translate="yes" xml:space="preserve">
          <source>Format to a string such as: &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt;.</source>
          <target state="translated">Отформатируйте в строку, например: &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69dbb2a04350f8cee981103c2cb9db39585e38b6" translate="yes" xml:space="preserve">
          <source>Format version needed to extract this member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a8c4c502d36efd7cdb40b63094b0c90409c783" translate="yes" xml:space="preserve">
          <source>FormatChar</source>
          <target state="translated">FormatChar</target>
        </trans-unit>
        <trans-unit id="d7ab63d27b9f2759987e52fd620d64164025e796" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb9d269d7b56db9164861bd1ad68cf391c388350" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fcb49409d4c929c4b7d5f9fa3a44391c37114d5" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;spec&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;spec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f215319169c289fbb719f3b0d628a3b737f8eded" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt;(Char)(Char[] fmt);</source>
          <target state="translated">FormatSpec! Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt; (Char) (Char [] fmt);</target>
        </trans-unit>
        <trans-unit id="ff3a107be5350e9cbdf489fea1b9a3cb189415cc" translate="yes" xml:space="preserve">
          <source>FormatSpec!char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec! Char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d214509fa791f89f2be58f52b1b3767a22ec982d" translate="yes" xml:space="preserve">
          <source>Formats &lt;code&gt;Tuple&lt;/code&gt; with either &lt;code&gt;%s&lt;/code&gt;, &lt;code&gt;%(inner%)&lt;/code&gt; or &lt;code&gt;%(inner%|sep%)&lt;/code&gt;.</source>
          <target state="translated">Форматы &lt;code&gt;Tuple&lt;/code&gt; с &lt;code&gt;%s&lt;/code&gt; , &lt;code&gt;%(inner%)&lt;/code&gt; или &lt;code&gt;%(inner%|sep%)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36fd923e1d2f6994803ec17defea621b9f080f14" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer, followed by a newline.</source>
          <target state="translated">Форматирует и записывает свои аргументы в текстовом формате в OutBuffer,за которым следует новая строка.</target>
        </trans-unit>
        <trans-unit id="7071823457762f9707da94f7448fddbd240e7baf" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer.</source>
          <target state="translated">Форматирует и записывает свои аргументы в текстовом формате в OutBuffer.</target>
        </trans-unit>
        <trans-unit id="a51cf9b2e5a5b055fe6bcc1d2693b2624065293b" translate="yes" xml:space="preserve">
          <source>Formats any value into &lt;code&gt;Char&lt;/code&gt; accepting &lt;code&gt;OutputRange&lt;/code&gt;, using the given &lt;code&gt;FormatSpec&lt;/code&gt;.</source>
          <target state="translated">Форматирует любое значение в &lt;code&gt;Char&lt;/code&gt; , принимая &lt;code&gt;OutputRange&lt;/code&gt; , используя заданную &lt;code&gt;FormatSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1857e4f5a36639d321cc75f53c946b6701eca2" translate="yes" xml:space="preserve">
          <source>Formats its arguments according to the format string and puts them to an OutputRange.</source>
          <target state="translated">Форматирует свои аргументы в соответствии со строкой форматирования и помещает их в OutputRange.</target>
        </trans-unit>
        <trans-unit id="7b102bb156b0812a82b4b3cc910bf7cff6a74f11" translate="yes" xml:space="preserve">
          <source>Formats supported by Tuple</source>
          <target state="translated">Форматы,поддерживаемые Tuple</target>
        </trans-unit>
        <trans-unit id="1eebc61a97141f60643e629482bce7edcfb75fe1" translate="yes" xml:space="preserve">
          <source>Formats the &lt;code&gt;Options&lt;/code&gt; for CLI printing.</source>
          <target state="translated">Форматирует &lt;code&gt;Options&lt;/code&gt; для печати CLI.</target>
        </trans-unit>
        <trans-unit id="026cf84e486080b485be195c8355623b05fc9001" translate="yes" xml:space="preserve">
          <source>Formats the RedBlackTree into a sink function. For more info see &lt;code&gt; std.format.formatValue&lt;/code&gt;. Note that this only is available when the element type can be formatted. Otherwise, the default toString from Object is used.</source>
          <target state="translated">Форматирует RedBlackTree в функцию приемника. Для получения дополнительной информации см. &lt;code&gt; std.format.formatValue&lt;/code&gt; . Обратите внимание, что это доступно только тогда, когда тип элемента может быть отформатирован. В противном случае по умолчанию используется toString from Object.</target>
        </trans-unit>
        <trans-unit id="1a1c1d1c97be2b241e71fcbcd57b8c7212c71103" translate="yes" xml:space="preserve">
          <source>Formats the stored value as a string.</source>
          <target state="translated">Форматирует сохраненное значение как строку.</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">Функции форматированной строковой печати</target>
        </trans-unit>
        <trans-unit id="fc5187ca67d19625ec5705d6a55febca2c516352" translate="yes" xml:space="preserve">
          <source>Formatted number of arguments.</source>
          <target state="translated">Форматированное количество аргументов.</target>
        </trans-unit>
        <trans-unit id="dfdf9e737f02222e3b629df49845cd2f57eea582" translate="yes" xml:space="preserve">
          <source>Formatting a struct by defining a method &lt;code&gt;toString&lt;/code&gt;, which takes an output range.  It's recommended that any &lt;code&gt;toString&lt;/code&gt; using &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output ranges&lt;/a&gt; use &lt;a href=&quot;std_range_primitives#put&quot;&gt;&lt;code&gt;std.range.primitives.put&lt;/code&gt;&lt;/a&gt; rather than use the &lt;code&gt;put&lt;/code&gt; method of the range directly.</source>
          <target state="translated">Форматирование структуры путем определения метода &lt;code&gt;toString&lt;/code&gt; , который принимает выходной диапазон. Рекомендуется, чтобы любая &lt;code&gt;toString&lt;/code&gt; , использующая &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;выходные диапазоны,&lt;/a&gt; использовала &lt;a href=&quot;std_range_primitives#put&quot;&gt; &lt;code&gt;std.range.primitives.put&lt;/code&gt; ,&lt;/a&gt; а не использовала метод &lt;code&gt;put&lt;/code&gt; диапазона напрямую.</target>
        </trans-unit>
        <trans-unit id="8e465166e94e67eebeab101e4359626150ec10a5" translate="yes" xml:space="preserve">
          <source>Forms the symbols available to all D programs. Includes Object, which is the root of the class object hierarchy. This module is implicitly imported.</source>
          <target state="translated">Формирует символы,доступные для всех программ D.Включает в себя Объект,который является корнем иерархии объектов класса.Данный модуль неявно импортируется.</target>
        </trans-unit>
        <trans-unit id="be4f9eeadbcbd0250352284fb3cd5289c89dd0aa" translate="yes" xml:space="preserve">
          <source>Forward range primitive.</source>
          <target state="translated">Передний диапазон примитивен.</target>
        </trans-unit>
        <trans-unit id="f29ecd0a8c2e85a8dd0a05e6e1849d59d6e26721" translate="yes" xml:space="preserve">
          <source>Forward range primitives.</source>
          <target state="translated">Примитивы дальнего радиуса действия.</target>
        </trans-unit>
        <trans-unit id="0aa520a29c82bb14e915d25c13dc5e309db9aa45" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Always present.</source>
          <target state="translated">Примитивы дальнего радиуса действия.Всегда присутствуют.</target>
        </trans-unit>
        <trans-unit id="d22e131c3ac191040ab33d51c37ffdb89ec4f5bd" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Only present if &lt;code&gt;Source&lt;/code&gt; is a forward range.</source>
          <target state="translated">Примитивы прямого диапазона. Присутствует только в том случае, если &lt;code&gt;Source&lt;/code&gt; - прямой диапазон.</target>
        </trans-unit>
        <trans-unit id="97bc99924d633226857a96f6afec14fc043cb16b" translate="yes" xml:space="preserve">
          <source>Forward range to check for sortedness.</source>
          <target state="translated">Передний диапазон для проверки сортировки.</target>
        </trans-unit>
        <trans-unit id="7657ababded98f92f21842f17fb3c2a8cd28a85d" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().back&lt;/code&gt;.</source>
          <target state="translated">Переслать в &lt;code&gt;opSlice().back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f670785452e24c08e6662a674722599db21dae68" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().front&lt;/code&gt;.</source>
          <target state="translated">Переслать в &lt;code&gt;opSlice().front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="406d6f916ef4dc2cf86b7e71d06ceb89e750f775" translate="yes" xml:space="preserve">
          <source>Forward.</source>
          <target state="translated">Forward.</target>
        </trans-unit>
        <trans-unit id="619c49003b4924854c54d8f88890d01e742d1cdb" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;back&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;back&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef30f2488fc02c13b78587f98f5f66b1ed09c755" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;choices&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;choices&lt;/code&gt; ForwardRange</target>
        </trans-unit>
        <trans-unit id="073a409c0a0f8fb805007ded8e0840b82337c88e" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;filler&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;filler&lt;/code&gt; ForwardRange</target>
        </trans-unit>
        <trans-unit id="d735aafe3953821674bcc047eed0a464f448083f" translate="yes" xml:space="preserve">
          <source>Forwarding</source>
          <target state="translated">Forwarding</target>
        </trans-unit>
        <trans-unit id="59753dcda35fa8785a7cb0df7205b2d4bd41fb72" translate="yes" xml:space="preserve">
          <source>Forwarding ScopeDsymbol. Used by ForwardingAttribDeclaration and ForwardingScopeDeclaration to forward symbol insertions to another scope. See &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; for more details.</source>
          <target state="translated">Переадресация ScopeDsymbol. Используется ForwardingAttribDeclaration и ForwardingScopeDeclaration для пересылки вставок символов в другую область. Смотрите &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="a8c3c38ee76d4f3b54240c75f491818942150299" translate="yes" xml:space="preserve">
          <source>ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt;;</source>
          <target state="translated">ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="350d94101794444e552e24c257a1f22a4fbe99df" translate="yes" xml:space="preserve">
          <source>ForwardingStatements are distributed over the flattened sequence of statements. This prevents flattening to be &quot;blocked&quot; by a ForwardingStatement and is necessary, for example, to support generating scope guards with `static foreach`:</source>
          <target state="translated">Форвардные заявления распределяются по сплющенной последовательности операторов.Это предотвращает &quot;блокирование&quot; сглаживания ForwardingStatements и необходимо,например,для поддержки генерирующих ограждений прицела с `статистическим передним планом`:</target>
        </trans-unit>
        <trans-unit id="692658a69283f7fb6a21aa51f11e5d6d2994d5d3" translate="yes" xml:space="preserve">
          <source>Forwards &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; вперед .</target>
        </trans-unit>
        <trans-unit id="5654a0e021e96bad526eccdeb7cb0d25a7be5435" translate="yes" xml:space="preserve">
          <source>Forwards each of the methods in &lt;code&gt;funs&lt;/code&gt; (if defined) to &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">Пересылает каждый из методов в &lt;code&gt;funs&lt;/code&gt; (если он определен) &lt;code&gt;member&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e165afdb83bce78d5a7427c72318f24d46092f4d" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while keeping &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; on the parameters.</source>
          <target state="translated">Нападающие аргументы функции, сохраняя при этом &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; и &lt;code&gt;lazy&lt;/code&gt; по параметрам.</target>
        </trans-unit>
        <trans-unit id="9385c6728b753fbb370a1c4f1034c150548b8bf1" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while saving ref-ness.</source>
          <target state="translated">Передает аргументы функции,сохраняя при этом реф-непригодность.</target>
        </trans-unit>
        <trans-unit id="9bf1ea57d6c29870d04450f92da2598f5a795126" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt; на alignAllocate (bytes, platformAlignment) .</target>
        </trans-unit>
        <trans-unit id="e78d71ac4fe9046b06039c1f36978f900fc90d21" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt;. Should be used with blocks obtained with &lt;code&gt;allocate&lt;/code&gt; otherwise the custom alignment passed with &lt;code&gt;alignedAllocate&lt;/code&gt; can be lost.</source>
          <target state="translated">&lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt; на alignReallocate (b, newSize, platformAlignment) . Должен использоваться с блоками , полученными с &lt;code&gt;allocate&lt;/code&gt; иначе пользовательские выравнивание прошло с &lt;code&gt;alignedAllocate&lt;/code&gt; могут быть потеряны.</target>
        </trans-unit>
        <trans-unit id="d788f6c07eb5fb2e6319214dbdc4af6789c0f502" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.alignedReallocate&lt;/code&gt; if defined, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;impl.alignedReallocate&lt;/code&gt; в impl.alignedReallocate, если она определена, в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bd9cee5dc99654ad10a48eac7f3712c848d2492" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.empty()&lt;/code&gt; if defined, otherwise returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;impl.empty()&lt;/code&gt; в impl.empty (), если он определен, в противном случае возвращает &lt;code&gt;Ternary.unknown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acf2453169c3a58c2868738f1fc21eb777d091c4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;insertBack&lt;/code&gt;.</source>
          <target state="translated">Вперед, чтобы &lt;code&gt;insertBack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60a899e29a86abcd90907c95435a5280010cfeb4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.alignedAllocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.alignedAllocate&lt;/code&gt; на parent.alignedAllocate . Влияет на экземпляр: &lt;code&gt;numAlignedAllocate&lt;/code&gt; , &lt;code&gt;bytesUsed&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; , &lt;code&gt;bytesSlack&lt;/code&gt; , &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; и &lt;code&gt;bytesHighTide&lt;/code&gt; . Влияет на вызов: &lt;code&gt;numAlignedAllocate&lt;/code&gt; , &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; и &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de51b91db75956f253cd2e990aebff215db91a5" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.allocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt; numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.allocate&lt;/code&gt; на parent.allocate . Влияет на экземпляр: &lt;code&gt;numAllocate&lt;/code&gt; , &lt;code&gt;bytesUsed&lt;/code&gt; , &lt;code&gt;bytesAllocated&lt;/code&gt; , &lt;code&gt;bytesSlack&lt;/code&gt; , &lt;code&gt;numAllocateOK&lt;/code&gt; и &lt;code&gt;bytesHighTide&lt;/code&gt; . Влияет на вызов: &lt;code&gt;numAllocate&lt;/code&gt; , &lt;code&gt; numAllocateOK&lt;/code&gt; и &lt;code&gt;bytesAllocated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcaf3b31885140c27644f437101ba9113ddebba0" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.expand(b, delta)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.expand(b, delta)&lt;/code&gt; к parent.expand (b, delta) .</target>
        </trans-unit>
        <trans-unit id="b27aa4f3be329203334bb86f539151cb305c808b" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.goodAllocSize&lt;/code&gt; (which accounts for the management overhead).</source>
          <target state="translated">&lt;code&gt;parent.goodAllocSize&lt;/code&gt; на parent.goodAllocSize (который учитывает накладные расходы на управление).</target>
        </trans-unit>
        <trans-unit id="0a8e660798dc338a8a1471f38403abdf431c688a" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.owns(b)&lt;/code&gt; на parent.owns (б) .</target>
        </trans-unit>
        <trans-unit id="c49defce19fbb5c360ddd5f8418442bee4a9e756" translate="yes" xml:space="preserve">
          <source>Found function if it satisfies &lt;code&gt;isThis()&lt;/code&gt;, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">Найденная функция, если она удовлетворяет &lt;code&gt;isThis()&lt;/code&gt; , иначе &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5b2644294a615403e1d25df5a0697b50b1f11f" translate="yes" xml:space="preserve">
          <source>Fractional seconds past the second (i.e. the portion of a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; which is less than a second).</source>
          <target state="translated">Дробные секунды после секунды (то есть часть &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; ,&lt;/a&gt; которая меньше секунды).</target>
        </trans-unit>
        <trans-unit id="379f2457e03cb11d9fb2efb285637d5db4d20d0e" translate="yes" xml:space="preserve">
          <source>Framework Paths</source>
          <target state="translated">Рамочные пути</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="76f3bbf403c0a1d06091b2e954aa5148b52956ac" translate="yes" xml:space="preserve">
          <source>Free ExceptionHeader that was created by create().</source>
          <target state="translated">Free ExceptionHeader,созданный функцией create().</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">Бесплатная память,используемая при подключении к базе данных</target>
        </trans-unit>
        <trans-unit id="ebc0d55c1803ae64cbd97a59b9b2802ad68ac4a1" translate="yes" xml:space="preserve">
          <source>Free a data definition struct.</source>
          <target state="translated">Освободите структуру определения данных.</target>
        </trans-unit>
        <trans-unit id="b863a7908826b1af85e7908ab51bda44bf1ecda4" translate="yes" xml:space="preserve">
          <source>Free a multipart formpost previously built with curl_formadd().</source>
          <target state="translated">Освободите мультипартийный формпост,ранее собранный функцией curl_formadd().</target>
        </trans-unit>
        <trans-unit id="3195ad8b795496334c672bd13584f65569ba68b7" translate="yes" xml:space="preserve">
          <source>Free a prior allocation</source>
          <target state="translated">Бесплатное предварительное выделение</target>
        </trans-unit>
        <trans-unit id="b1f545998e095b9a06b4728df726ebf0dad217f2" translate="yes" xml:space="preserve">
          <source>Free blocks have variable size and are linked in a singly-linked list.</source>
          <target state="translated">Свободные блоки имеют переменный размер и объединены в единый список.</target>
        </trans-unit>
        <trans-unit id="2e8b5134a1b2ec3e5e93b6a487571bc8ad9bf630" translate="yes" xml:space="preserve">
          <source>Free free list.</source>
          <target state="translated">Бесплатный бесплатный список.</target>
        </trans-unit>
        <trans-unit id="0917613170fb85672a58086626671da808078654" translate="yes" xml:space="preserve">
          <source>Free idxStr using sqlite3_free() if true</source>
          <target state="translated">Free idxStr с помощью sqlite3_free()if true</target>
        </trans-unit>
        <trans-unit id="98a1ae48a4466ad89a88d462e43c40189625122d" translate="yes" xml:space="preserve">
          <source>Free list built on top of exactly one contiguous block of memory. The block is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;, and is released in &lt;code&gt;ContiguousFreeList&lt;/code&gt;'s destructor (unless &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;).</source>
          <target state="translated">Свободный список строится поверх ровно одного непрерывного блока памяти. Предполагается, что блок был выделен с помощью &lt;code&gt;ParentAllocator&lt;/code&gt; и освобождается в деструкторе &lt;code&gt;ContiguousFreeList&lt;/code&gt; (если только &lt;code&gt;ParentAllocator&lt;/code&gt; не равен &lt;code&gt;NullAllocator&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="10d99eecb5370b60ca034187daa4ef1e45d53646" translate="yes" xml:space="preserve">
          <source>Free list.</source>
          <target state="translated">Бесплатный список.</target>
        </trans-unit>
        <trans-unit id="56d7e4661565975bfba4769fa7e3d64507696d05" translate="yes" xml:space="preserve">
          <source>Free memory allocated by FileName routines</source>
          <target state="translated">Свободная память,выделенная подпрограммами FileName</target>
        </trans-unit>
        <trans-unit id="f7c1a4f30544ddc6377c5a280a73f14897416990" translate="yes" xml:space="preserve">
          <source>Free returned value with FileName::free()</source>
          <target state="translated">Бесплатно возвращаемое значение с помощью FileName::free()</target>
        </trans-unit>
        <trans-unit id="3b18d56d2ee33e5deee0527f6a5620f9d07c8560" translate="yes" xml:space="preserve">
          <source>Free-form syntax, ignores whitespace in pattern, useful for formatting complex regular expressions.</source>
          <target state="translated">Синтаксис в свободной форме,игнорирует пробелы в шаблоне,полезен для форматирования сложных регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="927e12a7e999b3e0f18d3a882968560f012cc81f" translate="yes" xml:space="preserve">
          <source>FreeBSD-Only</source>
          <target state="translated">FreeBSD-Only</target>
        </trans-unit>
        <trans-unit id="736e4cd346eb715c4446b514550578d814d7d0e0" translate="yes" xml:space="preserve">
          <source>FreeBSD/DragonFlyBSD are the only systems which specifically have a clock set up for this (it has &lt;code&gt;CLOCK_SECOND&lt;/code&gt; to use with &lt;code&gt;clock_gettime&lt;/code&gt; which takes advantage of an in-kernel cached value), but on other systems, the fastest function available will be used, and the resulting &lt;code&gt;SysTime&lt;/code&gt; will be rounded down to the second if the clock that was used gave the time at a more precise resolution. So, it's guaranteed that the time will be given at a precision of one second and it's likely the case that will be faster than &lt;code&gt;ClockType.normal&lt;/code&gt;, since there tend to be several options on a system to get the time at low resolutions, and they tend to be faster than getting the time at high resolutions.</source>
          <target state="translated">FreeBSD / DragonFlyBSD - единственные системы, для которых специально настроены часы (для этого есть &lt;code&gt;CLOCK_SECOND&lt;/code&gt; для использования с &lt;code&gt;clock_gettime&lt;/code&gt; , использующим преимущества кэшированного значения в ядре), но в других системах будет использоваться самая быстрая доступная функция, и результирующий &lt;code&gt;SysTime&lt;/code&gt; будет округлен до секунды, если использованные часы дали время с более точным разрешением. Таким образом, гарантируется, что время будет дано с точностью до одной секунды, и, скорее всего, это будет быстрее, чем &lt;code&gt;ClockType.normal&lt;/code&gt; , поскольку в системе , как правило, имеется несколько вариантов получения времени при низких разрешениях, и они как правило, быстрее, чем получать время в высоком разрешении.</target>
        </trans-unit>
        <trans-unit id="a9cdca34912cf1be0977006662f6f41677329f87" translate="yes" xml:space="preserve">
          <source>FreeList shared across threads. Allocation and deallocation are lock-free. The parameters have the same semantics as for &lt;code&gt;FreeList&lt;/code&gt;.</source>
          <target state="translated">FreeList разделен между потоками. Распределение и освобождение без блокировки. Параметры имеют ту же семантику, что и для &lt;code&gt;FreeList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdbf1c9047d64cde03eaed8b92301afb24c8b3e" translate="yes" xml:space="preserve">
          <source>Freeing all GC allocated memory that has no active pointers to it and do not need destructors to run.</source>
          <target state="translated">Освобождение всей выделенной памяти GC,которая не имеет активных указателей на нее и не нуждается в деструкторах для запуска.</target>
        </trans-unit>
        <trans-unit id="9c1d262fbf3a7e284bb2c20e67267943ef09c825" translate="yes" xml:space="preserve">
          <source>Freeing any remaining unreachable memory.</source>
          <target state="translated">Освобождение оставшейся недоступной памяти.</target>
        </trans-unit>
        <trans-unit id="b1843177cd4be06555f8650438e2f5cee23b6d7c" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated for &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is a reference to a class or interface, the memory allocated for the underlying instance is freed. If &lt;code&gt;x&lt;/code&gt; is a pointer, the memory allocated for the pointed-to object is freed. If &lt;code&gt;x&lt;/code&gt; is a built-in array, the memory allocated for the array is freed. If &lt;code&gt;x&lt;/code&gt; does not refer to memory previously allocated with &lt;code&gt;new&lt;/code&gt; (or the lower-level equivalents in the GC API), the behavior is undefined.</source>
          <target state="translated">Освобождает память, выделенную для &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; является ссылкой на класс или интерфейс, память, выделенная для базового экземпляра, освобождается. Если &lt;code&gt;x&lt;/code&gt; является указателем, память, выделенная для указанного объекта, освобождается. Если &lt;code&gt;x&lt;/code&gt; является встроенным массивом, память, выделенная для массива, освобождается. Если &lt;code&gt;x&lt;/code&gt; не ссылается на память, ранее выделенную с помощью &lt;code&gt;new&lt;/code&gt; (или эквиваленты более низкого уровня в GC API), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="306cb21df3375fca60d15a5cf9f358aab2a447e3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">От &lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db2022114f51428d23663985d9512c4f397b106d" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">От &lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dcadc69133dc56548eb2198fe024d580cc53763" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e8638502dca540c07f22be8e25e01957c58dc0f" translate="yes" xml:space="preserve">
          <source>From a postblit perspective, qualifiying the struct definition yields the same result as explicitly qualifying the postblit.</source>
          <target state="translated">С точки зрения постблита,квалификация определения структуры дает тот же результат,что и явная квалификация постблита.</target>
        </trans-unit>
        <trans-unit id="a4300cea6afd6c5c0528f1834abaff027668e0ed" translate="yes" xml:space="preserve">
          <source>From units</source>
          <target state="translated">От единиц</target>
        </trans-unit>
        <trans-unit id="87b5b5d7f217c54f10b305679e84d27b0ffddee6" translate="yes" xml:space="preserve">
          <source>Front-end expression rewriting should create temporary variables for non trivial sub-expressions in order to: 1. save evaluation order 2. prevent sharing of sub-expression in AST</source>
          <target state="translated">Перезапись внешних выражений должна создавать временные переменные для не тривиальных подвыражений для того,чтобы:1.сохранить порядок оценки 2.предотвратить совместное использование подвыражений в AST</target>
        </trans-unit>
        <trans-unit id="d866f093f3136af5a6cee1f9313a0fdd24da6c23" translate="yes" xml:space="preserve">
          <source>FrontTransversal!(RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr);</source>
          <target state="translated">FrontTransversal! (RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt; (TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges) (RangeOfRanges rr);</target>
        </trans-unit>
        <trans-unit id="b96493999dfb84df4fdc104ae8dc68c5ab28eeb6" translate="yes" xml:space="preserve">
          <source>Full Usage Example</source>
          <target state="translated">Пример полного использования</target>
        </trans-unit>
        <trans-unit id="dd2159a885b04c76ad21acb9e9df96e1b3df4a78" translate="yes" xml:space="preserve">
          <source>Full content of the file to be written</source>
          <target state="translated">Полное содержание записываемого файла</target>
        </trans-unit>
        <trans-unit id="890fb87ee1e5cddd39317993afd9de0de79b7d45" translate="yes" xml:space="preserve">
          <source>Full metaprogramming facilities</source>
          <target state="translated">Полные средства метапрограммирования</target>
        </trans-unit>
        <trans-unit id="0c7ebd23a12a9077c88a3e9d528a97811a94a547" translate="yes" xml:space="preserve">
          <source>Fully sequenced (acquire + release). Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">Полностью секвенирована (приобретение + выпуск). Соответствует &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; и C ++ 11 / C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="244c67389fed3259f84c95197cc9eb3648ddcb0d" translate="yes" xml:space="preserve">
          <source>Fully working example is available at &lt;a href=&quot;#usage-example&quot;&gt;the bottom&lt;/a&gt;.</source>
          <target state="translated">Полностью рабочий пример доступен &lt;a href=&quot;#usage-example&quot;&gt;внизу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d32cb0b70d83396fe47823d8472eaa9476a37437" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46c96c463b9529c91720bbc72354f9466bd3c26f" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fd968926da674858b925b704767caf618b18035" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fdc&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;fdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e24cae0141215bceece007770b580c50fd2f38" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;func&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;func&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f3b288cb44551e47fdefb27fe0ea167fb4d1483" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt; (AggregateDeclaration ad, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="2e19843cd5ed176434a3efaeff7d8bda7426dc57" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="03359c276bccc50045b57bc8ace08bc6d8f2ae59" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="507d5c363210e3f23b2c42085b0c0ff39e10c2cc" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="859ef670635a842eaebad8ac23f82e95392d9e8c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="dc070bb95306fb1a92b40edce98353f4664181ad" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt; (StructDeclaration sd, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="a30ba00bb5d45e8e8a6da89f6ff22fb9cbecb606" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt;(TemplateInstance ti, Scope* sc2, FuncDeclaration fd, Type tthis, Expressions* fargs);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt; (TemplateInstance ti, Scope * sc2, FuncDeclaration fd, введите tthis, выражения * fargs);</target>
        </trans-unit>
        <trans-unit id="d05a566062ec8864bd0d4c9e283c124ce8c44dfa" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e42a220d72031c5ac346bcdb8b0d4dc5655921c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d75bdbbe19a26e762aba1b2f76a15fde383c64a0" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt; (AggregateDeclaration ad, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="fb1ead50f11e27697b705598972fc6d1ffead188" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt; (Scope * sc);</target>
        </trans-unit>
        <trans-unit id="9c8e5d63f59418c4c2add44a220d39f8eb8d7843" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e92604a27d4e8a86aead189ab657e429f7804d91" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, Objects* tiargs, Type tthis, Expressions* fargs, FuncResolveFlag flags);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolFuncCall&lt;/strong&gt; (ссылка const Loc loc, Область * sc, Символы, Объекты * tiargs, Тип tthis, Выражения * fargs, Флаги FuncResolveFlag);</target>
        </trans-unit>
        <trans-unit id="6bc7f2dda0d8c4f33d8fa77e2a6866f9c3e063da" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt;(StructDeclaration sd);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt; (StructDeclaration sd);</target>
        </trans-unit>
        <trans-unit id="d2f8d9014611a673032f33ed2918b0db3cbea6e7" translate="yes" xml:space="preserve">
          <source>FuncDeclaration of &lt;code&gt;toString()&lt;/code&gt; if found, &lt;code&gt;null&lt;/code&gt; if not</source>
          <target state="translated">FuncDeclaration из &lt;code&gt;toString()&lt;/code&gt; , если найден, &lt;code&gt;null&lt;/code&gt; , если не</target>
        </trans-unit>
        <trans-unit id="0de7865b78f78b6942752a1607fa8f3decdf8f8b" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cefac5fb4c4f6f7aad7982a9de7b94425bbd152a" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1147d19864a2f24679061fb745f4f2745312dc4d" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</source>
          <target state="translated">FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34754aacf81ddb7c1a4c8be9c611413058146f76" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</source>
          <target state="translated">FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0df7e78750c597d40962880c788feb5d42d0507c" translate="yes" xml:space="preserve">
          <source>FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</source>
          <target state="translated">FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d148d41b57da4467de12a195094eac776bca54d" translate="yes" xml:space="preserve">
          <source>Function Attribute Inference</source>
          <target state="translated">Поступок по атрибуту функции</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">Вспомогательные данные функции</target>
        </trans-unit>
        <trans-unit id="7cb4de12c910c8d000862c6b8806ba33b405085e" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading</source>
          <target state="translated">Перегрузка оператора вызова функций</target>
        </trans-unit>
        <trans-unit id="b257168e280b545833c00a892f5a9654498e1038" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading &lt;code&gt;f()&lt;/code&gt;</source>
          <target state="translated">Перегрузка оператора вызова функции &lt;code&gt;f()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="287c317aff3ca62b6d115ccce3c3993c93d19bb1" translate="yes" xml:space="preserve">
          <source>Function Calling Conventions</source>
          <target state="translated">Конвенции по вызову функций</target>
        </trans-unit>
        <trans-unit id="897aa7901cb2b135a5d5c44d09b74d23db3807ca" translate="yes" xml:space="preserve">
          <source>Function Default Arguments</source>
          <target state="translated">Аргументы по умолчанию функции</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">Функциональные флаги</target>
        </trans-unit>
        <trans-unit id="d8861f5c13214753c72cc4ec28a42da4d33141ab" translate="yes" xml:space="preserve">
          <source>Function Inheritance and Overriding</source>
          <target state="translated">Наследование и переопределение функций</target>
        </trans-unit>
        <trans-unit id="5bcb901ef2c2acd0ad4fdd3aaa4dbd63df1c459e" translate="yes" xml:space="preserve">
          <source>Function Literals</source>
          <target state="translated">Функция Буквы</target>
        </trans-unit>
        <trans-unit id="a9ab374cd6bd246bd36d7f40fb0af05f53c4d5a7" translate="yes" xml:space="preserve">
          <source>Function Name</source>
          <target state="translated">Имя функции</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="translated">Перегрузка функций</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">Функциональные параметры</target>
        </trans-unit>
        <trans-unit id="27e4c7203c9643477f2a066182da530038d7af91" translate="yes" xml:space="preserve">
          <source>Function Return Values</source>
          <target state="translated">Функция Вернуть значения</target>
        </trans-unit>
        <trans-unit id="564f4636a468d710ec718d52c0a86615388f886e" translate="yes" xml:space="preserve">
          <source>Function Safety</source>
          <target state="translated">Безопасность функционирования</target>
        </trans-unit>
        <trans-unit id="89ef743a3244fbdb65d0570367a96fdb2440073a" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
          <target state="translated">Шаблоны функций</target>
        </trans-unit>
        <trans-unit id="26851646d4034fb238c1b8a8d1cbdf65764b94ab" translate="yes" xml:space="preserve">
          <source>Function Templates with Auto Ref Parameters</source>
          <target state="translated">Функциональные шаблоны с автоматическими параметрами ссылки</target>
        </trans-unit>
        <trans-unit id="2a828a2f47a94f98e25eacb43fb34ce3a0a927e6" translate="yes" xml:space="preserve">
          <source>Function argument initializes a &lt;code&gt;return&lt;/code&gt; parameter, and that parameter gets assigned to &lt;code&gt;firstArg&lt;/code&gt;. Essentially, treat as &lt;code&gt;firstArg = arg;&lt;/code&gt;</source>
          <target state="translated">Аргумент функции инициализирует &lt;code&gt;return&lt;/code&gt; параметр, и этот параметр присваивается &lt;code&gt;firstArg&lt;/code&gt; . По сути, &lt;code&gt;firstArg = arg;&lt;/code&gt; как firstArg = arg;</target>
        </trans-unit>
        <trans-unit id="87a4aa72b8e4acaa8f362e2eba871dd25b95962b" translate="yes" xml:space="preserve">
          <source>Function attributes</source>
          <target state="translated">Атрибуты функций</target>
        </trans-unit>
        <trans-unit id="a3518d2ba96341cb705a0844010da23ec63c4f60" translate="yes" xml:space="preserve">
          <source>Function attributes are emitted in the order as listed above.</source>
          <target state="translated">Атрибуты функций излучаются в порядке,указанном выше.</target>
        </trans-unit>
        <trans-unit id="090cdc3abee08672ecc88627488c127b4dd88e47" translate="yes" xml:space="preserve">
          <source>Function bodies cannot be empty:</source>
          <target state="translated">Функциональные тела не могут быть пустыми:</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">Функциональный орган</target>
        </trans-unit>
        <trans-unit id="daa6044eeb443eca769ad767c0b819da1d93de92" translate="yes" xml:space="preserve">
          <source>Function calls to these are generated by the compiler and inserted into the object code.</source>
          <target state="translated">Вызовы функций к ним генерируются компилятором и вставляются в объектный код.</target>
        </trans-unit>
        <trans-unit id="dcd2bd5d9c9b442091f087f1d3ab7d165c7a6f01" translate="yes" xml:space="preserve">
          <source>Function contracts</source>
          <target state="translated">Функциональные контракты</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">Декларация функций</target>
        </trans-unit>
        <trans-unit id="60f82695f39f080d8446d9390fdbf10f4625d827" translate="yes" xml:space="preserve">
          <source>Function declarations annotated with the &lt;code&gt;@live&lt;/code&gt; attribute are checked for compliance with the Ownership/Borrowing rules. The checks are run after other semantic processing is complete. The checking does not influence code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0e134160bc0255e9ac645522671a4ceac9664b" translate="yes" xml:space="preserve">
          <source>Function for starting to a stop watch time when the function is called and stopping it when its return value goes out of scope and is destroyed.</source>
          <target state="translated">Функция запуска времени остановки при вызове функции и остановки при выходе ее возвращаемого значения за пределы диапазона и уничтожении.</target>
        </trans-unit>
        <trans-unit id="aae2ba6220f8db51d41c8edbd64b6b01f43243fd" translate="yes" xml:space="preserve">
          <source>Function is a C-style variadic function, which uses &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</source>
          <target state="translated">Функция - это переменная функция в стиле C, которая использует &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87d2f358ca186efbcb568c16e606003520afa9cd" translate="yes" xml:space="preserve">
          <source>Function is a D-style variadic function, which uses &lt;code&gt;__argptr&lt;/code&gt; and &lt;code&gt;__arguments&lt;/code&gt;.</source>
          <target state="translated">Функция - это переменная функция в стиле D, которая использует &lt;code&gt;__argptr&lt;/code&gt; и &lt;code&gt;__arguments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3435b54d43e95cebfb7003ed401ba2d6c58be33" translate="yes" xml:space="preserve">
          <source>Function is a typesafe variadic function.</source>
          <target state="translated">Функция является типовой вариадической функцией.</target>
        </trans-unit>
        <trans-unit id="02eaa479f3aca73ffbcbe24d76bdcbcb5f2a00b8" translate="yes" xml:space="preserve">
          <source>Function is not variadic.</source>
          <target state="translated">Функция не вариадическая.</target>
        </trans-unit>
        <trans-unit id="f04ac1afcdca4559aaa061f6f7593d6d3478e357" translate="yes" xml:space="preserve">
          <source>Function parameter &lt;code&gt;par&lt;/code&gt; is being initialized to &lt;code&gt;arg&lt;/code&gt;, and &lt;code&gt;par&lt;/code&gt; may escape. Detect if scoped values can escape this way. Print error messages when these are detected.</source>
          <target state="translated">Параметр функции &lt;code&gt;par&lt;/code&gt; инициализируется в &lt;code&gt;arg&lt;/code&gt; , и &lt;code&gt;par&lt;/code&gt; может выходить. Определите, могут ли значения области видимости избежать этого пути. Распечатайте сообщения об ошибках, когда они обнаружены.</target>
        </trans-unit>
        <trans-unit id="3029155acb4ac5fc232abd3463c11350cc2d960a" translate="yes" xml:space="preserve">
          <source>Function parameter declarations can have default values:</source>
          <target state="translated">Объявления параметров функций могут иметь значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="f6a6b4c753629a0ad23be9a19a0def5754916cb7" translate="yes" xml:space="preserve">
          <source>Function parameters can be documented by listing them in a params section. Each line that starts with an identifier followed by an '=' starts a new parameter description. A description can span multiple lines.</source>
          <target state="translated">Параметры функции можно документировать,перечисляя их в разделе параметров.Каждая строка,которая начинается с идентификатора,за которым следует '=',начинает новое описание параметра.Описание может охватывать несколько строк.</target>
        </trans-unit>
        <trans-unit id="6678c5d32e09052e0172ebd3cea351dcf7ca2766" translate="yes" xml:space="preserve">
          <source>Function parameters: Pident identifier of parameter Ptype type of argument Pelem default value for argument Psym symbol corresponding to Pident when using the parameter list as a symbol table For template-parameter-list: Pident identifier of parameter Ptype if NULL, this is a type-parameter else the type for a parameter-declaration value argument Pelem default value for value argument Pdeftype default value for type-parameter Pptpl template-parameter-list for template-template-parameter Psym default value for template-template-parameter For template-arg-list: (actual arguments) Pident NULL Ptype type-name Pelem expression (either Ptype or Pelem is NULL) Psym SCtemplate for template-template-argument</source>
          <target state="translated">Функциональные параметры:Идентификатор P-типа параметра P-тип аргумента Pelem значение по умолчанию для аргумента Psym символ,соответствующий Pident при использовании списка параметров в качестве таблицы символов для списка шаблонов-параметров:Pident идентификатор параметра Ptype if NULL,это тип параметра-параметр,иначе тип параметра-значения декларации значение параметра Pelem значение параметра Pdef тип значение параметра Pdef тип значение параметра Pptpl шаблоны-параметры-список шаблонов Psym значение параметра Psym значение параметра шаблоны-параметры шаблоны-шаблоны-параметры Для шаблонов-параметры-список:(фактические аргументы)Psym SCtemplate для шаблона-параметра шаблона-параметра шаблона-шаблона:(фактические аргументы)Pident NULL выражение Pelem name типа P (либо Ptype,либо Pelem is NULL)Psym SCtemplate для шаблона-параметра шаблона-шаблона</target>
        </trans-unit>
        <trans-unit id="4e74811387b8309f2eba7069545da73ad882b5db" translate="yes" xml:space="preserve">
          <source>Function pointers can be passed to functions taking a delegate argument by passing them through the &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt;&lt;code&gt;std.functional.toDelegate&lt;/code&gt;&lt;/a&gt; template, which converts any callable to a delegate without context.</source>
          <target state="translated">Указатели на функции можно передавать функциям, принимающим аргумент делегата, передавая их через шаблон &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt; &lt;code&gt;std.functional.toDelegate&lt;/code&gt; &lt;/a&gt; , который преобразует любой вызываемый объект в делегат без контекста.</target>
        </trans-unit>
        <trans-unit id="2f4d971f1b9568ee68d3c3afd0afa4bb0664e45b" translate="yes" xml:space="preserve">
          <source>Function results are returned from &lt;code&gt;yieldForce&lt;/code&gt;, &lt;code&gt;spinForce&lt;/code&gt; and &lt;code&gt;workForce&lt;/code&gt; by ref. If &lt;code&gt;fun&lt;/code&gt; returns by ref, the reference will point to the returned reference of &lt;code&gt;fun&lt;/code&gt;. Otherwise it will point to a field in this struct.</source>
          <target state="translated">Результаты функций возвращаются из &lt;code&gt;yieldForce&lt;/code&gt; , &lt;code&gt;spinForce&lt;/code&gt; и &lt;code&gt;workForce&lt;/code&gt; по ссылке . Если &lt;code&gt;fun&lt;/code&gt; возвращается по ссылке ref, ссылка будет указывать на возвращенную ссылку &lt;code&gt;fun&lt;/code&gt; . В противном случае он будет указывать на поле в этой структуре.</target>
        </trans-unit>
        <trans-unit id="c3097f849806cf699273164feb8e2d0ccfb12c15" translate="yes" xml:space="preserve">
          <source>Function return values are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="translated">Возвращаемые функции считаются значениями.Это означает,что они не могут передаваться по ссылке на другие функции.</target>
        </trans-unit>
        <trans-unit id="c7004e7f868eeb59bcb8e6e80ff83ca5a6d46adf" translate="yes" xml:space="preserve">
          <source>Function return values not marked as &lt;code&gt;ref&lt;/code&gt; are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828053ed1d877ebcde1ff06a5dea505b651e20d3" translate="yes" xml:space="preserve">
          <source>Function template type parameters that are to be implicitly deduced may not have specializations:</source>
          <target state="translated">Параметры типа шаблона функции,которые должны быть неявно выведены,могут не иметь специализации:</target>
        </trans-unit>
        <trans-unit id="a7d00ef56bc1d2f06bd67eb8bc21de19e80c263d" translate="yes" xml:space="preserve">
          <source>Function templates can be explicitly instantiated with a !(</source>
          <target state="translated">Шаблоны функций могут быть явно инстанцированы с помощью функции !(</target>
        </trans-unit>
        <trans-unit id="3b8df2ef7fc72848cf8d0bce3a9220b3a898f0b1" translate="yes" xml:space="preserve">
          <source>Function templates can have their return types deduced based on the &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function, just as with normal functions. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">Шаблоны функций могут получать свои типы возвращаемых &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;значений&lt;/i&gt;&lt;/a&gt; на основе &lt;i&gt;ReturnStatement&lt;/i&gt; в функции, как и в случае с обычными функциями. Смотрите &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Авто Функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55b6f95d2a2736a8bfaa71fcc12b1d0a3c85769f" translate="yes" xml:space="preserve">
          <source>Function that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">Функция, которая называется &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c7a2db7de16ccd53dc1b73193b31c814b7489e6" translate="yes" xml:space="preserve">
          <source>Function that does not take any parameters</source>
          <target state="translated">Функция,которая не принимает никаких параметров</target>
        </trans-unit>
        <trans-unit id="85ff978df4b7d827c80c5b427bf2c4db1e2ed45d" translate="yes" xml:space="preserve">
          <source>Function that will be called instead of the internal progress display function. This function should be defined as the curl_progress_callback prototype defines.</source>
          <target state="translated">Функция,которая будет вызвана вместо внутренней функции отображения прогресса.Эта функция должна быть определена как прототип curl_progress_callback.</target>
        </trans-unit>
        <trans-unit id="23533f8923b79f1dc08d42a47fdcce75663a40c0" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from UTF8 (instead of using the iconv calls in libcurl) Note that this is used only for SSL certificate processing</source>
          <target state="translated">Функция,которая будет вызвана для преобразования из UTF8 (вместо использования вызова iconv в libcurl)Обратите внимание,что она используется только для обработки SSL-сертификатов</target>
        </trans-unit>
        <trans-unit id="9149aa5e3f56e9141da81bbd147711474255a324" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">Функция,которая будет вызвана для преобразования из сетевой кодировки (вместо использования вызова iconv в libcurl).</target>
        </trans-unit>
        <trans-unit id="cffc93dc9124a77261edd44618001f6b42f32854" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert to the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">Функция,которая будет вызвана для преобразования в сетевую кодировку (вместо использования вызова iconv в libcurl).</target>
        </trans-unit>
        <trans-unit id="53a515cf174973bb65a87a5952e5c03252c9695d" translate="yes" xml:space="preserve">
          <source>Function that will be called to read the input (instead of fread). The parameters will use fread() syntax, make sure to follow them.</source>
          <target state="translated">Функция,которая будет вызвана для чтения входа (а не фреада).Параметры будут использовать синтаксис fread(),обязательно следуйте им.</target>
        </trans-unit>
        <trans-unit id="babcbdb82bd11f7164bb99107054b2a484fb1682" translate="yes" xml:space="preserve">
          <source>Function that will be called to store headers (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">Функция,которая будет вызвана для хранения заголовков (вместо записи).Параметры будут использовать синтаксис функции fwrite(),обязательно следуйте им.</target>
        </trans-unit>
        <trans-unit id="233d456dba50e927381d10867821a9bfe1f04637" translate="yes" xml:space="preserve">
          <source>Function that will be called to store the output (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">Функция,которая будет вызвана для хранения вывода (вместо записи).Параметры будут использовать синтаксис функции fwrite(),обязательно следуйте им.</target>
        </trans-unit>
        <trans-unit id="e221c711ff99df59e968c914d1979c6a0ad3ee61" translate="yes" xml:space="preserve">
          <source>Function to apply to each element of range</source>
          <target state="translated">Функция для применения к каждому элементу диапазона</target>
        </trans-unit>
        <trans-unit id="b844384b07c0f5d9caaa10fd46cb397be8c61ded" translate="yes" xml:space="preserve">
          <source>Function to be analyzed</source>
          <target state="translated">Функция для анализа</target>
        </trans-unit>
        <trans-unit id="b78a95743121775c17568fcabf9200b6a902bef0" translate="yes" xml:space="preserve">
          <source>Function to check, followed by a variadic number of function attributes as strings</source>
          <target state="translated">Функция для проверки,с последующим разнообразным количеством атрибутов функции в виде строк</target>
        </trans-unit>
        <trans-unit id="aefc954f08bca71e2e39ec093b9e23048430f8af" translate="yes" xml:space="preserve">
          <source>Function traits</source>
          <target state="translated">Функциональные характеристики</target>
        </trans-unit>
        <trans-unit id="2e40e24355bdf1170d50a1d6ead524ba20679656" translate="yes" xml:space="preserve">
          <source>Function/Delegate literal</source>
          <target state="translated">Функция/Удаление буквально</target>
        </trans-unit>
        <trans-unit id="8ebd95c8f1ce3b6070bf21aaa16655aa94a89c6b" translate="yes" xml:space="preserve">
          <source>FunctionLiteral</source>
          <target state="translated">FunctionLiteral</target>
        </trans-unit>
        <trans-unit id="a3d450d75bfa53b89f98aa6dae8be36130018cbb" translate="yes" xml:space="preserve">
          <source>FunctionLiteralBody</source>
          <target state="translated">FunctionLiteralBody</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="a03b0f45370db4b978978138169257e95bfff4b6" translate="yes" xml:space="preserve">
          <source>Functionality for processing subsequent matches of global regexes via range interface:</source>
          <target state="translated">Функциональность для обработки последующих совпадений глобальных регрексов через интерфейс диапазона:</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5687015bfcd81aa78a69312ebd359e3273b183cc" translate="yes" xml:space="preserve">
          <source>Functions Without Bodies</source>
          <target state="translated">Функции без тела</target>
        </trans-unit>
        <trans-unit id="bba90169e567d9c68b308641b7cc0ffd3300695b" translate="yes" xml:space="preserve">
          <source>Functions and delegates declared at module scope are zero-initialized by default. However both can be initialized to any function pointer (including a function literal). For delegates, the context pointer &lt;code&gt;.ptr&lt;/code&gt; is initialized to null.</source>
          <target state="translated">Функции и делегаты, объявленные в области видимости модуля, по умолчанию инициализируются нулями. Однако оба могут быть инициализированы для любого указателя функции (включая литерал функции). Для делегатов указатель контекста &lt;code&gt;.ptr&lt;/code&gt; инициализируется нулем.</target>
        </trans-unit>
        <trans-unit id="b9443a12c52c106d6f6936a59aa4d60507110962" translate="yes" xml:space="preserve">
          <source>Functions and types that manipulate built-in arrays and associative arrays.</source>
          <target state="translated">Функции и типы,которые управляют встроенными массивами и ассоциативными массивами.</target>
        </trans-unit>
        <trans-unit id="1fcc64ae1b70c55efc217545c066c056d0513c2e" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interface with extern(C++) ABI.</source>
          <target state="translated">Функции и переменные,специфичные для интерфейса с внешним(C++)ABI.</target>
        </trans-unit>
        <trans-unit id="fd8851f8cc2c81bc5719fd2159093b00e7797298" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interfacing with extern(C) ABI.</source>
          <target state="translated">Функции и переменные,специфичные для взаимодействия с внешним(C)ABI.</target>
        </trans-unit>
        <trans-unit id="7f5a53c5e8af7e00f9774b9397648dd6e21fd328" translate="yes" xml:space="preserve">
          <source>Functions are never inlined.</source>
          <target state="translated">Функции никогда не подчёркиваются.</target>
        </trans-unit>
        <trans-unit id="4713c57b4dfbd0d2f4ef062d96b18f64a40c55bc" translate="yes" xml:space="preserve">
          <source>Functions are overloaded based on how well the arguments to a function can match up with the parameters. The function with the</source>
          <target state="translated">Функции перегружены в зависимости от того,насколько аргументы функции могут совпадать с параметрами.Функция с</target>
        </trans-unit>
        <trans-unit id="a7f661a74f02a377df2091c16fea97336e40806f" translate="yes" xml:space="preserve">
          <source>Functions as Array Properties</source>
          <target state="translated">Функции как свойства массива</target>
        </trans-unit>
        <trans-unit id="e47c1a27abfc73a2fed656e28cc0a5aa9ab7a938" translate="yes" xml:space="preserve">
          <source>Functions can also be declared as &lt;code&gt;ref&lt;/code&gt;, meaning their return value is passed by reference:</source>
          <target state="translated">Функции также могут быть объявлены как &lt;code&gt;ref&lt;/code&gt; , что означает, что их возвращаемое значение передается по ссылке:</target>
        </trans-unit>
        <trans-unit id="fc9e94fc77751f7a520ef1950989f7a0e1c7828b" translate="yes" xml:space="preserve">
          <source>Functions can be nested within member functions:</source>
          <target state="translated">Функции могут быть вложены в функции членов:</target>
        </trans-unit>
        <trans-unit id="7e69a10d10797495520ab6d16edfbd50e9742682" translate="yes" xml:space="preserve">
          <source>Functions declared at the same scope overload against each other, and are called an</source>
          <target state="translated">Функции,объявленные в одной и той же области применения перегрузкой друг против друга,называются</target>
        </trans-unit>
        <trans-unit id="c566e2fda222bdb6e383ab5ff3c3433df764aa7f" translate="yes" xml:space="preserve">
          <source>Functions defined with non-D linkage cannot be overloaded. This is because the name mangling might not take the parameter types into account.</source>
          <target state="translated">Функции,определенные с помощью не D-связи,не могут быть перегружены.Это связано с тем,что при управлении именами могут не учитываться типы параметров.</target>
        </trans-unit>
        <trans-unit id="988f1aa7ff1ca669378942571abfebb6288e682f" translate="yes" xml:space="preserve">
          <source>Functions executed via CTFE can give different results from run time in the following scenarios:</source>
          <target state="translated">Функции,выполняемые через CTFE,могут давать различные результаты,отличные от времени выполнения в следующих сценариях:</target>
        </trans-unit>
        <trans-unit id="419aab857f4bb8c6136ba89e91fb3714fd5cb75f" translate="yes" xml:space="preserve">
          <source>Functions for starting and interacting with other processes, and for working with the current process' execution environment.</source>
          <target state="translated">Функции запуска и взаимодействия с другими процессами,а также работы со средой исполнения текущего процесса.</target>
        </trans-unit>
        <trans-unit id="50b5e5b232695481bdd4d283f8038b839689e2f6" translate="yes" xml:space="preserve">
          <source>Functions marked as &lt;code&gt;final&lt;/code&gt; may not be overridden in a derived class, unless they are also &lt;code&gt;private&lt;/code&gt;. For example:</source>
          <target state="translated">Функции, помеченные как &lt;code&gt;final&lt;/code&gt; , не могут быть переопределены в производном классе, если только они не являются &lt;code&gt;private&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="c40c48a24043c849a46e19c95c7d6f6bb43d3af4" translate="yes" xml:space="preserve">
          <source>Functions may be nested within other functions:</source>
          <target state="translated">Функции могут быть вложены в другие функции:</target>
        </trans-unit>
        <trans-unit id="ab842017af8570439bf6ba4b27c54b5312a024b2" translate="yes" xml:space="preserve">
          <source>Functions nested inside safe functions default to being safe functions.</source>
          <target state="translated">Функции,вложенные в безопасные функции по умолчанию являются функциями безопасности.</target>
        </trans-unit>
        <trans-unit id="e7c3eeba379274331a0b9c881db32559bea140a9" translate="yes" xml:space="preserve">
          <source>Functions taking a variable number of arguments are called variadic functions. A variadic function can take one of three forms:</source>
          <target state="translated">Функции,принимающие переменное количество аргументов,называются вариадическими функциями.Вариадическая функция может принимать одну из трех форм:</target>
        </trans-unit>
        <trans-unit id="2f8dcbed7cf260c12b9f8f40b2d592ffce349a24" translate="yes" xml:space="preserve">
          <source>Functions that deal with mutable, const, or immutable types with equanimity often need to transmit their type to the return value:</source>
          <target state="translated">Функциям,которые имеют дело с мутируемыми,константными или неизменяемыми типами с невозмутимостью,часто приходится передавать их тип на возвращаемое значение:</target>
        </trans-unit>
        <trans-unit id="8cc0d5a6974c142e0e42bd69101ee5cdc41acf88" translate="yes" xml:space="preserve">
          <source>Functions that manipulate other functions.</source>
          <target state="translated">Функции,которые манипулируют другими функциями.</target>
        </trans-unit>
        <trans-unit id="d4e8675aa25a2bddb84bf8fd8b778e29fe3cf68c" translate="yes" xml:space="preserve">
          <source>Functions that meet these requirements may be &lt;a href=&quot;#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trusted-functions&quot;&gt;&lt;code&gt;@trusted&lt;/code&gt;&lt;/a&gt;. Function that do not meet these requirements can only be &lt;a href=&quot;#system-functions&quot;&gt;&lt;code&gt;@system&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9283433eaa6818c4d57146ef0bb556e3d0ffc12f" translate="yes" xml:space="preserve">
          <source>Functions which are both portable and free of global side-effects can be executed at compile time. In certain contexts, such compile time execution is guaranteed. It is called Compile Time Function Execution (CTFE) then. The contexts that trigger CTFE are:</source>
          <target state="translated">Функции,которые являются портативными и не имеют глобальных побочных эффектов,могут быть выполнены во время компиляции.В определенных контекстах такое время компиляции гарантировано.Тогда она называется Compile Time Function Execution (CTFE).Это контексты,которые запускают CTFE:</target>
        </trans-unit>
        <trans-unit id="670fb705837790471a38cafc20ec80fbf30c8bf6" translate="yes" xml:space="preserve">
          <source>Functions which operate on ASCII characters.</source>
          <target state="translated">Функции,работающие с ASCII-символами.</target>
        </trans-unit>
        <trans-unit id="7c0d365cb94dab42778d857cad063abfc3d8f3b6" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage has an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="translated">Функции со связью &lt;code&gt;Objective-C&lt;/code&gt; имеют дополнительный скрытый, безымянный параметр, который является селектором, с которым он был вызван.</target>
        </trans-unit>
        <trans-unit id="2f12c7ced7f8f22b29fa0338695211d8c0538660" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage have an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbb7352ab0b0a6abe4eb4d50fb47e8061479506" translate="yes" xml:space="preserve">
          <source>Functions with non-D linkage cannot be virtual and hence cannot be overridden.</source>
          <target state="translated">Функции,не связанные с D-связью,не могут быть виртуальными и,следовательно,не могут быть переопределены.</target>
        </trans-unit>
        <trans-unit id="eaad94952abd8178c9c878e428d9910f2e427164" translate="yes" xml:space="preserve">
          <source>Functions with the &lt;code&gt;@live&lt;/code&gt; attribute enable diagnosing these sorts of errors by tracking the status of owner pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adb6747d6f26e87d983ed577d7da81919733d7b" translate="yes" xml:space="preserve">
          <source>Functions without bodies:</source>
          <target state="translated">Функции без тел:</target>
        </trans-unit>
        <trans-unit id="d783b16a7b27b910940b783d5fcc870c6c683d47" translate="yes" xml:space="preserve">
          <source>Fundamental Unicode algorithms and data structures.</source>
          <target state="translated">Фундаментальные алгоритмы Юникода и структуры данных.</target>
        </trans-unit>
        <trans-unit id="ba469f1bc17cb15fca5f5581188a0b34ac4471eb" translate="yes" xml:space="preserve">
          <source>Furthermore, even with orderable types, the order relation may not be linear. For example, one may define an ordering on sets via the subset relation, such that &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true if &lt;code&gt;x&lt;/code&gt; is a (strict) subset of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are disjoint sets, then neither &lt;code&gt;x &amp;lt; y&lt;/code&gt; nor &lt;code&gt;y &amp;lt; x&lt;/code&gt; holds, but that does not imply that &lt;code&gt;x == y&lt;/code&gt;. Thus, it is insufficient to determine equality purely based on &lt;code&gt;opCmp&lt;/code&gt; alone. For this reason, &lt;code&gt;opCmp&lt;/code&gt; is only used for the inequality operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt;. The equality operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; always employ &lt;code&gt;opEquals&lt;/code&gt; instead.</source>
          <target state="translated">Кроме того, даже с упорядочиваемыми типами отношение порядка может быть не линейным. Например, можно определить порядок на множествах через отношение подмножеств, так что &lt;code&gt;x &amp;lt; y&lt;/code&gt; истинно, если &lt;code&gt;x&lt;/code&gt; является (строгим) подмножеством &lt;code&gt;y&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются непересекающимися множествами, то не выполняется ни &lt;code&gt;x &amp;lt; y&lt;/code&gt; ни &lt;code&gt;y &amp;lt; x&lt;/code&gt; , но это не означает, что &lt;code&gt;x == y&lt;/code&gt; . Таким образом, недостаточно определить равенство исключительно на &lt;code&gt;opCmp&lt;/code&gt; только opCmp . По этой причине &lt;code&gt;opCmp&lt;/code&gt; используется только для операторов неравенства &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&lt;/code&gt; , Операторы равенства &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Всегда используют &lt;code&gt;opEquals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="869bc7df187eb57c1861571c27bf80367e22db67" translate="yes" xml:space="preserve">
          <source>Furthermore, predefined version identifiers from this list cannot be set from the command line or from version statements. (This prevents things like both &lt;code&gt;Windows&lt;/code&gt; and &lt;code&gt;linux&lt;/code&gt; being simultaneously set.)</source>
          <target state="translated">Кроме того, предопределенные идентификаторы версий из этого списка не могут быть установлены из командной строки или из операторов версии. (Это предотвращает одновременную настройку таких вещей, как &lt;code&gt;Windows&lt;/code&gt; и &lt;code&gt;linux&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="2b04009b8ca8039e0507f25a9f0361986b70a3e6" translate="yes" xml:space="preserve">
          <source>Future policies may offer a more even balance between reader and writer precedence.</source>
          <target state="translated">Будущая политика может предложить более равномерный баланс между приоритетом читателя и приоритетом писателя.</target>
        </trans-unit>
        <trans-unit id="99d254d35351117c9cff18872b82ba6d91c00e60" translate="yes" xml:space="preserve">
          <source>G &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">Г &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="227e2edf0447cd04a773c3b823f1c89795158178" translate="yes" xml:space="preserve">
          <source>GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt;(string name);</source>
          <target state="translated">GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt; (имя строки);</target>
        </trans-unit>
        <trans-unit id="17686e6502ad0f3cdaf4206e0191cbc522cc8283" translate="yes" xml:space="preserve">
          <source>GC FAQ</source>
          <target state="translated">ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ</target>
        </trans-unit>
        <trans-unit id="2715953d0812423734ebffeea6a105ce46d2c5b2" translate="yes" xml:space="preserve">
          <source>GC allocated string</source>
          <target state="translated">выделенная строка GC</target>
        </trans-unit>
        <trans-unit id="8b2c6daf9a150d506a85e85cb9bcb053667888f2" translate="yes" xml:space="preserve">
          <source>GC allocated string with spaces replaced with tabs; use &lt;a href=&quot;#entabber&quot;&gt;&lt;code&gt;entabber&lt;/code&gt;&lt;/a&gt; to not allocate.</source>
          <target state="translated">GC выделил строку с пробелами, замененными табуляцией используйте &lt;a href=&quot;#entabber&quot;&gt; &lt;code&gt;entabber&lt;/code&gt; ,&lt;/a&gt; чтобы не выделять.</target>
        </trans-unit>
        <trans-unit id="86e1b687d8486a9dcb7b4165bc8e5226d854f2c7" translate="yes" xml:space="preserve">
          <source>GC allocated string with tabs replaced with spaces</source>
          <target state="translated">GC выделенная строка с табуляциями заменена пробелами</target>
        </trans-unit>
        <trans-unit id="6b9746104b4c3bc7be22e5b6d74741bddee5a6bf" translate="yes" xml:space="preserve">
          <source>GC implementations are added to a registry that allows to supply more implementations by just linking them into the binary. To do so add a function that is executed before the D runtime initialization using &lt;code&gt;pragma(crt_constructor)&lt;/code&gt;:</source>
          <target state="translated">Реализации GC добавляются в реестр, что позволяет предоставлять больше реализаций, просто связывая их в двоичный файл. Для этого добавьте функцию, которая выполняется до инициализации среды выполнения D с использованием &lt;code&gt;pragma(crt_constructor)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5951ff6858fe229e78c3aef61db342f3d5f757a1" translate="yes" xml:space="preserve">
          <source>GC scan hook, called FOR each thread. Can be used to scan additional thread local memory.</source>
          <target state="translated">Крючок для GC-сканирования,вызывается для каждой нити.Может использоваться для сканирования дополнительных потоков локальной памяти.</target>
        </trans-unit>
        <trans-unit id="44da27f9ddec555cbd5fcd60022e2b6c8808bbdc" translate="yes" xml:space="preserve">
          <source>GC sweep hook, called FOR each thread. Can be used to free additional thread local memory or associated data structures. Note that only memory allocated from the GC can have marks.</source>
          <target state="translated">Крюк GC,называемый для каждой нити.Может использоваться для освобождения дополнительной локальной памяти потока или связанных с ним структур данных.Обратите внимание,что только память,выделенная из ГХ,может иметь пометки.</target>
        </trans-unit>
        <trans-unit id="152e90dd32518be928b899f58b1e3835f65ca8cc" translate="yes" xml:space="preserve">
          <source>GCFactory &lt;code&gt;factory&lt;/code&gt;</source>
          <target state="translated">GCЗаводская &lt;code&gt;factory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a69c000934b632336629d0d827590961013d5f" translate="yes" xml:space="preserve">
          <source>GDC (GNU D Compiler) is the compiler</source>
          <target state="translated">GDC (GNU D Compiler)-компилятор.</target>
        </trans-unit>
        <trans-unit id="c6b9fdbe9b835ce607d5f9465603dc2e9dd09b8c" translate="yes" xml:space="preserve">
          <source>GNU D Compiler (GDC)</source>
          <target state="translated">Компилятор GNU D (GDC)</target>
        </trans-unit>
        <trans-unit id="1ced0cf23647bda25b46395cd7423d5899e8cec5" translate="yes" xml:space="preserve">
          <source>GNU Hurd</source>
          <target state="translated">GNU Hurd</target>
        </trans-unit>
        <trans-unit id="c9744a883d88a359c771c7c407727c811697e7d9" translate="yes" xml:space="preserve">
          <source>GSS-Negotiate</source>
          <target state="translated">GSS-Negotiate</target>
        </trans-unit>
        <trans-unit id="649101d4277d8226d1453ed4ac0ae23fef3f6651" translate="yes" xml:space="preserve">
          <source>GapWeightedSimilarityIncremental!(R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSimilarityIncremental&lt;/strong&gt;(R, F)(R r1, R r2, F penalty);</source>
          <target state="translated">GapWeightedSdentifityIncremental! (R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSdentifityIncremental&lt;/strong&gt; (R, F) (R r1, R r2, штраф F);</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">Сбор мусора</target>
        </trans-unit>
        <trans-unit id="b68927a1fc8d1a3e9f2d3afdf28381f11e58bc69" translate="yes" xml:space="preserve">
          <source>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</source>
          <target state="translated">Сбор мусора:Алгоритмы автоматического динамического управления памятью</target>
        </trans-unit>
        <trans-unit id="26ed33deae58e27843afa7f067144cf4cc6aa56f" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are faster to develop and debug, because there's no need for developing, debugging, testing, or maintaining the explicit deallocation code.</source>
          <target state="translated">Программы,собирающие мусор,быстрее разрабатываются и отлаживаются,потому что нет необходимости в разработке,отладке,тестировании или сопровождении явного кода дилокации.</target>
        </trans-unit>
        <trans-unit id="b5b34cabae6ba38a27f9919e85bfc06a08059602" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are often faster. This is counterintuitive, but the reasons are:</source>
          <target state="translated">Программы по сбору мусора часто бывают быстрее.Это противоречит интуиции,но причина в этом:</target>
        </trans-unit>
        <trans-unit id="a8b92a6daa02321044a81fa8b11e153716774a33" translate="yes" xml:space="preserve">
          <source>Garbage collected programs do not suffer from gradual deterioration due to an accumulation of memory leaks.</source>
          <target state="translated">Программы для сбора мусора не страдают от постепенного ухудшения из-за накопления утечек памяти.</target>
        </trans-unit>
        <trans-unit id="7b3b619bb8bd26c9ff456e8cbc3e5bc6b3b1d018" translate="yes" xml:space="preserve">
          <source>Garbage collected programs have fewer hard-to-find pointer bugs. This is because there are no dangling references to freed memory. There is no code to explicitly manage memory, hence no bugs in such code.</source>
          <target state="translated">В программах по сбору мусора меньше ошибок в указателях.Это происходит потому,что нет висячих ссылок на освобожденную память.Нет кода для явного управления памятью,а значит,в таком коде нет ошибок.</target>
        </trans-unit>
        <trans-unit id="6274199ad9ef2c79ed1df932fffcb7da577e7439" translate="yes" xml:space="preserve">
          <source>Garbage collection doesn't solve every memory deallocation problem. For example, if a pointer to a large data structure is kept, the garbage collector cannot reclaim it, even if it is never referred to again. To eliminate this problem, it is good practice to set a reference or pointer to an object to null when no longer needed.</source>
          <target state="translated">Сбор мусора не решает каждой проблемы перераспределения памяти.Например,если указатель на большую структуру данных сохраняется,сборщик мусора не может его восстановить,даже если на него больше никогда не ссылаются.Чтобы устранить эту проблему,хорошей практикой является установка ссылки или указателя на объект на ноль,когда он больше не нужен.</target>
        </trans-unit>
        <trans-unit id="2a483157166b15cc6add50950e71104545209b12" translate="yes" xml:space="preserve">
          <source>Garbage collection is not a panacea. There are some downsides:</source>
          <target state="translated">Сбор мусора-это не панацея.Есть и недостатки:</target>
        </trans-unit>
        <trans-unit id="bdc8494b0a1f3be26c109010c1300b5540a63f86" translate="yes" xml:space="preserve">
          <source>Garbage collection kicks in only when memory gets tight. When memory is not tight, the program runs at full speed and does not spend any time tracing and freeing memory.</source>
          <target state="translated">Сбор мусора начинается только тогда,когда память становится плотной.Когда память не становится плотной,программа работает на полной скорости и не тратит время на трассировку и освобождение памяти.</target>
        </trans-unit>
        <trans-unit id="43e630068e8d3af90d5baf5c490d09a820b5fe43" translate="yes" xml:space="preserve">
          <source>Garbage collection should be implemented as a basic operating system kernel service. But since it is not, garbage collecting programs must carry around with them the garbage collection implementation. While this can be a shared library, it is still there.</source>
          <target state="translated">Уборка мусора должна быть реализована в качестве основного сервиса ядра операционной системы.Но так как это не так,то программы сбора мусора должны нести с собой реализацию сборки мусора.Хотя это может быть общая библиотека,она все же существует.</target>
        </trans-unit>
        <trans-unit id="8de09af360c7bfc02cd9b07759c0be1a92997bf1" translate="yes" xml:space="preserve">
          <source>Garbage collectors can keep around some memory that an explicit deallocator would not.</source>
          <target state="translated">Сборщики мусора могут хранить вокруг некоторой памяти,чего явно не сделал бы дилелокатор.</target>
        </trans-unit>
        <trans-unit id="52f128a6c5d8578ad64f58e212419d6613dc978b" translate="yes" xml:space="preserve">
          <source>Garbage collectors reclaim unused memory, therefore they do not suffer from &quot;memory leaks&quot; which can cause long running applications to gradually consume more and more memory until they bring down the system. GC programs have longer term stability.</source>
          <target state="translated">Сборщики мусора восстанавливают неиспользованную память,поэтому они не страдают от &quot;утечек памяти&quot;,которые могут привести к тому,что долго работающие приложения будут постепенно потреблять все больше и больше памяти до тех пор,пока не выведут систему из строя.GC-программы имеют более длительную стабильность.</target>
        </trans-unit>
        <trans-unit id="5929f6c7d4d9ef8bac1c480f80dfd125a208b5f6" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol</source>
          <target state="translated">Протокол шлюза к шлюзу</target>
        </trans-unit>
        <trans-unit id="6b850d9a8cc2ef5b85b6581a88258447107ac8f9" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol level</source>
          <target state="translated">Уровень протокола шлюза к шлюзу</target>
        </trans-unit>
        <trans-unit id="8e56a55c1f12981e7b0c87a44da833cae0277f14" translate="yes" xml:space="preserve">
          <source>Gcc Cpp runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0db25c1007f1ac431f102d1b6f3db7e823e1c1d" translate="yes" xml:space="preserve">
          <source>GccAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">GccAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="cc2b80e244c5b3f85b819f8e001f39a8b1778b1c" translate="yes" xml:space="preserve">
          <source>General Punctuation</source>
          <target state="translated">Общая пунктуация</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">Общие Типы</target>
        </trans-unit>
        <trans-unit id="fd7aec0ee16d41be57526539a4c6ef8ef63c34e9" translate="yes" xml:space="preserve">
          <source>General case =&amp;gt; symmetric calls to method opEquals</source>
          <target state="translated">Общий случай =&amp;gt; симметричные вызовы метода opEquals</target>
        </trans-unit>
        <trans-unit id="2def4e3aff28a0804ab7417604344f41584fcca9" translate="yes" xml:space="preserve">
          <source>General category sets listed below are only accessible with the &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; shorthand accessor.</source>
          <target state="translated">Перечисленные ниже наборы общих категорий доступны только при использовании сокращенного доступа &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2083d118900999f8d32dc5f2e8254d3f52ea6bf1" translate="yes" xml:space="preserve">
          <source>General use synchronization semaphore.</source>
          <target state="translated">Семафор синхронизации общего назначения.</target>
        </trans-unit>
        <trans-unit id="15c16d502337718b40d0beb9afa9790ccdf94859" translate="yes" xml:space="preserve">
          <source>Generally useful building blocks for customized normalization: &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt; for querying combining class and &lt;a href=&quot;#allowedIn&quot;&gt;&lt;code&gt;allowedIn&lt;/code&gt;&lt;/a&gt; for testing the Quick_Check property of a given normalization form.</source>
          <target state="translated">Обычно полезные строительные блоки для настраиваемой нормализации: &lt;a href=&quot;#combiningClass&quot;&gt; &lt;code&gt;combiningClass&lt;/code&gt; &lt;/a&gt; для запроса класса объединения и &lt;a href=&quot;#allowedIn&quot;&gt; &lt;code&gt;allowedIn&lt;/code&gt; &lt;/a&gt; для тестирования свойства Quick_Check данной формы нормализации.</target>
        </trans-unit>
        <trans-unit id="9641d9bcb23b576cc813cade93d2589aaa993fe5" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;stable&lt;/code&gt; ordering strategy may be more costly in time and/or space than the other two because it imposes additional constraints. Similarly, &lt;code&gt;semistable&lt;/code&gt; may be costlier than &lt;code&gt;unstable&lt;/code&gt;. As (semi-)stability is not needed very often, the ordering algorithms in this module parameterized by &lt;code&gt;SwapStrategy&lt;/code&gt; all choose &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; as the default.</source>
          <target state="translated">Как правило, стратегия &lt;code&gt;stable&lt;/code&gt; упорядочения может быть более дорогостоящей во времени и / или пространстве, чем две другие, потому что она накладывает дополнительные ограничения. Аналогично, &lt;code&gt;semistable&lt;/code&gt; может быть дороже, чем &lt;code&gt;unstable&lt;/code&gt; . Поскольку (полу) стабильность не требуется очень часто, алгоритмы упорядочения в этом модуле, параметризованном &lt;code&gt;SwapStrategy&lt;/code&gt; , все выбирают &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="05d74eaaa124507aed1ad66047271caa648813e4" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;std&lt;/code&gt; namespace is used for the main modules in the Phobos standard library. The &lt;code&gt;etc&lt;/code&gt; namespace is used for external C/C++ library bindings. The &lt;code&gt;core&lt;/code&gt; namespace is used for low-level D runtime functions.</source>
          <target state="translated">Как правило, пространство имен &lt;code&gt;std&lt;/code&gt; используется для основных модулей в стандартной библиотеке Phobos. Пространство имен &lt;code&gt;etc&lt;/code&gt; используется для привязки внешних библиотек C / C ++. Пространство имен &lt;code&gt;core&lt;/code&gt; используется для низкоуровневых функций времени выполнения D.</target>
        </trans-unit>
        <trans-unit id="270a807f0de4d20f0d7b86a3f7b8a65802e708dd" translate="yes" xml:space="preserve">
          <source>Generally, this function checks that &lt;code&gt;path&lt;/code&gt; is not empty, and that each component of the path either satisfies &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; or is equal to &lt;code&gt;&quot;.&quot;&lt;/code&gt; or &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">Как правило, эта функция проверяет, что &lt;code&gt;path&lt;/code&gt; не является пустым, и что каждый компонент пути либо удовлетворяет &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; ,&lt;/a&gt; либо равен &lt;code&gt;&quot;.&quot;&lt;/code&gt; или &lt;code&gt;&quot;..&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3d74ace2e58f845d2e516e7b9c956be3febfc4" translate="yes" xml:space="preserve">
          <source>Generate .obj file for Module.</source>
          <target state="translated">Сгенерируйте .obj файл для Модуля.</target>
        </trans-unit>
        <trans-unit id="f9dad7b8a1ce93a4eb80b95d85ef1cf88d8f4597" translate="yes" xml:space="preserve">
          <source>Generate C main() in response to seeing D main().</source>
          <target state="translated">Сгенерируйте C main()в ответ на видение D main().</target>
        </trans-unit>
        <trans-unit id="345123c70e49b34125173495f611953054f48574" translate="yes" xml:space="preserve">
          <source>Generate Expression to call the invariant.</source>
          <target state="translated">Сгенерировать выражение,чтобы назвать инварианта.</target>
        </trans-unit>
        <trans-unit id="d90320355fd64aadd68db9a959d0db877a879578" translate="yes" xml:space="preserve">
          <source>Generate HALT instruction.</source>
          <target state="translated">Сгенерировать инструкцию HALT.</target>
        </trans-unit>
        <trans-unit id="f40cd732815b9b227c307d8a881eabcde883c532" translate="yes" xml:space="preserve">
          <source>Generate Symbol of C++ type info for C++ class cd.</source>
          <target state="translated">Сгенерировать символ информации о типе C++для C++класса cd.</target>
        </trans-unit>
        <trans-unit id="71428fcf71b36719232a357b20981c579d5f795c" translate="yes" xml:space="preserve">
          <source>Generate a FuncDeclaration for a runtime library function.</source>
          <target state="translated">Сгенерируйте FuncDeclaration для функции библиотеки исполнения.</target>
        </trans-unit>
        <trans-unit id="c1f38d03f2f34b3b4a976dcf593b7574be546eff" translate="yes" xml:space="preserve">
          <source>Generate a convenient string for identifying this Tid. This is only useful to see if Tid's that are currently executing are the same or different, e.g. for logging and debugging. It is potentially possible that a Tid executed in the future will have the same toString() output as another Tid that has already terminated.</source>
          <target state="translated">Сгенерируйте удобную строку для идентификации этого Tid.Это полезно только для того,чтобы увидеть,являются ли выполняемые в данный момент Tid одинаковыми или разными,например,для протоколирования и отладки.Потенциально возможно,что Tid,выполняемый в будущем,будет иметь такой же вывод toString(),как и другой Tid,который уже завершился.</target>
        </trans-unit>
        <trans-unit id="42a4983512e25bdf4577cfbc7ade2d3d9ef11551" translate="yes" xml:space="preserve">
          <source>Generate a copy from e2 to e1.</source>
          <target state="translated">Сгенерируйте копию с e2 на e1.</target>
        </trans-unit>
        <trans-unit id="7e990bafe6b9623ad15b6163c4381e1e24f60827" translate="yes" xml:space="preserve">
          <source>Generate and output scope table.</source>
          <target state="translated">Сгенерировать и вывести таблицу диапазонов.</target>
        </trans-unit>
        <trans-unit id="d887428fee6838e30b863f3266f3121541d951d0" translate="yes" xml:space="preserve">
          <source>Generate call to C's assert failure function. One of exp, emsg, or str must not be null.</source>
          <target state="translated">Сгенерируйте вызов на функцию &quot;С&quot;.Одна из функций exp,emsg или str не должна быть нулевой.</target>
        </trans-unit>
        <trans-unit id="b0e2deeef3299cd274df6c669c731ce070bbe521" translate="yes" xml:space="preserve">
          <source>Generate data for instance of _cpp_type_info_ptr that refers to the C++ RTTI symbol for cd.</source>
          <target state="translated">Сгенерировать данные,например,_cpp_type_info_ptr,который ссылается на RTTI символ C++для cd.</target>
        </trans-unit>
        <trans-unit id="92ed283aad401b73892410374fb18c0200210984" translate="yes" xml:space="preserve">
          <source>Generate deterministic named identifier based on a source location, such that the name is consistent across multiple compilations. A new unique name is generated. If the prefix+location is already in the stringtable, an extra suffix is added (starting the count at &quot;1&quot;).</source>
          <target state="translated">Сгенерировать детерминистический именованный идентификатор,основанный на местоположении источника,таким образом,чтобы имя было последовательным в нескольких компиляциях.Генерируется новое уникальное имя.Если префикс+локация уже находится в строковом файле,добавляется дополнительный суффикс (начиная отсчет с &quot;1&quot;).</target>
        </trans-unit>
        <trans-unit id="e688f516a8d461fb5372c55840691f744fd51391" translate="yes" xml:space="preserve">
          <source>Generate import symbol from symbol.</source>
          <target state="translated">Сгенерировать символ импорта из символа.</target>
        </trans-unit>
        <trans-unit id="9978fdec524f341bfac18807618c73a3b51b46c1" translate="yes" xml:space="preserve">
          <source>Generate symbol of type ty at DATA:offset</source>
          <target state="translated">Сгенерировать символ типа шины на DATA:offset</target>
        </trans-unit>
        <trans-unit id="821fb78c5c9319cc69fa8057c9c2cd2d48fedaf8" translate="yes" xml:space="preserve">
          <source>Generate two operand instruction with XMM 128 bit operands.</source>
          <target state="translated">Сгенерируйте две инструкции для операндов с помощью 128-битных операндов XMM.</target>
        </trans-unit>
        <trans-unit id="5c437f1471923979723873169275d327e196c1fa" translate="yes" xml:space="preserve">
          <source>Generated Macro Definitions</source>
          <target state="translated">Генерируемые макроопределения</target>
        </trans-unit>
        <trans-unit id="b53fd19a2486af4f399d146936aa03eb7d82a727" translate="yes" xml:space="preserve">
          <source>Generated code is inserted in the scope of &lt;code&gt;std.typecons&lt;/code&gt; module. Thus, any useful functions outside &lt;code&gt;std.typecons&lt;/code&gt; cannot be used in the generated code. To workaround this problem, you may &lt;code&gt;import&lt;/code&gt; necessary things in a local struct, as done in the &lt;code&gt;generateLogger()&lt;/code&gt; template in the above example.</source>
          <target state="translated">Сгенерированный код вставляется в область действия модуля &lt;code&gt;std.typecons&lt;/code&gt; . Таким образом, любые полезные функции за пределами &lt;code&gt;std.typecons&lt;/code&gt; не могут быть использованы в сгенерированном коде. Чтобы обойти эту проблему, вы можете &lt;code&gt;import&lt;/code&gt; необходимые вещи в локальную структуру, как это сделано в шаблоне &lt;code&gt;generateLogger()&lt;/code&gt; в приведенном выше примере.</target>
        </trans-unit>
        <trans-unit id="e6857b9e8cb1c55a9a2f9226a5b4dc0cf595f501" translate="yes" xml:space="preserve">
          <source>Generates a hash for &lt;code&gt;this&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookToHash&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; does not implement &lt;code&gt;hookToHash&lt;/code&gt;, but it has state, a hash will be generated for the &lt;code&gt;Hook&lt;/code&gt; using the built-in function and it will be xored with the hash of the &lt;code&gt;payload&lt;/code&gt;.</source>
          <target state="translated">Создает хеш для &lt;code&gt;this&lt;/code&gt; . Если &lt;code&gt;Hook&lt;/code&gt; определяет &lt;code&gt;hookToHash&lt;/code&gt; , вызов немедленно возвращает &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; . Если &lt;code&gt;Hook&lt;/code&gt; не реализует &lt;code&gt;hookToHash&lt;/code&gt; , но имеет состояние, для &lt;code&gt;Hook&lt;/code&gt; будет сгенерирован хеш с помощью встроенной функции, и он будет добавлен в хэш &lt;code&gt;payload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feba4b72ab473cbf0cd5ea105195b64ec1ac1f2d" translate="yes" xml:space="preserve">
          <source>Generates a hash for the tree. Note that with a custom comparison function it may not hold that if two rbtrees are equal, the hashes of the trees will be equal.</source>
          <target state="translated">Генерирует гашиш для дерева.Обратите внимание,что при использовании пользовательской функции сравнения она может не удерживать,что если два дерева rbt равны,то хэши деревьев будут равны.</target>
        </trans-unit>
        <trans-unit id="57845456ec25b869fe6d9c20ab2d9cba380674de" translate="yes" xml:space="preserve">
          <source>Generates a human-readable stack-trace on POSIX targets using DWARF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398b1403000b9404acc8a7edce2480693602dfc5" translate="yes" xml:space="preserve">
          <source>Generates a number between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The &lt;code&gt;boundaries&lt;/code&gt; parameter controls the shape of the interval (open vs. closed on either side). Valid values for &lt;code&gt;boundaries&lt;/code&gt; are &lt;code&gt;&quot;[]&quot;&lt;/code&gt;, &lt;code&gt;&quot;(]&quot;&lt;/code&gt;, &lt;code&gt;&quot;[)&quot;&lt;/code&gt;, and &lt;code&gt;&quot;()&quot;&lt;/code&gt;. The default interval is closed to the left and open to the right. The version that does not take &lt;code&gt;urng&lt;/code&gt; uses the default generator &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">Создает число между &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; . Параметр &lt;code&gt;boundaries&lt;/code&gt; управляет формой интервала (открытый или закрытый с обеих сторон). Допустимые значения &lt;code&gt;boundaries&lt;/code&gt; : &lt;code&gt;&quot;[]&quot;&lt;/code&gt; , &lt;code&gt;&quot;(]&quot;&lt;/code&gt; , &lt;code&gt;&quot;[)&quot;&lt;/code&gt; и &lt;code&gt;&quot;()&quot;&lt;/code&gt; . Интервал по умолчанию закрыт слева и открыт справа. Версия, которая не принимает &lt;code&gt;urng&lt;/code&gt; , использует генератор по умолчанию &lt;code&gt;rndGen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31d5a7a72aa7d6403397ac8f8b98d7136fb359b8" translate="yes" xml:space="preserve">
          <source>Generates a uniform probability distribution of size &lt;code&gt;n&lt;/code&gt;, i.e., an array of size &lt;code&gt;n&lt;/code&gt; of positive numbers of type &lt;code&gt;F&lt;/code&gt; that sum to &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;useThis&lt;/code&gt; is provided, it is used as storage.</source>
          <target state="translated">Генерирует равномерное распределение вероятностей размера &lt;code&gt;n&lt;/code&gt; , то есть массив размером &lt;code&gt;n&lt;/code&gt; положительных чисел типа &lt;code&gt;F&lt;/code&gt; , сумма которых равна &lt;code&gt;1&lt;/code&gt; . Если &lt;code&gt;useThis&lt;/code&gt; предоставляется, он используется в качестве хранилища.</target>
        </trans-unit>
        <trans-unit id="e2682a8625295cc7a75ade62ec910662e42eb1ad" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed floating point number of type &lt;code&gt;T&lt;/code&gt; in the range [0, 1). If no random number generator is specified, the default RNG &lt;code&gt;rndGen&lt;/code&gt; will be used as the source of randomness.</source>
          <target state="translated">Генерирует равномерно распределенное число с плавающей запятой типа &lt;code&gt;T&lt;/code&gt; в диапазоне [0, 1). Если генератор случайных чисел не указан, в качестве источника случайности будет использоваться RNG по умолчанию &lt;code&gt;rndGen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="590a92dca2ec49812f71151418c5576ff9ad8ac5" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed number in the range &lt;code&gt;[T.min, T.max]&lt;/code&gt; for any integral or character type &lt;code&gt;T&lt;/code&gt;. If no random number generator is passed, uses the default &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">Создает равномерно распределенное число в диапазоне &lt;code&gt;[T.min, T.max]&lt;/code&gt; для любого интегрального или символа типа &lt;code&gt;T&lt;/code&gt; . Если генератор случайных чисел не передан, используется &lt;code&gt;rndGen&lt;/code&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="5a3dd4ef1d89d221f34cd8efe42c23a94aa835c2" translate="yes" xml:space="preserve">
          <source>Generates string with D source code of unary function with name of &lt;code&gt;funcName&lt;/code&gt; taking a single &lt;code&gt;dchar&lt;/code&gt; argument. If &lt;code&gt;funcName&lt;/code&gt; is empty the code is adjusted to be a lambda function.</source>
          <target state="translated">Генерирует строку с исходным кодом D унарной функции с именем &lt;code&gt;funcName&lt;/code&gt; , принимающим один аргумент &lt;code&gt;dchar&lt;/code&gt; . Если &lt;code&gt;funcName&lt;/code&gt; пусто, код корректируется как лямбда-функция.</target>
        </trans-unit>
        <trans-unit id="4b3935a65e18852e853df767745851e9e88c4154" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;torig&lt;/code&gt; if it hasn't already been generated</source>
          <target state="translated">Создает объект &lt;code&gt;TypeInfo&lt;/code&gt; , связанный с &lt;code&gt;torig&lt;/code&gt; , если он еще не был создан</target>
        </trans-unit>
        <trans-unit id="c898dd30458bc82445a94b03bf4338f7812ed73c" translate="yes" xml:space="preserve">
          <source>Generates the following:</source>
          <target state="translated">Генерирует следующее:</target>
        </trans-unit>
        <trans-unit id="ef2e0bcfe378859fb93a76e38ab31870b5aaab4c" translate="yes" xml:space="preserve">
          <source>Generating UUIDs</source>
          <target state="translated">Генерирование UUID</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="7282cafe7ab4dcfbd06151ce87eab6a8cb7b662e" translate="yes" xml:space="preserve">
          <source>Generic Template API used for CRC32 and CRC64 implementations.</source>
          <target state="translated">Общий API шаблона,используемый для реализации CRC32 и CRC64.</target>
        </trans-unit>
        <trans-unit id="48d04e2739718c3b5809e3d93e9ab17e0175ee79" translate="yes" xml:space="preserve">
          <source>Generic algorithms for processing sequences.</source>
          <target state="translated">Общие алгоритмы обработки последовательностей.</target>
        </trans-unit>
        <trans-unit id="7bca8ef182b8f3deaa44e5a838347a3d8559084e" translate="yes" xml:space="preserve">
          <source>Generic algorithms that work with &lt;a href=&quot;std_range&quot;&gt;ranges&lt;/a&gt; of any type, including strings, arrays, and other kinds of sequentially-accessed data. Algorithms include searching, comparison, iteration, sorting, set operations, and mutation.</source>
          <target state="translated">Универсальные алгоритмы, которые работают с &lt;a href=&quot;std_range&quot;&gt;диапазонами&lt;/a&gt; любого типа, включая строки, массивы и другие виды данных с последовательным доступом. Алгоритмы включают поиск, сравнение, итерацию, сортировку, операции над множествами и мутацию.</target>
        </trans-unit>
        <trans-unit id="e37a68ed0e7f2e44e67335effd984a4809f41f52" translate="yes" xml:space="preserve">
          <source>Generic code which deals with different Digest types should always call start though.</source>
          <target state="translated">Общий код,который работает с разными типами Digest,должен всегда вызывать start.</target>
        </trans-unit>
        <trans-unit id="a4fe6a7b8d8e501df226058c573d01d9418d71dd" translate="yes" xml:space="preserve">
          <source>Generic error</source>
          <target state="translated">Общая ошибка</target>
        </trans-unit>
        <trans-unit id="070a5062376a825143c54fc921ea5b5a3350219e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt;&lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Общее &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt; &lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt; &lt;/a&gt; по диапазонам: std.algorithm.mutation.strip</target>
        </trans-unit>
        <trans-unit id="a5f39e04859e495f02a94a4f09ad4d9de0e5160e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Общее &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt; &lt;/a&gt; на диапазоны: std.algorithm.mutation.stripLeft</target>
        </trans-unit>
        <trans-unit id="14b5394baf94216f2e7707c45724f2e122958d4a" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Общее &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt; &lt;/a&gt; по диапазонам: std.algorithm.mutation.stripRight</target>
        </trans-unit>
        <trans-unit id="f9464f7b462f8074504ba78be947c4f876e0fc5c" translate="yes" xml:space="preserve">
          <source>Generic type value getter A convenience getter that returns this &lt;code&gt;JSONValue&lt;/code&gt; as the specified D type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d110955c054077a9782bc3e9dc049c8ed9e192f" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units.</source>
          <target state="translated">Общий способ преобразования между двумя единицами времени.</target>
        </trans-unit>
        <trans-unit id="fdfe3a8efedde26bb169021d4c0add270ebc9913" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units. Conversions to smaller units use truncating division. Years and months can be converted to each other, small units can be converted to each other, but years and months cannot be converted to or from smaller units (due to the varying number of days in a month or year).</source>
          <target state="translated">Общий способ преобразования между двумя единицами времени.При преобразовании в меньшие единицы времени используется усечение.Годы и месяцы могут быть преобразованы друг в друга,малые единицы могут быть преобразованы друг в друга,но годы и месяцы не могут быть преобразованы в меньшие единицы или из них (из-за различного количества дней в месяце или году).</target>
        </trans-unit>
        <trans-unit id="8351f1bd421bb3c2f34de06d3708adb7a974a3d4" translate="yes" xml:space="preserve">
          <source>Geometric Shapes</source>
          <target state="translated">Геометрические формы</target>
        </trans-unit>
        <trans-unit id="aca441ddd2e8d07643b87c1b24a828fa5b4b3e42" translate="yes" xml:space="preserve">
          <source>Georgian</source>
          <target state="translated">Georgian</target>
        </trans-unit>
        <trans-unit id="c559cff938d372579d74b90c80d2874125e4b5d4" translate="yes" xml:space="preserve">
          <source>Georgian Supplement</source>
          <target state="translated">грузинское приложение</target>
        </trans-unit>
        <trans-unit id="2e85da619ae334aca9d3221727062ef17b60edd9" translate="yes" xml:space="preserve">
          <source>Get Pointer to Thrown Object if type of thrown object is implicitly convertible to the catch type.</source>
          <target state="translated">Получить указатель на брошенный объект,если тип брошенного объекта неявно конвертируется в тип catch.</target>
        </trans-unit>
        <trans-unit id="49759c09a6285b1e1c3c2442b86bed6b17c79b57" translate="yes" xml:space="preserve">
          <source>Get RTTI mangling of the given class declaration for C++ ABI.</source>
          <target state="translated">Получите RTTI манипуляцию декларации данного класса для C++ABI.</target>
        </trans-unit>
        <trans-unit id="30af4ba10b05a5544d5e9caa6adff1c6bc3df069" translate="yes" xml:space="preserve">
          <source>Get TypeInfo for 'next' type, as defined by what kind of type this is, null if none.</source>
          <target state="translated">Получить TypeInfo для 'следующего' типа,как определено,какой это тип,null if none.</target>
        </trans-unit>
        <trans-unit id="c92e7f5f377e9154bb8151fe8cde1e5454a8ad6b" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of</source>
          <target state="translated">Получите псевдоним</target>
        </trans-unit>
        <trans-unit id="2697c6709922de4b4eb3a504173797b3b2d2f222" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of the base class and base interfaces of this class or interface. BaseTypeTuple!Object returns the empty type tuple.</source>
          <target state="translated">Получите AliasSeq базового класса и базовых интерфейсов этого класса или интерфейса.BaseTypeTuple!Object возвращает кортеж пустого типа.</target>
        </trans-unit>
        <trans-unit id="debff9d835c323dd33cb0eb8c68915f9979c7a6c" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;gt; e according to the less comparator</source>
          <target state="translated">Получить диапазон из контейнера со всеми элементами, которые&amp;gt; e в соответствии с меньшим компаратором</target>
        </trans-unit>
        <trans-unit id="2f427a0e190ea30b9ef773b930557ceb28c95c24" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;lt; e according to the less comparator</source>
          <target state="translated">Получить диапазон из контейнера со всеми элементами, которые &amp;lt;e в соответствии с меньшим компаратором</target>
        </trans-unit>
        <trans-unit id="1a49fd135d74779940e67901f3680596c3cb7489" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are == e according to the less comparator</source>
          <target state="translated">Получить диапазон от контейнера со всеми элементами,которые ==e в соответствии с меньшим компаратором</target>
        </trans-unit>
        <trans-unit id="57416603cdc2a4317e5cef5fc1df8438a0dc691d" translate="yes" xml:space="preserve">
          <source>Get a socket option.</source>
          <target state="translated">Получите возможность подключения к розетке.</target>
        </trans-unit>
        <trans-unit id="ab0526a6b77b2a6ea32e278479a2c15bfc6233f8" translate="yes" xml:space="preserve">
          <source>Get a text description of this socket's error status, and clear the socket's error status.</source>
          <target state="translated">Получите текстовое описание состояния ошибки этого сокета и очистите его от ошибок.</target>
        </trans-unit>
        <trans-unit id="cb65e9616425e0463e1160c764ce114f293c53ad" translate="yes" xml:space="preserve">
          <source>Get a timeout (duration) option.</source>
          <target state="translated">Получить тайм-аут (продолжительность).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
