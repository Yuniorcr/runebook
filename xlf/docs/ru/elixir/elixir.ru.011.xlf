<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="814c5f11fc85ecacb301d5d1ff7a5207b63cc546" translate="yes" xml:space="preserve">
          <source>Starts monitoring the given &lt;code&gt;port&lt;/code&gt; from the calling process.</source>
          <target state="translated">Начинает мониторинг данного &lt;code&gt;port&lt;/code&gt; из вызывающего процесса.</target>
        </trans-unit>
        <trans-unit id="32f7fdf8c34390c9e691d76ef8c0ec7bd0d81af7" translate="yes" xml:space="preserve">
          <source>Starts the current application and runs code.</source>
          <target state="translated">Запускает текущее приложение и запускает код.</target>
        </trans-unit>
        <trans-unit id="465701ca429a2dfabc3bc5f01a8bd60e3b9231c7" translate="yes" xml:space="preserve">
          <source>Starts the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">Запускает данное &lt;code&gt;app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2271caeb4b7d5b3c207dd94c7b7c318ed2188f2" translate="yes" xml:space="preserve">
          <source>Starts the registry as a supervisor process.</source>
          <target state="translated">Запускает реестр как процесс супервайзера.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="a04227ba1319a1fad4347603729d051498bac906" translate="yes" xml:space="preserve">
          <source>Static code analysis</source>
          <target state="translated">Статический анализ кода</target>
        </trans-unit>
        <trans-unit id="cdde4f20ba31a24db2cc7ae71135c8353631907b" translate="yes" xml:space="preserve">
          <source>Steps</source>
          <target state="translated">Steps</target>
        </trans-unit>
        <trans-unit id="a62a6d902db47855d8f77112868e3787eabbca53" translate="yes" xml:space="preserve">
          <source>Stopping an application with a callback module has three steps:</source>
          <target state="translated">Остановка приложения с помощью модуля обратного вызова состоит из трех этапов:</target>
        </trans-unit>
        <trans-unit id="3753ad0cdb9c49b6498a88fe4f4514a2b9b36ece" translate="yes" xml:space="preserve">
          <source>Stopping an application without a callback module is defined, but except for some system tracing, it is in practice a no-op.</source>
          <target state="translated">Остановка приложения без модуля обратного вызова определена,но за исключением некоторой системной трассировки,на практике она не работает.</target>
        </trans-unit>
        <trans-unit id="d5b2d506e52eb47a1075dbad242127c01e521df7" translate="yes" xml:space="preserve">
          <source>Stopping applications</source>
          <target state="translated">Остановка приложений</target>
        </trans-unit>
        <trans-unit id="16d9ee2c7e28df63e19079e90e7824e30d92fc9f" translate="yes" xml:space="preserve">
          <source>Stops a child process started via &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Останавливает дочерний процесс, запущенный через &lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d836dc29fd66efd06619857a7f3fbdbb2570615" translate="yes" xml:space="preserve">
          <source>Stops the IO device and returns the remaining input/output buffers.</source>
          <target state="translated">Останавливает устройство ввода-вывода и возвращает оставшиеся буферы ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="420cba62897b963528b14026eceb60569ceedeae" translate="yes" xml:space="preserve">
          <source>Stops the execution of the calling process with the given reason.</source>
          <target state="translated">Останавливает выполнение вызывающего процесса по заданной причине.</target>
        </trans-unit>
        <trans-unit id="1b87ddfd2f0a1efe1c63c07d6457515d241e5a11" translate="yes" xml:space="preserve">
          <source>Stops the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">Останавливает данное &lt;code&gt;app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5206ef2f4946342c59fa2df527c82ea74eb890" translate="yes" xml:space="preserve">
          <source>Stores a compilation option.</source>
          <target state="translated">Хранит опцию компиляции.</target>
        </trans-unit>
        <trans-unit id="5e57817ff2a6b8e48e8d562b55890d766e0aa874" translate="yes" xml:space="preserve">
          <source>Stores all given compilation options.</source>
          <target state="translated">Хранит все заданные опции компиляции.</target>
        </trans-unit>
        <trans-unit id="7a8ca646fdc158d3d531a0223dadbec6991917ca" translate="yes" xml:space="preserve">
          <source>Stores registry metadata.</source>
          <target state="translated">Хранит метаданные реестра.</target>
        </trans-unit>
        <trans-unit id="486a63f10cb978abccfbd8ecf134b1efae0f41f9" translate="yes" xml:space="preserve">
          <source>Stores the given &lt;code&gt;key&lt;/code&gt;-&lt;code&gt;value&lt;/code&gt; pair in the process dictionary.</source>
          <target state="translated">Магазины данный &lt;code&gt;key&lt;/code&gt; - &lt;code&gt;value&lt;/code&gt; пары в словаре процесса.</target>
        </trans-unit>
        <trans-unit id="3a40588dab874cb0f15e4d524b5977f1cc44faf9" translate="yes" xml:space="preserve">
          <source>Storing information with attributes</source>
          <target state="translated">Хранение информации с атрибутами</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="74985da267c6803b262f117de72af2d02e48029f" translate="yes" xml:space="preserve">
          <source>Streams</source>
          <target state="translated">Streams</target>
        </trans-unit>
        <trans-unit id="32937312f1205a985f371273166b0a08620a94b4" translate="yes" xml:space="preserve">
          <source>Streams are composable, lazy enumerables (for an introduction on enumerables, see the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is a stream:</source>
          <target state="translated">Потоки - это компонуемые ленивые перечисления (введение в перечисления см. В модуле &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; ). Любой перечислимый объект, который генерирует элементы один за другим во время перечисления, называется потоком. Например, &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; Эликсира - это поток:</target>
        </trans-unit>
        <trans-unit id="9c5426850f84369e2b7dbe33f323ee50c006981f" translate="yes" xml:space="preserve">
          <source>Streams are composable, lazy enumerables (for an introduction on enumerables, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is a stream:</source>
          <target state="translated">Потоки - это составные ленивые перечисления (введение в перечисления см. В модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; ). Любой перечислимый объект, который генерирует элементы один за другим во время перечисления, называется потоком. Например, &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; Эликсира - это поток:</target>
        </trans-unit>
        <trans-unit id="4d05b9a39a36694d426084ba23a5f9e69c3f3e62" translate="yes" xml:space="preserve">
          <source>Streams are lazy, composable enumerables.</source>
          <target state="translated">Потоки-ленивые,композитные бесчисленные.</target>
        </trans-unit>
        <trans-unit id="712809970aa25b88c8417d13c741aaaed8cdc5c7" translate="yes" xml:space="preserve">
          <source>Streams the enumerable in chunks, containing &lt;code&gt;count&lt;/code&gt; elements each, where each new chunk starts &lt;code&gt;step&lt;/code&gt; elements into the enumerable.</source>
          <target state="translated">Выполняет потоковую передачу перечислимого в фрагменты, каждый из которых содержит &lt;code&gt;count&lt;/code&gt; элементы, причем каждый новый фрагмент запускает элементы &lt;code&gt;step&lt;/code&gt; в перечисляемом.</target>
        </trans-unit>
        <trans-unit id="c3766632b158ff372c632bd5e459fa938b757447" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;and&quot; operator.</source>
          <target state="translated">Строго логический оператор &quot;и&quot;.</target>
        </trans-unit>
        <trans-unit id="a5a9a0e0f16ce8cccca691f5a88a387331ed3a60" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;not&quot; operator.</source>
          <target state="translated">Строго логический оператор &quot;не&quot;.</target>
        </trans-unit>
        <trans-unit id="307c1d3f27f897db66810f52b5d24b80983a2d95" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;or&quot; operator.</source>
          <target state="translated">Строго логический оператор &quot;или&quot;.</target>
        </trans-unit>
        <trans-unit id="1134f2ebe54abc3c1e5e36f6931e4a7294126534" translate="yes" xml:space="preserve">
          <source>Strictly equal to operator.</source>
          <target state="translated">Строго соответствует оператору.</target>
        </trans-unit>
        <trans-unit id="30cf2e475f38e7c13632c86b9147ef4d7d19d6a3" translate="yes" xml:space="preserve">
          <source>Strictly not equal to operator.</source>
          <target state="translated">Строго не равна оператору.</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="642ccf43dc1d6fbbbae9dcb9d0b32837c15cd30f" translate="yes" xml:space="preserve">
          <source>String (binary) concatenation uses the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator but charlists use the lists concatenation operator &lt;code&gt;++&lt;/code&gt;:</source>
          <target state="translated">Конкатенация строк (двоичная) использует оператор &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , а списки символов используют оператор конкатенации списков &lt;code&gt;++&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7b412c0d58e5e7ad2aecfd7b3150626c2d9ea814" translate="yes" xml:space="preserve">
          <source>String (binary) concatenation uses the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator but charlists, being lists, use the list concatenation operator &lt;code&gt;++&lt;/code&gt;:</source>
          <target state="translated">Конкатенация строк (двоичная) использует оператор &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , но списки символов, будучи списками, используют оператор конкатенации списков &lt;code&gt;++&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83229f3ff8f7ea7a043154af3b38efd4909e3589" translate="yes" xml:space="preserve">
          <source>String and binary operations</source>
          <target state="translated">Строковые и двоичные операции</target>
        </trans-unit>
        <trans-unit id="bd850015d8baaaed30b4f3d5a9c9529f30dc8015" translate="yes" xml:space="preserve">
          <source>String concatenation is done with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Конкатенация строк выполняется с помощью &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d89992e6bf13c0c402335f758d9be996e2e01c23" translate="yes" xml:space="preserve">
          <source>String.Chars</source>
          <target state="translated">String.Chars</target>
        </trans-unit>
        <trans-unit id="34301512f5868a1de9803c4f3410c31c2c126816" translate="yes" xml:space="preserve">
          <source>String.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Протокол&lt;/small&gt; String.Chars&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1c5c736c504b053727fd9efef0379fa8c75be99f" translate="yes" xml:space="preserve">
          <source>String.Chars.t (0)</source>
          <target state="translated">String.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="53d34343625f2871cea1abc24cdb3f39da79c324" translate="yes" xml:space="preserve">
          <source>String.Chars.to_string (1)</source>
          <target state="translated">String.Chars.to_string (1)</target>
        </trans-unit>
        <trans-unit id="71b9f81312a912f581ac74b4c41e1dabf6deb89c" translate="yes" xml:space="preserve">
          <source>StringIO</source>
          <target state="translated">StringIO</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="4e070c4fd19657d532bad6b50d3c0bc3ada85afa" translate="yes" xml:space="preserve">
          <source>Strings are always represented as themselves in the AST.</source>
          <target state="translated">Строки всегда представлены как сами по себе в AST.</target>
        </trans-unit>
        <trans-unit id="9189545cce6b22534b68d2a8c78d66e2e097a67a" translate="yes" xml:space="preserve">
          <source>Strings can have line breaks in them. You can introduce them using escape sequences:</source>
          <target state="translated">В строках могут быть перерывы в строках.Вы можете ввести их с помощью эвакуационных последовательностей:</target>
        </trans-unit>
        <trans-unit id="8d0eb9bbaa9223ef9b42ad1496081c266e99b1dd" translate="yes" xml:space="preserve">
          <source>Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the &lt;code&gt;#{}&lt;/code&gt; syntax:</source>
          <target state="translated">Строки в Elixir также поддерживают интерполяцию. Это позволяет вам поместить какое-либо значение в середину строки, используя синтаксис &lt;code&gt;#{}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ca18cb73f9036b31075a45d8b8797d8a39e4a864" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are UTF-8 encoded binaries.</source>
          <target state="translated">Строки в эликсире являются двоичными файлами в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="04815a1192ce7e3ea77d99b96198de07fc1d57e2" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as &lt;code&gt;&quot;hello&quot;&lt;/code&gt; and &lt;code&gt;&quot;h&amp;eacute;ll&amp;ograve;&quot;&lt;/code&gt;.</source>
          <target state="translated">Строки в Elixir - это последовательность символов Unicode, обычно записываемых между строками в двойных кавычках, таких как &lt;code&gt;&quot;hello&quot;&lt;/code&gt; и &lt;code&gt;&quot;h&amp;eacute;ll&amp;ograve;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca38f6c1fbddaf28313e82e08e3bdd20ed71adb5" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are delimited by double quotes, and they are encoded in UTF-8:</source>
          <target state="translated">Строки в эликсире разделены двойными кавычками,и они закодированы в UTF-8:</target>
        </trans-unit>
        <trans-unit id="956ce6bc8b8fc3893f30f39eeac47f3c2031a779" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are represented internally by binaries which are sequences of bytes:</source>
          <target state="translated">Строки в эликсире внутренне представлены двоичными файлами,которые являются последовательностями байтов:</target>
        </trans-unit>
        <trans-unit id="06c215a72c89446e5cfff5f5e5552a7f7dfcebc0" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are represented internally by contiguous sequences of bytes known as binaries:</source>
          <target state="translated">Строки в эликсире внутренне представлены непрерывными последовательностями байтов,известными как двоичные файлы:</target>
        </trans-unit>
        <trans-unit id="949492a01a0acbead6a5b64c79b3a5208d1fa196" translate="yes" xml:space="preserve">
          <source>Strings, char lists, and word lists sigils</source>
          <target state="translated">Строки,знаки отличия и знаки слов.</target>
        </trans-unit>
        <trans-unit id="b1b0c17e89281d54da848221c3d7d64fce387af1" translate="yes" xml:space="preserve">
          <source>Strings, charlists, atoms and sigils are kept as is. No character is automatically escaped or unescaped. The choice of delimiter is also respected from the input</source>
          <target state="translated">Струны,знаки отличия,атомы и знаки хранятся как есть.Ни один символ не исчезает автоматически или не исчезает.Выбор разделителя также уважается из входных данных.</target>
        </trans-unit>
        <trans-unit id="5f59a80be2040336e52379484730e3abaf9c3bdf" translate="yes" xml:space="preserve">
          <source>Strips a beam file for a release.</source>
          <target state="translated">Файл с лучом для релиза.</target>
        </trans-unit>
        <trans-unit id="a4ab848fe5c4b2e5f638f279c7f13cc481bac6da" translate="yes" xml:space="preserve">
          <source>Struct</source>
          <target state="translated">Struct</target>
        </trans-unit>
        <trans-unit id="21e310386df8cb3491068257a8769c52dadb5d7d" translate="yes" xml:space="preserve">
          <source>Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, &lt;code&gt;10 + 11&lt;/code&gt; is evaluated at compile-time and the age field is stored with value &lt;code&gt;21&lt;/code&gt;:</source>
          <target state="translated">Поля структуры оцениваются во время компиляции, что позволяет им быть динамическими. В приведенном ниже примере &lt;code&gt;10 + 11&lt;/code&gt; оценивается во время компиляции, а поле возраста сохраняется со значением &lt;code&gt;21&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66b9bcf6fa135918752a0ac296373b9fc45c7435" translate="yes" xml:space="preserve">
          <source>Structs</source>
          <target state="translated">Structs</target>
        </trans-unit>
        <trans-unit id="e48092358ab469205143fa60ac35c7155aef2e05" translate="yes" xml:space="preserve">
          <source>Structs (see below)</source>
          <target state="translated">Структуры (см.ниже)</target>
        </trans-unit>
        <trans-unit id="1fa66ef16d007913d84111c1caa8d36201a759a2" translate="yes" xml:space="preserve">
          <source>Structs alongside protocols provide one of the most important features for Elixir developers: data polymorphism. That&amp;rsquo;s what we will explore in the next chapter.</source>
          <target state="translated">Структуры наряду с протоколами обеспечивают одну из самых важных функций для разработчиков Elixir: полиморфизм данных. Это то, что мы исследуем в следующей главе.</target>
        </trans-unit>
        <trans-unit id="906ed9113d865df8c36d98027adb8b4c438462a1" translate="yes" xml:space="preserve">
          <source>Structs also allow pattern matching on the struct name:</source>
          <target state="translated">Структуры также допускают совпадение шаблонов по имени структуры:</target>
        </trans-unit>
        <trans-unit id="403a81b60bd1b9d08b2aba9ce6f1c1e83a0ae9bd" translate="yes" xml:space="preserve">
          <source>Structs are bare maps underneath</source>
          <target state="translated">Струны-голые карты внизу</target>
        </trans-unit>
        <trans-unit id="ef8a5b2279bd1fda0dd17b3e4b37d53f5cabffc3" translate="yes" xml:space="preserve">
          <source>Structs are extensions built on top of maps that provide compile-time checks and default values.</source>
          <target state="translated">Структуры-это расширения,построенные поверх карт,которые обеспечивают проверку времени компиляции и значений по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b2f574270028afc6da451166304e7163b0e325d1" translate="yes" xml:space="preserve">
          <source>Structs are usually defined with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;Kernel.defstruct/1&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Структуры обычно определяются с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;Kernel.defstruct/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="57a5690039bdfaa887691c076af282fbfcd1e385" translate="yes" xml:space="preserve">
          <source>Structs are usually defined with the &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;Kernel.defstruct/1&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Структуры обычно определяются с помощью &lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;Kernel.defstruct/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="abdab30b78e5e45d65ba3227273c7089180b1f6f" translate="yes" xml:space="preserve">
          <source>Structs built on the map syntax by passing the struct name between &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;{&lt;/code&gt;. For example, &lt;code&gt;%User{...}&lt;/code&gt;.</source>
          <target state="translated">Структуры, построенные на синтаксисе карты путем передачи имени структуры между &lt;code&gt;%&lt;/code&gt; и &lt;code&gt;{&lt;/code&gt; . Например, &lt;code&gt;%User{...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ce56958d9176de03025283b3099e3721e59a8eb" translate="yes" xml:space="preserve">
          <source>Structs can also be used in pattern matching, both for matching on the value of specific keys as well as for ensuring that the matching value is a struct of the same type as the matched value.</source>
          <target state="translated">Структуры также могут быть использованы при выравнивании деталей,как для выравнивания по значению конкретных ключей,так и для обеспечения того,что выравниваемое значение является структурой того же типа,что и выравниваемое значение.</target>
        </trans-unit>
        <trans-unit id="627a64dfd0ce65d3cdca0e3adc12f995862ee10f" translate="yes" xml:space="preserve">
          <source>Structs provide &lt;em&gt;compile-time&lt;/em&gt; guarantees that only the fields (and &lt;em&gt;all&lt;/em&gt; of them) defined through &lt;code&gt;defstruct&lt;/code&gt; will be allowed to exist in a struct:</source>
          <target state="translated">Структуры предоставляют гарантии &lt;em&gt;времени компиляции,&lt;/em&gt; что только поля (и &lt;em&gt;все&lt;/em&gt; они), определенные с помощью &lt;code&gt;defstruct&lt;/code&gt; , будут допущены к существованию в структуре:</target>
        </trans-unit>
        <trans-unit id="9a421e5ee413973974fb1a4739a9e94164f81b8a" translate="yes" xml:space="preserve">
          <source>Structs take the name of the module they&amp;rsquo;re defined in. In the example above, we defined a struct named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Структуры принимают имя модуля, в котором они определены. В приведенном выше примере мы определили структуру с именем &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bcfdb993ad07d9903f21c6cf1477e9cf60ca26b" translate="yes" xml:space="preserve">
          <source>Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the &lt;code&gt;@opaque&lt;/code&gt; attribute. Structs whose internal structure is public should use &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">Структуры, внутренняя структура которых является частной для локального модуля (сопоставление шаблонов с ними или прямой доступ к их полям не должны быть разрешены), должны использовать атрибут &lt;code&gt;@opaque&lt;/code&gt; . Структуры, внутренняя структура которых является общедоступной, должны использовать &lt;code&gt;@type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fdac6921d89e2c5b2bed6c0d9d18041f744d060" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;code&gt;datetime2&lt;/code&gt; from &lt;code&gt;datetime1&lt;/code&gt;.</source>
          <target state="translated">Вычитает &lt;code&gt;datetime2&lt;/code&gt; из &lt;code&gt;datetime1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01f386a46810771df7fb30922411804e63bbb211" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;code&gt;naive_datetime2&lt;/code&gt; from &lt;code&gt;naive_datetime1&lt;/code&gt;.</source>
          <target state="translated">Вычитает &lt;code&gt;naive_datetime2&lt;/code&gt; от &lt;code&gt;naive_datetime1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14da215035d163f8d2e9ac00ee5de927b8ce5918" translate="yes" xml:space="preserve">
          <source>Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; with the previous accumulator (the initial value being the result returned by &lt;code&gt;start_fun&lt;/code&gt;) and it must return a tuple containing a list of elements to be emitted and the next accumulator. The enumeration finishes if it returns &lt;code&gt;{:halt, acc}&lt;/code&gt;.</source>
          <target state="translated">Последовательные значения генерируются путем вызова &lt;code&gt;next_fun&lt;/code&gt; с предыдущим аккумулятором (начальное значение является результатом, возвращаемым &lt;code&gt;start_fun&lt;/code&gt; ), и он должен возвращать кортеж, содержащий список элементов, которые должны быть сгенерированы, и следующий аккумулятор. Перечисление завершается, если возвращается &lt;code&gt;{:halt, acc}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="522311cdcaf7b3267814d3b09a19e47dea3c8a0f" translate="yes" xml:space="preserve">
          <source>Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Последовательные значения генерируются путем вызова &lt;code&gt;next_fun&lt;/code&gt; с предыдущим аккумулятором, и он должен возвращать кортеж с текущим значением и следующим аккумулятором. Перечисление завершается, если возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0597f1e250ca1cd4f549ebe479656572bafdd1" translate="yes" xml:space="preserve">
          <source>Such a guard would look like this:</source>
          <target state="translated">Такой охранник выглядел бы вот так:</target>
        </trans-unit>
        <trans-unit id="53658e37fb70788364f35c3ef3e5d3ef21ca3b29" translate="yes" xml:space="preserve">
          <source>Such function calls are efficient memory-wise no matter the size of the range. The implementation of the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.</source>
          <target state="translated">Такие вызовы функций эффективны с точки зрения памяти независимо от размера диапазона. Реализация протокола &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; использует логику, основанную исключительно на конечных точках, и не материализует весь список целых чисел.</target>
        </trans-unit>
        <trans-unit id="966ec8ae3fe9132ccbf00f8e3b57331123098390" translate="yes" xml:space="preserve">
          <source>Such function calls are efficient memory-wise no matter the size of the range. The implementation of the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.</source>
          <target state="translated">Такие вызовы функций эффективны с точки зрения памяти независимо от размера диапазона. Реализация протокола &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; использует логику, основанную исключительно на конечных точках, и не материализует весь список целых чисел.</target>
        </trans-unit>
        <trans-unit id="413448cc1d1e59d4180a2c1df46d6b20fc8b2386" translate="yes" xml:space="preserve">
          <source>Such is also useful when using update functions, allowing us to introduce values as we traverse the data structure for updates:</source>
          <target state="translated">Это также полезно при использовании функций обновления,позволяя нам вводить значения по мере того,как мы пересекаем структуру данных для обновления:</target>
        </trans-unit>
        <trans-unit id="f0c8c931aa883a1710a5641257d627e0b793426c" translate="yes" xml:space="preserve">
          <source>Such is possible for duplicate registries though:</source>
          <target state="translated">Однако это возможно для дублирующих реестров:</target>
        </trans-unit>
        <trans-unit id="af0451134f60a76766f000f3339e06b3c7fb942b" translate="yes" xml:space="preserve">
          <source>Suffix matches (&lt;code&gt;hello &amp;lt;&amp;gt; &quot; world&quot;&lt;/code&gt;) are not valid patterns.</source>
          <target state="translated">Совпадения суффиксов ( &lt;code&gt;hello &amp;lt;&amp;gt; &quot; world&quot;&lt;/code&gt; ) не являются допустимыми шаблонами.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9413f829dc8a9eeac79634a8fecd1c1711b00407" translate="yes" xml:space="preserve">
          <source>Summing up</source>
          <target state="translated">Подведение итогов</target>
        </trans-unit>
        <trans-unit id="008681d0cf389abc8327426047cec2a8b18317d8" translate="yes" xml:space="preserve">
          <source>Supervised tasks</source>
          <target state="translated">Контролируемые задачи</target>
        </trans-unit>
        <trans-unit id="908fa8f422bcf3bb9ccc6611b5129caf568648d9" translate="yes" xml:space="preserve">
          <source>Supervision trees</source>
          <target state="translated">Деревья-наблюдатели</target>
        </trans-unit>
        <trans-unit id="2cd4fa195ed5b220930149c31cc72fbb131921db" translate="yes" xml:space="preserve">
          <source>Supervisor</source>
          <target state="translated">Supervisor</target>
        </trans-unit>
        <trans-unit id="e1ea02d7a77e7dff85d3adb88e64fc729ba83f91" translate="yes" xml:space="preserve">
          <source>Supervisor &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Поведение&lt;/small&gt; руководителя&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d69abd18d455510b99f3ff0e898ca02a3c32b696" translate="yes" xml:space="preserve">
          <source>Supervisor and Application</source>
          <target state="translated">администратор и приложение</target>
        </trans-unit>
        <trans-unit id="def06f454fe2aafd60e9bf9113ffca345eac503e" translate="yes" xml:space="preserve">
          <source>Supervisor and GenServers</source>
          <target state="translated">администратор и серверы GenServers</target>
        </trans-unit>
        <trans-unit id="12010eabcaf19b4380edc62ef8ef7afae10e6caa" translate="yes" xml:space="preserve">
          <source>Supervisor and worker options</source>
          <target state="translated">Возможности руководителя и работников</target>
        </trans-unit>
        <trans-unit id="ef948fc60b8d6995f73a05206917fcdf6cd81c08" translate="yes" xml:space="preserve">
          <source>Supervisor.Spec</source>
          <target state="translated">Supervisor.Spec</target>
        </trans-unit>
        <trans-unit id="fb7cc714ff3123e658f82813b47d9835dd16af4d" translate="yes" xml:space="preserve">
          <source>Supervisors support different strategies; in the example above, we have chosen &lt;code&gt;:one_for_one&lt;/code&gt;. Furthermore, each supervisor can have many workers and/or supervisors as children, with each one having its own configuration (as outlined in the &quot;Child specification&quot; section).</source>
          <target state="translated">Супервизоры поддерживают разные стратегии; в приведенном выше примере мы выбрали &lt;code&gt;:one_for_one&lt;/code&gt; . Кроме того, у каждого супервизора может быть много рабочих и / или супервизоров в качестве потомков, каждый из которых имеет свою собственную конфигурацию (как указано в разделе &amp;laquo;Дочерние спецификации&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="0578994f188280cb99013a5c58ec4c81802bfe88" translate="yes" xml:space="preserve">
          <source>Supervisors support different supervision strategies (through the &lt;code&gt;:strategy&lt;/code&gt; option, as seen above):</source>
          <target state="translated">Супервизоры поддерживают различные стратегии супервизии (с помощью опции &lt;code&gt;:strategy&lt;/code&gt; , как показано выше):</target>
        </trans-unit>
        <trans-unit id="f32d5a3b17e614297417cc279a7ec1cd02274d65" translate="yes" xml:space="preserve">
          <source>Support</source>
          <target state="translated">Support</target>
        </trans-unit>
        <trans-unit id="e6e1e0cd205858fc9432c841e89bbd6483ce3fe6" translate="yes" xml:space="preserve">
          <source>Support for making &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defp/2&quot;&gt;private functions&lt;/a&gt; overridable</source>
          <target state="translated">Поддержка переопределения &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defp/2&quot;&gt;частных функций&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4eab47f32a482fa6a57e7d78931eebd65984bbe" translate="yes" xml:space="preserve">
          <source>Support for making private functions overridable</source>
          <target state="translated">Поддержка для того,чтобы сделать частные функции переопределяемыми</target>
        </trans-unit>
        <trans-unit id="6afec07b7fa976af6cf8797ee913469e9babea8a" translate="yes" xml:space="preserve">
          <source>Supported Erlang/OTP versions</source>
          <target state="translated">Поддерживаемые версии Erlang/OTP</target>
        </trans-unit>
        <trans-unit id="cc98180ca761a9afbf85fc26a48b02b6e25dbae6" translate="yes" xml:space="preserve">
          <source>Supported ID values</source>
          <target state="translated">Поддерживаемые значения ID</target>
        </trans-unit>
        <trans-unit id="59b7fd869e912d97d97078bf118935bf508cd7dc" translate="yes" xml:space="preserve">
          <source>Supported module values</source>
          <target state="translated">Поддерживаемые значения модулей</target>
        </trans-unit>
        <trans-unit id="4ce9ab2c76a64f3bead6b697086605679c05ba0b" translate="yes" xml:space="preserve">
          <source>Supported restart values</source>
          <target state="translated">Поддерживаемые значения перезапуска</target>
        </trans-unit>
        <trans-unit id="4754143afdbe77546c223d10dd545bf29beec5ec" translate="yes" xml:space="preserve">
          <source>Supported shutdown values</source>
          <target state="translated">Поддерживаемые значения выключения</target>
        </trans-unit>
        <trans-unit id="556737ead8feb164936eb5c9d04fdbaa68615120" translate="yes" xml:space="preserve">
          <source>Supported strategies</source>
          <target state="translated">Поддерживаемые стратегии</target>
        </trans-unit>
        <trans-unit id="011f076c3d846af2a7296431ecd45f9d0d9ceba4" translate="yes" xml:space="preserve">
          <source>Supported worker values</source>
          <target state="translated">Ценности поддерживаемых работников</target>
        </trans-unit>
        <trans-unit id="b1ffd261b167462587f7afeaf76db355c7359f62" translate="yes" xml:space="preserve">
          <source>Supporting documents</source>
          <target state="translated">Сопроводительные документы</target>
        </trans-unit>
        <trans-unit id="5074c54fe3d2dada9edf83c0782274a9de618a17" translate="yes" xml:space="preserve">
          <source>Supports multiple backends which are automatically supervised when plugged into &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поддерживает несколько бэкэндов, которые автоматически контролируются при подключении к &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63b71cb9682231a38f6cb8bfe3190bb22abb9ee8" translate="yes" xml:space="preserve">
          <source>Switch definitions</source>
          <target state="translated">Переключить определения</target>
        </trans-unit>
        <trans-unit id="3b07b3e7fad246aad851785b8640c09bc790a0c6" translate="yes" xml:space="preserve">
          <source>Switches can be specified via one of two options:</source>
          <target state="translated">Переключатели могут быть заданы с помощью одного из двух вариантов:</target>
        </trans-unit>
        <trans-unit id="10f820ab2456db02149e31f2047f0b2fc4844076" translate="yes" xml:space="preserve">
          <source>Switches can be specified with modifiers, which change how they behave. The following modifiers are supported:</source>
          <target state="translated">Переключатели могут быть заданы с помощью модификаторов,которые изменяют их поведение.Поддерживаются следующие модификаторы:</target>
        </trans-unit>
        <trans-unit id="76095f9f5c83633412d257a75ee9b301147d2861" translate="yes" xml:space="preserve">
          <source>Switches followed by a value will be assigned the value, as a string. Switches without an argument will be set automatically to &lt;code&gt;true&lt;/code&gt;. Since we cannot assert the type of the switch value, it is preferred to use the &lt;code&gt;:strict&lt;/code&gt; option that accepts only known switches and always verify their types.</source>
          <target state="translated">Переключателям, за которыми следует значение, будет присвоено значение в виде строки. Для переключателей без аргументов будет автоматически установлено значение &lt;code&gt;true&lt;/code&gt; . Поскольку мы не можем утверждать тип значения переключателя, рекомендуется использовать параметр &lt;code&gt;:strict&lt;/code&gt; , который принимает только известные переключатели и всегда проверяет их типы.</target>
        </trans-unit>
        <trans-unit id="5845d5880bc5d8b451e5a4dd803aa622305d25f1" translate="yes" xml:space="preserve">
          <source>Switches parsed by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt; may take zero or one arguments.</source>
          <target state="translated">Переключатели, анализируемые &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; ,&lt;/a&gt; могут принимать ноль или один аргумент.</target>
        </trans-unit>
        <trans-unit id="3687a859d3cbb75ed3b6669b03cb32119eb5e843" translate="yes" xml:space="preserve">
          <source>Synchronously stops the agent with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">Синхронно останавливает агент по указанной &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83e327b0ee0a0791c10736b6ce6e0977e644efa8" translate="yes" xml:space="preserve">
          <source>Synchronously stops the given supervisor with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">Синхронно останавливает данного супервизора по указанной &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20daca0170b9cf17db723aa618e07ac24ddb1612" translate="yes" xml:space="preserve">
          <source>Synchronously stops the server with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">Синхронно останавливает сервер по указанной &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">Синтаксический сахар</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="8c15a6de8bd57bfcd07b3aef8fb9a4bc8f26c05e" translate="yes" xml:space="preserve">
          <source>Syntax reference</source>
          <target state="translated">Ссылка на синтаксис</target>
        </trans-unit>
        <trans-unit id="de4af2ff6c0bd31526ce7f5f8ca08783d0cc5ed7" translate="yes" xml:space="preserve">
          <source>SyntaxError</source>
          <target state="translated">SyntaxError</target>
        </trans-unit>
        <trans-unit id="62e61480537cef04396517bf21f00631d5916b00" translate="yes" xml:space="preserve">
          <source>SyntaxError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">SyntaxError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bc0792d8dc81e8aa30b987246a5ce97c40cd6833" translate="yes" xml:space="preserve">
          <source>System</source>
          <target state="translated">System</target>
        </trans-unit>
        <trans-unit id="15a3c2ea878a67e7f83b1e5350d3a1c397e6870e" translate="yes" xml:space="preserve">
          <source>System messages such as timer messages and monitoring events</source>
          <target state="translated">Системные сообщения,такие как сообщения таймера и события мониторинга.</target>
        </trans-unit>
        <trans-unit id="629539f2b0b3c31f1b5b674c293fc529369d30a0" translate="yes" xml:space="preserve">
          <source>System modules</source>
          <target state="translated">Модули системы</target>
        </trans-unit>
        <trans-unit id="e1f03c30c4ad532e4c164e6bd797580a623de00e" translate="yes" xml:space="preserve">
          <source>SystemLimitError</source>
          <target state="translated">SystemLimitError</target>
        </trans-unit>
        <trans-unit id="87d2f1faf999bf62e28a61deae6996346ba925b4" translate="yes" xml:space="preserve">
          <source>SystemLimitError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">SystemLimitError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="34fe46e18f0db15e3602c13218d0d43606ec62eb" translate="yes" xml:space="preserve">
          <source>Table of deprecations</source>
          <target state="translated">Таблица депрессий</target>
        </trans-unit>
        <trans-unit id="848eed0fbd5429f556b2982dec3ea87136e33e44" translate="yes" xml:space="preserve">
          <source>Tags</source>
          <target state="translated">Tags</target>
        </trans-unit>
        <trans-unit id="b6178fb349e0b28eda375aea2c569cd350dc4da1" translate="yes" xml:space="preserve">
          <source>Tags are also very effective when used with case templates (&lt;a href=&quot;exunit.casetemplate&quot;&gt;&lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt;&lt;/a&gt;) allowing callbacks in the case template to customize the test behaviour.</source>
          <target state="translated">Теги также очень эффективны при использовании с шаблонами &lt;a href=&quot;exunit.casetemplate&quot;&gt; &lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt; &lt;/a&gt; ( ExUnit.CaseTemplate ), позволяя использовать обратные вызовы в шаблоне дела для настройки поведения теста.</target>
        </trans-unit>
        <trans-unit id="1e98eca58b343bf9eef58db2b4d0749342e87444" translate="yes" xml:space="preserve">
          <source>Tags are also very effective when used with case templates (&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaseTemplate.html&quot;&gt;&lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt;&lt;/a&gt;) allowing callbacks in the case template to customize the test behaviour.</source>
          <target state="translated">Теги также очень эффективны при использовании с шаблонами &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaseTemplate.html&quot;&gt; &lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt; &lt;/a&gt; ( ExUnit.CaseTemplate ), позволяя выполнять обратные вызовы в шаблоне кейсов для настройки поведения теста.</target>
        </trans-unit>
        <trans-unit id="fc249ccb61119dc450a78be8a81ac2c8c0e49629" translate="yes" xml:space="preserve">
          <source>Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via &lt;a href=&quot;exunit#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Теги также могут использоваться для идентификации конкретных тестов, которые затем могут быть включены или исключены с помощью фильтров. Наиболее распространенная функция - исключить выполнение некоторых конкретных тестов, что можно сделать с помощью &lt;a href=&quot;exunit#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fbe21cac3f1b836469722d6aaccceafc7c70d983" translate="yes" xml:space="preserve">
          <source>Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Теги также могут использоваться для идентификации конкретных тестов, которые затем могут быть включены или исключены с помощью фильтров. Наиболее распространенная функция - исключить выполнение некоторых конкретных тестов, что можно сделать с помощью &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8b6e5fd9a74ed5f0c910db816652873cf2d30599" translate="yes" xml:space="preserve">
          <source>Tags in ExUnit are used to annotate tests. Tags can be later used to filter tests. For example, you can avoid running external tests on your machine because they are slow and dependent on other services, while they can still be enabled in your build system.</source>
          <target state="translated">Метки в ExUnit используются для аннотации тестов.Теги могут быть позже использованы для фильтрации тестов.Например,вы можете избежать запуска внешних тестов на вашей машине,поскольку они медленны и зависят от других сервисов,в то время как они все еще могут быть включены в вашей системе сборки.</target>
        </trans-unit>
        <trans-unit id="001aa408e4c6ef94853eea6d535dd0cd3f2d9ecb" translate="yes" xml:space="preserve">
          <source>Take note of the second argument to &lt;code&gt;Macro.var/2&lt;/code&gt;. This is the context being used and will determine hygiene as described in the next section.</source>
          <target state="translated">Обратите внимание на второй аргумент &lt;code&gt;Macro.var/2&lt;/code&gt; . Это используемый контекст, который определяет гигиену, как описано в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="396cb525a863762a0153f155bab5fa14c60b4b53" translate="yes" xml:space="preserve">
          <source>Take such cases as a suggestion that your code should be refactored:</source>
          <target state="translated">Воспринимайте такие случаи как предложение обновить свой код:</target>
        </trans-unit>
        <trans-unit id="0ec41530414c8186f413ef6553a9627c2edc74fd" translate="yes" xml:space="preserve">
          <source>Take the following &lt;code&gt;.iex.exs&lt;/code&gt; file:</source>
          <target state="translated">Возьмите следующий файл &lt;code&gt;.iex.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3272b9a706ed0ca47f559e862d6dc2150998b033" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;count&lt;/code&gt; random elements from &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Принимает &lt;code&gt;count&lt;/code&gt; случайных элементов из &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff00a34c033bd6b414639eb45fc22dcd00b26ff3" translate="yes" xml:space="preserve">
          <source>Takes a compiled format and injects the level, timestamp, message, and metadata keyword list and returns a properly formatted string.</source>
          <target state="translated">Принимает скомпилированный формат и инжектирует уровень,метку времени,сообщение и список метаданных ключевых слов,а также возвращает правильно отформатированную строку.</target>
        </trans-unit>
        <trans-unit id="fc0be3a7f7029dd2d434cb9dc499906bd7070ad7" translate="yes" xml:space="preserve">
          <source>Takes a time zone name and a point in time for UTC and returns a &lt;code&gt;time_zone_period&lt;/code&gt; for that point in time.</source>
          <target state="translated">Принимает имя часового пояса и момент времени для UTC и возвращает &lt;code&gt;time_zone_period&lt;/code&gt; для этого момента времени.</target>
        </trans-unit>
        <trans-unit id="108613966b46cb41abd8d09ea8bc76b57d639cc0" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given &lt;code&gt;keys&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; and extracts them into a separate map.</source>
          <target state="translated">Принимает все записи, соответствующие данным &lt;code&gt;keys&lt;/code&gt; на &lt;code&gt;map&lt;/code&gt; и извлекает их в отдельную карту.</target>
        </trans-unit>
        <trans-unit id="a057f41d143426d964dc91f467aeae07be4b8c88" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</source>
          <target state="translated">Принимает все записи,соответствующие заданным клавишам,и извлекает их в отдельный список ключевых слов.</target>
        </trans-unit>
        <trans-unit id="22f2fcc0cd4b387311cd745e5116cafb06152b07" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given keys and returns them in a new keyword list.</source>
          <target state="translated">Принимает все записи,соответствующие заданным клавишам и возвращает их в новый список ключевых слов.</target>
        </trans-unit>
        <trans-unit id="f01e74291caa1b3fb31a76131a0358dad5dd2b3a" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;amount&lt;/code&gt; of elements from the beginning or the end of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Принимает &lt;code&gt;amount&lt;/code&gt; элементов с начала или с конца &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1f6557000f60347445111652f8c88ca3309153" translate="yes" xml:space="preserve">
          <source>Takes an enumerable that enumerates as a list of two-element tuples (e.g., a map or a keyword list) and returns a string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; where keys and values are URL encoded as per &lt;a href=&quot;#encode_www_form/1&quot;&gt;&lt;code&gt;encode_www_form/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Принимает перечислимый объект, который перечисляется как список двухэлементных кортежей (например, карта или список ключевых слов) и возвращает строку в форме &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; где ключи и значения закодированы в URL согласно &lt;a href=&quot;#encode_www_form/1&quot;&gt; &lt;code&gt;encode_www_form/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="faa8eb6bc5f76dd6add111a9e6f96763d7be8a60" translate="yes" xml:space="preserve">
          <source>Takes an enumerable that enumerates as a list of two-element tuples (for instance, a map or a keyword list) and returns a string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; where keys and values are URL encoded as per &lt;a href=&quot;#encode_www_form/1&quot;&gt;&lt;code&gt;encode_www_form/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Принимает перечислимый объект, который перечисляется как список двухэлементных кортежей (например, карта или список ключевых слов) и возвращает строку в форме &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; где ключи и значения закодированы в URL-адресе согласно &lt;a href=&quot;#encode_www_form/1&quot;&gt; &lt;code&gt;encode_www_form/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e45acfd4331b2440feb53de6fbc1560baa366e61" translate="yes" xml:space="preserve">
          <source>Takes an optional &lt;code&gt;character_limit&lt;/code&gt; as a second argument. If &lt;code&gt;character_limit&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, this function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Принимает необязательный &lt;code&gt;character_limit&lt;/code&gt; в качестве второго аргумента. Если &lt;code&gt;character_limit&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; , эта функция вернет &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feadb0c8e9163376cb17aaa5d080783ed49a3087" translate="yes" xml:space="preserve">
          <source>Takes an optional &lt;code&gt;limit&lt;/code&gt; as a second argument. &lt;a href=&quot;#ascii_printable?/2&quot;&gt;&lt;code&gt;ascii_printable?/2&lt;/code&gt;&lt;/a&gt; only checks the printability of the list up to the &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">Принимает необязательный &lt;code&gt;limit&lt;/code&gt; в качестве второго аргумента. &lt;a href=&quot;#ascii_printable?/2&quot;&gt; &lt;code&gt;ascii_printable?/2&lt;/code&gt; &lt;/a&gt; проверяет возможность печати списка только до &lt;code&gt;limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b31890ea4f4df85c9832a1da5e1e6d04b9bbfbd0" translate="yes" xml:space="preserve">
          <source>Takes changes such as summer time/DST into account. This means that adding time can cause the wall time to &quot;go backwards&quot; during &quot;fall back&quot; during autumn. Adding just a few seconds to a datetime just before &quot;spring forward&quot; can cause wall time to increase by more than an hour.</source>
          <target state="translated">Принимает во внимание такие изменения,как летнее время/DST.Это означает,что добавление времени может привести к тому,что время в стене будет &quot;идти назад&quot; во время &quot;осени&quot;.Добавление всего лишь нескольких секунд к дате непосредственно перед &quot;весной вперед&quot; может привести к увеличению настенного времени более чем на час.</target>
        </trans-unit>
        <trans-unit id="fae8e01301c7e0feb68a23236a2c9b3567e8ae34" translate="yes" xml:space="preserve">
          <source>Takes the elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt; while &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">Принимает элементы с начала &lt;code&gt;enumerable&lt;/code&gt; а &lt;code&gt;fun&lt;/code&gt; возвращает истинное значение.</target>
        </trans-unit>
        <trans-unit id="c5464b7fb8fc4c108c9bf24e8c373a4e9e4044e0" translate="yes" xml:space="preserve">
          <source>Takes the maximum width and a document to print as its arguments and returns an IO data representation of the best layout for the document to fit in the given width.</source>
          <target state="translated">Берет максимальную ширину и документ для печати в качестве аргументов и возвращает IO-данные представления лучшего макета для документа,чтобы уместиться в заданной ширине.</target>
        </trans-unit>
        <trans-unit id="8282e151892442f9f2cf52b76a916f132d30c0f4" translate="yes" xml:space="preserve">
          <source>Target ABI (for example, musl or gnu)</source>
          <target state="translated">Цель ПВБ (например,мускул или гну)</target>
        </trans-unit>
        <trans-unit id="9af45fd9ac96ee8998b351868ee1becb19e802d4" translate="yes" xml:space="preserve">
          <source>Target architecture (for example, x86_64 or ARM)</source>
          <target state="translated">Целевая архитектура (например,x86_64 или ARM)</target>
        </trans-unit>
        <trans-unit id="8e253f67079c51fc720f2bde4e13e5c23c03b6de" translate="yes" xml:space="preserve">
          <source>Target vendor + operating system (for example, Windows, Linux, or Darwin/macOS)</source>
          <target state="translated">Целевой производитель+операционная система (например,Windows,Linux или Darwin/macOS).</target>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="56913f440f346fedff0613f1a58aff47c8c81efb" translate="yes" xml:space="preserve">
          <source>Task and gen_tcp</source>
          <target state="translated">Задача и gen_tcp</target>
        </trans-unit>
        <trans-unit id="42d489b854c5dff6b39f3ae727392332235bf30a" translate="yes" xml:space="preserve">
          <source>Task supervisor</source>
          <target state="translated">куратор задач</target>
        </trans-unit>
        <trans-unit id="0590ada27ec6762e406a036264c8d3a5f2c7e027" translate="yes" xml:space="preserve">
          <source>Task-specific options</source>
          <target state="translated">Опции для конкретных задач</target>
        </trans-unit>
        <trans-unit id="35a08efc9d440da7708c69812b0507ba330ba97d" translate="yes" xml:space="preserve">
          <source>Task.Supervisor</source>
          <target state="translated">Task.Supervisor</target>
        </trans-unit>
        <trans-unit id="090ec5f560fc50377fcd95e5cda128e91b276e98" translate="yes" xml:space="preserve">
          <source>Tasks</source>
          <target state="translated">Tasks</target>
        </trans-unit>
        <trans-unit id="ba00cfab602d1779b811d576baf5eafe077e7cab" translate="yes" xml:space="preserve">
          <source>Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously:</source>
          <target state="translated">Задачи-это процессы,предназначенные для выполнения одного конкретного действия в течение всей своей жизни,часто с минимальной коммуникацией с другими процессами или вообще без таковой.Наиболее распространенным вариантом использования задач является преобразование последовательного кода в параллельный код путем асинхронного вычисления значения:</target>
        </trans-unit>
        <trans-unit id="8a0db3194d6f9d766302e10355f2237684a84453" translate="yes" xml:space="preserve">
          <source>Tasks are what make Mix extensible.</source>
          <target state="translated">Задачи-это то,что делает Mix расширяемым.</target>
        </trans-unit>
        <trans-unit id="a520f228dee983c80456da705995e99d0baf055b" translate="yes" xml:space="preserve">
          <source>Tasks build on top of the spawn functions to provide better error reports and introspection:</source>
          <target state="translated">Задачи строятся на основе функций порождения,чтобы обеспечить лучшие отчеты об ошибках и самопроверку:</target>
        </trans-unit>
        <trans-unit id="0d54343e18426db24d51d0ad44751f910be12ca3" translate="yes" xml:space="preserve">
          <source>Tasks spawned with &lt;code&gt;async&lt;/code&gt; can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed.</source>
          <target state="translated">Задачи, порожденные с помощью &lt;code&gt;async&lt;/code&gt; , могут ожидаться вызывающим процессом (и только вызывающим), как показано в примере выше. Они реализуются путем создания процесса, который отправляет сообщение вызывающей стороне после выполнения заданного вычисления.</target>
        </trans-unit>
        <trans-unit id="f19715ca7223bd4e0d3fbc34df5b7dcc7380e790" translate="yes" xml:space="preserve">
          <source>Tasks typically depend on the &lt;code&gt;&quot;app.config&quot;&lt;/code&gt; task, when they need to access code from the current project with all apps already configured, or the &quot;app.start&quot; task, when they also need those apps to be already started:</source>
          <target state="translated">Задачи обычно зависят от задачи &lt;code&gt;&quot;app.config&quot;&lt;/code&gt; , когда им нужен доступ к коду из текущего проекта со всеми уже настроенными приложениями, или задачи &amp;laquo;app.start&amp;raquo;, когда им также необходимо, чтобы эти приложения были уже запущены:</target>
        </trans-unit>
        <trans-unit id="0b4b058a048fc58f7cc9589f239b42e939508324" translate="yes" xml:space="preserve">
          <source>Techniques</source>
          <target state="translated">Techniques</target>
        </trans-unit>
        <trans-unit id="f36d34a8fff232dc61a718546ef8daf864665507" translate="yes" xml:space="preserve">
          <source>Tells whether the given process is alive on the local node.</source>
          <target state="translated">Говорит,жив ли данный процесс на локальном узле.</target>
        </trans-unit>
        <trans-unit id="3c899cc5439be26f0cd7b582a42447cf769aca66" translate="yes" xml:space="preserve">
          <source>Temporarily blocks the current process waiting for a task reply.</source>
          <target state="translated">Временно блокирует текущий процесс в ожидании ответа на задание.</target>
        </trans-unit>
        <trans-unit id="d33ebb237e98c8b9d937b2d694b2c125b79ca66f" translate="yes" xml:space="preserve">
          <source>Term ordering</source>
          <target state="translated">Заказ термина</target>
        </trans-unit>
        <trans-unit id="696845220c6e0a0d1e64cd82d61908625e60074a" translate="yes" xml:space="preserve">
          <source>Terminate the top-level supervisor.</source>
          <target state="translated">Прекратить работу начальника высшего звена.</target>
        </trans-unit>
        <trans-unit id="37c2abf54c623c6250b581aced135fc94e351e86" translate="yes" xml:space="preserve">
          <source>Terminates the Erlang runtime system without properly shutting down applications and ports. Please see &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; for a careful shutdown of the system.</source>
          <target state="translated">Завершает работу системы времени выполнения Erlang без надлежащего завершения работы приложений и портов. Пожалуйста, смотрите &lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; для осторожного отключения системы.</target>
        </trans-unit>
        <trans-unit id="3cd2179f3f59774aca5baa2c47c7a727d23960ae" translate="yes" xml:space="preserve">
          <source>Terminates the child with the given &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Завершает дочерний &lt;code&gt;pid&lt;/code&gt; с данным pid .</target>
        </trans-unit>
        <trans-unit id="c4bb07a1089485a5deadcff889ffd042bd8e458f" translate="yes" xml:space="preserve">
          <source>Terminates the given child identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;child_id&lt;/code&gt; данный дочерний элемент, идентифицированный child_id .</target>
        </trans-unit>
        <trans-unit id="a50fe58f5df366a9be1362e929ebd0084a28443a" translate="yes" xml:space="preserve">
          <source>Terminates the given child identified by &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Завершает данный дочерний &lt;code&gt;pid&lt;/code&gt; идентифицированный pid .</target>
        </trans-unit>
        <trans-unit id="a202094d471c445107dcaeee3f888512868cbcd8" translate="yes" xml:space="preserve">
          <source>Test filters and tags</source>
          <target state="translated">Тестовые фильтры и теги</target>
        </trans-unit>
        <trans-unit id="6259e4e6f0c5acd8366ddcebaae6c7f8a418bd4b" translate="yes" xml:space="preserve">
          <source>Test setup with ExUnit callbacks</source>
          <target state="translated">Тестовая настройка с обратными вызовами ExUnit</target>
        </trans-unit>
        <trans-unit id="56c4fd8cce0fae76b0fc19e67eda41b7a30e0a0f" translate="yes" xml:space="preserve">
          <source>Testing a GenServer</source>
          <target state="translated">Тестирование сервера GenServer</target>
        </trans-unit>
        <trans-unit id="788b3affdeae419dc740b3f8cbcd405e20e4cc4b" translate="yes" xml:space="preserve">
          <source>Testing a GenServer is not much different from testing an agent. We will spawn the server on a setup callback and use it throughout our tests. Create a file at &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; with the following:</source>
          <target state="translated">Тестирование GenServer мало чем отличается от тестирования агента. Мы создадим сервер с помощью обратного вызова установки и будем использовать его во всех наших тестах. Создайте файл в &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; со следующим:</target>
        </trans-unit>
        <trans-unit id="187e41969f8b9137e679aa44737b6ab5557c6441" translate="yes" xml:space="preserve">
          <source>Tests are first excluded, then included, and then skipped (if any left).</source>
          <target state="translated">Тесты сначала исключаются,затем включаются,а затем пропускаются (если они остались).</target>
        </trans-unit>
        <trans-unit id="85b9fcfc0f6fc72610f7a98efec365df258038e3" translate="yes" xml:space="preserve">
          <source>Tests in umbrella projects can be run from the root by specifying the full suite path, including &lt;code&gt;apps/my_app/test&lt;/code&gt;, in which case recursive tests for other child apps will be skipped completely:</source>
          <target state="translated">Тесты в зонтичных проектах можно запускать из корневого &lt;code&gt;apps/my_app/test&lt;/code&gt; указав полный путь к пакету, включая apps / my_app / test , и в этом случае рекурсивные тесты для других дочерних приложений будут полностью пропущены:</target>
        </trans-unit>
        <trans-unit id="c876e9844d9fdc72e6da9216815faacf651f395c" translate="yes" xml:space="preserve">
          <source>Text-based match operator. Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">Оператор сопоставления на основе текста. Соответствует термину &lt;code&gt;left&lt;/code&gt; и регулярному выражению или строке &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="062dbf72aa69df4b2bf2e11e396bf97a679fa018" translate="yes" xml:space="preserve">
          <source>Thankfully, Elixir v1.2 introduced the &lt;code&gt;with&lt;/code&gt; construct, which allows you to simplify code like the above, replacing nested &lt;code&gt;case&lt;/code&gt; calls with a chain of matching clauses. Let&amp;rsquo;s rewrite the &lt;code&gt;serve/1&lt;/code&gt; function to use &lt;code&gt;with&lt;/code&gt;:</source>
          <target state="translated">К счастью, в Elixir v1.2 появилась конструкция &lt;code&gt;with&lt;/code&gt; , которая позволяет упростить код, подобный приведенному выше, заменяя вложенные вызовы &lt;code&gt;case&lt;/code&gt; цепочкой соответствующих предложений. Давайте перепишем функцию &lt;code&gt;serve/1&lt;/code&gt; для использования &lt;code&gt;with&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="01e9b39e30c1a0e15112939ef1fff61fe4a3aa75" translate="yes" xml:space="preserve">
          <source>Thanks to the agent server process, the counter can be safely incremented concurrently.</source>
          <target state="translated">Благодаря серверному процессу агента,счетчик может быть безопасно инкрементирован одновременно.</target>
        </trans-unit>
        <trans-unit id="fb4fefaf1d73585354762c2031b68d75737ffd24" translate="yes" xml:space="preserve">
          <source>That defines a release named &lt;code&gt;foo&lt;/code&gt; with both &lt;code&gt;kv_server&lt;/code&gt; and &lt;code&gt;kv&lt;/code&gt; applications. Their mode is set to &lt;code&gt;:permanent&lt;/code&gt;, which means that, if those applications crash, the whole node terminates. That&amp;rsquo;s reasonable since those applications are essential to our system.</source>
          <target state="translated">Это определяет выпуск с именем &lt;code&gt;foo&lt;/code&gt; с приложениями &lt;code&gt;kv_server&lt;/code&gt; и &lt;code&gt;kv&lt;/code&gt; . Их режим установлен на &lt;code&gt;:permanent&lt;/code&gt; , что означает, что в случае сбоя этих приложений работа всего узла завершается. Это разумно, поскольку эти приложения необходимы для нашей системы.</target>
        </trans-unit>
        <trans-unit id="cdbd4eae22bceef6692b374955bde22d9b7d01d6" translate="yes" xml:space="preserve">
          <source>That defines a release named &lt;code&gt;foo&lt;/code&gt; with both &lt;code&gt;kv_server&lt;/code&gt; and &lt;code&gt;kv&lt;/code&gt; applications. Their mode is set to &lt;code&gt;:permanent&lt;/code&gt;, which means that, if those applications crash, the whole node terminates. That&amp;rsquo;s reasonable since those applications are essential to our system. With the configuration in place, let&amp;rsquo;s give another try at assembling the release:</source>
          <target state="translated">Это определяет выпуск с именем &lt;code&gt;foo&lt;/code&gt; с приложениями &lt;code&gt;kv_server&lt;/code&gt; и &lt;code&gt;kv&lt;/code&gt; . Их режим установлен на &lt;code&gt;:permanent&lt;/code&gt; , что означает, что в случае сбоя этих приложений работа всего узла завершается. Это разумно, поскольку эти приложения необходимы для нашей системы. Имея конфигурацию, давайте еще раз попробуем собрать релиз:</target>
        </trans-unit>
        <trans-unit id="c0b2e0d9fe52f84cc809886b734e22953d615efa" translate="yes" xml:space="preserve">
          <source>That ensures that if the task completes after the &lt;code&gt;timeout&lt;/code&gt; but before &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt; has been called, you will still get the result, since &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt; is designed to handle this case and return the result.</source>
          <target state="translated">Это гарантирует, что если задача завершится после &lt;code&gt;timeout&lt;/code&gt; но до &lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt; , вы все равно получите результат, поскольку &lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt; предназначен для обработки этого случая и возврата результата.</target>
        </trans-unit>
        <trans-unit id="d1fc0fd9268067ed50e8dff689947fe93beb5673" translate="yes" xml:space="preserve">
          <source>That happens because the &lt;code&gt;IO&lt;/code&gt; module actually works with processes (see &lt;a href=&quot;processes&quot;&gt;chapter 11&lt;/a&gt;). Given a file is a process, when you write to a file that has been closed, you are actually sending a message to a process which has been terminated:</source>
          <target state="translated">Это происходит потому, что модуль &lt;code&gt;IO&lt;/code&gt; действительно работает с процессами (см. &lt;a href=&quot;processes&quot;&gt;Главу 11&lt;/a&gt; ). Учитывая, что файл является процессом, когда вы пишете в файл, который был закрыт, вы фактически отправляете сообщение процессу, который был завершен:</target>
        </trans-unit>
        <trans-unit id="897c7bf39cdf3d75952cff1b5ff6f99e7827d8f9" translate="yes" xml:space="preserve">
          <source>That is, if the node can be part of a distributed system.</source>
          <target state="translated">То есть,если узел может быть частью распределенной системы.</target>
        </trans-unit>
        <trans-unit id="8e363ec1e2d5f0647070623c22f89c8707555da9" translate="yes" xml:space="preserve">
          <source>That is, if the number of bits in &lt;code&gt;bitstring&lt;/code&gt; is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time.</source>
          <target state="translated">То есть, если количество бит в &lt;code&gt;bitstring&lt;/code&gt; не делится на 8, результирующее количество байтов будет округлено (на избыток). Эта операция происходит в постоянное время.</target>
        </trans-unit>
        <trans-unit id="21fbb88b6f851991624fb5b17096150fe0715845" translate="yes" xml:space="preserve">
          <source>That said, there are still cases where using macros and modules to build domain-specific languages is useful. Since we have explored data structures and function definitions in the Getting Started guide, this chapter will explore how to use macros and module attributes to tackle more complex DSLs.</source>
          <target state="translated">Тем не менее,все еще есть случаи,когда использование макросов и модулей для создания специфических для домена языков полезно.Поскольку мы изучили структуры данных и определения функций в руководстве &quot;Начало работы&quot;,в этой главе мы рассмотрим,как использовать макросы и атрибуты модулей для решения более сложных DSL.</target>
        </trans-unit>
        <trans-unit id="814b47f77dfc5a37096b4b03955d625f97a0e859" translate="yes" xml:space="preserve">
          <source>That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straightforward because we also need to expand the caller aliases. For example:</source>
          <target state="translated">При этом нам нужно расширить узел псевдонимов выше до атома,чтобы мы могли получить его длину.Расширение узла не является простым,потому что нам также нужно расширить псевдонимы вызывающего абонента.Например:</target>
        </trans-unit>
        <trans-unit id="4d3f07f40965deb2a6bdc254e2fe7db4fac694fb" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because an umbrella project gives us plenty of options when deploying the software. We can:</source>
          <target state="translated">Это потому, что зонтичный проект дает нам множество вариантов при развертывании программного обеспечения. Мы можем:</target>
        </trans-unit>
        <trans-unit id="11e8efbea29607bc7f881559616858502e41b031" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because we were expecting data from &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; but the client closed the connection. We need to handle such cases better in future revisions of our server.</source>
          <target state="translated">Это потому, что мы ожидали данные от &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; , но клиент закрыл соединение. Нам нужно лучше обрабатывать такие случаи в будущих версиях нашего сервера.</target>
        </trans-unit>
        <trans-unit id="4c56715445461f557ef98a6e96f4646be8d6243e" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s enough for our tests to pass but there is a resource leakage in our application. When a bucket terminates, the supervisor will start a new bucket in its place. After all, that&amp;rsquo;s the role of the supervisor!</source>
          <target state="translated">Этого достаточно, чтобы наши тесты прошли, но в нашем приложении есть утечка ресурсов. Когда корзина завершается, супервизор запускает новую корзину вместо нее. В конце концов, это роль руководителя!</target>
        </trans-unit>
        <trans-unit id="b7a0f3e3c150c923165c6e2a99dd197a0a28b7af" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s happening because the release &lt;code&gt;foo&lt;/code&gt; is already listening on port &lt;code&gt;4040&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; is trying to do the same! One option could be to move the &lt;code&gt;:port&lt;/code&gt; configuration to the application environment, like we did for the routing table. But let&amp;rsquo;s try something else. Let&amp;rsquo;s make it so the &lt;code&gt;bar&lt;/code&gt; release contains only the &lt;code&gt;:kv&lt;/code&gt; application. So it works as a storage but it won&amp;rsquo;t have a front-end. Change the &lt;code&gt;:bar&lt;/code&gt; information to this:</source>
          <target state="translated">Это происходит потому, что релиз &lt;code&gt;foo&lt;/code&gt; уже прослушивает порт &lt;code&gt;4040&lt;/code&gt; , и &lt;code&gt;bar&lt;/code&gt; пытается сделать то же самое! Один из вариантов - переместить конфигурацию &lt;code&gt;:port&lt;/code&gt; в среду приложения, как мы это сделали для таблицы маршрутизации. Но давайте попробуем другое. Сделаем так, чтобы релиз &lt;code&gt;bar&lt;/code&gt; содержал только приложение &lt;code&gt;:kv&lt;/code&gt; . Таким образом, он работает как хранилище, но у него не будет интерфейса. Измените информацию &lt;code&gt;:bar&lt;/code&gt; на это:</target>
        </trans-unit>
        <trans-unit id="728db93af19ad8ae8e28827f7df6fa0ee95b6c1b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it for the client API. On the server side, we can implement a variety of callbacks to guarantee the server initialization, termination, and handling of requests. Those callbacks are optional and for now, we have only implemented the ones we care about. Let&amp;rsquo;s recap.</source>
          <target state="translated">Вот и все, что касается клиентского API. На стороне сервера мы можем реализовать множество обратных вызовов, чтобы гарантировать инициализацию, завершение и обработку запросов сервера. Эти обратные вызовы необязательны, и на данный момент мы реализовали только те, которые нам небезразличны. Подведем итоги.</target>
        </trans-unit>
        <trans-unit id="a3de339a8a8126c8176ac9eab07a22576517e36b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not what we wanted, since the value of the &lt;code&gt;number&lt;/code&gt; variable has not been injected and &lt;code&gt;number&lt;/code&gt; has been quoted in the expression. In order to inject the &lt;em&gt;value&lt;/em&gt; of the &lt;code&gt;number&lt;/code&gt; variable, &lt;code&gt;unquote&lt;/code&gt; has to be used inside the quoted representation:</source>
          <target state="translated">Это не то, что мы хотели, поскольку значение &lt;code&gt;number&lt;/code&gt; переменной не было введено, а &lt;code&gt;number&lt;/code&gt; было заключено в кавычки в выражении. Для того , чтобы впрыснуть &lt;em&gt;значение&lt;/em&gt; этого &lt;code&gt;number&lt;/code&gt; переменной, &lt;code&gt;unquote&lt;/code&gt; должен быть использован в процитированном представлении:</target>
        </trans-unit>
        <trans-unit id="dcf68842185af09e3a0f9fe32163648242f47543" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s what macros are all about. They are about receiving quoted expressions and transforming them into something else. In fact, &lt;code&gt;unless/2&lt;/code&gt; in Elixir is implemented as a macro:</source>
          <target state="translated">Вот что такое макросы. Они о получении цитируемых выражений и преобразовании их во что-то другое. Фактически, &lt;code&gt;unless/2&lt;/code&gt; в Эликсире не реализован как макрос:</target>
        </trans-unit>
        <trans-unit id="23bd0d6f40de4627ff508337339ea27a545beab3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s when &lt;code&gt;unquote_splicing&lt;/code&gt; becomes handy:</source>
          <target state="translated">Вот тогда и пригодится &lt;code&gt;unquote_splicing&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21e361b399ff70e0ade5d247fbe5325383f22c2c" translate="yes" xml:space="preserve">
          <source>That's because by reading the application in the module body and storing it in a module attribute, we are effectively reading the configuration at compile-time, which may become an issue when configuring the system later.</source>
          <target state="translated">Это связано с тем,что,читая приложение в теле модуля и сохраняя его в атрибуте модуля,мы эффективно читаем конфигурацию во время компиляции,что может стать проблемой при настройке системы в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="525c877e46b0705b116260fb28719a829fe1a18e" translate="yes" xml:space="preserve">
          <source>That's what we meant when we said earlier that streams are composable, lazy enumerables. Note that we could call &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt; multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Именно это мы имели в виду, когда говорили ранее, что потоки являются компонуемыми ленивыми перечислениями. Обратите внимание, что мы можем вызывать &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt; несколько раз, эффективно составляя потоки и сохраняя их ленивость. Вычисления выполняются только при вызове функции из модуля &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd53bd72aff61e4af823bbda7c24cb88da5c37ab" translate="yes" xml:space="preserve">
          <source>That's what we meant when we said earlier that streams are composable, lazy enumerables. Notice we could call &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt; multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Именно это мы имели в виду, когда говорили ранее, что потоки являются компонуемыми ленивыми перечислениями. Обратите внимание, что мы можем вызывать &lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt; несколько раз, эффективно составляя потоки и сохраняя их ленивость. Вычисления выполняются только при вызове функции из модуля &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09a6d160f8b301e17d705ee43757bf265bccdb38" translate="yes" xml:space="preserve">
          <source>The &quot;Current Era&quot; or the &quot;Common Era&quot; (CE) which starts in year &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo;Текущая эра&amp;raquo; или &amp;laquo;наша эра&amp;raquo; (СЕ), которая начинается в год &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a59d1e1634f57e0cf851ffcf7499aa4351a17212" translate="yes" xml:space="preserve">
          <source>The &quot;file:line&quot; represents the file and line a call to a deprecated &quot;module.function/arity&quot; is made. This operation does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">Файл:строка&quot; представляет собой файл и строку,в которой происходит вызов устаревшего &quot;модуля.функции/arity&quot;.В этой операции не отображаются ни устаревшие локальные вызовы (вызов устаревшей функции или макроса в том же модуле),ни вызовы устаревшей функциональности в самом Elixir.</target>
        </trans-unit>
        <trans-unit id="826934dab44a7a099fc8b2a86a3c62e533cc4b2e" translate="yes" xml:space="preserve">
          <source>The &quot;file:line&quot; represents the file and line a call to an unknown &quot;module.function/arity&quot; is made.</source>
          <target state="translated">Файл:строка&quot; представляет собой файл и строку вызова неизвестного &quot;модуля.функции/arity&quot;.</target>
        </trans-unit>
        <trans-unit id="f23646193825ac71d9878bc225694b7560e701b8" translate="yes" xml:space="preserve">
          <source>The --stale option</source>
          <target state="translated">Продажный вариант</target>
        </trans-unit>
        <trans-unit id="0c20b0f5fe22af74b9f5bd9023dad3c12944c0fd" translate="yes" xml:space="preserve">
          <source>The .iex.exs file</source>
          <target state="translated">Файл .iex.exs</target>
        </trans-unit>
        <trans-unit id="f8308d6c331d75737fe1ed60777039be95e5626b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#%253C%253E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:</source>
          <target state="translated">Оператор &lt;a href=&quot;#%253C%253E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; также может использоваться в сопоставлении с образцом (и защитных предложениях), если левый аргумент является буквальным двоичным кодом:</target>
        </trans-unit>
        <trans-unit id="2522f291657c90a8970a25fc0f5c55b3b111e28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:</source>
          <target state="translated">Оператор &lt;a href=&quot;#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; также может использоваться в сопоставлении с образцом (и защитных предложениях), если левый аргумент является буквальным двоичным кодом:</target>
        </trans-unit>
        <trans-unit id="3ea0da9cdd3dfdfb8c5593853f9e341b5464f742" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#--/2&quot;&gt;&lt;code&gt;--/2&lt;/code&gt;&lt;/a&gt; operator is right associative, meaning:</source>
          <target state="translated">Оператор &lt;a href=&quot;#--/2&quot;&gt; &lt;code&gt;--/2&lt;/code&gt; &lt;/a&gt; является правоассоциативным, что означает:</target>
        </trans-unit>
        <trans-unit id="ae4a9ae0930f3e9d2c507d033d48dd4bf27477e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#add/2&quot;&gt;&lt;code&gt;add/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#diff/2&quot;&gt;&lt;code&gt;diff/2&lt;/code&gt;&lt;/a&gt; functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01):</source>
          <target state="translated">Функции &lt;a href=&quot;#add/2&quot;&gt; &lt;code&gt;add/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#diff/2&quot;&gt; &lt;code&gt;diff/2&lt;/code&gt; &lt;/a&gt; могут использоваться для вычисления дат или получения количества дней между моментами. Например, если есть интерес к вычислению количества дней с эпохи Unix (1970-01-01):</target>
        </trans-unit>
        <trans-unit id="9ee4b27e73fcd2815c54fe669288c51019f1a3b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#add/3&quot;&gt;&lt;code&gt;add/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#diff/3&quot;&gt;&lt;code&gt;diff/3&lt;/code&gt;&lt;/a&gt; functions can be used for computing with date times or retrieving the number of seconds between instants. For example, if there is an interest in computing the number of seconds from the Unix epoch (1970-01-01 00:00:00):</source>
          <target state="translated">Функции &lt;a href=&quot;#add/3&quot;&gt; &lt;code&gt;add/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#diff/3&quot;&gt; &lt;code&gt;diff/3&lt;/code&gt; &lt;/a&gt; могут использоваться для вычисления с указанием даты и времени или для получения количества секунд между моментами. Например, если есть интерес к вычислению количества секунд с эпохи Unix (1970-01-01 00:00:00):</target>
        </trans-unit>
        <trans-unit id="a3dad105e7857da173ae25be4e7158181735facf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function returns an atom indicating the status of the compilation, and optionally can also return a list of &quot;diagnostics&quot; such as warnings or compilation errors. Doing this enables code editors to display issues inline without having to analyze the command-line output.</source>
          <target state="translated">Функция &lt;a href=&quot;#c:run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; возвращает атом, указывающий на состояние компиляции, и, при желании, также может возвращать список &amp;laquo;диагностических данных&amp;raquo;, таких как предупреждения или ошибки компиляции. Это позволяет редакторам кода отображать проблемы в режиме реального времени без необходимости анализировать вывод командной строки.</target>
        </trans-unit>
        <trans-unit id="43daa6aefdc5d7ab59c882f8c756868ab5825ba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback has to spawn and link a supervisor and return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor, and &lt;code&gt;state&lt;/code&gt; is an optional application state. &lt;code&gt;args&lt;/code&gt; is the second element of the tuple given to the &lt;code&gt;:mod&lt;/code&gt; option.</source>
          <target state="translated">&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; обратный вызов должен икру и связать супервизора и возвращение &lt;code&gt;{:ok, pid}&lt;/code&gt; или &lt;code&gt;{:ok, pid, state}&lt;/code&gt; , где &lt;code&gt;pid&lt;/code&gt; является PID - супервизора, и &lt;code&gt;state&lt;/code&gt; является необязательным состояние приложения. &lt;code&gt;args&lt;/code&gt; - это второй элемент кортежа, переданный опции &lt;code&gt;:mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed55773b14c9f49b1e67866369426e97f1e28202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; callback of the given &lt;code&gt;server&lt;/code&gt; will be invoked before exiting. This function returns &lt;code&gt;:ok&lt;/code&gt; if the server terminates with the given reason; if it terminates with another reason, the call exits.</source>
          <target state="translated">&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; обратного вызова данного &lt;code&gt;server&lt;/code&gt; будет вызываться перед выходом. Эта функция возвращает &lt;code&gt;:ok&lt;/code&gt; , если сервер завершает работу по указанной причине; если он завершается по другой причине, вызов завершается.</target>
        </trans-unit>
        <trans-unit id="e5479aff7c9902d4559e5268eb0059ef6a88b9eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module defines a behaviour for dynamically accessing keys of any type in a data structure via the &lt;code&gt;data[key]&lt;/code&gt; syntax.</source>
          <target state="translated">Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; определяет поведение для динамического доступа к ключам любого типа в структуре данных с помощью синтаксиса &lt;code&gt;data[key]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22076bf07a81ed27164e331c5cdde4703e5883c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module provides a basic server implementation that allows state to be retrieved and updated via a simple API.</source>
          <target state="translated">Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; обеспечивает базовую реализацию сервера, которая позволяет получать и обновлять состояние через простой API.</target>
        </trans-unit>
        <trans-unit id="ab7d336fe7d0f927a59616b237afeff91face2e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; module was designed to fill the gap left by the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;collectable#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; can be seen as the opposite of &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt;. If the functions in &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are about taking values out, then &lt;a href=&quot;collectable#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; is about collecting those values into a structure.</source>
          <target state="translated">Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; был разработан, чтобы заполнить пробел, оставленный протоколом &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;collectable#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; можно рассматривать как противоположность &lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; . Если функции в &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; предназначены для извлечения значений, то &lt;a href=&quot;collectable#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; предназначен для сбора этих значений в структуру.</target>
        </trans-unit>
        <trans-unit id="b8288b2458a158037407e3018394c02df95a408e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; module was designed to fill the gap left by the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; can be seen as the opposite of &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt;. If the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are about taking values out, then &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; is about collecting those values into a structure.</source>
          <target state="translated">Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; был разработан, чтобы заполнить пробел, оставленный протоколом &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; можно рассматривать как противоположность &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; . Если функции в &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; предназначены для извлечения значений, то &lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; предназначен для сбора этих значений в структуру.</target>
        </trans-unit>
        <trans-unit id="ba60445997acad418c74ca5920c2ffa31f99771e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module in Elixir was introduced in v1.9 as a replacement to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt;, which was specific to Mix and has been deprecated.</source>
          <target state="translated">Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; в Elixir был представлен в v1.9 в качестве замены &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt; , который был специфичным для Mix и объявлен устаревшим.</target>
        </trans-unit>
        <trans-unit id="abf8114bea9b602a6fa5cde26a4f28f20fe6f936" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is disabled by configuration but might be enabled later.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; отключена по конфигурации , но может быть включена позже.</target>
        </trans-unit>
        <trans-unit id="6bff3abe60e151fca7d023800c126e733ac84e99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. This is especially useful for fields containing private information.</source>
          <target state="translated">Протокол &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; может быть получен, чтобы скрыть определенные поля от структур, чтобы они не отображались в журналах, инспекциях и т.п. Это особенно полезно для полей, содержащих личную информацию.</target>
        </trans-unit>
        <trans-unit id="8080f21d315b84058f54169b0d0e5acda5fedb17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol converts an Elixir data structure into an algebra document.</source>
          <target state="translated">Протокол &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; преобразует структуру данных Elixir в документ алгебры.</target>
        </trans-unit>
        <trans-unit id="9574ae7fd608f87be01cc34283e1b30a27e28472" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt; module consists solely of macros that can be invoked anywhere in Elixir code without the use of the &lt;code&gt;Kernel.SpecialForms.&lt;/code&gt; prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; &lt;/a&gt; состоит исключительно из макросов, которые можно вызывать в любом месте кода Elixir без использования &lt;code&gt;Kernel.SpecialForms.&lt;/code&gt; приставка. Это возможно, потому что все они были автоматически импортированы таким же образом, как и функции и макросы из модуля &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b2d0f65323751f2d634dcefd3c1350838c93ed4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;List.Chars&lt;/code&gt;&lt;/a&gt; protocol is responsible for converting a structure to a charlist (only if applicable).</source>
          <target state="translated">Протокол &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;List.Chars&lt;/code&gt; &lt;/a&gt; отвечает за преобразование структуры в список символов (только если применимо).</target>
        </trans-unit>
        <trans-unit id="38d20b80dced22a569e8ce8dd2e2cb76ca007f43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; level can be changed via &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Уровень &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; можно изменить с помощью &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49b1a8808d4938037f08f4bb6036b797cb46526f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol is responsible for converting a structure to a binary (only if applicable).</source>
          <target state="translated">Протокол &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; отвечает за преобразование структуры в двоичную форму (только если применимо).</target>
        </trans-unit>
        <trans-unit id="3a7cc4ed1dd3a53a3c1622be5d60a8754eb496ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module also provides functions that work with time, returning different times kept by the system with support for different time units.</source>
          <target state="translated">Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt; также предоставляет функции, которые работают со временем, возвращая разное время, хранимое системой, с поддержкой разных единиц времени.</target>
        </trans-unit>
        <trans-unit id="cb4a8417128c99dd0f8e923027d6accff8aed84b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module provides functions that interact directly with the VM or the host system.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt; модуль обеспечивает функцию , которые взаимодействуют непосредственно с ВМ или хост - системой.</target>
        </trans-unit>
        <trans-unit id="12062fd16ee7106907717a179dc3f0336ff014a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#escape/2&quot;&gt;&lt;code&gt;escape/2&lt;/code&gt;&lt;/a&gt; function is sometimes confused with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt;, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</source>
          <target state="translated">&lt;a href=&quot;#escape/2&quot;&gt; &lt;code&gt;escape/2&lt;/code&gt; &lt;/a&gt; функция иногда путают с &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt; , потому что выше примеры ведут себя так же с обоими. Ключевое различие лучше всего проиллюстрировано, когда экранируемое значение сохраняется в переменной.</target>
        </trans-unit>
        <trans-unit id="809a6d9b2839f1f30bd03fe2ee9a26d931f04222" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#escape/2&quot;&gt;&lt;code&gt;escape/2&lt;/code&gt;&lt;/a&gt; function is sometimes confused with &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt;, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</source>
          <target state="translated">&lt;a href=&quot;#escape/2&quot;&gt; &lt;code&gt;escape/2&lt;/code&gt; &lt;/a&gt; функция иногда путают с &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt; , потому что выше примеры ведут себя так же с обоими. Ключевое различие лучше всего иллюстрируется, когда значение, которое нужно ускользнуть, хранится в переменной.</target>
        </trans-unit>
        <trans-unit id="9c2c3fda2409ed0d9077f83013708c3d236d2331" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt; operator (as well as &lt;code&gt;not in&lt;/code&gt;) can be used in guard clauses as long as the right-hand side is a range or a list. In such cases, Elixir will expand the operator to a valid guard expression. For example:</source>
          <target state="translated">Оператор &lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt; (а также оператор &lt;code&gt;not in&lt;/code&gt; ) может использоваться в защитных предложениях, если правая часть представляет собой диапазон или список. В таких случаях Elixir расширит оператор до допустимого охранного выражения. Например:</target>
        </trans-unit>
        <trans-unit id="12e9561355b5b7e730bdce33c0452a589a9f44d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; macro emits the provided message at the &lt;code&gt;:info&lt;/code&gt; level. Note the arguments given to &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt; will only be evaluated if a message is logged. For instance, if the Logger level is set to &lt;code&gt;:warning&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt; messages are never logged and therefore the arguments given above won't even be executed.</source>
          <target state="translated">&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; &lt;/a&gt; макрос выдает предоставленное сообщение на &lt;code&gt;:info&lt;/code&gt; уровне. Обратите внимание, что аргументы, указанные в &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; ,&lt;/a&gt; будут оцениваться только в том случае, если сообщение зарегистрировано. Например, если уровень Logger устанавливаются на &lt;code&gt;:warning&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; сообщение не регистрируется и поэтому аргументы , приведенные выше , не будет даже казнены.</target>
        </trans-unit>
        <trans-unit id="64530a6b669b9204e5a94bb0898670f111e23370" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; function receives the entity to be inspected followed by the inspecting options, represented by the struct &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Building of the algebra document is done with &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt; получает объект для проверки, за которым следуют параметры проверки, представленные структурой &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt; . Построение документа алгебры осуществляется с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1987eac8908bd887fd45fd0aa17e5d5cf4eae6f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; function receives the entity to be inspected followed by the inspecting options, represented by the struct &lt;a href=&quot;inspect.opts&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Building of the algebra document is done with &lt;a href=&quot;inspect.algebra&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt; получает объект для проверки, за которым следуют параметры проверки, представленные структурой &lt;a href=&quot;inspect.opts&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt; . Построение документа алгебры осуществляется с помощью &lt;a href=&quot;inspect.algebra&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="134dffce704618fe41bc1a6ff89c996a1a5a5795" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; function is an alternative to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; which stops parsing as soon as it finds a value that is not a switch nor a value for a previous switch.</source>
          <target state="translated">Функция &lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; является альтернативой &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; ,&lt;/a&gt; которая останавливает синтаксический анализ, как только находит значение, которое не является переключателем или значением для предыдущего переключателя.</target>
        </trans-unit>
        <trans-unit id="697f7c6714240908cebb2f84042a4676fb351582" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#receive/1&quot;&gt;&lt;code&gt;receive/1&lt;/code&gt;&lt;/a&gt; special form handles variables exactly as the &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt; special macro. For more information, check the docs for &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#receive/1&quot;&gt; &lt;code&gt;receive/1&lt;/code&gt; &lt;/a&gt; специальных формы ручки переменных точно так , как &lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt; специальный макрос. Дополнительные сведения см. В документации &lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a73aff6dd1644a4fec2f0cc2e5b4cbf67e226d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function will receive a list of all arguments passed to the command line.</source>
          <target state="translated">Функция &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; получит список всех аргументов, переданных в командную строку.</target>
        </trans-unit>
        <trans-unit id="d0035717d441177cdcf48958cde9b6d4cb1dceef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function will receive a list of all command line arguments passed, according to the user's terminal.</source>
          <target state="translated">Функция &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; получит список всех переданных аргументов командной строки в соответствии с терминалом пользователя.</target>
        </trans-unit>
        <trans-unit id="659e7f5a2f80c4b590db43cd2313e4b28833eba7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol.</source>
          <target state="translated">Функция &lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; ,&lt;/a&gt; автоматически импортируемая &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; вызывает этот протокол.</target>
        </trans-unit>
        <trans-unit id="1acbbf7700e430d5e8a317ed727437d8f72605c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol.</source>
          <target state="translated">Функция &lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; ,&lt;/a&gt; автоматически импортируемая &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; вызывает этот протокол.</target>
        </trans-unit>
        <trans-unit id="e73d8ea623f499f0cd55a3dd0c9f7d97f06db4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol. String interpolation also invokes &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; in its arguments. For example, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; ,&lt;/a&gt; автоматически импортируемая &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; вызывает этот протокол. Строковая интерполяция также вызывает &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; в своих аргументах. Например, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; - это то же самое, что &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9a742b2d1a9b66bf0c1dce63c60e9a1472deab1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol. String interpolation also invokes &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; in its arguments. For example, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; ,&lt;/a&gt; автоматически импортируемая &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; вызывает этот протокол. Строчная интерполяция также вызывает &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; в своих аргументах. Например, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; - это то же самое, что &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99cfcb046ece84f36691d25008fe9a0f03a6c335" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module ships with many convenience accessor functions, like the &lt;code&gt;all&lt;/code&gt; anonymous function defined above. See &lt;a href=&quot;access#all/0&quot;&gt;&lt;code&gt;Access.all/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access#key/2&quot;&gt;&lt;code&gt;Access.key/2&lt;/code&gt;&lt;/a&gt;, and others as examples.</source>
          <target state="translated">В &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; модуль поставляется с большим количеством функций , удобство аксессоры, как &lt;code&gt;all&lt;/code&gt; анонимные функции , определенной выше. См. &lt;a href=&quot;access#all/0&quot;&gt; &lt;code&gt;Access.all/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;access#key/2&quot;&gt; &lt;code&gt;Access.key/2&lt;/code&gt; &lt;/a&gt; и др.</target>
        </trans-unit>
        <trans-unit id="bf10aa8724a5861c9b7609f06466ac0092733d78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; function uses this protocol to insert an enumerable into a collection:</source>
          <target state="translated">Функция &lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; использует этот протокол для вставки перечислимого объекта в коллекцию:</target>
        </trans-unit>
        <trans-unit id="fa114b12b62761d046798dab8cfd3d0e25686da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol do not keep shape. For example, passing a map to &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; always returns a list.</source>
          <target state="translated">Протокол &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; полезен для извлечения значений из коллекции. Чтобы поддерживать широкий диапазон значений, функции, предоставляемые протоколом &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , не сохраняют форму. Например, передача карты в &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; всегда возвращает список.</target>
        </trans-unit>
        <trans-unit id="c6e919949e1cc4c7055aecf80d424e6c7c8e1be6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;exunit.assertions&quot;&gt;&lt;code&gt;ExUnit.Assertions&lt;/code&gt;&lt;/a&gt; module contains a set of macros to generate assertions with appropriate error messages.</source>
          <target state="translated">Модуль &lt;a href=&quot;exunit.assertions&quot;&gt; &lt;code&gt;ExUnit.Assertions&lt;/code&gt; &lt;/a&gt; содержит набор макросов для создания утверждений с соответствующими сообщениями об ошибках.</target>
        </trans-unit>
        <trans-unit id="e06ff54ee1b695829bf1293f395bfa9eaf00995b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://erlang.org/doc/man/queue.html&quot;&gt;&lt;code&gt;queue&lt;/code&gt; is a data structure&lt;/a&gt; that implements (double-ended) FIFO (first-in first-out) queues efficiently:</source>
          <target state="translated">&lt;a href=&quot;http://erlang.org/doc/man/queue.html&quot;&gt; &lt;code&gt;queue&lt;/code&gt; представляет собой структуру данных&lt;/a&gt; , которая реализует (Двухконтактные) буфер FIFO (первым вошел первым вышел) очередей эффективно:</target>
        </trans-unit>
        <trans-unit id="07ed121626ed7e8f632f13e54f94021e4c3eade3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module ships with many convenience accessor functions, like the &lt;code&gt;all&lt;/code&gt; anonymous function defined above. See &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#all/0&quot;&gt;&lt;code&gt;Access.all/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#key/2&quot;&gt;&lt;code&gt;Access.key/2&lt;/code&gt;&lt;/a&gt;, and others as examples.</source>
          <target state="translated">В &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; модуль поставляется с большим количеством функций , удобство аксессоры, как &lt;code&gt;all&lt;/code&gt; анонимные функции , определенной выше. См. &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#all/0&quot;&gt; &lt;code&gt;Access.all/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#key/2&quot;&gt; &lt;code&gt;Access.key/2&lt;/code&gt; &lt;/a&gt; и др.</target>
        </trans-unit>
        <trans-unit id="bdd1437c3341d1c07273b3f627a96d773e38e418" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt; module&lt;/a&gt;, which we&amp;rsquo;re going to see in the next chapter, already provides many conveniences for working with lists. For instance, the examples above could be written as:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; модуль&lt;/a&gt; , который мы будем видеть в следующей главе, уже предоставляет множество удобств для работы со списками. Например, приведенные выше примеры можно записать как:</target>
        </trans-unit>
        <trans-unit id="61a11f1e7c47a4cc245aed3807805f29443ecca4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; function uses this protocol to insert an enumerable into a collection:</source>
          <target state="translated">Функция &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; использует этот протокол для вставки перечислимого объекта в коллекцию:</target>
        </trans-unit>
        <trans-unit id="2f7b5a0e03b34766993d4d199617c0cbd0ae5332" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol do not keep shape. For example, passing a map to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; always returns a list.</source>
          <target state="translated">Протокол &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; полезен для извлечения значений из коллекции. Чтобы поддерживать широкий диапазон значений, функции, предоставляемые протоколом &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , не сохраняют форму. Например, передача карты в &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; всегда возвращает список.</target>
        </trans-unit>
        <trans-unit id="a8c7834fd0c261cc1b5f7ce8f49f4c14a50c74c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; module contains functions that allow us to open files as IO devices. By default, files are opened in binary mode, which requires developers to use the specific &lt;code&gt;IO.binread/2&lt;/code&gt; and &lt;code&gt;IO.binwrite/2&lt;/code&gt; functions from the &lt;code&gt;IO&lt;/code&gt; module:</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; содержит функции, которые позволяют нам открывать файлы как устройства ввода-вывода. По умолчанию файлы открываются в двоичном режиме, что требует от разработчиков использования определенных &lt;code&gt;IO.binread/2&lt;/code&gt; и &lt;code&gt;IO.binwrite/2&lt;/code&gt; из модуля &lt;code&gt;IO&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f10e5258e9f652f477ba9a6f2a826f10009c524a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module is the main mechanism in Elixir for reading and writing to standard input/output (&lt;code&gt;:stdio&lt;/code&gt;), standard error (&lt;code&gt;:stderr&lt;/code&gt;), files, and other IO devices. Usage of the module is pretty straightforward:</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; - это основной механизм в Elixir для чтения и записи в стандартный ввод / вывод ( &lt;code&gt;:stdio&lt;/code&gt; ), стандартную ошибку ( &lt;code&gt;:stderr&lt;/code&gt; ), файлы и другие устройства ввода-вывода. Использование модуля довольно простое:</target>
        </trans-unit>
        <trans-unit id="cedaefb5f61468b8c215642cc99c539ddbc0a94c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides streams, that are both &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, here is an upcase echo server using comprehensions:</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; предоставляет потоки, которые являются как &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; , вот эхо-сервер upcase, использующий понимания:</target>
        </trans-unit>
        <trans-unit id="e868f828529603da9f63a81284af34a853bef03f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt; function comes from &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; and it concatenates algebra documents together. In the example above it is concatenating the string &lt;code&gt;&quot;#MapSet&amp;lt;&quot;&lt;/code&gt;, the document returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt;, and the final string &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;. We prefix the module name &lt;code&gt;#&lt;/code&gt; to denote the inspect presentation is not actually valid Elixir syntax.</source>
          <target state="translated">Функция &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; &lt;/a&gt; происходит от &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; и объединяет документы алгебры вместе. В приведенном выше примере он объединяет строку &lt;code&gt;&quot;#MapSet&amp;lt;&quot;&lt;/code&gt; , документ, возвращаемый &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; &lt;/a&gt; , и последнюю строку &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; . Мы ставим перед именем модуля префикс &lt;code&gt;#&lt;/code&gt; , чтобы обозначить, что презентация inspect не соответствует синтаксису Elixir.</target>
        </trans-unit>
        <trans-unit id="ae641337e01b9f93059a36e1a3ba275b039ee2b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for more information.</source>
          <target state="translated">Протокол &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; может быть создан для скрытия определенных полей из структур, чтобы они не отображались в журналах, инспекциях и т. Д. Для получения дополнительной информации см. Раздел &amp;laquo;Получение&amp;raquo; документации по протоколу &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a28216d6e4672680d6eab32ae15b9eaaeac9554" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;%NaiveDateTime{}&lt;/a&gt; struct contains fields from both &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt;. You can create one using the &lt;code&gt;~N&lt;/code&gt; sigil:</source>
          <target state="translated">Структура &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;% NaiveDateTime {}&lt;/a&gt; содержит поля как для &lt;code&gt;Date&lt;/code&gt; и для &lt;code&gt;Time&lt;/code&gt; . Вы можете создать его, используя сигил &lt;code&gt;~N&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0707ff13aefb15f3954d547b10f3f7c1336b24c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;String module&lt;/a&gt; contains a bunch of functions that operate on strings as defined in the Unicode standard:</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;String&lt;/a&gt; содержит набор функций, которые работают со строками, как определено в стандарте Unicode:</target>
        </trans-unit>
        <trans-unit id="d8cf6fffff5672b5280f7c52df7e56e3e88d0bc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module was designed to handle mostly static children that are started in the given order when the supervisor starts. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; starts with no children. Instead, children are started on demand via &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;. When a dynamic supervisor terminates, all children are shut down at the same time, with no guarantee of ordering.</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; был разработан для обработки в основном статических дочерних элементов, которые запускаются в заданном порядке при запуске Supervisor . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; начинается без детей. Вместо этого дети запускаются по запросу через &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; . Когда динамический супервизор завершает работу, все дочерние элементы закрываются одновременно, без гарантии упорядочивания.</target>
        </trans-unit>
        <trans-unit id="3698c4ae0d236660076a5f1da19f774b16936015" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; module allows developers to dynamically create multiple supervised tasks.</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; позволяет разработчикам динамически создавать несколько контролируемых задач.</target>
        </trans-unit>
        <trans-unit id="bc49e09c4c997793290301e758bea0470f3d8f68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;%Time{}&lt;/a&gt; struct contains the fields &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, and &lt;code&gt;calendar&lt;/code&gt;. You can create one using the &lt;code&gt;~T&lt;/code&gt; sigil:</source>
          <target state="translated">Структура &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;% Time {}&lt;/a&gt; содержит поля &lt;code&gt;hour&lt;/code&gt; , &lt;code&gt;minute&lt;/code&gt; , &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;microsecond&lt;/code&gt; и &lt;code&gt;calendar&lt;/code&gt; . Вы можете создать его, используя сигилу &lt;code&gt;~T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e2e3efd9b70a9c902779bfbca4902214d293def" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Assertions.html&quot;&gt;&lt;code&gt;ExUnit.Assertions&lt;/code&gt;&lt;/a&gt; module contains a set of macros to generate assertions with appropriate error messages.</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Assertions.html&quot;&gt; &lt;code&gt;ExUnit.Assertions&lt;/code&gt; &lt;/a&gt; содержит набор макросов для создания утверждений с соответствующими сообщениями об ошибках.</target>
        </trans-unit>
        <trans-unit id="67af9d3d80d8598be47bff2ebf254dbbb32a0636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt; command also allows the &lt;code&gt;--sup&lt;/code&gt; option to scaffold an application with a supervision tree out of the box. We talk about supervision trees later on when discussing one of the common anti-patterns when writing libraries.</source>
          <target state="translated">Команда &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt; также позволяет &lt;code&gt;--sup&lt;/code&gt; параметр --sup для создания готового шаблона приложения с деревом наблюдения. Мы поговорим о деревьях супервизии позже, когда будем обсуждать один из распространенных антишаблонов при написании библиотек.</target>
        </trans-unit>
        <trans-unit id="08414f62e4bbf9fd4d3ea08bc5b82b4c8e08abc1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for more information.</source>
          <target state="translated">Протокол &lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; может быть получен, чтобы скрыть определенные поля от структур, чтобы они не отображались в журналах, инспекциях и т.п. Для получения дополнительной информации см. Раздел &amp;laquo;Получение&amp;raquo; документации по протоколу &lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40361add3dfacd3a82f9de048a333c39b479ae30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;inspect.algebra#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt; function comes from &lt;a href=&quot;inspect.algebra&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; and it concatenates algebra documents together. In the example above, it is concatenating the string &lt;code&gt;&quot;MapSet&amp;lt;&quot;&lt;/code&gt; (all strings are valid algebra documents that keep their formatting when pretty printed), the document returned by &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; and the other string &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;inspect.algebra#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; &lt;/a&gt; пришла из &lt;a href=&quot;inspect.algebra&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; и объединяет документы алгебры вместе. В приведенном выше примере он объединяет строку &lt;code&gt;&quot;MapSet&amp;lt;&quot;&lt;/code&gt; (все строки являются действительными документами алгебры, которые сохраняют свое форматирование при правильной печати), документ, возвращаемый &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; ,&lt;/a&gt; и другую строку &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e499fed5d9e082220ab4665ee83930202fbc216" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides streams, that are both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, here is an upcase echo server using comprehensions:</source>
          <target state="translated">Модуль &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; предоставляет потоки, которые являются как &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; , вот эхо-сервер upcase, использующий понимания:</target>
        </trans-unit>
        <trans-unit id="ef991dbc6590a70e7dc7792c1502faa5b82544ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;logger#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; macro emits the provided message at the &lt;code&gt;:info&lt;/code&gt; level. Note the arguments given to &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt; will only be evaluated if a message is logged. For instance, if the Logger level is set to &lt;code&gt;:warn&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt; messages are never logged and therefore the arguments given above won't even be executed.</source>
          <target state="translated">&lt;a href=&quot;logger#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; &lt;/a&gt; макрос выдает предоставленное сообщение на &lt;code&gt;:info&lt;/code&gt; уровне. Обратите внимание, что аргументы, указанные в &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; ,&lt;/a&gt; будут оцениваться только в том случае, если сообщение зарегистрировано. Например, если уровень Logger устанавливаются на &lt;code&gt;:warn&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; сообщение никогда не регистрируется и поэтому аргументы , приведенные выше , не будет даже казнены.</target>
        </trans-unit>
        <trans-unit id="3fb892be769329b47a3a72fea685384027a625eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module was designed to handle mostly static children that are started in the given order when the supervisor starts. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; starts with no children. Instead, children are started on demand via &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;. When a dynamic supervisor terminates, all children are shut down at the same time, with no guarantee of ordering.</source>
          <target state="translated">Модуль &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; был разработан для обработки в основном статических дочерних элементов, которые запускаются в заданном порядке при запуске супервизора. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; начинается без детей. Вместо этого дети запускаются по запросу через &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; . Когда динамический супервизор завершается, все дочерние элементы закрываются одновременно, без гарантии упорядочивания.</target>
        </trans-unit>
        <trans-unit id="26a12a273dc85b3ddb0a7cf7190ec7cccb61c0d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; module allows developers to dynamically create multiple supervised tasks.</source>
          <target state="translated">Модуль &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; позволяет разработчикам динамически создавать несколько контролируемых задач.</target>
        </trans-unit>
        <trans-unit id="9f3bcdc6b0dacd5812de01049f85ba71ec9d986e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;1&lt;/code&gt; represents the first argument passed into the function. &lt;code&gt;&amp;amp;(&amp;amp;1 + 1)&lt;/code&gt; above is exactly the same as &lt;code&gt;fn x -&amp;gt; x + 1 end&lt;/code&gt;. The syntax above is useful for short function definitions.</source>
          <target state="translated">&lt;code&gt;&amp;amp;1&lt;/code&gt; представляет собой первый аргумент , передаваемый в функцию. &lt;code&gt;&amp;amp;(&amp;amp;1 + 1)&lt;/code&gt; выше точно то же самое, что и &lt;code&gt;fn x -&amp;gt; x + 1 end&lt;/code&gt; . Приведенный выше синтаксис полезен для коротких определений функций.</target>
        </trans-unit>
        <trans-unit id="462dea57799a704e8bdaa1d60d5f41548cf0ff70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator can be used with more complex expressions:</source>
          <target state="translated">Оператор &lt;code&gt;&amp;amp;&lt;/code&gt; можно использовать с более сложными выражениями:</target>
        </trans-unit>
        <trans-unit id="8324a31beed435619f352d82babacf78e2ffed56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--source&lt;/code&gt; and &lt;code&gt;--sink&lt;/code&gt; options are particularly useful when trying to understand how the modules in a particular file interact with the whole system. You can combine those options with &lt;code&gt;--label&lt;/code&gt; and &lt;code&gt;--only-nodes&lt;/code&gt; to get all files that exhibit a certain property, for example:</source>
          <target state="translated">Параметры &lt;code&gt;--source&lt;/code&gt; и &lt;code&gt;--sink&lt;/code&gt; особенно полезны при попытке понять, как модули в конкретном файле взаимодействуют со всей системой. Вы можете комбинировать эти параметры с &lt;code&gt;--label&lt;/code&gt; и &lt;code&gt;--only-nodes&lt;/code&gt; , чтобы получить все файлы, обладающие определенным свойством, например:</target>
        </trans-unit>
        <trans-unit id="da8c5a69e634407470f64de131f93cd85b1c1054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; command line option attempts to run only the test files which reference modules that have changed since the last time you ran this task with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;--stale&lt;/code&gt; попытки опции командной строки для запуска только тестовые файлы , которые ссылаются на модули , которые изменились с момента последнего запуска этой задачи с &lt;code&gt;--stale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27914fb6ca74f78b539d08d503dae1d70d9876c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; command line option attempts to run only those test files which reference modules that have changed since the last time you ran this task with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;--stale&lt;/code&gt; попытки опции командной строки для запуска только те тестовые файлы , которые ссылаются на модули , которые изменились с момента последнего запуска этой задачи с &lt;code&gt;--stale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df6e7ebae80eb329ea0918689120d554cb37f2c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; option is extremely useful for software iteration, allowing you to run only the relevant tests as you perform changes to the codebase.</source>
          <target state="translated">Параметр &lt;code&gt;--stale&lt;/code&gt; чрезвычайно полезен для итерации программного обеспечения, позволяя запускать только соответствующие тесты при внесении изменений в кодовую базу.</target>
        </trans-unit>
        <trans-unit id="08ab3c233377a6ec13838eb8f093fb564ec02061" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trace&lt;/code&gt; option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (&lt;code&gt;async: true&lt;/code&gt; has no effect) and shows detailed information about each test. If you run the tests multiple times you may see this intermittent failure:</source>
          <target state="translated">Параметр &lt;code&gt;--trace&lt;/code&gt; полезен, когда ваши тесты зашли в тупик или есть условия гонки, поскольку он запускает все тесты синхронно ( &lt;code&gt;async: true&lt;/code&gt; не действует) и показывает подробную информацию о каждом тесте. Если вы запустите тесты несколько раз, вы можете увидеть этот периодический сбой:</target>
        </trans-unit>
        <trans-unit id="70c59bbd77397d77a76b99b62c09d5b35df96a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trace&lt;/code&gt; option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (&lt;code&gt;async: true&lt;/code&gt; has no effect) and shows detailed information about each test. You may see one or two intermittent failures:</source>
          <target state="translated">Параметр &lt;code&gt;--trace&lt;/code&gt; полезен, когда ваши тесты зашли в тупик или есть условия гонки, поскольку он запускает все тесты синхронно ( &lt;code&gt;async: true&lt;/code&gt; имеет никакого эффекта) и показывает подробную информацию о каждом тесте. Вы можете увидеть один или два периодических сбоя:</target>
        </trans-unit>
        <trans-unit id="bac163fa8c2566f186b54fd07de5c6d65f93af5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ascii&lt;/code&gt; mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters:</source>
          <target state="translated">Режим &lt;code&gt;:ascii&lt;/code&gt; игнорирует символы Unicode и обеспечивает более производительную реализацию, если вы знаете, что строка содержит только символы ASCII:</target>
        </trans-unit>
        <trans-unit id="05564ea628704e49dd4cc09651f569d44c1a82ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:crypto&lt;/code&gt; module is not part of the Erlang standard library, but is included with the Erlang distribution. This means you must list &lt;code&gt;:crypto&lt;/code&gt; in your project&amp;rsquo;s applications list whenever you use it. To do this, edit your &lt;code&gt;mix.exs&lt;/code&gt; file to include:</source>
          <target state="translated">Модуль &lt;code&gt;:crypto&lt;/code&gt; не является частью стандартной библиотеки Erlang, но включен в дистрибутив Erlang. Это означает, что вы должны указывать &lt;code&gt;:crypto&lt;/code&gt; в списке приложений вашего проекта всякий раз, когда вы его используете. Для этого отредактируйте файл &lt;code&gt;mix.exs&lt;/code&gt; , включив в него:</target>
        </trans-unit>
        <trans-unit id="add3cf115e3a7915716bd93a5b79e1744ef2d173" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:fd&lt;/code&gt; name option allows developers to access &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; file descriptors used by the Erlang VM. You would use those only if you are reimplementing core part of the Runtime System, such as the &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:shell&lt;/code&gt; processes.</source>
          <target state="translated">&lt;code&gt;:fd&lt;/code&gt; вариант имени позволяет разработчикам получить доступ &lt;code&gt;in&lt;/code&gt; и &lt;code&gt;out&lt;/code&gt; дескрипторов файлов , используемых в Erlang VM. Вы можете использовать их только в том случае, если вы повторно реализуете основную часть системы времени выполнения, такую ​​как процессы &lt;code&gt;:user&lt;/code&gt; и &lt;code&gt;:shell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f6ac7a8b41e26b0d52e88d330fed22cf2cc2f20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:into&lt;/code&gt; and &lt;code&gt;:uniq&lt;/code&gt; options</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; и &lt;code&gt;:uniq&lt;/code&gt; варианты</target>
        </trans-unit>
        <trans-unit id="0211bc3942dfba08cb46ef94332394518116ea6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:into&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; опции</target>
        </trans-unit>
        <trans-unit id="a3988e2dcd8f368dd88c8ea1b7ec2bcd3100e56a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:label&lt;/code&gt; option is especially useful with pipelines:</source>
          <target state="translated">Параметр &lt;code&gt;:label&lt;/code&gt; особенно полезен с конвейерами:</target>
        </trans-unit>
        <trans-unit id="d03df649244dc7c63287f31c15a54de9bf6e2182" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mod&lt;/code&gt; option specifies the &amp;ldquo;application callback module&amp;rdquo;, followed by the arguments to be passed on application start. The application callback module can be any module that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;Application&lt;/a&gt; behaviour.</source>
          <target state="translated">Параметр &lt;code&gt;:mod&lt;/code&gt; указывает &amp;laquo;модуль обратного вызова приложения&amp;raquo;, за которым следуют аргументы, передаваемые при запуске приложения. Модуль обратного вызова приложения может быть любым модулем, реализующим поведение &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;приложения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc92fad8b6ff75a2a9c584dbe63fcee1353d021" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">Опция &lt;code&gt;:name&lt;/code&gt; также может быть указана для регистрации имени супервизора, поддерживаемые значения описаны в разделе &amp;laquo;Регистрация имени&amp;raquo; в &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; модуля GenServer .</target>
        </trans-unit>
        <trans-unit id="869c20a77b331e475dc6550865b679c81c154f2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">Опция &lt;code&gt;:name&lt;/code&gt; также может быть указана для регистрации имени супервизора, поддерживаемые значения описаны в разделе &amp;laquo;Регистрация имени&amp;raquo; в &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; модуля GenServer .</target>
        </trans-unit>
        <trans-unit id="9dd616361d3877df539a2d092f8aadb9d1c83008" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">Опцию &lt;code&gt;:name&lt;/code&gt; также можно использовать для регистрации имени супервизора. Поддерживаемые значения описаны в разделе &amp;laquo;Регистрация имени&amp;raquo; в &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; модуля GenServer .</target>
        </trans-unit>
        <trans-unit id="2ccfdad6d1a6ed0b138742630a980b7e627021ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">Опцию &lt;code&gt;:name&lt;/code&gt; также можно использовать для регистрации имени супервизора. Поддерживаемые значения описаны в разделе &amp;laquo;Регистрация имени&amp;raquo; в &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; модуля GenServer .</target>
        </trans-unit>
        <trans-unit id="0be059e0f52bc117f0d9ac535f0ebaba535ffdbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option is used for registration as described in the module documentation.</source>
          <target state="translated">Параметр &lt;code&gt;:name&lt;/code&gt; используется для регистрации, как описано в документации модуля.</target>
        </trans-unit>
        <trans-unit id="9ae6a790ebfb15d6c60e22c6003dc079f27e1350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:persistent&lt;/code&gt; option can be set to &lt;code&gt;true&lt;/code&gt; when there is a need to guarantee parameters set with this function will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.</source>
          <target state="translated">Параметр &lt;code&gt;:persistent&lt;/code&gt; может быть установлен в значение &lt;code&gt;true&lt;/code&gt; , если необходимо гарантировать, что параметры, установленные с помощью этой функции, не будут заменены параметрами, определенными в файле ресурсов приложения при загрузке. Это означает, что постоянные значения будут сохраняться после загрузки приложения, а также при перезагрузке приложения.</target>
        </trans-unit>
        <trans-unit id="f0d1fdc494208ae6f6f718ee89ecd443e0ecaf7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:reduce&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;:reduce&lt;/code&gt; вариант</target>
        </trans-unit>
        <trans-unit id="fb3b286cd086eae72642832fb5a362f5110c1af4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:restart&lt;/code&gt; option controls what the supervisor should consider to be a successful termination or not. If the termination is successful, the supervisor won't restart the child. If the child process crashed, the supervisor will start a new one.</source>
          <target state="translated">Параметр &lt;code&gt;:restart&lt;/code&gt; управляет тем, что супервизор должен считать успешным завершением работы или нет. Если завершение прошло успешно, супервизор не перезапустит ребенка. Если дочерний процесс потерпел крах, супервизор запустит новый.</target>
        </trans-unit>
        <trans-unit id="21c211e6097ddfd5bc4a9bb4945fe2497ef06a6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:second&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt;, &lt;code&gt;:microsecond&lt;/code&gt; and &lt;code&gt;:nanosecond&lt;/code&gt; time units controls the return value of the functions that accept a time unit.</source>
          <target state="translated">&lt;code&gt;:second&lt;/code&gt; , &lt;code&gt;:millisecond&lt;/code&gt; , &lt;code&gt;:microsecond&lt;/code&gt; и &lt;code&gt;:nanosecond&lt;/code&gt; единицы время контролирует возвращаемое значение функций , которые принимают единицу времени.</target>
        </trans-unit>
        <trans-unit id="2027010005a9400e00a3f5e7626e15299c8de0f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:secret_key&lt;/code&gt; key under &lt;code&gt;:my_app&lt;/code&gt; will be computed on the host machine, whenever the release is built. Setting the &lt;code&gt;MY_APP_SECRET_KEY&lt;/code&gt; right before starting your release will have no effect.</source>
          <target state="translated">&lt;code&gt;:secret_key&lt;/code&gt; ключ под &lt;code&gt;:my_app&lt;/code&gt; будет вычисляться на хост - машине, когда будет построен релиз. Установка &lt;code&gt;MY_APP_SECRET_KEY&lt;/code&gt; прямо перед запуском вашего выпуска не будет иметь никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="1fc77c6e40a992f998c561f03446c6642ec346ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:spawn&lt;/code&gt; tuple receives a binary that is going to be executed as a full invocation. For example, we can use it to invoke &quot;echo hello&quot; directly:</source>
          <target state="translated">&lt;code&gt;:spawn&lt;/code&gt; кортеж получает бинарный код , который будет выполнен в виде полный вызова. Например, мы можем использовать его для прямого вызова &quot;echo hello&quot;:</target>
        </trans-unit>
        <trans-unit id="7b93bb4d3ff18560e52b37ae6c18a308889c8bd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static_atom_encoder&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;:static_atom_encoder&lt;/code&gt; функция</target>
        </trans-unit>
        <trans-unit id="1e63d1877fcfa7f1cccde5219f1c0beb12c1d581" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static_atoms_encoder&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;:static_atoms_encoder&lt;/code&gt; функция</target>
        </trans-unit>
        <trans-unit id="a4c229bf7cb4e00904018bc0adfca73eff22ebc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:steps&lt;/code&gt; option must be a list and it must always include the atom &lt;code&gt;:assemble&lt;/code&gt;, which does most of the release assembling. You can pass anonymous functions before and after the &lt;code&gt;:assemble&lt;/code&gt; to customize your release assembling pipeline. Those anonymous functions will receive a &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct and must return the same or an updated &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct. It is also possible to build a tarball of the release by passing the &lt;code&gt;:tar&lt;/code&gt; step anywhere after &lt;code&gt;:assemble&lt;/code&gt;. If the release &lt;code&gt;:path&lt;/code&gt; is not configured, the tarball is created in &lt;code&gt;_build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz&lt;/code&gt; Otherwise it is created inside the configured &lt;code&gt;:path&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;:steps&lt;/code&gt; должен быть списком, и он всегда должен включать атом &lt;code&gt;:assemble&lt;/code&gt; , который выполняет большую часть сборки выпуска. Вы можете передавать анонимные функции до и после &lt;code&gt;:assemble&lt;/code&gt; чтобы настроить конвейер сборки выпуска. Эти анонимные функции получат структуру &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt; и должны возвращать ту же или обновленную структуру &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt; . Также можно создать архив релиза, передав шаг &lt;code&gt;:tar&lt;/code&gt; в любом месте после &lt;code&gt;:assemble&lt;/code&gt; . Если &lt;code&gt;:path&lt;/code&gt; release : не &lt;code&gt;_build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz&lt;/code&gt; , архив создается в _build / MIX_ENV / RELEASE_NAME-RELEASE_VSN.tar.gzВ противном случае он создается внутри настроенного &lt;code&gt;:path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7852e9b0f6e5ea07cd2dd1ac64030694b4b9d2d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; is a required option and the currently supported value is &lt;code&gt;:one_for_one&lt;/code&gt;. The remaining options can be found in the &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; является обязательным вариантом и в настоящее время поддерживается значение &lt;code&gt;:one_for_one&lt;/code&gt; . Остальные параметры можно найти в документации по &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ecf2c76d0e93dbfb5af69dd0e723a8fce1f3ba3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">Параметр &lt;code&gt;:strategy&lt;/code&gt; является обязательным, и по умолчанию разрешено максимум 3 перезапуска в течение 5 секунд. Проверьте модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; для получения подробного описания доступных стратегий.</target>
        </trans-unit>
        <trans-unit id="39fdbe497bf489a09ea386b4627370ef6bf6b5e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">Параметр &lt;code&gt;:strategy&lt;/code&gt; является обязательным, и по умолчанию разрешено максимум 3 перезапуска в течение 5 секунд. Проверьте модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; для подробного описания доступных стратегий.</target>
        </trans-unit>
        <trans-unit id="4318a8c81e458ee0b9cf77340dadbaf79a290499" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">Параметр &lt;code&gt;:strategy&lt;/code&gt; является обязательным, и по умолчанию разрешено максимум 3 перезапуска в течение 5 секунд. Проверьте модуль &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; для получения подробного описания доступных стратегий.</target>
        </trans-unit>
        <trans-unit id="6fd3d939dbec7e219780c6a3622d4fe572215853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_coverage&lt;/code&gt; configuration accepts the following options:</source>
          <target state="translated">&lt;code&gt;:test_coverage&lt;/code&gt; конфигурация принимает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="ad9818925ace018f87e1927334e33ca1a365e0b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_type&lt;/code&gt; tag is automatically set by ExUnit, but is &lt;em&gt;not&lt;/em&gt; reserved. This tag is available for users to customize if they desire.</source>
          <target state="translated">&lt;code&gt;:test_type&lt;/code&gt; метка автоматически устанавливается ExUnit, но &lt;em&gt;не&lt;/em&gt; защищены. Этот тег может быть изменен пользователями при желании.</target>
        </trans-unit>
        <trans-unit id="34f5e1a838ff9cda2c11258cd3b2a863cbdf176f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_type&lt;/code&gt; tag is automatically set by ExUnit, but is &lt;strong&gt;not&lt;/strong&gt; reserved. This tag is available for users to customize if they desire.</source>
          <target state="translated">&lt;code&gt;:test_type&lt;/code&gt; метка автоматически устанавливается ExUnit, но &lt;strong&gt;не&lt;/strong&gt; защищены. Этот тег может быть изменен пользователями при желании.</target>
        </trans-unit>
        <trans-unit id="9ea129091dfbd99c2a530d95ef2783ebbf81e5ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:tracers&lt;/code&gt; compiler option can be combined with the &lt;code&gt;:parser_options&lt;/code&gt; compiler option to enrich the metadata of the traced events above.</source>
          <target state="translated">&lt;code&gt;:tracers&lt;/code&gt; опция компилятора может быть объединена с &lt;code&gt;:parser_options&lt;/code&gt; опцией компилятора для обогащения метаданных прорисованных событий выше.</target>
        </trans-unit>
        <trans-unit id="0bb936c2d2f36ac2f8066e21c586a6fb2a08b1b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@&lt;/code&gt; macro compiles to a call to this function. For example, the following code:</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; Макрос компилируется вызова этой функции. Например, такой код:</target>
        </trans-unit>
        <trans-unit id="4db7ff3247782ab9520366b88d96d14d1712fe6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@optional_callbacks&lt;/code&gt; attributes are used to create a &lt;code&gt;behaviour_info/1&lt;/code&gt; function available on the defining module. This function can be used to retrieve the callbacks and optional callbacks defined by that module.</source>
          <target state="translated">В &lt;code&gt;@callback&lt;/code&gt; и &lt;code&gt;@optional_callbacks&lt;/code&gt; атрибуты используются для создания &lt;code&gt;behaviour_info/1&lt;/code&gt; функцию , доступную на определяющем модуле. Эта функция может использоваться для получения обратных вызовов и дополнительных обратных вызовов, определенных этим модулем.</target>
        </trans-unit>
        <trans-unit id="5131f63d4a847e5310d4b0da9f690cbf2653c391" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@compile&lt;/code&gt; attribute accepts different options that are used by both Elixir and Erlang compilers. Some of the common use cases are documented below:</source>
          <target state="translated">&lt;code&gt;@compile&lt;/code&gt; атрибут принимает различные параметры, которые используются как Elixir и Erlang составителей. Некоторые из распространенных вариантов использования описаны ниже:</target>
        </trans-unit>
        <trans-unit id="9c96b72a2b5229c84ff37173dda7b65a784fe244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; annotation immediately preceding &lt;code&gt;use Supervisor&lt;/code&gt; will be attached to the generated &lt;code&gt;child_spec/1&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; аннотация непосредственно предшествующее &lt;code&gt;use Supervisor&lt;/code&gt; будет присоединена к сгенерированной &lt;code&gt;child_spec/1&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="c2548a73a793d075044328d72e23f487f2153196" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@moduledoc&lt;/code&gt; attribute is used to add documentation to the module. &lt;code&gt;@doc&lt;/code&gt; is used before a function to provide documentation for it. Besides the attributes above, &lt;code&gt;@typedoc&lt;/code&gt; can also be used to attach documentation to types defined as part of typespecs. Elixir also allows metadata to be attached to documentation, by passing a keyword list to &lt;code&gt;@doc&lt;/code&gt; and friends.</source>
          <target state="translated">&lt;code&gt;@moduledoc&lt;/code&gt; атрибут используется для добавления документации к модулю. &lt;code&gt;@doc&lt;/code&gt; используется перед функцией, чтобы предоставить для нее документацию. Помимо атрибутов, указанных выше, &lt;code&gt;@typedoc&lt;/code&gt; также может использоваться для прикрепления документации к типам, определенным как часть спецификаций типов. Elixir также позволяет прикреплять метаданные к документации, передавая список ключевых слов &lt;code&gt;@doc&lt;/code&gt; и друзьям.</target>
        </trans-unit>
        <trans-unit id="5c4c9561309d3048192c645c1b53867cd58046c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@spec&lt;/code&gt; above expresses that all types allowed to implement the given protocol are valid argument types for the given function.</source>
          <target state="translated">&lt;code&gt;@spec&lt;/code&gt; выше экспрессов , что все типы позволили реализовать данный протокол являются допустимыми типами аргументов для данной функции.</target>
        </trans-unit>
        <trans-unit id="4ecf8bb424c804cabf2a64179dad99d91c08aa50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@type&lt;/code&gt;, &lt;code&gt;@typep&lt;/code&gt;, and &lt;code&gt;@opaque&lt;/code&gt; module attributes can be used to define new types:</source>
          <target state="translated">В &lt;code&gt;@type&lt;/code&gt; , &lt;code&gt;@typep&lt;/code&gt; и &lt;code&gt;@opaque&lt;/code&gt; атрибуты модуля могут быть использованы для определения новых типов:</target>
        </trans-unit>
        <trans-unit id="525e602ced98f13bd5ecaf2f8ae5f13ce9d11d61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@typedoc&lt;/code&gt; attribute, similar to the &lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@moduledoc&lt;/code&gt; attributes, is used to document custom types.</source>
          <target state="translated">&lt;code&gt;@typedoc&lt;/code&gt; атрибут, похожий на &lt;code&gt;@doc&lt;/code&gt; и &lt;code&gt;@moduledoc&lt;/code&gt; атрибутов, используется для пользовательских типов документов.</target>
        </trans-unit>
        <trans-unit id="923172e1b194c31095f6b50cc3fcf7cd6864f7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@typedoc&lt;/code&gt; directive, similarly to the &lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@moduledoc&lt;/code&gt; directives, is used to document custom types.</source>
          <target state="translated">&lt;code&gt;@typedoc&lt;/code&gt; директива, аналогично &lt;code&gt;@doc&lt;/code&gt; и &lt;code&gt;@moduledoc&lt;/code&gt; директив, используется для пользовательских типов документов.</target>
        </trans-unit>
        <trans-unit id="a562fb60ef30731bd3203cf4bbff217d46bc1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Agent.update/3&lt;/code&gt; function accepts as a second argument any function that receives one argument and returns a value:</source>
          <target state="translated">Функция &lt;code&gt;Agent.update/3&lt;/code&gt; принимает в качестве второго аргумента любую функцию, которая получает один аргумент и возвращает значение:</target>
        </trans-unit>
        <trans-unit id="a63341783e3511427fe146f8a19ffd92af29382f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Agent.update/3&lt;/code&gt; function accepts as second argument any function that receives one argument and returns a value:</source>
          <target state="translated">Функция &lt;code&gt;Agent.update/3&lt;/code&gt; принимает в качестве второго аргумента любую функцию, которая получает один аргумент и возвращает значение:</target>
        </trans-unit>
        <trans-unit id="7a655503d2990c75edcb4c8b8a481ab364d1c5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config&lt;/code&gt; module in Elixir was introduced in v1.9 as a replacement to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt;, which was specific to Mix and has been deprecated.</source>
          <target state="translated">Модуль &lt;code&gt;Config&lt;/code&gt; в Elixir был представлен в v1.9 в качестве замены &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt; , который был специфичным для Mix и объявлен устаревшим.</target>
        </trans-unit>
        <trans-unit id="e27fe58053aba859d0bb7d011fc28980f6e9c181" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Enum&lt;/code&gt; module provides a huge range of functions to transform, sort, group, filter and retrieve items from enumerables. It is one of the modules developers use frequently in their Elixir code.</source>
          <target state="translated">Модуль &lt;code&gt;Enum&lt;/code&gt; предоставляет огромный набор функций для преобразования, сортировки, группировки, фильтрации и извлечения элементов из перечислимых объектов. Это один из модулей, которые разработчики часто используют в своем коде на Эликсире.</target>
        </trans-unit>
        <trans-unit id="1d4fbc9808f8e26c00c234d6fa1459002dc186de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;File&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; модуля</target>
        </trans-unit>
        <trans-unit id="e840334dc33e37be12e55cfa6bc3b7e8c169342a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; модуль</target>
        </trans-unit>
        <trans-unit id="ef38704061a34457ddb379b41a2b80be49207a37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Inspect&lt;/code&gt; protocol is the protocol used to transform any data structure into a readable textual representation. This is what tools like IEx use to print results:</source>
          <target state="translated">Протокол &lt;code&gt;Inspect&lt;/code&gt; - это протокол, используемый для преобразования любой структуры данных в читаемое текстовое представление. Вот что используют такие инструменты, как IEx, для печати результатов:</target>
        </trans-unit>
        <trans-unit id="867c539e4d21456c5aa36b2d220867f9a7212a1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;KV.RouterTest&lt;/code&gt; truly has to be distributed, as its purpose is to test the distribution. However, the test in &lt;code&gt;KVServerTest&lt;/code&gt; was only made distributed because we had a hardcoded distributed routing table, which we couldn&amp;rsquo;t configure, but now we can!</source>
          <target state="translated">&lt;code&gt;KV.RouterTest&lt;/code&gt; действительно должен быть распределен, так как его цель состоит в том, чтобы проверить распределение. Однако тест в &lt;code&gt;KVServerTest&lt;/code&gt; был сделан распределенным только потому, что у нас была жестко запрограммированная таблица распределенной маршрутизации, которую мы не могли настроить, но теперь можем!</target>
        </trans-unit>
        <trans-unit id="98cbbae17162ecee1b3987ff4642880f4c337dca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MyApp&lt;/code&gt; module given to &lt;code&gt;:mod&lt;/code&gt; needs to implement the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; behaviour. This can be done by putting &lt;code&gt;use Application&lt;/code&gt; in that module and implementing the &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback, for example:</source>
          <target state="translated">Модуль &lt;code&gt;MyApp&lt;/code&gt; , предоставленный &lt;code&gt;:mod&lt;/code&gt; , должен реализовывать поведение &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; . Это можно сделать, поместив &lt;code&gt;use Application&lt;/code&gt; в этот модуль и реализовав обратный вызов &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="eb345c09eb20de824e9541a17d7bf17e012b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; модуля</target>
        </trans-unit>
        <trans-unit id="c334edecfba6073bd7010af2e40dba91546f5ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; protocol can now be implemented for &lt;code&gt;Any&lt;/code&gt;:</source>
          <target state="translated">Протокол &lt;code&gt;Size&lt;/code&gt; теперь может быть реализован для &lt;code&gt;Any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e306d6fedad75e62089879bf19da4f3ec37aa79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; protocol expects a function called &lt;code&gt;size&lt;/code&gt; that receives one argument (the data structure we want to know the size of) to be implemented. We can now implement this protocol for the data structures that would have a compliant implementation:</source>
          <target state="translated">Протокол &lt;code&gt;Size&lt;/code&gt; ожидает, что будет реализована функция с именем &lt;code&gt;size&lt;/code&gt; , которая получает один аргумент (структуру данных, размер которой мы хотим знать). Теперь мы можем реализовать этот протокол для структур данных, которые будут иметь совместимую реализацию:</target>
        </trans-unit>
        <trans-unit id="db5fefc34081f3a8d848c3114be6230d0555c05c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User switch command&lt;/code&gt; can also be used to terminate an existing session, for example when the evaluator gets stuck in an infinite loop or when you are stuck typing an expression:</source>
          <target state="translated">Команду &lt;code&gt;User switch command&lt;/code&gt; также можно использовать для завершения существующего сеанса, например, когда оценщик застревает в бесконечном цикле или когда вы застряли при вводе выражения:</target>
        </trans-unit>
        <trans-unit id="7f41e81f3757a1435933e38bc5bfe28881ade0a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User switch command&lt;/code&gt; menu also allows developers to connect to remote shells using the &lt;code&gt;r&lt;/code&gt; command. A topic which we will discuss next.</source>
          <target state="translated">&lt;code&gt;User switch command&lt;/code&gt; меню также позволяет разработчикам подключаться к удаленным оболочкам с помощью &lt;code&gt;r&lt;/code&gt; команды. Тема, которую мы обсудим дальше.</target>
        </trans-unit>
        <trans-unit id="57c1d154dd951f8282bee6bdc6065d02cb12023d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[head | tail]&lt;/code&gt; format is not only used on pattern matching but also for prepending items to a list:</source>
          <target state="translated">&lt;code&gt;[head | tail]&lt;/code&gt; формат используется не только для сопоставления с образцом, но и для добавления элементов в список:</target>
        </trans-unit>
        <trans-unit id="fd1f98818191e0504c9112dc757cd520cf41584f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;after&lt;/code&gt; clause can be specified even if there are no match clauses. The timeout value given to &lt;code&gt;after&lt;/code&gt; can be any expression evaluating to one of the allowed values:</source>
          <target state="translated">Предложение &lt;code&gt;after&lt;/code&gt; может быть указано, даже если нет предложений соответствия. Значение тайм-аута, присвоенное &lt;code&gt;after&lt;/code&gt; , может быть любым выражением, оценивающим одно из допустимых значений:</target>
        </trans-unit>
        <trans-unit id="d4dc8c4ed1d9e88f4741236f5ec92ee315c9d28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;after&lt;/code&gt; clause will be executed regardless of whether or not the tried block succeeds. Note, however, that if a linked process exits, this process will exit and the &lt;code&gt;after&lt;/code&gt; clause will not get run. Thus &lt;code&gt;after&lt;/code&gt; provides only a soft guarantee. Luckily, files in Elixir are also linked to the current processes and therefore they will always get closed if the current process crashes, independent of the &lt;code&gt;after&lt;/code&gt; clause. You will find the same to be true for other resources like ETS tables, sockets, ports and more.</source>
          <target state="translated">Предложение &lt;code&gt;after&lt;/code&gt; будет выполнено независимо от того, успешен ли проверенный блок. Обратите внимание, однако, что если связанный процесс завершится, этот процесс завершится, а предложение &lt;code&gt;after&lt;/code&gt; не будет запущено. Таким образом, &lt;code&gt;after&lt;/code&gt; предоставляет только мягкую гарантию. К счастью, файлы в Elixir также связаны с текущими процессами, и поэтому они всегда будут закрыты, если текущий процесс выйдет из строя, независимо от предложения &lt;code&gt;after&lt;/code&gt; . Вы обнаружите, что то же самое верно и для других ресурсов, таких как таблицы ETS, сокеты, порты и многое другое.</target>
        </trans-unit>
        <trans-unit id="522546706684271ab3f2efbb350890fbe1239f1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assigns&lt;/code&gt; extension is useful when the number of variables required by the template is not specified at compilation time.</source>
          <target state="translated">Расширение &lt;code&gt;assigns&lt;/code&gt; полезно, когда количество переменных, требуемых шаблоном, не указано во время компиляции.</target>
        </trans-unit>
        <trans-unit id="20b542c507c9f404606e6129f6dd5795d8b21d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binding&lt;/code&gt; argument is a keyword list of variable bindings. The &lt;code&gt;opts&lt;/code&gt; argument is a keyword list of environment options.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; аргумент является списком ключевых слов привязок переменных. &lt;code&gt;opts&lt;/code&gt; аргументом является список ключевых слов из вариантов среды.</target>
        </trans-unit>
        <trans-unit id="f9ca71e42e6855918a8f26e42f0cc7edcc80187e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binding&lt;/code&gt; argument is a list of variable bindings. The &lt;code&gt;opts&lt;/code&gt; argument is a keyword list of environment options.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; аргумент является списком привязок переменных. &lt;code&gt;opts&lt;/code&gt; аргументом является список ключевых слов из вариантов среды.</target>
        </trans-unit>
        <trans-unit id="43af9d9f02afe40e3a624713286d4df36015f946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause also supports &lt;code&gt;:error&lt;/code&gt; alongside &lt;code&gt;:exit&lt;/code&gt; and &lt;code&gt;:throw&lt;/code&gt; as in Erlang, although this is commonly avoided in favor of &lt;code&gt;raise&lt;/code&gt;/&lt;code&gt;rescue&lt;/code&gt; control mechanisms. One reason for this is that when catching &lt;code&gt;:error&lt;/code&gt;, the error is not automatically transformed into an Elixir error:</source>
          <target state="translated">Предложение &lt;code&gt;catch&lt;/code&gt; также поддерживает &lt;code&gt;:error&lt;/code&gt; вместе с &lt;code&gt;:exit&lt;/code&gt; и &lt;code&gt;:throw&lt;/code&gt; , как в Erlang, хотя этого обычно избегают в пользу механизмов управления &lt;code&gt;raise&lt;/code&gt; / &lt;code&gt;rescue&lt;/code&gt; . Одна из причин этого заключается в том, что при перехвате &lt;code&gt;:error&lt;/code&gt; ошибка не преобразуется автоматически в ошибку Elixir:</target>
        </trans-unit>
        <trans-unit id="efeea9a7b42fc8c994bd1aa663c47cac8fa65f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause also supports catching exits and errors. To do that, it allows matching on both the &lt;em&gt;kind&lt;/em&gt; of the caught value as well as the value itself:</source>
          <target state="translated">Предложение &lt;code&gt;catch&lt;/code&gt; также поддерживает перехват выходов и ошибок. Для этого он позволяет сопоставить как &lt;em&gt;вид&lt;/em&gt; пойманного значения, так и само значение:</target>
        </trans-unit>
        <trans-unit id="24330da6829bfcedd43d719e9d8c6b8cc77a9453" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause can be used to catch thrown values, exits, and errors.</source>
          <target state="translated">Предложение &lt;code&gt;catch&lt;/code&gt; можно использовать для перехвата выброшенных значений, выходов и ошибок.</target>
        </trans-unit>
        <trans-unit id="8d2397a8238f753aef5def5de423d0f7288e2079" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;child_spec/1&lt;/code&gt; function returns the child specification which describes how to start the process, if the process is a worker or a supervisor, if the process is temporary, transient or permanent and so on. The &lt;code&gt;child_spec/1&lt;/code&gt; function is automatically defined when we &lt;code&gt;use Agent&lt;/code&gt;, &lt;code&gt;use GenServer&lt;/code&gt;, &lt;code&gt;use Supervisor&lt;/code&gt;, etc. Let&amp;rsquo;s give it a try in the terminal with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;child_spec/1&lt;/code&gt; возвращает дочернюю спецификацию, которая описывает, как запустить процесс, если процесс является рабочим или супервизором, если процесс временный, переходный или постоянный и так далее. Функция &lt;code&gt;child_spec/1&lt;/code&gt; автоматически определяется, когда мы &lt;code&gt;use Agent&lt;/code&gt; , &lt;code&gt;use GenServer&lt;/code&gt; , &lt;code&gt;use Supervisor&lt;/code&gt; и т. Д. Давайте попробуем в терминале с помощью &lt;code&gt;iex -S mix&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5076e4aa7f98418aab62c50ce92daa399ad148af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;datetime&lt;/code&gt; is expected to be using the ISO calendar with a year greater than or equal to 0.</source>
          <target state="translated">Ожидается, что &lt;code&gt;datetime&lt;/code&gt; будет использовать календарь ISO с годом больше или равным 0.</target>
        </trans-unit>
        <trans-unit id="a7470ce899e96bb2d28a9c1301a9927e4e0d7efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of bytes or line by line if &lt;code&gt;:line&lt;/code&gt; is given. Alternatively, if &lt;code&gt;:all&lt;/code&gt; is given, then whole &lt;code&gt;device&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; итеративно с помощью заданного числа байт или строки за строкой , если &lt;code&gt;:line&lt;/code&gt; задаются. В качестве альтернативы, если задано &lt;code&gt;:all&lt;/code&gt; , возвращается все &lt;code&gt;device&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18926bc10cd79bf34225eb9fdce31365b1c6d418" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of bytes or line by line if &lt;code&gt;:line&lt;/code&gt; is given. This reads from the IO device as a raw binary.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; итеративно с помощью заданного числа байт или строки за строкой , если &lt;code&gt;:line&lt;/code&gt; задаются. Это считывается с устройства ввода-вывода как необработанный двоичный файл.</target>
        </trans-unit>
        <trans-unit id="d123d0b725ad2bf46d13d4f89ecd59664f74da3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of characters or line by line if &lt;code&gt;:line&lt;/code&gt; is given.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; итеративно по заданному количеству символов или построчно , если &lt;code&gt;:line&lt;/code&gt; дается.</target>
        </trans-unit>
        <trans-unit id="8d73a8d9622fd3342e8e37363bb8e4678e91ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of characters or line by line if &lt;code&gt;:line&lt;/code&gt; is given. Alternatively, if &lt;code&gt;:all&lt;/code&gt; is given, then whole &lt;code&gt;device&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; итеративно по заданному количеству символов или построчно , если &lt;code&gt;:line&lt;/code&gt; дается. В качестве альтернативы, если задано &lt;code&gt;:all&lt;/code&gt; , возвращается все &lt;code&gt;device&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd6d16ba352ae3e2cd0c595b6f985cf5e9830dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do:&lt;/code&gt; and &lt;code&gt;else:&lt;/code&gt; pairs form a keyword list! In fact, the call above is equivalent to:</source>
          <target state="translated">&lt;code&gt;do:&lt;/code&gt; и &lt;code&gt;else:&lt;/code&gt; пары образуют список ключевых слов! Фактически, приведенный выше вызов эквивалентен:</target>
        </trans-unit>
        <trans-unit id="814c3b44f539cbabd4a18b1a20149ed63266fd5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doctest&lt;/code&gt; macro loops through all functions and macros defined in &lt;code&gt;MyModule&lt;/code&gt;, parsing their documentation in search of code examples.</source>
          <target state="translated">В &lt;code&gt;doctest&lt;/code&gt; макро петли через все функции и макросы определены в &lt;code&gt;MyModule&lt;/code&gt; , разбор их документации в поисках примеров кода.</target>
        </trans-unit>
        <trans-unit id="c8fc7f9dce0c33872417dd46af42c25ac3d59fce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; is used to set environment variables. In there, you can set vars such as &lt;code&gt;RELEASE_NODE&lt;/code&gt;, &lt;code&gt;RELEASE_COOKIE&lt;/code&gt;, and &lt;code&gt;RELEASE_TMP&lt;/code&gt; to customize your node name, cookie and tmp directory respectively. Whenever &lt;code&gt;env.sh&lt;/code&gt; or &lt;code&gt;env.bat&lt;/code&gt; is invoked, the variables &lt;code&gt;RELEASE_ROOT&lt;/code&gt;, &lt;code&gt;RELEASE_NAME&lt;/code&gt;, &lt;code&gt;RELEASE_VSN&lt;/code&gt;, and &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; have already been set, so you can rely on them. See the section on environment variables for more information.</source>
          <target state="translated">&lt;code&gt;env.sh&lt;/code&gt; и &lt;code&gt;env.bat&lt;/code&gt; используются для установки переменных окружения. Там вы можете установить переменные, такие как &lt;code&gt;RELEASE_NODE&lt;/code&gt; , &lt;code&gt;RELEASE_COOKIE&lt;/code&gt; и &lt;code&gt;RELEASE_TMP&lt;/code&gt; , чтобы настроить имя вашего узла, файл cookie и каталог tmp соответственно. Каждый раз, когда &lt;code&gt;env.sh&lt;/code&gt; или &lt;code&gt;env.bat&lt;/code&gt; , переменные &lt;code&gt;RELEASE_ROOT&lt;/code&gt; , &lt;code&gt;RELEASE_NAME&lt;/code&gt; , &lt;code&gt;RELEASE_VSN&lt;/code&gt; и &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; уже были установлены, поэтому вы можете положиться на них. См. Раздел о переменных среды для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d34a58294096caa28e71e9a15e38240b2916397f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eval&lt;/code&gt; command starts its own instance of the VM but without starting any of the applications in the release and without starting distribution. For example, if you need to do some prep work before running the actual system, like migrating your database, &lt;code&gt;eval&lt;/code&gt; can be a good fit. Just keep in mind any application you may use during eval has to be explicitly loaded and/or started.</source>
          <target state="translated">Команда &lt;code&gt;eval&lt;/code&gt; запускает собственный экземпляр виртуальной машины, но без запуска каких-либо приложений в выпуске и без запуска распространения. Например, если вам нужно выполнить некоторую подготовительную работу перед запуском реальной системы, например, перенести базу данных, &lt;code&gt;eval&lt;/code&gt; может подойти. Просто имейте в виду, что любое приложение, которое вы можете использовать во время eval, должно быть явно загружено и / или запущено.</target>
        </trans-unit>
        <trans-unit id="d7d3bd404eb61a5ace38bb205d91cc9fe9dacd66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; argument is usually a keyword list with field names as atom keys and default values as corresponding values. &lt;a href=&quot;#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct's field names and they will all default to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; аргумент, как правило, список ключевых слов с именами полей в качестве ключей атома и значения по умолчанию , как соответствующие значения. &lt;a href=&quot;#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt; также поддерживает список атомов в качестве аргумента: в этом случае атомы в списке будут использоваться в качестве имен полей структуры, и все они будут по умолчанию &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f8139dc2ac79685ca13901ec7c7e0bf0f70fcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;container&lt;/code&gt;) and must return a two-element tuple &lt;code&gt;{get_value, update_value}&lt;/code&gt;: the &quot;get&quot; value &lt;code&gt;get_value&lt;/code&gt; (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; (&lt;code&gt;update_value&lt;/code&gt;). &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value should be removed from the container and returned.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; аргумент получает значение &lt;code&gt;key&lt;/code&gt; (или &lt;code&gt;nil&lt;/code&gt; , если &lt;code&gt;key&lt;/code&gt; не присутствует в &lt;code&gt;container&lt;/code&gt; ) и должен возвращать два элемента кортежа &lt;code&gt;{get_value, update_value}&lt;/code&gt; : &amp;laquo;Получить&amp;raquo; значение &lt;code&gt;get_value&lt;/code&gt; (полученное значение, которое может работать на перед тем возвращается) и новое значение, которое будет сохранено под &lt;code&gt;key&lt;/code&gt; ( &lt;code&gt;update_value&lt;/code&gt; ). &lt;code&gt;fun&lt;/code&gt; также может возвращать &lt;code&gt;:pop&lt;/code&gt; , что означает, что текущее значение должно быть удалено из контейнера и возвращено.</target>
        </trans-unit>
        <trans-unit id="ab82e984fadbbf0154d9f589974323854d91ddd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return one of the following values:</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; аргумент получает значение &lt;code&gt;key&lt;/code&gt; (или &lt;code&gt;nil&lt;/code&gt; , если &lt;code&gt;key&lt;/code&gt; не присутствует) и должен возвращать одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="15ae90181c3399df6f57363e86986a58cdd69c58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inspect/1&lt;/code&gt; function is used to convert a data structure&amp;rsquo;s internal representation into a string, typically for printing. Notice that when the &lt;code&gt;receive&lt;/code&gt; block gets executed the sender process we have spawned may already be dead, as its only instruction was to send a message.</source>
          <target state="translated">Функция &lt;code&gt;inspect/1&lt;/code&gt; используется для преобразования внутреннего представления структуры данных в строку, обычно для печати. Обратите внимание, что когда выполняется блок &lt;code&gt;receive&lt;/code&gt; , порожденный нами процесс-отправитель может уже быть мертвым, поскольку его единственной инструкцией была отправка сообщения.</target>
        </trans-unit>
        <trans-unit id="409be34f87b611c8cf8263c5eb6c08385aeb1ddd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;install&lt;/code&gt; command must be executed as an administrator.</source>
          <target state="translated">Команду &lt;code&gt;install&lt;/code&gt; необходимо выполнять от имени администратора.</target>
        </trans-unit>
        <trans-unit id="b4ef8eb0a2e7ca9a57a606a0bc63171348ce16a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/kv.ex&lt;/code&gt; file was compiled, an application manifest named &lt;code&gt;kv.app&lt;/code&gt; was generated and &lt;a href=&quot;../protocols#protocol-consolidation&quot;&gt;all protocols were consolidated as described in the Getting Started guide&lt;/a&gt;. All compilation artifacts are placed inside the &lt;code&gt;_build&lt;/code&gt; directory using the options defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;lib/kv.ex&lt;/code&gt; файл был скомпилирован, приложение манифест под названием &lt;code&gt;kv.app&lt;/code&gt; был создан и &lt;a href=&quot;../protocols#protocol-consolidation&quot;&gt;все протоколы были объединены , как описано в руководстве Приступая к работе&lt;/a&gt; . Все артефакты компиляции помещаются в каталог &lt;code&gt;_build&lt;/code&gt; с использованием параметров, определенных в файле &lt;code&gt;mix.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afab5577848b6315338da48841f3a29c305f64dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/kv.ex&lt;/code&gt; file was compiled, an application manifest named &lt;code&gt;kv.app&lt;/code&gt; was generated. All compilation artifacts are placed inside the &lt;code&gt;_build&lt;/code&gt; directory using the options defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;lib/kv.ex&lt;/code&gt; файл был скомпилирован, приложение манифест под названием &lt;code&gt;kv.app&lt;/code&gt; был создан. Все артефакты компиляции помещаются в каталог &lt;code&gt;_build&lt;/code&gt; с использованием параметров, определенных в файле &lt;code&gt;mix.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb93b5ae3cb838786493785c00bd4b6f99477ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line_or_bytes&lt;/code&gt; argument configures how the file is read when streaming, by &lt;code&gt;:line&lt;/code&gt; (default) or by a given number of bytes.</source>
          <target state="translated">&lt;code&gt;line_or_bytes&lt;/code&gt; аргумент определяет , как файл считывается при потоковой передаче, с помощью &lt;code&gt;:line&lt;/code&gt; ( по умолчанию) или на заданное число байтов.</target>
        </trans-unit>
        <trans-unit id="fe606eea5a853797263dc491beb562e8cbcc73c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logger&lt;/code&gt; application ships as part of Elixir. We stated that our application needs it by specifying it in the &lt;code&gt;:extra_applications&lt;/code&gt; list in &lt;code&gt;mix.exs&lt;/code&gt;. See the &lt;a href=&quot;https://hexdocs.pm/logger&quot;&gt;official docs&lt;/a&gt; for more information.</source>
          <target state="translated">Приложение &lt;code&gt;logger&lt;/code&gt; входит в состав Elixir. Мы заявили, что он нужен нашему приложению, указав его в списке &lt;code&gt;:extra_applications&lt;/code&gt; в &lt;code&gt;mix.exs&lt;/code&gt; . См. &lt;a href=&quot;https://hexdocs.pm/logger&quot;&gt;Официальную документацию&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="54af23949bca7ed78e1b2333920d90c038af7ad6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mix test&lt;/code&gt; command also allows us to dynamically include and exclude tags. For example, we can run &lt;code&gt;$ mix test --include distributed&lt;/code&gt; to run distributed tests regardless of the value set in &lt;code&gt;test/test_helper.exs&lt;/code&gt;. We could also pass &lt;code&gt;--exclude&lt;/code&gt; to exclude a particular tag from the command line. Finally, &lt;code&gt;--only&lt;/code&gt; can be used to run only tests with a particular tag:</source>
          <target state="translated">Команда &lt;code&gt;mix test&lt;/code&gt; также позволяет нам динамически включать и исключать теги. Например, мы можем запустить &lt;code&gt;$ mix test --include distributed&lt;/code&gt; для запуска распределенных тестов независимо от значения, установленного в &lt;code&gt;test/test_helper.exs&lt;/code&gt; . Мы также можем передать &lt;code&gt;--exclude&lt;/code&gt; , чтобы исключить определенный тег из командной строки. Наконец, &lt;code&gt;--only&lt;/code&gt; можно использовать только для запуска тестов с определенным тегом:</target>
        </trans-unit>
        <trans-unit id="75c3e7f0c2115829278fc15321400f8791e52369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mod&lt;/code&gt; key of an application resource file configures an application callback module and start argument:</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; ключ файл ресурсов приложения настраивает модуль обратного вызова приложений и начать аргумент:</target>
        </trans-unit>
        <trans-unit id="9164f612584725a4293d48491d9ba4d200ea917a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; received by this function are also supported by &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;options&lt;/code&gt; полученные этой функцией, также поддерживаются &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cefbaf0f99d8706ada7dd49301877753ff097956" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; received by this function are also supported by &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;options&lt;/code&gt; полученные этой функцией, также поддерживаются &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64284a2724bf8bf1be42ef3f1c05bbea72ce9fee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; is not received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; аргумент должен быть образцом матча. Терпит неудачу с &lt;code&gt;failure_message&lt;/code&gt; , если соответствующее сообщения &lt;code&gt;pattern&lt;/code&gt; не получена.</target>
        </trans-unit>
        <trans-unit id="306d8664f10996ce7979609652732704d345ac55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; is received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; аргумент должен быть образцом матча. Терпит неудачу с &lt;code&gt;failure_message&lt;/code&gt; , если соответствующий сообщение &lt;code&gt;pattern&lt;/code&gt; принимается.</target>
        </trans-unit>
        <trans-unit id="e0b8cb821a5d5214e8e6bc4e51c9c7ff6f736aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; was not received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; аргумент должен быть образцом матча. Отклоняет сообщение с &lt;code&gt;failure_message&lt;/code&gt; если не было получено сообщение, соответствующее &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05af0549cba6832bb035eed4973d7149b45f6ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; was received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; аргумент должен быть образцом матча. Отключает сообщение с &lt;code&gt;failure_message&lt;/code&gt; если было получено сообщение, соответствующее &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df3b9d4931bcfe8e3dcb9ad739101300cbf08327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; may be a string, a list of strings, a regular expression, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; может быть строка, список строк, регулярное выражение, или скомпилированный шаблон.</target>
        </trans-unit>
        <trans-unit id="9712132d8ecb090f4be0f4f06a8c889cede54cae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; may be a string, a regular expression, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; может быть строкой, регулярное выражение, или скомпилированный шаблон.</target>
        </trans-unit>
        <trans-unit id="f1e822b0c23d86ef4a2e7320c3e2f68f5b6a5886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_line/1&lt;/code&gt; implementation receives data from the socket using &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; and &lt;code&gt;write_line/2&lt;/code&gt; writes to the socket using &lt;code&gt;:gen_tcp.send/2&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;read_line/1&lt;/code&gt; получает данные из сокета, используя &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; , а &lt;code&gt;write_line/2&lt;/code&gt; записывает в сокет, используя &lt;code&gt;:gen_tcp.send/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4738ad60c532661639b80291c79bbfd95de51f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replacement&lt;/code&gt; may be a string or a function that receives the matched pattern and must return the replacement as a string or iodata.</source>
          <target state="translated">&lt;code&gt;replacement&lt;/code&gt; может быть строкой или функция , которая получает подходящий шаблон и должен возвратить замену в виде строки или iodata.</target>
        </trans-unit>
        <trans-unit id="9c0458fa683a21c30d6bb8dd696e33377e0fc149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rescue&lt;/code&gt; clause is used to handle exceptions while the &lt;code&gt;catch&lt;/code&gt; clause can be used to catch thrown values and exits. The &lt;code&gt;else&lt;/code&gt; clause can be used to control flow based on the result of the expression. &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; clauses work based on pattern matching (similar to the &lt;code&gt;case&lt;/code&gt; special form).</source>
          <target state="translated">Предложение &lt;code&gt;rescue&lt;/code&gt; используется для обработки исключений, в то время как предложение &lt;code&gt;catch&lt;/code&gt; может использоваться для перехвата выброшенных значений и выхода. Предложение &lt;code&gt;else&lt;/code&gt; может использоваться для управления потоком на основе результата выражения. &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;rescue&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; работают на основе сопоставления с образцом (аналогично специальной форме &lt;code&gt;case&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d1df58d3bea703fd1bbf8c012df285de49b968d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup_all&lt;/code&gt; callbacks are invoked only once per module, before any test is run. All &lt;code&gt;setup&lt;/code&gt; callbacks are run before each test. No callback is run if the test case has no tests or all tests have been filtered out.</source>
          <target state="translated">В &lt;code&gt;setup_all&lt;/code&gt; обратных вызовов вызываются только один раз для каждого модуля, прежде чем любой тест запускается. Все обратные вызовы &lt;code&gt;setup&lt;/code&gt; выполняются перед каждым тестом. Обратный вызов не запускается, если в тестовом примере нет тестов или все тесты были отфильтрованы.</target>
        </trans-unit>
        <trans-unit id="bd0f9431cca0c37985b6fe072752b25bee336f01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; value returned by this function is used for boundary checks, therefore it is extremely important that this function only returns &lt;code&gt;:ok&lt;/code&gt; if retrieving the &lt;code&gt;size&lt;/code&gt; of the &lt;code&gt;enumerable&lt;/code&gt; is cheap, fast and takes constant time. Otherwise the simplest of operations, such as &lt;code&gt;Enum.at(enumerable, 0)&lt;/code&gt;, will become too expensive.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; значение , возвращаемое этой функцией используется для граничных проверок, поэтому крайне важно , что эта функция возвращает только &lt;code&gt;:ok&lt;/code&gt; , если извлекая &lt;code&gt;size&lt;/code&gt; в &lt;code&gt;enumerable&lt;/code&gt; дешево, быстро и занимает постоянное время. В противном случае простейшие операции, такие как &lt;code&gt;Enum.at(enumerable, 0)&lt;/code&gt; , станут слишком дорогими.</target>
        </trans-unit>
        <trans-unit id="c3101c570b674a9ec75b76ebada532649060afec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spec&lt;/code&gt; consists of a list of three part tuples, in the shape of &lt;code&gt;[{match_pattern, guards, body}]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; состоят из списка из трех частей кортежей, в виде &lt;code&gt;[{match_pattern, guards, body}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135f720ae9d7a6885e26e8bce732a1ea91412353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; position is a number &lt;code&gt;&amp;gt;= 0&lt;/code&gt; and guaranteed to exist in the &lt;code&gt;enumerable&lt;/code&gt;. The length is a number &lt;code&gt;&amp;gt;= 1&lt;/code&gt; in a way that &lt;code&gt;start + length &amp;lt;= count&lt;/code&gt;, where &lt;code&gt;count&lt;/code&gt; is the maximum amount of elements in the enumerable.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; позиция представляет собой число &lt;code&gt;&amp;gt;= 0&lt;/code&gt; и гарантированно существует в &lt;code&gt;enumerable&lt;/code&gt; . Длина - это число &lt;code&gt;&amp;gt;= 1&lt;/code&gt; таким образом, что &lt;code&gt;start + length &amp;lt;= count&lt;/code&gt; , где &lt;code&gt;count&lt;/code&gt; - максимальное количество элементов в перечисляемом.</target>
        </trans-unit>
        <trans-unit id="e168d9178d44f7f46283a9cdf56615be6a7637ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_link/1&lt;/code&gt; (or a custom) is then called for each child process. The &lt;code&gt;start_link/1&lt;/code&gt; function must return &lt;code&gt;{:ok, pid}&lt;/code&gt; where &lt;code&gt;pid&lt;/code&gt; is the process identifier of a new process that is linked to the supervisor. The child process usually starts its work by executing the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback. Generally speaking, the &lt;code&gt;init&lt;/code&gt; callback is where we initialize and configure the child process.</source>
          <target state="translated">Затем для каждого дочернего процесса &lt;code&gt;start_link/1&lt;/code&gt; (или custom). Функция &lt;code&gt;start_link/1&lt;/code&gt; должна возвращать &lt;code&gt;{:ok, pid}&lt;/code&gt; где &lt;code&gt;pid&lt;/code&gt; - это идентификатор нового процесса, который связан с супервизором. Дочерний процесс обычно начинает свою работу с выполнения обратного вызова &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; . Вообще говоря, обратный вызов &lt;code&gt;init&lt;/code&gt; - это то место, где мы инициализируем и настраиваем дочерний процесс.</target>
        </trans-unit>
        <trans-unit id="a8a0cec068e183c964ba134c5b70d885df25681c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_supervised!&lt;/code&gt; function was injected into our test module by &lt;code&gt;use ExUnit.Case&lt;/code&gt;. It does the job of starting the &lt;code&gt;KV.Registry&lt;/code&gt; process, by calling its &lt;code&gt;start_link/1&lt;/code&gt; function. The advantage of using &lt;code&gt;start_supervised!&lt;/code&gt; is that ExUnit will guarantee that the registry process will be shutdown &lt;strong&gt;before&lt;/strong&gt; the next test starts. In other words, it helps guarantee that the state of one test is not going to interfere with the next one in case they depend on shared resources.</source>
          <target state="translated">&lt;code&gt;start_supervised!&lt;/code&gt; функция была &lt;code&gt;use ExUnit.Case&lt;/code&gt; в наш тестовый модуль с помощью ExUnit.Case . Он &lt;code&gt;KV.Registry&lt;/code&gt; процесс KV.Registry , вызывая его &lt;code&gt;start_link/1&lt;/code&gt; . Преимущество использования &lt;code&gt;start_supervised!&lt;/code&gt; заключается в том, что ExUnit гарантирует, что процесс реестра будет завершен &lt;strong&gt;до&lt;/strong&gt; начала следующего теста. Другими словами, это помогает гарантировать, что состояние одного теста не будет мешать следующему, если они зависят от общих ресурсов.</target>
        </trans-unit>
        <trans-unit id="b4592fb7e0957a1fc52071c848d5e17c99c69385" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;starting_on&lt;/code&gt; represents the starting day of the week. All calendars must support at least the &lt;code&gt;:default&lt;/code&gt; value. They may also support other values representing their days of the week.</source>
          <target state="translated">&lt;code&gt;starting_on&lt;/code&gt; представляет начальный день недели. Все календари должны поддерживать как минимум значение &lt;code&gt;:default&lt;/code&gt; . Они также могут поддерживать другие значения, представляющие их дни недели.</target>
        </trans-unit>
        <trans-unit id="7c3b0210439efc565cc631c8fa0e308643197cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string()&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;string()&lt;/code&gt; тип</target>
        </trans-unit>
        <trans-unit id="61ebcef3a8537f672d50ed7bff3d6db73d860578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; argument may be an atom (which defines &lt;code&gt;defstruct&lt;/code&gt;) or a &lt;code&gt;struct&lt;/code&gt; itself. The second argument is any &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that emits two-element tuples (key-value pairs) during enumeration.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; аргумент может быть атом (который определяет &lt;code&gt;defstruct&lt;/code&gt; ) или - &lt;code&gt;struct&lt;/code&gt; самого. Второй аргумент - это любой &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; ,&lt;/a&gt; который генерирует двухэлементные кортежи (пары ключ-значение) во время перечисления.</target>
        </trans-unit>
        <trans-unit id="38386201665d1e0b386055fc8c5fb1dd196e0581" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; argument may be an atom (which defines &lt;code&gt;defstruct&lt;/code&gt;) or a &lt;code&gt;struct&lt;/code&gt; itself. The second argument is any &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that emits two-element tuples (key-value pairs) during enumeration.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; аргумент может быть атом (который определяет &lt;code&gt;defstruct&lt;/code&gt; ) или - &lt;code&gt;struct&lt;/code&gt; самого. Второй аргумент - это любой &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; ,&lt;/a&gt; который генерирует двухэлементные кортежи (пары ключ-значение) во время перечисления.</target>
        </trans-unit>
        <trans-unit id="3ca4af46f233ac35dc3b79485d62ec51b88145af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subject&lt;/code&gt; is always a string.</source>
          <target state="translated">&lt;code&gt;subject&lt;/code&gt; всегда является строкой.</target>
        </trans-unit>
        <trans-unit id="bae6804f43f42b63c5528bcc2381471d0d39bad4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task will still be linked to the caller, see &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information and &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt; for a non-linked variant.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; должен быть ссылкой , как это определено в &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . Задача по-прежнему будет связана с вызывающей стороной, см. &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации и &lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt; для несвязанного варианта.</target>
        </trans-unit>
        <trans-unit id="08337e923feb72c49328d32727f3434709f1f848" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task won't be linked to the caller, see &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; должен быть ссылкой , как это определено в &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . Задача не будет связана с вызывающей стороной, см. &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="fa2ecf30353c15851b99330eab13deee5216e86a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task will still be linked to the caller, see &lt;a href=&quot;task#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information and &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt; for a non-linked variant.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; должен быть ссылкой , как это определено в &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . Задача по-прежнему будет связана с вызывающим, см. &lt;a href=&quot;task#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации и &lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt; для несвязанного варианта.</target>
        </trans-unit>
        <trans-unit id="549a87864f7a5407aab555d12f030b23c5278a92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task won't be linked to the caller, see &lt;a href=&quot;task#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; должен быть ссылкой , как это определено в &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . Задача не будет связана с вызывающим абонентом, см &lt;a href=&quot;task#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="bc1957bc0923712dab3fe287b0e8df3bec3ec39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; macro</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; макро</target>
        </trans-unit>
        <trans-unit id="6bf883ffd229719baaf3e026049bc07e3e3fdc26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument passed to &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; is usually &lt;code&gt;:normal&lt;/code&gt; unless in a distributed setup where application takeovers and failovers are configured. Distributed applications are beyond the scope of this documentation.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; аргумент , передаваемый &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; , как правило &lt;code&gt;:normal&lt;/code&gt; , если в распределенной установке , где захваты приложений и сбой не настроены. Распределенные приложения выходят за рамки этой документации.</target>
        </trans-unit>
        <trans-unit id="69149411f0751c47ab43a2cb8ee2352867ce8c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument specifies the type of the application:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; аргумент определяет тип приложения:</target>
        </trans-unit>
        <trans-unit id="f6663df984e95662866d3ab67e965809a6b673af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update_in/2&lt;/code&gt; macro is similar but allows us to pass a function that controls how the value changes. For example, let&amp;rsquo;s remove &amp;ldquo;Clojure&amp;rdquo; from Mary&amp;rsquo;s list of languages:</source>
          <target state="translated">&lt;code&gt;update_in/2&lt;/code&gt; макрос похож , но позволяет передать функцию , которая определяет , как изменяется значение. Например, удалим Clojure из списка языков Мэри:</target>
        </trans-unit>
        <trans-unit id="8f6feff517dde91abd98ddcc94fc5f8ee947ce68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; macro is frequently used as an extension point. This means that, when you &lt;code&gt;use&lt;/code&gt; a module &lt;code&gt;FooBar&lt;/code&gt;, you allow that module to inject &lt;em&gt;any&lt;/em&gt; code in the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; макросов часто используется в качестве точки расширения. Это означает, что когда вы &lt;code&gt;use&lt;/code&gt; модуль &lt;code&gt;FooBar&lt;/code&gt; , вы разрешаете этому модулю внедрять &lt;em&gt;любой&lt;/em&gt; код в текущий модуль, например, импортировать себя или другие модули, определять новые функции, устанавливать состояние модуля и т. Д.</target>
        </trans-unit>
        <trans-unit id="443668287cbb8f84b2664ce3f01400a9552185b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt; types are for Unicode code points. They can also be applied to literal strings and charlists:</source>
          <target state="translated">В &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; и &lt;code&gt;utf32&lt;/code&gt; типов для кодовых точек Unicode. Они также могут применяться к буквальным строкам и спискам символов:</target>
        </trans-unit>
        <trans-unit id="d593cc256ac243970966e445b59ce382b3d1c4ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vm.args&lt;/code&gt; file may contain any of the VM flags accepted by the &lt;a href=&quot;http://erlang.org/doc/man/erl.html&quot;&gt;&lt;code&gt;erl&lt;/code&gt; command&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;vm.args&lt;/code&gt; файл может содержать любого из флагов VM , принятых &lt;a href=&quot;http://erlang.org/doc/man/erl.html&quot;&gt; &lt;code&gt;erl&lt;/code&gt; команды&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="766b25b711b24bf14734bf86264816b50201e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xref&lt;/code&gt; task expects a mode as first argument:</source>
          <target state="translated">Задача &lt;code&gt;xref&lt;/code&gt; ожидает режим в качестве первого аргумента:</target>
        </trans-unit>
        <trans-unit id="848f828061a57fea28024ac6791811ddcc578da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{module, function}&lt;/code&gt; will be invoked with four arguments:</source>
          <target state="translated">&lt;code&gt;{module, function}&lt;/code&gt; будет вызываться с четырьмя аргументами:</target>
        </trans-unit>
        <trans-unit id="6bb6f7b835bb4273bfb73268cdb830e1eaa1b0c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&amp;gt;&lt;/code&gt; operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline:</source>
          <target state="translated">Оператор &lt;code&gt;|&amp;gt;&lt;/code&gt; в основном полезен, когда есть желание выполнить серию операций, напоминающих конвейер:</target>
        </trans-unit>
        <trans-unit id="e7c15f5a444d0eb501f58185ab4ff6cc148686d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&amp;gt;&lt;/code&gt; symbol used in the snippet above is the &lt;strong&gt;pipe operator&lt;/strong&gt;: it takes the output from the expression on its left side and passes it as the first argument to the function call on its right side. It&amp;rsquo;s similar to the Unix &lt;code&gt;|&lt;/code&gt; operator. Its purpose is to highlight the data being transformed by a series of functions. To see how it can make the code cleaner, have a look at the example above rewritten without using the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator:</source>
          <target state="translated">Символ &lt;code&gt;|&amp;gt;&lt;/code&gt; , использованный в приведенном выше фрагменте, является &lt;strong&gt;оператором канала&lt;/strong&gt; : он принимает выходные данные из выражения с левой стороны и передает их в качестве первого аргумента в вызов функции с правой стороны. Это похоже на Unix &lt;code&gt;|&lt;/code&gt; оператор. Его цель - выделить данные, преобразованные с помощью ряда функций. Чтобы увидеть, как это может сделать код чище, взгляните на приведенный выше пример, переписанный без использования оператора &lt;code&gt;|&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="de83fadff1ba2a72273182089ea2a050990085bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~c&lt;/code&gt; sigil is useful for generating char lists that contain single quotes:</source>
          <target state="translated">&lt;code&gt;~c&lt;/code&gt; сигила полезен для создания списков полукокса , которые содержат одиночные кавычки:</target>
        </trans-unit>
        <trans-unit id="281b4a2fc5fd64a2cedf95577018a34d44729cd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~s&lt;/code&gt; sigil is used to generate strings, like double quotes are. The &lt;code&gt;~s&lt;/code&gt; sigil is useful when a string contains double quotes:</source>
          <target state="translated">В &lt;code&gt;~s&lt;/code&gt; сигила используется для генерации строк, как двойные кавычки. Символ &lt;code&gt;~s&lt;/code&gt; полезен, когда строка содержит двойные кавычки:</target>
        </trans-unit>
        <trans-unit id="1b5ce296d52d56b387e6952a8ac2c01f7f747b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~w&lt;/code&gt; sigil also accepts the &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; modifiers (for char lists, strings, and atoms, respectively), which specify the data type of the elements of the resulting list:</source>
          <target state="translated">Символ &lt;code&gt;~w&lt;/code&gt; также принимает модификаторы &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; (для списков символов, строк и атомов соответственно), которые определяют тип данных элементов результирующего списка:</target>
        </trans-unit>
        <trans-unit id="9578a70bcff0146fc766139c2fb2691deada995b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~w&lt;/code&gt; sigil is used to generate lists of words (&lt;em&gt;words&lt;/em&gt; are just regular strings). Inside the &lt;code&gt;~w&lt;/code&gt; sigil, words are separated by whitespace.</source>
          <target state="translated">&lt;code&gt;~w&lt;/code&gt; сигил используются для создания списков слов ( &lt;em&gt;слова&lt;/em&gt; просто обычные строки). Внутри сигиллы &lt;code&gt;~w&lt;/code&gt; слова разделяются пробелами.</target>
        </trans-unit>
        <trans-unit id="57c0bcba93565ebcb726bbcf9fe5e3a854d68664" translate="yes" xml:space="preserve">
          <source>The AST for a pipeline (a sequence of applications of &lt;code&gt;|&amp;gt;&lt;/code&gt;) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most &lt;code&gt;:|&amp;gt;&lt;/code&gt; (which is the last one to be executed), and its left-hand and right-hand sides are its arguments:</source>
          <target state="translated">AST для конвейера (последовательность применения &lt;code&gt;|&amp;gt;&lt;/code&gt; ) аналогичен AST последовательности бинарных операторов или приложений функций: выражение верхнего уровня является самым правым &lt;code&gt;:|&amp;gt;&lt;/code&gt; (которое является последним выполняется), а его левая и правая части являются его аргументами:</target>
        </trans-unit>
        <trans-unit id="22673f1e15930ac4a2bce8fc889928e4bf1f922d" translate="yes" xml:space="preserve">
          <source>The BREAK menu</source>
          <target state="translated">Меню BREAK</target>
        </trans-unit>
        <trans-unit id="98504b06eb756100aa8d0fe1b8a5bed8131e1638" translate="yes" xml:space="preserve">
          <source>The Client API</source>
          <target state="translated">Клиентский API</target>
        </trans-unit>
        <trans-unit id="de89441db4562cab93bdfbf9ab1875a33c2df7e4" translate="yes" xml:space="preserve">
          <source>The Date struct contains the fields year, month, day and calendar. New dates can be built with the &lt;a href=&quot;#new/3&quot;&gt;&lt;code&gt;new/3&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~D&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_D/2&quot;&gt;&lt;code&gt;Kernel.sigil_D/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Структура Date содержит поля год, месяц, день и календарь. Новые даты могут быть созданы с помощью &lt;a href=&quot;#new/3&quot;&gt; &lt;code&gt;new/3&lt;/code&gt; &lt;/a&gt; функции / 3 или с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_D/2&quot;&gt; &lt;code&gt;Kernel.sigil_D/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~D&lt;/code&gt; (см. Kernel.sigil_D / 2 ):</target>
        </trans-unit>
        <trans-unit id="087349ac5d28e5bd9b6d72d6f50436cef7a3d724" translate="yes" xml:space="preserve">
          <source>The Date struct contains the fields year, month, day and calendar. New dates can be built with the &lt;a href=&quot;#new/3&quot;&gt;&lt;code&gt;new/3&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~D&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_D/2&quot;&gt;&lt;code&gt;Kernel.sigil_D/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Структура Date содержит поля год, месяц, день и календарь. Новые даты могут быть созданы с помощью &lt;a href=&quot;#new/3&quot;&gt; &lt;code&gt;new/3&lt;/code&gt; &lt;/a&gt; функции / 3 или с помощью &lt;a href=&quot;kernel#sigil_D/2&quot;&gt; &lt;code&gt;Kernel.sigil_D/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~D&lt;/code&gt; (см. Kernel.sigil_D / 2 ):</target>
        </trans-unit>
        <trans-unit id="60739ce280ae99907b36b37adf6ef92a05aaedd6" translate="yes" xml:space="preserve">
          <source>The Elixir AST</source>
          <target state="translated">Эликсир АСТ</target>
        </trans-unit>
        <trans-unit id="b354da44a5ccc03b14d8e9e9f977406245074d69" translate="yes" xml:space="preserve">
          <source>The Elixir guides are also available in EPUB format:</source>
          <target state="translated">Справочники Elixir также доступны в формате EPUB:</target>
        </trans-unit>
        <trans-unit id="3b3b88c39f2093f79b409f882370622044ce70ae" translate="yes" xml:space="preserve">
          <source>The Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the &lt;code&gt;bin_opt_info&lt;/code&gt; compiler option:</source>
          <target state="translated">Компилятор Erlang может обеспечить ряд оптимизаций при создании и сопоставлении двоичных файлов. Чтобы увидеть результаты оптимизации, установите &lt;code&gt;bin_opt_info&lt;/code&gt; компилятора bin_opt_info :</target>
        </trans-unit>
        <trans-unit id="7953816f5ef9843a5ed4589ec36cf1a54fdf799d" translate="yes" xml:space="preserve">
          <source>The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in.</source>
          <target state="translated">Поведение GenServer абстрагирует общее взаимодействие клиент-сервер.От разработчиков требуется только реализовать интересующие их обратные вызовы и функциональность.</target>
        </trans-unit>
        <trans-unit id="3d66e19aeb4f8b03c43c83bf06d0a7f010db09c4" translate="yes" xml:space="preserve">
          <source>The GenServer name</source>
          <target state="translated">Имя GenServer</target>
        </trans-unit>
        <trans-unit id="4c83968c19110a694ab1613224a8a36aaf6e3f41" translate="yes" xml:space="preserve">
          <source>The IEx.Server.</source>
          <target state="translated">IEx.Server.</target>
        </trans-unit>
        <trans-unit id="06223706895cabbf123c8e779883d2c10704e930" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras:</source>
          <target state="translated">Календарь ИСО имеет две эпохи:</target>
        </trans-unit>
        <trans-unit id="abfb693f46640a1c9464403f477ffc2622e7b611" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras: the &quot;current era&quot; (CE) which starts in year &lt;code&gt;1&lt;/code&gt; and is defined as era &lt;code&gt;1&lt;/code&gt;. And &quot;before the current era&quot; (BCE) for those years less than &lt;code&gt;1&lt;/code&gt;, defined as era &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">В календаре ISO есть две эры: &amp;laquo;текущая эра&amp;raquo; (CE), которая начинается в год &lt;code&gt;1&lt;/code&gt; и определяется как эра &lt;code&gt;1&lt;/code&gt; . И &amp;laquo;до нынешней эры&amp;raquo; (BCE) для тех лет, которые меньше &lt;code&gt;1&lt;/code&gt; , определяется как эра &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25aef49825211907484d43e756114a0b1fa27f36" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras: the current era which starts in year 1 and is defined as era &quot;1&quot;. And a second era for those years less than 1 defined as era &quot;0&quot;.</source>
          <target state="translated">Календарь ИСО имеет две эпохи:текущая эпоха,которая начинается с года 1 и определяется как эпоха &quot;1&quot;.А вторая эра для тех лет меньше 1 определяется как эра &quot;0&quot;.</target>
        </trans-unit>
        <trans-unit id="1a856fcbbb476ea67477f19a707dbe002ca4c6dc" translate="yes" xml:space="preserve">
          <source>The Jaro distance metric is designed and best suited for short strings such as person names. Elixir itself uses this function to provide the &quot;did you mean?&quot; functionality. For instance, when you are calling a function in a module and you have a typo in the function name, we attempt to suggest the most similar function name available, if any, based on the &lt;a href=&quot;#jaro_distance/2&quot;&gt;&lt;code&gt;jaro_distance/2&lt;/code&gt;&lt;/a&gt; score.</source>
          <target state="translated">Метрика расстояния Джаро разработана и лучше всего подходит для коротких строк, таких как имена людей. Сам Elixir использует эту функцию, чтобы задать вопрос &amp;laquo;Вы имели в виду?&amp;raquo; функциональность. Например, когда вы вызываете функцию в модуле и у вас есть опечатка в имени функции, мы пытаемся предложить наиболее похожее имя функции, если таковое имеется, на основе &lt;a href=&quot;#jaro_distance/2&quot;&gt; &lt;code&gt;jaro_distance/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2243840442a8f32a34eed8592db54cfe259c03b6" translate="yes" xml:space="preserve">
          <source>The Mix build tool automates most of the application management tasks. For example, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; automatically starts your application dependencies and your application itself before your test runs. &lt;code&gt;mix run --no-halt&lt;/code&gt; boots your current project and can be used to start a long running system. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix help run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Инструмент сборки Mix автоматизирует большинство задач по управлению приложениями. Например, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; автоматически запускает зависимости вашего приложения и само приложение перед запуском теста. &lt;code&gt;mix run --no-halt&lt;/code&gt; загружает ваш текущий проект и может использоваться для запуска долго работающей системы. См. &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix help run&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37173c596301d8be8275b8b1f500a183f87ab7fa" translate="yes" xml:space="preserve">
          <source>The Mix build tool can also be used to start your applications. For example, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; automatically starts your application dependencies and your application itself before your test runs. &lt;code&gt;mix run --no-halt&lt;/code&gt; boots your current project and can be used to start a long running system. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix help run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Инструмент сборки Mix также можно использовать для запуска ваших приложений. Например, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; автоматически запускает зависимости вашего приложения и само приложение перед запуском теста. &lt;code&gt;mix run --no-halt&lt;/code&gt; загружает ваш текущий проект и может использоваться для запуска долго работающей системы. См. &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix help run&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed1904da080bbb46fb65f0901cdd39a58e1d853d" translate="yes" xml:space="preserve">
          <source>The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation, computed via &lt;code&gt;mix xref warnings&lt;/code&gt;.</source>
          <target state="translated">Компилятор Mix автоматически ищет вызовы устаревших модулей и выдает предупреждения во время компиляции, вычисленные с помощью &lt;code&gt;mix xref warnings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d196736edd538da5aa685ff060f4fbf30705946" translate="yes" xml:space="preserve">
          <source>The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation.</source>
          <target state="translated">Компилятор Mix автоматически ищет вызовы устаревших модулей и выдает предупреждения при компиляции.</target>
        </trans-unit>
        <trans-unit id="34452d9cfe86755e31b4602a825598bf680a2294" translate="yes" xml:space="preserve">
          <source>The Mix.Release struct has the following read-only fields</source>
          <target state="translated">Структура Mix.Release имеет следующие поля,доступные только для чтения</target>
        </trans-unit>
        <trans-unit id="39b03d254e8865b80217130278011a49c00a226d" translate="yes" xml:space="preserve">
          <source>The Mix.Release struct has the following read-only fields:</source>
          <target state="translated">Структура Mix.Release имеет следующие поля,доступные только для чтения:</target>
        </trans-unit>
        <trans-unit id="9dfe2774b7ab63b2ea9316075f485e26e6770c05" translate="yes" xml:space="preserve">
          <source>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the &lt;a href=&quot;#new/2&quot;&gt;&lt;code&gt;new/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#new/8&quot;&gt;&lt;code&gt;new/8&lt;/code&gt;&lt;/a&gt; functions or using the &lt;code&gt;~N&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_N/2&quot;&gt;&lt;code&gt;Kernel.sigil_N/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Структура NaiveDateTime содержит поля год, месяц, день, час, минута, секунда, микросекунда и календарь. Новые наивные даты могут быть построены с помощью функций &lt;a href=&quot;#new/2&quot;&gt; &lt;code&gt;new/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#new/8&quot;&gt; &lt;code&gt;new/8&lt;/code&gt; &lt;/a&gt; или с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_N/2&quot;&gt; &lt;code&gt;Kernel.sigil_N/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~N&lt;/code&gt; (см. Kernel.sigil_N / 2 ):</target>
        </trans-unit>
        <trans-unit id="be1eb0ffc63d3de62778534778d3195fa7ba19b5" translate="yes" xml:space="preserve">
          <source>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the &lt;a href=&quot;#new/2&quot;&gt;&lt;code&gt;new/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#new/8&quot;&gt;&lt;code&gt;new/8&lt;/code&gt;&lt;/a&gt; functions or using the &lt;code&gt;~N&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_N/2&quot;&gt;&lt;code&gt;Kernel.sigil_N/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Структура NaiveDateTime содержит поля год, месяц, день, час, минута, секунда, микросекунда и календарь. Новые наивные даты могут быть построены с помощью функций &lt;a href=&quot;#new/2&quot;&gt; &lt;code&gt;new/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#new/8&quot;&gt; &lt;code&gt;new/8&lt;/code&gt; &lt;/a&gt; или с помощью &lt;a href=&quot;kernel#sigil_N/2&quot;&gt; &lt;code&gt;Kernel.sigil_N/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~N&lt;/code&gt; (см. Kernel.sigil_N / 2 ):</target>
        </trans-unit>
        <trans-unit id="68ea22c150e9e8bf3b5e486f34ccdf3da6885051" translate="yes" xml:space="preserve">
          <source>The Plug library also allows developers to define their own plugs which can be run in a web server:</source>
          <target state="translated">Библиотека Plug также позволяет разработчикам определять свои собственные плагины,которые могут быть запущены на веб-сервере:</target>
        </trans-unit>
        <trans-unit id="a12ef86cf46c7d5f545c70ee0f3e00bac2b5a15b" translate="yes" xml:space="preserve">
          <source>The Supervisor name</source>
          <target state="translated">Имя руководителя</target>
        </trans-unit>
        <trans-unit id="ec4b01d7b2161ab93486a9f17a632dd403411fb3" translate="yes" xml:space="preserve">
          <source>The Task struct.</source>
          <target state="translated">Структура задачи.</target>
        </trans-unit>
        <trans-unit id="5c4c62b39d79d7cb27a5185a0a6601bdd97a3708" translate="yes" xml:space="preserve">
          <source>The Task type.</source>
          <target state="translated">Тип задачи.</target>
        </trans-unit>
        <trans-unit id="9e011d9f109b1de717a6e789ef4d48fa0c5bf500" translate="yes" xml:space="preserve">
          <source>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the &lt;a href=&quot;#new/4&quot;&gt;&lt;code&gt;new/4&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~T&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_T/2&quot;&gt;&lt;code&gt;Kernel.sigil_T/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Структура Time содержит поля часов, минут, секунд и микросекунд. Новое время можно построить с помощью функции &lt;a href=&quot;#new/4&quot;&gt; &lt;code&gt;new/4&lt;/code&gt; &lt;/a&gt; или с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_T/2&quot;&gt; &lt;code&gt;Kernel.sigil_T/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~T&lt;/code&gt; (см. Kernel.sigil_T / 2 ):</target>
        </trans-unit>
        <trans-unit id="3b4c615274399f80e52f24988cf891d5bac9928c" translate="yes" xml:space="preserve">
          <source>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the &lt;a href=&quot;#new/4&quot;&gt;&lt;code&gt;new/4&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~T&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_T/2&quot;&gt;&lt;code&gt;Kernel.sigil_T/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Структура Time содержит поля часов, минут, секунд и микросекунд. Новое время можно построить с помощью функции &lt;a href=&quot;#new/4&quot;&gt; &lt;code&gt;new/4&lt;/code&gt; &lt;/a&gt; или с помощью &lt;a href=&quot;kernel#sigil_T/2&quot;&gt; &lt;code&gt;Kernel.sigil_T/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~T&lt;/code&gt; (см. Kernel.sigil_T / 2 ):</target>
        </trans-unit>
        <trans-unit id="8474ee41c99d01d2c859c45e3ba20cf759140dae" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one code point needs to be rejected.</source>
          <target state="translated">Кодировка UTF-8 является самосинхронизирующейся.Это означает,что при обнаружении некорректных данных (т.е.данных,которые не возможны согласно определению кодировки),необходимо отвергнуть только одну точку кода.</target>
        </trans-unit>
        <trans-unit id="af4cd337ec1852f0dfb035c5a67522bde05e43a9" translate="yes" xml:space="preserve">
          <source>The Unicode standard assigns code points to many of the characters we know. For example, the letter &lt;code&gt;a&lt;/code&gt; has code point &lt;code&gt;97&lt;/code&gt; while the letter &lt;code&gt;ł&lt;/code&gt; has code point &lt;code&gt;322&lt;/code&gt;. When writing the string &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; to disk, we need to convert this sequence of characters to bytes. If we adopted a rule that said one byte represents one code point, we wouldn&amp;rsquo;t be able to write &lt;code&gt;&quot;hełło&quot;&lt;/code&gt;, because it uses the code point &lt;code&gt;322&lt;/code&gt; for &lt;code&gt;ł&lt;/code&gt;, and one byte can only represent a number from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. But of course, given you can actually read &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; on your screen, it must be represented &lt;em&gt;somehow&lt;/em&gt;. That&amp;rsquo;s where encodings come in.</source>
          <target state="translated">Стандарт Unicode присваивает кодовые точки многим известным нам символам. Например, буква &lt;code&gt;a&lt;/code&gt; имеет код &lt;code&gt;97&lt;/code&gt; , а буква &lt;code&gt;ł&lt;/code&gt; - &lt;code&gt;322&lt;/code&gt; . При записи строки &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; на диск нам нужно преобразовать эту последовательность символов в байты. Если бы мы приняли правило, согласно которому один байт представляет одну кодовую точку, мы не смогли бы написать &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; , потому что оно использует кодовую точку &lt;code&gt;322&lt;/code&gt; для &lt;code&gt;ł&lt;/code&gt; , а один байт может представлять только число от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;255&lt;/code&gt; . Но, конечно, если вы действительно можете прочитать &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; на экране, это должно быть представлено&lt;em&gt;как-то&lt;/em&gt; . Вот где пригодятся кодировки.</target>
        </trans-unit>
        <trans-unit id="2f4916c41c92d9991c4b1a3b6471eb39a20e54f2" translate="yes" xml:space="preserve">
          <source>The User switch command</source>
          <target state="translated">Команда переключения пользователя</target>
        </trans-unit>
        <trans-unit id="1a567b978fcdc4da963f5cc140173eaaff0ae789" translate="yes" xml:space="preserve">
          <source>The above example shows the difference; the &lt;code&gt;String&lt;/code&gt; module returns Unicode codepoints, while &lt;code&gt;:binary&lt;/code&gt; deals with raw data bytes.</source>
          <target state="translated">Приведенный выше пример показывает разницу; &lt;code&gt;String&lt;/code&gt; модуль возвращает кодовые Unicode, в то время как &lt;code&gt;:binary&lt;/code&gt; сделки с необработанными байтами данных.</target>
        </trans-unit>
        <trans-unit id="3a294edc39ba298dd2fbf7c3e29c2a6c5831e0fe" translate="yes" xml:space="preserve">
          <source>The above is treated the same as &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; by the parser.</source>
          <target state="translated">Вышеупомянутое обрабатывается синтаксическим анализатором так же, как &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bc5ff1abf3cc124d1fca8a735f66352777e819" translate="yes" xml:space="preserve">
          <source>The above will open another Graphical User Interface that provides many panes to fully understand and navigate the runtime and your project:</source>
          <target state="translated">Вышесказанное откроет еще один графический интерфейс пользователя,который предоставляет множество панелей для полного понимания и навигации во время выполнения и в вашем проекте:</target>
        </trans-unit>
        <trans-unit id="d9d727dddfefcfe94e321842e4a52a5241d4e51c" translate="yes" xml:space="preserve">
          <source>The accepted formats are:</source>
          <target state="translated">Принятые форматы:</target>
        </trans-unit>
        <trans-unit id="4124955158531615905cdb11c74372fed2efecdc" translate="yes" xml:space="preserve">
          <source>The accepted options are:</source>
          <target state="translated">Принимаются следующие варианты:</target>
        </trans-unit>
        <trans-unit id="7021d5fb676b9152eef63709fd1b96c4dc35ca14" translate="yes" xml:space="preserve">
          <source>The access syntax can also be used with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#put_in/2&quot;&gt;&lt;code&gt;Kernel.put_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#update_in/2&quot;&gt;&lt;code&gt;Kernel.update_in/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt;&lt;/a&gt; macros to allow values to be set in nested data structures:</source>
          <target state="translated">Синтаксис доступа также можно использовать с &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#put_in/2&quot;&gt; &lt;code&gt;Kernel.put_in/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#update_in/2&quot;&gt; &lt;code&gt;Kernel.update_in/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt; ,&lt;/a&gt; чтобы разрешить установку значений во вложенных структурах данных:</target>
        </trans-unit>
        <trans-unit id="aca7adeb72bb259b777f4c2b15cd9a4f9b4ff5ce" translate="yes" xml:space="preserve">
          <source>The access syntax can also be used with the &lt;a href=&quot;kernel#put_in/2&quot;&gt;&lt;code&gt;Kernel.put_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#update_in/2&quot;&gt;&lt;code&gt;Kernel.update_in/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#get_and_update_in/2&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt;&lt;/a&gt; macros to allow values to be set in nested data structures:</source>
          <target state="translated">Синтаксис доступа также можно использовать с &lt;a href=&quot;kernel#put_in/2&quot;&gt; &lt;code&gt;Kernel.put_in/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#update_in/2&quot;&gt; &lt;code&gt;Kernel.update_in/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;kernel#get_and_update_in/2&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt; ,&lt;/a&gt; чтобы разрешить установку значений во вложенных структурах данных:</target>
        </trans-unit>
        <trans-unit id="243c0eadcb33ec262a94b0246c4ece1f117a3666" translate="yes" xml:space="preserve">
          <source>The access syntax is represented as a call to &lt;a href=&quot;access#get/2&quot;&gt;&lt;code&gt;Access.get/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Синтаксис доступа представлен как вызов &lt;a href=&quot;access#get/2&quot;&gt; &lt;code&gt;Access.get/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3c19d0ebf16010f6efd63fa157dd829c700b0b58" translate="yes" xml:space="preserve">
          <source>The access syntax is represented as a call to &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#get/2&quot;&gt;&lt;code&gt;Access.get/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Синтаксис доступа представлен в виде вызова &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#get/2&quot;&gt; &lt;code&gt;Access.get/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4b8d2c8f5f09f671794f31f1f907968a5ca06aff" translate="yes" xml:space="preserve">
          <source>The accumulator is only calculated when transformation starts. It also allows an after function to be given which is invoked when the stream halts or completes.</source>
          <target state="translated">Аккумулятор вычисляется только тогда,когда начинается трансформация.Он также позволяет задать функцию after,которая вызывается,когда поток останавливается или завершается.</target>
        </trans-unit>
        <trans-unit id="231cb19852aaf99a578b488de350325c3dbaf7df" translate="yes" xml:space="preserve">
          <source>The accumulator value for each step.</source>
          <target state="translated">Значение аккумулятора для каждой ступени.</target>
        </trans-unit>
        <trans-unit id="e04f1a61804f76a146e2c529d3dfa319227959a4" translate="yes" xml:space="preserve">
          <source>The actual line is especially formatted in bold.</source>
          <target state="translated">Реальная строка специально отформатирована жирным шрифтом.</target>
        </trans-unit>
        <trans-unit id="3f1f1fb598d7730a9ff70812d543d26b95408bb0" translate="yes" xml:space="preserve">
          <source>The advantage of starting a process under the test supervisor is that it is guaranteed to exit before the next test starts. Therefore, you don't need to remove the process at the end of your tests via &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt;. You only need to use &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt; if you want to remove a process from the supervision tree in the middle of a test, as simply shutting down the process would cause it to be restarted according to its &lt;code&gt;:restart&lt;/code&gt; value.</source>
          <target state="translated">Преимущество запуска процесса под наблюдением над тестированием состоит в том, что он гарантированно завершится до начала следующего теста. Следовательно, вам не нужно удалять процесс в конце ваших тестов через &lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt; . Вам нужно использовать &lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; только в том&lt;/a&gt; случае, если вы хотите удалить процесс из дерева наблюдения в середине теста, поскольку простое завершение процесса приведет к его перезапуску в соответствии со значением &lt;code&gt;:restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f25d9730409ef1dfe6f5e984f31be4fd99cffcf1" translate="yes" xml:space="preserve">
          <source>The advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key &lt;code&gt;:full_name&lt;/code&gt; in the &lt;code&gt;User&lt;/code&gt; struct:</source>
          <target state="translated">Преимущество структур в том, что они подтверждают, что данные ключи являются частью определенной структуры. Приведенный ниже пример завершится ошибкой, поскольку в структуре &lt;code&gt;User&lt;/code&gt; нет ключа &lt;code&gt;:full_name&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83ac1b567e220f667e9d9d2c2f19a5c7705de064" translate="yes" xml:space="preserve">
          <source>The agent name</source>
          <target state="translated">Имя агента</target>
        </trans-unit>
        <trans-unit id="850cde34796934da35ab95f25d166c013161b0f7" translate="yes" xml:space="preserve">
          <source>The agent reference</source>
          <target state="translated">Ссылка на агента</target>
        </trans-unit>
        <trans-unit id="79d99d2d3b7f3ac280b26b43a51cc435cf66db5f" translate="yes" xml:space="preserve">
          <source>The agent state</source>
          <target state="translated">Государство-агент</target>
        </trans-unit>
        <trans-unit id="04287ba52642f4b2e9805d3cbb6242221ac4131b" translate="yes" xml:space="preserve">
          <source>The agent's state will be added to the given list of arguments (&lt;code&gt;[%{}]&lt;/code&gt;) as the first argument.</source>
          <target state="translated">Состояние агента будет добавлено в указанный список аргументов ( &lt;code&gt;[%{}]&lt;/code&gt; ) в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="8beb83ba7f5ecd3254d30e564e0d6fb8a2d460e5" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &quot;An O(ND) Difference Algorithm and Its Variations&quot; paper by E. Myers.</source>
          <target state="translated">Алгоритм описан в работе Э.Майерса &quot;Алгоритм дифференциации O(ND)и его вариации&quot;.</target>
        </trans-unit>
        <trans-unit id="3e134324067f32fab468c28c29405fca71811700" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &quot;String Matching with Metric Trees Using an Approximate Distance&quot; paper by Ilaria Bartolini, Paolo Ciaccia, and Marco Patella.</source>
          <target state="translated">Алгоритм описан в работе Иларии Бартолини,Паоло Чьячча и Марко Пателлы &quot;Совпадение струн с метрическими деревьями на близком расстоянии&quot;.</target>
        </trans-unit>
        <trans-unit id="e4b130944005218b61f70b8dda4acb83f5f8b422" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29, Unicode Text Segmentation&lt;/a&gt;.</source>
          <target state="translated">Алгоритм описан в &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Приложении № 29&lt;/a&gt; к стандарту Unicode, Сегментация текста Unicode .</target>
        </trans-unit>
        <trans-unit id="f9558fd66aceb0ac12811fbd079f3478d2d6d0b6" translate="yes" xml:space="preserve">
          <source>The allowed modes:</source>
          <target state="translated">Допустимые режимы:</target>
        </trans-unit>
        <trans-unit id="22b1bedb9b0e24d713b2164c5c95fdaf0f81ef84" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;flag&lt;/code&gt; are only a subset of those allowed in &lt;a href=&quot;#flag/2&quot;&gt;&lt;code&gt;flag/2&lt;/code&gt;&lt;/a&gt;, namely &lt;code&gt;:save_calls&lt;/code&gt;.</source>
          <target state="translated">Допустимые значения для &lt;code&gt;flag&lt;/code&gt; - это только подмножество разрешенных в &lt;a href=&quot;#flag/2&quot;&gt; &lt;code&gt;flag/2&lt;/code&gt; &lt;/a&gt; , а именно &lt;code&gt;:save_calls&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1284e6a8b509aaab6853404ad966b4c6d0d9c11" translate="yes" xml:space="preserve">
          <source>The amount of functionality in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules can be daunting at first, but you will get familiar with them case by case. In particular, focus on the &lt;code&gt;Enum&lt;/code&gt; module first and only move to &lt;code&gt;Stream&lt;/code&gt; for the particular scenarios where laziness is required, to either deal with slow resources or large, possibly infinite, collections.</source>
          <target state="translated">Поначалу количество функций в модулях &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; может показаться пугающим, но вы будете знакомиться с ними от случая к случаю. В частности, сначала сосредоточьтесь на модуле &lt;code&gt;Enum&lt;/code&gt; и переходите к &lt;code&gt;Stream&lt;/code&gt; только для конкретных сценариев, где требуется лень, чтобы иметь дело с медленными ресурсами или большими, возможно бесконечными, коллекциями.</target>
        </trans-unit>
        <trans-unit id="7e8600e30f0a326a12149028f15ee8e6ad16cef8" translate="yes" xml:space="preserve">
          <source>The anonymous function receives 0 arguments, and may return any value.</source>
          <target state="translated">Анонимная функция получает 0 аргументов и может возвращать любое значение.</target>
        </trans-unit>
        <trans-unit id="3860a6ee964a29eb95c7ca816e5e5490427978d6" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ответ может быть возвращен в любом &lt;code&gt;unit&lt;/code&gt; доступном в &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35961a2d2bc407917b83fe316a44657eb3d70dde" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. If the first time value is earlier than the second, a negative number is returned.</source>
          <target state="translated">Ответ может быть возвращен в любом &lt;code&gt;unit&lt;/code&gt; доступном в &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; . Если первое значение времени раньше, чем второе, возвращается отрицательное число.</target>
        </trans-unit>
        <trans-unit id="273c2352c55239386071c9f97857464d5b54d531" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ответ может быть возвращен в любом &lt;code&gt;unit&lt;/code&gt; доступном в &lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c851ccba3a0c5e2913af28fbba1bc5059650f30" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. If the first unit is smaller than the second, a negative number is returned.</source>
          <target state="translated">Ответ может быть возвращен в любом &lt;code&gt;unit&lt;/code&gt; доступном в &lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; . Если первая единица меньше второй, возвращается отрицательное число.</target>
        </trans-unit>
        <trans-unit id="11872c1546ad5d8d77e3dd6dcf24fe80bdc32569" translate="yes" xml:space="preserve">
          <source>The application callback</source>
          <target state="translated">Обратный вызов приложения</target>
        </trans-unit>
        <trans-unit id="498cebd5386c08940274d180a46313b584299218" translate="yes" xml:space="preserve">
          <source>The application callback module</source>
          <target state="translated">Модуль обратного вызова приложения</target>
        </trans-unit>
        <trans-unit id="ce357182db7e39e7d54f85ac0fa8ea1bfe43cdcd" translate="yes" xml:space="preserve">
          <source>The application environment</source>
          <target state="translated">Прикладная среда</target>
        </trans-unit>
        <trans-unit id="40917bb5c729fef80a4c140a2928d1f7a14bf4d7" translate="yes" xml:space="preserve">
          <source>The application environment can be overridden via the &lt;code&gt;-config&lt;/code&gt; option of &lt;code&gt;erl&lt;/code&gt;, as well as command-line options, as we are going to see below.</source>
          <target state="translated">Среду приложения можно переопределить с помощью параметра &lt;code&gt;-config&lt;/code&gt; в &lt;code&gt;erl&lt;/code&gt; , а также параметров командной строки, как мы увидим ниже.</target>
        </trans-unit>
        <trans-unit id="37789b75dd5f623e649e47a61f598fab65dfa7b6" translate="yes" xml:space="preserve">
          <source>The application environment should be reserved only for configurations that are truly global, for example, to control your application boot process and its supervision tree.</source>
          <target state="translated">Среда приложений должна быть зарезервирована только для конфигураций,которые действительно глобальны,например,для управления процессом загрузки приложений и их деревом наблюдения.</target>
        </trans-unit>
        <trans-unit id="280a9a5faaec5ff9e8215df748115db28ebee1a0" translate="yes" xml:space="preserve">
          <source>The application is located by analyzing the spec of all loaded applications. Returns &lt;code&gt;nil&lt;/code&gt; if the module is not listed in any application spec.</source>
          <target state="translated">Приложение находится путем анализа спецификаций всех загруженных приложений. Возвращает &lt;code&gt;nil&lt;/code&gt; , если модуль не указан ни в одной спецификации приложения.</target>
        </trans-unit>
        <trans-unit id="bc8d61b7265354046282efa86c0154278c621f25" translate="yes" xml:space="preserve">
          <source>The application life cycle</source>
          <target state="translated">Жизненный цикл приложения</target>
        </trans-unit>
        <trans-unit id="cc4a58ee1265d5c1fe9173d32bf0ac223249dd85" translate="yes" xml:space="preserve">
          <source>The application lifecycle</source>
          <target state="translated">Жизненный цикл приложения</target>
        </trans-unit>
        <trans-unit id="143141b825e19c759eb1a18e855e24abed92b957" translate="yes" xml:space="preserve">
          <source>The application resource file</source>
          <target state="translated">Файл ресурса приложения</target>
        </trans-unit>
        <trans-unit id="e3563cd3d1dfc3ea0fa27f37030c6816eb2657f5" translate="yes" xml:space="preserve">
          <source>The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:</source>
          <target state="translated">Приложение работает как распределенный магазин стоимости ключей.Мы собираемся организовать пары ключей-значений в ведра и распределить эти ведра по нескольким узлам.Мы также построим простой клиент,который позволит нам подключаться к любому из этих узлов и отправлять такие запросы:</target>
        </trans-unit>
        <trans-unit id="27642ed423e2fa876dc5149e7e9fb4418a0af850" translate="yes" xml:space="preserve">
          <source>The archive will be created in the current directory (which is expected to be the project root), unless an argument &lt;code&gt;-o&lt;/code&gt; is provided with the file name.</source>
          <target state="translated">Архив будет создан в текущем каталоге (который, как ожидается, будет корнем проекта), если в имени файла не &lt;code&gt;-o&lt;/code&gt; аргумент -o .</target>
        </trans-unit>
        <trans-unit id="d0f3ead845310ee387fe5a545e6953c55ffb1629" translate="yes" xml:space="preserve">
          <source>The argument can also be a compiled pattern:</source>
          <target state="translated">Аргументом также может быть скомпилированный шаблон:</target>
        </trans-unit>
        <trans-unit id="591637cab81491d8824a1f871aa68b8d413473f1" translate="yes" xml:space="preserve">
          <source>The argument can be either a variable unquoted or in standard tuple form &lt;code&gt;{name, meta, context}&lt;/code&gt;.</source>
          <target state="translated">Аргументом может быть переменная без кавычек или в стандартной форме кортежа &lt;code&gt;{name, meta, context}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="001d538e8d0cdf963d20a8cda73ecd32223786da" translate="yes" xml:space="preserve">
          <source>The arguments passed to the callbacks are related to the state optionally returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, and are documented in the section about the callback module above.</source>
          <target state="translated">Аргументы, передаваемые обратным вызовам, связаны с состоянием, которое может быть возвращено параметром &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; , и задокументированы в разделе о модуле обратного вызова выше.</target>
        </trans-unit>
        <trans-unit id="2a881ae7cb35da41cfdaee7b5069205d1b09ab08" translate="yes" xml:space="preserve">
          <source>The atom encoder is not called for &lt;em&gt;all&lt;/em&gt; atoms that are present in the AST. It won't be invoked for the following atoms:</source>
          <target state="translated">Кодировщик атомов вызывается не для &lt;em&gt;всех&lt;/em&gt; атомов, присутствующих в AST. Он не будет вызываться для следующих атомов:</target>
        </trans-unit>
        <trans-unit id="ca8797b60e8c99dfe84eeca54f5b5a5a65568918" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;.</source>
          <target state="translated">Значения атрибутов будут доступны через &lt;code&gt;context.registered&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1aacd6450630dafa0ac3016ebf55acec692c62f" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;#describe/2&quot;&gt;&lt;code&gt;describe/2&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@describetag&lt;/code&gt;.</source>
          <target state="translated">Значения атрибутов будут доступны через &lt;code&gt;context.registered&lt;/code&gt; . Зарегистрированные значения очищаются после каждого &lt;a href=&quot;#describe/2&quot;&gt; &lt;code&gt;describe/2&lt;/code&gt; &lt;/a&gt; аналогично &lt;code&gt;@describetag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f388a223145d9f2cd324e6f166a8ccfc6a8b5209" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;#test/3&quot;&gt;&lt;code&gt;test/3&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@tag&lt;/code&gt;.</source>
          <target state="translated">Значения атрибутов будут доступны через &lt;code&gt;context.registered&lt;/code&gt; . Зарегистрированные значения очищаются после каждого &lt;a href=&quot;#test/3&quot;&gt; &lt;code&gt;test/3&lt;/code&gt; &lt;/a&gt; аналогично &lt;code&gt;@tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b41ad89c98d422fd2e978f100782ecfe3f1da362" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;exunit.case#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@tag&lt;/code&gt;.</source>
          <target state="translated">Значения атрибутов будут доступны через &lt;code&gt;context.registered&lt;/code&gt; . Зарегистрированные значения сбрасываются после каждого &lt;a href=&quot;exunit.case#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; &lt;/a&gt; , похожие на &lt;code&gt;@tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fadbc924b0cd6b0ad53d9ab7f75eafe50d08633" translate="yes" xml:space="preserve">
          <source>The available backends by default are:</source>
          <target state="translated">По умолчанию доступны бэкэнды:</target>
        </trans-unit>
        <trans-unit id="6cce71e8c20ef741ad606617e045711680af943f" translate="yes" xml:space="preserve">
          <source>The available color options are:</source>
          <target state="translated">Доступные цветовые варианты:</target>
        </trans-unit>
        <trans-unit id="6310c4c55c85283101be1a934d0a00206b4f631d" translate="yes" xml:space="preserve">
          <source>The backend needs to be started and running in order to be configured at runtime.</source>
          <target state="translated">Бэкэнд должен быть запущен и запущен,чтобы быть настроенным во время выполнения.</target>
        </trans-unit>
        <trans-unit id="96a787facf19135fb4b200f8b487060672819be8" translate="yes" xml:space="preserve">
          <source>The bag distance is meant to be an efficient approximation of the distance between two strings to quickly rule out strings that are largely different.</source>
          <target state="translated">Расстояние между сумками предназначено для эффективного приближения расстояния между двумя струнами,чтобы быстро исключить струны,которые сильно отличаются друг от друга.</target>
        </trans-unit>
        <trans-unit id="b0aa33c6e6c19292365b6836f590a40f470ae9e8" translate="yes" xml:space="preserve">
          <source>The base needs to be between &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;36&lt;/code&gt;.</source>
          <target state="translated">База должна быть от &lt;code&gt;2&lt;/code&gt; до &lt;code&gt;36&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="338ca5e9a146228c6591ce27e258c309b41537d7" translate="yes" xml:space="preserve">
          <source>The basic mechanism for spawning new processes is the auto-imported &lt;code&gt;spawn/1&lt;/code&gt; function:</source>
          <target state="translated">Основным механизмом порождения новых процессов является автоматически импортированная функция &lt;code&gt;spawn/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e7559ee61af701da957bbebc32b89de3be4e12f" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#ceil/2&quot;&gt;&lt;code&gt;ceil/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">Поведение &lt;a href=&quot;#ceil/2&quot;&gt; &lt;code&gt;ceil/2&lt;/code&gt; &lt;/a&gt; для поплавков может вызывать удивление. Например:</target>
        </trans-unit>
        <trans-unit id="d56bb8e1dfaa2c0603350dcc324ff5c454da55f1" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#floor/2&quot;&gt;&lt;code&gt;floor/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">Поведение &lt;a href=&quot;#floor/2&quot;&gt; &lt;code&gt;floor/2&lt;/code&gt; &lt;/a&gt; для поплавков может вызывать удивление. Например:</target>
        </trans-unit>
        <trans-unit id="038842fad2e4b3a86e4d5b65bf16dcbffaa55807" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#round/2&quot;&gt;&lt;code&gt;round/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">Поведение &lt;a href=&quot;#round/2&quot;&gt; &lt;code&gt;round/2&lt;/code&gt; &lt;/a&gt; для поплавков может вызывать удивление. Например:</target>
        </trans-unit>
        <trans-unit id="c79b8f7e64e352a09f016328372f8c34533b468e" translate="yes" xml:space="preserve">
          <source>The behaviour of any expression in a clause is the same as outside. For example, &lt;code&gt;=&lt;/code&gt; will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; instead of returning the non-matched value:</source>
          <target state="translated">Поведение любого выражения в предложении такое же, как и снаружи. Например, &lt;code&gt;=&lt;/code&gt; вызовет &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt; вместо возврата несоответствующего значения:</target>
        </trans-unit>
        <trans-unit id="850b8800d7a40702a94f4c6f350b76c00c714c91" translate="yes" xml:space="preserve">
          <source>The behaviour of any expression in a clause is the same as outside. For example, &lt;code&gt;=&lt;/code&gt; will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; instead of returning the non-matched value:</source>
          <target state="translated">Поведение любого выражения в предложении такое же, как и снаружи. Например, &lt;code&gt;=&lt;/code&gt; вызовет &lt;a href=&quot;matcherror&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt; вместо возврата несоответствующего значения:</target>
        </trans-unit>
        <trans-unit id="2c2089b4c70310731d109bdd4cb28eac8386c5ba" translate="yes" xml:space="preserve">
          <source>The behaviours above are not guaranteed. We may remove or add new rules in the future. The goal of documenting them is to provide better understanding on what to expect from the formatter.</source>
          <target state="translated">Поведение,описанное выше,не гарантируется.Мы можем удалить или добавить новые правила в будущем.Цель документирования их заключается в том,чтобы обеспечить лучшее понимание того,чего ожидать от форматизатора.</target>
        </trans-unit>
        <trans-unit id="1b5532ea236231522d81c8ef60d96c8157a31b23" translate="yes" xml:space="preserve">
          <source>The best solution is to simply use the explicit module, function, and arguments APIs when working with distributed agents.</source>
          <target state="translated">Лучшим решением является простое использование явных API модуля,функции и аргументов при работе с распределенными агентами.</target>
        </trans-unit>
        <trans-unit id="230a7e78c26b7490aaeba0ccd0ad9d4d649d4144" translate="yes" xml:space="preserve">
          <source>The best way to get started with your first project is by calling &lt;code&gt;mix new my_project&lt;/code&gt; from the command line.</source>
          <target state="translated">Лучший способ начать работу с вашим первым проектом - вызвать &lt;code&gt;mix new my_project&lt;/code&gt; из командной строки.</target>
        </trans-unit>
        <trans-unit id="d0bbf418b1f38a55ccb7dde48f0990ed9ed4760a" translate="yes" xml:space="preserve">
          <source>The binary module</source>
          <target state="translated">Двоичный модуль</target>
        </trans-unit>
        <trans-unit id="95ca58a2bc8511627f8365c4bfe2246bdcfdaed5" translate="yes" xml:space="preserve">
          <source>The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</source>
          <target state="translated">Ключами привязки обычно являются атомы,но они могут быть кортежом для переменных,определенных в другом контексте.</target>
        </trans-unit>
        <trans-unit id="0b507e4caeeefa4e12188b817548237116e75e51" translate="yes" xml:space="preserve">
          <source>The booleans &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are also atoms:</source>
          <target state="translated">Логические значения &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; также являются атомами:</target>
        </trans-unit>
        <trans-unit id="922dc50f7cf9b7578080aaeb54c1d2a1b40ac190" translate="yes" xml:space="preserve">
          <source>The boot script uses the RELEASE_LIB environment variable, which must be accordingly set with &lt;code&gt;--boot-var&lt;/code&gt; and point to the release lib dir.</source>
          <target state="translated">Сценарий загрузки использует переменную среды RELEASE_LIB, которая должна быть соответственно установлена ​​с помощью &lt;code&gt;--boot-var&lt;/code&gt; и указывать на каталог библиотеки выпуска.</target>
        </trans-unit>
        <trans-unit id="173c29727301f1e8ee220ab1adbc4da76be15175" translate="yes" xml:space="preserve">
          <source>The bucket supervisor</source>
          <target state="translated">Начальник ведра</target>
        </trans-unit>
        <trans-unit id="28ca52bc03d0c7c44e235ef531de8f5ba2e83b87" translate="yes" xml:space="preserve">
          <source>The building block of Elixir's AST is a call, such as:</source>
          <target state="translated">Строительный блок АСТ Эликсира-это,например,звонок:</target>
        </trans-unit>
        <trans-unit id="461328f5549d78a8b5fdedc116f07cd5036d784a" translate="yes" xml:space="preserve">
          <source>The building block of an Elixir program is a tuple with three elements. For example, the function call &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; is represented internally as:</source>
          <target state="translated">Строительный блок программы на Эликсире - это кортеж из трех элементов. Например, &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; вызова функции (1, 2, 3) внутренне представлена ​​как:</target>
        </trans-unit>
        <trans-unit id="75d9d0a9c9a355ba2103db23084500c77872bd8e" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;iodata/0&lt;/code&gt;&lt;/a&gt; type is defined in terms of &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;iolist/0&lt;/code&gt;&lt;/a&gt;. An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself).</source>
          <target state="translated">Встроенный тип &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;iodata/0&lt;/code&gt; &lt;/a&gt; определяется в терминах &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;iolist/0&lt;/code&gt; &lt;/a&gt; . Список ввода-вывода такой же, как данные ввода-вывода, но он не позволяет использовать двоичные файлы на верхнем уровне (но двоичные файлы по-прежнему разрешены в самом списке).</target>
        </trans-unit>
        <trans-unit id="bb521e80a89a4c39c427f904962402bd53b9f9e8" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;iodata/0&lt;/code&gt;&lt;/a&gt; type is defined in terms of &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;iolist/0&lt;/code&gt;&lt;/a&gt;. An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself).</source>
          <target state="translated">Встроенный тип &lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;iodata/0&lt;/code&gt; &lt;/a&gt; определяется в терминах &lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;iolist/0&lt;/code&gt; &lt;/a&gt; . Список ввода-вывода такой же, как данные ввода-вывода, но он не позволяет использовать двоичные файлы на верхнем уровне (но двоичные файлы по-прежнему разрешены в самом списке).</target>
        </trans-unit>
        <trans-unit id="fa702ce8bbd071f4798263a3cd547b0d108c54b2" translate="yes" xml:space="preserve">
          <source>The built-in Elixir String module handles binaries that are UTF-8 encoded. &lt;a href=&quot;http://erlang.org/doc/man/binary.html&quot;&gt;The binary module&lt;/a&gt; is useful when you are dealing with binary data that is not necessarily UTF-8 encoded.</source>
          <target state="translated">Встроенный модуль Elixir String обрабатывает двоичные файлы в кодировке UTF-8. &lt;a href=&quot;http://erlang.org/doc/man/binary.html&quot;&gt;Двоичный модуль&lt;/a&gt; полезен, когда вы имеете дело с двоичными данными, которые не обязательно закодированы в UTF-8.</target>
        </trans-unit>
        <trans-unit id="9912c6244d1c63cb84c34b3a68b26e804aecd085" translate="yes" xml:space="preserve">
          <source>The built-in calendar does not support leap seconds.</source>
          <target state="translated">Встроенный календарь не поддерживает прыжковые секунды.</target>
        </trans-unit>
        <trans-unit id="eac291bdda8b39cdd07415652c800893620c2cab" translate="yes" xml:space="preserve">
          <source>The calendar era.</source>
          <target state="translated">Календарная эра.</target>
        </trans-unit>
        <trans-unit id="c53205e7065bb3ce87323206c4d4e303fc4d8e79" translate="yes" xml:space="preserve">
          <source>The callback is invoked after the compiler runs and it receives a tuple with current status and the list of diagnostic. It must return the updated status and diagnostics.</source>
          <target state="translated">Обратный вызов вызывается после запуска компилятора и получает кортеж с текущим статусом и списком диагностики.Он должен вернуть обновленный статус и диагностику.</target>
        </trans-unit>
        <trans-unit id="b5d5a7fc225ff3dc99ea235a243bb670a176a9d8" translate="yes" xml:space="preserve">
          <source>The calling process is put into a waiting state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future.</source>
          <target state="translated">Вызовной процесс переводится в состояние ожидания,в котором максимально сокращено выделение памяти,что полезно,если процесс не ожидает получения сообщений в ближайшем будущем.</target>
        </trans-unit>
        <trans-unit id="2b5b064f8261c2b03a774df6e6ae6dcd0d5c8140" translate="yes" xml:space="preserve">
          <source>The canonical example for attributes is annotating that a module implements an OTP behaviour, such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Канонический пример атрибутов - это аннотирование того, что модуль реализует поведение OTP, например &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f0b8dfb4a5a810c9b8c195f76200b64770caff21" translate="yes" xml:space="preserve">
          <source>The canonical example for attributes is annotating that a module implements an OTP behaviour, such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Канонический пример атрибутов - это аннотирование того, что модуль реализует поведение OTP, например &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="88868f6d5562a67e7ddaf9b29fc243c12f68bba4" translate="yes" xml:space="preserve">
          <source>The capture operator</source>
          <target state="translated">Оператор захвата</target>
        </trans-unit>
        <trans-unit id="1347b7b88b5541d0e12b97a6af43a979bc085407" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name:</source>
          <target state="translated">Оператор захвата может также использоваться для захвата локальных функций,в том числе частных,и импортируемых функций,пропуская имя модуля:</target>
        </trans-unit>
        <trans-unit id="75226e8489147d2da09b1c8fddde984e1d062fca" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to create anonymous functions that expect at least one argument:</source>
          <target state="translated">Оператор захвата можно также использовать для создания анонимных функций,которые ожидают по крайней мере одного аргумента:</target>
        </trans-unit>
        <trans-unit id="9ef5fce1b72abda5249ca40d94c6bba5adc71084" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to partially apply functions, where &lt;code&gt;&amp;amp;1&lt;/code&gt;, &lt;code&gt;&amp;amp;2&lt;/code&gt; and so on can be used as value placeholders. For example:</source>
          <target state="translated">Оператор захвата также может использоваться для частичного применения функций, где &lt;code&gt;&amp;amp;1&lt;/code&gt; , &lt;code&gt;&amp;amp;2&lt;/code&gt; и т. Д. Могут использоваться в качестве заполнителей значений. Например:</target>
        </trans-unit>
        <trans-unit id="ed78fb3f56be122fa668d8b4473c09f744fcc1e2" translate="yes" xml:space="preserve">
          <source>The capture operator is most commonly used to capture a function with given name and arity from a module:</source>
          <target state="translated">Оператор захвата чаще всего используется для захвата функции с заданным именем и arity из модуля:</target>
        </trans-unit>
        <trans-unit id="daa5b67ac4266d64104c7c678fbebf39b612b043" translate="yes" xml:space="preserve">
          <source>The changes we have performed above have broken our tests because the registry requires the &lt;code&gt;:name&lt;/code&gt; option when starting up. Furthermore, some registry operations such as &lt;code&gt;lookup/2&lt;/code&gt; require the name to be given as an argument, instead of a PID, so we can do the ETS table lookup. Let&amp;rsquo;s change the setup function in &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; to fix both issues:</source>
          <target state="translated">Внесенные выше изменения нарушили наши тесты, потому что при запуске реестра требуется параметр &lt;code&gt;:name&lt;/code&gt; . Более того, некоторые операции реестра, такие как &lt;code&gt;lookup/2&lt;/code&gt; требуют, чтобы имя было указано в качестве аргумента, а не PID, поэтому мы можем выполнить поиск в таблице ETS. Давайте изменим функцию настройки в &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; , чтобы исправить обе проблемы:</target>
        </trans-unit>
        <trans-unit id="a0d4f7e1122a8b55f665626ee09ac09a98518fc5" translate="yes" xml:space="preserve">
          <source>The child specification contains 6 keys. The first two are required, and the remaining ones are optional:</source>
          <target state="translated">Спецификация ребенка содержит 6 ключей.Первые два необходимы,остальные являются необязательными:</target>
        </trans-unit>
        <trans-unit id="7160687e53597f9f0ad549c50eef17c501e4af5e" translate="yes" xml:space="preserve">
          <source>The child specification describes how the supervisor starts, shuts down, and restarts child processes.</source>
          <target state="translated">Спецификация ребенка описывает,как супервайзер запускает,выключает и перезапускает процессы ребенка.</target>
        </trans-unit>
        <trans-unit id="950e3568a25b27f2811958eb0aa95e081e11f40c" translate="yes" xml:space="preserve">
          <source>The child specification is a map containing up to 6 elements. The first two keys in the following list are required, and the remaining ones are optional:</source>
          <target state="translated">Спецификация ребенка-это карта,содержащая до 6 элементов.Первые две клавиши в следующем списке являются обязательными,остальные-необязательными:</target>
        </trans-unit>
        <trans-unit id="42da62bf1cce6040df7eca9209cf8b54396ada67" translate="yes" xml:space="preserve">
          <source>The child specification must exist and the corresponding child process must not be running.</source>
          <target state="translated">Спецификация ребенка должна существовать,и соответствующий дочерний процесс не должен быть запущен.</target>
        </trans-unit>
        <trans-unit id="313526f010da8f629d585c9d88474ee1e8f4898f" translate="yes" xml:space="preserve">
          <source>The children is a list of modules, two-element tuples with module and arguments or a map with the child specification. A strategy is required to be provided through the &lt;code&gt;:strategy&lt;/code&gt; option. See &quot;start_link/2, init/2, and strategies&quot; for examples and other options.</source>
          <target state="translated">Дочерние элементы - это список модулей, двухэлементные кортежи с модулем и аргументами или карта со спецификацией дочернего элемента. Стратегия должна быть предоставлена ​​с помощью опции &lt;code&gt;:strategy&lt;/code&gt; . См. &amp;laquo;Start_link / 2, init / 2 и стратегии&amp;raquo; для примеров и других опций.</target>
        </trans-unit>
        <trans-unit id="53b9ca94898155cae15db3cc7ef654f0bd4da634" translate="yes" xml:space="preserve">
          <source>The choice between &lt;code&gt;:do&lt;/code&gt; keyword and &lt;code&gt;do/end&lt;/code&gt; blocks is left to the user</source>
          <target state="translated">Выбор между &lt;code&gt;:do&lt;/code&gt; ключевое слово и &lt;code&gt;do/end&lt;/code&gt; блоки оставляют пользователю</target>
        </trans-unit>
        <trans-unit id="7b1b61c1ee1c04db8df86f79837449227f41eae5" translate="yes" xml:space="preserve">
          <source>The choice between parens and no parens is a matter of preference.</source>
          <target state="translated">Выбор между парнями и без парней-это вопрос предпочтений.</target>
        </trans-unit>
        <trans-unit id="a3a0a29c159eb1228d94714c1b6b06e0b32d7a74" translate="yes" xml:space="preserve">
          <source>The choice of parens and no parens also affects indentation. When a function call with parens doesn't fit on the same line, the formatter introduces a newline around parens and indents the arguments with two spaces:</source>
          <target state="translated">Выбор парен и отсутствие парен также влияет на вдавливание.Когда вызов функции с парнями не помещается на одной строке,форматер вводит новую строку вокруг парен и отступает аргументы с двумя пробелами:</target>
        </trans-unit>
        <trans-unit id="23594e68f8f770603c0ad519dc9b20dde3e76ac3" translate="yes" xml:space="preserve">
          <source>The clause above will only be invoked if the user's age is more than or equal to 16. A more complete introduction to guards is available &lt;a href=&quot;guards&quot;&gt;in the Guards page&lt;/a&gt;.</source>
          <target state="translated">Вышеупомянутый пункт будет задействован только в том случае, если возраст пользователя больше или равен 16. Более полное введение в охранников доступно &lt;a href=&quot;guards&quot;&gt;на странице Стражи&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba6a994f50b6302be9c679389659a12c3a4b68fd" translate="yes" xml:space="preserve">
          <source>The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. The whole guard is true if all guard expressions will evaluate to &lt;code&gt;true&lt;/code&gt;. A more complete introduction to guards is available &lt;a href=&quot;patterns-and-guards&quot;&gt;in the &quot;Patterns and Guards&quot; page&lt;/a&gt;.</source>
          <target state="translated">Вышеупомянутый пункт будет активирован только в том случае, если возраст пользователя больше или равен 16. Стражи также поддерживают объединение нескольких условий с помощью &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; . Вся защита верна, если все выражения защиты будут иметь значение &lt;code&gt;true&lt;/code&gt; . Более полное введение в охранников доступно &lt;a href=&quot;patterns-and-guards&quot;&gt;на странице &amp;laquo;Выкройки и охранники&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c255b3390bdbf75961fab635ba6b005f6d757746" translate="yes" xml:space="preserve">
          <source>The client sends the given &lt;code&gt;request&lt;/code&gt; to the server and waits until a reply arrives or a timeout occurs. &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; will be called on the server to handle the request.</source>
          <target state="translated">Клиент отправляет данный &lt;code&gt;request&lt;/code&gt; на сервер и ждет, пока не придет ответ или не истечет время ожидания. &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; будет вызываться на сервере для обработки запроса.</target>
        </trans-unit>
        <trans-unit id="d9950721b47bf760ca7644941dac9e25516ba4de" translate="yes" xml:space="preserve">
          <source>The closest representable number to 0.01 is 0.0099999997</source>
          <target state="translated">Ближайшее репрезентабельное число к 0,01-0,0099999997.</target>
        </trans-unit>
        <trans-unit id="94f439e6735d38fbe26e845fc67b04161ed13286" translate="yes" xml:space="preserve">
          <source>The closest representable number to 0.1 is 0.1000000014</source>
          <target state="translated">Ближайшее репрезентабельное число к 0.1-0.1000000014.</target>
        </trans-unit>
        <trans-unit id="a2e208db8b2d737003cfa026657e7817cb56f94b" translate="yes" xml:space="preserve">
          <source>The code above has very long lines and running the formatter is not going to address this issue. In fact, the formatter may make it more obvious that you have complex expressions:</source>
          <target state="translated">В приведенном выше коде есть очень длинные строки,и запуск формирователя не решит эту проблему.На самом деле,форматировщик может сделать более очевидным наличие сложных выражений:</target>
        </trans-unit>
        <trans-unit id="8971296bf8b5fe352cb67c40d256dea059794cfe" translate="yes" xml:space="preserve">
          <source>The code above says we are only bringing in the functions from &lt;code&gt;MyLib&lt;/code&gt; so we can invoke &lt;code&gt;some_fun(arg1, arg2)&lt;/code&gt; directly without the &lt;code&gt;MyLib.&lt;/code&gt; prefix. Even more important, &lt;code&gt;import MyLib&lt;/code&gt; says that we have an option to not &lt;code&gt;import MyLib&lt;/code&gt; at all as we can simply invoke the function as &lt;code&gt;MyLib.some_fun(arg1, arg2)&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше коде говорится, что мы &lt;code&gt;MyLib&lt;/code&gt; только функции из MyLib, поэтому мы можем вызывать &lt;code&gt;some_fun(arg1, arg2)&lt;/code&gt; напрямую, без &lt;code&gt;MyLib.&lt;/code&gt; префикс. &lt;code&gt;import MyLib&lt;/code&gt; еще более важно, import MyLib говорит, что у нас есть возможность вообще не &lt;code&gt;import MyLib&lt;/code&gt; поскольку мы можем просто вызвать функцию как &lt;code&gt;MyLib.some_fun(arg1, arg2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09481c86dbd26d18c6fe8e729156a7702b288946" translate="yes" xml:space="preserve">
          <source>The code above will be kept with one keyword entry per line by the formatter. To avoid that, just squash everything into a single line.</source>
          <target state="translated">Код,приведенный выше,будет сохранен форматировщиком по одному ключевому слову в строке.Чтобы избежать этого,просто раздавите все в одну строку.</target>
        </trans-unit>
        <trans-unit id="5a5a8b1aa48591121657910360da4599001ef7e7" translate="yes" xml:space="preserve">
          <source>The code above will fail because the &lt;code&gt;=&lt;/code&gt; operator always fails when the sides do not match and &lt;a href=&quot;#refute/2&quot;&gt;&lt;code&gt;refute/2&lt;/code&gt;&lt;/a&gt; does not change it.</source>
          <target state="translated">Приведенный выше код завершится ошибкой, потому что оператор &lt;code&gt;=&lt;/code&gt; всегда дает сбой, когда стороны не совпадают, и &lt;a href=&quot;#refute/2&quot;&gt; &lt;code&gt;refute/2&lt;/code&gt; &lt;/a&gt; не меняет его.</target>
        </trans-unit>
        <trans-unit id="d1a28899a290431210335f780f9a3a344e1bdaa4" translate="yes" xml:space="preserve">
          <source>The code above will work but issue a warning: &lt;code&gt;variable &quot;a&quot; is unused&lt;/code&gt;. The macro is overriding the original value and the original value is never used.</source>
          <target state="translated">Приведенный выше код будет работать, но выдаст предупреждение: &lt;code&gt;variable &quot;a&quot; is unused&lt;/code&gt; . Макрос заменяет исходное значение, и исходное значение никогда не используется.</target>
        </trans-unit>
        <trans-unit id="269d3d7086c8d03fa3a689c409e633046b40f522" translate="yes" xml:space="preserve">
          <source>The code above would have the same flaw: if we link the &lt;code&gt;serve(client)&lt;/code&gt; task to the acceptor, a crash when serving a request would bring the acceptor, and consequently all other connections, down.</source>
          <target state="translated">В приведенном выше коде будет тот же недостаток: если мы свяжем задачу &lt;code&gt;serve(client)&lt;/code&gt; с приемником, сбой при обслуживании запроса приведет к отключению приемника и, следовательно, всех других соединений.</target>
        </trans-unit>
        <trans-unit id="382718e17e13c129c8263cdafc53473338fb082d" translate="yes" xml:space="preserve">
          <source>The code in the loaded &lt;code&gt;.iex.exs&lt;/code&gt; file is evaluated in the shell's context. For instance, any modules that are loaded or variables that are bound in the &lt;code&gt;.iex.exs&lt;/code&gt; file will be available in the shell after it has booted.</source>
          <target state="translated">Код в загруженном файле &lt;code&gt;.iex.exs&lt;/code&gt; оценивается в контексте оболочки. Например, все загруженные модули или переменные, связанные с файлом &lt;code&gt;.iex.exs&lt;/code&gt; , будут доступны в оболочке после ее загрузки.</target>
        </trans-unit>
        <trans-unit id="89723bc3e0f1ff8256d889a81362651a037ba774" translate="yes" xml:space="preserve">
          <source>The code is now more readable, as it is now clear which functions are part of your API and which ones are callback implementations. To reinforce this idea, &lt;code&gt;@impl true&lt;/code&gt; automatically marks the function as &lt;code&gt;@doc false&lt;/code&gt;, disabling documentation unless &lt;code&gt;@doc&lt;/code&gt; is explicitly set.</source>
          <target state="translated">Код стал более читабельным, так как теперь ясно, какие функции являются частью вашего API, а какие - реализациями обратного вызова. Чтобы усилить эту идею, &lt;code&gt;@impl true&lt;/code&gt; автоматически помечает функцию как &lt;code&gt;@doc false&lt;/code&gt; , отключая документацию, если &lt;code&gt;@doc&lt;/code&gt; не установлен явно.</target>
        </trans-unit>
        <trans-unit id="27bd571c88e679120d69355a8855de7b06b30a1a" translate="yes" xml:space="preserve">
          <source>The collection types are compared using the following rules:</source>
          <target state="translated">Типы коллекций сравниваются по следующим правилам:</target>
        </trans-unit>
        <trans-unit id="8c5b2a728faaf0d704086c8a732474d34b64c7d1" translate="yes" xml:space="preserve">
          <source>The comma should be followed by a space.</source>
          <target state="translated">За запятой должен следовать пробел.</target>
        </trans-unit>
        <trans-unit id="139636692335607d6eb4460b93391d027f1c3267" translate="yes" xml:space="preserve">
          <source>The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one.</source>
          <target state="translated">Команда выше не работает,потому что мы поменялись снарядами.Так как оболочки изолированы друг от друга,вы не можете получить доступ к переменным,определенным в одной оболочке от другой.</target>
        </trans-unit>
        <trans-unit id="000af91ba82011c87383cf8f5a08713fe7fef900" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;:error&lt;/code&gt;</source>
          <target state="translated">Приведенная выше команда возвращает &lt;code&gt;:error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93e8c4e8d6a9562251088181806121ea8983b620" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;{:ok, bucket}&lt;/code&gt;</source>
          <target state="translated">Приведенная выше команда возвращает &lt;code&gt;{:ok, bucket}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="919db13977d98a781eec05aba6aea3150c8048e9" translate="yes" xml:space="preserve">
          <source>The command above will start a new shell and connect to it. Create a new variable called &lt;code&gt;hello&lt;/code&gt; and assign some value to it:</source>
          <target state="translated">Приведенная выше команда запустит новую оболочку и подключится к ней. Создайте новую переменную &lt;code&gt;hello&lt;/code&gt; и присвойте ей какое-нибудь значение:</target>
        </trans-unit>
        <trans-unit id="604e09637e094315eab98b85fbd210082725e389" translate="yes" xml:space="preserve">
          <source>The command name will correspond to the portion of the module name following &lt;code&gt;Mix.Tasks.&lt;/code&gt;. For example, a module name of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Clean.html&quot;&gt;&lt;code&gt;Mix.Tasks.Deps.Clean&lt;/code&gt;&lt;/a&gt; corresponds to a task name of &lt;code&gt;deps.clean&lt;/code&gt;.</source>
          <target state="translated">Имя команды будет соответствовать части имени модуля после &lt;code&gt;Mix.Tasks.&lt;/code&gt; . Например, имя модуля &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Clean.html&quot;&gt; &lt;code&gt;Mix.Tasks.Deps.Clean&lt;/code&gt; &lt;/a&gt; соответствует имени задачи &lt;code&gt;deps.clean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ecae1fb9875a4247d5f5ea9609a8cfd1c1df1d2" translate="yes" xml:space="preserve">
          <source>The community has also created its own tools, often to aid in production, other times in development:</source>
          <target state="translated">Община также создала свои собственные инструменты,часто для оказания помощи в производстве,в других случаях-в развитии:</target>
        </trans-unit>
        <trans-unit id="efb56379060db8ad190cf0cb0689ca498a14c785" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сравнение между элементами должно выполняться с использованием &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f587be913201bd350f5a6a58f7e5d2545a34fce" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сравнение между элементами должно выполняться с использованием &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86fab95de2a0427fca68934f781f6fe06670a789" translate="yes" xml:space="preserve">
          <source>The compilation can be customized by passing a &lt;code&gt;compile&lt;/code&gt; option in the dependency:</source>
          <target state="translated">Компиляцию можно настроить, передав параметр &lt;code&gt;compile&lt;/code&gt; в зависимости:</target>
        </trans-unit>
        <trans-unit id="b72ead9d1380c933dae651b694aba918748f04d3" translate="yes" xml:space="preserve">
          <source>The compilation will fail because &lt;code&gt;My.Module&lt;/code&gt; when quoted is not an atom, but a syntax tree as follows:</source>
          <target state="translated">Компиляция завершится неудачно, потому что &lt;code&gt;My.Module&lt;/code&gt; в кавычках является не атомом, а следующим синтаксическим деревом:</target>
        </trans-unit>
        <trans-unit id="cd0d32bee722121f8e488a947a395b8badae67cf" translate="yes" xml:space="preserve">
          <source>The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.</source>
          <target state="translated">Скомпилированный шаблон полезен,когда одно и то же совпадение будет повторяться снова и снова.Обратите внимание,что скомпилированный шаблон не может быть сохранен в атрибуте модуля,так как он генерируется во время выполнения и не выдерживает компиляции.</target>
        </trans-unit>
        <trans-unit id="2c261a06d80c478e0111d6983a7ae911378fd70b" translate="yes" xml:space="preserve">
          <source>The compiler is telling us that invoking the &lt;code&gt;join&lt;/code&gt; function with two arguments will always choose the first definition of &lt;code&gt;join&lt;/code&gt; whereas the second one will only be invoked when three arguments are passed:</source>
          <target state="translated">Компилятор сообщает нам, что при вызове функции &lt;code&gt;join&lt;/code&gt; с двумя аргументами всегда будет выбираться первое определение &lt;code&gt;join&lt;/code&gt; тогда как второе будет вызываться только при передаче трех аргументов:</target>
        </trans-unit>
        <trans-unit id="4a5b9456e8b2526749824cf107036fdea5219003" translate="yes" xml:space="preserve">
          <source>The compiler translates this into multiple functions with different arities, here &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; and &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt;, that represent cases when arguments for parameters with default values are passed or not passed.</source>
          <target state="translated">Компилятор переводит это в несколько функций с разной арностью, здесь &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; и &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt; , которые представляют случаи, когда аргументы для параметров со значениями по умолчанию передаются или не передаются.</target>
        </trans-unit>
        <trans-unit id="fbf77ba7c519d57f697a772e3efbb085cc5c852a" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, and so on. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="translated">Компилятор использует временные модули для компиляции кода. Например, &lt;code&gt;elixir_compiler_1&lt;/code&gt; , &lt;code&gt;elixir_compiler_2&lt;/code&gt; и так далее. В случае, если в скомпилированном коде хранятся ссылки на анонимные функции или аналогичные, компилятор Elixir может быть не в состоянии вернуть эти модули, сохраняя ненужный объем кода в памяти и в конечном итоге приводя к таким модулям, как &lt;code&gt;elixir_compiler_12345&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25ad36289d9fc32f9ce285a83c0db949e85318f5" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, etc. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="translated">Компилятор использует временные модули для компиляции кода. Например, &lt;code&gt;elixir_compiler_1&lt;/code&gt; , &lt;code&gt;elixir_compiler_2&lt;/code&gt; и т. Д. В случае, если скомпилированный код хранит ссылки на анонимные функции или аналогичные, компилятор Elixir может быть не в состоянии вернуть эти модули, сохраняя ненужный объем кода в памяти и в конечном итоге приводя к таким модулям, как &lt;code&gt;elixir_compiler_12345&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e326f0b1277ff195521c682d15083f035944526" translate="yes" xml:space="preserve">
          <source>The compiler will infer this argument as &lt;code&gt;map&lt;/code&gt;. Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation:</source>
          <target state="translated">Компилятор выведет этот аргумент как &lt;code&gt;map&lt;/code&gt; . Иногда вывод будет неоптимальным, особенно если функция содержит несколько предложений с сопоставлением аргументов каждый раз с разными значениями. Вы можете указать собственные имена для документации, объявив только заголовок функции в любой момент до реализации:</target>
        </trans-unit>
        <trans-unit id="68165d5af4e0c7518ce750565d2875d5f1b99f6f" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, e.g. &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="translated">Сложность &lt;code&gt;a ++ b&lt;/code&gt; пропорциональна &lt;code&gt;length(a)&lt;/code&gt; , поэтому избегайте повторного добавления в списки произвольной длины, например &lt;code&gt;list ++ [element]&lt;/code&gt; . Вместо этого рассмотрите возможность добавления с помощью &lt;code&gt;[element | rest]&lt;/code&gt; а затем задним ходом.</target>
        </trans-unit>
        <trans-unit id="51b97324d416e9860c0329e32ca5a0050e8a20b3" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, for example, &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="translated">Сложность &lt;code&gt;a ++ b&lt;/code&gt; пропорциональна &lt;code&gt;length(a)&lt;/code&gt; , поэтому избегайте повторного добавления в списки произвольной длины, например, &lt;code&gt;list ++ [element]&lt;/code&gt; . Вместо этого рассмотрите возможность добавления с помощью &lt;code&gt;[element | rest]&lt;/code&gt; а затем задним ходом.</target>
        </trans-unit>
        <trans-unit id="ce5190846b0b9ce88bde5e1fb9838155c0302562" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a -- b&lt;/code&gt; is proportional to &lt;code&gt;length(a) * length(b)&lt;/code&gt;, meaning that it will be very slow if both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are long lists. In such cases, consider converting each list to a &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; and using &lt;a href=&quot;mapset#difference/2&quot;&gt;&lt;code&gt;MapSet.difference/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сложность &lt;code&gt;a -- b&lt;/code&gt; пропорциональна &lt;code&gt;length(a) * length(b)&lt;/code&gt; , что означает, что он будет очень медленным, если и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; являются длинными списками. В таких случаях рассмотрите возможность преобразования каждого списка в &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; и использования &lt;a href=&quot;mapset#difference/2&quot;&gt; &lt;code&gt;MapSet.difference/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84ce76ba55c26126100351cef4100465580a3f63" translate="yes" xml:space="preserve">
          <source>The compressed option must be combined with either read or write, but not both. Note that the file size obtained with &lt;a href=&quot;#stat/1&quot;&gt;&lt;code&gt;stat/1&lt;/code&gt;&lt;/a&gt; will most probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="translated">Параметр сжатия должен сочетаться с чтением или записью, но не с обоими. Обратите внимание, что размер файла, полученный с помощью &lt;a href=&quot;#stat/1&quot;&gt; &lt;code&gt;stat/1&lt;/code&gt; &lt;/a&gt; , скорее всего, не будет соответствовать количеству байтов, которое можно прочитать из сжатого файла.</target>
        </trans-unit>
        <trans-unit id="6d2bc42beb1d07a11bffabca4e75ecee65b8f3cc" translate="yes" xml:space="preserve">
          <source>The concurrency can be increased or decreased using the &lt;code&gt;:max_concurrency&lt;/code&gt; option. For example, if the tasks are IO heavy, the value can be increased:</source>
          <target state="translated">Параллелизм можно увеличить или уменьшить с помощью параметра &lt;code&gt;:max_concurrency&lt;/code&gt; . Например, если задачи требуют ввода-вывода, значение можно увеличить:</target>
        </trans-unit>
        <trans-unit id="2dcb06049bb00d9d82db3a23393505f88e85183b" translate="yes" xml:space="preserve">
          <source>The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them.</source>
          <target state="translated">Конфигурации сливаются со значениями во второй,имеющей более высокое предпочтение,чем первая в случае конфликтов.В случае,если оба значения установлены в списки ключевых слов,происходит их глубокое слияние.</target>
        </trans-unit>
        <trans-unit id="8bfd0598c3186c98ed3b75f81d353f661a54c9d0" translate="yes" xml:space="preserve">
          <source>The console backend allows you to customize the format of your log messages with the &lt;code&gt;:format&lt;/code&gt; option.</source>
          <target state="translated">Серверная часть консоли позволяет настраивать формат сообщений журнала с помощью параметра &lt;code&gt;:format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7235027880d78a2aea2ca7dc4debaca1a57f60b0" translate="yes" xml:space="preserve">
          <source>The console backend logs messages by printing them to the console. It supports the following options:</source>
          <target state="translated">Бэкэнд консоли регистрирует сообщения,распечатывая их на консоли.Она поддерживает следующие опции:</target>
        </trans-unit>
        <trans-unit id="b55d6ec1cda71844493902f9fd51af5232de80cd" translate="yes" xml:space="preserve">
          <source>The contents are compared to avoid asking the user to override if the contents did not change. Returns false if the file exists and the content is the same or the user forbade to override it. Returns true otherwise.</source>
          <target state="translated">Содержимое сравнивается,чтобы не просить пользователя переопределить,если содержимое не изменилось.Возвращает false,если файл существует и его содержимое одинаковое или пользователь запретил его переопределять.Возвращает true иначе.</target>
        </trans-unit>
        <trans-unit id="8de6b43b33ab75286e101ec804e217bdf4636eeb" translate="yes" xml:space="preserve">
          <source>The context is used to pass information from the callbacks to the test. In order to pass information from the test to the callback, ExUnit provides tags.</source>
          <target state="translated">Контекст используется для передачи информации от обратных вызовов к тесту.Для передачи информации из теста в обратный вызов ExUnit предоставляет теги.</target>
        </trans-unit>
        <trans-unit id="0ac124f60dd5f0bf6457e5116fc9264ff455388d" translate="yes" xml:space="preserve">
          <source>The context returned by &lt;a href=&quot;#setup_all/1&quot;&gt;&lt;code&gt;setup_all/1&lt;/code&gt;&lt;/a&gt; will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself. For instance, the &lt;code&gt;conn&lt;/code&gt; from the previous example can be accessed as:</source>
          <target state="translated">Контекст, возвращаемый &lt;a href=&quot;#setup_all/1&quot;&gt; &lt;code&gt;setup_all/1&lt;/code&gt; ,&lt;/a&gt; будет доступен во всех последующих &lt;code&gt;setup_all&lt;/code&gt; , &lt;code&gt;setup&lt;/code&gt; и самом &lt;code&gt;test&lt;/code&gt; . Например, &lt;code&gt;conn&lt;/code&gt; из предыдущего примера можно получить как:</target>
        </trans-unit>
        <trans-unit id="df9b547258c058ce1d60f5a04eb16b39a7714b90" translate="yes" xml:space="preserve">
          <source>The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result.</source>
          <target state="translated">Продолжением является закрытие,возвращенное в результате,когда перепись приостановлена.При вызове он ожидает нового аккумулятора и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="95e2451a8bd06ec3ff7404ffc596006e9814e181" translate="yes" xml:space="preserve">
          <source>The correct way to write the refutation above is to use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Правильный способ написать опровержение выше - использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt; &lt;code&gt;Kernel.match?/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="471e051b1dfc7605a0864374979ff909fdd918ff" translate="yes" xml:space="preserve">
          <source>The corresponding child process must not be running; use &lt;a href=&quot;#terminate_child/2&quot;&gt;&lt;code&gt;terminate_child/2&lt;/code&gt;&lt;/a&gt; to terminate it if it's running.</source>
          <target state="translated">Соответствующий дочерний процесс не должен быть запущен; используйте &lt;a href=&quot;#terminate_child/2&quot;&gt; &lt;code&gt;terminate_child/2&lt;/code&gt; ,&lt;/a&gt; чтобы завершить его, если он запущен.</target>
        </trans-unit>
        <trans-unit id="25f2832dc850f5e3ce868623e448ed6173ae8a76" translate="yes" xml:space="preserve">
          <source>The crypto module</source>
          <target state="translated">Модуль криптографии</target>
        </trans-unit>
        <trans-unit id="6c25b4183ffb2089e8226e185f14e599e79dc998" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">К текущей среде можно получить доступ в любое время как &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; . Внутри макросов к среде вызывающего абонента можно получить доступ как &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ecd090fb1dcdddfdde8d184412bdb4ef34572bf" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">К текущей среде можно получить доступ в любое время как &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; . Внутри макросов к среде вызывающего абонента можно получить доступ как &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3e60a2c1efd523ca96fe66ffa2af8ecfa3ad2af" translate="yes" xml:space="preserve">
          <source>The current working directory is set for the BEAM globally. This can lead to race conditions if multiple processes are changing the current working directory concurrently. To run an external command in a given directory without changing the global current working directory, use the &lt;code&gt;:cd&lt;/code&gt; option of &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Текущий рабочий каталог устанавливается для BEAM глобально. Это может привести к состояниям гонки, если несколько процессов одновременно изменяют текущий рабочий каталог. Чтобы запустить внешнюю команду в заданном каталоге без изменения глобального текущего рабочего каталога, используйте параметр &lt;code&gt;:cd&lt;/code&gt; в &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11ca9436cf4382b007a36385f24017c6fe9ea438" translate="yes" xml:space="preserve">
          <source>The daemon will write all of its standard output to the &quot;tmp/log/&quot; directory in the release root. You can watch the log file by doing &lt;code&gt;tail -f tmp/log/erlang.log.1&lt;/code&gt; or similar. Once files get too large, the index suffix will be incremented. A developer can also attach to the standard input of the daemon by invoking &quot;to_erl tmp/pipe/&quot; from the release root. However, note that attaching to the system should be done with extreme care, since the usual commands for exiting an Elixir system, such as hitting Ctrl+C twice or Ctrl+\, will actually shut down the daemon. Therefore, using &lt;code&gt;bin/RELEASE_NAME remote&lt;/code&gt; should be preferred, even in daemon mode.</source>
          <target state="translated">Демон будет записывать весь свой стандартный вывод в каталог &amp;laquo;tmp / log /&amp;raquo; в корне выпуска. Вы можете просмотреть файл журнала, выполнив &lt;code&gt;tail -f tmp/log/erlang.log.1&lt;/code&gt; или аналогичный. Когда файлы становятся слишком большими, суффикс индекса будет увеличиваться. Разработчик также может подключиться к стандартному вводу демона, вызвав &quot;to_erl tmp / pipe /&quot; из корня выпуска. Однако обратите внимание, что подключение к системе должно выполняться с особой осторожностью, поскольку обычные команды для выхода из системы Elixir, такие как двойное нажатие Ctrl + C или Ctrl + \, фактически завершают работу демона. Следовательно, использование &lt;code&gt;bin/RELEASE_NAME remote&lt;/code&gt; предпочтительнее даже в режиме демона.</target>
        </trans-unit>
        <trans-unit id="d8cd8e8b468d03cac9b2aec5728511f109cbd6ae" translate="yes" xml:space="preserve">
          <source>The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol.</source>
          <target state="translated">Структура данных,для которой вы реализуете протокол,должна быть первым аргументом для всех функций,определенных в протоколе.</target>
        </trans-unit>
        <trans-unit id="b2d538224a6564739f222b37335408e88b676276" translate="yes" xml:space="preserve">
          <source>The date and time fields in the struct can be accessed directly:</source>
          <target state="translated">К полям даты и времени в структуре можно получить прямой доступ:</target>
        </trans-unit>
        <trans-unit id="efa23e38a0ca17fbedb614ea88023f4b1e8f6b6f" translate="yes" xml:space="preserve">
          <source>The datetime can be any of the Calendar types (&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;) or any map, as long as they contain all of the relevant fields necessary for formatting. For example, if you use &lt;code&gt;%Y&lt;/code&gt; to format the year, the datetime must have the &lt;code&gt;:year&lt;/code&gt; field. Therefore, if you pass a &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, or a map without the &lt;code&gt;:year&lt;/code&gt; field to a format that expects &lt;code&gt;%Y&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; может быть любым из типов Calendar ( &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; и DateTime ) или любой картой, если они содержат все соответствующие поля, необходимые для форматирования. Например, если вы используете &lt;code&gt;%Y&lt;/code&gt; для форматирования года, в поле datetime должно быть поле &lt;code&gt;:year&lt;/code&gt; . Следовательно, если вы передадите &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; или карту без поля &lt;code&gt;:year&lt;/code&gt; в формат, ожидающий &lt;code&gt;%Y&lt;/code&gt; , возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="104ca7733bdc0fce19ec1a42bd6f6c3a9728b295" translate="yes" xml:space="preserve">
          <source>The days are counted as Gregorian days. The date is returned in the same calendar as it was given in.</source>
          <target state="translated">Дни считаются григорианскими.Дата возвращается в том же календаре,в котором она была указана.</target>
        </trans-unit>
        <trans-unit id="81de1658f9b930a338fa7d15b3cd46a31f6ce081" translate="yes" xml:space="preserve">
          <source>The default engine used by EEx.</source>
          <target state="translated">Двигатель по умолчанию,используемый EEx.</target>
        </trans-unit>
        <trans-unit id="5c2506b585933bcf9d63b9d589d2095db52d7f38" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="translated">Узлом по умолчанию является &lt;a href=&quot;#self/0&quot;&gt; &lt;code&gt;Node.self/0&lt;/code&gt; &lt;/a&gt; , локальный узел. Если &lt;code&gt;node&lt;/code&gt; является локальным узлом, функция также устанавливает cookie всех других неизвестных узлов в &lt;code&gt;cookie&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1841b4dcd409156ad003b434d7d06485770c7448" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;node#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="translated">Узлом по умолчанию является &lt;a href=&quot;node#self/0&quot;&gt; &lt;code&gt;Node.self/0&lt;/code&gt; &lt;/a&gt; , локальный узел. Если &lt;code&gt;node&lt;/code&gt; является локальным узлом, функция также устанавливает cookie всех других неизвестных узлов в &lt;code&gt;cookie&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee7448078e00a12f44bc6d6a512061a6e8e76068" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The first row after the header contains the sums of the partial results and the average time for all the function calls listed. The following rows contain the function call, followed by the number of times that the function was called, then by the percentage of time that the call uses, then the total time for that function in microseconds, and, finally, the average time per call in microseconds.</source>
          <target state="translated">Выход по умолчанию содержит данные,собранные из всех соответствующих функций.Первая строка после заголовка содержит суммы частичных результатов и среднее время всех перечисленных вызовов функций.Следующие строки содержат вызов функции,затем количество раз,когда была вызвана функция,затем процент времени,которое используется вызов,затем общее время для этой функции в микросекундах,и,наконец,среднее время для каждого вызова в микросекундах.</target>
        </trans-unit>
        <trans-unit id="ea39ed70f4785b6c480b790dacca9bfe36cb2b1f" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The left column structures each module and its total call count trace is presented on the right. Each module has its count discriminated by function below. The &lt;code&gt;&amp;lt;--&lt;/code&gt; symbol is meant to help visualize where a new module call count begins.</source>
          <target state="translated">Выходные данные по умолчанию содержат данные, собранные всеми соответствующими функциями. В левом столбце структурируется каждый модуль, а его общий счетчик вызовов представлен справа. Каждый модуль имеет свой счетчик, который различается по функциям ниже. Символ &lt;code&gt;&amp;lt;--&lt;/code&gt; предназначен для визуализации того, где начинается счетчик вызовов нового модуля.</target>
        </trans-unit>
        <trans-unit id="819e6f3391fb45f7ce5241a6dd1d1431dc481702" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all profiled processes. All times are wall clock milliseconds. The columns have the following meaning:</source>
          <target state="translated">Вывод по умолчанию содержит данные,собранные из всех профилированных процессов.Все время-это миллисекунды настенных часов.Столбцы имеют следующее значение:</target>
        </trans-unit>
        <trans-unit id="27a16bfaa2e09572a48e318dc8d0f73e02fd7ff6" translate="yes" xml:space="preserve">
          <source>The default value will not be passed through the update function.</source>
          <target state="translated">Значение по умолчанию не будет передано через функцию обновления.</target>
        </trans-unit>
        <trans-unit id="380321e8388d234e55ec92513260d8b22df6e305" translate="yes" xml:space="preserve">
          <source>The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example:</source>
          <target state="translated">Определение,приведенное выше,не будет работать для данного конкретного примера,так как оно будет пытаться запустить счетчик с начальным значением пустого списка.Однако,это может быть жизнеспособным вариантом в ваших собственных агентах.Общий подход заключается в использовании списка ключевых слов,так как это позволило бы установить начальное значение и дать имя процессу счетчика,например:</target>
        </trans-unit>
        <trans-unit id="14e3a7f1b4ff430ef2347af078514bfcd6aac53f" translate="yes" xml:space="preserve">
          <source>The dependencies' versions are expected to be formatted according to Semantic Versioning and the requirements must be specified as defined in the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Ожидается, что версии зависимостей будут отформатированы в соответствии с семантическим управлением версиями, а требования должны быть указаны, как определено в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0199850bb5adebc71f4018576818506ad556f1cc" translate="yes" xml:space="preserve">
          <source>The device will be created and sent to the function given. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">Устройство будет создано и отправлено указанной функции. Когда функция вернется, устройство будет закрыто. Конечным результатом будет кортеж с &lt;code&gt;:ok&lt;/code&gt; и результатом функции.</target>
        </trans-unit>
        <trans-unit id="92c1c70614d3e16189eb567106d0cd377288e598" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; is that the latter is more strict when comparing integers and floats:</source>
          <target state="translated">Разница между &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;===&lt;/code&gt; в том, что последний более строгий при сравнении целых чисел и чисел с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="bce9ae6a81650ed69afbfa89ac267aa5dbf3c9da" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Разница между этими двумя подходами заключается в том, что супервизор на основе модулей дает вам более прямой контроль над инициализацией супервизора. Вместо того, чтобы вызывать &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt; со списком автоматически инициализируемых потомков, мы вручную инициализировали потомков, вызвав &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt; внутри его обратного вызова &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b165d79002d46e097dd675e283b2c25db64a858" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;supervisor#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Разница между этими двумя подходами заключается в том, что супервизор на основе модулей дает вам более прямой контроль над инициализацией супервизора. Вместо вызова &lt;a href=&quot;supervisor#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt; со списком автоматически инициализируемых дочерних элементов мы вручную инициализировали дочерние элементы, вызвав &lt;a href=&quot;supervisor#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt; внутри его обратного вызова &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5eb7b6faff508891acf9d2eb056d03565a244c" translate="yes" xml:space="preserve">
          <source>The difference is that anonymous functions require the target node to have exactly the same code version as the caller. Using module, function, and arguments is more robust because you only need to find a function with matching arity in the given module.</source>
          <target state="translated">Разница в том,что анонимные функции требуют,чтобы целевой узел имел точно такую же версию кода,как и вызывающий абонент.Использование модуля,функции и аргументов более надежно,так как в данном модуле нужно только найти функцию с совпадающей массивностью.</target>
        </trans-unit>
        <trans-unit id="42de26ff16cbc728a59ab8e0d11febc5d9712289" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Разница в том, что &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; ожидает дочернюю спецификацию в момент &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; , а не при обратном вызове init. Если при инициализации заданы какие-либо начальные аргументы, такие как &lt;code&gt;[initial_arg]&lt;/code&gt; , их можно &lt;code&gt;:extra_arguments&lt;/code&gt; флаге : extra_arguments в &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5358501133f2ba56bf1b306cdd649fc8fee2e62a" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Разница в том, что &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; ожидает дочернюю спецификацию в момент &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; , а не при обратном вызове init. Если при инициализации заданы какие-либо начальные аргументы, такие как &lt;code&gt;[initial_arg]&lt;/code&gt; , их можно &lt;code&gt;:extra_arguments&lt;/code&gt; флаге : extra_arguments в &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53c4296a8b739f59bee25619f4e6585ba6646d78" translate="yes" xml:space="preserve">
          <source>The digraph module</source>
          <target state="translated">Модуль диграфа</target>
        </trans-unit>
        <trans-unit id="d3687778e68f2e38fa3eb29706a7417475b459a2" translate="yes" xml:space="preserve">
          <source>The document starts flat (without breaks) until a group is found.</source>
          <target state="translated">Документ начинается плоско (без перерывов)до тех пор,пока не будет найдена группа.</target>
        </trans-unit>
        <trans-unit id="2ad969954076e16dcc1ff7f0c2aba06e5e46ee7f" translate="yes" xml:space="preserve">
          <source>The dot (&lt;code&gt;.&lt;/code&gt;) in Elixir can be used for remote calls:</source>
          <target state="translated">Точка ( &lt;code&gt;.&lt;/code&gt; ) В Elixir может использоваться для удаленных вызовов:</target>
        </trans-unit>
        <trans-unit id="555f5e20b9d1a7a0564cfc99c5aa3c497147b302" translate="yes" xml:space="preserve">
          <source>The dot may be used to invoke anonymous functions too:</source>
          <target state="translated">Точка может быть использована и для вызова анонимных функций:</target>
        </trans-unit>
        <trans-unit id="6bfa76913b9787750a0bfa227b60b3c7658a646a" translate="yes" xml:space="preserve">
          <source>The downside of this approach is that the doctest result is not really what users would see in the terminal.</source>
          <target state="translated">Недостатком такого подхода является то,что результат доктеста на самом деле не тот,что пользователи увидят в терминале.</target>
        </trans-unit>
        <trans-unit id="2b457ad21100bb14e953ebf6025ecbe3add69796" translate="yes" xml:space="preserve">
          <source>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</source>
          <target state="translated">Элементы в обоих возвращаемых списках расположены в том же относительном порядке,что и в исходном списке (если такой список был упорядочен,как и список).См.примеры ниже.</target>
        </trans-unit>
        <trans-unit id="46fd29816806a299fb407c730c9ba36ba20c158f" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. It is required to return either &lt;code&gt;{:ok, term}&lt;/code&gt;, where term is an atom. It is possible to return something else than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="translated">Предполагается, что функция кодировщика создает атом из заданной строки. Требуется вернуть либо &lt;code&gt;{:ok, term}&lt;/code&gt; , где term - атом. Однако можно вернуть что-то еще, кроме атома, в этом случае AST больше не является &quot;действительным&quot;, поскольку его нельзя использовать для компиляции или оценки кода Elixir. Вариант использования для этого - если вы хотите использовать парсер Elixir в ситуации, связанной с пользователем, но не хотите исчерпывать таблицу атомов.</target>
        </trans-unit>
        <trans-unit id="865f48d17fe14cd4996952b1bd0f45d973a938ce" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. To produce a valid AST, it is required to return &lt;code&gt;{:ok, term}&lt;/code&gt;, where &lt;code&gt;term&lt;/code&gt; is an atom. It is possible to return something other than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="translated">Предполагается, что функция кодировщика создает атом из данной строки. Чтобы создать действительный AST, необходимо вернуть &lt;code&gt;{:ok, term}&lt;/code&gt; , где &lt;code&gt;term&lt;/code&gt; - это атом. Однако можно вернуть что-то другое, кроме атома, в этом случае AST больше не является &amp;laquo;действительным&amp;raquo;, поскольку его нельзя использовать для компиляции или оценки кода Elixir. Вариант использования для этого - если вы хотите использовать парсер Elixir в ситуации, связанной с пользователем, но вы не хотите исчерпывать таблицу атомов.</target>
        </trans-unit>
        <trans-unit id="7abcd054d6c0c3b0676a107d280986f037e15ba1" translate="yes" xml:space="preserve">
          <source>The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt;.</source>
          <target state="translated">Функция кодировщика получит имя атома (в двоичном формате) и список ключевых слов с текущим файлом, строкой и столбцом. Он должен возвращать &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d93739e1f908805f248fbd3ca05efb8a31a93ffb" translate="yes" xml:space="preserve">
          <source>The environment</source>
          <target state="translated">Окружающая среда</target>
        </trans-unit>
        <trans-unit id="b1059c7023600cf66d37436e09b5b8c7e27f7d77" translate="yes" xml:space="preserve">
          <source>The environment applies only to the current project. As we will see in future chapters, any dependency you add to your project will by default run in the &lt;code&gt;:prod&lt;/code&gt; environment.</source>
          <target state="translated">Среда применяется только к текущему проекту. Как мы увидим в следующих главах, любая зависимость, которую вы добавляете в свой проект, по умолчанию будет выполняться в среде &lt;code&gt;:prod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="569fc959f1dad768558df72d1e65bcb68e016b15" translate="yes" xml:space="preserve">
          <source>The environment can be changed via the command line by setting the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable, for example:</source>
          <target state="translated">Среду можно изменить через командную строку, установив &lt;code&gt;MIX_ENV&lt;/code&gt; среды MIX_ENV , например:</target>
        </trans-unit>
        <trans-unit id="514025daae02cae2313ca1d48fbcc882bf070826" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#env/0&quot;&gt; &lt;code&gt;Mix.env/0&lt;/code&gt; &lt;/a&gt; можно прочитать через Mix.env / 0 .</target>
        </trans-unit>
        <trans-unit id="cfd48ae86d7fb6e0cc9118fb73487346d9610f87" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;mix#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mix#env/0&quot;&gt; &lt;code&gt;Mix.env/0&lt;/code&gt; &lt;/a&gt; можно прочитать через Mix.env / 0 .</target>
        </trans-unit>
        <trans-unit id="79b786be3813b81bda2dd7613367e75b678039b6" translate="yes" xml:space="preserve">
          <source>The environment is available after loading the application, which is a process explained later:</source>
          <target state="translated">Среда доступна после загрузки приложения,что является процессом,описанным ниже:</target>
        </trans-unit>
        <trans-unit id="97a5f35bc8e443b15b7816310584c96da8ae8afe" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;exunit.test&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exunit.testmodule&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Состояние ошибки, возвращаемое &lt;a href=&quot;exunit.test&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;exunit.testmodule&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1dd062c870a86dc73f9a75e2843a53a9fc3ffd4b" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Состояние ошибки, возвращаемое &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67a7d2b9fd9ee22fe670aa85c88c37eecda3144b" translate="yes" xml:space="preserve">
          <source>The exact chunks that are kept are not documented and may change in future versions.</source>
          <target state="translated">Точные куски,которые хранятся,не документируются и могут быть изменены в будущих версиях.</target>
        </trans-unit>
        <trans-unit id="fd79581f4945ce7000f24bd77d80edb09d58223a" translate="yes" xml:space="preserve">
          <source>The example above broadcasted the message &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; to all processes registered under the &quot;topic&quot; (or &quot;key&quot; as we called it until now) &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере сообщение &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; всем процессам, зарегистрированным под &quot;темой&quot; (или &quot;ключом&quot;, как мы это называли до сих пор) &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85cebbc730e74ea1586122c70e3648ace6b606a3" translate="yes" xml:space="preserve">
          <source>The example above has a pipeline of operations. We start with a range and then multiply each element in the range by 3. This first operation will now create and return a list with &lt;code&gt;100_000&lt;/code&gt; items. Then we keep all odd elements from the list, generating a new list, now with &lt;code&gt;50_000&lt;/code&gt; items, and then we sum all entries.</source>
          <target state="translated">В приведенном выше примере есть конвейер операций. Мы начинаем с диапазона, а затем умножаем каждый элемент в диапазоне на 3. Эта первая операция теперь создаст и вернет список из &lt;code&gt;100_000&lt;/code&gt; элементов. Затем мы сохраняем все нечетные элементы из списка, генерируя новый список, теперь с &lt;code&gt;50_000&lt;/code&gt; элементами, а затем суммируем все записи.</target>
        </trans-unit>
        <trans-unit id="d7a86a0bce3d2d4979cfe2b252cb1ba44bf3ffc0" translate="yes" xml:space="preserve">
          <source>The example above is the same as calling &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt;.</source>
          <target state="translated">Приведенный выше пример аналогичен вызову &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a98e7e58a5ad26483cead8675329ffdc04e919" translate="yes" xml:space="preserve">
          <source>The example above rescues the runtime error and returns the error itself which is then printed in the &lt;code&gt;iex&lt;/code&gt; session.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;iex&lt;/code&gt; ошибка времени выполнения и возвращается сама ошибка, которая затем печатается в сеансе IEX .</target>
        </trans-unit>
        <trans-unit id="a1acf2309aa592e7d6d6148eb2c43c7439baf836" translate="yes" xml:space="preserve">
          <source>The example above shows the preferred strategy for customizing exception messages.</source>
          <target state="translated">В приведенном выше примере показана предпочтительная стратегия настройки сообщений об исключениях.</target>
        </trans-unit>
        <trans-unit id="7c4ee977260f8fcae5e39eaa8c9f47beb473c79e" translate="yes" xml:space="preserve">
          <source>The example above will define two modules: &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt;. The second can be accessed as &lt;code&gt;Bar&lt;/code&gt; inside &lt;code&gt;Foo&lt;/code&gt; as long as they are in the same lexical scope. The code above is exactly the same as:</source>
          <target state="translated">В приведенном выше примере будут определены два модуля: &lt;code&gt;Foo&lt;/code&gt; и &lt;code&gt;Foo.Bar&lt;/code&gt; . Ко вторым можно получить доступ как &lt;code&gt;Bar&lt;/code&gt; внутри &lt;code&gt;Foo&lt;/code&gt; , если они находятся в той же лексической области. Код выше точно такой же, как:</target>
        </trans-unit>
        <trans-unit id="8af5b80536d2c072fd5d6366536aa5700dca7b65" translate="yes" xml:space="preserve">
          <source>The example above will fetch the first 10 lines of the file you have selected. This means streams can be very useful for handling large files or even slow resources like network resources.</source>
          <target state="translated">В приведенном выше примере будут получены первые 10 строк выбранного вами файла.Это означает,что потоки могут быть очень полезны для работы с большими файлами или даже медленными ресурсами,такими как сетевые ресурсы.</target>
        </trans-unit>
        <trans-unit id="696bcc0172521f253466c2cb561bc8d6cc698268" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="translated">Приведенный выше пример будет работать, только если &lt;code&gt;x&lt;/code&gt; соответствует первому значению в правом списке. В противном случае это вызовет &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt; (как это сделал бы оператор &lt;code&gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5335acb8d877ec62b7cb06ce91a567ae1709575" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="translated">Приведенный выше пример будет работать, только если &lt;code&gt;x&lt;/code&gt; соответствует первому значению в правом списке. В противном случае это вызовет &lt;a href=&quot;matcherror&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt; (как это сделал бы оператор &lt;code&gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b460f75ed7a246aed0999b0840cd9a86244be18" translate="yes" xml:space="preserve">
          <source>The example above will print:</source>
          <target state="translated">Пример выше будет распечатан:</target>
        </trans-unit>
        <trans-unit id="fb87f61c9de07aa0c29854b1fe6c1165c0f17fed" translate="yes" xml:space="preserve">
          <source>The example above will run all tests that have the external option set to &lt;code&gt;true&lt;/code&gt;. It is also possible to include all examples that have a given tag, regardless of its value:</source>
          <target state="translated">В приведенном выше примере будут запущены все тесты, для которых для параметра external установлено значение &lt;code&gt;true&lt;/code&gt; . Также можно включить все примеры с данным тегом, независимо от его значения:</target>
        </trans-unit>
        <trans-unit id="a35cc3928c93cd1525534e5aae37a525e3a1f63a" translate="yes" xml:space="preserve">
          <source>The example below prints the available compilers and then the list of dependencies.</source>
          <target state="translated">В примере ниже распечатываются доступные компиляторы,а затем список зависимостей.</target>
        </trans-unit>
        <trans-unit id="fd542bcb5f7a7bfb0b02572bb9041c4454ce88bf" translate="yes" xml:space="preserve">
          <source>The examples below use the &lt;code&gt;:exrop&lt;/code&gt; pseudorandom algorithm since it's the default from Erlang/OTP 20, however if you are using Erlang/OTP 22 or above then &lt;code&gt;:exsss&lt;/code&gt; is the default algorithm. If you are using &lt;code&gt;:exsplus&lt;/code&gt;, then please update, as this algorithm is deprecated since Erlang/OTP 20.</source>
          <target state="translated">В приведенных ниже примерах используется псевдослучайный алгоритм &lt;code&gt;:exrop&lt;/code&gt; , поскольку он используется по умолчанию в Erlang / OTP 20, однако, если вы используете Erlang / OTP 22 или выше, тогда &lt;code&gt;:exsss&lt;/code&gt; является алгоритмом по умолчанию. Если вы используете &lt;code&gt;:exsplus&lt;/code&gt; , обновите его, так как этот алгоритм устарел с Erlang / OTP 20.</target>
        </trans-unit>
        <trans-unit id="977b62dac31ac2298799e3e82efadb76ace792aa" translate="yes" xml:space="preserve">
          <source>The examples below will use &lt;code&gt;break!&lt;/code&gt;, assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name &lt;code&gt;IEx.break!&lt;/code&gt;.</source>
          <target state="translated">В примерах ниже будет использоваться &lt;code&gt;break!&lt;/code&gt; , предполагая, что вы устанавливаете точку останова прямо из оболочки IEx. Но вы можете настроить перерыв из любого места, используя полное имя &lt;code&gt;IEx.break!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="598b6c321009ab41147aeda0cc432613c93bc6ff" translate="yes" xml:space="preserve">
          <source>The exception type</source>
          <target state="translated">Тип исключения</target>
        </trans-unit>
        <trans-unit id="96d166dd9433a91274c33b5c64faa14557b71d73" translate="yes" xml:space="preserve">
          <source>The expected result should start at the next line after the &lt;code&gt;iex&amp;gt;&lt;/code&gt; or &lt;code&gt;...&amp;gt;&lt;/code&gt; line(s) and it is terminated either by a newline.</source>
          <target state="translated">Ожидаемый результат должен начинаться со следующей строки после строки (строк) &lt;code&gt;iex&amp;gt;&lt;/code&gt; или &lt;code&gt;...&amp;gt;&lt;/code&gt; и заканчиваться либо новой строкой.</target>
        </trans-unit>
        <trans-unit id="ef1dcbe751c0f9e41d4eb9dc12ae9aa4ff81e740" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</source>
          <target state="translated">Тот факт,что эта функция использует термин упорядочения Эрланга,означает,что сравнение является структурным,а не семантическим.Например:</target>
        </trans-unit>
        <trans-unit id="9d619b509d29dcc70d09a1c1eedfade7f7d69f11" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">Тот факт, что эта функция использует термин упорядочение Эрланга, означает, что сравнение является структурным, а не семантическим. Поэтому, если вы хотите сравнить структуры, большинство структур предоставляют функцию &amp;laquo;сравнения&amp;raquo;, например &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt; , которая получает две структуры и возвращает &lt;code&gt;:lt&lt;/code&gt; (меньше-чем) ,: &lt;code&gt;:eq&lt;/code&gt; (равно) и &lt;code&gt;:gt&lt;/code&gt; (лучше чем). Если вы передадите модуль в качестве функции сортировки, Elixir автоматически будет использовать функцию &lt;code&gt;compare/2&lt;/code&gt; указанного модуля:</target>
        </trans-unit>
        <trans-unit id="a8e9535a979f24690a83f0d69ec866c95c5b87d9" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;enum#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="translated">Эта функция устарела за счет выдачи предупреждений об использовании. Это также известно как отказ от поддержки. Чтобы объявить функцию устаревшей, предлагаемая альтернатива ДОЛЖНА существовать как минимум для ТРЕХ второстепенных версий. Например, &lt;code&gt;Enum.uniq/2&lt;/code&gt; был мягко устаревшим в пользу &lt;a href=&quot;enum#uniq_by/2&quot;&gt; &lt;code&gt;Enum.uniq_by/2&lt;/code&gt; &lt;/a&gt; в Elixir v1.1. Это означает, что предупреждение об устаревании может выдаваться только Elixir v1.4 или новее.</target>
        </trans-unit>
        <trans-unit id="767e9fa4f6cbd49737c9ee934e26b4707f937c6f" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="translated">Эта функция устарела за счет выдачи предупреждений при использовании. Это также известно как отказ от поддержки. Чтобы объявить функцию устаревшей, предлагаемая альтернатива ДОЛЖНА существовать как минимум для ТРЕХ второстепенных версий. Например, &lt;code&gt;Enum.uniq/2&lt;/code&gt; был мягко объявлен устаревшим в пользу &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#uniq_by/2&quot;&gt; &lt;code&gt;Enum.uniq_by/2&lt;/code&gt; &lt;/a&gt; в Elixir v1.1. Это означает, что предупреждение об устаревании может выдаваться только Elixir v1.4 или новее.</target>
        </trans-unit>
        <trans-unit id="77826c76ea0072ad69d2f391c353d094902019fd" translate="yes" xml:space="preserve">
          <source>The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x.</source>
          <target state="translated">Функция удалена.Это может произойти только на мажорных релизах.Это означает,что устаревшие функции в версии Elixir v1.x должны быть удалены только в версии Elixir v2.x.</target>
        </trans-unit>
        <trans-unit id="64f27bcc28943bbd06806f078df1fb5cd0c4fa41" translate="yes" xml:space="preserve">
          <source>The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature.</source>
          <target state="translated">Функция имеет мягкую структуру.Это означает,что как ИЗМЕНЕНИЕ,так и документация должны указывать характеристику как устаревшую,но при выполнении кода не выдаётся никаких предупреждений.Нет необходимости в программно-депрессивном обновлении функции.</target>
        </trans-unit>
        <trans-unit id="aaf695dceb54489cced53f84555aabadc2f0e697" translate="yes" xml:space="preserve">
          <source>The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">Если файл не существует, он создается. Если он существует, предыдущее содержимое перезаписывается. Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха или &lt;code&gt;{:error, reason}&lt;/code&gt; случае ошибки.</target>
        </trans-unit>
        <trans-unit id="d594748254e0bf9d6de08774efbf46885ccdc846" translate="yes" xml:space="preserve">
          <source>The file is created if it doesn't exist. Requires datetime in UTC (as returned by &lt;code&gt;:erlang.universaltime()&lt;/code&gt;) or an integer representing the POSIX timestamp (as returned by &lt;code&gt;System.os_time(:second)&lt;/code&gt;).</source>
          <target state="translated">Если файл не существует, он создается. Требуется дата и время в формате UTC (возвращаемое &lt;code&gt;:erlang.universaltime()&lt;/code&gt; ) или целое число, представляющее отметку времени POSIX (возвращаемую &lt;code&gt;System.os_time(:second)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="16e6a8d0dd5fc8fad11975b4cd8380cee1d272d3" translate="yes" xml:space="preserve">
          <source>The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function.</source>
          <target state="translated">Файл открывается,передается функции в качестве аргумента и автоматически закрывается после возврата функции,независимо от того,была ли ошибка при выполнении функции.</target>
        </trans-unit>
        <trans-unit id="7da78c24b03af92a331655b22affad9970828441" translate="yes" xml:space="preserve">
          <source>The file will be compiled in memory and executed, printing &amp;ldquo;3&amp;rdquo; as the result. No bytecode file will be created. In the following examples, we recommend you write your code into script files and execute them as shown above.</source>
          <target state="translated">Файл будет скомпилирован в памяти и выполнен с выводом &amp;laquo;3&amp;raquo; в качестве результата. Файл с байт-кодом не будет создан. В следующих примерах мы рекомендуем вам записать свой код в файлы сценариев и выполнить их, как показано выше.</target>
        </trans-unit>
        <trans-unit id="163b392b3771b3d68e4cabd76e12f649d752ed1d" translate="yes" xml:space="preserve">
          <source>The final code for the application built in this guide is in &lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;this repository&lt;/a&gt; and can be used as a reference.</source>
          <target state="translated">Последний код для приложения, созданного в этом руководстве, находится в &lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;этом репозитории&lt;/a&gt; и может использоваться в качестве справочного материала.</target>
        </trans-unit>
        <trans-unit id="849e4d016851d364ddd912997469160b512c2434" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="translated">Окончательное имя модуля будет &lt;code&gt;MyHelpers.Module&lt;/code&gt; , а не &lt;code&gt;My.Module&lt;/code&gt; . В &lt;a href=&quot;#expand/2&quot;&gt; &lt;code&gt;Macro.expand/2&lt;/code&gt; &lt;/a&gt; такие псевдонимы учитываются. Также расширены локальные и удаленные макросы. Мы могли бы переписать наш макрос выше, чтобы использовать эту функцию как:</target>
        </trans-unit>
        <trans-unit id="eeed0a9446d454784748ae3c92f5f970ae5e8749" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;macro#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="translated">Окончательное имя модуля будет &lt;code&gt;MyHelpers.Module&lt;/code&gt; , а не &lt;code&gt;My.Module&lt;/code&gt; . В &lt;a href=&quot;macro#expand/2&quot;&gt; &lt;code&gt;Macro.expand/2&lt;/code&gt; &lt;/a&gt; такие псевдонимы учитываются. Также расширены локальные и удаленные макросы. Мы могли бы переписать наш макрос выше, чтобы использовать эту функцию как:</target>
        </trans-unit>
        <trans-unit id="c94b7aa6c8d6098097b882564487315e75f42062" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; is a list of child specifications as defined in the &quot;child_spec/1&quot; section above.</source>
          <target state="translated">Первый аргумент, передаваемый &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; ,&lt;/a&gt; представляет собой список дочерних спецификаций, как определено в разделе &amp;laquo;child_spec / 1&amp;raquo; выше.</target>
        </trans-unit>
        <trans-unit id="13a0df9187b50523011cbb4505688a72e2b67377" translate="yes" xml:space="preserve">
          <source>The first argument is the application name. The second argument &lt;code&gt;key_or_path&lt;/code&gt; is either an atom key or a path to traverse in search of the configuration, starting with an atom key.</source>
          <target state="translated">Первый аргумент - это название приложения. Второй аргумент &lt;code&gt;key_or_path&lt;/code&gt; - это либо ключ атома, либо путь, по которому нужно пройти в поисках конфигурации, начиная с ключа атома.</target>
        </trans-unit>
        <trans-unit id="3bd0d4cfc55b69d9253066edc78349e5a5f0a43e" translate="yes" xml:space="preserve">
          <source>The first clause above will only match when &lt;code&gt;x&lt;/code&gt; is positive.</source>
          <target state="translated">Первое предложение выше будет соответствовать только тогда, когда &lt;code&gt;x&lt;/code&gt; положительно.</target>
        </trans-unit>
        <trans-unit id="eb035f0f30f88032dbb2e6101c25284087903853" translate="yes" xml:space="preserve">
          <source>The first clause has a guard which says &amp;ldquo;use this definition if and only if &lt;code&gt;n&lt;/code&gt; is less than or equal to &lt;code&gt;1&lt;/code&gt;&amp;rdquo;. Since this is not the case, Elixir proceeds to the next clause&amp;rsquo;s definition.</source>
          <target state="translated">В первом предложении есть предохранитель, который говорит: &amp;laquo;Используйте это определение тогда и только тогда, когда &lt;code&gt;n&lt;/code&gt; меньше или равно &lt;code&gt;1&lt;/code&gt; &amp;raquo;. Поскольку это не так, Elixir переходит к определению следующего пункта.</target>
        </trans-unit>
        <trans-unit id="89e50c2ad64d1cb084a88caace5a204ed21c004f" translate="yes" xml:space="preserve">
          <source>The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from.</source>
          <target state="translated">Первая колонка-это версия,которая была сильно устарела.Во второй колонке вкратце описывается устаревшая функция,а в третьей колонке объясняется замена и из какой версии она доступна.</target>
        </trans-unit>
        <trans-unit id="090b48aa7b27ba7aabd1d7a17461511059a79e62" translate="yes" xml:space="preserve">
          <source>The first element is always dropped, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">Первый элемент всегда удаляется, если &lt;code&gt;nth&lt;/code&gt; не равно 0.</target>
        </trans-unit>
        <trans-unit id="f10968f84672fced5f1e4ec8ec8d8d3398ac17ef" translate="yes" xml:space="preserve">
          <source>The first element is always included, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">Всегда включается первый элемент, если &lt;code&gt;nth&lt;/code&gt; не равно 0.</target>
        </trans-unit>
        <trans-unit id="d62944a019ad040d05e692b397bd4389633cb416" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function, unless &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">В данную функцию всегда передается первый элемент, если &lt;code&gt;nth&lt;/code&gt; не равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d3d07fd30dfdee5089f7add816955448e8a7e62" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function.</source>
          <target state="translated">Первый элемент всегда передается в данную функцию.</target>
        </trans-unit>
        <trans-unit id="a20362c2ee76acf3525cfe072360096fe727a0f9" translate="yes" xml:space="preserve">
          <source>The first element is an atom or another tuple in the same representation;</source>
          <target state="translated">Первый элемент-это атом или другой кортеж в том же самом представлении;</target>
        </trans-unit>
        <trans-unit id="de5cd0ed2836b580d20a53b60b89fdbc3744b2af" translate="yes" xml:space="preserve">
          <source>The first element is the function name, the second is a keyword list containing metadata and the third is the arguments list.</source>
          <target state="translated">Первый элемент-это имя функции,второй-это список ключевых слов,содержащий метаданные,а третий-список аргументов.</target>
        </trans-unit>
        <trans-unit id="8b93358d99cbfe2c9b65df07674bef6d363d42e0" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;enumerable&lt;/code&gt; is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the &lt;code&gt;enumerable&lt;/code&gt; is done, the last accumulator is returned.</source>
          <target state="translated">Первый элемент &lt;code&gt;enumerable&lt;/code&gt; используется как начальное значение аккумулятора. Затем функция вызывается со следующим элементом и аккумулятором. Результат, возвращаемый функцией, рекурсивно используется в качестве аккумулятора для следующей итерации. Когда &lt;code&gt;enumerable&lt;/code&gt; выполнено, возвращается последний аккумулятор.</target>
        </trans-unit>
        <trans-unit id="ff5ed72f8d68d33e831fb03d181cb08f9312e39a" translate="yes" xml:space="preserve">
          <source>The first element of the tuple is always an atom or another tuple in the same representation.</source>
          <target state="translated">Первый элемент кортежа всегда является атомом или другим кортежом в одном и том же представлении.</target>
        </trans-unit>
        <trans-unit id="3622c3705870af3b02b55f90fe91c49c65360502" translate="yes" xml:space="preserve">
          <source>The first element of these tuples is known as the &lt;em&gt;key&lt;/em&gt;, and it must be an atom. The second element, known as the &lt;em&gt;value&lt;/em&gt;, can be any term.</source>
          <target state="translated">Первый элемент этих кортежей известен как &lt;em&gt;ключ&lt;/em&gt; и должен быть атомом. Второй элемент, известный как &lt;em&gt;значение&lt;/em&gt; , может быть любым термином.</target>
        </trans-unit>
        <trans-unit id="753965fc9c8c958c1adc18030905ea9a9fce1c71" translate="yes" xml:space="preserve">
          <source>The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling &lt;code&gt;do_something_expensive(state)&lt;/code&gt; outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values.</source>
          <target state="translated">Первая функция блокирует агента. Вторая функция копирует все состояние клиенту, а затем выполняет операцию на клиенте. Один аспект, который следует учитывать, заключается в том, достаточно ли велики данные, чтобы потребовать обработки на сервере, по крайней мере, на начальном этапе, или достаточно ли малы, чтобы их можно было дешево отправить клиенту. Другой фактор заключается в том, нужно ли обрабатывать данные атомарно: получение состояния и вызов &lt;code&gt;do_something_expensive(state)&lt;/code&gt; вне агента означает, что состояние агента в это время может быть обновлено. Это особенно важно в случае обновлений, поскольку вычисление нового состояния на клиенте, а не на сервере, может привести к условиям гонки, если несколько клиентов пытаются обновить одно и то же состояние до разных значений.</target>
        </trans-unit>
        <trans-unit id="3a8bdc0ad5ea0cf6a739758090fdb5a2d0573fc4" translate="yes" xml:space="preserve">
          <source>The first function is &lt;code&gt;start_link/1&lt;/code&gt;, which starts a new GenServer passing a list of options. &lt;code&gt;start_link/1&lt;/code&gt; calls out to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;, which takes three arguments:</source>
          <target state="translated">Первая функция - &lt;code&gt;start_link/1&lt;/code&gt; , которая запускает новый GenServer, передавая список параметров. &lt;code&gt;start_link/1&lt;/code&gt; вызывает &lt;code&gt;GenServer.start_link/3&lt;/code&gt; , который принимает три аргумента:</target>
        </trans-unit>
        <trans-unit id="6da90265feaa08cdbd5c291c792941296efaf6fb" translate="yes" xml:space="preserve">
          <source>The first is the &lt;code&gt;init/1&lt;/code&gt; callback, that receives the second argument given to &lt;code&gt;GenServer.start_link/3&lt;/code&gt; and returns &lt;code&gt;{:ok, state}&lt;/code&gt;, where state is a new map. We can already notice how the &lt;code&gt;GenServer&lt;/code&gt; API makes the client/server segregation more apparent. &lt;code&gt;start_link/3&lt;/code&gt; happens in the client, while &lt;code&gt;init/1&lt;/code&gt; is the respective callback that runs on the server.</source>
          <target state="translated">Первый - это обратный вызов &lt;code&gt;init/1&lt;/code&gt; , который получает второй аргумент, переданный &lt;code&gt;GenServer.start_link/3&lt;/code&gt; , и возвращает &lt;code&gt;{:ok, state}&lt;/code&gt; , где state - это новая карта. Мы уже можем заметить, как &lt;code&gt;GenServer&lt;/code&gt; API делает разделение клиент / сервер более очевидным. &lt;code&gt;start_link/3&lt;/code&gt; происходит на клиенте, а &lt;code&gt;init/1&lt;/code&gt; - это соответствующий обратный вызов, который выполняется на сервере.</target>
        </trans-unit>
        <trans-unit id="6abd6bfc1ce31ae2f7f3cf73ef51afa902c3df53" translate="yes" xml:space="preserve">
          <source>The first is to rely on the fact that doctest can compare internal structures as long as they are at the root. So one could write:</source>
          <target state="translated">Первое-полагаться на то,что doctest может сравнивать внутренние структуры,пока они находятся в корне.Так что можно писать:</target>
        </trans-unit>
        <trans-unit id="56525212a2d836e7b2e6c9fc3d438debd74b1ce4" translate="yes" xml:space="preserve">
          <source>The first occurrence of each element is kept.</source>
          <target state="translated">Сохраняется первое появление каждого элемента.</target>
        </trans-unit>
        <trans-unit id="6fdbbd4ad4f56c5f2d4b83c9b51836d3c3baff1c" translate="yes" xml:space="preserve">
          <source>The first one is related to operator precedence. For example, the following expression:</source>
          <target state="translated">Первая связана с приоритетом оператора.Например,следующее выражение:</target>
        </trans-unit>
        <trans-unit id="eb6432ba2d593bb02b187beac0081aecf4153a10" translate="yes" xml:space="preserve">
          <source>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</source>
          <target state="translated">Первое,что код действительно вычисляется и не компилируется.Это означает,что любое бенчмаркинговое тестирование,выполненное в оболочке,будет иметь искаженные результаты.Поэтому никогда не выполняйте ни профилирование,ни бенчмаркинг в оболочке.</target>
        </trans-unit>
        <trans-unit id="9aa7af0b736df8170b447c11a0b1486409c8447e" translate="yes" xml:space="preserve">
          <source>The first one is with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; which we can use instead of &lt;code&gt;IO.inspect binding()&lt;/code&gt;:</source>
          <target state="translated">Первый - с &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; ,&lt;/a&gt; который мы можем использовать вместо &lt;code&gt;IO.inspect binding()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cece2699937857700a6e57ae7a8e2fdab1620e09" translate="yes" xml:space="preserve">
          <source>The first part, the match pattern, must be a tuple that will match the structure of the the data stored in the registry, which is &lt;code&gt;{key, pid, value}&lt;/code&gt;. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. This can be combined like &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt;.</source>
          <target state="translated">Первая часть, шаблон соответствия, должен быть кортежем, который будет соответствовать структуре данных, хранящихся в реестре, то есть &lt;code&gt;{key, pid, value}&lt;/code&gt; . Атом &lt;code&gt;:_&lt;/code&gt; можно использовать для игнорирования данного значения или элемента кортежа, а атом &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; можно использовать для временного присвоения части шаблона переменной для последующего сравнения. Это можно комбинировать как &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33bf9cc2d09af8093ef73164f4425101ddcff356" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all function calls. In the last row the number of matching functions that were considered for profiling is presented.</source>
          <target state="translated">Первая строка (Всего)-это сумма всех вызовов функции.В последней строке представлено количество соответствующих функций,которые рассматривались для профилирования.</target>
        </trans-unit>
        <trans-unit id="c85192b0b88529b2ffa5c7dc5ed794fb80bfa927" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all functions executed in all profiled processes. For the given output, we had a total of 200279 function calls and spent about 2 seconds running the code.</source>
          <target state="translated">Первая строка (Итог)-это сумма всех функций,выполняемых во всех профилированных процессах.Для данного вывода мы имели суммарное количество вызовов функций 200279 и потратили около 2 секунд на выполнение кода.</target>
        </trans-unit>
        <trans-unit id="7cd60f6007c291382d0b163734079218de4d7d65" translate="yes" xml:space="preserve">
          <source>The first step in our implementation is to call &lt;code&gt;use Agent&lt;/code&gt;.</source>
          <target state="translated">Первым шагом в нашей реализации является вызов &lt;code&gt;use Agent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="868cc4dcae35b14912938b182f9884b2f9e36c22" translate="yes" xml:space="preserve">
          <source>The first step is to tell our application definition (i.e. our &lt;code&gt;.app&lt;/code&gt; file) which module is going to implement the application callback. Let&amp;rsquo;s do so by opening &lt;code&gt;mix.exs&lt;/code&gt; and changing &lt;code&gt;def application&lt;/code&gt; to the following:</source>
          <target state="translated">Первый шаг - сообщить нашему определению приложения (т.е. нашему файлу &lt;code&gt;.app&lt;/code&gt; ), какой модуль будет реализовывать обратный вызов приложения. Давайте сделаем это, открыв &lt;code&gt;mix.exs&lt;/code&gt; и изменив &lt;code&gt;def application&lt;/code&gt; на следующее:</target>
        </trans-unit>
        <trans-unit id="b1db7f18a01e941b219c679437813ff0c63b86ff" translate="yes" xml:space="preserve">
          <source>The first step to do so is to add a &lt;code&gt;:mod&lt;/code&gt; key to the &lt;code&gt;application/0&lt;/code&gt; definition in your &lt;code&gt;mix.exs&lt;/code&gt; file. It expects a tuple, with the application callback module and start argument (commonly an empty list):</source>
          <target state="translated">Первый шаг для этого - добавить ключ &lt;code&gt;:mod&lt;/code&gt; в определение &lt;code&gt;application/0&lt;/code&gt; в вашем файле &lt;code&gt;mix.exs&lt;/code&gt; . Он ожидает кортеж с модулем обратного вызова приложения и аргументом запуска (обычно пустой список):</target>
        </trans-unit>
        <trans-unit id="08b35c8002543aef4eef62b9715905dd1c3e096e" translate="yes" xml:space="preserve">
          <source>The first test invokes &lt;code&gt;Kernel.node/0&lt;/code&gt;, which returns the name of the current node, based on the bucket names &amp;ldquo;hello&amp;rdquo; and &amp;ldquo;world&amp;rdquo;. According to our routing table so far, we should get &lt;code&gt;foo@computer-name&lt;/code&gt; and &lt;code&gt;bar@computer-name&lt;/code&gt; as responses, respectively.</source>
          <target state="translated">Первый тест вызывает &lt;code&gt;Kernel.node/0&lt;/code&gt; , который возвращает имя текущего узла на основе имен сегментов &amp;laquo;hello&amp;raquo; и &amp;laquo;world&amp;raquo;. Согласно нашей таблице маршрутизации, мы должны получить ответы &lt;code&gt;foo@computer-name&lt;/code&gt; и &lt;code&gt;bar@computer-name&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="aac5f450f7a22287bfbd1ca580bfb413b84283d5" translate="yes" xml:space="preserve">
          <source>The first time this task is run with &lt;code&gt;--stale&lt;/code&gt;, all tests are run and a manifest is generated. On subsequent runs, a test file is marked &quot;stale&quot; if any modules it references (and any modules those modules reference, recursively) were modified since the last run with &lt;code&gt;--stale&lt;/code&gt;. A test file is also marked &quot;stale&quot; if it has been changed since the last run with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">При первом запуске этой задачи с &lt;code&gt;--stale&lt;/code&gt; выполняются все тесты и создается манифест. При последующих запусках тестовый файл помечается как &amp;laquo;устаревший&amp;raquo;, если какие-либо модули, на которые он ссылается (и любые модули, на которые эти модули ссылаются рекурсивно), были изменены с момента последнего запуска с &lt;code&gt;--stale&lt;/code&gt; . Тестовый файл также помечается как &amp;laquo;устаревший&amp;raquo;, если он был изменен с момента последнего запуска с &lt;code&gt;--stale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="295fb12141f4c89eb596a5dac17f4949547acbec" translate="yes" xml:space="preserve">
          <source>The following attributes are part of typespecs and are also built-in in Elixir:</source>
          <target state="translated">Следующие атрибуты являются частью Typepecs и также встроены в Elixir:</target>
        </trans-unit>
        <trans-unit id="7ddb17433dfdb141914290560e8f56274113cff7" translate="yes" xml:space="preserve">
          <source>The following behaviour applies if &lt;code&gt;reason&lt;/code&gt; is any term except &lt;code&gt;:normal&lt;/code&gt; or &lt;code&gt;:kill&lt;/code&gt;:</source>
          <target state="translated">Следующее поведение применяется, если &lt;code&gt;reason&lt;/code&gt; - это любой термин, кроме &lt;code&gt;:normal&lt;/code&gt; или &lt;code&gt;:kill&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7cc6a385de289ddbe867800f5a4d45eaf506d87a" translate="yes" xml:space="preserve">
          <source>The following code is clearer:</source>
          <target state="translated">Следующий код понятнее:</target>
        </trans-unit>
        <trans-unit id="bd520f433c3d9627651ec8f3c46e49f2f0b40321" translate="yes" xml:space="preserve">
          <source>The following commands are supported by &lt;code&gt;bin/RELEASE_NAME&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; поддерживает следующие команды :</target>
        </trans-unit>
        <trans-unit id="ab6fa07c7c4a4b08ed5ab5840982521232d9dc60" translate="yes" xml:space="preserve">
          <source>The following configuration applies to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;'s wrapper around Erlang's logging functionalities. All the configurations below must be set before the &lt;code&gt;:logger&lt;/code&gt; application starts.</source>
          <target state="translated">Следующая конфигурация применяется к &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; для функций ведения журналов Erlang. Все приведенные ниже конфигурации должны быть установлены до запуска приложения &lt;code&gt;:logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b59ddac9c85343e9c0315f555148e29de15b834" translate="yes" xml:space="preserve">
          <source>The following configuration must be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">Следующая конфигурация должна быть установлена ​​через файлы конфигурации (такие как &lt;code&gt;config/config.exs&lt;/code&gt; ) до запуска приложения &lt;code&gt;:logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7468ef5075d9f1bb00ad4478b84201c0051a39d2" translate="yes" xml:space="preserve">
          <source>The following configurations apply only for Erlang/OTP 20 and earlier:</source>
          <target state="translated">Следующие конфигурации применимы только для Erlang/OTP 20 и более ранних версий:</target>
        </trans-unit>
        <trans-unit id="5bee2fb68242ae2a980fb37c51c72ff07363e60a" translate="yes" xml:space="preserve">
          <source>The following contents are expanded:</source>
          <target state="translated">Следующее содержание расширено:</target>
        </trans-unit>
        <trans-unit id="184db633c0e9a1d1d50d51efc796a68bbb36b312" translate="yes" xml:space="preserve">
          <source>The following document has 10 bytes and therefore it does not format to width 9 without breaks:</source>
          <target state="translated">Следующий документ имеет 10 байт и поэтому не форматируется до ширины 9 без разрывов:</target>
        </trans-unit>
        <trans-unit id="de1fd9b941b49b602c0ebc3107ff23bc87d50045" translate="yes" xml:space="preserve">
          <source>The following escape codes can be used in strings and char lists:</source>
          <target state="translated">Следующие экранирующие коды могут быть использованы в строках и чар-листах:</target>
        </trans-unit>
        <trans-unit id="7c26c5de3e4e7cd245868d8c611a09003ff421aa" translate="yes" xml:space="preserve">
          <source>The following events are possible:</source>
          <target state="translated">Возможны следующие события:</target>
        </trans-unit>
        <trans-unit id="d46d9ba3da9322ecdf037e20b892895d0db04656" translate="yes" xml:space="preserve">
          <source>The following fields are available:</source>
          <target state="translated">Доступны следующие поля:</target>
        </trans-unit>
        <trans-unit id="7293829d505cc3a0054aa1a59ac73bad4f509dae" translate="yes" xml:space="preserve">
          <source>The following fields are deprecated and must not be accessed or relied on:</source>
          <target state="translated">Следующие поля являются устаревшими и не должны быть доступны или на них нельзя полагаться:</target>
        </trans-unit>
        <trans-unit id="8e9526796f05e114fb24325e062cf85e1db31da0" translate="yes" xml:space="preserve">
          <source>The following fields are private to Elixir's macro expansion mechanism and must not be accessed directly:</source>
          <target state="translated">Следующие поля являются закрытыми для механизма макрорасширения Elixir и не должны быть доступны напрямую:</target>
        </trans-unit>
        <trans-unit id="30c2e9695ce3105ad651330d3b52e46b3a324658" translate="yes" xml:space="preserve">
          <source>The following fields are public:</source>
          <target state="translated">Следующие поля являются общедоступными:</target>
        </trans-unit>
        <trans-unit id="4144d492a1a8552ba49119bd2fcd0fd26179f7b6" translate="yes" xml:space="preserve">
          <source>The following fields may be modified as long as they keep their defined types:</source>
          <target state="translated">Следующие поля могут быть изменены,если они сохраняют свои определенные типы:</target>
        </trans-unit>
        <trans-unit id="ecaaab8e8eae9b4df4d22551bafa8feaa1ec9420" translate="yes" xml:space="preserve">
          <source>The following fields pertain to variable handling and must not be accessed or relied on. To get a list of all variables, see &lt;a href=&quot;#vars/1&quot;&gt;&lt;code&gt;vars/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Следующие поля относятся к обработке переменных, к ним нельзя обращаться или полагаться на них. Чтобы получить список всех переменных, см. &lt;a href=&quot;#vars/1&quot;&gt; &lt;code&gt;vars/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e8fcb5815c5a0952c38de454edd61e7d1f142d6d" translate="yes" xml:space="preserve">
          <source>The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:</source>
          <target state="translated">Ниже приведен список всех операторов,которые Elixir способен разбивать,упорядочивая их по порядку от более высокого к более низкому приоритету,наряду с их ассоциативностью:</target>
        </trans-unit>
        <trans-unit id="9104e819567333a6da0e8ce2dab5b947458c30fd" translate="yes" xml:space="preserve">
          <source>The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:</source>
          <target state="translated">Ниже приведена таблица всех операторов,которые Elixir способен анализировать,но которые не используются по умолчанию:</target>
        </trans-unit>
        <trans-unit id="0ba751c3adfd8a7fc2856a1dbf3e62fbc4ec76f2" translate="yes" xml:space="preserve">
          <source>The following keys are optional:</source>
          <target state="translated">Следующие клавиши являются необязательными:</target>
        </trans-unit>
        <trans-unit id="7b884b576e7fc0feccc202abb8a4a3d2fbce2d97" translate="yes" xml:space="preserve">
          <source>The following keys are returned:</source>
          <target state="translated">Возвращаются следующие ключи:</target>
        </trans-unit>
        <trans-unit id="bf2cdc4ebfa3f4a0590ef2625ba82e196ae8c2a8" translate="yes" xml:space="preserve">
          <source>The following literals are also supported in typespecs:</source>
          <target state="translated">Следующие буквы также поддерживаются в типепепе:</target>
        </trans-unit>
        <trans-unit id="b914b4fb7bd70067053e9e95983328f16ab1fd00" translate="yes" xml:space="preserve">
          <source>The following macros are generated:</source>
          <target state="translated">Генерируются следующие макросы:</target>
        </trans-unit>
        <trans-unit id="8b11c8558e4b5ede506774a8ccaf530f1714eee7" translate="yes" xml:space="preserve">
          <source>The following metadata keys are enabled by &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#string_to_quoted/2&quot;&gt;&lt;code&gt;Code.string_to_quoted/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#string_to_quoted/2&quot;&gt; &lt;code&gt;Code.string_to_quoted/2&lt;/code&gt; &lt;/a&gt; включает следующие ключи метаданных :</target>
        </trans-unit>
        <trans-unit id="73eaa1cbb3b18d9fd1ab6f109e8770b921b255f4" translate="yes" xml:space="preserve">
          <source>The following metadata keys are private:</source>
          <target state="translated">Следующие ключи метаданных являются личными:</target>
        </trans-unit>
        <trans-unit id="a19a723fcc38df91c7efce744ef29817327ec398" translate="yes" xml:space="preserve">
          <source>The following metadata keys are public:</source>
          <target state="translated">Следующие ключи метаданных являются общедоступными:</target>
        </trans-unit>
        <trans-unit id="d3a2d7253e70d0b7ab68844ea930f5d415637299" translate="yes" xml:space="preserve">
          <source>The following modules build on top of processes to provide concurrency, fault-tolerance, and more.</source>
          <target state="translated">Следующие модули построены на основе процессов,обеспечивающих параллельность,отказоустойчивость и многое другое.</target>
        </trans-unit>
        <trans-unit id="b4f887b33e0c44ae6b51e81b5ab7bc56ab3d3fc4" translate="yes" xml:space="preserve">
          <source>The following modules handle Elixir built-in data types:</source>
          <target state="translated">Следующие модули обрабатывают встроенные типы данных Elixir:</target>
        </trans-unit>
        <trans-unit id="16b7215fb9d992fc605683d883c23ca3932275a5" translate="yes" xml:space="preserve">
          <source>The following names are reserved and cannot be assigned to processes nor ports:</source>
          <target state="translated">Следующие имена зарезервированы и не могут быть назначены ни процессам,ни портам:</target>
        </trans-unit>
        <trans-unit id="5b3878c8ab3dccd7e89f167b65de39bd2f92844f" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Следующие операторы используются модулем &lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; при импорте: &lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt; &lt;code&gt;^^^&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt; &lt;code&gt;|||&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;bitwise#~~~/1&quot;&gt; &lt;code&gt;~~~&lt;/code&gt; &lt;/a&gt; . Дополнительную информацию см. В документации по &lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="178f615607801ccb48b704fc1947669dd0349eaf" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%5E%5E%5E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3C%3C%3C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3E%3E%3E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%7C%7C%7C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Следующие операторы используются модулем &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; при импорте: &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%5E%5E%5E/2&quot;&gt; &lt;code&gt;^^^&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3C%3C%3C/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3E%3E%3E/2&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%7C%7C%7C/2&quot;&gt; &lt;code&gt;|||&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#~~~/1&quot;&gt; &lt;code&gt;~~~&lt;/code&gt; &lt;/a&gt; . См. Документацию по &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="77f3895c41618839ee5e26a20028be3be4ec2b1d" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="translated">Следующая опция должна быть указана в вашем &lt;code&gt;mix.exs&lt;/code&gt; в разделе &lt;code&gt;:escript&lt;/code&gt; key:</target>
        </trans-unit>
        <trans-unit id="cf3f75fb4a0fa1361326143ff900caf814328a06" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under the &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="translated">Следующая опция должна быть указана в вашем &lt;code&gt;mix.exs&lt;/code&gt; под ключом: &lt;code&gt;:escript&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e4d77afab2cb5c0e79177397fed4c21c74e5e9f3" translate="yes" xml:space="preserve">
          <source>The following options are accepted:</source>
          <target state="translated">Принимаются следующие варианты:</target>
        </trans-unit>
        <trans-unit id="3ab6a9f1a0bbaef19cacfbc5c31136467bf2e22d" translate="yes" xml:space="preserve">
          <source>The following options are supported:</source>
          <target state="translated">Поддерживаются следующие опции:</target>
        </trans-unit>
        <trans-unit id="5d2ba16817e078ffdf67dfcad431c49900869b20" translate="yes" xml:space="preserve">
          <source>The following options can be set inside your &lt;code&gt;mix.exs&lt;/code&gt; on each release definition:</source>
          <target state="translated">Следующие параметры могут быть установлены внутри вашего &lt;code&gt;mix.exs&lt;/code&gt; для каждого определения выпуска:</target>
        </trans-unit>
        <trans-unit id="3e0b1eaa4142d08cf206798562baf46888ee1a50" translate="yes" xml:space="preserve">
          <source>The following options can be set inside your releases key in your &lt;code&gt;mix.exs&lt;/code&gt; to control how config providers work:</source>
          <target state="translated">Следующие параметры могут быть установлены внутри ключа релизов в &lt;code&gt;mix.exs&lt;/code&gt; для управления работой поставщиков конфигурации:</target>
        </trans-unit>
        <trans-unit id="a63388a7d9c69cb081c0bd25c0b348227ea8b98e" translate="yes" xml:space="preserve">
          <source>The following restart values are supported in the &lt;code&gt;:restart&lt;/code&gt; option:</source>
          <target state="translated">В опции: restart поддерживаются следующие значения &lt;code&gt;:restart&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e3bfac8b769dcde18c31230db7c8155e1610b73f" translate="yes" xml:space="preserve">
          <source>The following sets up a breakpoint on &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Следующее устанавливает &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; &lt;/a&gt; останова на URI.decode_query / 2 :</target>
        </trans-unit>
        <trans-unit id="af7f88d381759e98fbd8a59a2974fdc1427bfa5a" translate="yes" xml:space="preserve">
          <source>The following shutdown values are supported in the &lt;code&gt;:shutdown&lt;/code&gt; option:</source>
          <target state="translated">В параметре &lt;code&gt;:shutdown&lt;/code&gt; поддерживаются следующие значения выключения :</target>
        </trans-unit>
        <trans-unit id="62c95490240e6721731c2a4166fbf474d701eaa5" translate="yes" xml:space="preserve">
          <source>The following switches take one argument:</source>
          <target state="translated">Следующие переключатели принимают один аргумент:</target>
        </trans-unit>
        <trans-unit id="09182b59468032ac91eb3e19cfac73cd63919777" translate="yes" xml:space="preserve">
          <source>The following switches types take no arguments:</source>
          <target state="translated">Следующие типы переключателей не принимают аргументов:</target>
        </trans-unit>
        <trans-unit id="656560aa5a4b69ea097162499366d646d82b57a2" translate="yes" xml:space="preserve">
          <source>The following tags are set automatically by ExUnit and are therefore reserved:</source>
          <target state="translated">Следующие теги автоматически устанавливаются ExUnit и поэтому резервируются:</target>
        </trans-unit>
        <trans-unit id="5fc9716a622a264a8eff71eefa013048286d3378" translate="yes" xml:space="preserve">
          <source>The following tags customize how tests behave:</source>
          <target state="translated">Следующие теги настраивают поведение тестов:</target>
        </trans-unit>
        <trans-unit id="f3f1a1a3a62e3160fd586f6ee95d4fab3af95423" translate="yes" xml:space="preserve">
          <source>The following tasks are automatically reenabled: &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.do&quot;&gt;&lt;code&gt;mix do&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.loadconfig&quot;&gt;&lt;code&gt;mix loadconfig&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt;&lt;code&gt;mix profile.cprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt;&lt;code&gt;mix profile.eprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt;&lt;code&gt;mix profile.fprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Следующие задачи &lt;a href=&quot;mix.tasks.loadconfig&quot;&gt; &lt;code&gt;mix loadconfig&lt;/code&gt; &lt;/a&gt; автоматически: &lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.do&quot;&gt; &lt;code&gt;mix do&lt;/code&gt; &lt;/a&gt; , mix loadconfig , &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt; &lt;code&gt;mix profile.cprof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt; &lt;code&gt;mix profile.eprof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt; &lt;code&gt;mix profile.fprof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94b02fa4807601cf95b13d7bfacf63de52daec08" translate="yes" xml:space="preserve">
          <source>The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above.</source>
          <target state="translated">Следующие типы также предоставляются Elixir'ом в виде ярлыков поверх основных и буквальных типов,описанных выше.</target>
        </trans-unit>
        <trans-unit id="23128f3afb79fe9776e7ccf884ae9b5f280de2c5" translate="yes" xml:space="preserve">
          <source>The following values in the prompt string will be replaced appropriately:</source>
          <target state="translated">Следующие значения в строке запроса будут соответствующим образом заменены:</target>
        </trans-unit>
        <trans-unit id="55cd405f97f23c4fe92ae34e5fe7acfcdc9373f0" translate="yes" xml:space="preserve">
          <source>The following variables can be set before you invoke the release or inside &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt;:</source>
          <target state="translated">Следующие переменные могут быть установлены перед &lt;code&gt;env.sh&lt;/code&gt; выпуска или внутри env.sh и &lt;code&gt;env.bat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bd9e27e386ddec7a2956d45d1104ee9dcf8cf427" translate="yes" xml:space="preserve">
          <source>The following will answer with &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; to the prompt &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt;:</source>
          <target state="translated">Следующий ответ будет &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; на запрос &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d10907c83024affa6f13fdf8900f10947fef49e4" translate="yes" xml:space="preserve">
          <source>The format, metadata and colors can be configured with &lt;code&gt;:format&lt;/code&gt;, &lt;code&gt;:metadata&lt;/code&gt; and &lt;code&gt;:colors&lt;/code&gt; respectively. These three options defaults to the &lt;code&gt;:console&lt;/code&gt; backend configuration parameters.</source>
          <target state="translated">Формат, метаданные и цвет могут быть настроены с &lt;code&gt;:format&lt;/code&gt; , &lt;code&gt;:metadata&lt;/code&gt; и &lt;code&gt;:colors&lt;/code&gt; соответственно. По умолчанию для этих трех параметров используются параметры конфигурации серверной части &lt;code&gt;:console&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc2e84198cf648d67efe0dc56f0a0d3f7a6c41f5" translate="yes" xml:space="preserve">
          <source>The formatter also extracts all trailing comments to their previous line. For example, the code below</source>
          <target state="translated">Форматер также извлекает все комментарии к предыдущей строке.Например,код ниже</target>
        </trans-unit>
        <trans-unit id="f2dbb773aae103d1ac648bef9a245406adea93a6" translate="yes" xml:space="preserve">
          <source>The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character.</source>
          <target state="translated">Форматер также обрабатывает комментарии к коду таким образом,чтобы гарантировать,что между началом комментария (#)и следующим символом всегда добавляется пробел.</target>
        </trans-unit>
        <trans-unit id="174a1bba642104242141e782016509d0a3307dd9" translate="yes" xml:space="preserve">
          <source>The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot.</source>
          <target state="translated">Форматтер пытается поместить максимально возможное количество элементов на одной линии и вводит разрывы строк везде,где это возможно,когда это невозможно.</target>
        </trans-unit>
        <trans-unit id="db2d1c69ac2af0675a9fbaa3dbf3bb62be0f48e5" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, etc. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="translated">Форматер не жестко кодирует имена. Средство форматирования не будет вести себя особым образом, потому что функция называется &lt;code&gt;defmodule&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; и т. Д. Этот принцип отражает цель Elixir - быть расширяемым языком, где разработчики могут расширять язык с помощью новых конструкций, как если бы они были частью языка. Когда абсолютно необходимо изменить поведение на основе имени, это поведение должно быть настраиваемым, например с &lt;code&gt;:locals_without_parens&lt;/code&gt; параметра : locals_without_parens .</target>
        </trans-unit>
        <trans-unit id="4b2df21441dc79dd9bd7c2eac32664e6ea35e2a4" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, or the like. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="translated">Форматер не жестко кодирует имена. Средство форматирования не будет вести себя особым образом, потому что функция называется &lt;code&gt;defmodule&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; или тому подобное. Этот принцип отражает цель Elixir - быть расширяемым языком, где разработчики могут расширять язык с помощью новых конструкций, как если бы они были частью языка. Когда абсолютно необходимо изменить поведение на основе имени, это поведение должно быть настраиваемым, например с &lt;code&gt;:locals_without_parens&lt;/code&gt; параметра : locals_without_parens .</target>
        </trans-unit>
        <trans-unit id="03003fdc11feaf71c728ace4a4e8175ee7b4844f" translate="yes" xml:space="preserve">
          <source>The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules.</source>
          <target state="translated">Формататор получает строку,представляющую код Elixir,и возвращает iodata,представляющую отформатированный код в соответствии с заданными правилами.</target>
        </trans-unit>
        <trans-unit id="72e5baea79c2662552fd592f7668202474a199d4" translate="yes" xml:space="preserve">
          <source>The formatter respects the input format in some cases. Those are listed below:</source>
          <target state="translated">В некоторых случаях форматировщик соблюдает формат ввода.Они перечислены ниже:</target>
        </trans-unit>
        <trans-unit id="73147abbfb07a1782272353b129dfe6ae2759140" translate="yes" xml:space="preserve">
          <source>The formatter was designed under three principles.</source>
          <target state="translated">Форматер был разработан в соответствии с тремя принципами.</target>
        </trans-unit>
        <trans-unit id="d253cdad860fbe489673fba372b661892f2a2b1a" translate="yes" xml:space="preserve">
          <source>The formatter will also receive the following events but they are deprecated and should be ignored:</source>
          <target state="translated">Форматтер также получит следующие события,но они устарели,и их следует игнорировать:</target>
        </trans-unit>
        <trans-unit id="16faacc4637c873b1a6d5ef2df7c790ea5ae523a" translate="yes" xml:space="preserve">
          <source>The formatter will read a &lt;code&gt;.formatter.exs&lt;/code&gt; file in the current directory for formatter configuration. Evaluating this file should return a keyword list.</source>
          <target state="translated">Средство форматирования прочитает файл &lt;code&gt;.formatter.exs&lt;/code&gt; в текущем каталоге для настройки средства форматирования. При оценке этого файла должен быть возвращен список ключевых слов.</target>
        </trans-unit>
        <trans-unit id="54861fc5081e64334a71df9d50b523e9ef441995" translate="yes" xml:space="preserve">
          <source>The formatter wraps the algebra document representing the map in &lt;a href=&quot;#next_break_fits/1&quot;&gt;&lt;code&gt;next_break_fits/1&lt;/code&gt;&lt;/a&gt; so the code is formatted as:</source>
          <target state="translated">Форматировщик оборачивает документ алгебры, представляющий карту, в &lt;a href=&quot;#next_break_fits/1&quot;&gt; &lt;code&gt;next_break_fits/1&lt;/code&gt; ,&lt;/a&gt; поэтому код отформатирован как:</target>
        </trans-unit>
        <trans-unit id="1b530c8de3f53b8e27706291f76c2c2287eac72b" translate="yes" xml:space="preserve">
          <source>The formatting syntax for strftime is a sequence of characters in the following format:</source>
          <target state="translated">Синтаксис форматирования для strftime представляет собой последовательность символов в следующем формате:</target>
        </trans-unit>
        <trans-unit id="95bd7646a64eb0576fcb230b316aeb1624812ca3" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Основа Mix - это проект. Проект можно определить с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; в модуле, обычно помещаемом в файл с именем &lt;code&gt;mix.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="619bfcd8852612a615d36e293bdf93e9442a2fd9" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;mix.project&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Основа Mix - это проект. Проект можно определить с помощью &lt;a href=&quot;mix.project&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; в модуле, обычно помещаемом в файл с именем &lt;code&gt;mix.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7b28558869b4d11a344cb1f239f09303f041a1a0" translate="yes" xml:space="preserve">
          <source>The full ExUnit configuration is passed as the argument to &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt;&lt;code&gt;GenServer.init/1&lt;/code&gt;&lt;/a&gt; callback when the formatters are started. If you need to do runtime configuration of a formatter, you can add any configuration needed by using &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#start/1&quot;&gt;&lt;code&gt;ExUnit.start/1&lt;/code&gt;&lt;/a&gt;, and this will then be included in the options passed to the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt;&lt;code&gt;GenServer.init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Полная конфигурация ExUnit передается в качестве аргумента &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt; &lt;code&gt;GenServer.init/1&lt;/code&gt; &lt;/a&gt; обратного вызова GenServer.init / 1 при запуске форматеров. Если вам нужно выполнить настройку форматировщика во время выполнения, вы можете добавить любую необходимую конфигурацию с помощью &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#start/1&quot;&gt; &lt;code&gt;ExUnit.start/1&lt;/code&gt; &lt;/a&gt; , и это будет затем включено в параметры, передаваемые в &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt; &lt;code&gt;GenServer.init/1&lt;/code&gt; &lt;/a&gt; вызов GenServer.init / 1 .</target>
        </trans-unit>
        <trans-unit id="27f8279b8cd5628c38c64722e539ac026a11da8b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#put_env/3&quot;&gt;&lt;code&gt;put_env/3&lt;/code&gt;&lt;/a&gt; allows dynamic configuration of the application environment, but as a rule of thumb each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications.</source>
          <target state="translated">Функция &lt;a href=&quot;#put_env/3&quot;&gt; &lt;code&gt;put_env/3&lt;/code&gt; &lt;/a&gt; позволяет динамически конфигурировать среду приложения, но, как правило, каждое приложение отвечает за свою среду. Пожалуйста, не используйте функции этого модуля для прямого доступа или изменения среды других приложений.</target>
        </trans-unit>
        <trans-unit id="44dd7e8c0883ba7364643058445d069f16c2e43c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#struct!/2&quot;&gt;&lt;code&gt;struct!/2&lt;/code&gt;&lt;/a&gt; emulates the compile time behaviour of structs. This means that:</source>
          <target state="translated">Функция &lt;a href=&quot;#struct!/2&quot;&gt; &lt;code&gt;struct!/2&lt;/code&gt; &lt;/a&gt; имитирует поведение структур во время компиляции. Это означает, что:</target>
        </trans-unit>
        <trans-unit id="8e0639c36ddd40dd4d3c1545de8b7ff6af66a1a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (that is, the &quot;get&quot; value) and the second one being the new state of the agent.</source>
          <target state="translated">Функция &lt;code&gt;fun&lt;/code&gt; отправляется &lt;code&gt;agent&lt;/code&gt; который вызывает функцию, передающую состояние агента. Функция должна возвращать кортеж с двумя элементами, первый из которых является возвращаемым значением (то есть значением &amp;laquo;get&amp;raquo;), а второй - новым состоянием агента.</target>
        </trans-unit>
        <trans-unit id="216982854731717320607d5aa3e2c69ffa39cfa0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The result of the function invocation is returned from this function.</source>
          <target state="translated">Функция &lt;code&gt;fun&lt;/code&gt; отправляется &lt;code&gt;agent&lt;/code&gt; который вызывает функцию, передающую состояние агента. Эта функция возвращает результат вызова функции.</target>
        </trans-unit>
        <trans-unit id="fc7b0ec15b4d375100169c807030b178d76cb224" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The return value of &lt;code&gt;fun&lt;/code&gt; becomes the new state of the agent.</source>
          <target state="translated">Функция &lt;code&gt;fun&lt;/code&gt; отправляется &lt;code&gt;agent&lt;/code&gt; который вызывает функцию, передающую состояние агента. Возвращаемое значение &lt;code&gt;fun&lt;/code&gt; становится новым состоянием агента.</target>
        </trans-unit>
        <trans-unit id="cad7f93891da662dbbaf24dfbad6e47a904e9038" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term which is used to determine if two elements are duplicates.</source>
          <target state="translated">Функция &lt;code&gt;fun&lt;/code&gt; сопоставляет каждый элемент с термином, который используется для определения дубликатов двух элементов.</target>
        </trans-unit>
        <trans-unit id="2063958f17451467d712f93ea552d845434a5f7b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term. Two elements are considered duplicates if the return value of &lt;code&gt;fun&lt;/code&gt; is equal for both of them.</source>
          <target state="translated">Функция &lt;code&gt;fun&lt;/code&gt; отображает каждый элемент на термин. Два элемента считаются дубликатами, если возвращаемое значение &lt;code&gt;fun&lt;/code&gt; одинаково для них обоих.</target>
        </trans-unit>
        <trans-unit id="786bdba792da55f0fb2aae425ae917dfa7672afd" translate="yes" xml:space="preserve">
          <source>The function must receive the exit status code as an argument.</source>
          <target state="translated">В качестве аргумента функция должна получить код состояния выхода.</target>
        </trans-unit>
        <trans-unit id="a56026b8a6cb0f0aeff01c85c9ee7342a99db076" translate="yes" xml:space="preserve">
          <source>The function must return:</source>
          <target state="translated">Функция должна вернуться:</target>
        </trans-unit>
        <trans-unit id="78c45238f9f6bc55b2be81844c73ef2dab477691" translate="yes" xml:space="preserve">
          <source>The function receives the arguments and passes them to &lt;code&gt;if&lt;/code&gt;. However, as we learned in the &lt;a href=&quot;quote-and-unquote&quot;&gt;previous chapter&lt;/a&gt;, the macro will receive quoted expressions, inject them into the quote, and finally return another quoted expression.</source>
          <target state="translated">Функция получает аргументы и передает их &lt;code&gt;if&lt;/code&gt; . Однако, как мы узнали в &lt;a href=&quot;quote-and-unquote&quot;&gt;предыдущей главе&lt;/a&gt; , макрос будет получать цитируемые выражения, вставлять их в кавычки и, наконец, возвращать другое цитируемое выражение.</target>
        </trans-unit>
        <trans-unit id="970e1abe8c2a97edfeb1747215a9aaebefbaf05f" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;:ok&lt;/code&gt; in case of success. Otherwise, it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">Функция возвращает &lt;code&gt;:ok&lt;/code&gt; в случае успеха. В противном случае возвращается &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42211e9c17fc840b6d18e986bbdd31d79b28999c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; in case of success, &lt;code&gt;files_and_directories&lt;/code&gt; lists all files and directories copied in no specific order. It returns &lt;code&gt;{:error, reason, file}&lt;/code&gt; otherwise.</source>
          <target state="translated">Функция возвращает &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; в случае успеха, &lt;code&gt;files_and_directories&lt;/code&gt; перечисляет все файлы и каталоги, скопированные в произвольном порядке. В противном случае он возвращает &lt;code&gt;{:error, reason, file}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b12965a38c8943a04c360761ab1a75653a316455" translate="yes" xml:space="preserve">
          <source>The function should return a non empty list where the amount of elements is equal to &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">Функция должна возвращать непустой список, в котором количество элементов равно &lt;code&gt;length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="370959ce1313e0ee1574bb7b4f639ad8e764cdd3" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;fun&lt;/code&gt;, receives two arguments: the first one is the element, and the second one is the accumulator. &lt;code&gt;fun&lt;/code&gt; must return a tuple with two elements in the form of &lt;code&gt;{result, accumulator}&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;fun&lt;/code&gt; получает два аргумента: первый - это элемент, а второй - это аккумулятор. &lt;code&gt;fun&lt;/code&gt; должен возвращать кортеж с двумя элементами в виде &lt;code&gt;{result, accumulator}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5956f11dd1602a7d0b839eecd3ea612fa5aace7" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#nest/2&quot;&gt;&lt;code&gt;nest/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#space/2&quot;&gt;&lt;code&gt;space/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#line/2&quot;&gt;&lt;code&gt;line/2&lt;/code&gt;&lt;/a&gt; help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like &lt;a href=&quot;#glue/3&quot;&gt;&lt;code&gt;glue/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#group/1&quot;&gt;&lt;code&gt;group/1&lt;/code&gt;&lt;/a&gt;. A glue inserts a break between two documents. A group indicates a document that must fit the current line, otherwise breaks are rendered as new lines. Let's glue two docs together with a break, group it and then render it:</source>
          <target state="translated">Функции &lt;a href=&quot;#nest/2&quot;&gt; &lt;code&gt;nest/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#space/2&quot;&gt; &lt;code&gt;space/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#line/2&quot;&gt; &lt;code&gt;line/2&lt;/code&gt; &lt;/a&gt; помогают собрать документ в жесткую структуру. Однако алгебра документов становится интересной при использовании таких функций, как &lt;a href=&quot;#glue/3&quot;&gt; &lt;code&gt;glue/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#group/1&quot;&gt; &lt;code&gt;group/1&lt;/code&gt; &lt;/a&gt; . Клей вставляет разрыв между двумя документами. Группа указывает документ, который должен соответствовать текущей строке, в противном случае разрывы отображаются как новые строки. Давайте склеим два документа вместе с разрывом, сгруппируем и отрендерим:</target>
        </trans-unit>
        <trans-unit id="c253790d407e18b7d5f0c9bb8af92800693543dd" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; do not guarantee any property when it comes to ordering. However, since a keyword list is simply a list, all the operations defined in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; can be applied too, especially when ordering is required.</source>
          <target state="translated">Функции в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; не гарантируют никаких свойств, когда дело доходит до заказа. Однако, поскольку список ключевых слов - это просто список, все операции, определенные в &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; ,также&lt;/a&gt; могут применяться, особенно когда требуется упорядочение.</target>
        </trans-unit>
        <trans-unit id="fc395b4f1565e86a3f414d5f43f358ea3ab4b968" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;File&lt;/code&gt; also allow lists to be given as arguments. Not only that, they also allow a mixed list of lists, integers, and binaries to be given:</source>
          <target state="translated">Функции в &lt;code&gt;IO&lt;/code&gt; и &lt;code&gt;File&lt;/code&gt; также позволяют указывать списки в качестве аргументов. Мало того, они также позволяют задавать смешанный список списков, целых чисел и двоичных файлов:</target>
        </trans-unit>
        <trans-unit id="c24702aeda4cc39358f5c9073ad6385b684128ba" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;ets&lt;/code&gt; module will modify the state of the table as a side-effect.</source>
          <target state="translated">Функции в модуле &lt;code&gt;ets&lt;/code&gt; изменяют состояние таблицы как побочный эффект.</target>
        </trans-unit>
        <trans-unit id="645c924b3f04d5643fc9c0295858b7ef02f4fe7d" translate="yes" xml:space="preserve">
          <source>The functions in the Enum module are limited to, as the name says, enumerating values in data structures. For specific operations, like inserting and updating particular elements, you may need to reach for modules specific to the data type. For example, if you want to insert an element at a given position in a list, you should use the &lt;code&gt;List.insert_at/3&lt;/code&gt; function from &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;the &lt;code&gt;List&lt;/code&gt; module&lt;/a&gt;, as it would make little sense to insert a value into, for example, a range.</source>
          <target state="translated">Функции в модуле Enum ограничены, как следует из названия, перечислением значений в структурах данных. Для определенных операций, таких как вставка и обновление определенных элементов, вам может потребоваться обратиться к модулям, специфичным для данного типа данных. Например, если вы хотите , чтобы вставить элемент в заданной позиции в списке, вы должны использовать &lt;code&gt;List.insert_at/3&lt;/code&gt; функцию из &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;в &lt;code&gt;List&lt;/code&gt; модулей&lt;/a&gt; , как это было бы мало смысла , чтобы вставить значение в, например, диапазон ,</target>
        </trans-unit>
        <trans-unit id="77cce334a46132ba295a248960c6d018c960a8aa" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 11.0.0.</source>
          <target state="translated">Функции этого модуля действуют в соответствии со стандартом Unicode,версия 11.0.0.</target>
        </trans-unit>
        <trans-unit id="2539a9cd4324f66b525de87feede6af27bf5479d" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 12.1.0.</source>
          <target state="translated">Функции этого модуля действуют в соответствии со стандартом Unicode,версия 12.1.0.</target>
        </trans-unit>
        <trans-unit id="435e788eab1bd17ae90e69f5f7810182e093e4b6" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="translated">Функции в этом модуле объявлены устаревшими, и они не работают со спецификациями дочерних модулей на основе модулей, представленными в Elixir v1.5. Вместо этого см. Документацию &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="173416c87fd5ec34f77cd8d34322b0332ac7cfcb" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="translated">Функции в этом модуле объявлены устаревшими и не работают со спецификациями дочерних модулей на основе модулей, представленными в Elixir v1.5. Вместо этого см. Документацию &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55c1606f7340829fac4bdeef11ed0e160ebd64a6" translate="yes" xml:space="preserve">
          <source>The functions in this module come in two flavors: named or operators. For example:</source>
          <target state="translated">Функции в этом модуле поставляются в двух вариантах:с именами или с операторами.Например:</target>
        </trans-unit>
        <trans-unit id="96e74349f320a8c58dc1c59108496ee930024bf1" translate="yes" xml:space="preserve">
          <source>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</source>
          <target state="translated">Функции в этом модуле могут получать в качестве аргумента чардата (т.е.строку или список символов/строка)и всегда будут возвращать строку (в кодировке UTF-8).</target>
        </trans-unit>
        <trans-unit id="b429b5ce2f9a2392aff46c5515cf68d49d6d6adf" translate="yes" xml:space="preserve">
          <source>The functions in this module support chardata, so giving a list will treat it as a single entity:</source>
          <target state="translated">Функции в этом модуле поддерживают чардаты,поэтому предоставление списка будет восприниматься как единая сущность:</target>
        </trans-unit>
        <trans-unit id="255d1a73d20d6ce6127802c33ec8ce540df5e39c" translate="yes" xml:space="preserve">
          <source>The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple:</source>
          <target state="translated">Функции в этом модуле,которые добавляют и удаляют элементы кортежей,редко используются на практике,так как обычно подразумевают,что кортежи используются в качестве коллекций.Чтобы дополнить кортеж,предпочтительно извлечь элементы из старого кортежа с выравниванием по шаблону,а затем создать новый кортеж:</target>
        </trans-unit>
        <trans-unit id="33b30755a342f20f218b83071cf71f52c8757557" translate="yes" xml:space="preserve">
          <source>The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as &lt;a href=&quot;#keys/1&quot;&gt;&lt;code&gt;keys/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values/1&quot;&gt;&lt;code&gt;values/1&lt;/code&gt;&lt;/a&gt;, run in linear time because they need to get to every element in the map.</source>
          <target state="translated">Функции этого модуля, которым необходимо найти конкретный ключ, работают в логарифмическом времени. Это означает, что время, необходимое для поиска ключей, увеличивается по мере роста карты, но оно не прямо пропорционально размеру карты. По сравнению с поиском элемента в списке он работает лучше, потому что списки имеют линейную временную сложность. Некоторые функции, такие как &lt;a href=&quot;#keys/1&quot;&gt; &lt;code&gt;keys/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#values/1&quot;&gt; &lt;code&gt;values/1&lt;/code&gt; &lt;/a&gt; , выполняются за линейное время, потому что им нужно добраться до каждого элемента на карте.</target>
        </trans-unit>
        <trans-unit id="74f82d17a516dfeabf8954e130f2901c86439fbe" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">Функции в этом модуле работают в линейном времени. Это означает, что время, необходимое для выполнения операции, растет с той же скоростью, что и длина перечисляемого. Это ожидается в таких операциях, как &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; . В конце концов, если мы хотим пройти по каждому элементу в списке, чем длиннее список, тем больше элементов нам нужно пройти и тем больше времени это займет.</target>
        </trans-unit>
        <trans-unit id="9f0853ffd0b6dd95f29653e4a1c1ad06e52385c2" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">Функции в этом модуле работают в линейном времени. Это означает, что время, необходимое для выполнения операции, растет с той же скоростью, что и длина перечисляемого. Это ожидается в таких операциях, как &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; . В конце концов, если мы хотим пройти по каждому элементу в списке, чем длиннее список, тем больше элементов нам нужно пройти, и тем больше времени это займет.</target>
        </trans-unit>
        <trans-unit id="3463cc17b842a1d5960bd8ec694214b314a84bdc" translate="yes" xml:space="preserve">
          <source>The functions listed under &lt;code&gt;:locals_without_parens&lt;/code&gt; in the &lt;code&gt;:export&lt;/code&gt; option of a dependency can be imported in a project by listing that dependency in the &lt;code&gt;:import_deps&lt;/code&gt; option of the formatter configuration file of the project.</source>
          <target state="translated">Функции, перечисленные в &lt;code&gt;:locals_without_parens&lt;/code&gt; в параметре &lt;code&gt;:export&lt;/code&gt; зависимости, могут быть импортированы в проект, указав эту зависимость в параметре &lt;code&gt;:import_deps&lt;/code&gt; файла конфигурации программы форматирования проекта.</target>
        </trans-unit>
        <trans-unit id="2b5e518a4ce1d29fa0de0a02c9ab38609211f7bc" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Функции в этом модуле работают со структурой &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; ,&lt;/a&gt; а также со структурой, содержащей те же поля, что и структура &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , например &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . Такие функции ожидают &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:date/0&quot;&gt; &lt;code&gt;Calendar.date/0&lt;/code&gt; &lt;/a&gt; в своих типах (вместо &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="709dd48512a8ffdaa9639efcdf5626b90390736d" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Функции этого модуля работают со структурой &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; ,&lt;/a&gt; а также со структурой, содержащей те же поля, что и структура &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , например &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . Такие функции ожидают &lt;a href=&quot;calendar#t:date/0&quot;&gt; &lt;code&gt;Calendar.date/0&lt;/code&gt; &lt;/a&gt; в своих типах (вместо &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ff0d30d9202c4c6b14208fdf831e03638322939" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Функции в этом модуле работают со структурой &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; ,&lt;/a&gt; а также со структурой, содержащей те же поля, что и структура &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; , например &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . Такие функции ожидают &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:time/0&quot;&gt; &lt;code&gt;Calendar.time/0&lt;/code&gt; &lt;/a&gt; в своих типах (вместо &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd7fe8f3288c5b63dba38948e86e695e4e2b2557" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Функции в этом модуле работают со структурой &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; ,&lt;/a&gt; а также с любой структурой, содержащей те же поля, что и структура &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; , например &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . Такие функции ожидают &lt;a href=&quot;calendar#t:time/0&quot;&gt; &lt;code&gt;Calendar.time/0&lt;/code&gt; &lt;/a&gt; в своих типах (вместо &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="003b5d0dd560d869b45725f5251941da4e2978b9" translate="yes" xml:space="preserve">
          <source>The general Elixir identifier rule is specified as:</source>
          <target state="translated">Общее правило идентификатора эликсира указано как:</target>
        </trans-unit>
        <trans-unit id="279b2d1d6d51ad298e11acb6402db1bbf4467c85" translate="yes" xml:space="preserve">
          <source>The generated files are similar to the ones we first generated for &lt;code&gt;kv&lt;/code&gt;, with a few differences. Let&amp;rsquo;s open up &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Сгенерированные файлы похожи на те, которые мы сначала создали для &lt;code&gt;kv&lt;/code&gt; , с некоторыми отличиями. Откроем до &lt;code&gt;mix.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe11b786cb48918f9b05dccc30b89f3c9d182f54" translate="yes" xml:space="preserve">
          <source>The generated macros can also be used in order to pattern match on records and to bind variables during the match:</source>
          <target state="translated">Сгенерированные макросы также могут быть использованы для шаблонного совпадения по записям и для привязки переменных во время совпадения:</target>
        </trans-unit>
        <trans-unit id="50f5c0fcf4c39bd1e0e3ce49d94a449eccf8a5ee" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;datetime_string&lt;/code&gt; must include &quot;Z&quot; or &quot;00:00&quot; offset which marks it as UTC, otherwise an error is raised.</source>
          <target state="translated">Данная &lt;code&gt;datetime_string&lt;/code&gt; должна включать смещение &amp;laquo;Z&amp;raquo; или &amp;laquo;00:00&amp;raquo;, которое отмечает ее как UTC, в противном случае возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="5945d8ce9d0ed7b935712680470e46feacdd1644" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;fun&lt;/code&gt; is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node.</source>
          <target state="translated">Данная &lt;code&gt;fun&lt;/code&gt; вызывается для каждого узла в AST с двумя аргументами: AST печатаемого узла и строковое представление того же узла. Возвращаемое значение этой функции используется в качестве окончательного строкового представления для этого узла AST.</target>
        </trans-unit>
        <trans-unit id="a83da51956cb3348840e43e856af798fc100e9ea" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing configuration for the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">Указанные &lt;code&gt;opts&lt;/code&gt; объединяются в существующую конфигурацию для данного &lt;code&gt;root_key&lt;/code&gt; . Конфликтующие ключи заменяются ключами, указанными в &lt;code&gt;opts&lt;/code&gt; . Например, конфигурация приложения ниже</target>
        </trans-unit>
        <trans-unit id="b05f234517d759a8cb3f7b2d59dc801482a98965" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing values for &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">Указанные &lt;code&gt;opts&lt;/code&gt; объединяются с существующими значениями &lt;code&gt;key&lt;/code&gt; в данном &lt;code&gt;root_key&lt;/code&gt; . Конфликтующие ключи заменяются ключами, указанными в &lt;code&gt;opts&lt;/code&gt; . Например, конфигурация приложения ниже</target>
        </trans-unit>
        <trans-unit id="02ef5a607d49adbb7866b57f819df6b77fdbb345" translate="yes" xml:space="preserve">
          <source>The given config should not:</source>
          <target state="translated">Данная конфигурация не должна:</target>
        </trans-unit>
        <trans-unit id="44e635edac5e4e08e828b82a2eaab3164491a4b7" translate="yes" xml:space="preserve">
          <source>The given datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">Указанное время возвращается без изменений,если оно уже имеет более низкую точность,чем заданная.</target>
        </trans-unit>
        <trans-unit id="77d42dd0c470aae641d549b4c74c46ab9659c1be" translate="yes" xml:space="preserve">
          <source>The given dependencies and the projects they depend on will be unlocked and updated to the latest version according to their version requirements.</source>
          <target state="translated">Данные зависимости и проекты,от которых они зависят,будут разблокированы и обновлены до последней версии в соответствии с их требованиями к версии.</target>
        </trans-unit>
        <trans-unit id="6d2a43a0c7f321f6321fd1b9eb5b43b059a8e70b" translate="yes" xml:space="preserve">
          <source>The given naive datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">Указанное наивное время даты возвращается без изменений,если оно уже имеет более низкую точность,чем заданная.</target>
        </trans-unit>
        <trans-unit id="ee23443246e5491d80625e07cdf87fe6cfe649c9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="translated">Указанные параметры могут быть либо двоичным &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; с символами, представляющими те же параметры регулярного выражения, что и сигил &lt;code&gt;~r&lt;/code&gt; (см. Kernel.sigil_r / 2 ), либо списком параметров, как ожидается модулем Erlang &lt;code&gt;:re&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8ff7c40025099fed2b47a6ca6bd7d1bee58abb9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="translated">Указанные параметры могут быть либо двоичным &lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; с символами, представляющими те же параметры регулярного выражения, что и сигил &lt;code&gt;~r&lt;/code&gt; (см. Kernel.sigil_r / 2 ), либо списком параметров, как ожидается модулем Erlang &lt;code&gt;:re&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a877d88a9ed060a658c7f85f772f951264b25f7d" translate="yes" xml:space="preserve">
          <source>The given string may contain a timezone offset but it is ignored.</source>
          <target state="translated">Данная строка может содержать смещение часового пояса,но игнорируется.</target>
        </trans-unit>
        <trans-unit id="8ee391432291b1d23474c64748cd369ce3de6c17" translate="yes" xml:space="preserve">
          <source>The given time is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">Данное время возвращается без изменений,если оно уже имеет более низкую точность,чем заданная.</target>
        </trans-unit>
        <trans-unit id="595ea9127c2b29264915dada8a0a74f247f402db" translate="yes" xml:space="preserve">
          <source>The goal in this chapter is to build a module named &lt;code&gt;TestCase&lt;/code&gt; that allows us to write the following:</source>
          <target state="translated">Цель этой главы - создать модуль с именем &lt;code&gt;TestCase&lt;/code&gt; , который позволит нам написать следующее:</target>
        </trans-unit>
        <trans-unit id="005035c0ac9ba5b2d03b96ccf393ae5ff11ffe11" translate="yes" xml:space="preserve">
          <source>The goal of a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is to abstract the &quot;receive&quot; loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own &quot;receive&quot; inside the GenServer callbacks as doing so will cause the GenServer to misbehave.</source>
          <target state="translated">Цель &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; - абстрагировать цикл &amp;laquo;получения&amp;raquo; для разработчиков, автоматически обрабатывая системные сообщения, поддерживая изменение кода, синхронные вызовы и многое другое. Следовательно, вы никогда не должны вызывать собственное &amp;laquo;получение&amp;raquo; внутри обратных вызовов GenServer, так как это приведет к неправильному поведению GenServer.</target>
        </trans-unit>
        <trans-unit id="1a6d568374392c51e27178f8aac8e2da82bbf64d" translate="yes" xml:space="preserve">
          <source>The good news is that breaking an umbrella apart is quite straightforward, as you simply need to move applications outside of the umbrella project&amp;rsquo;s &lt;code&gt;apps/&lt;/code&gt; directory. In the worst case scenario, you can discard the umbrella project and all related configuration (&lt;code&gt;build_path&lt;/code&gt;, &lt;code&gt;config_path&lt;/code&gt;, &lt;code&gt;deps_path&lt;/code&gt; and &lt;code&gt;lockfile&lt;/code&gt;) and still leverage the &amp;ldquo;mono-repo&amp;rdquo; pattern by keeping all applications together in the same repository. Each application will have its own dependencies and configuration. Dependencies between those applications can still be explicitly listed by using the &lt;code&gt;:path&lt;/code&gt; option (in contrast to &lt;code&gt;:git&lt;/code&gt;).</source>
          <target state="translated">Хорошая новость заключается в том, что разорвать зонтик на части довольно просто, поскольку вам просто нужно переместить приложения за пределы каталога &lt;code&gt;apps/&lt;/code&gt; зонтичного проекта . В худшем случае, вы можете отказаться от проекта зонтик и всю соответствующую конфигурацию ( &lt;code&gt;build_path&lt;/code&gt; , &lt;code&gt;config_path&lt;/code&gt; , &lt;code&gt;deps_path&lt;/code&gt; и &lt;code&gt;lockfile&lt;/code&gt; ) и по- прежнему использовать &amp;laquo;моно-репо&amp;raquo; шаблон, сохраняя все приложения вместе в том же хранилище. У каждого приложения будут свои зависимости и настройки. Зависимости между этими приложениями по-прежнему можно явно указать с помощью параметра &lt;code&gt;:path&lt;/code&gt; (в отличие от &lt;code&gt;:git&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="78ffff4bce308419c28073fad905a3416ef9e300" translate="yes" xml:space="preserve">
          <source>The good news is that developers can use third-party implementations of both Elixir backends and Erlang handlers.</source>
          <target state="translated">Хорошая новость заключается в том,что разработчики могут использовать сторонние реализации как бэкэндов Elixir,так и обработчиков Erlang.</target>
        </trans-unit>
        <trans-unit id="18abb99c49c0cd9f625ee8db0e020cadbbd4d636" translate="yes" xml:space="preserve">
          <source>The greatest common divisor (GCD) of &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; is the largest positive integer that divides both &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; without leaving a remainder.</source>
          <target state="translated">Наибольший общий делитель (НОД) &lt;code&gt;integer1&lt;/code&gt; и &lt;code&gt;integer2&lt;/code&gt; - это наибольшее положительное целое число, которое делит как &lt;code&gt;integer1&lt;/code&gt; ,так и &lt;code&gt;integer2&lt;/code&gt; , не оставляя остатка.</target>
        </trans-unit>
        <trans-unit id="04a15f34a10083efdd1b4c7fb23d6409a2799f7b" translate="yes" xml:space="preserve">
          <source>The group mode can also be set to &lt;code&gt;:inherit&lt;/code&gt;, which means it automatically breaks if the parent group has broken too.</source>
          <target state="translated">Групповой режим также может быть установлен на &lt;code&gt;:inherit&lt;/code&gt; , что означает, что он автоматически прерывается, если родительская группа тоже сломалась.</target>
        </trans-unit>
        <trans-unit id="a353728570ac2d4d82e8f0ff930144d1e562cb6a" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, and others) won't be available by the time the handler function is invoked.</source>
          <target state="translated">Обработчик всегда выполняет процесс,отличный от того,в котором он был зарегистрирован.Как следствие,любые ресурсы,управляемые вызывающим процессом (таблицы ETS,открытые файлы и другие),не будут доступны к моменту вызова функции обработчика.</target>
        </trans-unit>
        <trans-unit id="abae706b2e9875a2d4fe24ac37232c3285b58047" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, etc.) won't be available by the time the handler function is invoked.</source>
          <target state="translated">Обработчик всегда выполняет процесс,отличный от того,в котором он был зарегистрирован.Как следствие,любые ресурсы,управляемые вызывающим процессом (таблицы ETS,открытые файлы и т.д.),не будут доступны к моменту вызова функции обработчика.</target>
        </trans-unit>
        <trans-unit id="91dc0be92537f81da316aa8d3834b6a0c2b63c02" translate="yes" xml:space="preserve">
          <source>The head element of aliases can be any term that must expand to an atom at compilation time.</source>
          <target state="translated">Головным элементом псевдонимов может быть любой термин,который должен расширяться до атома во время компиляции.</target>
        </trans-unit>
        <trans-unit id="d895e647576b7caa588974823adee16cc261b47d" translate="yes" xml:space="preserve">
          <source>The hex representation will also help you look up information about a code point, e.g. &lt;a href=&quot;https://codepoints.net/U+0061&quot;&gt;https://codepoints.net/U+0061&lt;/a&gt; has a data sheet all about the lower case &lt;code&gt;a&lt;/code&gt;, a.k.a. code point 97.</source>
          <target state="translated">Шестнадцатеричное представление также поможет вам найти информацию о кодовой точке, например, &lt;a href=&quot;https://codepoints.net/U+0061&quot;&gt;https://codepoints.net/U+0061&lt;/a&gt; содержит таблицу данных о нижнем регистре &lt;code&gt;a&lt;/code&gt; , также известном как кодовая точка 97.</target>
        </trans-unit>
        <trans-unit id="b5f5e37ee6e6bb7829dd572b3c957edcc2f9784b" translate="yes" xml:space="preserve">
          <source>The implementation above is arguably not a reasonable one. For example, it makes no sense to say that the size of a &lt;code&gt;PID&lt;/code&gt; or an &lt;code&gt;Integer&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутая реализация, возможно, не является разумной. Например, нет смысла говорить, что размер &lt;code&gt;PID&lt;/code&gt; или &lt;code&gt;Integer&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a82e7d1f4f1afb4f634e8bc16b67baab165570d" translate="yes" xml:space="preserve">
          <source>The implementation is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;reservoir sampling&lt;/a&gt; algorithm. It assumes that the sample being returned can fit into memory; the input &lt;code&gt;enumerable&lt;/code&gt; doesn't have to, as it is traversed just once.</source>
          <target state="translated">Реализация основана на алгоритме &lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;отбора проб&lt;/a&gt; из пласта . Предполагается, что возвращаемый образец может уместиться в памяти; входной &lt;code&gt;enumerable&lt;/code&gt; не обязан , поскольку он проходит только один раз.</target>
        </trans-unit>
        <trans-unit id="8b8d2b9e0c9b1879d05717152c53da40bcc3437b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; is based on the Strictly Pretty paper by &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt; which builds on top of previous pretty printing algorithms but is tailored to strict languages, such as Elixir. The core idea in the paper is the use of explicit document groups which are rendered as flat (breaks as spaces) or as break (breaks as newlines).</source>
          <target state="translated">Реализация &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; основана на статье Strictly Pretty от &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Линдига,&lt;/a&gt; которая построена на основе предыдущих красивых алгоритмов печати, но адаптирована для строгих языков, таких как Elixir. Основная идея в статье - использование явных групп документов, которые отображаются как плоские (разрывы как пробелы) или как разрывы (разрывы как символы новой строки).</target>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="translated">Реализация этого обратного вызова должна вызывать &lt;code&gt;fun&lt;/code&gt; со значением под &lt;code&gt;key&lt;/code&gt; в переданных &lt;code&gt;data&lt;/code&gt; структуры или с &lt;code&gt;nil&lt;/code&gt; , если &lt;code&gt;key&lt;/code&gt; в нем отсутствует. Эта функция должна возвращать либо &lt;code&gt;{get_value, update_value}&lt;/code&gt; либо &lt;code&gt;:pop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="791ef5c45db6655a2b8e0d52e101cc594625c78d" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">Начальные серверные ВМ загружаются через конфигурацию &lt;code&gt;:backends&lt;/code&gt; , которая должна быть установлена ​​до запуска приложения &lt;code&gt;:logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26abb8f8f9a767e820200e7bf8e998799e79b893" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started. Backends can also be added dynamically through &lt;a href=&quot;#add_backend/2&quot;&gt;&lt;code&gt;add_backend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Первоначальные серверные ВМ загружаются через конфигурацию &lt;code&gt;:backends&lt;/code&gt; , которая должна быть установлена ​​до запуска приложения &lt;code&gt;:logger&lt;/code&gt; . Бэкэнды также могут быть добавлены динамически через &lt;a href=&quot;#add_backend/2&quot;&gt; &lt;code&gt;add_backend/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5d99b4bc070e331607e6d5df8659a98abe40c48" translate="yes" xml:space="preserve">
          <source>The initial value of the accumulator is &lt;code&gt;acc&lt;/code&gt;. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</source>
          <target state="translated">Начальное значение аккумулятора &lt;code&gt;acc&lt;/code&gt; . Функция вызывается для каждого элемента перечисляемого с аккумулятором. Результат, возвращаемый функцией, используется в качестве аккумулятора для следующей итерации. Функция возвращает последний аккумулятор.</target>
        </trans-unit>
        <trans-unit id="a3d8510abacaf7b1519659fdcdb00b6e366da892" translate="yes" xml:space="preserve">
          <source>The initialization arguments, in this case the atom &lt;code&gt;:ok&lt;/code&gt;</source>
          <target state="translated">Аргументы инициализации, в данном случае атом &lt;code&gt;:ok&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3041c0950b326f4d917de04b2c7baea534d3ad6" translate="yes" xml:space="preserve">
          <source>The inputs of a macro</source>
          <target state="translated">Входы макроса</target>
        </trans-unit>
        <trans-unit id="90073db7fde62d3d91fecce3e1a99c3827dbc4cc" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="translated">Целое число может быть указано в разных единицах измерения в соответствии с &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; ,&lt;/a&gt; и оно будет внутренне преобразовано в микросекунды.</target>
        </trans-unit>
        <trans-unit id="36e6d864c0e22df1c9a628ca13539c3c770887d4" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally. Up to 253402300799 seconds is supported.</source>
          <target state="translated">Целое число может быть указано в разных единицах измерения в соответствии с &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; ,&lt;/a&gt; и оно будет внутренне преобразовано в микросекунды. Поддерживается до 253402300799 секунд.</target>
        </trans-unit>
        <trans-unit id="c1ddbc45c619f8049cea4c440a4edb65fecbed96" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="translated">Целое число может быть указано в разных единицах измерения в соответствии с &lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; ,&lt;/a&gt; и оно будет внутренне преобразовано в микросекунды.</target>
        </trans-unit>
        <trans-unit id="c5f1e2568ac6af5c9527d828828602700a4893a4" translate="yes" xml:space="preserve">
          <source>The interesting thing about this approach is that Mix has many conveniences for working with such projects, such as the ability to compile and test all applications inside &lt;code&gt;apps&lt;/code&gt; with a single command. However, even though they are all listed together inside &lt;code&gt;apps&lt;/code&gt;, they are still decoupled from each other, so you can build, test and deploy each application in isolation if you want to.</source>
          <target state="translated">Интересным в этом подходе является то, что Mix имеет множество удобств для работы с такими проектами, например, возможность компилировать и тестировать все приложения внутри &lt;code&gt;apps&lt;/code&gt; с помощью одной команды. Однако, несмотря на то, что все они перечислены вместе внутри &lt;code&gt;apps&lt;/code&gt; , они по-прежнему отделены друг от друга, поэтому вы можете создавать, тестировать и развертывать каждое приложение изолированно, если хотите.</target>
        </trans-unit>
        <trans-unit id="ccef43e698ff7f77a039db9e5b5b3d002b852b8a" translate="yes" xml:space="preserve">
          <source>The internal date format that is used when converting between calendars.</source>
          <target state="translated">Внутренний формат даты,используемый при конвертации между календарями.</target>
        </trans-unit>
        <trans-unit id="5490fd4bbe326611a1d9b742e7e1f91649638437" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (meaning it can not be sent to a process on another node and still remain a valid compiled match_spec, nor can it be stored on disk).</source>
          <target state="translated">Внутреннее представление непрозрачно и не может быть преобразовано во внешний формат терминов,а затем обратно без потери своих свойств (это означает,что оно не может быть отправлено в процесс на другом узле и при этом остается действительным скомпилированным match_spec,а также не может быть сохранено на диске).</target>
        </trans-unit>
        <trans-unit id="6c115b27adcc796af14ec5adb8e1c50e34b4b2ef" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque.</source>
          <target state="translated">Внутреннее представительство непрозрачно.</target>
        </trans-unit>
        <trans-unit id="7334ee5b04d77d686d637a0f70cc9375ca49af7d" translate="yes" xml:space="preserve">
          <source>The internal time format is used when converting between calendars.</source>
          <target state="translated">Внутренний формат времени используется при конвертировании между календарями.</target>
        </trans-unit>
        <trans-unit id="1c746eb548e21139e2d2543ac649c03aeac54f5a" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;env&lt;/code&gt; of an application resource file has a list of tuples that map atoms to terms, and its contents are known as the application &lt;em&gt;environment&lt;/em&gt;. Note that this environment is unrelated to the operating system environment.</source>
          <target state="translated">Ключевой &lt;code&gt;env&lt;/code&gt; файла ресурсов приложения имеет список кортежей, которые сопоставляют атомы с терминами, и его содержимое известно как &lt;em&gt;среда&lt;/em&gt; приложения . Обратите внимание, что эта среда не связана со средой операционной системы.</target>
        </trans-unit>
        <trans-unit id="3409677dd18b558166751c16ef637b64275c9b00" translate="yes" xml:space="preserve">
          <source>The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence. A map value does not belong to this type if it contains a key that is not in the allowed map keys.</source>
          <target state="translated">Типы ключей на картах могут накладываться друг на друга,и если они накладываются,то самый левый ключ имеет приоритет.Значение карты не принадлежит этому типу,если в ней содержится ключ,которого нет в разрешенных ключах карты.</target>
        </trans-unit>
        <trans-unit id="32d41944ca5b336f1b48c86344355078fd3da940" translate="yes" xml:space="preserve">
          <source>The keyword list used with &lt;code&gt;defstruct&lt;/code&gt; defines what fields the struct will have along with their default values.</source>
          <target state="translated">Список ключевых слов, используемый с &lt;code&gt;defstruct&lt;/code&gt; , определяет, какие поля структура будет иметь вместе со значениями по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e67b4b10fb8bead468c4a33dc123a05fee573455" translate="yes" xml:space="preserve">
          <source>The kind (&lt;code&gt;:def&lt;/code&gt; or &lt;code&gt;:defp&lt;/code&gt;) must be given, the function name, its arguments and the compilation options.</source>
          <target state="translated">Должен быть указан тип ( &lt;code&gt;:def&lt;/code&gt; или &lt;code&gt;:defp&lt;/code&gt; ), имя функции, ее аргументы и параметры компиляции.</target>
        </trans-unit>
        <trans-unit id="4db3abef2e6392ab0276950699e4f4e0f758b4c0" translate="yes" xml:space="preserve">
          <source>The kind handled by formatting functions</source>
          <target state="translated">Вид,обрабатываемый функциями форматирования</target>
        </trans-unit>
        <trans-unit id="35b01fa192b09fbd575c96a38ea9c12c69135b18" translate="yes" xml:space="preserve">
          <source>The last step is to change the registry to use the dynamic supervisor:</source>
          <target state="translated">Последний шаг-это изменение реестра для использования динамического супервизора:</target>
        </trans-unit>
        <trans-unit id="ec09c363bc1673984c9ef7c8fd26b487f2e86ec0" translate="yes" xml:space="preserve">
          <source>The last step is to implement &lt;code&gt;KVServer.Command.run/1&lt;/code&gt;, to run the parsed commands against the &lt;code&gt;:kv&lt;/code&gt; application. Its implementation is shown below:</source>
          <target state="translated">Последний шаг - реализовать &lt;code&gt;KVServer.Command.run/1&lt;/code&gt; , чтобы запускать проанализированные команды для приложения &lt;code&gt;:kv&lt;/code&gt; . Его реализация показана ниже:</target>
        </trans-unit>
        <trans-unit id="a7d6dc59f16f27e400e615ab808e1ed8fe0b3a57" translate="yes" xml:space="preserve">
          <source>The last step is to replace all &lt;code&gt;Mix.env()&lt;/code&gt; calls by &lt;code&gt;config_env()&lt;/code&gt;.</source>
          <target state="translated">Последний шаг - заменить все &lt;code&gt;Mix.env()&lt;/code&gt; на &lt;code&gt;config_env()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1505f07b9a5dea491d06c3282407488da838a326" translate="yes" xml:space="preserve">
          <source>The last syntax convenience are &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks. &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks are equivalent to keywords as the last argument of a function call where the block contents are wrapped in parentheses. For example:</source>
          <target state="translated">Последнее удобство синтаксиса - &lt;code&gt;do&lt;/code&gt; блоки do / &lt;code&gt;end&lt;/code&gt; . Блоки &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; эквивалентны ключевым словам в качестве последнего аргумента вызова функции, где содержимое блока заключено в круглые скобки. Например:</target>
        </trans-unit>
        <trans-unit id="bc0ec7829a3c5fbbae5ba7d71fb20b1484d4bd86" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression.</source>
          <target state="translated">Стрелка слева направо ( &lt;code&gt;-&amp;gt;&lt;/code&gt; ) представлена ​​аналогично операторам, за исключением того, что они всегда являются частью списка, ее левая часть представляет собой список аргументов, а правая часть - выражение.</target>
        </trans-unit>
        <trans-unit id="a6289423275f2a3ff2ff61d789c2121d3f39f1f8" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The &lt;code&gt;-&amp;gt;&lt;/code&gt; may appear one or more times between one of the following terminators: &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; or &lt;code&gt;(&lt;/code&gt;/&lt;code&gt;)&lt;/code&gt;. When &lt;code&gt;-&amp;gt;&lt;/code&gt; is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax.</source>
          <target state="translated">Стрелка слева направо ( &lt;code&gt;-&amp;gt;&lt;/code&gt; ) используется для установления связи между левым и правым, обычно называемой предложениями. Левая часть может иметь ноль, один или несколько аргументов; правая часть - это ноль, одно или несколько выражений, разделенных новой строкой. Знак &lt;code&gt;-&amp;gt;&lt;/code&gt; может появляться один или несколько раз между одним из следующих разделителей: &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; или &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt; . Когда используется &lt;code&gt;-&amp;gt;&lt;/code&gt; , между этими терминаторами разрешены только другие предложения. Смешанные предложения и регулярные выражения являются недопустимым синтаксисом.</target>
        </trans-unit>
        <trans-unit id="62dfa2cc28c3ba61b288f1d13e4cdc1ed0d38af0" translate="yes" xml:space="preserve">
          <source>The left-hand side supports any expression you would use on the left-hand side of a match:</source>
          <target state="translated">Левая сторона поддерживает любое выражение,которое вы бы использовали на левой стороне матча:</target>
        </trans-unit>
        <trans-unit id="452a67adaa49211fbae18840ab0e8f40710191cd" translate="yes" xml:space="preserve">
          <source>The length of the match is equal to the &lt;code&gt;unit&lt;/code&gt; (a number of bits) times the &lt;code&gt;size&lt;/code&gt; (the number of repeated segments of length &lt;code&gt;unit&lt;/code&gt;).</source>
          <target state="translated">Длина совпадения равна &lt;code&gt;unit&lt;/code&gt; (количество битов), умноженной на &lt;code&gt;size&lt;/code&gt; (количество повторяющихся сегментов &lt;code&gt;unit&lt;/code&gt; длины ).</target>
        </trans-unit>
        <trans-unit id="9b58150e587a8ab776f8c034fd8c13d895af6209" translate="yes" xml:space="preserve">
          <source>The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below).</source>
          <target state="translated">Уровень параллельности и разрешенное время выполнения задач можно контролировать с помощью опций (см.раздел &quot;Опции&quot; ниже).</target>
        </trans-unit>
        <trans-unit id="0f521fe02fee98ba137b8a2f629c9607b50efc70" translate="yes" xml:space="preserve">
          <source>The limit in the given &lt;code&gt;inspect_opts&lt;/code&gt; is respected and when reached this function stops processing and outputs &lt;code&gt;&quot;...&quot;&lt;/code&gt; instead.</source>
          <target state="translated">Предел в заданном &lt;code&gt;inspect_opts&lt;/code&gt; соблюдается, и по достижении эта функция прекращает обработку и вместо этого выводит &lt;code&gt;&quot;...&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1945f9bf3a795845e8993a19f7a9dfe86f17eea" translate="yes" xml:space="preserve">
          <source>The line above makes &lt;code&gt;:kv&lt;/code&gt; available as a dependency inside &lt;code&gt;:kv_server&lt;/code&gt; and automatically starts the &lt;code&gt;:kv&lt;/code&gt; application before the server starts.</source>
          <target state="translated">Строка выше делает &lt;code&gt;:kv&lt;/code&gt; доступным как зависимость внутри &lt;code&gt;:kv_server&lt;/code&gt; и автоматически запускает приложение &lt;code&gt;:kv&lt;/code&gt; перед запуском сервера.</target>
        </trans-unit>
        <trans-unit id="6f3150330fa7863de05e8e4f528741a7ca7bb476" translate="yes" xml:space="preserve">
          <source>The line where the module is defined and its file &lt;strong&gt;must&lt;/strong&gt; be passed as options.</source>
          <target state="translated">Строка, в которой определяется модуль, и его файл &lt;strong&gt;должны&lt;/strong&gt; быть переданы в качестве параметров.</target>
        </trans-unit>
        <trans-unit id="65e5d401ccb2b8279fcac802ea4250628d92a6f3" translate="yes" xml:space="preserve">
          <source>The list of &lt;code&gt;entries&lt;/code&gt; is a non-empty list of two-element tuples where the first element is the PID and the second element is the value associated to the PID. If there are no entries for the given key, the callback is never invoked.</source>
          <target state="translated">Список &lt;code&gt;entries&lt;/code&gt; - это непустой список двухэлементных кортежей, где первый элемент - это PID, а второй элемент - это значение, связанное с PID. Если для данного ключа нет записей, обратный вызов никогда не вызывается.</target>
        </trans-unit>
        <trans-unit id="d8d60e505b52f11e3ed1a46b8da9d55ffe759f2d" translate="yes" xml:space="preserve">
          <source>The list of callers of the current process can be retrieved from the Process dictionary with &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt;. This will return either &lt;code&gt;nil&lt;/code&gt; or a list &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; with at least one entry Where &lt;code&gt;pid_n&lt;/code&gt; is the PID that called the current process, &lt;code&gt;pid2&lt;/code&gt; called &lt;code&gt;pid_n&lt;/code&gt;, and &lt;code&gt;pid2&lt;/code&gt; was called by &lt;code&gt;pid1&lt;/code&gt;.</source>
          <target state="translated">Список вызывающих текущего процесса можно получить из словаря процесса с помощью &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt; . Это вернет либо &lt;code&gt;nil&lt;/code&gt; , либо список &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; по крайней мере с одной записью, где &lt;code&gt;pid_n&lt;/code&gt; - это PID, который вызвал текущий процесс, &lt;code&gt;pid2&lt;/code&gt; вызвал &lt;code&gt;pid_n&lt;/code&gt; , а &lt;code&gt;pid2&lt;/code&gt; был вызван &lt;code&gt;pid1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2470ea39e6ace181c558514355d2df667d90f1fa" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="translated">Список документов сворачивается &amp;laquo;справа&amp;raquo;; в этом эта функция аналогична &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#foldr/3&quot;&gt; &lt;code&gt;List.foldr/3&lt;/code&gt; &lt;/a&gt; , за исключением того, что она не ожидает начального аккумулятора и использует последний элемент &lt;code&gt;docs&lt;/code&gt; в качестве начального аккумулятора.</target>
        </trans-unit>
        <trans-unit id="6ed6bd036ce9220742f24381556f3269068288d9" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;list#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="translated">Список документов сворачивается &amp;laquo;справа&amp;raquo;; в этом эта функция аналогична &lt;a href=&quot;list#foldr/3&quot;&gt; &lt;code&gt;List.foldr/3&lt;/code&gt; &lt;/a&gt; , за исключением того, что она не ожидает начального аккумулятора и использует последний элемент &lt;code&gt;docs&lt;/code&gt; в качестве начального аккумулятора.</target>
        </trans-unit>
        <trans-unit id="55a959d98d885f3a529aa834328d65182098caeb" translate="yes" xml:space="preserve">
          <source>The local copy is stored in your &lt;code&gt;MIX_HOME&lt;/code&gt; (defaults to &lt;code&gt;~/.mix&lt;/code&gt;). This version of Rebar will be used as required by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Compile.html&quot;&gt;&lt;code&gt;mix deps.compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Локальная копия хранится в вашем &lt;code&gt;MIX_HOME&lt;/code&gt; (по умолчанию &lt;code&gt;~/.mix&lt;/code&gt; ). Эта версия Rebar будет использоваться в соответствии с требованиями &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Compile.html&quot;&gt; &lt;code&gt;mix deps.compile&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c160860031d2eb83a58036161c7480f1f6e09fc" translate="yes" xml:space="preserve">
          <source>The lock is sent via &lt;code&gt;opts[:lock]&lt;/code&gt; but it may not always be available. In such cases, if the SCM requires a lock, it must return &lt;code&gt;:mismatch&lt;/code&gt;, otherwise simply &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">Блокировка отправляется через &lt;code&gt;opts[:lock]&lt;/code&gt; но не всегда доступна. В таких случаях, если SCM требует блокировки, он должен вернуть &lt;code&gt;:mismatch&lt;/code&gt; , иначе просто &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bae6744658312a20896e781b3c9940470c438e50" translate="yes" xml:space="preserve">
          <source>The low-level API for prying sessions and setting up breakpoints.</source>
          <target state="translated">Низкоуровневый API для переноса сессий и установки точек останова.</target>
        </trans-unit>
        <trans-unit id="b1a2ec347d3bbd914ac71de3130a3ca5d8e9ba73" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~d&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date sigils.</source>
          <target state="translated">Вариант &lt;code&gt;~d&lt;/code&gt; нижнем регистре не существует, так как интерполяция и escape-символы не используются для сигилов даты.</target>
        </trans-unit>
        <trans-unit id="243770f815841be461d24f785d91a84dc8f25160" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~n&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">Вариант &lt;code&gt;~n&lt;/code&gt; нижнем регистре не существует, так как символы интерполяции и escape-символы не используются для сигилов даты и времени.</target>
        </trans-unit>
        <trans-unit id="61c4050f1d545dfb95cf8194b35027ab14a85e08" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~t&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for time sigils.</source>
          <target state="translated">Вариант &lt;code&gt;~t&lt;/code&gt; нижнем регистре не существует, так как символы интерполяции и escape-символы не используются для временных сигил.</target>
        </trans-unit>
        <trans-unit id="32388371298b5aa74ba2be98958ecd5080c981d1" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~u&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">Вариант &lt;code&gt;~u&lt;/code&gt; нижнем регистре не существует, так как интерполяция и escape-символы не используются для сигилов даты и времени.</target>
        </trans-unit>
        <trans-unit id="94a5c210052abe863a1fe8f7104b55665bd29e19" translate="yes" xml:space="preserve">
          <source>The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See &lt;a href=&quot;#t:input/0&quot;&gt;&lt;code&gt;input/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#t:output/0&quot;&gt;&lt;code&gt;output/0&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Макрос получает представление кода, указанного в качестве аргумента, а функция получает результат кода, заданного в качестве аргумента. Макрос должен возвращать расширенный набор представления кода. См. &lt;a href=&quot;#t:input/0&quot;&gt; &lt;code&gt;input/0&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#t:output/0&quot;&gt; &lt;code&gt;output/0&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7ef1cd736ece10b4c740827fd1cda368fe6a8305" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#notice/2&quot;&gt;&lt;code&gt;notice/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warning/2&quot;&gt;&lt;code&gt;warning/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#critical/2&quot;&gt;&lt;code&gt;critical/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#alert/2&quot;&gt;&lt;code&gt;alert/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#emergency/2&quot;&gt;&lt;code&gt;emergency/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">Макросы &lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#notice/2&quot;&gt; &lt;code&gt;notice/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#warning/2&quot;&gt; &lt;code&gt;warning/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#error/2&quot;&gt; &lt;code&gt;error/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#critical/2&quot;&gt; &lt;code&gt;critical/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#alert/2&quot;&gt; &lt;code&gt;alert/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#emergency/2&quot;&gt; &lt;code&gt;emergency/2&lt;/code&gt; &lt;/a&gt; предпочтительнее этого макроса, поскольку они могут автоматически исключить вызов &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; целом на время компиляции, если это необходимо (см. документацию к модулю &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8467f6194459766a9d70ef8dad6012fd6200c681" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn/2&quot;&gt;&lt;code&gt;warn/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">Макросы &lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#warn/2&quot;&gt; &lt;code&gt;warn/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#error/2&quot;&gt; &lt;code&gt;error/2&lt;/code&gt; &lt;/a&gt; предпочтительнее этого макроса, так как они могут автоматически исключить вызов &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; в&lt;/a&gt; целом во время компиляции, если это необходимо (см. Документацию для модуля &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="824174ce5b570e4d9805c05f1124ce5c26a319b1" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#defrecord/3&quot;&gt;&lt;code&gt;defrecord/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defrecordp/3&quot;&gt;&lt;code&gt;defrecordp/3&lt;/code&gt;&lt;/a&gt; can be used to create records while &lt;a href=&quot;#extract/2&quot;&gt;&lt;code&gt;extract/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extract_all/1&quot;&gt;&lt;code&gt;extract_all/1&lt;/code&gt;&lt;/a&gt; can be used to extract records from Erlang files.</source>
          <target state="translated">Макросы &lt;a href=&quot;#defrecord/3&quot;&gt; &lt;code&gt;defrecord/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#defrecordp/3&quot;&gt; &lt;code&gt;defrecordp/3&lt;/code&gt; &lt;/a&gt; может быть использован для создания записей в то время как &lt;a href=&quot;#extract/2&quot;&gt; &lt;code&gt;extract/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extract_all/1&quot;&gt; &lt;code&gt;extract_all/1&lt;/code&gt; &lt;/a&gt; могут быть использованы для извлечения записей из Erlang файлов.</target>
        </trans-unit>
        <trans-unit id="dd1487033e0043998b4a55854f41e5aff164999a" translate="yes" xml:space="preserve">
          <source>The macros in this module come in two flavors: named or operators. For example:</source>
          <target state="translated">Макросы в этом модуле имеют два вкуса:по имени или по операторам.Например:</target>
        </trans-unit>
        <trans-unit id="9f2bf18c746e61e235b955af779aaf9aaea45f54" translate="yes" xml:space="preserve">
          <source>The main entry point to compile source files.</source>
          <target state="translated">Основная точка входа для компиляции исходных файлов.</target>
        </trans-unit>
        <trans-unit id="38f9dca5177d03726cc73b1076b1d78de398e382" translate="yes" xml:space="preserve">
          <source>The main function in this module is &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;, which parses a list of command line options and arguments into a keyword list:</source>
          <target state="translated">Основная функция в этом модуле - &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; , которая анализирует список параметров и аргументов командной строки в список ключевых слов:</target>
        </trans-unit>
        <trans-unit id="a06fbfa6c4b60070753ff93ddfbef19aade6baec" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="translated">Большинство функций ожидают chardata. Если указан другой тип, функции будут преобразовывать эти типы в строку через протокол &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; (как показано в спецификациях типов). Дополнительные сведения о chardata см. В разделе &amp;laquo;Данные ввода-вывода&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="852a05b0450dc656348efc6729f9e523cd593860" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="translated">Большинство функций ожидают chardata. Если задан другой тип, функции будут преобразовывать эти типы в строку через протокол &lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; (как показано в спецификациях типов). Дополнительные сведения о chardata см. В разделе &amp;laquo;Данные ввода-вывода&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="99c734179f1102a008e516a50860fb644aef0bb8" translate="yes" xml:space="preserve">
          <source>The majority of the functions in the &lt;code&gt;File&lt;/code&gt; module expect paths as arguments. Most commonly, those paths will be regular binaries. The &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; module provides facilities for working with such paths:</source>
          <target state="translated">Большинство функций в модуле &lt;code&gt;File&lt;/code&gt; ожидают пути в качестве аргументов. Чаще всего это обычные двоичные файлы. Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; предоставляет возможности для работы с такими путями:</target>
        </trans-unit>
        <trans-unit id="14d50e0537a311e097eac9e5b800ff509846d646" translate="yes" xml:space="preserve">
          <source>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like &lt;a href=&quot;#wildcard/2&quot;&gt;&lt;code&gt;wildcard/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;expand/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Большинство функций в этом модуле не взаимодействуют с файловой системой, за исключением нескольких функций, которые требуют этого (например, &lt;a href=&quot;#wildcard/2&quot;&gt; &lt;code&gt;wildcard/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#expand/1&quot;&gt; &lt;code&gt;expand/1&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="53cb17dd3de6e34ca6338dd415345dba7ba819e3" translate="yes" xml:space="preserve">
          <source>The majority of times we spawn processes in Elixir, we spawn them as linked processes. Before we show an example with &lt;code&gt;spawn_link/1&lt;/code&gt;, let&amp;rsquo;s see what happens when a process started with &lt;code&gt;spawn/1&lt;/code&gt; fails:</source>
          <target state="translated">В большинстве случаев мы порождаем процессы в Elixir, мы порождаем их как связанные процессы. Прежде чем мы покажем пример с &lt;code&gt;spawn_link/1&lt;/code&gt; , давайте посмотрим, что происходит, когда процесс, запущенный с &lt;code&gt;spawn/1&lt;/code&gt; , терпит неудачу:</target>
        </trans-unit>
        <trans-unit id="dffb7c1527c61bbb5104fbd6ca60eac0e55a8d98" translate="yes" xml:space="preserve">
          <source>The map above defines a child with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="translated">На карте выше определен дочерний элемент с &lt;code&gt;:id&lt;/code&gt; для &lt;code&gt;Stack&lt;/code&gt; , который запускается путем вызова &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10d66e531d4200425ddeb9a59e3170249b7e1aed" translate="yes" xml:space="preserve">
          <source>The map above defines a supervisor with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="translated">На карте выше определяет руководитель с &lt;code&gt;:id&lt;/code&gt; из &lt;code&gt;Stack&lt;/code&gt; , который запускается вызовом &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bb3eb4a71679f85fc1f23e76313b0ee7d67d6ad" translate="yes" xml:space="preserve">
          <source>The map contains the following keys:</source>
          <target state="translated">Карта содержит следующие клавиши:</target>
        </trans-unit>
        <trans-unit id="89c1e1079a87250a9082cabf85f0e2b686337098" translate="yes" xml:space="preserve">
          <source>The map must be a function. The function receives an integer representing the code point of the character it wants to unescape. Here is the default mapping function implemented by Elixir:</source>
          <target state="translated">Карта должна быть функцией.Функция получает целое число,представляющее кодовую точку символа,который она хочет распечатать.Вот функция отображения по умолчанию,реализованная Elixir:</target>
        </trans-unit>
        <trans-unit id="23154a42b58e45ef674deb33492b4a7b042bd7a7" translate="yes" xml:space="preserve">
          <source>The mapping between code and data (the underlying AST) is what allows Elixir to implement &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and others in Elixir itself. Elixir makes the constructs available for building the language accessible to developers who want to extend the language to new domains.</source>
          <target state="translated">Сопоставление кода и данных (базовый AST) - это то, что позволяет Elixir реализовать &lt;code&gt;defmodule&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; и другие в самом Elixir. Elixir делает конструкции доступными для построения языка доступными разработчикам, которые хотят расширить язык до новых областей.</target>
        </trans-unit>
        <trans-unit id="a6991efb82e0a459b03a5b7c2a6877fbcec33018" translate="yes" xml:space="preserve">
          <source>The marker is what follows exactly after &lt;code&gt;&amp;lt;%&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; has an empty marker, but &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; has &lt;code&gt;&quot;=&quot;&lt;/code&gt; as marker. The allowed markers so far are:</source>
          <target state="translated">Маркер - это то, что следует точно после &lt;code&gt;&amp;lt;%&lt;/code&gt; . Например, &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; имеет пустой маркер, но &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; имеет &lt;code&gt;&quot;=&quot;&lt;/code&gt; в качестве маркера. На данный момент разрешенные маркеры:</target>
        </trans-unit>
        <trans-unit id="cbb00df7fd3fe762840c451309786ffe89ed55ff" translate="yes" xml:space="preserve">
          <source>The match operator</source>
          <target state="translated">Оператор матча</target>
        </trans-unit>
        <trans-unit id="f8693773fd6ff53ba9de6646d15390dd067bbab4" translate="yes" xml:space="preserve">
          <source>The match operator is not only used to match against simple values, but it is also useful for destructuring more complex data types. For example, we can pattern match on tuples:</source>
          <target state="translated">Оператор сравнения используется не только для сравнения с простыми значениями,но и для уничтожения более сложных типов данных.Например,можно выполнить совпадение по шаблонам на кортежах:</target>
        </trans-unit>
        <trans-unit id="a9ee80ea2fa936cf7002a1188db1c8b023133c11" translate="yes" xml:space="preserve">
          <source>The math module</source>
          <target state="translated">Модуль математики</target>
        </trans-unit>
        <trans-unit id="a810ba47e0afb01caa643d3b27868322a40ed5d7" translate="yes" xml:space="preserve">
          <source>The maximum atom size is of 255 Unicode code points.</source>
          <target state="translated">Максимальный размер атома составляет 255 единиц юникодного кода.</target>
        </trans-unit>
        <trans-unit id="da10e2a3fe264c784b7e0fdd60cc0177cfc3d0fb" translate="yes" xml:space="preserve">
          <source>The message is formatted and displayed in the same format as used by Elixir's CLI.</source>
          <target state="translated">Сообщение форматируется и отображается в том же формате,который используется в CLI Elixir.</target>
        </trans-unit>
        <trans-unit id="ae60ef8d035658452d72bdc4024fef29dc953c1c" translate="yes" xml:space="preserve">
          <source>The message is not sent immediately. Therefore, &lt;code&gt;dest&lt;/code&gt; can receive other messages in-between even when &lt;code&gt;time&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Сообщение отправляется не сразу. Следовательно, &lt;code&gt;dest&lt;/code&gt; может получать другие промежуточные сообщения, даже если &lt;code&gt;time&lt;/code&gt; равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1852e95a6b1b63c415d7d9c305bc3d2ad89962d3" translate="yes" xml:space="preserve">
          <source>The messages supported by ports and their counterpart function APIs are listed below:</source>
          <target state="translated">Ниже перечислены сообщения,поддерживаемые портами и API их аналогов:</target>
        </trans-unit>
        <trans-unit id="01f467e93a20e666a1a71239d36e1b21c0c18df1" translate="yes" xml:space="preserve">
          <source>The metadata in Elixir AST is a keyword list of values. Any key can be used and different parts of the compiler may use different keys. For example, the AST received by a macro will always include the &lt;code&gt;:line&lt;/code&gt; annotation, while the AST emitted by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt; will only have the &lt;code&gt;:line&lt;/code&gt; annotation if the &lt;code&gt;:line&lt;/code&gt; option is provided.</source>
          <target state="translated">Метаданные в Elixir AST - это список значений ключевых слов. Можно использовать любой ключ, и разные части компилятора могут использовать разные ключи. Например, AST , полученная макро всегда будет включать в себя &lt;code&gt;:line&lt;/code&gt; аннотации, в то время как AST излучаемая &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; &lt;/a&gt; будет иметь только &lt;code&gt;:line&lt;/code&gt; аннотации , если &lt;code&gt;:line&lt;/code&gt; опция предусмотрена.</target>
        </trans-unit>
        <trans-unit id="d94502ad54e0168b2a0dd7bb477e4117c14a5e51" translate="yes" xml:space="preserve">
          <source>The minimum example of a &lt;code&gt;test_helper.exs&lt;/code&gt; file would be:</source>
          <target state="translated">Минимальный пример файла &lt;code&gt;test_helper.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36e330d350d67652867a9b1fa816fde5c72c65e0" translate="yes" xml:space="preserve">
          <source>The modifiers available when creating a Regex are:</source>
          <target state="translated">Модификаторы доступны при создании Регекса:</target>
        </trans-unit>
        <trans-unit id="554bd8892a2a2f959aaf3286fab34f7cb4eab543" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="translated">Модуль &lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; также включает в себя несколько &lt;a href=&quot;bitwise#guards&quot;&gt;побитовых операций Erlang в качестве защиты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6202288899e34ec4c71c794b46b5bcdf21e2a59" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="translated">Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; также включает в себя несколько &lt;a href=&quot;bitwise#guards&quot;&gt;побитовых операций Erlang в качестве защиты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6173752a29eeb047f2dfafc51f6c1560f53e16b" translate="yes" xml:space="preserve">
          <source>The module containing the custom sigil must be imported before the sigil syntax can be used.</source>
          <target state="translated">Модуль,содержащий пользовательскую подпись,должен быть импортирован перед использованием синтаксиса подписей.</target>
        </trans-unit>
        <trans-unit id="11a697026fe35980b1003f6f8535e1c516332e63" translate="yes" xml:space="preserve">
          <source>The module documentation above contains documentation and examples for the supported &lt;code&gt;name&lt;/code&gt; values, summarized below:</source>
          <target state="translated">Приведенная выше документация модуля содержит документацию и примеры для поддерживаемых значений &lt;code&gt;name&lt;/code&gt; , кратко изложенные ниже:</target>
        </trans-unit>
        <trans-unit id="6052f32cd5500caeb9f54ee4b03cfe6002f80902" translate="yes" xml:space="preserve">
          <source>The module where the server callbacks are implemented, in this case &lt;code&gt;__MODULE__&lt;/code&gt; (meaning the current module)</source>
          <target state="translated">Модуль, в котором реализованы обратные вызовы сервера, в данном случае &lt;code&gt;__MODULE__&lt;/code&gt; (имеется в виду текущий модуль)</target>
        </trans-unit>
        <trans-unit id="5d69468bc82e2cdb38bbc6e03284931c1987f717" translate="yes" xml:space="preserve">
          <source>The modules &lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt;&lt;code&gt;ets&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt;&lt;code&gt;dets&lt;/code&gt;&lt;/a&gt; handle storage of large data structures in memory or on disk respectively.</source>
          <target state="translated">Модули &lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt; &lt;code&gt;ets&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt; &lt;code&gt;dets&lt;/code&gt; &lt;/a&gt; обрабатывать хранения больших структур данных в памяти или на диске соответственно.</target>
        </trans-unit>
        <trans-unit id="aad5655a8df039c1d174539db815749409e4e0c7" translate="yes" xml:space="preserve">
          <source>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</source>
          <target state="translated">Модули,определенные в файле,не удаляются;вызов этой функции только удаляет их из списка,позволяя снова потребовать их.</target>
        </trans-unit>
        <trans-unit id="ea2b347a7bc6a5535356bac28ba3f2b363ebc47b" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Наиболее распространенные ошибки Erlang будут преобразованы в их аналог в Elixir. Те, которых нет, будут преобразованы в более общий &lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a0e8b772b81f68e7e9d79ec05dc5213643ac8a48" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Наиболее распространенные ошибки Erlang будут преобразованы в их аналог в Elixir. Те, которых нет, будут преобразованы в более общий &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cdce2f67135b244ca8a17c4bfd6e3995d0cb745a" translate="yes" xml:space="preserve">
          <source>The most common sigil in Elixir is &lt;code&gt;~r&lt;/code&gt;, which is used to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;:</source>
          <target state="translated">Самый распространенный символ в Elixir - &lt;code&gt;~r&lt;/code&gt; , который используется для создания &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;регулярных выражений&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5a6e4e1aba3cc5896f4b550cdd6a497deff0ddb9" translate="yes" xml:space="preserve">
          <source>The most common tasks are &lt;code&gt;mix deps.get&lt;/code&gt; and &lt;code&gt;mix deps.update&lt;/code&gt;. Once fetched, dependencies are automatically compiled for you. You can read more about deps by typing &lt;code&gt;mix help deps&lt;/code&gt;, and in the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;documentation for the Mix.Tasks.Deps module&lt;/a&gt;.</source>
          <target state="translated">Наиболее частыми задачами являются &lt;code&gt;mix deps.get&lt;/code&gt; и &lt;code&gt;mix deps.update&lt;/code&gt; . После получения зависимости автоматически компилируются для вас. Вы можете узнать больше о deps, набрав &lt;code&gt;mix help deps&lt;/code&gt; или в &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;документации к модулю Mix.Tasks.Deps&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b9cc7f30985b20ae7924700825d31d820820e24" translate="yes" xml:space="preserve">
          <source>The most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:</source>
          <target state="translated">Наиболее распространенным случаем использования heredoc sigils является написание документации.Например,запись экранирующих символов в документации вскоре может привести к ошибкам из-за необходимости двойного ввода некоторых символов:</target>
        </trans-unit>
        <trans-unit id="9a837abf2f926d7bd68d291aea16431f4ec63587" translate="yes" xml:space="preserve">
          <source>The most common use of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt; is to define application configuration so that &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt;&lt;code&gt;Application.get_env/3&lt;/code&gt;&lt;/a&gt; and other &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; functions can be used to retrieve or further change them.</source>
          <target state="translated">Чаще всего &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt; используется для определения конфигурации приложения, чтобы можно было использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt; &lt;code&gt;Application.get_env/3&lt;/code&gt; &lt;/a&gt; и другие функции &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; для их получения или дальнейшего изменения.</target>
        </trans-unit>
        <trans-unit id="b3b38c4c7bf2ec83c1026ecdaac1402a38fdf641" translate="yes" xml:space="preserve">
          <source>The most common way to raise an exception is via &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Самый распространенный способ вызвать исключение - через &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="db6ae63cdeae86d32f305032ae11a7867f19ace7" translate="yes" xml:space="preserve">
          <source>The most commonly used keys are:</source>
          <target state="translated">Наиболее часто используемые ключи:</target>
        </trans-unit>
        <trans-unit id="ec63aea88c70e103879cfde37537cf2e076faa36" translate="yes" xml:space="preserve">
          <source>The name of the generated macros will be &lt;code&gt;name&lt;/code&gt; (which has to be an atom). &lt;code&gt;tag&lt;/code&gt; is also an atom and is used as the &quot;tag&quot; for the record (i.e., the first element of the record tuple); by default (if &lt;code&gt;nil&lt;/code&gt;), it's the same as &lt;code&gt;name&lt;/code&gt;. &lt;code&gt;kv&lt;/code&gt; is a keyword list of &lt;code&gt;name: default_value&lt;/code&gt; fields for the new record.</source>
          <target state="translated">Имя сгенерированного макроса будет &lt;code&gt;name&lt;/code&gt; (которое должно быть атомом). &lt;code&gt;tag&lt;/code&gt; также является атомом и используется как &amp;laquo;тег&amp;raquo; для записи (т. е. первый элемент кортежа записи); по умолчанию (если &lt;code&gt;nil&lt;/code&gt; ) совпадает с &lt;code&gt;name&lt;/code&gt; . &lt;code&gt;kv&lt;/code&gt; - это список ключевых слов, &lt;code&gt;name: default_value&lt;/code&gt; полей name: default_value для новой записи.</target>
        </trans-unit>
        <trans-unit id="c90ebcf1b0655ac03fd3dd0d53f96acb011b2609" translate="yes" xml:space="preserve">
          <source>The name of the service is &lt;code&gt;demo_demo&lt;/code&gt; because the name is built by concatenating the node name with the release name. Since Elixir automatically uses the same name for both, the service will be referenced as &lt;code&gt;demo_demo&lt;/code&gt;.</source>
          <target state="translated">Имя службы - &lt;code&gt;demo_demo&lt;/code&gt; , потому что имя создается путем объединения имени узла с именем выпуска. Поскольку Elixir автоматически использует одно и то же имя для обоих, служба будет &lt;code&gt;demo_demo&lt;/code&gt; как demo_demo .</target>
        </trans-unit>
        <trans-unit id="090750250669854ad5f2a1b18b4694400b5de691" translate="yes" xml:space="preserve">
          <source>The named sequences are represented by atoms.</source>
          <target state="translated">Названные последовательности представлены атомами.</target>
        </trans-unit>
        <trans-unit id="84dca7c82c4adab78e96e4275650ccd595bf63f7" translate="yes" xml:space="preserve">
          <source>The need for monitoring</source>
          <target state="translated">Необходимость мониторинга</target>
        </trans-unit>
        <trans-unit id="11f3fb45a34842b8d6e2b1b6e9657cdd42649db8" translate="yes" xml:space="preserve">
          <source>The new child specs outlined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; (v1.5)</source>
          <target state="translated">Новые дочерние спецификации, описанные в &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; (v1.5)</target>
        </trans-unit>
        <trans-unit id="5d5693a336fde96fc9f4a9263d265529c9d65820" translate="yes" xml:space="preserve">
          <source>The next two functions, &lt;code&gt;lookup/2&lt;/code&gt; and &lt;code&gt;create/2&lt;/code&gt;, are responsible for sending these requests to the server. In this case, we have used &lt;code&gt;{:lookup, name}&lt;/code&gt; and &lt;code&gt;{:create, name}&lt;/code&gt; respectively. Requests are often specified as tuples, like this, in order to provide more than one &amp;ldquo;argument&amp;rdquo; in that first argument slot. It&amp;rsquo;s common to specify the action being requested as the first element of a tuple, and arguments for that action in the remaining elements. Note that the requests must match the first argument to &lt;code&gt;handle_call/3&lt;/code&gt; or &lt;code&gt;handle_cast/2&lt;/code&gt;.</source>
          <target state="translated">Следующие две функции, &lt;code&gt;lookup/2&lt;/code&gt; и &lt;code&gt;create/2&lt;/code&gt; , отвечают за отправку этих запросов на сервер. В этом случае мы использовали &lt;code&gt;{:lookup, name}&lt;/code&gt; и &lt;code&gt;{:create, name}&lt;/code&gt; соответственно. Запросы часто задаются в виде кортежей, как здесь, чтобы предоставить более одного &amp;laquo;аргумента&amp;raquo; в этом первом слоте аргумента. Обычно запрашиваемое действие указывается как первый элемент кортежа, а аргументы для этого действия - в остальных элементах. Обратите внимание, что запросы должны соответствовать первому аргументу &lt;code&gt;handle_call/3&lt;/code&gt; или &lt;code&gt;handle_cast/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="987bf5fe1a29a589006df7a1c4246dedd1188aa8" translate="yes" xml:space="preserve">
          <source>The node list defaults to a list of all connected nodes.</source>
          <target state="translated">По умолчанию список узлов содержит список всех подключенных узлов.</target>
        </trans-unit>
        <trans-unit id="1e4f23ef668efde946b979656f1273bb8fc04978" translate="yes" xml:space="preserve">
          <source>The notation to represent the union of types is the pipe &lt;code&gt;|&lt;/code&gt;. For example, the typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; creates a type &lt;code&gt;type&lt;/code&gt; that can be either an &lt;code&gt;atom&lt;/code&gt;, a &lt;code&gt;pid&lt;/code&gt;, or a &lt;code&gt;tuple&lt;/code&gt;. This is usually called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum type&lt;/a&gt; in other languages</source>
          <target state="translated">Обозначение для представления объединения типов - труба &lt;code&gt;|&lt;/code&gt; , Например, typepec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; создает тип &lt;code&gt;type&lt;/code&gt; который может быть &lt;code&gt;atom&lt;/code&gt; , &lt;code&gt;pid&lt;/code&gt; или &lt;code&gt;tuple&lt;/code&gt; . В других языках это обычно называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;типом суммы.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ab75e9fdd50914ae4096566ba3ee4815b968a2a" translate="yes" xml:space="preserve">
          <source>The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.</source>
          <target state="translated">Количество аргументов в каждом пункте анонимной функции должно быть одинаковым,в противном случае возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="58646d5d2a31b22e08348e0987be6fb1b1552f1b" translate="yes" xml:space="preserve">
          <source>The offset is capped to the length of the string. Returns a tuple with two elements.</source>
          <target state="translated">Смещение ограничивается длиной строки.Возвращает кортеж с двумя элементами.</target>
        </trans-unit>
        <trans-unit id="fc47b2c77b07a194ec3fbe01564888859692ecf9" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="translated">Единственная разница между &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; заключается в том, что &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; строг, когда дело доходит до сравнения целых чисел и чисел с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="7ac751725399e216969e58864613bb897ae9753a" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="translated">Единственная разница между &lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; заключается в том, что &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; строг, когда дело доходит до сравнения целых чисел и чисел с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="42fcb26dc86b08d995f11bae71b9989f2f7b728a" translate="yes" xml:space="preserve">
          <source>The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.</source>
          <target state="translated">Единственным исключением из вышеперечисленных гарантий совместимости являются экспериментальные функции,которые будут четко обозначены как таковые и не предоставляют никаких гарантий совместимости до тех пор,пока они не будут стабилизированы.</target>
        </trans-unit>
        <trans-unit id="7f057536218de2bcb4eee9345b4ec9df6b4b0d58" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is that &lt;code&gt;:skip&lt;/code&gt; is found in the &lt;code&gt;include&lt;/code&gt; filter, &lt;code&gt;:ok&lt;/code&gt; is returned regardless of whether the test was excluded or not.</source>
          <target state="translated">Единственным исключением из этого правила является то, что &lt;code&gt;:skip&lt;/code&gt; находится в фильтре &lt;code&gt;include&lt;/code&gt; ,: &lt;code&gt;:ok&lt;/code&gt; возвращается независимо от того, был ли тест исключен или нет.</target>
        </trans-unit>
        <trans-unit id="5b80c752c5e1cd83678df53e132bab989245bf95" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="translated">Единственная функция, которую необходимо реализовать, - это &lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; ,&lt;/a&gt; которая выполняет преобразование.</target>
        </trans-unit>
        <trans-unit id="3738a03df0b0292cd0fc541a62dccb969b8d4008" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt;, which does the conversion.</source>
          <target state="translated">Единственная функция, которую необходимо реализовать, - это &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; , которая выполняет преобразование.</target>
        </trans-unit>
        <trans-unit id="9818a90770672e6306fec6ad6c84e3f7b8114355" translate="yes" xml:space="preserve">
          <source>The only function that must be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="translated">Единственная функция, которая должна быть реализована, - это &lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; ,&lt;/a&gt; которая выполняет преобразование.</target>
        </trans-unit>
        <trans-unit id="ade81e07849e4708797e256e50ea8daa5d7c1c81" translate="yes" xml:space="preserve">
          <source>The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &lt;code&gt;&amp;amp;1&lt;/code&gt;, and that block expressions are not supported:</source>
          <target state="translated">Единственными ограничениями при создании анонимных функций является то, что должен присутствовать хотя бы один заполнитель, то есть он должен содержать как минимум &lt;code&gt;&amp;amp;1&lt;/code&gt; , и что выражения блока не поддерживаются:</target>
        </trans-unit>
        <trans-unit id="5bde5d825d53af6907621f0cb4672e1213049a4a" translate="yes" xml:space="preserve">
          <source>The operation is Unicode unsafe.</source>
          <target state="translated">Операция является небезопасной в Юникоде.</target>
        </trans-unit>
        <trans-unit id="820323122693cc928f8711400bb7374b1eb73417" translate="yes" xml:space="preserve">
          <source>The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="translated">Операция выполняется с двоичной плавающей запятой,без преобразования в десятичную.</target>
        </trans-unit>
        <trans-unit id="215bce352413475dfa0bf14c5c4c4836769feeb5" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="translated">Операторы, которые использует Elixir (например, &lt;code&gt;+&lt;/code&gt; ), могут быть определены любым модулем и использоваться вместо операторов, определенных Elixir, при условии, что они специально не импортированы из &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; (которое по умолчанию импортируется повсюду). Например:</target>
        </trans-unit>
        <trans-unit id="54a4338b50a933ea4de60119e3d7bc1ba6605f93" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="translated">Операторы, которые использует Elixir (например, &lt;code&gt;+&lt;/code&gt; ), могут быть определены любым модулем и использоваться вместо операторов, определенных Elixir, при условии, что они специально не импортируются из &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; (которое по умолчанию импортируется повсюду). Например:</target>
        </trans-unit>
        <trans-unit id="d083ec82ad103a49d0f2c21f621e7d904b855c2f" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="translated">Противоположностью преобразования строки в форму в кавычках является &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt; , который преобразует форму в кавычках в строковое / двоичное представление.</target>
        </trans-unit>
        <trans-unit id="35424357ca8ff1662dd08fa3f02518cdf95e9618" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="translated">Противоположностью преобразования строки в форму в кавычках является &lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt; , который преобразует форму в кавычках в строковое / двоичное представление.</target>
        </trans-unit>
        <trans-unit id="648996e2b78ff86fed25658983c86c1ca75fe83d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if deprecated calls exist.</source>
          <target state="translated">Параметр &lt;code&gt;--abort-if-any&lt;/code&gt; может использоваться для сбоя команды, если существуют устаревшие вызовы.</target>
        </trans-unit>
        <trans-unit id="719eb9d884931feb59017fec9c07b6c8395fab97" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if unreachable calls exist.</source>
          <target state="translated">Параметр &lt;code&gt;--abort-if-any&lt;/code&gt; может использоваться для сбоя команды при наличии недоступных вызовов.</target>
        </trans-unit>
        <trans-unit id="098132f317e5ef6b4049ca986c6beb4394ebb00e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; can be used with &lt;code&gt;@derive&lt;/code&gt; to specify which fields should and should not appear in the algebra document:</source>
          <target state="translated">Параметры &lt;code&gt;:only&lt;/code&gt; и &lt;code&gt;:except&lt;/code&gt; можно использовать с &lt;code&gt;@derive&lt;/code&gt; , чтобы указать, какие поля должны и не должны появляться в документе алгебры:</target>
        </trans-unit>
        <trans-unit id="1ca038b4953a725a1168758bdb05bf6957d97558" translate="yes" xml:space="preserve">
          <source>The options above have different properties. Both &lt;code&gt;:rpc&lt;/code&gt; and using a GenServer would serialize your requests on a single server, while tasks are effectively running asynchronously on the remote node, with the only serialization point being the spawning done by the supervisor.</source>
          <target state="translated">Параметры, указанные выше, имеют разные свойства. Оба &lt;code&gt;:rpc&lt;/code&gt; и использование GenServer будут сериализовать ваши запросы на одном сервере, в то время как задачи эффективно выполняются асинхронно на удаленном узле, причем единственной точкой сериализации является порождение, выполняемое супервизором.</target>
        </trans-unit>
        <trans-unit id="ec569bf070d46fd1797683900e4e0d1b42dd476e" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">Параметры также можно использовать для регистрации имени супервизора. Поддерживаемые значения описаны в разделе &amp;laquo;Регистрация имени&amp;raquo; в &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; модуля GenServer .</target>
        </trans-unit>
        <trans-unit id="dbbff1ba0f3f44314e39e2577a433b4751e9e390" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">Параметры также можно использовать для регистрации имени супервизора. Поддерживаемые значения описаны в разделе &amp;laquo;Регистрация имени&amp;raquo; в &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; модуля GenServer .</target>
        </trans-unit>
        <trans-unit id="b29b1695f7e1a72d94e875780fae402a43a9edf2" translate="yes" xml:space="preserve">
          <source>The options given in the child specification are documented in &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметры, указанные в дочерней спецификации, задокументированы в &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29149d2185c124051b475d7edf03c7125bd21d1c" translate="yes" xml:space="preserve">
          <source>The options not available are:</source>
          <target state="translated">Опции не доступны:</target>
        </trans-unit>
        <trans-unit id="4550dfac2891c5670508cc8032dc4a8ebcd0b681" translate="yes" xml:space="preserve">
          <source>The order they are returned is guaranteed to be sorted for proper dependency resolution. For example, if A depends on B, then B will listed before A.</source>
          <target state="translated">Порядок,в котором они возвращаются,гарантированно сортируется для правильного решения проблемы зависимости.Например,если A зависит от B,то B будет перечислена перед A.</target>
        </trans-unit>
        <trans-unit id="df79e73939e2f96120d0bd91e6ec1e8015418fd3" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;List&lt;/code&gt; can still be accessed within &lt;code&gt;Stats&lt;/code&gt; by the fully-qualified name &lt;code&gt;Elixir.List&lt;/code&gt;.</source>
          <target state="translated">К исходному &lt;code&gt;List&lt;/code&gt; все еще можно получить доступ в &lt;code&gt;Stats&lt;/code&gt; по полностью определенному имени &lt;code&gt;Elixir.List&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9ed5ea2ea656edc685034fbbcbc4be784892bd" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">Вывод можно украсить меткой, предоставив параметр &lt;code&gt;:label&lt;/code&gt; , чтобы легко отличить его от других &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt; . Этикетка будет напечатана перед проверяемым &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1668a9a07e94faf6e48dc573decf8c9122af382" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">Вывод можно украсить меткой, предоставив параметр &lt;code&gt;:label&lt;/code&gt; , чтобы легко отличить его от других &lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt; . Этикетка будет распечатана перед проверяемым &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f95d4e3d274d4d273eca22868ba00ceeec8b577f" translate="yes" xml:space="preserve">
          <source>The output of a macro</source>
          <target state="translated">Вывод макроса</target>
        </trans-unit>
        <trans-unit id="a8fcd6a77b8cc147c47e87ab2b38b5ca8be3e761" translate="yes" xml:space="preserve">
          <source>The path for local archives or escripts.</source>
          <target state="translated">Путь к местным архивам или эскриптам.</target>
        </trans-unit>
        <trans-unit id="abd015aedaea96a1467039e45829bb4bd7fad58c" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="translated">Перед добавлением путь расширяется с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; . Если этот путь не существует, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="e20a72d38a5ba46e84750b746640ae5729db0fc4" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Перед &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; путь расширяется с помощью Path.expand / 1 . Если путь не существует, эта функция возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e11342758ba07f1f86c835e6c8736ad536d0d920" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="translated">Перед добавлением путь расширяется с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; . Если этот путь не существует, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="313b3334ac8a23ead5e2d1a7fbc216efaabeea04" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="translated">Перед добавлением путь расширяется с помощью &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; . Если этот путь не существует, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="6d4310f7386df1164fbd8636a1690c05bd665337" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Перед &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; путь расширяется с помощью Path.expand / 1 . Если путь не существует, эта функция возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="838b6d73e0a2709d4a72a878f5b42de538ac3faf" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="translated">Перед добавлением путь расширяется с помощью &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; . Если этот путь не существует, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="e091aa0884c675c72ffb53e03abf27a7e2087b1e" translate="yes" xml:space="preserve">
          <source>The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion.</source>
          <target state="translated">Пути могут быть как чарлистом,так и строкой.Внутренне они работают как чарлисты,поэтому передача их как списков позволяет избежать лишних преобразований.</target>
        </trans-unit>
        <trans-unit id="668bfdcbbc88064352f1db03b861c85f89d02114" translate="yes" xml:space="preserve">
          <source>The pattern can be a module name, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; to count all calls to that module, a call without arity, such as &lt;code&gt;String.split&lt;/code&gt;, to count all calls to that function regardless of arity, or a call with arity, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt;, to count all calls to that exact module, function and arity.</source>
          <target state="translated">Шаблон может быть именем модуля, например &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; для подсчета всех вызовов этого модуля, вызовом без арности, например &lt;code&gt;String.split&lt;/code&gt; , для подсчета всех вызовов этой функции независимо от арности, или вызовом с арностью, например &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt; , чтобы подсчитать все вызовы этого точного модуля, функции и арности.</target>
        </trans-unit>
        <trans-unit id="e6382a5f5628ad82e683e23e1297c423e36e37f3" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matched patterns:</source>
          <target state="translated">Деталь также может быть списком строк,а замена может быть функцией,которая получает соответствующие детали:</target>
        </trans-unit>
        <trans-unit id="d3b17b28d01efecd387f4a558aef5d36e3e123e9" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matches:</source>
          <target state="translated">Шаблон также может быть списком строк,а замена может быть функцией получения совпадений:</target>
        </trans-unit>
        <trans-unit id="5c2c0506c6452af899d4d254cc14a3c00d8d753c" translate="yes" xml:space="preserve">
          <source>The pattern of keeping multiple applications in the same repository is known as &amp;ldquo;mono-repo&amp;rdquo;. Umbrella projects maximize this pattern by providing conveniences to compile, test and run multiple applications at once.</source>
          <target state="translated">Шаблон хранения нескольких приложений в одном репозитории известен как &amp;laquo;монорепозиторий&amp;raquo;. Проекты Umbrella максимально используют этот шаблон, предоставляя удобство для компиляции, тестирования и одновременного запуска нескольких приложений.</target>
        </trans-unit>
        <trans-unit id="b5336f2e10af99a0ddce0df1dbcc6953c1b3edca" translate="yes" xml:space="preserve">
          <source>The pin operator</source>
          <target state="translated">Пин-оператор</target>
        </trans-unit>
        <trans-unit id="8a16097e3345670b784d58d96c0daf29bd6b6363" translate="yes" xml:space="preserve">
          <source>The pipe operator</source>
          <target state="translated">Оператор трубопровода</target>
        </trans-unit>
        <trans-unit id="38ac69a732c3ec695582cbd0d48d9b6cb576dd15" translate="yes" xml:space="preserve">
          <source>The port can be opened through four main mechanisms.</source>
          <target state="translated">Порт можно открыть с помощью четырех основных механизмов.</target>
        </trans-unit>
        <trans-unit id="16f2f4882ba1e010d9493752e86925be5a3100f2" translate="yes" xml:space="preserve">
          <source>The power of Elixir&amp;rsquo;s extensibility comes when protocols and structs are used together.</source>
          <target state="translated">Сила расширяемости Elixir проявляется тогда, когда протоколы и структуры используются вместе.</target>
        </trans-unit>
        <trans-unit id="4539c5e2ab058d8719dac59fa3bb2dc3b38cff89" translate="yes" xml:space="preserve">
          <source>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</source>
          <target state="translated">Точность представляет собой количество цифр,которые должны использоваться при представлении микросекунд во внешнем формате.Если точность равна 0,это означает,что микросекунды должны быть пропущены.</target>
        </trans-unit>
        <trans-unit id="7b62847898ead6d12d866064984b0e4967caa7b6" translate="yes" xml:space="preserve">
          <source>The previous implementation used pipelines which made the logic straightforward to follow. However, now that we need to handle different error codes along the way, our server logic is nested inside many &lt;code&gt;case&lt;/code&gt; calls.</source>
          <target state="translated">В предыдущей реализации использовались конвейеры, что упрощало выполнение логики. Однако теперь, когда нам нужно обрабатывать разные коды ошибок по пути, логика нашего сервера вложена во многие вызовы &lt;code&gt;case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="199cc5f932aae17375561fec949a9c5a51d6d815" translate="yes" xml:space="preserve">
          <source>The problem with the code above is that, if the user supplies an invalid input, the error will be raised deep inside the library, which makes it confusing for users. Furthermore, when you don't validate the values at the boundary, the internals of your library are never quite sure which kind of values they are working with.</source>
          <target state="translated">Проблема с приведенным выше кодом заключается в том,что если пользователь предоставит неверный ввод,то ошибка будет поднята глубоко внутри библиотеки,что приводит пользователей в замешательство.Более того,когда вы не проверяете значения на границе,внутренние компоненты вашей библиотеки никогда не уверены,с какими именно значениями они работают.</target>
        </trans-unit>
        <trans-unit id="523d730771dc4a286c57cbc053f5c708e3c1f6ea" translate="yes" xml:space="preserve">
          <source>The process is terminated, if there's one. The child specification is kept unless the child is temporary.</source>
          <target state="translated">Процесс завершается,если он есть.Спецификация ребенка сохраняется,если только ребенок не является временным.</target>
        </trans-unit>
        <trans-unit id="b431d95d4131709473d087764c74e5d0bd63926d" translate="yes" xml:space="preserve">
          <source>The process of taking a list and &lt;em&gt;reducing&lt;/em&gt; it down to one value is known as a &lt;em&gt;reduce algorithm&lt;/em&gt; and is central to functional programming.</source>
          <target state="translated">Процесс &lt;em&gt;сокращения&lt;/em&gt; списка до одного значения известен как &lt;em&gt;алгоритм сокращения&lt;/em&gt; и является центральным в функциональном программировании.</target>
        </trans-unit>
        <trans-unit id="2fe675ae074650fc0dd2cca82261ebbd5e4a0afa" translate="yes" xml:space="preserve">
          <source>The process that sends the message does not block on &lt;code&gt;send/2&lt;/code&gt;, it puts the message in the recipient&amp;rsquo;s mailbox and continues. In particular, a process can send messages to itself.</source>
          <target state="translated">Процесс, отправляющий сообщение, не блокируется на &lt;code&gt;send/2&lt;/code&gt; , он помещает сообщение в почтовый ящик получателя и продолжает работу. В частности, процесс может отправлять сообщения самому себе.</target>
        </trans-unit>
        <trans-unit id="f279aa503c0e9c1a8851aaff4d4667435775ccbe" translate="yes" xml:space="preserve">
          <source>The project name is given in the &lt;code&gt;snake_case&lt;/code&gt; convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the &lt;a href=&quot;naming-conventions&quot;&gt;Naming Conventions&lt;/a&gt; document for more information.</source>
          <target state="translated">Имя проекта дается в соглашении &lt;code&gt;snake_case&lt;/code&gt; , где все буквы в нижнем регистре, а слова разделяются подчеркиванием. Это то же соглашение, которое используется для переменных, имен функций и атомов в Elixir. См. Документ &amp;laquo; &lt;a href=&quot;naming-conventions&quot;&gt;Соглашения&lt;/a&gt; об именах&amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ee55aee8e2dfe77fe02c53dba2352810a3c64b0a" translate="yes" xml:space="preserve">
          <source>The protocol definition would look like this:</source>
          <target state="translated">Определение протокола будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="bc915ce7d8df69961e91346b51ae1b4406aeabbb" translate="yes" xml:space="preserve">
          <source>The queue module</source>
          <target state="translated">Хвостовой модуль</target>
        </trans-unit>
        <trans-unit id="0af8f5620b697ca5fb92373212c500e4cb31990a" translate="yes" xml:space="preserve">
          <source>The rand module</source>
          <target state="translated">Модуль рандов</target>
        </trans-unit>
        <trans-unit id="ff54517df928691d964fdb5317bf18da5a260890" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Обоснование такого поведения состоит в том, чтобы лучше поддерживать библиотеки Erlang, которые могут возвращать текст в виде списков символов вместо строк Elixir. В Erlang списки символов - это способ обработки строк по умолчанию, а в Elixir - двоичные файлы. Одним из примеров таких функций является &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#loaded_applications/0&quot;&gt; &lt;code&gt;Application.loaded_applications/0&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="231da92c7cb81a49b248aa20d7528608e5de9c35" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. One example of such functions is &lt;a href=&quot;application#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Обоснование такого поведения состоит в том, чтобы лучше поддерживать библиотеки Erlang, которые могут возвращать текст в виде списков символов вместо строк Elixir. Одним из примеров таких функций является &lt;a href=&quot;application#loaded_applications/0&quot;&gt; &lt;code&gt;Application.loaded_applications/0&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="22c7e6cba80de4bce6770359917648b6c44cab9b" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="translated">Настоящая польза от протоколов проявляется в сочетании со структурами. Например, Elixir поставляется со многими типами данных, реализованными в виде структур, таких как &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; . Мы можем реализовать протокол &lt;code&gt;Size&lt;/code&gt; для этих типов:</target>
        </trans-unit>
        <trans-unit id="bd093bcc0572d7db8f0249b943686c7ab44cd28f" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="translated">Настоящее преимущество протоколов проявляется в сочетании со структурами. Например, Elixir поставляется со многими типами данных, реализованными в виде структур, таких как &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; . Мы также можем реализовать протокол &lt;code&gt;Size&lt;/code&gt; для этих типов:</target>
        </trans-unit>
        <trans-unit id="dd7d714c1aa6b48b1d5593fcc16114d85e6a86ca" translate="yes" xml:space="preserve">
          <source>The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like &lt;code&gt;~r(^https?://)&lt;/code&gt; reads arguably better than &lt;code&gt;~r/^https?:\/\//&lt;/code&gt;. Similarly, if the regular expression has forward slashes and capturing groups (that use &lt;code&gt;()&lt;/code&gt;), you may then choose double quotes instead of parentheses.</source>
          <target state="translated">Причина поддержки различных разделителей заключается в том, чтобы обеспечить возможность записи литералов без экранированных разделителей. Например, регулярное выражение с косой чертой, такое как &lt;code&gt;~r(^https?://)&lt;/code&gt; читается лучше, чем &lt;code&gt;~r/^https?:\/\//&lt;/code&gt; . Точно так же, если в регулярном выражении есть косая черта и группы захвата (которые используют &lt;code&gt;()&lt;/code&gt; ), вы можете выбрать двойные кавычки вместо скобок.</target>
        </trans-unit>
        <trans-unit id="2ebf61cf3ca7649d4a079542dcbdefccc549e8d6" translate="yes" xml:space="preserve">
          <source>The reason those failures are happening is because, for didactic purposes, we have made two mistakes:</source>
          <target state="translated">Причина этих неудач заключается в том,что в дидактических целях мы допустили две ошибки:</target>
        </trans-unit>
        <trans-unit id="c08560839cd14ff160f58cb4ece9a90b113b6018" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don&amp;rsquo;t need to worry about different data types in order to sort. The overall sorting order is defined below:</source>
          <target state="translated">Причина, по которой мы можем сравнивать разные типы данных, - это прагматизм. Алгоритмам сортировки не нужно беспокоиться о разных типах данных для сортировки. Общий порядок сортировки определен ниже:</target>
        </trans-unit>
        <trans-unit id="96b6eb1d3d1c2f52c89893113a0264a48486f7f0" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below:</source>
          <target state="translated">Причина,по которой мы можем сравнивать различные типы данных,заключается в прагматизме.Алгоритмам сортировки не нужно беспокоиться о разных типах данных.Для справки,общий порядок сортировки определен ниже:</target>
        </trans-unit>
        <trans-unit id="5bf8002bbf671d6262f86dd4db1f940a5c99c6ee" translate="yes" xml:space="preserve">
          <source>The reason we don't provide hot code upgrades is because they are very complicated to perform in practice, as they require careful coding of your processes and applications as well as extensive testing. Given most teams can use other techniques that are language agnostic to upgrade their systems, such as Blue/Green deployments, Canary deployments, Rolling deployments, and others, hot upgrades are rarely a viable option. Let's understand why.</source>
          <target state="translated">Причина,по которой мы не предоставляем обновления горячего кода,заключается в том,что они очень сложны для выполнения на практике,так как требуют тщательного кодирования ваших процессов и приложений,а также обширного тестирования.Учитывая,что большинство команд может использовать другие методы,которые являются языковыми агностическими для обновления своих систем,таких как синий/зеленый развертывания,Канарские развертывания,Rolling развертывания,и другие,горячие обновления редко являются жизнеспособным вариантом.Давайте разберемся,почему.</target>
        </trans-unit>
        <trans-unit id="9745fde52cc90f68fc3769f51bdd3839a79e7909" translate="yes" xml:space="preserve">
          <source>The reason why defining the &lt;code&gt;__using__&lt;/code&gt; macro above should be avoided is because when a developer writes:</source>
          <target state="translated">Причина, по которой следует избегать определения макроса &lt;code&gt;__using__&lt;/code&gt; выше, заключается в том, что когда разработчик пишет:</target>
        </trans-unit>
        <trans-unit id="6ec6b8d401a0e57e5eec7caca955764b74ee728d" translate="yes" xml:space="preserve">
          <source>The reducer function.</source>
          <target state="translated">Функция редуктора.</target>
        </trans-unit>
        <trans-unit id="fe9b615b4b2367b7daee50e253cbdf23dba26c40" translate="yes" xml:space="preserve">
          <source>The registry can be used for different purposes, such as name lookups (using the &lt;code&gt;:via&lt;/code&gt; option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below.</source>
          <target state="translated">Реестр может использоваться для различных целей, таких как поиск имени (с использованием параметра &lt;code&gt;:via&lt;/code&gt; ), хранение свойств, настраиваемые правила диспетчеризации или реализация pubsub. Ниже мы рассмотрим некоторые из этих вариантов использования.</target>
        </trans-unit>
        <trans-unit id="830561c69ec1b44d20b1476b8ca91dcfe652b847" translate="yes" xml:space="preserve">
          <source>The registry creates the bucket and updates the cache table</source>
          <target state="translated">Реестр создает ведро и обновляет таблицу кэша</target>
        </trans-unit>
        <trans-unit id="1e02149d4dfcef116ac8ae8bc7c958f58a3e9c0d" translate="yes" xml:space="preserve">
          <source>The registry identifier</source>
          <target state="translated">Идентификатор реестра</target>
        </trans-unit>
        <trans-unit id="6c262eba9d17501af95e8d89e43d93764b4ff9c4" translate="yes" xml:space="preserve">
          <source>The registry may also be transparently partitioned, which provides more scalable behaviour for running registries on highly concurrent environments with thousands or millions of entries.</source>
          <target state="translated">Реестр может быть также прозрачно разделен на разделы,что обеспечивает более масштабируемое поведение при запуске реестров в сильно параллельных средах с тысячами или миллионами записей.</target>
        </trans-unit>
        <trans-unit id="6dcaa3fc50cf9fd5531a012d77c058d5085b7bd8" translate="yes" xml:space="preserve">
          <source>The registry needs to guarantee that it is always up to date. For example, if one of the bucket processes crashes due to a bug, the registry must notice this change and avoid serving stale entries. In Elixir, we say the registry needs to &lt;em&gt;monitor&lt;/em&gt; each bucket. Because our &lt;em&gt;registry&lt;/em&gt; needs to be able to receive and handle ad-hoc messages from the system, the &lt;code&gt;Agent&lt;/code&gt; API is not enough.</source>
          <target state="translated">Реестр должен гарантировать, что он всегда актуален. Например, если один из процессов корзины выходит из строя из-за ошибки, реестр должен заметить это изменение и избежать обслуживания устаревших записей. В Elixir мы говорим, что реестр должен &lt;em&gt;отслеживать&lt;/em&gt; каждую корзину. Поскольку наш &lt;em&gt;реестр&lt;/em&gt; должен иметь возможность получать и обрабатывать специальные сообщения от системы, API &lt;code&gt;Agent&lt;/code&gt; недостаточно.</target>
        </trans-unit>
        <trans-unit id="4a058f690e57a3aca65e5ad6c344df9d0e9611d7" translate="yes" xml:space="preserve">
          <source>The registry requires the following keys:</source>
          <target state="translated">Реестр требует следующие ключи:</target>
        </trans-unit>
        <trans-unit id="66187ff2a57d2c76b021b6e86b887377c3911cc5" translate="yes" xml:space="preserve">
          <source>The remaining fields are private and should not be accessed.</source>
          <target state="translated">Остальные поля являются приватными и не должны быть доступны.</target>
        </trans-unit>
        <trans-unit id="1f0abbf815761f3e816424020ca8e718d8880a26" translate="yes" xml:space="preserve">
          <source>The remaining options can be specified to further customize the escript:</source>
          <target state="translated">Остальные опции можно указать для дальнейшей настройки скрипта:</target>
        </trans-unit>
        <trans-unit id="7b880036afa4f762da2230a6fa814b25c0b9e585" translate="yes" xml:space="preserve">
          <source>The replacement can be either a string or a function. The string is used as a replacement for every match and it allows specific captures to be accessed via &lt;code&gt;\N&lt;/code&gt; or &lt;code&gt;\g{N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the capture. In case &lt;code&gt;\0&lt;/code&gt; is used, the whole match is inserted. Note that in regexes the backslash needs to be escaped, hence in practice you'll need to use &lt;code&gt;\\N&lt;/code&gt; and &lt;code&gt;\\g{N}&lt;/code&gt;.</source>
          <target state="translated">Замена может быть строкой или функцией. Строка используется в качестве замены для каждого совпадения и позволяет получить доступ к определенным захватам через &lt;code&gt;\N&lt;/code&gt; или &lt;code&gt;\g{N}&lt;/code&gt; , где &lt;code&gt;N&lt;/code&gt; - это захват. В случае использования &lt;code&gt;\0&lt;/code&gt; вставляется все совпадение. Обратите внимание, что в регулярных выражениях необходимо экранировать обратную косую черту, поэтому на практике вам нужно будет использовать &lt;code&gt;\\N&lt;/code&gt; и &lt;code&gt;\\g{N}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d12dcacc64e49f2ca797e3a42d48c6b95c4c021d" translate="yes" xml:space="preserve">
          <source>The reply sent by the task will be in the format &lt;code&gt;{ref, result}&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; is the monitor reference held by the task struct and &lt;code&gt;result&lt;/code&gt; is the return value of the task function.</source>
          <target state="translated">Ответ, отправленный задачей, будет в формате &lt;code&gt;{ref, result}&lt;/code&gt; , где &lt;code&gt;ref&lt;/code&gt; - ссылка на монитор, содержащаяся в структуре задачи, а &lt;code&gt;result&lt;/code&gt; - возвращаемое значение функции задачи.</target>
        </trans-unit>
        <trans-unit id="fbae3095fe06d4c7dbe53db6c416f757e85aa9e2" translate="yes" xml:space="preserve">
          <source>The requirement operand after the &lt;code&gt;~&amp;gt;&lt;/code&gt; is allowed to omit the patch version, allowing us to express &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; or &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt;, something that wouldn't be allowed when using the common comparison operators.</source>
          <target state="translated">Операнду требования после &lt;code&gt;~&amp;gt;&lt;/code&gt; разрешено опускать версию патча, что позволяет нам выражать &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; или &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt; , что было бы недопустимо при использовании обычных операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="48c107c58db2b694200d1ee8f97e6cacd70556ad" translate="yes" xml:space="preserve">
          <source>The requirements for this guide are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">Требования к этому руководству (см. &lt;code&gt;elixir -v&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="510fb68883c75cfa0f5726ad2958e2b2d1f8df13" translate="yes" xml:space="preserve">
          <source>The rest of this document will cover how child processes are specified, how they can be started and stopped, different supervision strategies and more.</source>
          <target state="translated">Остальная часть этого документа будет посвящена тому,как задаются детские процессы,как их запускать и останавливать,различным стратегиям надзора и многому другому.</target>
        </trans-unit>
        <trans-unit id="34f71128fc5223e069e44135ef71e787278b7b2a" translate="yes" xml:space="preserve">
          <source>The result depends on the given options. In particular, if &lt;code&gt;:monitor&lt;/code&gt; is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID.</source>
          <target state="translated">Результат зависит от заданных вариантов. В частности, если &lt;code&gt;:monitor&lt;/code&gt; указан как опция, он вернет кортеж, содержащий PID и ссылку на мониторинг, в противном случае - только PID порожденного процесса.</target>
        </trans-unit>
        <trans-unit id="8c0864a3fd323ad326bf0ff0a4ae750f6f28b62b" translate="yes" xml:space="preserve">
          <source>The result is a map where each key is given by &lt;code&gt;key_fun&lt;/code&gt; and each value is a list of elements given by &lt;code&gt;value_fun&lt;/code&gt;. The order of elements within each list is preserved from the &lt;code&gt;enumerable&lt;/code&gt;. However, like all maps, the resulting map is unordered.</source>
          <target state="translated">Результатом является карта, где каждый ключ задается параметром &lt;code&gt;key_fun&lt;/code&gt; , а каждое значение представляет собой список элементов, заданных параметром &lt;code&gt;value_fun&lt;/code&gt; . Порядок элементов в каждом списке сохраняется из &lt;code&gt;enumerable&lt;/code&gt; . Однако, как и все карты, результирующая карта неупорядочена.</target>
        </trans-unit>
        <trans-unit id="8c937afc93e905039ed962f46e31ce761b0b7910" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the code point and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">Результатом является кортеж с кодовой точкой и остатком строки или &lt;code&gt;nil&lt;/code&gt; в случае, если строка достигла своего конца.</target>
        </trans-unit>
        <trans-unit id="b054d17c2daa0de49da800a95e641450c215bba5" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the grapheme and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the String reached its end.</source>
          <target state="translated">Результатом является кортеж с графемой и остатком строки или &lt;code&gt;nil&lt;/code&gt; в случае, если строка достигла своего конца.</target>
        </trans-unit>
        <trans-unit id="cf56030549a526b9bf11fca22b129025175f9e01" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">Результатом является кортеж со следующим размером графемы и остатком строки или &lt;code&gt;nil&lt;/code&gt; в случае, если строка достигла своего конца.</target>
        </trans-unit>
        <trans-unit id="49e5bd89a099593fc1d84560689945a8bdf9718a" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size in bytes and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">Результатом является кортеж со следующим размером графемы в байтах и ​​остатком строки или &lt;code&gt;nil&lt;/code&gt; в случае, если строка достигла своего конца.</target>
        </trans-unit>
        <trans-unit id="69c824c2f4dd9e92c63e7c43b613daec936f10e9" translate="yes" xml:space="preserve">
          <source>The result is always a float. Use &lt;a href=&quot;#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rem/2&quot;&gt;&lt;code&gt;rem/2&lt;/code&gt;&lt;/a&gt; if you want an integer division or the remainder.</source>
          <target state="translated">В результате всегда получается float. Используйте &lt;a href=&quot;#div/2&quot;&gt; &lt;code&gt;div/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#rem/2&quot;&gt; &lt;code&gt;rem/2&lt;/code&gt; ,&lt;/a&gt; если вы хотите целочисленное деление или остаток.</target>
        </trans-unit>
        <trans-unit id="e60b28a7c2d9f237889da5d63ad55cd56db26e5f" translate="yes" xml:space="preserve">
          <source>The result is returned in the &lt;code&gt;:native&lt;/code&gt; time unit.</source>
          <target state="translated">Результат возвращается в единице времени &lt;code&gt;:native&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e378125d134cee06b90778b774e2ca53b3a689f" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (e.g., obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="translated">Результат возвращается в единицу времени с учетом &lt;code&gt;unit&lt;/code&gt; . Возвращенное смещение, добавленное к монотонному времени Эрланга (например, полученное с помощью &lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; &lt;/a&gt; ), дает системное время Эрланга, которое соответствует этому монотонному времени.</target>
        </trans-unit>
        <trans-unit id="bd31606d8c7fb963c24880e97f324e4acb8d8f68" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (for instance, one obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="translated">Результат возвращается в единицу времени с учетом &lt;code&gt;unit&lt;/code&gt; . Возвращенное смещение, добавленное к монотонному времени Эрланга (например, полученному с помощью &lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; &lt;/a&gt; ), дает системное время Эрланга, которое соответствует этому монотонному времени.</target>
        </trans-unit>
        <trans-unit id="ad2bb7bf504a7a31fc692bc22a46a7f6c26558df" translate="yes" xml:space="preserve">
          <source>The result is rounded via the floor function.</source>
          <target state="translated">Результат округляется с помощью функции пола.</target>
        </trans-unit>
        <trans-unit id="7c9d24e7e55d00cf51e7d7ac4365534956cf6af0" translate="yes" xml:space="preserve">
          <source>The result of the reduce operation.</source>
          <target state="translated">Результат операции по сокращению.</target>
        </trans-unit>
        <trans-unit id="5c33a08ba308a53a6a04ff3b3a415b2906539c81" translate="yes" xml:space="preserve">
          <source>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">Результат этой функции используется для проверки одновременного опрокидывания двух календарей в одно и то же время суток.Если нет,то мы можем только конвертировать даты и время между ними.Если они делают это,то это означает,что мы также можем конвертировать даты,а также наивные даты между ними.</target>
        </trans-unit>
        <trans-unit id="deee6a8e2cf3a1dc01e05f85abd7a333a49b9743" translate="yes" xml:space="preserve">
          <source>The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.</source>
          <target state="translated">Результатом,возвращаемым в качестве аргумента,является список узлов,удовлетворяющих дизъюнкции элементов списка.</target>
        </trans-unit>
        <trans-unit id="de9d80b1ab304736a1d1cf097b00ab6920ddf496" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;fun&lt;/code&gt; is expected to be</source>
          <target state="translated">Ожидается, что возвращаемое значение для &lt;code&gt;fun&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="ac8a9c64fdd4a29692e13a9877d1bb2d850a96ef" translate="yes" xml:space="preserve">
          <source>The return value is considered to be found when the result is truthy (neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Возвращаемое значение считается найденным, если результат является правдивым (ни &lt;code&gt;nil&lt;/code&gt; ни &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c789d5090be5fd4830e5650f8cf224329bb3d092" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; or any of the &lt;code&gt;handle_*&lt;/code&gt; callbacks may include a timeout value in milliseconds; if not, &lt;code&gt;:infinity&lt;/code&gt; is assumed. The timeout can be used to detect a lull in incoming messages.</source>
          <target state="translated">Возвращаемое значение &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; или любого из &lt;code&gt;handle_*&lt;/code&gt; вызовов handle_ * может включать значение тайм-аута в миллисекундах; в противном случае &lt;code&gt;:infinity&lt;/code&gt; предполагается бесконечность . Тайм-аут может использоваться для обнаружения перерыва во входящих сообщениях.</target>
        </trans-unit>
        <trans-unit id="637f2543c6c71a469bb5665295bb80f1c21c7816" translate="yes" xml:space="preserve">
          <source>The return value of this function is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение этой функции всегда &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aee9968a076604f4bf8eb65e4e57dfeed366595f" translate="yes" xml:space="preserve">
          <source>The return value of this function is the value that was previously stored under &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; in case no value was stored under it.</source>
          <target state="translated">Возвращаемое значение этой функции - это значение, которое ранее было сохранено под &lt;code&gt;key&lt;/code&gt; , или &lt;code&gt;nil&lt;/code&gt; , если под ним не было сохранено никакого значения.</target>
        </trans-unit>
        <trans-unit id="8981b39a20d60bae9e3cc6f4a790fa30d54a0258" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; will have &lt;code&gt;UTC&lt;/code&gt; timezone, if you want other timezone, please use &lt;a href=&quot;#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; будет иметь &lt;code&gt;UTC&lt;/code&gt; часовой пояс, если вы хотите другой часовой пояс, пожалуйста , используйте &lt;a href=&quot;#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30cb91bc5640b8dc4f60b9f7ca0aa50c81c4fc01" translate="yes" xml:space="preserve">
          <source>The returned datetime must be in UTC. The original &lt;code&gt;utc_offset&lt;/code&gt; it was written in must be returned in the result.</source>
          <target state="translated">Возвращаемое datetime должно быть в формате UTC. Исходный &lt;code&gt;utc_offset&lt;/code&gt; ,в котором он был записан, должен быть возвращен в результате.</target>
        </trans-unit>
        <trans-unit id="68256b5cc686943a73a48ce0ec84d14bdbd6db53" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt; функция обычно передается как средство доступа Kernel.get_in / 2 , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt; и друзьям.</target>
        </trans-unit>
        <trans-unit id="f600704ad2a1d265216e1874920599247dcd864b" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;kernel#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">&lt;a href=&quot;kernel#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt; функция обычно передается как средство доступа Kernel.get_in / 2 , &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt; и друзьям.</target>
        </trans-unit>
        <trans-unit id="feb14c2276580a5fb93fd8afe56dfe5ef725b402" translate="yes" xml:space="preserve">
          <source>The returned function raises if &lt;code&gt;index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">Возвращенная функция возникает, если &lt;code&gt;index&lt;/code&gt; выходит за допустимые пределы.</target>
        </trans-unit>
        <trans-unit id="f18363f66f41ea776d213b7a358943fee2fbf810" translate="yes" xml:space="preserve">
          <source>The returned function receives a term and a command and injects the term into the collectable on every &lt;code&gt;{:cont, term}&lt;/code&gt; command.</source>
          <target state="translated">Возвращенная функция получает термин и команду и вставляет термин в коллекцию для каждой команды &lt;code&gt;{:cont, term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03b6bd0a789c54c65fa616d4c3d05a787c9fac95" translate="yes" xml:space="preserve">
          <source>The returned function uses the default value if the key does not exist. This can be used to specify defaults and safely traverse missing keys:</source>
          <target state="translated">Возвращаемая функция использует значение по умолчанию,если ключ не существует.Это может быть использовано для задания значений по умолчанию и безопасного перемещения отсутствующих ключей:</target>
        </trans-unit>
        <trans-unit id="17eadcc2531c98be75b3d36e9d02f1db40badbf9" translate="yes" xml:space="preserve">
          <source>The returned information is a two-element tuple in the shape of &lt;code&gt;{info, value}&lt;/code&gt;.</source>
          <target state="translated">Возвращенная информация представляет собой двухэлементный кортеж в форме &lt;code&gt;{info, value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40619e10ae25c330063c65535cf867c78a0305e7" translate="yes" xml:space="preserve">
          <source>The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following:</source>
          <target state="translated">Возвращаемые клавиши (с соответствующими возможными значениями)для всех типов функций (локальных и внешних)являются следующими:</target>
        </trans-unit>
        <trans-unit id="8ee75b4eeb81fcc96ebfd98173bc87ddff369546" translate="yes" xml:space="preserve">
          <source>The returned path will be expanded.</source>
          <target state="translated">Возвращаемый путь будет расширен.</target>
        </trans-unit>
        <trans-unit id="4d71c99a8e09f63bf55427e1e561d5818b8e3777" translate="yes" xml:space="preserve">
          <source>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</source>
          <target state="translated">Возвращаемая ссылка будет повторяться примерно после 2^82 звонков,поэтому она достаточно уникальна для практических целей.</target>
        </trans-unit>
        <trans-unit id="6710b3a068da95fe2b8593d7add9ec761b0835bc" translate="yes" xml:space="preserve">
          <source>The returned value is a map containing name-value pairs. Variable names and their values are strings.</source>
          <target state="translated">Возвращаемое значение представляет собой карту,содержащую пары &quot;имя-значение&quot;.Имена переменных и их значения являются строками.</target>
        </trans-unit>
        <trans-unit id="b373635bb9902337ad9e10b973bd7b4caeea100c" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new keyword list with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение представляет собой кортеж со значением &amp;laquo;get&amp;raquo;, возвращаемым &lt;code&gt;fun&lt;/code&gt; , и новым списком ключевых слов с обновленным значением под &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42137d3006c00e4b619eab71021a2f058571bc2" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new map with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - это кортеж со значением &quot;get&quot;, возвращаемым &lt;code&gt;fun&lt;/code&gt; , и новая карта с обновленным значением под &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
