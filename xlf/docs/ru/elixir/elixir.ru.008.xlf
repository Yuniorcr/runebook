<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="7ee68d6d5538c71b755e522365fc502dbb4b5228" translate="yes" xml:space="preserve">
          <source>In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.</source>
          <target state="translated">Таким образом,документация представляет собой договор с пользователями вашего API,которые не обязательно имеют доступ к исходному коду;в то время как комментарии к коду предназначены для тех,кто непосредственно взаимодействует с исходным кодом.Вы можете узнать и выразить различные гарантии в отношении вашего программного обеспечения,разделив эти два понятия.</target>
        </trans-unit>
        <trans-unit id="88056ec75ab5d6672e9f690c2cbe9609ac25a458" translate="yes" xml:space="preserve">
          <source>In the &quot;Mix.Task&quot; section, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</source>
          <target state="translated">В разделе &quot;Mix.Task&quot; мы определили задачу,которая будет доступна каждому,использующему наш проект в качестве зависимости.Что,если бы мы хотели,чтобы эта задача была доступна только для нашего проекта? Просто определите псевдоним:</target>
        </trans-unit>
        <trans-unit id="ff37981f126b5bf2fa55d0c06620d51ba16e7f55" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;agent&quot;&gt;previous chapter&lt;/a&gt;, we used agents to represent our buckets. In the &lt;a href=&quot;introduction-to-mix&quot;&gt;introduction to mix&lt;/a&gt;, we specified we would like to name each bucket so we can do the following:</source>
          <target state="translated">В &lt;a href=&quot;agent&quot;&gt;предыдущей главе&lt;/a&gt; мы использовали агентов для представления наших корзин. Во &lt;a href=&quot;introduction-to-mix&quot;&gt;введении к микшированию&lt;/a&gt; мы указали, что хотели бы назвать каждое ведро, чтобы мы могли сделать следующее:</target>
        </trans-unit>
        <trans-unit id="3b5fc14f69e9c66ff005f61efabe92506fc54ff9" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic-types&quot;&gt;previous chapter&lt;/a&gt;, we saw Elixir provides &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; as arithmetic operators, plus the functions &lt;code&gt;div/2&lt;/code&gt; and &lt;code&gt;rem/2&lt;/code&gt; for integer division and remainder.</source>
          <target state="translated">В &lt;a href=&quot;basic-types&quot;&gt;предыдущей главе&lt;/a&gt; мы видели, что Elixir предоставляет &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; в качестве арифметических операторов, а также функции &lt;code&gt;div/2&lt;/code&gt; и &lt;code&gt;rem/2&lt;/code&gt; для целочисленного деления и остатка.</target>
        </trans-unit>
        <trans-unit id="f26102656dadf27f08b5ecc06639ee0453b4518a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;structs&quot;&gt;previous chapter&lt;/a&gt;, we have learned that although structs are maps, they do not share protocol implementations with maps. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s (sets based on maps) are implemented as structs. Let&amp;rsquo;s try to use the &lt;code&gt;Size&lt;/code&gt; protocol with a &lt;code&gt;MapSet&lt;/code&gt;:</source>
          <target state="translated">В &lt;a href=&quot;structs&quot;&gt;предыдущей главе&lt;/a&gt; мы узнали, что хотя структуры являются картами, они не разделяют реализации протокола с картами. Например, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; (наборы на основе карт) реализованы как структуры. Попробуем использовать протокол &lt;code&gt;Size&lt;/code&gt; с &lt;code&gt;MapSet&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53173cc148f94bd7e146b01b777ce24e106147bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;__using__/1&lt;/code&gt; implementation, we will initialize a module attribute named &lt;code&gt;@tests&lt;/code&gt; to an empty list, then store the name of each defined test in this attribute so the tests can be invoked from the &lt;code&gt;run&lt;/code&gt; function.</source>
          <target state="translated">В реализации &lt;code&gt;__using__/1&lt;/code&gt; мы инициализируем атрибут модуля с именем &lt;code&gt;@tests&lt;/code&gt; пустым списком, а затем сохраним имя каждого определенного теста в этом атрибуте, чтобы тесты можно было вызывать из функции &lt;code&gt;run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b21c1f93db813518da68dd14fe39d40364740d5a" translate="yes" xml:space="preserve">
          <source>In the Applications tab, you will see all applications currently running in your system alongside their supervision tree. You can select the &lt;code&gt;kv&lt;/code&gt; application to explore it further:</source>
          <target state="translated">На вкладке &amp;laquo;Приложения&amp;raquo; вы увидите все приложения, запущенные в настоящее время в вашей системе, а также их дерево наблюдения. Вы можете выбрать приложение &lt;code&gt;kv&lt;/code&gt; для дальнейшего изучения:</target>
        </trans-unit>
        <trans-unit id="bde538c8f6213c2789f457ce470a93e8d2f207d9" translate="yes" xml:space="preserve">
          <source>In the above, process termination refers to unsuccessful termination, which is determined by the &lt;code&gt;:restart&lt;/code&gt; option.</source>
          <target state="translated">В приведенном выше описании завершение процесса означает неудачное завершение, которое определяется параметром &lt;code&gt;:restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7821fdeb2e1e82ffc7914547f20081eb14c31b6f" translate="yes" xml:space="preserve">
          <source>In the case a value is stored multiple times in the keyword list, later occurrences are removed.</source>
          <target state="translated">В случае,если значение хранится в списке ключевых слов несколько раз,последующие события удаляются.</target>
        </trans-unit>
        <trans-unit id="de44ed6132703d951e8099501d3dde1a95e8c6be" translate="yes" xml:space="preserve">
          <source>In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:</source>
          <target state="translated">В случае вызова анонимных функций внутренний кортеж с точечной специальной формой имеет только один аргумент,отражающий тот факт,что оператор является унарным:</target>
        </trans-unit>
        <trans-unit id="0c98e9cf9dcf59ac9fca17a0c41969297e7c44d2" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;Logger.flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В случае события &lt;code&gt;:flush&lt;/code&gt; обработчики flush должны сбрасывать все ожидающие данные. Это событие запускается &lt;a href=&quot;#flush/0&quot;&gt; &lt;code&gt;Logger.flush/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bee66e2e0ed3861603c7e12d98d2bb864e0a4a57" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В случае события &lt;code&gt;:flush&lt;/code&gt; обработчики flush должны сбрасывать все ожидающие данные. Это событие запускается &lt;a href=&quot;#flush/0&quot;&gt; &lt;code&gt;flush/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7d253a49741f6c380664521d0e7ead5dde4a470" translate="yes" xml:space="preserve">
          <source>In the code above, we have a process, which we call &amp;ldquo;the client&amp;rdquo; sending a request to an agent, &amp;ldquo;the server&amp;rdquo;. The request contains an anonymous function, which must be executed by the server.</source>
          <target state="translated">В приведенном выше коде у нас есть процесс, который мы называем &amp;laquo;клиентом&amp;raquo;, отправляя запрос агенту, &amp;laquo;серверу&amp;raquo;. Запрос содержит анонимную функцию, которую должен выполнить сервер.</target>
        </trans-unit>
        <trans-unit id="2ea691104e7ec52f4ddc63f9f0cace981d953b17" translate="yes" xml:space="preserve">
          <source>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</source>
          <target state="translated">В среде вы можете получить доступ к текущему имени файла,номерам строк,установить псевдонимы,текущей функции и другим.</target>
        </trans-unit>
        <trans-unit id="e0731e3b2d6896ada3ab5956119cf51186ed0825" translate="yes" xml:space="preserve">
          <source>In the environment you can access the filename, line numbers, set up aliases, the function and others.</source>
          <target state="translated">В среде вы можете получить доступ к имени файла,номерам строк,установить псевдонимы,функции и другим.</target>
        </trans-unit>
        <trans-unit id="608b24d6e5e5edc7ece0be6b5cce2c71fcef971e" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Cmd.html&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="translated">В приведенном выше примере мы создали псевдоним &lt;code&gt;some_alias&lt;/code&gt; , который будет запускать &lt;code&gt;mix hex.info&lt;/code&gt; задач hex.info , затем &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; для запуска сценария Elixir, затем &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Cmd.html&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt; для выполнения сценария оболочки командной строки. Это показывает, насколько мощными могут быть псевдонимы, смешанные с задачами Mix.</target>
        </trans-unit>
        <trans-unit id="2913df470cab8312823dbbd9aad2e70e4f9242e6" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="translated">В приведенном выше примере мы создали псевдоним &lt;code&gt;some_alias&lt;/code&gt; , который будет запускать &lt;code&gt;mix hex.info&lt;/code&gt; задач hex.info , затем &lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; для запуска сценария Elixir, затем &lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt; для выполнения сценария оболочки командной строки. Это показывает, насколько мощными могут быть псевдонимы, смешанные с задачами Mix.</target>
        </trans-unit>
        <trans-unit id="8a1ba160e9b96d6822e0f9cf64aea8a58c334907" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#max_by/3&quot;&gt;&lt;code&gt;max_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#max/1&quot;&gt; &lt;code&gt;max/1&lt;/code&gt; &lt;/a&gt; вернул 31 марта вместо 1 апреля, потому что структурное сравнение сравнивает день перед годом. Это можно решить, используя &lt;a href=&quot;#max_by/3&quot;&gt; &lt;code&gt;max_by/3&lt;/code&gt; &lt;/a&gt; и полагаясь на структуры, в которых наиболее значимые цифры идут впереди. В этом конкретном случае мы можем использовать &lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; ,&lt;/a&gt; чтобы получить представление кортежа с полями года, месяца и дня:</target>
        </trans-unit>
        <trans-unit id="d50a70865839f28bf705bef682c6bf3df4c9c940" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt; вернул 31 марта вместо 1 апреля, потому что структурное сравнение сравнивает день перед годом. По этой причине большинство структур предоставляют функцию &amp;laquo;сравнения&amp;raquo;, например &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt; , которая принимает две структуры и возвращает &lt;code&gt;:lt&lt;/code&gt; (меньше-чем) ,: &lt;code&gt;:eq&lt;/code&gt; (равно) и &lt;code&gt;:gt&lt;/code&gt; (больше-чем). . Если вы передадите модуль в качестве функции сортировки, Elixir автоматически будет использовать функцию &lt;code&gt;compare/2&lt;/code&gt; указанного модуля:</target>
        </trans-unit>
        <trans-unit id="00b3dfc102ba0bf3e9031dc021dd5e02de63d0cd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt; вернул 31 марта вместо 1 апреля, потому что структурное сравнение сравнивает день перед годом. В таких случаях модули обычно предоставляют такие функции, как &lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; ,&lt;/a&gt; которые выполняют семантическое сравнение.</target>
        </trans-unit>
        <trans-unit id="27e3001adb27cd38424db873e11a855a0fabd25e" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt; вернул 31 марта вместо 1 апреля, потому что структурное сравнение сравнивает день перед годом. В таких случаях модули обычно предоставляют такие функции, как &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; ,&lt;/a&gt; которые выполняют семантическое сравнение.</target>
        </trans-unit>
        <trans-unit id="7872f4b6748675f8cea9f2aac1d82fd307d18a15" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#min_by/3&quot;&gt;&lt;code&gt;min_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#min/1&quot;&gt; &lt;code&gt;min/1&lt;/code&gt; &lt;/a&gt; вернул 1 апреля вместо 31 марта, потому что структурное сравнение сравнивает день перед годом. Это можно решить, используя &lt;a href=&quot;#min_by/3&quot;&gt; &lt;code&gt;min_by/3&lt;/code&gt; &lt;/a&gt; и полагаясь на структуры, в которых наиболее значимые цифры идут впереди. В этом конкретном случае мы можем использовать &lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; ,&lt;/a&gt; чтобы получить представление кортежа с полями года, месяца и дня:</target>
        </trans-unit>
        <trans-unit id="b47db09b5466e9e31fe82800684896500461db1f" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt; вернул 1 апреля вместо 31 марта, потому что структурное сравнение сравнивает день перед годом. По этой причине большинство структур предоставляют функцию &amp;laquo;сравнения&amp;raquo;, например &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt; , которая принимает две структуры и возвращает &lt;code&gt;:lt&lt;/code&gt; (меньше-чем) ,: &lt;code&gt;:eq&lt;/code&gt; (равно) и &lt;code&gt;:gt&lt;/code&gt; (больше-чем). . Если вы передадите модуль в качестве функции сортировки, Elixir автоматически будет использовать функцию &lt;code&gt;compare/2&lt;/code&gt; указанного модуля:</target>
        </trans-unit>
        <trans-unit id="0cf57110afa2caf6b8fbffc8cc551e293da6c450" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt; вернул 1 апреля вместо 31 марта, потому что структурное сравнение сравнивает день перед годом. В таких случаях модули обычно предоставляют такие функции, как &lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; ,&lt;/a&gt; которые выполняют семантическое сравнение.</target>
        </trans-unit>
        <trans-unit id="6741cfc7caed86bbef15f21d887f8bb7d9a69a68" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt; вернул 1 апреля вместо 31 марта, потому что структурное сравнение сравнивает день перед годом. В таких случаях модули обычно предоставляют такие функции, как &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; ,&lt;/a&gt; которые выполняют семантическое сравнение.</target>
        </trans-unit>
        <trans-unit id="baf0386ec100f9836f02578a5562d4a28953ca57" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; накапливает результат каждого вызова &lt;code&gt;fun&lt;/code&gt; в список в обратном порядке, который правильно упорядочивается в конце путем вызова &lt;a href=&quot;#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3ad3c30dbfab7415bf70f15c8e5b3a581930bcb" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; накапливает результат каждого вызова &lt;code&gt;fun&lt;/code&gt; в список в обратном порядке, который правильно упорядочивается в конце путем вызова &lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ab2fe333dba7cd1bd613d8d2e21311292cba7df" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; returns a data type, an actual stream, that represents the &lt;code&gt;map&lt;/code&gt; computation over the range &lt;code&gt;1..100_000&lt;/code&gt;:</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; возвращает тип данных, фактический поток, который представляет вычисление &lt;code&gt;map&lt;/code&gt; в диапазоне &lt;code&gt;1..100_000&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05fc4140bc39b53558f26707ec168a4d86893856" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;ExUnit&lt;/code&gt; stores the value of &lt;code&gt;async: true&lt;/code&gt; in a module attribute to change how the module is compiled. Tags are also defined as &lt;code&gt;accumulate: true&lt;/code&gt; attributes, and they store tags that can be used to setup and filter tests. For example, you can avoid running external tests on your machine because they are slow and dependent on other services, while they can still be enabled in your build system.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;ExUnit&lt;/code&gt; сохраняет значение &lt;code&gt;async: true&lt;/code&gt; в атрибуте модуля, чтобы изменить способ компиляции модуля. Теги также определены как атрибуты &lt;code&gt;accumulate: true&lt;/code&gt; , и в них хранятся теги, которые можно использовать для настройки и фильтрации тестов. Например, вы можете избежать запуска внешних тестов на вашем компьютере, потому что они медленные и зависят от других служб, хотя их все еще можно включить в вашей системе сборки.</target>
        </trans-unit>
        <trans-unit id="d7c845572f115897b2ebea0f8fac31816b299fd4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;a&lt;/code&gt; returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the &lt;code&gt;var!&lt;/code&gt; macro:</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;a&lt;/code&gt; возвращает 10, даже если макрос явно устанавливает для него значение 1, поскольку переменные, определенные в макросе, не влияют на контекст, в котором выполняется макрос. Если вы хотите установить или получить переменную в контексте вызывающего объекта, вы можно сделать это с помощью &lt;code&gt;var!&lt;/code&gt; макрос:</target>
        </trans-unit>
        <trans-unit id="7a7545c257a489979c415df1e9f0cbb1c93d77bd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;bar&lt;/code&gt; will be returned if &lt;code&gt;foo&lt;/code&gt; evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Otherwise, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;bar&lt;/code&gt; будет возвращен, если &lt;code&gt;foo&lt;/code&gt; вернет истинное значение (ни &lt;code&gt;false&lt;/code&gt; , ни &lt;code&gt;nil&lt;/code&gt; ). В противном случае будет возвращено &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eacffd5adbf5fd949bb658e0457a877aa95d246" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; or &lt;code&gt;13&lt;/code&gt; depending on the value of &lt;code&gt;lucky?&lt;/code&gt;. In case &lt;code&gt;value&lt;/code&gt; has no previous value before case, clauses that do not explicitly bind a value have the variable bound to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;value&lt;/code&gt; будет &lt;code&gt;7&lt;/code&gt; или &lt;code&gt;13&lt;/code&gt; в зависимости от значения &lt;code&gt;lucky?&lt;/code&gt; , В случае, если &lt;code&gt;value&lt;/code&gt; не имеет предыдущего значения перед case, в предложениях, которые явно не связывают значение, переменная привязана к &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29dddd8ca2fe8a806f189d92127cef817ecb30da" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; regardless of the value of &lt;code&gt;lucky?&lt;/code&gt;. The variable &lt;code&gt;value&lt;/code&gt; bound in the clause and the variable &lt;code&gt;value&lt;/code&gt; bound in the outer context are two entirely separate variables.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;value&lt;/code&gt; будет &lt;code&gt;7&lt;/code&gt; независимо от значения &lt;code&gt;lucky?&lt;/code&gt; . Переменная &lt;code&gt;value&lt;/code&gt; связана в предложении и переменной &lt;code&gt;value&lt;/code&gt; , связанной во внешнем контексте две совершенно отдельные переменные.</target>
        </trans-unit>
        <trans-unit id="72cbf21e3fa3d74880817514a949e8994722f839" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; cannot be accessed since it was defined inside the &lt;code&gt;try&lt;/code&gt; clause. A common practice to address this issue is to return the variables defined inside &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">В приведенном выше примере к &lt;code&gt;x&lt;/code&gt; нельзя получить доступ, поскольку он был определен внутри предложения &lt;code&gt;try&lt;/code&gt; . Обычная практика решения этой проблемы - вернуть переменные, определенные внутри &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6f83ecedbf7273a5aa4b952ec92a7a095991da80" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; starts without a value and has &lt;code&gt;1&lt;/code&gt; assigned to it. Then, we compare the value of &lt;code&gt;x&lt;/code&gt; to the literal &lt;code&gt;1&lt;/code&gt;, which succeeds as they are both &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;x&lt;/code&gt; начинается без значения и ему присвоено значение &lt;code&gt;1&lt;/code&gt; . Затем мы сравниваем значение &lt;code&gt;x&lt;/code&gt; с литералом &lt;code&gt;1&lt;/code&gt; , который успешен, поскольку оба они равны &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bed3d677daa97ab1f5b51e489879c2e74facf10" translate="yes" xml:space="preserve">
          <source>In the example above, a &lt;code&gt;sum/2&lt;/code&gt; function is defined; this function receives two arguments and returns their sum.</source>
          <target state="translated">В приведенном выше примере определена функция &lt;code&gt;sum/2&lt;/code&gt; ; эта функция получает два аргумента и возвращает их сумму.</target>
        </trans-unit>
        <trans-unit id="9fb262ec317cb005dd946c4cd7d04d84b1f69668" translate="yes" xml:space="preserve">
          <source>In the example above, a set of macros named &lt;code&gt;user&lt;/code&gt; but with different arities will be defined to manipulate the underlying record.</source>
          <target state="translated">В приведенном выше примере для управления базовой записью будет определен набор макросов с именем &lt;code&gt;user&lt;/code&gt; , но с разной арностью.</target>
        </trans-unit>
        <trans-unit id="0c0f218463838143ec4982ca79e4ec70bc05323d" translate="yes" xml:space="preserve">
          <source>In the example above, a supervisor was started by passing the supervision structure to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;. However, supervisors can also be created by explicitly defining a supervision module:</source>
          <target state="translated">В приведенном выше примере супервизор был запущен передачей структуры супервизора в &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; . Однако супервизоры также могут быть созданы путем явного определения модуля контроля:</target>
        </trans-unit>
        <trans-unit id="442ca993474ce04915ab444e69370d1fd701d187" translate="yes" xml:space="preserve">
          <source>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module allows us to map the range, without triggering its enumeration:</source>
          <target state="translated">В приведенном выше примере, когда мы отображали диапазон, перечисляемые элементы были созданы один за другим во время перечисления. Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; позволяет нам отображать диапазон, не вызывая его перечисление:</target>
        </trans-unit>
        <trans-unit id="73b31064dddafd7aceb7c6dd33acb2dfd723e612" translate="yes" xml:space="preserve">
          <source>In the example above, by using &lt;code&gt;TestCase&lt;/code&gt;, we can write tests using the &lt;code&gt;test&lt;/code&gt; macro, which defines a function named &lt;code&gt;run&lt;/code&gt; to automatically run all tests for us. Our prototype will rely on the match operator (&lt;code&gt;=&lt;/code&gt;) as a mechanism to do assertions.</source>
          <target state="translated">В приведенном выше примере, используя &lt;code&gt;TestCase&lt;/code&gt; , мы можем писать тесты, используя &lt;code&gt;test&lt;/code&gt; макрос, который определяет функцию с именем &lt;code&gt;run&lt;/code&gt; для автоматического запуска всех тестов за нас. Наш прототип будет полагаться на оператор сопоставления ( &lt;code&gt;=&lt;/code&gt; ) как на механизм для выполнения утверждений.</target>
        </trans-unit>
        <trans-unit id="f3bbbdd7b6d7f4d0dd2d5c03396c880a058ec265" translate="yes" xml:space="preserve">
          <source>In the example above, even though the macro injects &lt;code&gt;a = 1&lt;/code&gt;, it does not affect the variable &lt;code&gt;a&lt;/code&gt; defined by the &lt;code&gt;go&lt;/code&gt; function. If a macro wants to explicitly affect the context, it can use &lt;code&gt;var!&lt;/code&gt;:</source>
          <target state="translated">В приведенном выше примере, хотя макрос вводит &lt;code&gt;a = 1&lt;/code&gt; , он не влияет на переменную &lt;code&gt;a&lt;/code&gt; , определенную функцией &lt;code&gt;go&lt;/code&gt; . Если макрос хочет явно повлиять на контекст, он может использовать &lt;code&gt;var!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="df21e3e8f902f80311e9ed366624d965e22d8f36" translate="yes" xml:space="preserve">
          <source>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">В приведенном выше примере, даже если в правом списке больше записей, чем в левом, деструктуризация работает нормально. Если правый список меньше, остальные элементы просто устанавливаются &lt;code&gt;nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad9447b0ab139bf0ce77de940f7116ad1118f9e7" translate="yes" xml:space="preserve">
          <source>In the example above, pattern matching works because underneath structs are bare maps with a fixed set of fields. As maps, structs store a &amp;ldquo;special&amp;rdquo; field named &lt;code&gt;__struct__&lt;/code&gt; that holds the name of the struct:</source>
          <target state="translated">В приведенном выше примере сопоставление с образцом работает, потому что под структурами находятся голые карты с фиксированным набором полей. Как и карты, структуры хранят &amp;laquo;специальное&amp;raquo; поле с именем &lt;code&gt;__struct__&lt;/code&gt; , которое содержит имя структуры:</target>
        </trans-unit>
        <trans-unit id="dae57a394eb52ab25120ea39543d455089abff36" translate="yes" xml:space="preserve">
          <source>In the example above, since we are invoking &lt;code&gt;alias&lt;/code&gt; inside the function &lt;code&gt;plus/2&lt;/code&gt;, the alias will be valid only inside the function &lt;code&gt;plus/2&lt;/code&gt;. &lt;code&gt;minus/2&lt;/code&gt; won&amp;rsquo;t be affected at all.</source>
          <target state="translated">В приведенном выше примере, поскольку мы вызываем &lt;code&gt;alias&lt;/code&gt; внутри функции &lt;code&gt;plus/2&lt;/code&gt; , псевдоним будет действителен только внутри функции &lt;code&gt;plus/2&lt;/code&gt; . &lt;code&gt;minus/2&lt;/code&gt; никак не повлияет.</target>
        </trans-unit>
        <trans-unit id="062b7f604b56dd870819716494d195af709ce6fe" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;|&amp;gt;&lt;/code&gt; pipe is the right-most pipe; &lt;code&gt;arg1&lt;/code&gt; is the AST for &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt;, and &lt;code&gt;arg2&lt;/code&gt; is the AST for &lt;code&gt;div(2)&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере канал &lt;code&gt;|&amp;gt;&lt;/code&gt; - это крайний правый канал; &lt;code&gt;arg1&lt;/code&gt; - это AST для &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt; , а &lt;code&gt;arg2&lt;/code&gt; - это AST для &lt;code&gt;div(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3764d5750387486a4a8182c32859bf0c44e3a53a" translate="yes" xml:space="preserve">
          <source>In the example above, the imported &lt;code&gt;List.duplicate/2&lt;/code&gt; is only visible within that specific function. &lt;code&gt;duplicate/2&lt;/code&gt; won&amp;rsquo;t be available in any other function in that module (or any other module for that matter).</source>
          <target state="translated">В приведенном выше примере импортированный &lt;code&gt;List.duplicate/2&lt;/code&gt; виден только внутри этой конкретной функции. &lt;code&gt;duplicate/2&lt;/code&gt; не будет доступен ни в одной другой функции этого модуля (или любого другого модуля в этом отношении).</target>
        </trans-unit>
        <trans-unit id="a9ba96d97b36e1f6537a9985e8f45706e25424fa" translate="yes" xml:space="preserve">
          <source>In the example above, the linked process died by sending an &lt;code&gt;exit&lt;/code&gt; signal with a value of 1. The Elixir shell automatically handles those messages and prints them to the terminal.</source>
          <target state="translated">В приведенном выше примере связанный процесс остановился, послав сигнал &lt;code&gt;exit&lt;/code&gt; со значением 1. Оболочка Elixir автоматически обрабатывает эти сообщения и выводит их на терминал.</target>
        </trans-unit>
        <trans-unit id="4c70f5b2fc854619c8625c6a22c3a81ffb99e2fe" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="translated">В приведенном выше примере список &lt;code&gt;[1, [2], 3]&lt;/code&gt; передается в качестве первого аргумента функции &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#flatten/1&quot;&gt; &lt;code&gt;List.flatten/1&lt;/code&gt; &lt;/a&gt; , затем сведенный список передается в качестве первого аргумента функции &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; ,&lt;/a&gt; которая удваивает каждый элемент списка.</target>
        </trans-unit>
        <trans-unit id="df1a4779609dfb3efd8db910186e109c073a0338" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;list#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="translated">В приведенном выше примере список &lt;code&gt;[1, [2], 3]&lt;/code&gt; передается в качестве первого аргумента функции &lt;a href=&quot;list#flatten/1&quot;&gt; &lt;code&gt;List.flatten/1&lt;/code&gt; &lt;/a&gt; , затем сведенный список передается в качестве первого аргумента функции &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; ,&lt;/a&gt; которая удваивает каждый элемент списка.</target>
        </trans-unit>
        <trans-unit id="30a372309337ceccb6cd8c47007e31bef89794f8" translate="yes" xml:space="preserve">
          <source>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</source>
          <target state="translated">В приведенном выше примере оболочка будет ожидать больше входных данных до тех пор,пока не найдет закрывающую котировку.Иногда неясно,какого символа ожидает оболочка,и пользователь может оказаться в состоянии неполного выражения,не имея возможности закончить его,кроме как выйдя из оболочки.</target>
        </trans-unit>
        <trans-unit id="2c1055e1dbf2125278d879200ab263f9e383b43c" translate="yes" xml:space="preserve">
          <source>In the example above, this happens:</source>
          <target state="translated">В приведенном выше примере такое случается:</target>
        </trans-unit>
        <trans-unit id="c8625f3069f10910c0e9de120b21d6981d601654" translate="yes" xml:space="preserve">
          <source>In the example above, two modules - &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt; - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module &lt;code&gt;Foo.Bar&lt;/code&gt; to be accessed as &lt;code&gt;Bar&lt;/code&gt; in the same lexical scope where it's defined (the &lt;code&gt;Foo&lt;/code&gt; module). This only happens if the nested module is defined via an alias.</source>
          <target state="translated">В приведенном выше примере созданы два модуля - &lt;code&gt;Foo&lt;/code&gt; и &lt;code&gt;Foo.Bar&lt;/code&gt; . При вложении Elixir автоматически создает псевдоним для внутреннего модуля, позволяя получить доступ ко второму модулю &lt;code&gt;Foo.Bar&lt;/code&gt; как &lt;code&gt;Bar&lt;/code&gt; в той же лексической области, где он определен ( модуль &lt;code&gt;Foo&lt;/code&gt; ). Это происходит только в том случае, если вложенный модуль определен через псевдоним.</target>
        </trans-unit>
        <trans-unit id="cee742c4ffa43a93d2e20f415d5f42aefbd9bd95" translate="yes" xml:space="preserve">
          <source>In the example above, we are explicitly setting the version attribute for that module. &lt;code&gt;@vsn&lt;/code&gt; is used by the code reloading mechanism in the Erlang</source>
          <target state="translated">В приведенном выше примере мы явно устанавливаем атрибут версии для этого модуля. &lt;code&gt;@vsn&lt;/code&gt; используется механизмом перезагрузки кода в Erlang</target>
        </trans-unit>
        <trans-unit id="a373d89a73cb82089c1340de9b4a2f42e3a9dea1" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. However, data structures in Elixir are immutable. For this reason, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="translated">В приведенном выше примере мы изменяем как массив, так и переменную &lt;code&gt;i&lt;/code&gt; . Однако структуры данных в Elixir неизменяемы. По этой причине функциональные языки полагаются на рекурсию: функция вызывается рекурсивно, пока не будет достигнуто условие, останавливающее продолжение рекурсивного действия. Никакие данные не изменяются в этом процессе. Рассмотрим приведенный ниже пример, в котором строка печатается произвольное количество раз:</target>
        </trans-unit>
        <trans-unit id="021f23fc44f1b5057c72ccb35305764a702bc70f" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. Mutating is not possible in Elixir. Instead, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="translated">В приведенном выше примере мы изменяем как массив, так и переменную &lt;code&gt;i&lt;/code&gt; . В Эликсире мутации невозможны. Вместо этого функциональные языки полагаются на рекурсию: функция вызывается рекурсивно до тех пор, пока не будет достигнуто условие, останавливающее продолжение рекурсивного действия. Никакие данные не изменяются в этом процессе. Рассмотрим приведенный ниже пример, в котором строка печатается произвольное количество раз:</target>
        </trans-unit>
        <trans-unit id="d5006566e063521dde7ab998be88e6cd1a64640e" translate="yes" xml:space="preserve">
          <source>In the example above, we can access the value &lt;code&gt;foo&lt;/code&gt; under the binding &lt;code&gt;assigns&lt;/code&gt; using &lt;code&gt;@foo&lt;/code&gt;. This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set.</source>
          <target state="translated">В приведенном выше примере, можно получить доступ к значению &lt;code&gt;foo&lt;/code&gt; под связыванием &lt;code&gt;assigns&lt;/code&gt; с использованием &lt;code&gt;@foo&lt;/code&gt; . Это полезно, потому что шаблон после компиляции может получать разные назначения и не требует перекомпиляции для каждого набора переменных.</target>
        </trans-unit>
        <trans-unit id="67d3a850b4e721008a9a33c249f890ed36ddb4d7" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="translated">В приведенном выше примере мы захватили &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_atom/1&quot;&gt; &lt;code&gt;Kernel.is_atom/1&lt;/code&gt; &lt;/a&gt; как анонимную функцию, а затем вызвали ее.</target>
        </trans-unit>
        <trans-unit id="5661752d4cc9fd9fdd4a2d139f2888ecb877cbf6" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;kernel#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="translated">В приведенном выше примере мы захватили &lt;a href=&quot;kernel#is_atom/1&quot;&gt; &lt;code&gt;Kernel.is_atom/1&lt;/code&gt; &lt;/a&gt; как анонимную функцию, а затем вызвали ее.</target>
        </trans-unit>
        <trans-unit id="ca7f8c9d2062b97da89273704dad9ed0703a8452" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">В приведенном выше примере мы создаем задачи, которые спят от 1 до 10 секунд и возвращают количество секунд, в течение которых они спали. Если вы выполните весь код сразу, вы должны увидеть от 1 до 5 напечатанных, поскольку это были задачи, на которые был дан ответ в заданное время. Все остальные задачи будут закрыты с помощью &lt;a href=&quot;#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3bbf3a8f78417d03c53c8a99adeb57f91aa4785" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">В приведенном выше примере мы создаем задачи, которые спят от 1 до 10 секунд и возвращают количество секунд, в течение которых они спали. Если вы выполните весь код сразу, вы должны увидеть от 1 до 5 напечатанных, поскольку это были задачи, на которые был дан ответ в заданное время. Все остальные задачи будут закрыты с помощью &lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43dbb6ffa3efa205c169cb0eb943acb32507c0e1" translate="yes" xml:space="preserve">
          <source>In the example above, we defined an anonymous function that receives two arguments, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and returns the result of &lt;code&gt;a + b&lt;/code&gt;. The arguments are always on the left-hand side of &lt;code&gt;-&amp;gt;&lt;/code&gt; and the code to be executed on the right-hand side. The anonymous function is stored in the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере мы определили анонимную функцию, которая получает два аргумента, &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , и возвращает результат &lt;code&gt;a + b&lt;/code&gt; . Аргументы всегда находятся слева от &lt;code&gt;-&amp;gt;&lt;/code&gt; , а код, который нужно выполнить, - справа. Анонимная функция хранится в переменной &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2957729dcc7602ce0c24fbab3553e81f82dbdc" translate="yes" xml:space="preserve">
          <source>In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options:</source>
          <target state="translated">В приведенном выше примере мы определили спецификации для рабочих и руководителей.Эти спецификации (как для рабочих,так и для руководителей)допускают следующие варианты:</target>
        </trans-unit>
        <trans-unit id="5e6b4da92c054f57ac5d7ebeeafc523687c5adff" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on UNIX systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="translated">В приведенном выше примере мы создали новый порт, который выполняет программу &lt;code&gt;cat&lt;/code&gt; . &lt;code&gt;cat&lt;/code&gt; - это программа, доступная в системах UNIX, которая получает данные из нескольких входов и объединяет их в выходных данных.</target>
        </trans-unit>
        <trans-unit id="156803f5c97e61fd27214bc1371c5ad133572347" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on Unix-like operating systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="translated">В приведенном выше примере мы создали новый порт, который выполняет программу &lt;code&gt;cat&lt;/code&gt; . &lt;code&gt;cat&lt;/code&gt; - это программа, доступная в Unix-подобных операционных системах, которая получает данные из нескольких входов и объединяет их на выходе.</target>
        </trans-unit>
        <trans-unit id="b0e39547d1868b820dfb08e74cce03806dbaf13c" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a tag called &lt;code&gt;:cd&lt;/code&gt; that is read in the setup callback to configure the working directory the test is going to run on.</source>
          <target state="translated">В приведенном выше примере мы определили тег с именем &lt;code&gt;:cd&lt;/code&gt; , который считывается в обратном вызове установки для настройки рабочего каталога, в котором будет запускаться тест.</target>
        </trans-unit>
        <trans-unit id="0fd333e5963bb492deae7a782ebcecbae48824d5" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined an alias named &lt;code&gt;mix all&lt;/code&gt;, that prints &quot;Hello world&quot;, then fetches dependencies specific to the current environment, and compiles the project.</source>
          <target state="translated">В приведенном выше примере мы определили псевдоним с именем &lt;code&gt;mix all&lt;/code&gt; , который печатает &amp;laquo;Hello world&amp;raquo;, затем выбирает зависимости, специфичные для текущей среды, и компилирует проект.</target>
        </trans-unit>
        <trans-unit id="660bac6b0180ebfa96d383b78487f5cdbac50030" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="translated">В приведенном выше примере мы определили два псевдонима. Один из них - это &lt;code&gt;mix c&lt;/code&gt; , который является ярлыком для &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; . Другой называется &lt;code&gt;mix hello&lt;/code&gt; , что эквивалентно &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; ,которое мы определили в разделе &amp;laquo;Mix.Task&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b55e3dbdcda3974f9c85104c4aab9938de0f3064" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="translated">В приведенном выше примере мы определили два псевдонима. Один из них - это &lt;code&gt;mix c&lt;/code&gt; , который является ярлыком для &lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; . Другой называется &lt;code&gt;mix hello&lt;/code&gt; , что эквивалентно &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; ,которое мы определили в разделе &amp;laquo;Mix.Task&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="61eada0cb9cbd1b50540cd6782b9dfeead876351" translate="yes" xml:space="preserve">
          <source>In the example above, we have generated the functions &lt;code&gt;foo/0&lt;/code&gt; and &lt;code&gt;bar/0&lt;/code&gt; dynamically. Now, imagine that we want to convert this functionality into a macro:</source>
          <target state="translated">В приведенном выше примере мы сгенерировали функции &lt;code&gt;foo/0&lt;/code&gt; и &lt;code&gt;bar/0&lt;/code&gt; динамически. Теперь представьте, что мы хотим преобразовать эту функциональность в макрос:</target>
        </trans-unit>
        <trans-unit id="eb997411d2a35ea49834890c6520f8f8d681bd86" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере мы настроили &lt;code&gt;MyKeyword&lt;/code&gt; для псевдонима &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; . Итак, теперь любая ссылка на &lt;code&gt;MyKeyword&lt;/code&gt; &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; будет автоматически заменена на MyKeyword .</target>
        </trans-unit>
        <trans-unit id="5c4c73a0b16c4020cd89858453c999ce24f50d3b" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере мы настроили &lt;code&gt;MyKeyword&lt;/code&gt; для псевдонима &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; . Итак, теперь любая ссылка на &lt;code&gt;MyKeyword&lt;/code&gt; &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; будет автоматически заменена на MyKeyword .</target>
        </trans-unit>
        <trans-unit id="053a645de735a836658d24ec36de529750445dbd" translate="yes" xml:space="preserve">
          <source>In the example above, we have used the &lt;code&gt;plug/1&lt;/code&gt; macro to connect functions that will be invoked when there is a web request. Internally, every time you call &lt;code&gt;plug/1&lt;/code&gt;, the Plug library stores the given argument in a &lt;code&gt;@plugs&lt;/code&gt; attribute. Just before the module is compiled, Plug runs a callback that defines a function (&lt;code&gt;call/2&lt;/code&gt;) which handles HTTP requests. This function will run all plugs inside &lt;code&gt;@plugs&lt;/code&gt; in order.</source>
          <target state="translated">В приведенном выше примере мы использовали макрос &lt;code&gt;plug/1&lt;/code&gt; для подключения функций, которые будут вызываться при наличии веб-запроса. Внутри каждый раз, когда вы вызываете &lt;code&gt;plug/1&lt;/code&gt; , библиотека Plug сохраняет заданный аргумент в &lt;code&gt;@plugs&lt;/code&gt; . Непосредственно перед компиляцией модуля Plug запускает обратный вызов, который определяет функцию ( &lt;code&gt;call/2&lt;/code&gt; ), которая обрабатывает HTTP-запросы. Эта функция запустит все разъемы внутри &lt;code&gt;@plugs&lt;/code&gt; по порядку.</target>
        </trans-unit>
        <trans-unit id="245b9813cb08572f08e7ce35fd5f72dcd40372ab" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="translated">В приведенном выше примере мы импортировали макросы из &lt;code&gt;MyMacros&lt;/code&gt; , заменив исходную реализацию &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; нашей собственной в этой конкретной функции. Все остальные функции в этом модуле по-прежнему смогут использовать исходную.</target>
        </trans-unit>
        <trans-unit id="d04cc9035f609252303b7cf3699ee2289f736ec0" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="translated">В приведенном выше примере мы импортировали макросы из &lt;code&gt;MyMacros&lt;/code&gt; , заменив исходную реализацию &lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; нашей собственной в этой конкретной функции. Все остальные функции в этом модуле по-прежнему смогут использовать исходную.</target>
        </trans-unit>
        <trans-unit id="143be83aa54f7c530d19333f4615426ffc2f8abd" translate="yes" xml:space="preserve">
          <source>In the example above, we match &lt;code&gt;thing&lt;/code&gt; against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches.</source>
          <target state="translated">В приведенном выше примере мы сопоставляем &lt;code&gt;thing&lt;/code&gt; с каждым предложением &amp;laquo;head&amp;raquo; и выполняем предложение &amp;laquo;body&amp;raquo;, соответствующее первому совпадающему предложению.</target>
        </trans-unit>
        <trans-unit id="6b838b0193a4108fff85d3563dd635cc22b74b28" translate="yes" xml:space="preserve">
          <source>In the example above, we pass a string with &lt;code&gt;\n&lt;/code&gt; escaped and return a version with it unescaped.</source>
          <target state="translated">В приведенном выше примере мы передаем строку с экранированием &lt;code&gt;\n&lt;/code&gt; и возвращаем версию без экранирования.</target>
        </trans-unit>
        <trans-unit id="d7a1701f06e939aba29cc4e178e9955eb9fec15b" translate="yes" xml:space="preserve">
          <source>In the example above, we prefixed the function names with the command name used to execute them, but that is entirely optional.</source>
          <target state="translated">В приведенном выше примере мы префиксовали имена функций с именем команды,используемой для их выполнения,но это совершенно необязательно.</target>
        </trans-unit>
        <trans-unit id="e34b35a1a0f6a7ae64d902f20f6d3b6957890f8c" translate="yes" xml:space="preserve">
          <source>In the example above, we show how guards can be used in function clauses. There are several constructs that allow guards; for example:</source>
          <target state="translated">В примере выше мы покажем,как можно использовать защитные элементы в функциональных клаузулах.Есть несколько конструкций,которые позволяют использовать защитные клаузулы,например:</target>
        </trans-unit>
        <trans-unit id="e73b208830253cfcccda8b595f6a7fc37ec019c4" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and ask for the number of keys in the registry:</source>
          <target state="translated">В примере ниже мы регистрируем текущий процесс и запрашиваем количество ключей в реестре:</target>
        </trans-unit>
        <trans-unit id="600451af2621db08950612f2b8a384ceb1caba3b" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and look it up both from itself and other processes:</source>
          <target state="translated">В примере ниже мы регистрируем текущий процесс и ищем его как от себя,так и от других процессов:</target>
        </trans-unit>
        <trans-unit id="798fe8739fe086fd76b2f2f854df6fe2d36c1741" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process under the same key in a duplicate registry but with different values:</source>
          <target state="translated">В примере ниже мы регистрируем текущий процесс под одним и тем же ключом в дублирующем реестре,но с разными значениями:</target>
        </trans-unit>
        <trans-unit id="78080544e53670fa0133b74d89a92858bb262655" translate="yes" xml:space="preserve">
          <source>In the example below, we have a macro that generates a module with a function named &lt;code&gt;name_length&lt;/code&gt; that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</source>
          <target state="translated">В приведенном ниже примере у нас есть макрос, который генерирует модуль с функцией &lt;code&gt;name_length&lt;/code&gt; , которая возвращает длину имени модуля. Значение этой функции будет вычислено во время компиляции, а не во время выполнения.</target>
        </trans-unit>
        <trans-unit id="f8f1d08583916da8a72b67e1316644cdd98dc53a" translate="yes" xml:space="preserve">
          <source>In the example below, we pass a directory to where the &lt;a href=&quot;#c/2&quot;&gt;&lt;code&gt;c/2&lt;/code&gt;&lt;/a&gt; function will write the compiled &lt;code&gt;.beam&lt;/code&gt; files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems:</source>
          <target state="translated">В приведенном ниже примере мы передаем каталог, в который функция &lt;a href=&quot;#c/2&quot;&gt; &lt;code&gt;c/2&lt;/code&gt; &lt;/a&gt; будет записывать скомпилированные файлы &lt;code&gt;.beam&lt;/code&gt; . Этот каталог обычно называется &quot;ebin&quot; в системах Erlang / Elixir:</target>
        </trans-unit>
        <trans-unit id="15375188c3b299d4050635b90946ba7afce11069" translate="yes" xml:space="preserve">
          <source>In the example below, we use a function to get all the maps inside a list:</source>
          <target state="translated">В примере ниже мы используем функцию для получения всех карт в списке:</target>
        </trans-unit>
        <trans-unit id="7b9f19cdead9cbae542d5210ec70e748cea04410" translate="yes" xml:space="preserve">
          <source>In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the &lt;code&gt;:into&lt;/code&gt; option to the comprehension.</source>
          <target state="translated">В приведенных выше примерах все интерпретации возвращали списки в качестве своего результата. Однако результат понимания может быть вставлен в разные структуры данных, передав параметр &lt;code&gt;:into&lt;/code&gt; в понимание.</target>
        </trans-unit>
        <trans-unit id="e7b33831c78babc5b4b6a0cc0e2347ac123865c0" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">В приведенных выше примерах результат, возвращаемый пониманием, всегда был списком. Возвращаемый результат можно настроить, передав параметр &lt;code&gt;:into&lt;/code&gt; , который принимает любую структуру, если она реализует протокол &lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73e547c48fc4efe942c1938b956ce334b82c040a" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">В приведенных выше примерах результат, возвращаемый пониманием, всегда был списком. Возвращаемый результат можно настроить, передав параметр &lt;code&gt;:into&lt;/code&gt; , который принимает любую структуру, если она реализует протокол &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dec1f7ea6cca2c448adce8e9cc2f35e0ad761d20" translate="yes" xml:space="preserve">
          <source>In the examples above, we have used the match operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/a&gt;) and function clauses to showcase patterns and guards respectively. Here is the list of the built-in constructs in Elixir that support patterns and guards.</source>
          <target state="translated">В приведенных выше примерах мы использовали оператор сопоставления ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt; &lt;code&gt;=&lt;/code&gt; &lt;/a&gt; ) и предложения функций для демонстрации шаблонов и средств защиты соответственно. Вот список встроенных в Elixir конструкций, которые поддерживают шаблоны и охранники.</target>
        </trans-unit>
        <trans-unit id="d0daacadfe9f7077fb5dcbe6bf521a065a6a635d" translate="yes" xml:space="preserve">
          <source>In the expression above, &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; is the &lt;strong&gt;generator&lt;/strong&gt;. It is literally generating values to be used in the comprehension. Any enumerable can be passed on the right-hand side of the generator expression:</source>
          <target state="translated">В приведенном выше выражении &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; является &lt;strong&gt;генератором&lt;/strong&gt; . Он буквально генерирует значения, которые будут использоваться в понимании. В правой части выражения генератора можно передать любое перечислимое значение:</target>
        </trans-unit>
        <trans-unit id="5f3acf5fd7cb6799236adf41693aa239ed339ba4" translate="yes" xml:space="preserve">
          <source>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</source>
          <target state="translated">В первом примере акцент стоит перед гласной,поэтому он считается двумя графами.Однако,когда вы один раз перевернете ее,за гласной следует ударение,которое становится одной графемой.Перевернув её ещё раз,вы сохраните её как одну графему.</target>
        </trans-unit>
        <trans-unit id="81851c5f2cda0fa01d07a6553b4cc2343064b54a" translate="yes" xml:space="preserve">
          <source>In the first scenario, a lock is received in &lt;code&gt;opts&lt;/code&gt; and the repository must be updated to the lock. In the second, no lock is given and the repository can be updated freely.</source>
          <target state="translated">В первом сценарии блокировка получена в &lt;code&gt;opts&lt;/code&gt; , и репозиторий должен быть обновлен до блокировки. Во втором случае блокировка отсутствует, и репозиторий можно свободно обновлять.</target>
        </trans-unit>
        <trans-unit id="edabe1bf622029e68e1aff637ff6cf8ec47fb508" translate="yes" xml:space="preserve">
          <source>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. It&amp;rsquo;s about time for us to learn how to compile Elixir code and also how to run Elixir scripts.</source>
          <target state="translated">В следующих разделах наши примеры будут увеличиваться в размере, и может быть сложно ввести их все в оболочку. Пора нам узнать, как компилировать код на Эликсире, а также как запускать сценарии на Эликсире.</target>
        </trans-unit>
        <trans-unit id="ea21b7568312a339bf9ae152813dc701fedd0816" translate="yes" xml:space="preserve">
          <source>In the next chapter, we are going to discuss pattern matching through the use of &lt;code&gt;=&lt;/code&gt;, the match operator.</source>
          <target state="translated">В следующей главе мы собираемся обсудить сопоставление с образцом с помощью &lt;code&gt;=&lt;/code&gt; , оператора сопоставления.</target>
        </trans-unit>
        <trans-unit id="d8135bc13d648cc8121bc02383bb281b2bb322ce" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will explore GenServers, where the segregation between clients and servers is made more apparent.</source>
          <target state="translated">В следующей главе мы рассмотрим GenServers,где более четко прослеживается разделение между клиентами и серверами.</target>
        </trans-unit>
        <trans-unit id="71fe1559a8acce4f8cb459f05a93f2c23c27af01" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will start parsing the client requests and sending responses, finishing our server.</source>
          <target state="translated">В следующей главе мы начнем разбирать клиентские запросы и посылать ответы,завершив работу над нашим сервером.</target>
        </trans-unit>
        <trans-unit id="97a27cfc769eb0315701a749f650534e93e63132" translate="yes" xml:space="preserve">
          <source>In the next chapters, we&amp;rsquo;ll explore structs and protocols before moving to exception handling and other constructs like sigils and comprehensions.</source>
          <target state="translated">В следующих главах мы исследуем структуры и протоколы, прежде чем перейти к обработке исключений и другим конструкциям, таким как сигилы и понимания.</target>
        </trans-unit>
        <trans-unit id="83c96bdabbdcc08e2e498fa4f73aafa1f188be21" translate="yes" xml:space="preserve">
          <source>In the previous chapter about &lt;code&gt;GenServer&lt;/code&gt;, we implemented &lt;code&gt;KV.Registry&lt;/code&gt; to manage buckets. At some point, we started monitoring buckets so we were able to take action whenever a &lt;code&gt;KV.Bucket&lt;/code&gt; crashed. Although the change was relatively small, it introduced a question which is frequently asked by Elixir developers: what happens when something fails?</source>
          <target state="translated">В предыдущей главе о &lt;code&gt;GenServer&lt;/code&gt; мы реализовали &lt;code&gt;KV.Registry&lt;/code&gt; для управления бакетами. В какой-то момент мы начали отслеживать ведра, чтобы иметь возможность принимать меры при &lt;code&gt;KV.Bucket&lt;/code&gt; строя KV.Bucket . Хотя изменение было относительно небольшим, оно вызвало вопрос, который часто задают разработчики Elixir: что происходит, когда что-то выходит из строя?</target>
        </trans-unit>
        <trans-unit id="7c0c1e10201013cbed4ae2f15c5fb7856de2269f" translate="yes" xml:space="preserve">
          <source>In the previous chapters, we have always started processes directly. For example, we would call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;, which would return &lt;code&gt;{:ok, pid}&lt;/code&gt;, and that would allow us to interact with the registry via its &lt;code&gt;pid&lt;/code&gt;. Now that processes are started by the supervisor, we have to directly ask the supervisor who its children are, and fetch the pid from the returned list of children. In practice, doing so every time would be very expensive. To address this, we often give names to processes, allowing them to be uniquely identified in a single machine from anywhere in our code.</source>
          <target state="translated">В предыдущих главах мы всегда запускали процессы напрямую. Например, мы могли бы вызвать &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; , который вернет &lt;code&gt;{:ok, pid}&lt;/code&gt; , и это позволит нам взаимодействовать с реестром через его &lt;code&gt;pid&lt;/code&gt; . Теперь, когда процессы запускаются супервизором, мы должны напрямую спросить супервизора, кто его дочерние элементы, и получить pid из возвращенного списка потомков. На практике делать это каждый раз было бы очень дорого. Чтобы решить эту проблему, мы часто даем имена процессам, что позволяет им однозначно идентифицировать на одной машине из любой точки нашего кода.</target>
        </trans-unit>
        <trans-unit id="d89af771bb31edf816f69ac576dd476d68e9b7c3" translate="yes" xml:space="preserve">
          <source>In the previous example, we read the application environment at runtime:</source>
          <target state="translated">В предыдущем примере мы читали среду приложений во время выполнения:</target>
        </trans-unit>
        <trans-unit id="023e1eab071b1e9447d8611d553a6798a82a86d3" translate="yes" xml:space="preserve">
          <source>In the previous example, we were not interested in associating a value to the process:</source>
          <target state="translated">В предыдущем примере нам не было интересно ассоциировать значение с процессом:</target>
        </trans-unit>
        <trans-unit id="59cfb6ab9287629bc99d4335b390c03667b20499" translate="yes" xml:space="preserve">
          <source>In the returned result, keys are variable names and values are the corresponding variable values.</source>
          <target state="translated">В возвращаемом результате ключами являются имена переменных,а значения-соответствующие значения переменных.</target>
        </trans-unit>
        <trans-unit id="de1b308ba8fcb658982badee13287d07ac9706b3" translate="yes" xml:space="preserve">
          <source>In the second line of the failure, right below the test name, there is the location where the test was defined. If you copy the test location in full, including the file and line number, and append it to &lt;code&gt;mix test&lt;/code&gt;, Mix will load and run just that particular test:</source>
          <target state="translated">Во второй строке ошибки, прямо под названием теста, указано место, где был определен тест. Если вы скопируете тестовую локацию полностью, включая файл и номер строки, и добавите ее в &lt;code&gt;mix test&lt;/code&gt; , Mix загрузит и запустит только этот конкретный тест:</target>
        </trans-unit>
        <trans-unit id="f677b0be0ad961b242015e2787d48da5351af3eb" translate="yes" xml:space="preserve">
          <source>In the sections above, we have configured an application in the &lt;code&gt;application/0&lt;/code&gt; section of the &lt;code&gt;mix.exs&lt;/code&gt; file. Ultimately, Mix will use this configuration to create an &lt;a href=&quot;http://erlang.org/doc/man/app.html&quot;&gt;&lt;em&gt;application resource file&lt;/em&gt;&lt;/a&gt;, which is a file called &lt;code&gt;APP_NAME.app&lt;/code&gt;. For example, the application resource file of the OTP application &lt;code&gt;ex_unit&lt;/code&gt; is called &lt;code&gt;ex_unit.app&lt;/code&gt;.</source>
          <target state="translated">В предыдущих разделах мы настроили приложение в &lt;code&gt;application/0&lt;/code&gt; секции &lt;code&gt;mix.exs&lt;/code&gt; файла. В конечном итоге Mix будет использовать эту конфигурацию для создания &lt;a href=&quot;http://erlang.org/doc/man/app.html&quot;&gt;&lt;em&gt;файла ресурсов приложения&lt;/em&gt;&lt;/a&gt; , который является файлом &lt;code&gt;APP_NAME.app&lt;/code&gt; . Например, файл ресурсов приложения OTP-приложения &lt;code&gt;ex_unit&lt;/code&gt; называется &lt;code&gt;ex_unit.app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56699ac32b40ebbed14cd456a076f153ca769c75" translate="yes" xml:space="preserve">
          <source>In the session above we interacted with the &amp;ldquo;shopping&amp;rdquo; bucket.</source>
          <target state="translated">В предыдущем сеансе мы взаимодействовали с корзиной &amp;laquo;покупки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="99f7aeec7f3d83fb7c14ef77613795b1757f5d28" translate="yes" xml:space="preserve">
          <source>In this case, the answer is yes: if the acceptor crashes, there is no need to crash the existing connections. On the other hand, if the task supervisor crashes, there is no need to crash the acceptor too.</source>
          <target state="translated">В этом случае ответ &quot;да&quot;:если акцептор выйдет из строя,то нет необходимости прерывать существующие соединения.С другой стороны,в случае падения диспетчера задач нет необходимости и в падении акцептора.</target>
        </trans-unit>
        <trans-unit id="c5b73c40f211641ff7fce3baa3df52cd94ce14cd" translate="yes" xml:space="preserve">
          <source>In this case, there is no module, so we picked the name &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;. It could have been any other name. We also chose the &lt;code&gt;:one_for_one&lt;/code&gt; strategy, which is currently the only available strategy for dynamic supervisors.</source>
          <target state="translated">В данном случае модуля нет, поэтому мы выбрали имя &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; . Это могло быть любое другое имя. Мы также выбрали стратегию &lt;code&gt;:one_for_one&lt;/code&gt; , которая в настоящее время является единственной доступной стратегией для динамических супервизоров.</target>
        </trans-unit>
        <trans-unit id="69b79e652a12895505240a6d60f23b561b08605d" translate="yes" xml:space="preserve">
          <source>In this case, we are importing only the function &lt;code&gt;duplicate&lt;/code&gt; (with arity 2) from &lt;code&gt;List&lt;/code&gt;. Although &lt;code&gt;:only&lt;/code&gt; is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. &lt;code&gt;:except&lt;/code&gt; could also be given as an option in order to import everything in a module &lt;em&gt;except&lt;/em&gt; a list of functions.</source>
          <target state="translated">В этом случае мы импортируем только &lt;code&gt;duplicate&lt;/code&gt; функции (с арностью 2) из &lt;code&gt;List&lt;/code&gt; . Хотя &lt;code&gt;:only&lt;/code&gt; не является обязательным, его использование рекомендуется во избежание импорта всех функций данного модуля внутри пространства имен. &lt;code&gt;:except&lt;/code&gt; также можно указать в качестве опции для импорта всего в модуле, &lt;em&gt;кроме&lt;/em&gt; списка функций.</target>
        </trans-unit>
        <trans-unit id="98ecd27c52ed18c7b95002136d1b65249ac3fde1" translate="yes" xml:space="preserve">
          <source>In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, strings, lists and tuples. Some basic types are:</source>
          <target state="translated">В этой главе мы узнаем больше об основных типах Elixir:целые числа,с плавающей точкой,булеан,атомы,строки,списки и кортежи.Некоторые базовые типы:</target>
        </trans-unit>
        <trans-unit id="95bc41f24cd4a15d49d6be30cfe2c21aeb083956" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to explore sigils, which are one of the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (&lt;code&gt;~&lt;/code&gt;) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</source>
          <target state="translated">В этой главе мы собираемся исследовать сигилы, которые являются одним из механизмов, предоставляемых языком для работы с текстовыми представлениями. Сигилы начинаются с символа тильды ( &lt;code&gt;~&lt;/code&gt; ), за которым следует буква (которая идентифицирует сигилу) и затем разделитель; необязательно, модификаторы могут быть добавлены после последнего разделителя.</target>
        </trans-unit>
        <trans-unit id="8ac2c0d2324769d5f24fd923ab3874ad8881b99a" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to learn how to use &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:gen_tcp&lt;/code&gt; module&lt;/a&gt; to serve requests. This provides a great opportunity to explore Elixir&amp;rsquo;s &lt;code&gt;Task&lt;/code&gt; module. In future chapters, we will expand our server so it can actually serve the commands.</source>
          <target state="translated">В этой главе мы узнаем, как использовать &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;модуль &lt;/a&gt;Erlang &lt;code&gt;:gen_tcp&lt;/code&gt; для обслуживания запросов. Это дает прекрасную возможность изучить модуль &lt;code&gt;Task&lt;/code&gt; Эликсира . В следующих главах мы расширим наш сервер, чтобы он действительно мог обслуживать команды.</target>
        </trans-unit>
        <trans-unit id="3790f5eba5f0f0e875bea6125a8a5886ab46f334" translate="yes" xml:space="preserve">
          <source>In this chapter, we have learned more about Mix dependencies and umbrella projects. While we may run &lt;code&gt;kv&lt;/code&gt; without a server, our &lt;code&gt;kv_server&lt;/code&gt; depends directly on &lt;code&gt;kv&lt;/code&gt;. By breaking them into separate applications, we gain more control in how they are developed and tested.</source>
          <target state="translated">В этой главе мы узнали больше о зависимостях Mix и зонтичных проектах. Хотя мы можем запускать &lt;code&gt;kv&lt;/code&gt; без сервера, наш &lt;code&gt;kv_server&lt;/code&gt; напрямую зависит от &lt;code&gt;kv&lt;/code&gt; . Разбивая их на отдельные приложения, мы получаем больший контроль над тем, как они разрабатываются и тестируются.</target>
        </trans-unit>
        <trans-unit id="77b3cbb396af520fe87eb129b43b21e8d9c63f1e" translate="yes" xml:space="preserve">
          <source>In this chapter, we will create our first project using Mix and explore different features in</source>
          <target state="translated">В этой главе мы создадим наш первый проект с использованием Mix и исследуем различные возможности в</target>
        </trans-unit>
        <trans-unit id="9c4b6a4ca897d48c33e42fad527b3db14a79b9ad" translate="yes" xml:space="preserve">
          <source>In this chapter, we will discuss how to manage dependencies in Mix.</source>
          <target state="translated">В этой главе мы обсудим,как управлять зависимостями в Mix.</target>
        </trans-unit>
        <trans-unit id="1d38e5f6537d823a5c3903caf420e15d1b2908d8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will gain clarity on what exactly binaries are, how they relate to strings, and what single-quoted values, &lt;code&gt;'like this'&lt;/code&gt;, mean in Elixir. Although strings are one of the most common data types in computer languages, they are subtly complex and are often misunderstood. To understand strings in Elixir, we have to educate ourselves about &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; and character encodings, specifically the &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; encoding.</source>
          <target state="translated">В этой главе мы проясним, что именно представляют собой двоичные файлы, как они соотносятся со строками и какие значения, заключенные в одинарные кавычки, &lt;code&gt;'like this'&lt;/code&gt; , означают в Elixir. Хотя строки являются одним из наиболее распространенных типов данных в компьютерных языках, они довольно сложны и часто неправильно понимаются. Чтобы понять строки в Elixir, мы должны изучить &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; и кодировки символов, в частности &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;кодировку UTF-8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4cdb3f68133770a5d693d42e9c4f0a6b1d29ed8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will go back to the &lt;code&gt;:kv&lt;/code&gt; application and add a routing layer that will allow us to distribute requests between nodes based on the bucket name.</source>
          <target state="translated">В этой главе мы вернемся к приложению &lt;code&gt;:kv&lt;/code&gt; и добавим уровень маршрутизации, который позволит нам распределять запросы между узлами на основе имени корзины.</target>
        </trans-unit>
        <trans-unit id="06e8c486e5a64f168562aa1973836cfefc091cf1" translate="yes" xml:space="preserve">
          <source>In this chapter, we will implement the code that parses the commands we described in the first chapter:</source>
          <target state="translated">В этой главе мы реализуем код,который разбирает команды,описанные в первой главе:</target>
        </trans-unit>
        <trans-unit id="c851aca018e560f965209935144975cb8ea448f3" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about ETS (Erlang Term Storage) and how to use it as a cache mechanism.</source>
          <target state="translated">В этой главе мы узнаем о ETS (Erlang Term Storage)и о том,как использовать ее в качестве механизма кэширования.</target>
        </trans-unit>
        <trans-unit id="49223bed7f677bd886d57a37c64f3ed6e0f504be" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt; control flow structures.</source>
          <target state="translated">В этой главе мы узнаем о структурах потока управления &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;cond&lt;/code&gt; и &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1590a3a3e635043fe94ad7ec0fb7a6fa472857ed" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.</source>
          <target state="translated">В этой главе мы познакомимся с основными конструкциями для порождения новых процессов,а также отправки и получения сообщений между процессами.</target>
        </trans-unit>
        <trans-unit id="7f5c0837809d0d37d72c00bc93c0560646fc3127" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.</source>
          <target state="translated">В этой главе мы узнаем,как сохранить и разделить состояние между несколькими субъектами.Если у вас есть предыдущий опыт программирования,вы можете подумать о глобальных разделяемых переменных,но модель,которую мы здесь изучим,совершенно другая.В следующих главах будут обобщены введенные здесь понятия.</target>
        </trans-unit>
        <trans-unit id="dc7ec789bc29ccf1df57435cd9cab759827e4cca" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to put those concepts into practice by supervising the &lt;code&gt;KV.Registry&lt;/code&gt; process. After all, if something goes wrong with the registry, the whole registry is lost and no bucket could ever be found! To address this, we will define a &lt;code&gt;KV.Supervisor&lt;/code&gt; module that guarantees that our &lt;code&gt;KV.Registry&lt;/code&gt; is up and running at any given moment.</source>
          <target state="translated">В этой главе мы узнаем, как &lt;code&gt;KV.Registry&lt;/code&gt; эти концепции на практике, наблюдая за процессом KV.Registry . В конце концов, если что-то пойдет не так с реестром, весь реестр будет потерян, и никакая корзина не может быть найдена! Чтобы решить эту проблему, мы определим модуль &lt;code&gt;KV.Supervisor&lt;/code&gt; , который гарантирует, что наш &lt;code&gt;KV.Registry&lt;/code&gt; запущен и работает в любой момент.</target>
        </trans-unit>
        <trans-unit id="f4e872a924d2554a59dc215ca3cc9595e893d535" translate="yes" xml:space="preserve">
          <source>In this chapter, we will show how the &lt;code&gt;=&lt;/code&gt; operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator &lt;code&gt;^&lt;/code&gt; used to access previously bound values.</source>
          <target state="translated">В этой главе мы покажем, как оператор &lt;code&gt;=&lt;/code&gt; в Elixir на самом деле является оператором сопоставления и как его использовать для сопоставления с образцом внутри структур данных. Наконец, мы узнаем об операторе вывода &lt;code&gt;^&lt;/code&gt; , используемом для доступа к ранее связанным значениям.</target>
        </trans-unit>
        <trans-unit id="31213f804ca1ba2bcaeea192ccfad5a4a66aadab" translate="yes" xml:space="preserve">
          <source>In this chapter, we will understand what binaries are, how they associate with strings, and what a single-quoted value, &lt;code&gt;'like this'&lt;/code&gt;, means in Elixir.</source>
          <target state="translated">В этой главе мы поймем, что такое двоичные файлы, как они связаны со строками и что означает в Elixir значение в одинарных кавычках, &lt;code&gt;'like this'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f80acbf2877628032b5dc355543214de25ec8ae5" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="translated">В приведенном выше примере мы использовали &lt;code&gt;.&lt;/code&gt; для вызова &lt;code&gt;downcase&lt;/code&gt; в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , передавая &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="cab0abe1635159a22d386896876d7d1271b3ac90" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="translated">В приведенном выше примере мы использовали &lt;code&gt;.&lt;/code&gt; для вызова &lt;code&gt;downcase&lt;/code&gt; в модуле &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , передавая &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="c10b9029231d6bc54c409155c2532fc1a938191b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt;&lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt;&lt;/a&gt; is called with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument; &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">В этом примере &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt; &lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt; &lt;/a&gt; вызывается со списком ключевых слов &lt;code&gt;[async: true]&lt;/code&gt; качестве аргумента; &lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; переводится как:</target>
        </trans-unit>
        <trans-unit id="f2fc4f7ce9494d0ca1b19525b3d662418384d95e" translate="yes" xml:space="preserve">
          <source>In this example, Elixir will call the &lt;code&gt;__using__/1&lt;/code&gt; macro in the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument.</source>
          <target state="translated">В этом примере Elixir вызовет &lt;code&gt;__using__/1&lt;/code&gt; в модуле &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; со списком ключевых слов &lt;code&gt;[async: true]&lt;/code&gt; качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="626c073c42c41fdffe192fe74593219354688844" translate="yes" xml:space="preserve">
          <source>In this example, the order that the application callbacks are called in is:</source>
          <target state="translated">В этом примере порядок,в котором вызываются обратные вызовы приложения:</target>
        </trans-unit>
        <trans-unit id="9b0189dd5873fd5c12528d067cb5fcd86bb62926" translate="yes" xml:space="preserve">
          <source>In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments:</source>
          <target state="translated">В этом примере мы также зададим количество разделов на количество планировщиков в режиме онлайн,что сделает реестр более работоспособным в сильно параллельных средах:</target>
        </trans-unit>
        <trans-unit id="bf3e2a2aeea0818b1b9eedf9fbfeaab414232e77" translate="yes" xml:space="preserve">
          <source>In this function, creating the email address will copy the &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; binaries. Now imagine you want to use the resulting email inside another binary:</source>
          <target state="translated">В этой функции при создании адреса электронной почты будут скопированы двоичные файлы имени &lt;code&gt;username&lt;/code&gt; и &lt;code&gt;domain&lt;/code&gt; . Теперь представьте, что вы хотите использовать полученное электронное письмо в другом двоичном файле:</target>
        </trans-unit>
        <trans-unit id="ddbd4da73762eca8a66a74cb6eb4786c527ab302" translate="yes" xml:space="preserve">
          <source>In this guide, we will learn how to build a complete Elixir application, with its own supervision tree, configuration, tests and more.</source>
          <target state="translated">В этом руководстве мы узнаем,как построить полноценное приложение Elixir,с собственным деревом управления,конфигурацией,тестами и многим другим.</target>
        </trans-unit>
        <trans-unit id="09acda557e592790e954bfce0950e7ceb658a690" translate="yes" xml:space="preserve">
          <source>In this introduction, we have laid the groundwork to finally write our first macro, so let&amp;rsquo;s move to the next chapter.</source>
          <target state="translated">В этом введении мы заложили основу, чтобы наконец написать наш первый макрос, поэтому перейдем к следующей главе.</target>
        </trans-unit>
        <trans-unit id="c76b277befaa00029a051ea468b00e6a56d4277a" translate="yes" xml:space="preserve">
          <source>In this last chapter, we will make the routing table for our distributed key-value store configurable, and then finally package the software for production.</source>
          <target state="translated">В этой последней главе мы сделаем таблицу маршрутизации для нашего распределенного хранилища значений ключей настраиваемой,а затем,наконец,упакуем программное обеспечение для производства.</target>
        </trans-unit>
        <trans-unit id="5f9c06a521bbdcc292934d8151f4d75a668e854f" translate="yes" xml:space="preserve">
          <source>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</source>
          <target state="translated">В этом меню разработчики могут запускать новые оболочки и чередовать их.Давайте попробуем:</target>
        </trans-unit>
        <trans-unit id="469f4d72bd11aaf469d5b151d58b6e80c06007ce" translate="yes" xml:space="preserve">
          <source>In this section we document common anti-patterns to avoid when writing libraries.</source>
          <target state="translated">В этом разделе мы документируем общие анти-шаблоны,которых следует избегать при написании библиотек.</target>
        </trans-unit>
        <trans-unit id="eebb3e9870cca1a5d4d8634270c5f11116a4eca3" translate="yes" xml:space="preserve">
          <source>In this section, we will implement the parsing functionality, document it and make sure our documentation is up to date with doctests. This helps us provide documentation with accurate code samples.</source>
          <target state="translated">В этом разделе мы реализуем функциональность синтаксического анализа,документируем его и следим за тем,чтобы наша документация была актуальна с помощью доктестов.Это поможет нам обеспечить документацию точными примерами кода.</target>
        </trans-unit>
        <trans-unit id="06285168ac2e5f025d4d90f97df36744161f8367" translate="yes" xml:space="preserve">
          <source>In this setup, Elixir will escape the following: &lt;code&gt;\0&lt;/code&gt;, &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;. Bytes can be given as hexadecimals via &lt;code&gt;\xNN&lt;/code&gt; and Unicode code points as &lt;code&gt;\uNNNN&lt;/code&gt; escapes.</source>
          <target state="translated">В этой настройке Elixir избегает следующих символов: &lt;code&gt;\0&lt;/code&gt; , &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; и &lt;code&gt;\v&lt;/code&gt; . Байты могут быть заданы как шестнадцатеричные числа через &lt;code&gt;\xNN&lt;/code&gt; и кодовые точки Unicode как &lt;code&gt;\uNNNN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8dd5e09e7dc956434b7d83de8c59a3badda6a30" translate="yes" xml:space="preserve">
          <source>In this tutorial, we are going to teach you about Elixir fundamentals - the language syntax, how to define modules, how to manipulate the characteristics of common data structures, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir&amp;rsquo;s Interactive Shell, called IEx.</source>
          <target state="translated">В этом руководстве мы научим вас основам Elixir - синтаксису языка, способам определения модулей, управлению характеристиками общих структур данных и многому другому. В этой главе основное внимание будет уделено тому, чтобы убедиться, что Elixir установлен, и вы можете успешно запустить интерактивную оболочку Elixir, называемую IEx.</target>
        </trans-unit>
        <trans-unit id="e88b9f3b5b9f4ee90610e431c8c812f026786e56" translate="yes" xml:space="preserve">
          <source>In your app's logger configuration, you would need to include the &lt;code&gt;:error_code&lt;/code&gt; key and you would need to include &lt;code&gt;$metadata&lt;/code&gt; as part of your log format template:</source>
          <target state="translated">В конфигурации регистратора вашего приложения вам нужно будет включить ключ &lt;code&gt;:error_code&lt;/code&gt; , и вам нужно будет включить &lt;code&gt;$metadata&lt;/code&gt; как часть вашего шаблона формата журнала:</target>
        </trans-unit>
        <trans-unit id="793085c85e85a2ff028456a29daed3461d17ddd7" translate="yes" xml:space="preserve">
          <source>In your supervisor tree, you would write:</source>
          <target state="translated">В вашем дереве начальника,вы бы написали:</target>
        </trans-unit>
        <trans-unit id="83526b8b240a9db63b8d55e8fb00ed7f5d21007b" translate="yes" xml:space="preserve">
          <source>In-memory reloading</source>
          <target state="translated">Перезагрузка в память</target>
        </trans-unit>
        <trans-unit id="d704ee1641420e0d4b1d894e7413ca3a127523fd" translate="yes" xml:space="preserve">
          <source>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; means the last element of the &lt;code&gt;enumerable&lt;/code&gt;).</source>
          <target state="translated">Индексы нормализованы, что означает, что отрицательные индексы будут отсчитываться с конца (например, &lt;code&gt;-1&lt;/code&gt; означает последний элемент &lt;code&gt;enumerable&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="326e3957dade8d1a772302e6b546ac73cdbf4311" translate="yes" xml:space="preserve">
          <source>Indicates if the current task is recursing.</source>
          <target state="translated">Указывает,возвращается ли текущая задача.</target>
        </trans-unit>
        <trans-unit id="cc7fb80993cfbaec0cc1b10ecafb323d9e5355f1" translate="yes" xml:space="preserve">
          <source>Indicates no meaningful value for a field.</source>
          <target state="translated">Указывает на отсутствие значимого значения для поля.</target>
        </trans-unit>
        <trans-unit id="f2a5522bf941f8a31cb4a9be81260d9ace1f85be" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise AND of its arguments.</source>
          <target state="translated">Оператор Infix;вычисляет битовый AND своих аргументов.</target>
        </trans-unit>
        <trans-unit id="e2dd1c549a548d8e01a78692703764dc3748f955" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise OR of its arguments.</source>
          <target state="translated">Оператор &quot;Исправить&quot;;вычисляет битовое &quot;ИЛИ&quot; своих аргументов.</target>
        </trans-unit>
        <trans-unit id="9f117367d5e095016d1671e5594b015b66cce626" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise XOR of its arguments.</source>
          <target state="translated">Оператор Infix;вычисляет битовый XOR своих аргументов.</target>
        </trans-unit>
        <trans-unit id="a6c9f00063f505c603b4195c6e85acdf426886dc" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic left bitshift.</source>
          <target state="translated">Оператор &quot;Исправить&quot;;вычисляет результат арифметического сдвига левого бита.</target>
        </trans-unit>
        <trans-unit id="39d1b96bbfeb4f731610e743c469a2a9cffcbf06" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic right bitshift.</source>
          <target state="translated">Оператор &quot;Исправить&quot;;вычисляет результат арифметического сдвига вправо.</target>
        </trans-unit>
        <trans-unit id="edfb572bfe264c3828dc3338e200d7d692f743a8" translate="yes" xml:space="preserve">
          <source>Initialization, shutdown and restart logic (as seen in supervisors)</source>
          <target state="translated">Логика инициализации,выключения и перезапуска (как видно из супервизоров)</target>
        </trans-unit>
        <trans-unit id="db2dd11fcae49760a96da6470cc842932b211ef8" translate="yes" xml:space="preserve">
          <source>Injects the contents of the file at &lt;code&gt;path&lt;/code&gt; as if it was typed into the shell.</source>
          <target state="translated">Вставляет содержимое файла по &lt;code&gt;path&lt;/code&gt; как если бы оно было введено в оболочку.</target>
        </trans-unit>
        <trans-unit id="cdae762bf8cb5cd492029bc8d296aa3edef79fb0" translate="yes" xml:space="preserve">
          <source>Injects the stream values into the given collectable as a side-effect.</source>
          <target state="translated">В качестве побочного эффекта вставляет значения потока в заданный коллекционный файл.</target>
        </trans-unit>
        <trans-unit id="dc55e2c53e188d355acce4a5c45f90740eaed542" translate="yes" xml:space="preserve">
          <source>Inlined by the compiler.</source>
          <target state="translated">Построенный компилятором.</target>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="60256592be0f79d02de4ff02fdbe0edd9f4a9db3" translate="yes" xml:space="preserve">
          <source>Input will be consumed until Enter is pressed.</source>
          <target state="translated">Вход будет потребляться до тех пор,пока не будет нажата клавиша Enter.</target>
        </trans-unit>
        <trans-unit id="15148f3718aedfec6834b4f2c01d66f0986c9e24" translate="yes" xml:space="preserve">
          <source>Insert these changes in your code and now you may start your application using the following command &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt;, notice how we are passing the port as a variable, but still defaults to 4040 if none is given.</source>
          <target state="translated">Вставьте эти изменения в свой код, и теперь вы можете запустить свое приложение, используя следующую команду &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt; , обратите внимание, как мы передаем порт как переменную, но по-прежнему по умолчанию 4040, если ничего не указано.</target>
        </trans-unit>
        <trans-unit id="477a1b44713d7d2cea8e0f490e55ba9af37236ea" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;map_set&lt;/code&gt; if &lt;code&gt;map_set&lt;/code&gt; doesn't already contain it.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в &lt;code&gt;map_set&lt;/code&gt; , если &lt;code&gt;map_set&lt;/code&gt; его еще не содержит.</target>
        </trans-unit>
        <trans-unit id="1e63d377cb4e0957757e5467d8c996119f6f2f02" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в &lt;code&gt;tuple&lt;/code&gt; по заданному &lt;code&gt;index&lt;/code&gt; . Вызывает ошибку &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;index&lt;/code&gt; отрицателен или превышает длину &lt;code&gt;tuple&lt;/code&gt; . Индекс отсчитывается от нуля.</target>
        </trans-unit>
        <trans-unit id="1f08770187662583a163ac728c2c3de32f5a374d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в &lt;code&gt;tuple&lt;/code&gt; по заданному &lt;code&gt;index&lt;/code&gt; . Вызывает ошибку &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;index&lt;/code&gt; отрицателен или превышает длину &lt;code&gt;tuple&lt;/code&gt; . Индекс отсчитывается от нуля.</target>
        </trans-unit>
        <trans-unit id="afa4ba1a8961d06fdaefcb0b7808a06ce72411d7" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory linebreak between two documents.</source>
          <target state="translated">Вставляет обязательный перерыв между двумя документами.</target>
        </trans-unit>
        <trans-unit id="ee42585ac2116aa5e9e194a89ae83cd36cb233ed" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory single space between two documents.</source>
          <target state="translated">Вставляет обязательное единое место между двумя документами.</target>
        </trans-unit>
        <trans-unit id="58646ce229b992058a739db41cd5c12f2f3030cf" translate="yes" xml:space="preserve">
          <source>Inserts an element at the end of a tuple.</source>
          <target state="translated">Вставляет элемент в конец кортежа.</target>
        </trans-unit>
        <trans-unit id="aefced5d83d6f9626d89c8b81563a063596124ad" translate="yes" xml:space="preserve">
          <source>Inserts an element into a tuple.</source>
          <target state="translated">Вставляет элемент в кортеж.</target>
        </trans-unit>
        <trans-unit id="82491edefb5fd8fccc5cef67dd8728cddce98356" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt; according to the transformation function.</source>
          <target state="translated">Вставляет заданное &lt;code&gt;enumerable&lt;/code&gt; в &lt;code&gt;collectable&lt;/code&gt; соответствии с функцией преобразования.</target>
        </trans-unit>
        <trans-unit id="58e9b11975e38f1615e69956c4ba72b1614985c8" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt;.</source>
          <target state="translated">Вставляет данное &lt;code&gt;enumerable&lt;/code&gt; в &lt;code&gt;collectable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40d18588e5bd7683cf2537e97eac6badfff84230" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="translated">Внутри &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt; &lt;code&gt;defimpl/2&lt;/code&gt; &lt;/a&gt; вы можете использовать &lt;code&gt;@protocol&lt;/code&gt; для доступа к реализуемому протоколу и &lt;code&gt;@for&lt;/code&gt; для доступа к модулю, для которого он определяется.</target>
        </trans-unit>
        <trans-unit id="4dc843d3a107d849e18140a0726786e2d0083112" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="translated">Внутри &lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;defimpl/2&lt;/code&gt; &lt;/a&gt; вы можете использовать &lt;code&gt;@protocol&lt;/code&gt; для доступа к реализуемому протоколу и &lt;code&gt;@for&lt;/code&gt; для доступа к модулю, для которого он определяется.</target>
        </trans-unit>
        <trans-unit id="9a72c5141d8fa1919f077425c1ba8fcc0bb6e0f3" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks you may introduce other keywords, such as &lt;code&gt;else&lt;/code&gt; used in the &lt;code&gt;if&lt;/code&gt; above. The supported keywords between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; are static and are:</source>
          <target state="translated">Внутри блоков &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; вы можете ввести другие ключевые слова, такие как &lt;code&gt;else&lt;/code&gt; , используемые в &lt;code&gt;if&lt;/code&gt; выше. Поддерживаемые ключевые слова между &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; статичны и:</target>
        </trans-unit>
        <trans-unit id="7b06fc5ccdbbb6e1341b5ead9ee2126b0e7d8721" translate="yes" xml:space="preserve">
          <source>Inside IEx, hitting &lt;code&gt;Ctrl+C&lt;/code&gt; will open up the &lt;code&gt;BREAK&lt;/code&gt; menu. In this menu you can quit the shell, see process and ETS tables information and much more.</source>
          <target state="translated">Внутри IEx нажатие &lt;code&gt;Ctrl+C&lt;/code&gt; откроет меню &lt;code&gt;BREAK&lt;/code&gt; . В этом меню вы можете выйти из оболочки, просмотреть информацию о процессах и таблицах ETS и многое другое.</target>
        </trans-unit>
        <trans-unit id="03f0e4a7260af9ca9a8463a85cd7efbea72439fd" translate="yes" xml:space="preserve">
          <source>Inside a module, we can define functions with &lt;code&gt;def/2&lt;/code&gt; and private functions with &lt;code&gt;defp/2&lt;/code&gt;. A function defined with &lt;code&gt;def/2&lt;/code&gt; can be invoked from other modules while a private function can only be invoked locally.</source>
          <target state="translated">Внутри модуля мы можем определять функции с помощью &lt;code&gt;def/2&lt;/code&gt; и частные функции с помощью &lt;code&gt;defp/2&lt;/code&gt; . Функция, определенная с помощью &lt;code&gt;def/2&lt;/code&gt; , может быть вызвана из других модулей, в то время как частная функция может быть вызвана только локально.</target>
        </trans-unit>
        <trans-unit id="1b5876476355703f4f43fdf75b583d0b33e50128" translate="yes" xml:space="preserve">
          <source>Inside umbrellas:</source>
          <target state="translated">Внутри зонтиков:</target>
        </trans-unit>
        <trans-unit id="113a1b9884a89043121b7d7c5d9c0a394636f751" translate="yes" xml:space="preserve">
          <source>Inside your umbrella, you can define multiple releases:</source>
          <target state="translated">Внутри зонтика можно определить несколько релизов:</target>
        </trans-unit>
        <trans-unit id="ff7d1285dd1427c76ab7acf44b71a8c8783f99ac" translate="yes" xml:space="preserve">
          <source>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</source>
          <target state="translated">Незначительные цифры в числах сохраняются как есть.Форматер,однако,всегда вставляет подчеркивание для десятичных чисел с более чем 5-ю цифрами и преобразует шестнадцатеричные цифры в заглавные.</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="8414c282c4799a38a5a542eddf3fbf5bc932cf21" translate="yes" xml:space="preserve">
          <source>Inspect &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">Проверить &lt;small&gt;протокол&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2cc0c476786708af2220b5a7c37218a295c0e" translate="yes" xml:space="preserve">
          <source>Inspect.Algebra</source>
          <target state="translated">Inspect.Algebra</target>
        </trans-unit>
        <trans-unit id="cac9e750c4626e97af4bfdac5963505168c991af" translate="yes" xml:space="preserve">
          <source>Inspect.Error</source>
          <target state="translated">Inspect.Error</target>
        </trans-unit>
        <trans-unit id="2f7084207f03105946937040d7f1a8666466847e" translate="yes" xml:space="preserve">
          <source>Inspect.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Inspect.Error &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c1eea5039122d61678f099bc1095c3d343dfa88b" translate="yes" xml:space="preserve">
          <source>Inspect.Opts</source>
          <target state="translated">Inspect.Opts</target>
        </trans-unit>
        <trans-unit id="76857fe76fdec2188870db7ef8e5489c2f660af9" translate="yes" xml:space="preserve">
          <source>Inspect.inspect (2)</source>
          <target state="translated">Проверьте.проверьте (2)</target>
        </trans-unit>
        <trans-unit id="11718aedd18c27cc6d385458412c98fc95530888" translate="yes" xml:space="preserve">
          <source>Inspect.t (0)</source>
          <target state="translated">Проверьте.t (0)</target>
        </trans-unit>
        <trans-unit id="728cbccfe7f399bad0002a59ae5fe929d7156d22" translate="yes" xml:space="preserve">
          <source>Inspecting behaviours</source>
          <target state="translated">Проверка поведения</target>
        </trans-unit>
        <trans-unit id="4b093666bfbe436abd6e75ff4060483a6eed400e" translate="yes" xml:space="preserve">
          <source>Inspects &lt;code&gt;item&lt;/code&gt; according to the given options using the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">Осматривает &lt;code&gt;item&lt;/code&gt; соответствии с заданными параметрами с помощью &lt;code&gt;device&lt;/code&gt; ввода-вывода .</target>
        </trans-unit>
        <trans-unit id="c5a3a1e7021ff3bf12f0c5dee5b6d4b45795751a" translate="yes" xml:space="preserve">
          <source>Inspects and writes the given &lt;code&gt;item&lt;/code&gt; to the device.</source>
          <target state="translated">Проверяет и записывает данный &lt;code&gt;item&lt;/code&gt; в устройство.</target>
        </trans-unit>
        <trans-unit id="bf74027804ecc526da780a7ae1724e9dedba411f" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="translated">Проверяет данный аргумент согласно протоколу &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; . Второй аргумент - это список ключевых слов с параметрами для управления проверкой.</target>
        </trans-unit>
        <trans-unit id="e7503cce5b05ca6c10725fe1362e1e1fb0df01fb" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="translated">Проверяет данный аргумент согласно протоколу &lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; . Второй аргумент - это список ключевых слов с параметрами для управления проверкой.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="410e2de2d51ba0a8c2653a12efa8b959eb14239c" translate="yes" xml:space="preserve">
          <source>Installing external dependencies is simple. Most commonly, we use the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;, by listing the dependency inside the deps function in our &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">Установить внешние зависимости просто. Чаще всего мы используем &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt; , перечисляя зависимости внутри функции deps в нашем файле &lt;code&gt;mix.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ba9749301614c940b015d94dafda1de33dee733" translate="yes" xml:space="preserve">
          <source>Installs Hex locally.</source>
          <target state="translated">Устанавливает Гекс на месте.</target>
        </trans-unit>
        <trans-unit id="fe27c68af6ef5819f7f323521831724db906052b" translate="yes" xml:space="preserve">
          <source>Installs an archive locally.</source>
          <target state="translated">Устанавливает архив локально.</target>
        </trans-unit>
        <trans-unit id="ac37dc92363c2e268a61314e8483b955fcaa10e1" translate="yes" xml:space="preserve">
          <source>Installs an escript locally.</source>
          <target state="translated">Устанавливает эскрипт локально.</target>
        </trans-unit>
        <trans-unit id="5fc6648d32dcda7f8258be9d7bfe7a810c641ff1" translate="yes" xml:space="preserve">
          <source>Instead &lt;strong&gt;do&lt;/strong&gt;:</source>
          <target state="translated">Вместо этого &lt;strong&gt;сделайте&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="70e1c1220b6164c7f3f3c7f9ac3d512f4ed39191" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt;, &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; can be used.</source>
          <target state="translated">Вместо того , чтобы &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt; , &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="a1b879c3f25c9b1c9960a54e86cb4fc16cf79dfc" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt;, we use &lt;code&gt;Task.start/1&lt;/code&gt; and &lt;code&gt;Task.start_link/1&lt;/code&gt; which return &lt;code&gt;{:ok, pid}&lt;/code&gt; rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, &lt;code&gt;Task&lt;/code&gt; provides convenience functions, like &lt;code&gt;Task.async/1&lt;/code&gt; and &lt;code&gt;Task.await/1&lt;/code&gt;, and functionality to ease distribution.</source>
          <target state="translated">Вместо &lt;code&gt;spawn/1&lt;/code&gt; и &lt;code&gt;spawn_link/1&lt;/code&gt; мы используем &lt;code&gt;Task.start/1&lt;/code&gt; и &lt;code&gt;Task.start_link/1&lt;/code&gt; , которые возвращают &lt;code&gt;{:ok, pid}&lt;/code&gt; а не только PID. Это то, что позволяет использовать задачи в деревьях наблюдения. Кроме того, &lt;code&gt;Task&lt;/code&gt; предоставляет удобные функции, такие как &lt;code&gt;Task.async/1&lt;/code&gt; и &lt;code&gt;Task.await/1&lt;/code&gt; , а также функции для упрощения распространения.</target>
        </trans-unit>
        <trans-unit id="2b04d71a821407f326a765c34eafcb3d188ed9ec" translate="yes" xml:space="preserve">
          <source>Instead of abusing the built-in name facility, we will create our own &lt;em&gt;process registry&lt;/em&gt; that associates the bucket name to the bucket process.</source>
          <target state="translated">Вместо того, чтобы злоупотреблять встроенной функцией имени, мы создадим наш собственный &lt;em&gt;реестр процессов,&lt;/em&gt; который связывает имя сегмента с процессом корзины.</target>
        </trans-unit>
        <trans-unit id="46ebdd1c0d8185516f828a303e26f55b8135c53d" translate="yes" xml:space="preserve">
          <source>Instead of asking &amp;ldquo;how to do X in Elixir&amp;rdquo;, ask &amp;ldquo;how to solve Y in Elixir&amp;rdquo;. In other words, don&amp;rsquo;t ask how to implement a particular solution, instead describe the problem at hand. Stating the problem gives more context and less bias for a correct answer.</source>
          <target state="translated">Вместо того, чтобы спрашивать &amp;laquo;как решить X в эликсире&amp;raquo;, спросите &amp;laquo;как решить Y в эликсире&amp;raquo;. Другими словами, не спрашивайте, как реализовать конкретное решение, а опишите проблему под рукой. Постановка проблемы дает больше контекста и меньше предвзятости для правильного ответа.</target>
        </trans-unit>
        <trans-unit id="657f86bb1607bd9dc12a6834cf040e983fea5025" translate="yes" xml:space="preserve">
          <source>Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the &lt;code&gt;Enum&lt;/code&gt; module. Streams are useful when working with large, &lt;em&gt;possibly infinite&lt;/em&gt;, collections.</source>
          <target state="translated">Вместо создания промежуточных списков потоки создают серию вычислений, которые вызываются только тогда, когда мы передаем базовый поток модулю &lt;code&gt;Enum&lt;/code&gt; . Потоки полезны при работе с большими, &lt;em&gt;возможно, бесконечными&lt;/em&gt; коллекциями.</target>
        </trans-unit>
        <trans-unit id="cbcbdeb5ce82b55a1db6bc95122644a2da9c98f8" translate="yes" xml:space="preserve">
          <source>Instead of sharing protocol implementation with maps, structs require their own protocol implementation. Since a &lt;code&gt;MapSet&lt;/code&gt; has its size precomputed and accessible through &lt;code&gt;MapSet.size/1&lt;/code&gt;, we can define a &lt;code&gt;Size&lt;/code&gt; implementation for it:</source>
          <target state="translated">Вместо того чтобы совместно использовать реализацию протокола с картами, структурам требуется собственная реализация протокола. Поскольку размер &lt;code&gt;MapSet&lt;/code&gt; предварительно &lt;code&gt;MapSet.size/1&lt;/code&gt; и доступен через MapSet.size / 1 , мы можем определить для него реализацию &lt;code&gt;Size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b1cda74ad7f0576bffdba14e7c0e5fbf0bd02a81" translate="yes" xml:space="preserve">
          <source>Instead, you can store the value of the &lt;code&gt;try&lt;/code&gt; expression:</source>
          <target state="translated">Вместо этого вы можете сохранить значение выражения &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="e340bf5c2746e3a29b7ae3f2341d749b9a8e7f42" translate="yes" xml:space="preserve">
          <source>Integer code points</source>
          <target state="translated">Целые точки кода</target>
        </trans-unit>
        <trans-unit id="6329201f484f49f6ec697e329c43d6e6707a772f" translate="yes" xml:space="preserve">
          <source>Integer that represents the day of the week, where 1 is Monday and 7 is Sunday.</source>
          <target state="translated">Целое,представляющее собой день недели,где 1-понедельник,а 7-воскресенье.</target>
        </trans-unit>
        <trans-unit id="03c914e9cf272bd181f63f8ca95aa4134406a908" translate="yes" xml:space="preserve">
          <source>Integers (&lt;code&gt;1234&lt;/code&gt;) and floats (&lt;code&gt;123.4&lt;/code&gt;) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as &lt;code&gt;1_000_000&lt;/code&gt;. Integers never contain a dot (&lt;code&gt;.&lt;/code&gt;) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as &lt;code&gt;123.4e10&lt;/code&gt; or &lt;code&gt;123.4E10&lt;/code&gt;.</source>
          <target state="translated">Целые числа ( &lt;code&gt;1234&lt;/code&gt; ) и числа с плавающей запятой ( &lt;code&gt;123.4&lt;/code&gt; ) в Elixir представлены как последовательность цифр, которые могут быть разделены подчеркиванием для удобства чтения, например &lt;code&gt;1_000_000&lt;/code&gt; . Целые числа никогда не содержат точки ( &lt;code&gt;.&lt;/code&gt; ) В своем представлении. Поплавки содержат точку и, по крайней мере, еще одну цифру после точки. Поплавки также поддерживают научную нотацию, например &lt;code&gt;123.4e10&lt;/code&gt; или &lt;code&gt;123.4E10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b69f8490219ca339df3ffe0a24133cf0845a779" translate="yes" xml:space="preserve">
          <source>Integers can be &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;, defaulting to &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">Целые числа могут быть со &lt;code&gt;signed&lt;/code&gt; или &lt;code&gt;unsigned&lt;/code&gt; , по умолчанию - &lt;code&gt;unsigned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2871c600eee20d37fb547e17a478f66ee810c41" translate="yes" xml:space="preserve">
          <source>Integers in other bases and Unicode code points</source>
          <target state="translated">Целочисленные в других базах и точках кода Юникода</target>
        </trans-unit>
        <trans-unit id="cca6e2eff6c59ea0c8e68e40ac9ddccb40190ce0" translate="yes" xml:space="preserve">
          <source>Integrates with Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt;&lt;code&gt;:logger&lt;/code&gt;&lt;/a&gt; to convert terms to Elixir syntax.</source>
          <target state="translated">Интегрируется с Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt; &lt;code&gt;:logger&lt;/code&gt; &lt;/a&gt; для преобразования терминов в синтаксис Elixir.</target>
        </trans-unit>
        <trans-unit id="67bd439657ec8c91af9cab8e9c61775e95c7d415" translate="yes" xml:space="preserve">
          <source>Integration with Mix</source>
          <target state="translated">Интеграция с Mix</target>
        </trans-unit>
        <trans-unit id="8c7b691a3d33f4bf5d25d380d9c0cebf6d69f172" translate="yes" xml:space="preserve">
          <source>Integration with OS level tracers, such as &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit,&lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE,&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt;</source>
          <target state="translated">Интеграция с трассировщиками уровня ОС, такими как &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit, &lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE&lt;/a&gt; и &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">Интерактивный режим</target>
        </trans-unit>
        <trans-unit id="f4f8ff7b4770e825fb6a5a6969991c0326746be8" translate="yes" xml:space="preserve">
          <source>Internal and external functions</source>
          <target state="translated">Внутренние и внешние функции</target>
        </trans-unit>
        <trans-unit id="6815f4d63967846048009b2275fddb5992a2ae7f" translate="yes" xml:space="preserve">
          <source>Internal dependencies</source>
          <target state="translated">Внутренние зависимости</target>
        </trans-unit>
        <trans-unit id="fd76d47a90f8cc879523d078abeee342549c2a2c" translate="yes" xml:space="preserve">
          <source>Internal dependencies are the ones that are specific to your project. They usually don&amp;rsquo;t make sense outside the scope of your project/company/organization. Most of the time, you want to keep them private, whether due to technical, economic or business reasons.</source>
          <target state="translated">Внутренние зависимости - это те, которые специфичны для вашего проекта. Обычно они не имеют смысла вне рамок вашего проекта / компании / организации. В большинстве случаев вы хотите сохранить их конфиденциальность по техническим, экономическим или деловым причинам.</target>
        </trans-unit>
        <trans-unit id="6edc5ae2d27d92f734915c3bcae38bfcff562e82" translate="yes" xml:space="preserve">
          <source>Internal special form for block expressions.</source>
          <target state="translated">Внутренняя специальная форма для блочных выражений.</target>
        </trans-unit>
        <trans-unit id="7b9df6e3733e8709e741819162ae8b21c5560f05" translate="yes" xml:space="preserve">
          <source>Internal special form to hold aliases information.</source>
          <target state="translated">Внутренняя специальная форма для хранения информации о псевдонимах.</target>
        </trans-unit>
        <trans-unit id="7ea238b82c732c14af0d56ae146c57de7821e30a" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="translated">Внутри &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; реализован следующим образом:</target>
        </trans-unit>
        <trans-unit id="d4d06a23df2e5f8415d5588be7a06fbd36f8ee7c" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="translated">Внутри &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; реализован следующим образом:</target>
        </trans-unit>
        <trans-unit id="444e75baf2b8d0e94b94fc3e049285ea03c10723" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="translated">Внутри эта функция использует &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; для взаимодействия с внешним миром. Однако, если вы планируете запускать долго работающую программу, порты гарантируют, что устройства stdin / stdout будут закрыты, но это не приведет к автоматическому завершению программы. В документации к модулю &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; описывается эта проблема и возможные решения в разделе &amp;laquo;Зомби-процессы&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="827c1e94219dfeaae7b53280233314ac83030abd" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="translated">Внутри эта функция использует &lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; для взаимодействия с внешним миром. Однако, если вы планируете запускать долго работающую программу, порты гарантируют, что устройства stdin / stdout будут закрыты, но это не приведет к автоматическому завершению программы. В документации к модулю &lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; описана эта проблема и возможные решения в разделе &amp;laquo;Зомби-процессы&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="77ae57c279c9e2ef961ac607460659eac146477d" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in sigils</source>
          <target state="translated">Интерполяция и побег в сигаретах</target>
        </trans-unit>
        <trans-unit id="d142f547e062671930a17d6dfc85716aa23453f5" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in string sigils</source>
          <target state="translated">Интерполяция и выход в струнных сигаретах</target>
        </trans-unit>
        <trans-unit id="5064a21ec7e025e2514366b24e54341fcd2022ec" translate="yes" xml:space="preserve">
          <source>Interpreting integers as codepoints may lead to some surprising behavior. For example, if you are storing a list of integers that happen to range between 0 and 127, by default IEx will interpret this as a charlist and it will display the corresponding ASCII characters.</source>
          <target state="translated">Интерпретация целых чисел в качестве кодовых точек может привести к некоторому удивительному поведению.Например,если вы храните список целых чисел,которые случайно находятся в диапазоне от 0 до 127,то по умолчанию IEx будет интерпретировать его как charlist и отобразит соответствующие ASCII символы.</target>
        </trans-unit>
        <trans-unit id="f901cbbe7edd4e8b636ff99e09fd9aa3ab5b6c2c" translate="yes" xml:space="preserve">
          <source>Intersperses &lt;code&gt;element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">Вставляет &lt;code&gt;element&lt;/code&gt; между каждым элементом перечисления.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3ad9a82c5e5ec7f5cdb591679187a3a184cc6e2c" translate="yes" xml:space="preserve">
          <source>Introduction to Mix</source>
          <target state="translated">Введение в микс</target>
        </trans-unit>
        <trans-unit id="556666f2a50884d36f095e81af9943cd94538e19" translate="yes" xml:space="preserve">
          <source>Invalid (when setup_all fails)</source>
          <target state="translated">Недействительный (когда setup_all терпит неудачу)</target>
        </trans-unit>
        <trans-unit id="44c16916fee38218c7470ca5f830ff4fbd096ffc" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are skipped and the remaining of the string is converted. If you want the algorithm to stop and return on invalid codepoint, use &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfd_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfd_binary/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfc_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfc_binary/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkd_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfkd_binary/1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkc_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfkc_binary/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Недействительные кодовые точки Unicode пропускаются, а оставшаяся часть строки преобразуется. Если вы хотите алгоритм для остановки и возвращения на недействительный, использование элемент кода &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfd_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfd_binary/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfc_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfc_binary/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkd_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfkd_binary/1&lt;/code&gt; &lt;/a&gt; , а &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkc_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfkc_binary/1&lt;/code&gt; &lt;/a&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="979685031faaab9869c01a670026bc6edde40c74" translate="yes" xml:space="preserve">
          <source>Invoke the required callback &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вызвать необходимую &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; обратного вызова / 1 .</target>
        </trans-unit>
        <trans-unit id="9c2fcbf3d8569fd3d11cfd7171a8054a4d1a7f48" translate="yes" xml:space="preserve">
          <source>Invoked at the beginning of every nesting.</source>
          <target state="translated">Вызвано в начале каждого гнездования.</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">Вызывается для доступа к значению, хранящемуся под &lt;code&gt;key&lt;/code&gt; в данном термине &lt;code&gt;term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">Вызывается для доступа к значению под &lt;code&gt;key&lt;/code&gt; и одновременного его обновления.</target>
        </trans-unit>
        <trans-unit id="f708aba5828f8cac72cfe36605553c37461c0165" translate="yes" xml:space="preserve">
          <source>Invoked in some cases to retrieve a formatted version of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; status.</source>
          <target state="translated">Вызывается в некоторых случаях для получения отформатированной версии статуса &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47f17640bca3b36f9d932ef8aed6fea2692e715d" translate="yes" xml:space="preserve">
          <source>Invoked to &quot;pop&quot; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">Вызывается для &quot;выталкивания&quot; значения под &lt;code&gt;key&lt;/code&gt; из данной структуры данных.</target>
        </trans-unit>
        <trans-unit id="8ffa339626f86dfddb50d2f5a5ebf28a3fe4886f" translate="yes" xml:space="preserve">
          <source>Invoked to change the state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</source>
          <target state="translated">Вызывается для изменения состояния &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; ,&lt;/a&gt; когда загружается другая версия модуля (горячая замена кода), и временная структура состояния должна быть изменена.</target>
        </trans-unit>
        <trans-unit id="7fd464e0a7bfe3444479112d481808fd4426398a" translate="yes" xml:space="preserve">
          <source>Invoked to handle &lt;code&gt;continue&lt;/code&gt; instructions.</source>
          <target state="translated">Вызывается для обработки инструкций &lt;code&gt;continue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="823c64bbe586eac0f81ae84a9ece9107aadfc7b3" translate="yes" xml:space="preserve">
          <source>Invoked to handle all other messages.</source>
          <target state="translated">Призван обрабатывать все остальные сообщения.</target>
        </trans-unit>
        <trans-unit id="251e86e0358f8330275ee3b3f133b8139914e86a" translate="yes" xml:space="preserve">
          <source>Invoked to handle asynchronous &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; messages.</source>
          <target state="translated">Вызывается для обработки асинхронных сообщений &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="490b6e99cd71fc7e4dff011cebfd6c5bbbf5b87c" translate="yes" xml:space="preserve">
          <source>Invoked to handle synchronous &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; messages. &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; will block until a reply is received (unless the call times out or nodes are disconnected).</source>
          <target state="translated">Вызывается для обработки синхронных сообщений &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; будет блокироваться до тех пор, пока не будет получен ответ (если не истечет время ожидания вызова или узлы не отключены).</target>
        </trans-unit>
        <trans-unit id="971fbd6b9ae7269a95c5e43e7e31db62769d21ec" translate="yes" xml:space="preserve">
          <source>Invoked when initializing a config provider.</source>
          <target state="translated">Запрашивается при инициализации провайдера конфигураций.</target>
        </trans-unit>
        <trans-unit id="618d0cf7ef6acc312a2d60fcc796f79659809cb5" translate="yes" xml:space="preserve">
          <source>Invoked when the server is about to exit. It should do any cleanup required.</source>
          <target state="translated">Вызовется,когда сервер собирается выходить.Он должен выполнить любую необходимую очистку.</target>
        </trans-unit>
        <trans-unit id="7d36bf5909d0181e92966ebf880c59e2f526bd11" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;start/3&lt;/code&gt;&lt;/a&gt; will block until it returns.</source>
          <target state="translated">Вызывается при запуске сервера. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;start/3&lt;/code&gt; &lt;/a&gt; будет блокироваться до тех пор, пока не вернется.</target>
        </trans-unit>
        <trans-unit id="dc23160ff26718d1a90643ca2158ff18ecfa2d78" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt; with the accumulator.</source>
          <target state="translated">Вызывает &lt;code&gt;fun&lt;/code&gt; для каждого элемента &lt;code&gt;enumerable&lt;/code&gt; с аккумулятором.</target>
        </trans-unit>
        <trans-unit id="3e3f9c65eaf0d3e4e4ac9e30375324284bc3c5a7" translate="yes" xml:space="preserve">
          <source>Invokes at the end of a nesting.</source>
          <target state="translated">Вызывает в конце гнезда.</target>
        </trans-unit>
        <trans-unit id="d9056f0569ac34dc376baf3f7e7aa026280e9f07" translate="yes" xml:space="preserve">
          <source>Invokes the callback with all entries under &lt;code&gt;key&lt;/code&gt; in each partition for the given &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">Вызывает обратный вызов со всеми записями под &lt;code&gt;key&lt;/code&gt; в каждом разделе данного &lt;code&gt;registry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ee7c7e2a41aa50f02ea0f66057171a17276f9a" translate="yes" xml:space="preserve">
          <source>Invokes the given &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Вызывает заданное &lt;code&gt;fun&lt;/code&gt; для каждого элемента &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c515146dfdcfd5de926f55b367fb13cb7ae87958" translate="yes" xml:space="preserve">
          <source>Invokes the given anonymous function &lt;code&gt;fun&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Вызывает заданную анонимную функцию &lt;code&gt;fun&lt;/code&gt; со списком аргументов &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa0eb875a1a8fbbb92dc87b00ef479f56d53d97" translate="yes" xml:space="preserve">
          <source>Invokes the given function from &lt;code&gt;module&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Вызывает заданную функцию из &lt;code&gt;module&lt;/code&gt; со списком аргументов &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5649c0331fbb3552ad202de096382bf84abd3b21" translate="yes" xml:space="preserve">
          <source>Invokes the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt; to reduce it to a single element, while keeping an accumulator.</source>
          <target state="translated">Вызывает заданную функцию для каждого элемента &lt;code&gt;enumerable&lt;/code&gt; чтобы уменьшить его до одного элемента, сохраняя при этом аккумулятор.</target>
        </trans-unit>
        <trans-unit id="1dc0b084acbb8122b7369800b4f64ab048152c7c" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;mix&lt;/code&gt; is the same as &lt;code&gt;mix run&lt;/code&gt;. Therefore, if you want to pass a flag to &lt;code&gt;mix&lt;/code&gt; or &lt;code&gt;iex -S mix&lt;/code&gt;, we just need to add the task name and the desired flags. For example, run &lt;code&gt;iex -S mix run --no-start&lt;/code&gt;:</source>
          <target state="translated">Вызов &lt;code&gt;mix&lt;/code&gt; аналогичен &lt;code&gt;mix run&lt;/code&gt; . Следовательно, если вы хотите передать флаг для &lt;code&gt;mix&lt;/code&gt; или &lt;code&gt;iex -S mix&lt;/code&gt; , нам просто нужно добавить имя задачи и желаемые флаги. Например, выполните &lt;code&gt;iex -S mix run --no-start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e66a67e4e899cac7ac07ae70b407650c10def5dc" translate="yes" xml:space="preserve">
          <source>Invoking this function when the distribution has already been started, either via the command line interface or dynamically, will return an error.</source>
          <target state="translated">При вызове этой функции,когда распределение уже запущено,либо через интерфейс командной строки,либо динамически,будет возвращена ошибка.</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">Это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">это то же самое:</target>
        </trans-unit>
        <trans-unit id="b48400f8fe9d35749daa7cbd1527dc39de359530" translate="yes" xml:space="preserve">
          <source>It MUST &lt;code&gt;import Config&lt;/code&gt; at the top instead of the deprecated &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="translated">Он ДОЛЖЕН &lt;code&gt;import Config&lt;/code&gt; вверху вместо устаревшего &lt;code&gt;use Mix.Config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3354e4898e62c5bb42e290c77847d16af508d4f" translate="yes" xml:space="preserve">
          <source>It MUST NOT access &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt; in any way, as &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt; is a build tool and it is not available inside releases</source>
          <target state="translated">Он НЕ ДОЛЖЕН получать доступ к &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt; каким-либо образом, так как &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt; - это инструмент сборки, и он недоступен внутри выпусков.</target>
        </trans-unit>
        <trans-unit id="7e1d9cf438c969dee7915e9b562a69ea08c11e60" translate="yes" xml:space="preserve">
          <source>It MUST NOT import any other configuration file via &lt;code&gt;import_config&lt;/code&gt;</source>
          <target state="translated">Он НЕ ДОЛЖЕН импортировать любой другой файл конфигурации через &lt;code&gt;import_config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5705683fdebc9e7c3a2a72f5f351756cecd2661" translate="yes" xml:space="preserve">
          <source>It accepts a list of &lt;code&gt;imported_paths&lt;/code&gt; that should raise if attempted to be imported again (to avoid recursive imports).</source>
          <target state="translated">Он принимает список &lt;code&gt;imported_paths&lt;/code&gt; который должен увеличиться при повторной попытке импорта (чтобы избежать рекурсивного импорта).</target>
        </trans-unit>
        <trans-unit id="8b02345541bef5990635992a1f66fbd5e80cdc19" translate="yes" xml:space="preserve">
          <source>It accepts a set of &lt;code&gt;options&lt;/code&gt; to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; (the same ones accepted by &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Он принимает набор &lt;code&gt;options&lt;/code&gt; для настройки &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt; (те же самые, которые принимает &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c6bdae26359278127b2679c1e0f6e34574670e1" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; as both functions are built on top of this function. This function may return:</source>
          <target state="translated">Он принимает те же параметры, что и &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; ,&lt;/a&gt; поскольку обе функции построены на основе этой функции. Эта функция может возвращать:</target>
        </trans-unit>
        <trans-unit id="52c79809b7aa93e13235dedf1c047e396021dbc2" translate="yes" xml:space="preserve">
          <source>It accepts the struct module or a struct itself and simply removes the &lt;code&gt;__struct__&lt;/code&gt; field from the given struct or from a new struct generated from the given module.</source>
          <target state="translated">Он принимает модуль структуры или саму структуру и просто удаляет поле &lt;code&gt;__struct__&lt;/code&gt; из данной структуры или из новой структуры, созданной из данного модуля.</target>
        </trans-unit>
        <trans-unit id="9db7ae3984a1b1beb1ad6d9414dcb836e49e4a46" translate="yes" xml:space="preserve">
          <source>It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.</source>
          <target state="translated">Она позволяет разработчику динамически добавлять,удалять и регистрировать атрибуты,прикреплять документацию и так далее.</target>
        </trans-unit>
        <trans-unit id="2ac59abc929bedbd71d6ab74f36247bff27a3d81" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 process. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="translated">Это позволяет разработчикам искать один или несколько процессов с заданным ключом. Если в реестре есть &lt;code&gt;:unique&lt;/code&gt; ключи, ключ указывает на 0 или 1 процесс. Если реестр допускает &lt;code&gt;:duplicate&lt;/code&gt; ключи, один ключ может указывать на любое количество процессов. В обоих случаях разные ключи могут идентифицировать один и тот же процесс.</target>
        </trans-unit>
        <trans-unit id="5e72ef20465fc62c76630754f83ef1dcdcf00df1" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 processes. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="translated">Это позволяет разработчикам искать один или несколько процессов с заданным ключом. Если в реестре есть &lt;code&gt;:unique&lt;/code&gt; ключи, ключ указывает на 0 или 1 процесс. Если реестр допускает &lt;code&gt;:duplicate&lt;/code&gt; ключи, один ключ может указывать на любое количество процессов. В обоих случаях разные ключи могут идентифицировать один и тот же процесс.</target>
        </trans-unit>
        <trans-unit id="4a71454b932a3e5f1fc7b4c0e7b18e42341a6164" translate="yes" xml:space="preserve">
          <source>It also accepts extra options, for the list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он также принимает дополнительные параметры, список доступных параметров проверьте &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fbb9737feae3b4fd98e6dc6a9178278f7164fb2" translate="yes" xml:space="preserve">
          <source>It also accepts functions in the format &lt;code&gt;function/arity&lt;/code&gt; and &lt;code&gt;module.function/arity&lt;/code&gt;, for example:</source>
          <target state="translated">Он также принимает функции в формате &lt;code&gt;function/arity&lt;/code&gt; &lt;code&gt;module.function/arity&lt;/code&gt; и module.function / arity , например:</target>
        </trans-unit>
        <trans-unit id="99ac564cc223e5941d854a27c61609f6da592403" translate="yes" xml:space="preserve">
          <source>It also accepts single module argument to list all available behaviour callbacks.</source>
          <target state="translated">Он также принимает аргумент одного модуля,чтобы перечислить все доступные поведенческие обратные вызовы.</target>
        </trans-unit>
        <trans-unit id="c75c3d13969e4bc5682206b7605cdbcb131cac76" translate="yes" xml:space="preserve">
          <source>It also checks the inbox for an input message matching:</source>
          <target state="translated">Также проверяется соответствие входящего сообщения:</target>
        </trans-unit>
        <trans-unit id="d684369d14eb5a8f47ce27babf1c852d61fa5f18" translate="yes" xml:space="preserve">
          <source>It also works with operators and other constructs (try &lt;code&gt;h +/2&lt;/code&gt;). Invoking &lt;code&gt;h&lt;/code&gt; without arguments displays the documentation for &lt;code&gt;IEx.Helpers&lt;/code&gt;, which is where &lt;code&gt;h&lt;/code&gt; and other functionality is defined.</source>
          <target state="translated">Он также работает с операторами и другими конструкциями (попробуйте &lt;code&gt;h +/2&lt;/code&gt; ). Вызов &lt;code&gt;h&lt;/code&gt; без аргументов отображает документацию для &lt;code&gt;IEx.Helpers&lt;/code&gt; , где определены &lt;code&gt;h&lt;/code&gt; и другие функции.</target>
        </trans-unit>
        <trans-unit id="66bb36cef2226ba0f885d74efad89fc9715f130c" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;:ok&lt;/code&gt;. Raises an error for invalid options.</source>
          <target state="translated">Всегда возвращается &lt;code&gt;:ok&lt;/code&gt; . Вызывает ошибку при недопустимых параметрах.</target>
        </trans-unit>
        <trans-unit id="5c52aede24529ec1285e253d78f2de5411948ef5" translate="yes" xml:space="preserve">
          <source>It assumes the application exists in the release.</source>
          <target state="translated">Он предполагает,что приложение существует в выпуске.</target>
        </trans-unit>
        <trans-unit id="a500beab3e68eedeee4019c52133aa404957a732" translate="yes" xml:space="preserve">
          <source>It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns &lt;code&gt;false&lt;/code&gt; for symbolic links pointing to non-existing targets.</source>
          <target state="translated">Это может быть обычный файл, каталог, сокет, символическая ссылка, именованный канал или файл устройства. Возвращает &lt;code&gt;false&lt;/code&gt; для символических ссылок, указывающих на несуществующие цели.</target>
        </trans-unit>
        <trans-unit id="c22cd573aa0e917048596a531fe8bd4df0ba66d2" translate="yes" xml:space="preserve">
          <source>It can be upgraded to the DynamicSupervisor like this:</source>
          <target state="translated">Он может быть модернизирован до DynamicSupervisor вот так:</target>
        </trans-unit>
        <trans-unit id="7d4ae51a95fbbfa60a796e3589c4762cdf4df826" translate="yes" xml:space="preserve">
          <source>It can be used in your &lt;code&gt;mix.exs&lt;/code&gt; to prepend or append new compilers to Mix:</source>
          <target state="translated">Его можно использовать в вашем &lt;code&gt;mix.exs&lt;/code&gt; для добавления новых компиляторов в Mix:</target>
        </trans-unit>
        <trans-unit id="28b1a3769a282dd753685d31c1db0ca20ed8c01c" translate="yes" xml:space="preserve">
          <source>It contains the following fields:</source>
          <target state="translated">Он содержит следующие поля:</target>
        </trans-unit>
        <trans-unit id="af1426f38289e13f36126375da54309f97a70a12" translate="yes" xml:space="preserve">
          <source>It contains these fields:</source>
          <target state="translated">Он содержит эти поля:</target>
        </trans-unit>
        <trans-unit id="113d9a8235b2ac8f428decf342fbd7858aa4973c" translate="yes" xml:space="preserve">
          <source>It could also be corrected by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="translated">Его также можно исправить,используя несколько охранников,так что если исключение приводит к отказу одного охранника,то оценивается следующий.</target>
        </trans-unit>
        <trans-unit id="d0ae36b9918c76d1dbdaba834a0193896ca365cc" translate="yes" xml:space="preserve">
          <source>It defaults to safely download a Rebar copy from Hex's CDN. However, a URL can be given as argument, usually for an existing local copy of Rebar:</source>
          <target state="translated">По умолчанию безопасно загрузить копию перезагрузки с CDN Hex.Однако,в качестве аргумента может быть указан URL,обычно для существующей локальной копии Rebar:</target>
        </trans-unit>
        <trans-unit id="1987bff89f1c6703dd2895ae7707929f8d89192f" translate="yes" xml:space="preserve">
          <source>It depends. It is ok to rely on shared state as long as we depend only on a non-shared partition of this state. Although multiple registries may start buckets on the shared bucket supervisor, those buckets and registries are isolated from each other. We would only run into concurrency issues if we used a function like &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; which would count all buckets from all registries, potentially giving different results when tests run concurrently.</source>
          <target state="translated">Это зависит. Можно полагаться на разделяемое состояние, пока мы зависим только от не разделяемого раздела этого состояния. Хотя несколько реестров могут запускать сегменты в супервизоре общего сегмента, эти сегменты и реестры изолированы друг от друга. Мы столкнулись бы с проблемами параллелизма, только если бы мы использовали такую ​​функцию, как &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; которая будет подсчитывать все сегменты из всех реестров, потенциально давая разные результаты при одновременном запуске тестов.</target>
        </trans-unit>
        <trans-unit id="4a261e69bb9abf1be6a9e6bf29d1f5c299e998d0" translate="yes" xml:space="preserve">
          <source>It differs in that the test suite will fail if no tests are executed when the &lt;code&gt;--only&lt;/code&gt; option is used.</source>
          <target state="translated">Он отличается тем, что набор тестов завершится ошибкой, если при &lt;code&gt;--only&lt;/code&gt; параметра --only не будут выполнены тесты .</target>
        </trans-unit>
        <trans-unit id="bebaceae48e94abb745e77cdc9d79c5704717c94" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t seem to work at all. That&amp;rsquo;s because we are serving requests in the same process that are accepting connections. When one client is connected, we can&amp;rsquo;t accept another client.</source>
          <target state="translated">Кажется, это вообще не работает. Это потому, что мы обслуживаем запросы в том же процессе, что и прием соединений. Когда подключен один клиент, мы не можем принять другого клиента.</target>
        </trans-unit>
        <trans-unit id="18c00afbabba2721adf88ec3c29e863b42471b6a" translate="yes" xml:space="preserve">
          <source>It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the &lt;code&gt;:width&lt;/code&gt; option.</source>
          <target state="translated">По умолчанию он обеспечивает красивую печать шириной 80 символов. Ширину можно изменить, явно передав параметр &lt;code&gt;:width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38c802c651048f44f24f8b3150960035a31699cb" translate="yes" xml:space="preserve">
          <source>It exists for convenience purposes. For example, you could invoke it inside your &lt;code&gt;mix.exs&lt;/code&gt; to read some external data you decided to move to a configuration file:</source>
          <target state="translated">Он существует для удобства. Например, вы можете вызвать его внутри вашего &lt;code&gt;mix.exs&lt;/code&gt; для чтения некоторых внешних данных, которые вы решили переместить в файл конфигурации:</target>
        </trans-unit>
        <trans-unit id="cfbe9f805346901fb7658c3a10caf05daf303078" translate="yes" xml:space="preserve">
          <source>It expects a &lt;code&gt;radius&lt;/code&gt; which chooses how many lines before and after the current line we should print. By default the &lt;code&gt;radius&lt;/code&gt; is of two lines:</source>
          <target state="translated">Он ожидает &lt;code&gt;radius&lt;/code&gt; который выбирает, сколько строк до и после текущей строки мы должны напечатать. По умолчанию &lt;code&gt;radius&lt;/code&gt; состоит из двух линий:</target>
        </trans-unit>
        <trans-unit id="e8f41592949431573d9fa16ad07b816bc20d280c" translate="yes" xml:space="preserve">
          <source>It expects a child specification or a module, similar to the ones given to &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt;. For example, if your application starts a supervision tree by running:</source>
          <target state="translated">Он ожидает дочернюю спецификацию или модуль, аналогичный тем, которые даны для &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt; . Например, если ваше приложение запускает дерево наблюдения, запустив:</target>
        </trans-unit>
        <trans-unit id="88606c2938fbdad4196a7b400eb0db21cee6ea05" translate="yes" xml:space="preserve">
          <source>It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given.</source>
          <target state="translated">Он ожидает список файлов для компиляции и необязательный путь для написания скомпилированного кода.По умолчанию файлы компилируются в памяти.Для записи скомпилированных файлов в текущий каталог можно указать пустую строку.</target>
        </trans-unit>
        <trans-unit id="6adc6a5d8736969f9827e5e4d2dbab0ae103ab01" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is not passed it will default to &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt;, which always succeeds. Otherwise, the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">Ожидается, что часовой пояс будет помещен в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . Если часовой пояс не передан, по умолчанию будет установлено &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt; , что всегда успешно. В противном случае &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; &lt;code&gt;time_zone_database&lt;/code&gt; базой данных часовых поясов, заданной как time_zone_database . См. Раздел &amp;laquo;База данных часовых поясов&amp;raquo; в документации модуля.</target>
        </trans-unit>
        <trans-unit id="8a2620b634b0dd22db12b71fb16f9100f9f18265" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is not passed it will default to &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt;, which always succeeds. Otherwise, the DateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">Ожидается, что часовой пояс будет помещен в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . Если часовой пояс не передан, по умолчанию будет установлено &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt; , что всегда успешно. В противном случае DateTime &lt;code&gt;time_zone_database&lt;/code&gt; базой данных часовых поясов, заданной как time_zone_database . См. Раздел &amp;laquo;База данных часовых поясов&amp;raquo; в документации модуля.</target>
        </trans-unit>
        <trans-unit id="546a02d155d91f970f8b486494def9374e27bedc" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; что часовой пояс будет помещен в NaiveDateTime . Если часовой пояс &amp;laquo;Etc / UTC&amp;raquo;, это всегда успешно. В противном случае NaiveDateTime проверяется по базе данных часовых поясов, заданной как &lt;code&gt;time_zone_database&lt;/code&gt; . См. Раздел &amp;laquo;База данных часовых поясов&amp;raquo; в документации модуля.</target>
        </trans-unit>
        <trans-unit id="f95cc29acd1a8f43652435b365857f4644147164" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; что часовой пояс будет помещен в NaiveDateTime . Если часовой пояс &amp;laquo;Etc / UTC&amp;raquo;, это всегда успешно. В противном случае NaiveDateTime проверяется по базе данных часовых поясов, заданной как &lt;code&gt;time_zone_database&lt;/code&gt; . См. Раздел &amp;laquo;База данных часовых поясов&amp;raquo; в документации модуля.</target>
        </trans-unit>
        <trans-unit id="1a16340d7de1aebc03edf6573a0e15525a829528" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">Ожидается, что часовой пояс будет помещен в NaiveDateTime. Если часовой пояс &amp;laquo;Etc / UTC&amp;raquo;, это всегда успешно. В противном случае NaiveDateTime проверяется по базе данных часовых поясов, заданной как &lt;code&gt;time_zone_database&lt;/code&gt; . См. Раздел &amp;laquo;База данных часовых поясов&amp;raquo; в документации модуля.</target>
        </trans-unit>
        <trans-unit id="c6e8dcd4689f9bb5cfe59fd80447b6dfb675bc3e" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">Он ожидает аккумулятор и функцию, которая получает каждый перечислимый элемент, и должна возвращать кортеж, содержащий новый перечислимый элемент (часто список) с новым аккумулятором или кортеж с &lt;code&gt;:halt&lt;/code&gt; в качестве первого элемента и аккумулятора в качестве второго.</target>
        </trans-unit>
        <trans-unit id="ae9f951251e613dc3b8cb49889447942b487f90f" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">Он ожидает аккумулятор и функцию, которая принимает каждый элемент потока и аккумулятор, и должна возвращать кортеж, содержащий новый поток (часто список) с новым аккумулятором или кортеж с &lt;code&gt;:halt&lt;/code&gt; в качестве первого элемента и аккумулятора в качестве второго.</target>
        </trans-unit>
        <trans-unit id="cccf2ce5212dd9d14c0a4002d35324d8f82c2fda" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator. It must return a tuple, where the first element is a new stream (often a list) or the atom &lt;code&gt;:halt&lt;/code&gt;, and the second element is the accumulator to be used by the next element, if any, in both cases.</source>
          <target state="translated">Он ожидает аккумулятор и функцию, которая принимает каждый элемент потока и аккумулятор. Он должен возвращать кортеж, где первый элемент - это новый поток (часто список) или атом &lt;code&gt;:halt&lt;/code&gt; , а второй элемент - аккумулятор, который будет использоваться следующим элементом, если таковой имеется, в обоих случаях.</target>
        </trans-unit>
        <trans-unit id="cdb9574f709769eda3fcd701f6835100d09de7b2" translate="yes" xml:space="preserve">
          <source>It happens we can also use this same syntax for updating the value:</source>
          <target state="translated">Бывает,что мы также можем использовать этот же синтаксис для обновления значения:</target>
        </trans-unit>
        <trans-unit id="7d301b15b4e45486cec4db8315f250c006b60e6f" translate="yes" xml:space="preserve">
          <source>It has to be replaced by:</source>
          <target state="translated">Его нужно заменить:</target>
        </trans-unit>
        <trans-unit id="272be857efb69d0027fa3d247e076f214cedbf37" translate="yes" xml:space="preserve">
          <source>It includes assigns (like &lt;code&gt;@foo&lt;/code&gt;) and possibly other conveniences in the future.</source>
          <target state="translated">Он включает в себя назначения (например, &lt;code&gt;@foo&lt;/code&gt; ) и, возможно, другие удобства в будущем.</target>
        </trans-unit>
        <trans-unit id="6566504417caf3c9fcfa6f04770ab2069caa71e8" translate="yes" xml:space="preserve">
          <source>It includes many features:</source>
          <target state="translated">Он включает в себя множество функций:</target>
        </trans-unit>
        <trans-unit id="71b759b7ba0ceba9436adc2e4d919d9a0599963f" translate="yes" xml:space="preserve">
          <source>It is advised to pass to &lt;a href=&quot;#to_argv/2&quot;&gt;&lt;code&gt;to_argv/2&lt;/code&gt;&lt;/a&gt; the same set of &lt;code&gt;options&lt;/code&gt; given to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;. Some switches can only be reconstructed correctly with the &lt;code&gt;:switches&lt;/code&gt; information in hand.</source>
          <target state="translated">Рекомендуется передать &lt;a href=&quot;#to_argv/2&quot;&gt; &lt;code&gt;to_argv/2&lt;/code&gt; &lt;/a&gt; тот же набор &lt;code&gt;options&lt;/code&gt; что и &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; . Некоторые переключатели можно правильно реконструировать только при наличии информации &lt;code&gt;:switches&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eb61a3d0a7df51c644f050632b4aa72ddabe51e" translate="yes" xml:space="preserve">
          <source>It is also common to define your setup as a series of functions, which are put together by calling &lt;code&gt;setup&lt;/code&gt; or &lt;code&gt;setup_all&lt;/code&gt; with a list of atoms. Each of these functions receive the context and can return any of the values allowed in &lt;code&gt;setup&lt;/code&gt; blocks:</source>
          <target state="translated">Также принято определять вашу установку как серию функций, которые объединяются путем вызова &lt;code&gt;setup&lt;/code&gt; или &lt;code&gt;setup_all&lt;/code&gt; со списком атомов. Каждая из этих функций получает контекст и может возвращать любое из значений, разрешенных в блоках &lt;code&gt;setup&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c0856684d2283019235a3b8fb6bf7df63dcb5c31" translate="yes" xml:space="preserve">
          <source>It is also possible to capture public module functions and pass them around as if they were anonymous functions by using the capture operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;amp;/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.&amp;amp;/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Также возможно захватить функции общедоступного модуля и передать их, как если бы они были анонимными функциями, с помощью оператора захвата &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;amp;/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.&amp;amp;/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="56aeb1cfede9d1959649b5d6d4fd4f20a2043a1a" translate="yes" xml:space="preserve">
          <source>It is also possible to format code across the whole project by passing a list of patterns and files to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix format&lt;/code&gt;&lt;/a&gt;, as shown at the top of this task documentation. This list can also be set in the &lt;code&gt;.formatter.exs&lt;/code&gt; file under the &lt;code&gt;:inputs&lt;/code&gt; key.</source>
          <target state="translated">Также можно отформатировать код для всего проекта, передав список шаблонов и файлов для &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix format&lt;/code&gt; &lt;/a&gt; , как показано в верхней части этой документации по задаче. Этот список также можно задать в файле &lt;code&gt;.formatter.exs&lt;/code&gt; с помощью ключа &lt;code&gt;:inputs&lt;/code&gt; inputs .</target>
        </trans-unit>
        <trans-unit id="5ec9133e5ffa0e2eb38967925bbcd3b498316545" translate="yes" xml:space="preserve">
          <source>It is also possible to put an element at a particular index in a tuple with &lt;code&gt;put_elem/3&lt;/code&gt;:</source>
          <target state="translated">Также можно поместить элемент по определенному индексу в кортеж с помощью &lt;code&gt;put_elem/3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="68a13c5162ca9952e7df7f252e41c665b4a6ce1a" translate="yes" xml:space="preserve">
          <source>It is also possible to register the &lt;code&gt;pid&lt;/code&gt;, giving it a name, and allowing everyone that knows the name to send it messages:</source>
          <target state="translated">Также можно зарегистрировать &lt;code&gt;pid&lt;/code&gt; , присвоив ему имя и разрешив всем, кто знает это имя, отправлять ему сообщения:</target>
        </trans-unit>
        <trans-unit id="a136eb79bc8a61b01254d5faf81fdf246125d6a9" translate="yes" xml:space="preserve">
          <source>It is also possible to spawn a task under a supervisor. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module implements the &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, which allows it to be started directly under a supervisor by passing a tuple with a function to run:</source>
          <target state="translated">Также возможно создать задачу под супервизором. Модуль &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; реализует &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; , которая позволяет запускать его непосредственно под супервизором, передавая кортеж с функцией для запуска:</target>
        </trans-unit>
        <trans-unit id="d56d59c22a31d0146ae9749c3030a51ef3731009" translate="yes" xml:space="preserve">
          <source>It is also used between &lt;code&gt;fn/end&lt;/code&gt; for building anonymous functions:</source>
          <target state="translated">Он также используется между &lt;code&gt;fn/end&lt;/code&gt; для создания анонимных функций:</target>
        </trans-unit>
        <trans-unit id="56e71075219fd34ef819cdd9dc47abc0939b0f36" translate="yes" xml:space="preserve">
          <source>It is also very common to use &lt;code&gt;IO.inspect/2&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt;&lt;code&gt;binding()&lt;/code&gt;&lt;/a&gt;, which returns all variable names and their values:</source>
          <target state="translated">Также очень часто &lt;code&gt;IO.inspect/2&lt;/code&gt; используется с &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt; &lt;code&gt;binding()&lt;/code&gt; &lt;/a&gt; , которая возвращает все имена переменных и их значения:</target>
        </trans-unit>
        <trans-unit id="d30bf8f40195feb2fe708ceb6f9af150955200b6" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 366.</source>
          <target state="translated">Это целое число от 1 до 366.</target>
        </trans-unit>
        <trans-unit id="32489e7a3e2d6e237839e846a2d9f094cd20f95c" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 4.</source>
          <target state="translated">Это целое число от 1 до 4.</target>
        </trans-unit>
        <trans-unit id="aef7af646cd422fb9f21670a1cedef851042bc5d" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</source>
          <target state="translated">Это целое число от 1 до 7,где 1-понедельник и 7-воскресенье.</target>
        </trans-unit>
        <trans-unit id="9d6b7aa9053923985210f1530605583decd65914" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is the given &lt;code&gt;starting_on&lt;/code&gt; weekday. For example, if &lt;code&gt;starting_on&lt;/code&gt; is set to &lt;code&gt;:monday&lt;/code&gt;, then 1 is Monday and 7 is Sunday.</source>
          <target state="translated">Это целое число от 1 до 7, где 1 - заданный &lt;code&gt;starting_on&lt;/code&gt; недели. Например, если &lt;code&gt;starting_on&lt;/code&gt; установлен в &lt;code&gt;:monday&lt;/code&gt; , а затем 1 понедельник и 7 это воскресенье.</target>
        </trans-unit>
        <trans-unit id="e3505fd23f7d466c912f750fe33536eb913541ef" translate="yes" xml:space="preserve">
          <source>It is available only in the &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; clauses of &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">Он доступен только в &lt;code&gt;catch&lt;/code&gt; и &lt;code&gt;rescue&lt;/code&gt; пунктах &lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt; выражений.</target>
        </trans-unit>
        <trans-unit id="80946675cc21f317c9b0ef6e5905961ee735ea93" translate="yes" xml:space="preserve">
          <source>It is exactly this supervision system that makes constructs like &lt;code&gt;try/catch&lt;/code&gt; and &lt;code&gt;try/rescue&lt;/code&gt; so uncommon in Elixir. Instead of rescuing an error, we&amp;rsquo;d rather &amp;ldquo;fail fast&amp;rdquo; since the supervision tree will guarantee our application will go back to a known initial state after the error.</source>
          <target state="translated">Именно эта система надзора делает такие конструкции, как &lt;code&gt;try/catch&lt;/code&gt; и &lt;code&gt;try/rescue&lt;/code&gt; , столь необычными в Эликсире. Вместо того, чтобы исправлять ошибку, мы предпочли бы &amp;laquo;быстро выйти из строя&amp;raquo;, поскольку дерево наблюдения гарантирует, что наше приложение вернется в известное начальное состояние после ошибки.</target>
        </trans-unit>
        <trans-unit id="d207929393d3a65f7ffe43fdfee93a560fcbb309" translate="yes" xml:space="preserve">
          <source>It is extremely important that &lt;strong&gt;the formatting function does not fail&lt;/strong&gt;, as it will bring that particular logger instance down, causing your system to temporarily lose messages. If necessary, wrap the function in a &lt;code&gt;rescue&lt;/code&gt; and log a default message instead:</source>
          <target state="translated">Чрезвычайно важно, &lt;strong&gt;чтобы функция форматирования не сработала&lt;/strong&gt; , так как это приведет к отключению этого конкретного экземпляра регистратора, в результате чего ваша система временно потеряет сообщения. Если необходимо, оберните функцию в &lt;code&gt;rescue&lt;/code&gt; и вместо этого запишите сообщение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="94832ece51ae5f1825006490cfa48c6fe6830752" translate="yes" xml:space="preserve">
          <source>It is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won&amp;rsquo;t be expanded and will be translated to a function call:</source>
          <target state="translated">Важно, чтобы макрос был определен перед его использованием. Неспособность определить макрос до его вызова вызовет ошибку во время выполнения, поскольку макрос не будет расширен и будет преобразован в вызов функции:</target>
        </trans-unit>
        <trans-unit id="0771070acf565ebd4c40d426b39c1e6523d52f21" translate="yes" xml:space="preserve">
          <source>It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window.</source>
          <target state="translated">Важно выбрать команду редактора,которая не блокирует и не пытается запустить редактор непосредственно в терминале.Редакторы,основанные на командной строке,скорее всего,нуждаются в дополнительной настройке,поэтому они открывают данный файл и строку в отдельном окне.</target>
        </trans-unit>
        <trans-unit id="b481005fe84ee670ac7d11f9a15a1a80d4c1bd8f" translate="yes" xml:space="preserve">
          <source>It is important to bear in mind that variables defined inside &lt;code&gt;try/catch/rescue/after&lt;/code&gt; blocks do not leak to the outer context. This is because the &lt;code&gt;try&lt;/code&gt; block may fail and as such the variables may never be bound in the first place. In other words, this code is invalid:</source>
          <target state="translated">Важно помнить, что переменные, определенные внутри блоков &lt;code&gt;try/catch/rescue/after&lt;/code&gt; , не попадают во внешний контекст. Это связано с тем, что блок &lt;code&gt;try&lt;/code&gt; может дать сбой, и поэтому переменные вообще могут никогда не быть привязаны. Другими словами, этот код недействителен:</target>
        </trans-unit>
        <trans-unit id="d6056e64535d65b5186c963f7472dd3b3997efc0" translate="yes" xml:space="preserve">
          <source>It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments.</source>
          <target state="translated">Важно учитывать ограничения распределенных агентов.Агенты предоставляют два API,один из которых работает с анонимными функциями,а другой ожидает явного модуля,функции и аргументов.</target>
        </trans-unit>
        <trans-unit id="f355f25591ea852cf993c5e79bb23c864b9b3d30" translate="yes" xml:space="preserve">
          <source>It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is invoked only after termination of the whole supervision tree.</source>
          <target state="translated">Важно подчеркнуть, что шаг 2 является блокирующим. Завершение супервизора вызывает рекурсивную цепочку завершений дочерних элементов, поэтому все дочерние процессы упорядоченно завершаются. &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; обратного вызова вызывается только после завершения всего дерева контроля.</target>
        </trans-unit>
        <trans-unit id="a5cda11adf3996ed10a3333a6901fb7bf070783d" translate="yes" xml:space="preserve">
          <source>It is important to note a couple of things:</source>
          <target state="translated">Важно отметить пару вещей:</target>
        </trans-unit>
        <trans-unit id="3bb3eb88d00232d84e73101145b87680a8e850e6" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="translated">Важно отметить, что &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; является лексическим. Это означает, что вы можете импортировать определенные макросы в определенные функции:</target>
        </trans-unit>
        <trans-unit id="c367faed115a28802b3ecac8ce4c9b1b9a88de2a" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="translated">Важно отметить, что имя без &lt;code&gt;!&lt;/code&gt; не означает, что функция никогда не будет повышаться. Например, даже &lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; может выйти из строя в случае неверных аргументов:</target>
        </trans-unit>
        <trans-unit id="aa95687972f4da1c12036d1d732365101465e0f4" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="translated">Важно отметить, что имя без &lt;code&gt;!&lt;/code&gt; не означает, что функция никогда не будет повышаться. Например, даже &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; может выйти из строя в случае неверных аргументов:</target>
        </trans-unit>
        <trans-unit id="0c642ed82cafd6a24d5b1cc716988f94df5a4508" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="translated">Важно отметить, что при чтении атрибута делается снимок его текущего значения. Другими словами, значение читается во время компиляции, а не во время выполнения. Проверьте &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; наличие других функций для управления атрибутами модуля.</target>
        </trans-unit>
        <trans-unit id="64d0775b812a63ae04cc72818c998dd0360e82ac" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="translated">Важно отметить, что при чтении атрибута делается снимок его текущего значения. Другими словами, значение читается во время компиляции, а не во время выполнения. Проверьте &lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; наличие других функций для управления атрибутами модуля.</target>
        </trans-unit>
        <trans-unit id="a19241f2445b2abd37c68c335fe23ae6dbe32fe5" translate="yes" xml:space="preserve">
          <source>It is important to notice that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="translated">Важно отметить, что &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; является лексическим. Это означает, что вы можете импортировать определенные макросы в определенные функции:</target>
        </trans-unit>
        <trans-unit id="74faff03e6fb39084e8fdee360d2d52a55c9644f" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Не рекомендуется &lt;code&gt;await&lt;/code&gt; длительную задачу внутри поведения OTP, такого как &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . Вместо этого вы должны сопоставить сообщение, исходящее от задачи, внутри вашего обратного вызова &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о формате сообщения см. В документации по &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a27744ee2d67c05a1fd73d07307738a8c486c4d3" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Не рекомендуется &lt;code&gt;await&lt;/code&gt; длительную задачу внутри поведения OTP, такого как &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . Вместо этого вы должны сопоставить сообщение, исходящее от задачи, внутри вашего обратного вызова &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о формате сообщения см. В документации по &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4e76fae45b6859058ea6f91264d2611d753a491" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; long-running tasks inside an OTP behaviour such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#await/2&quot;&gt;&lt;code&gt;await/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Не рекомендуется &lt;code&gt;await&lt;/code&gt; длительные задачи внутри поведения OTP, такого как &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . См. &lt;a href=&quot;#await/2&quot;&gt; &lt;code&gt;await/2&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="8f8ca3b4e0816d59dc7e2cc08d33fe47c5a02853" translate="yes" xml:space="preserve">
          <source>It is not required to call this function when terminating the caller, unless exiting with reason &lt;code&gt;:normal&lt;/code&gt; or if the task is trapping exits. If the caller is exiting with a reason other than &lt;code&gt;:normal&lt;/code&gt; and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason &lt;code&gt;:shutdown&lt;/code&gt; to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</source>
          <target state="translated">При завершении вызывающего объекта вызывать эту функцию не требуется, если только для выхода не используется причина &lt;code&gt;:normal&lt;/code&gt; или если задача перехватывает выходы. Если вызывающий выходит по причине, отличной от &lt;code&gt;:normal&lt;/code&gt; , и задача не захватывает выходы, сигнал выхода вызывающего абонента остановит задачу. Вызывающий может выйти с указанием причины &lt;code&gt;:shutdown&lt;/code&gt; чтобы завершить все связанные с ним процессы, включая задачи, которые не захватывают выходы, без создания каких-либо сообщений журнала.</target>
        </trans-unit>
        <trans-unit id="8334dc9705c04a7a750a85ba594ba8cd9d9eec49" translate="yes" xml:space="preserve">
          <source>It is possible to add one or more steps before and after the release is assembled. This can be done with the &lt;code&gt;:steps&lt;/code&gt; option:</source>
          <target state="translated">Можно добавить один или несколько шагов до и после сборки релиза. Это можно сделать с помощью параметра &lt;code&gt;:steps&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d286fc13ee24e748fd4ca773cb4fabc977988588" translate="yes" xml:space="preserve">
          <source>It is possible to configure the level to capture with &lt;code&gt;:level&lt;/code&gt;, which will set the capturing level for the duration of the capture, for instance, if the log level is set to :error any message with the lower level will be ignored. The default level is &lt;code&gt;nil&lt;/code&gt;, which will capture all messages. The behaviour is undetermined if async tests change Logger level.</source>
          <target state="translated">Можно настроить уровень захвата с помощью &lt;code&gt;:level&lt;/code&gt; , который установит уровень захвата на время захвата, например, если для уровня журнала задано значение: error, любое сообщение с более низким уровнем будет проигнорировано. Уровень по умолчанию равен &lt;code&gt;nil&lt;/code&gt; , что позволяет захватить все сообщения. Поведение не определено, если асинхронные тесты изменяют уровень Регистратора.</target>
        </trans-unit>
        <trans-unit id="67f36f6c8c75697bc200a5a574eb5412409dbdaf" translate="yes" xml:space="preserve">
          <source>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</source>
          <target state="translated">Получить историю оболочки можно,передав некоторые опции,которые включают ее в ВМ.Это можно сделать по необходимости при запуске IEx:</target>
        </trans-unit>
        <trans-unit id="69aceb3d7f53fc191d1a69a74161461cd8fbf145" translate="yes" xml:space="preserve">
          <source>It is possible to implement protocols for all Elixir types:</source>
          <target state="translated">Возможно реализовать протоколы для всех типов Elixir:</target>
        </trans-unit>
        <trans-unit id="54b8401178da67a2e8ae820b1821bcca42b37a5a" translate="yes" xml:space="preserve">
          <source>It is possible to load another file by supplying the &lt;code&gt;--dot-iex&lt;/code&gt; option to IEx. See &lt;code&gt;iex --help&lt;/code&gt;.</source>
          <target state="translated">Можно загрузить другой файл, &lt;code&gt;--dot-iex&lt;/code&gt; параметр --dot-iex для IEx. См. &lt;code&gt;iex --help&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4658430a105177a520b05efa9b8a1f1f62f88a4e" translate="yes" xml:space="preserve">
          <source>It is received by formatters and contains the following fields:</source>
          <target state="translated">Он принимается форматорами и содержит следующие поля:</target>
        </trans-unit>
        <trans-unit id="02b1294519dc996fe92a26357c7d5248dd2135f9" translate="yes" xml:space="preserve">
          <source>It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.</source>
          <target state="translated">Рекомендуется вызывать эту функцию в начальном обратном вызове вашего приложения в случае,если вы хотите зарегистрировать новые URI.</target>
        </trans-unit>
        <trans-unit id="5e8259dbbda9694f8ea6053003d2b8b79b9d00cb" translate="yes" xml:space="preserve">
          <source>It is recommended that backends support at least the following configuration options:</source>
          <target state="translated">Рекомендуется,чтобы бэкэнды поддерживали,по крайней мере,следующие параметры конфигурации:</target>
        </trans-unit>
        <trans-unit id="01b6fa79cb9bec0bdf62d160c7cca8aebb12f76e" translate="yes" xml:space="preserve">
          <source>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</source>
          <target state="translated">Рекомендуется,чтобы обработчики игнорировали сообщения,в которых лидер группы находится в другом узле,чем тот,в котором установлен обработчик.Например:</target>
        </trans-unit>
        <trans-unit id="f259c2cd34cad051f58a609a1b449871f089e4f6" translate="yes" xml:space="preserve">
          <source>It is recommended to define types for structs. By convention such type is called &lt;code&gt;t&lt;/code&gt;. To define a struct inside a type, the struct literal syntax is used:</source>
          <target state="translated">Рекомендуется определять типы для структур. Условно такой тип называется &lt;code&gt;t&lt;/code&gt; . Чтобы определить структуру внутри типа, используется синтаксис литерала структуры:</target>
        </trans-unit>
        <trans-unit id="2d5fa416a3649615d6c6d6b9cb2027f26118c8ff" translate="yes" xml:space="preserve">
          <source>It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use &lt;code&gt;User.t&lt;/code&gt; instead of &lt;code&gt;%User{}&lt;/code&gt;.</source>
          <target state="translated">При определении типа структуры рекомендуется использовать только синтаксис структуры. При ссылке на другую структуру лучше использовать &lt;code&gt;User.t&lt;/code&gt; вместо &lt;code&gt;%User{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5056e9d07d3e016975093e74ccd6e13e0e051a1" translate="yes" xml:space="preserve">
          <source>It is seen on &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt; constructs between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">Это видно в конструкциях &lt;code&gt;case&lt;/code&gt; и &lt;code&gt;cond&lt;/code&gt; между &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5a7029e719605ca3d075a3021c347e0da442f5a" translate="yes" xml:space="preserve">
          <source>It is the VM view of the &lt;a href=&quot;#os_time/0&quot;&gt;&lt;code&gt;os_time/0&lt;/code&gt;&lt;/a&gt;. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</source>
          <target state="translated">Это представление VM для &lt;a href=&quot;#os_time/0&quot;&gt; &lt;code&gt;os_time/0&lt;/code&gt; &lt;/a&gt; . Они могут не совпадать в случае деформации времени, хотя виртуальная машина работает над их выравниванием. На этот раз не монотонно.</target>
        </trans-unit>
        <trans-unit id="788b993466f063f33f672e4a2e86998a7111a391" translate="yes" xml:space="preserve">
          <source>It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">Он полезен для выполнения работы после инициализации или для разделения работы в обратном вызове на несколько этапов,обновления состояния процесса на этом пути.</target>
        </trans-unit>
        <trans-unit id="bb15e04c4610818bfc29250241bbd9f9e91a6db6" translate="yes" xml:space="preserve">
          <source>It is usually compiled to an atom:</source>
          <target state="translated">Обычно он компилируется в атом:</target>
        </trans-unit>
        <trans-unit id="8399d5e7ea32483e0653c8979fe14b6e85b08287" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt;&lt;code&gt;mix format&lt;/code&gt;&lt;/a&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="translated">Стоит упомянуть, что некоторые задачи, например, в случае команды &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt; &lt;code&gt;mix format&lt;/code&gt; &lt;/a&gt; в приведенном выше примере, могут принимать несколько файлов, поэтому их можно переписать как:</target>
        </trans-unit>
        <trans-unit id="609d6804675f59ef88a96987b74ba4711ad19be8" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;code&gt;format&lt;/code&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="translated">Стоит отметить, что некоторые задачи, например, в случае команды &lt;code&gt;format&lt;/code&gt; в приведенном выше примере, могут принимать несколько файлов, поэтому их можно переписать как:</target>
        </trans-unit>
        <trans-unit id="581eca3344ca4bb0aa530a5501c01bfdeab48bb0" translate="yes" xml:space="preserve">
          <source>It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">Стоит отметить,что поток ввода-вывода имеет побочные эффекты,и каждый раз,когда вы проходите по потоку,вы можете получить разные результаты.</target>
        </trans-unit>
        <trans-unit id="d5d4db08190e3953685aadfa886d49cc802cec92" translate="yes" xml:space="preserve">
          <source>It is, however, possible to customize the operating system exit signal by invoking:</source>
          <target state="translated">Однако можно настроить сигнал выхода операционной системы путем вызова:</target>
        </trans-unit>
        <trans-unit id="b7d48f671c8d7393dad3a546a97b3ca8d3a912b7" translate="yes" xml:space="preserve">
          <source>It mainly consists of:</source>
          <target state="translated">В основном он состоит из:</target>
        </trans-unit>
        <trans-unit id="1e0c789d57c1d4d0b775a90fcdfa554caa5f5673" translate="yes" xml:space="preserve">
          <source>It may also be used in bit strings to specify the type of a given bit segment:</source>
          <target state="translated">Он также может быть использован в битовых строках для указания типа заданного сегмента бита:</target>
        </trans-unit>
        <trans-unit id="a3af067d0b325c04e2171267019d9beee23844b2" translate="yes" xml:space="preserve">
          <source>It may be &lt;em&gt;done&lt;/em&gt; when the enumeration is finished by reaching its end, or &lt;em&gt;halted&lt;/em&gt;/&lt;em&gt;suspended&lt;/em&gt; when the enumeration was halted or suspended by the &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Это может быть &lt;em&gt;выполнено,&lt;/em&gt; когда перечисление завершено, достигнув своего конца, или &lt;em&gt;остановлено&lt;/em&gt; / &lt;em&gt;приостановлено,&lt;/em&gt; когда перечисление было остановлено или приостановлено функцией &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d98718d8646c579d0371793bd45e746bde50bf4" translate="yes" xml:space="preserve">
          <source>It may raise an exception if an alias or a task can't be found or the task is invalid. Check &lt;a href=&quot;#get!/1&quot;&gt;&lt;code&gt;get!/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Это может вызвать исключение, если псевдоним или задача не могут быть найдены или задача недействительна. Проверьте &lt;a href=&quot;#get!/1&quot;&gt; &lt;code&gt;get!/1&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="29d3bbbc7e626b9af27ea95ab16c0ff3bafa7043" translate="yes" xml:space="preserve">
          <source>It may return:</source>
          <target state="translated">Он может вернуться:</target>
        </trans-unit>
        <trans-unit id="96e34b31aa2d5f1e971f892ae829e91c39507ae8" translate="yes" xml:space="preserve">
          <source>It merely logged an error but the parent process is still running. That&amp;rsquo;s because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with &lt;code&gt;spawn_link/1&lt;/code&gt;:</source>
          <target state="translated">Он просто зарегистрировал ошибку, но родительский процесс все еще работает. Это потому, что процессы изолированы. Если мы хотим, чтобы сбой в одном процессе распространялся на другой, мы должны связать их. Это можно сделать с помощью &lt;code&gt;spawn_link/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7645b02092dd9c481669b06461dd8a3b1f2ddfe" translate="yes" xml:space="preserve">
          <source>It must be a tagged tuple with one of the following &quot;tags&quot;:</source>
          <target state="translated">Это должен быть кортеж с меткой с одним из следующих &quot;тегов&quot;:</target>
        </trans-unit>
        <trans-unit id="30bfead53f6532d0dcb4d8f1a07f530eb7b28e4c" translate="yes" xml:space="preserve">
          <source>It must be added to &lt;a href=&quot;#t:utc_offset/0&quot;&gt;&lt;code&gt;utc_offset/0&lt;/code&gt;&lt;/a&gt; to get the total offset from UTC used for &quot;wall time&quot;.</source>
          <target state="translated">Его необходимо добавить к &lt;a href=&quot;#t:utc_offset/0&quot;&gt; &lt;code&gt;utc_offset/0&lt;/code&gt; ,&lt;/a&gt; чтобы получить общее смещение от UTC, используемое для &amp;laquo;времени стены&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9191e1a92c69837df58d349dc309a932384aa7e6" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the nesting.</source>
          <target state="translated">Он должен возвращать вложенные выражения Эликсира в кавычках.</target>
        </trans-unit>
        <trans-unit id="712b77376d5995f0d379321d9075dffa76132d6d" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the template.</source>
          <target state="translated">Он должен возвращать для шаблона выражения Elixir в кавычках.</target>
        </trans-unit>
        <trans-unit id="38cc5837d518a2974bbdd3756a4a52b60b4904d1" translate="yes" xml:space="preserve">
          <source>It must return a new state that is used only inside the nesting. Once the nesting terminates, the current &lt;code&gt;state&lt;/code&gt; is resumed.</source>
          <target state="translated">Он должен возвращать новое состояние, которое используется только внутри вложения. По окончании вложения восстанавливается текущее &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9f2946629b87a86268abeeb2d37b8eeaaa2dbc9" translate="yes" xml:space="preserve">
          <source>It must return the current lock.</source>
          <target state="translated">Он должен вернуть текущий замок.</target>
        </trans-unit>
        <trans-unit id="0854aef4598e67609aceb61dad3e1730bf8b1dd1" translate="yes" xml:space="preserve">
          <source>It must return the initial state.</source>
          <target state="translated">Он должен вернуть начальное состояние.</target>
        </trans-unit>
        <trans-unit id="e3fb70c8558503fe57ada3a7512d669bb23cc15f" translate="yes" xml:space="preserve">
          <source>It must return the updated state.</source>
          <target state="translated">Он должен вернуть обновленное состояние.</target>
        </trans-unit>
        <trans-unit id="168abfa6eb1b0dfa8208332679693b0f2aede472" translate="yes" xml:space="preserve">
          <source>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</source>
          <target state="translated">Он выполняет нормализацию формы канонического разложения (NFD)на строках до их сравнения.Эта функция эквивалентна:</target>
        </trans-unit>
        <trans-unit id="00eb69ecf576738c75d84548dd92cdb318ece3aa" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Он вызывает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;pid&lt;/code&gt; не является локальным процессом.</target>
        </trans-unit>
        <trans-unit id="7e7523b5dc45d67bb8b9c0de3919b26ce0d37a20" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="translated">Он вызывает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; ,&lt;/a&gt; когда индекс отрицателен или находится вне диапазона элементов кортежа.</target>
        </trans-unit>
        <trans-unit id="76fb97ed0a7148c60ad0f98f15c424a1449add5a" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Он вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;pid&lt;/code&gt; не является локальным процессом.</target>
        </trans-unit>
        <trans-unit id="51c53ba47f1eded5769c444b1e03509454cd6f04" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="translated">Он вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; ,&lt;/a&gt; когда индекс отрицательный или находится вне диапазона элементов кортежа.</target>
        </trans-unit>
        <trans-unit id="edab83575d7f73053cab67ad9c4668e68f7c32f0" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;https://hexdocs.pm/elixir/BadMapError.html&quot;&gt;&lt;code&gt;BadMapError&lt;/code&gt;&lt;/a&gt; if the first element is not a map.</source>
          <target state="translated">Он вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/BadMapError.html&quot;&gt; &lt;code&gt;BadMapError&lt;/code&gt; &lt;/a&gt; если первый элемент не является картой.</target>
        </trans-unit>
        <trans-unit id="a7db82325b8b2d3d85d652577eadfac10c4e6cc9" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards.</source>
          <target state="translated">Она поднимается во время компиляции,если определение использует выражения,которые не разрешены в охранниках,и в противном случае создает макрос,который может быть использован как внутри,так и снаружи охранников.</target>
        </trans-unit>
        <trans-unit id="1064c23cd1e6b9f641867dd10b3bf5061844678b" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module.</source>
          <target state="translated">Она поднимается при компиляции,если определение использует выражения,которые не разрешены в охранниках,и в противном случае создает приватный макрос,который может быть использован как внутри,так и снаружи охранников в текущем модуле.</target>
        </trans-unit>
        <trans-unit id="dd862729751c13eb6c25128449accf571b5c5e26" translate="yes" xml:space="preserve">
          <source>It receives a path to the boot file, without extension, such as &lt;code&gt;releases/0.1.0/start&lt;/code&gt; and this command will write &lt;code&gt;start.rel&lt;/code&gt;, &lt;code&gt;start.boot&lt;/code&gt;, and &lt;code&gt;start.script&lt;/code&gt; to the given path, returning &lt;code&gt;{:ok, rel_path}&lt;/code&gt; or &lt;code&gt;{:error, message}&lt;/code&gt;.</source>
          <target state="translated">Он получает путь к загрузочному файлу без расширения, например &lt;code&gt;start.rel&lt;/code&gt; &lt;code&gt;releases/0.1.0/start&lt;/code&gt; и эта команда запишет start.rel , &lt;code&gt;start.boot&lt;/code&gt; и &lt;code&gt;start.script&lt;/code&gt; по указанному пути, возвращая &lt;code&gt;{:ok, rel_path}&lt;/code&gt; или &lt;code&gt;{:error, message}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68ba5419581bb056603e98e4fbe37e8377520d3d" translate="yes" xml:space="preserve">
          <source>It receives the &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt; and the snippet &lt;code&gt;radius&lt;/code&gt; and returns &lt;code&gt;{:ok, lines}&lt;/code&gt;, where lines is a list of chardata containing each formatted line, or &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">Он получает &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; и &lt;code&gt;radius&lt;/code&gt; фрагмента и возвращает &lt;code&gt;{:ok, lines}&lt;/code&gt; , где строки - это список символьных данных, содержащих каждую отформатированную строку, или &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4865031f19e0226674ccac4c00c4c4f11e96290" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;config.reader#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="translated">Он получает текущую &lt;code&gt;config&lt;/code&gt; и &lt;code&gt;state&lt;/code&gt; возвращаемое &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; . Затем вы обычно читаете дополнительную конфигурацию из внешнего источника и объединяете ее с полученной &lt;code&gt;config&lt;/code&gt; . Слияние должно выполняться с помощью &lt;a href=&quot;config.reader#merge/2&quot;&gt; &lt;code&gt;Config.Reader.merge/2&lt;/code&gt; &lt;/a&gt; , поскольку он выполняет глубокое слияние. Он должен вернуть обновленную конфигурацию.</target>
        </trans-unit>
        <trans-unit id="45b33d74133687a9a3b23bdb8a29834a7bdc904c" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="translated">Он получает текущую &lt;code&gt;config&lt;/code&gt; и &lt;code&gt;state&lt;/code&gt; возвращаемое &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; . Затем вы обычно читаете дополнительную конфигурацию из внешнего источника и объединяете ее с полученной &lt;code&gt;config&lt;/code&gt; . Слияние должно выполняться с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html#merge/2&quot;&gt; &lt;code&gt;Config.Reader.merge/2&lt;/code&gt; &lt;/a&gt; , так как он выполняет глубокое слияние. Он должен вернуть обновленную конфигурацию.</target>
        </trans-unit>
        <trans-unit id="7ff8300751e75adc2c83e12f280310fb0e3959a9" translate="yes" xml:space="preserve">
          <source>It receives the same options as &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">Он получает те же параметры, что и &lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt; . Возврат &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59be0f6a9003a8021cb33c59b00cb9642811fc44" translate="yes" xml:space="preserve">
          <source>It receives the time spent running the tests and optionally the time spent loading the test suite.</source>
          <target state="translated">Он получает информацию о времени,затраченном на выполнение тестов,и,в качестве опции,о времени,затраченном на загрузку набора тестов.</target>
        </trans-unit>
        <trans-unit id="63a1b1ead1b4654ed54aa371a1a054c21e1c05bd" translate="yes" xml:space="preserve">
          <source>It relies on &lt;a href=&quot;#format_banner/3&quot;&gt;&lt;code&gt;format_banner/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#format_stacktrace/1&quot;&gt;&lt;code&gt;format_stacktrace/1&lt;/code&gt;&lt;/a&gt; to generate the final format.</source>
          <target state="translated">Он полагается на &lt;a href=&quot;#format_banner/3&quot;&gt; &lt;code&gt;format_banner/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#format_stacktrace/1&quot;&gt; &lt;code&gt;format_stacktrace/1&lt;/code&gt; &lt;/a&gt; для генерации окончательного формата.</target>
        </trans-unit>
        <trans-unit id="ff0e052a45a87445bf1db1b18304c3b0b5b06885" translate="yes" xml:space="preserve">
          <source>It represents time as a fraction of a day (starting from midnight). &lt;code&gt;parts_in_day&lt;/code&gt; specifies how much of the day is already passed, while &lt;code&gt;parts_per_day&lt;/code&gt; signifies how many parts there fit in a day.</source>
          <target state="translated">Он представляет время как долю дня (начиная с полуночи). &lt;code&gt;parts_in_day&lt;/code&gt; указывает, какая часть дня уже прошла, а &lt;code&gt;parts_per_day&lt;/code&gt; указывает, сколько частей умещается в день.</target>
        </trans-unit>
        <trans-unit id="1b4a09c3103a4b1384852ae0065066d0ba0ed3ed" translate="yes" xml:space="preserve">
          <source>It requires an &lt;code&gt;env&lt;/code&gt; to be given to make the expansion of the guards.</source>
          <target state="translated">Требуется дать &lt;code&gt;env&lt;/code&gt; для расширения охранников.</target>
        </trans-unit>
        <trans-unit id="ef0b176f883854b3bc16cf9fece54e5b9b4e4c75" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">Он возвращает &lt;code&gt;:ok&lt;/code&gt; если это удается.</target>
        </trans-unit>
        <trans-unit id="b4dd7376af1ba434a4580bda89ca9e2039d7b5af" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit.</source>
          <target state="translated">Он возвращает &lt;code&gt;:ok&lt;/code&gt; , если агент завершает работу по указанной причине. Если агент завершает работу по другой причине, вызов завершится.</target>
        </trans-unit>
        <trans-unit id="fa25fad557d19ecb8fc577a65e74f7d1d95fee17" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the expression is valid. Otherwise it returns a tuple in the form of &lt;code&gt;{:error, remainder}&lt;/code&gt; where &lt;code&gt;remainder&lt;/code&gt; is the invalid part of the quoted expression.</source>
          <target state="translated">Он возвращает &lt;code&gt;:ok&lt;/code&gt; если выражение верное. В противном случае он возвращает кортеж в виде &lt;code&gt;{:error, remainder}&lt;/code&gt; где &lt;code&gt;remainder&lt;/code&gt; является недопустимой частью цитируемого выражения.</target>
        </trans-unit>
        <trans-unit id="1aa27a7fb3f7df06a7eb5b40933d88237c6da58a" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the supervisor terminates with the given reason. If it terminates with another reason, the call exits.</source>
          <target state="translated">Он возвращает &lt;code&gt;:ok&lt;/code&gt; , если супервизор завершает работу по указанной причине. Если он завершается по другой причине, вызов завершается.</target>
        </trans-unit>
        <trans-unit id="20439119e73e5c84c38c2e670d5943fecce5bbc5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if there is a supervised process with such &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">Он возвращает &lt;code&gt;:ok&lt;/code&gt; , если есть контролируемый процесс с таким &lt;code&gt;id&lt;/code&gt; , в противном случае &lt;code&gt;{:error, :not_found}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6ba3f217ed1eba268a6fdafd4321bb54d3750b6" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;amount&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;start_index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">Он возвращает &lt;code&gt;[]&lt;/code&gt; , если &lt;code&gt;amount&lt;/code&gt; равна &lt;code&gt;0&lt;/code&gt; или если &lt;code&gt;start_index&lt;/code&gt; выходит за границы.</target>
        </trans-unit>
        <trans-unit id="a24863390fa39668ae8776992d58e83d80073d64" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt;.</source>
          <target state="translated">Он возвращает &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; или &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15cf8a959344bff62a34e05c441e26b91698feeb" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt;.</source>
          <target state="translated">Он возвращает &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="115a450f9d17534c1b57fc590c68a557bb8594c5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, regex}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">Он возвращает &lt;code&gt;{:ok, regex}&lt;/code&gt; в случае успеха, &lt;code&gt;{:error, reason}&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="de65d4d5bdecdb8de8753805e8f5f01ea831d124" translate="yes" xml:space="preserve">
          <source>It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">Возвращает charlist,как будто это одна цитируемая строка,распечатывая символы и заменяя интерполяции.</target>
        </trans-unit>
        <trans-unit id="a009c09b517ab0e5d3d4c4e196c2ea69f3fa9d2a" translate="yes" xml:space="preserve">
          <source>It returns a charlist without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</source>
          <target state="translated">Возвращает charlist без интерполяций и без экранирующих символов,за исключением экранирования самого символа закрывающего знака.</target>
        </trans-unit>
        <trans-unit id="a66f3b8a76faa873e28dfa79a7a12532886cbb5f" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without escaping nor interpreting interpolations.</source>
          <target state="translated">Возвращает список &quot;слов&quot;,разделенный пробелами без экранирования и интерпретации интерполяций.</target>
        </trans-unit>
        <trans-unit id="282736101413fcdaca5aa663365cdb6c77665dfd" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</source>
          <target state="translated">Возвращает список &quot;слов&quot;,разделенных пробелами без интерполяции и без экранирующих символов,за исключением экранирования самого символа закрывающего знака.</target>
        </trans-unit>
        <trans-unit id="11c767a0c0e8da6110101dac7c301abe9c23f7ad" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word.</source>
          <target state="translated">Возвращает список &quot;слов&quot;,разделенный пробелами.Для каждого слова происходит снятие символов и интерполяция.</target>
        </trans-unit>
        <trans-unit id="e5072f624143fef2c9ac9a882f637a2b3946d312" translate="yes" xml:space="preserve">
          <source>It returns a list with all defined functions and macros, public and private, in the shape of &lt;code&gt;[{name, arity}, ...]&lt;/code&gt;.</source>
          <target state="translated">Он возвращает список со всеми определенными функциями и макросами, общедоступными и частными, в форме &lt;code&gt;[{name, arity}, ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12058e15be1548c9678ae57e51b9c05668dbfa6c" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without escaping nor interpreting interpolations.</source>
          <target state="translated">Он возвращает шаблон регулярного выражения без экранирования и интерпретации интерполяций.</target>
        </trans-unit>
        <trans-unit id="15ffdd78fcfc5d45572c98d243590020d3b93dea" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without interpolations and without escape characters. Note it still supports escape of Regex tokens (such as escaping &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;) and it also requires you to escape the closing sigil character itself if it appears on the Regex.</source>
          <target state="translated">Он возвращает шаблон регулярного выражения без интерполяции и без escape-символов. Обратите внимание, что он по-прежнему поддерживает экранирование токенов Regex (например, экранирование &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;?&lt;/code&gt; ), А также требует, чтобы вы экранировали сам закрывающий символ сигилы, если он появляется в Regex.</target>
        </trans-unit>
        <trans-unit id="c2339efe4030b11d97d29c7a067b3b9900e5b1d8" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern, unescaping characters and replacing interpolations.</source>
          <target state="translated">Он возвращает шаблон регулярного выражения,освобождая символы и заменяя интерполяции.</target>
        </trans-unit>
        <trans-unit id="2eefd18752fd7d7d11850a6f38a6e135cd46467d" translate="yes" xml:space="preserve">
          <source>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">Она возвращает строку,как если бы это была строка с двойными кавычками,распечатывая символы и заменяя интерполяции.</target>
        </trans-unit>
        <trans-unit id="a90d4a90b12398793185e7dc61f47bfd041a9450" translate="yes" xml:space="preserve">
          <source>It returns a string without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</source>
          <target state="translated">Возвращает строку без интерполяции и без экранирующих символов,за исключением экранирования самого символа закрывающего знака.</target>
        </trans-unit>
        <trans-unit id="1309542e01ede5ca574094267b91e1297dcf83b5" translate="yes" xml:space="preserve">
          <source>It returns a three-element tuple with the form &lt;code&gt;{parsed, args, invalid}&lt;/code&gt;, where:</source>
          <target state="translated">Он возвращает трехэлементный кортеж с формой &lt;code&gt;{parsed, args, invalid}&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="5d3aa2fe3892cfc7dc8712478400dbcd79a2ad47" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module byte code and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="translated">Он возвращает кортеж формы &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; где &lt;code&gt;module&lt;/code&gt; - это имя модуля, &lt;code&gt;binary&lt;/code&gt; - это байтовый код модуля, а &lt;code&gt;term&lt;/code&gt; - результат последнего выражения в &lt;code&gt;quoted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad0c31c6f4bb3fda034b624191c0766e4bec1f10" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module bytecode and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="translated">Он возвращает кортеж формы &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; где &lt;code&gt;module&lt;/code&gt; - это имя модуля, &lt;code&gt;binary&lt;/code&gt; - это байт-код модуля, а &lt;code&gt;term&lt;/code&gt; - результат последнего выражения в &lt;code&gt;quoted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f7bd0c8a3a6137c5122d78d75fdfc59b0d95055" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is a list of values for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{[], keyword_list}&lt;/code&gt; is returned.</source>
          <target state="translated">Он возвращает кортеж, где первый элемент - это список значений для &lt;code&gt;key&lt;/code&gt; а второй элемент - это список ключевых слов, из которого удалены все записи, связанные с &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует в списке ключевых слов, возвращается &lt;code&gt;{[], keyword_list}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="105ded5280b2ff4b7ca0620f752d88bc06179945" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is the first value for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{default, keyword_list}&lt;/code&gt; is returned.</source>
          <target state="translated">Он возвращает кортеж, в котором первый элемент - это первое значение &lt;code&gt;key&lt;/code&gt; а второй элемент - это список ключевых слов, из которого удалены все записи, связанные с &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует в списке ключевых слов, возвращается &lt;code&gt;{default, keyword_list}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60c44e4aa381e2f2476e80a74b5488ef1fbe7e6d" translate="yes" xml:space="preserve">
          <source>It returns a tuple with the configuration and the imported paths.</source>
          <target state="translated">Возвращает кортеж с конфигурацией и импортированными путями.</target>
        </trans-unit>
        <trans-unit id="1c6d5c298bfea7e740d50d208c24e0a7cb35ea15" translate="yes" xml:space="preserve">
          <source>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</source>
          <target state="translated">Он возвращает двухэлементный кортеж с двумя списками элементов.Элемент,который вызвал разделение,является частью второго списка.</target>
        </trans-unit>
        <trans-unit id="3fdf4c8d7953d6b126d5564a13f2c8bce040ab31" translate="yes" xml:space="preserve">
          <source>It returns the &lt;code&gt;mix.exs&lt;/code&gt; file, the lock manifest, and all config files in the &lt;code&gt;config&lt;/code&gt; directory that do not start with a leading period (for example, &lt;code&gt;.my_config.exs&lt;/code&gt;).</source>
          <target state="translated">Он возвращает файл &lt;code&gt;mix.exs&lt;/code&gt; , манифест блокировки и все файлы &lt;code&gt;config&lt;/code&gt; каталоге конфигурации, которые не начинаются с начальной точки (например, &lt;code&gt;.my_config.exs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ae16c311c39efb30b710f0d18b8495dac13e0f28" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;https://hexdocs.pm/elixir/TokenMissingError.html&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;https://hexdocs.pm/elixir/SyntaxError.html&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">В случае успеха он возвращает ast, в противном случае вызывает исключение. Исключением является &lt;a href=&quot;https://hexdocs.pm/elixir/TokenMissingError.html&quot;&gt; &lt;code&gt;TokenMissingError&lt;/code&gt; &lt;/a&gt; в случае отсутствия токена (обычно из-за неполного выражения), в &lt;a href=&quot;https://hexdocs.pm/elixir/SyntaxError.html&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; случае - SyntaxError .</target>
        </trans-unit>
        <trans-unit id="fe0d0c5e22a39b889893a15373fe9daae0aa2349" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;tokenmissingerror&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">В случае успеха он возвращает ast, в противном случае вызывает исключение. Исключением является &lt;a href=&quot;tokenmissingerror&quot;&gt; &lt;code&gt;TokenMissingError&lt;/code&gt; &lt;/a&gt; в случае отсутствия токена (обычно из-за неполного выражения), в &lt;a href=&quot;syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; случае - SyntaxError .</target>
        </trans-unit>
        <trans-unit id="0ddb2097e9b6c67aac6845519cb92def4ddcd595" translate="yes" xml:space="preserve">
          <source>It returns the deleted attribute value (or &lt;code&gt;nil&lt;/code&gt; if nothing was set).</source>
          <target state="translated">Он возвращает удаленное значение атрибута (или &lt;code&gt;nil&lt;/code&gt; если ничего не было установлено).</target>
        </trans-unit>
        <trans-unit id="02c714a4ea003b7686a6af1daae5b12a336be932" translate="yes" xml:space="preserve">
          <source>It returns the names of the compiled modules.</source>
          <target state="translated">Возвращает имена скомпилированных модулей.</target>
        </trans-unit>
        <trans-unit id="ae123871707a2b6de82ed2c56ead673cc4cadc39" translate="yes" xml:space="preserve">
          <source>It returns the new map of compiler options.</source>
          <target state="translated">Он возвращает новую карту опций компилятора.</target>
        </trans-unit>
        <trans-unit id="766f8a3783379e82be75e43a3208cd1da372d673" translate="yes" xml:space="preserve">
          <source>It returns the number of Gregorian days between the dates. Only &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</source>
          <target state="translated">Он возвращает количество дней по григорианскому календарю между датами. Таким образом можно сравнивать только структуры &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; ,&lt;/a&gt; которые следуют за одним и тем же или совместимым календарем. Если два календаря несовместимы, поднимется.</target>
        </trans-unit>
        <trans-unit id="b6852c5d07c3b9783a2c197a51ccbe9ab48fc88a" translate="yes" xml:space="preserve">
          <source>It returns the same as the built-in &lt;code&gt;node()&lt;/code&gt;.</source>
          <target state="translated">Он возвращает то же, что и встроенный &lt;code&gt;node()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85ecab1cba97830aafe60c7db9bcdf6c281beb4" translate="yes" xml:space="preserve">
          <source>It returns the term stored in the documentation chunk in the format defined by &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; if the chunk is not available.</source>
          <target state="translated">Он возвращает термин, хранящийся в блоке документации, в формате, определенном &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; или &lt;code&gt;{:error, reason}&lt;/code&gt; если блок недоступен.</target>
        </trans-unit>
        <trans-unit id="3386214fb50a8516bbdf778fc1cd94340c90a3d8" translate="yes" xml:space="preserve">
          <source>It returns the updated version of the protocol bytecode. If the first element of the tuple is &lt;code&gt;:ok&lt;/code&gt;, it means the protocol was consolidated.</source>
          <target state="translated">Он возвращает обновленную версию байт-кода протокола. Если первым элементом кортежа является &lt;code&gt;:ok&lt;/code&gt; , это означает, что протокол был объединен.</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">Он возвращается:</target>
        </trans-unit>
        <trans-unit id="7e69f73c47c2d4297cd900ce85c28a9c948c1b19" translate="yes" xml:space="preserve">
          <source>It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.</source>
          <target state="translated">Кажется,мы готовы! Мы будем использовать интерактивную оболочку довольно много в следующих главах,чтобы немного ближе познакомиться с языковыми конструкциями и основными типами,начиная со следующей главы.</target>
        </trans-unit>
        <trans-unit id="5f614aba654107e82be85c23faa333a8020b0a23" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="translated">Он должен возвращать &lt;code&gt;{:ok, boolean}&lt;/code&gt; если вы можете проверить принадлежность данного элемента к &lt;code&gt;enumerable&lt;/code&gt; с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; ,&lt;/a&gt; не просматривая все перечислимое значение.</target>
        </trans-unit>
        <trans-unit id="7b61a10d3b18f5d9c1eaf6bc0cc59326c9f15aec" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="translated">Он должен вернуть &lt;code&gt;{:ok, boolean}&lt;/code&gt; если вы можете проверить членство данного элемента в &lt;code&gt;enumerable&lt;/code&gt; с помощью &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; ,&lt;/a&gt; не проходя через все перечислимое.</target>
        </trans-unit>
        <trans-unit id="4eda1ce345c7961b8d8eaacacd3842665d668e46" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, count}&lt;/code&gt; if you can count the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Он должен вернуть &lt;code&gt;{:ok, count}&lt;/code&gt; если вы можете подсчитать количество элементов в &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b69c5b898ed0b1df84697cb05eb4de3925bc611c" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; if the &lt;code&gt;enumerable&lt;/code&gt; has a known bound and can access a position in the &lt;code&gt;enumerable&lt;/code&gt; without traversing all previous elements.</source>
          <target state="translated">Он должен возвращать &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; если &lt;code&gt;enumerable&lt;/code&gt; имеет известную границу и может получить доступ к позиции в &lt;code&gt;enumerable&lt;/code&gt; без обхода всех предыдущих элементов.</target>
        </trans-unit>
        <trans-unit id="c6ec473d814fbb944cadb6ef7ecbd0b54ffb7903" translate="yes" xml:space="preserve">
          <source>It simply prints messages to stdio and stderr.</source>
          <target state="translated">Он просто печатает сообщения на stdio и stderr.</target>
        </trans-unit>
        <trans-unit id="c2bf5d9b723f91bde75bc41d3f4bce002f449711" translate="yes" xml:space="preserve">
          <source>It simply returns a charlist without escaping characters and without interpolations.</source>
          <target state="translated">Он просто возвращает charlist без экранирования символов и без интерполяции.</target>
        </trans-unit>
        <trans-unit id="c84e40ba905fa3630ef387da0561b471023546c1" translate="yes" xml:space="preserve">
          <source>It simply returns a string without escaping characters and without interpolations.</source>
          <target state="translated">Он просто возвращает строку без экранирующих символов и без интерполяций.</target>
        </trans-unit>
        <trans-unit id="6ac5bb057ce19bda73528c6e24000df9f4d91f41" translate="yes" xml:space="preserve">
          <source>It simply runs the compilers registered in your project and returns a tuple with the compilation status and a list of diagnostics.</source>
          <target state="translated">Он просто запускает компиляторы,зарегистрированные в вашем проекте и возвращает кортеж со статусом компиляции и списком диагностики.</target>
        </trans-unit>
        <trans-unit id="16d9b6683d66aba15c717ff1071205cd0f26c442" translate="yes" xml:space="preserve">
          <source>It supports the following options:</source>
          <target state="translated">Он поддерживает следующие опции:</target>
        </trans-unit>
        <trans-unit id="a2e490ec4460253855b541489b49bac1f8ad8cbb" translate="yes" xml:space="preserve">
          <source>It takes an &lt;code&gt;enumerable&lt;/code&gt; with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</source>
          <target state="translated">Он принимает &lt;code&gt;enumerable&lt;/code&gt; с элементами, представляющими собой двухэлементные кортежи, и возвращает кортеж с двумя списками, каждый из которых формируется первым и вторым элементами каждого кортежа соответственно.</target>
        </trans-unit>
        <trans-unit id="65267298def1e5c3f27ba97cc79959f0ec4e9b43" translate="yes" xml:space="preserve">
          <source>It takes the &lt;code&gt;kind&lt;/code&gt; spilled by &lt;code&gt;catch&lt;/code&gt; as an argument and normalizes only &lt;code&gt;:error&lt;/code&gt;, returning the untouched payload for others.</source>
          <target state="translated">Он принимает в качестве аргумента &lt;code&gt;kind&lt;/code&gt; переданный с помощью &lt;code&gt;catch&lt;/code&gt; , и нормализует только &lt;code&gt;:error&lt;/code&gt; , возвращая нетронутую полезную нагрузку для других.</target>
        </trans-unit>
        <trans-unit id="017d4c0f52ec05a16013c629cf13480b366963be" translate="yes" xml:space="preserve">
          <source>It uses &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; to check if any remote call does not exist or is deprecated, and emits warnings in such cases. This task does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">Он использует &lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; ,&lt;/a&gt; чтобы проверить, не существует ли какой-либо удаленный вызов или является ли он устаревшим, и выдает предупреждения в таких случаях. В этой задаче не отображаются устаревшие локальные вызовы (вызов устаревшей функции или макроса в том же модуле), а также вызовы устаревших функций в самом Elixir.</target>
        </trans-unit>
        <trans-unit id="3f274a1513094f60249f099c239e9ebf65b2ef59" translate="yes" xml:space="preserve">
          <source>It uses the following release options to customize its behaviour:</source>
          <target state="translated">Он использует следующие опции выпуска для настройки своего поведения:</target>
        </trans-unit>
        <trans-unit id="14a6eb5a7e6cf2ff92914f35b6fcd693c9459181" translate="yes" xml:space="preserve">
          <source>It uses the given &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; documents as surrounding and the separator document &lt;code&gt;separator&lt;/code&gt; to separate items in &lt;code&gt;docs&lt;/code&gt;. If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit.</source>
          <target state="translated">Он использует данный &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; документы , как окружающие и разделитель документ &lt;code&gt;separator&lt;/code&gt; для разделения элементов в &lt;code&gt;docs&lt;/code&gt; . Если все записи в коллекции являются простыми документами (текстами или строками), то эта функция пытается разместить как можно больше в одной строке. Если они не простые, то в каждой строке отображается только одна запись, если они не подходят.</target>
        </trans-unit>
        <trans-unit id="359c8a3a80dc42f4d09ef45dc62e03c2a4526a01" translate="yes" xml:space="preserve">
          <source>It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation.</source>
          <target state="translated">В нем используется кратчайшее представление по алгоритму,описанному в статье &quot;Быстрая и точная печать чисел с плавающей точкой&quot; в материалах конференции SIGPLAN '96 по проектированию и внедрению языков программирования.</target>
        </trans-unit>
        <trans-unit id="8c45e1d7dd527f5dc5b63b0e91b53d37c7df9f32" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он также добавит &lt;a href=&quot;#reset/0&quot;&gt; &lt;code&gt;IO.ANSI.reset/0&lt;/code&gt; &lt;/a&gt; к chardata при выполнении преобразования. Если вам не нужно такое поведение, используйте &lt;a href=&quot;#format_fragment/2&quot;&gt; &lt;code&gt;format_fragment/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="226d68525abc4cd650686c46c4c3000914e7ba94" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;io.ansi#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он также добавит &lt;a href=&quot;io.ansi#reset/0&quot;&gt; &lt;code&gt;IO.ANSI.reset/0&lt;/code&gt; &lt;/a&gt; к chardata при выполнении преобразования. Если вам не нужно такое поведение, используйте &lt;a href=&quot;#format_fragment/2&quot;&gt; &lt;code&gt;format_fragment/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d625ecd25a91e55e3a68933b351320ae362d970" translate="yes" xml:space="preserve">
          <source>It will also unload all &lt;code&gt;:included_applications&lt;/code&gt;. Note that the function does not purge the application modules.</source>
          <target state="translated">Он также выгружает все &lt;code&gt;:included_applications&lt;/code&gt; . Обратите внимание, что функция не очищает модули приложения.</target>
        </trans-unit>
        <trans-unit id="8f9afeda7f3ae15ea1269533344b9ee72aa71396" translate="yes" xml:space="preserve">
          <source>It will define a private function with the &lt;code&gt;name&lt;/code&gt; followed by &lt;code&gt;_template&lt;/code&gt; that expects assigns as arguments.</source>
          <target state="translated">Он определит частную функцию с &lt;code&gt;name&lt;/code&gt; за которым следует &lt;code&gt;_template&lt;/code&gt; , которая ожидает назначения в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="b14179a0fb239e1b0a7f866572618fb6a7e039c8" translate="yes" xml:space="preserve">
          <source>It will define a private function with the &lt;code&gt;name&lt;/code&gt; followed by &lt;code&gt;_text&lt;/code&gt; that expects no arguments.</source>
          <target state="translated">Он определит частную функцию с &lt;code&gt;name&lt;/code&gt; за которым следует &lt;code&gt;_text&lt;/code&gt; , которая не требует аргументов.</target>
        </trans-unit>
        <trans-unit id="84aa5327df0b5a9bb286871a09b1bb5335320dee" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="translated">Если структура недоступна, это вызовет &lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fe073227420180d1f3a4b21845f2700d1e729eb" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="translated">Если структура недоступна, она вызовет &lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a06e9516c751736de535751e4a5286672c93ce3" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он вернет целое число с заданной единицей, согласно &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6ad31346e231231ef72c5f43225ffd3c66f70d" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он вернет целое число с заданной единицей, согласно &lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a600be691bf00b4e32fb62041ceec8dd63d79b4c" translate="yes" xml:space="preserve">
          <source>It works with improper lists.</source>
          <target state="translated">Он работает с неподходящими списками.</target>
        </trans-unit>
        <trans-unit id="56c7bd1e0de49688ba67dc0411a013f58a48e6b1" translate="yes" xml:space="preserve">
          <source>It would be repetitive to write every time we need this check. Instead you can use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt;&lt;code&gt;defguard/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt;&lt;code&gt;defguardp/1&lt;/code&gt;&lt;/a&gt; to create guard macros. Here's an example how:</source>
          <target state="translated">Было бы однообразно писать каждый раз, когда нам нужна эта проверка. Вместо этого вы можете использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt; &lt;code&gt;defguard/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt; &lt;code&gt;defguardp/1&lt;/code&gt; &lt;/a&gt; для создания охранных макросов. Вот пример того, как:</target>
        </trans-unit>
        <trans-unit id="6681def299dea9fa997a7ef9b6707d61767cc884" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to implement protocols for all Elixir data types:</source>
          <target state="translated">Возможна реализация протоколов для всех типов данных Elixir:</target>
        </trans-unit>
        <trans-unit id="999db6f61bff83218a31d16026d001272eea2261" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a block to the &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro. The first example above would be translated to:</source>
          <target state="translated">Также можно передать блок в макрос &lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; . Первый пример выше будет переведен на:</target>
        </trans-unit>
        <trans-unit id="d7133394c8c36d8e6246933599c2f2817f5680a9" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="translated">Важно отметить, что он возвращает данный &lt;code&gt;item&lt;/code&gt; без изменений. Это позволяет &amp;laquo;шпионить&amp;raquo; за значениями, вставляя &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt; почти в любом месте вашего кода, например, в середине конвейера.</target>
        </trans-unit>
        <trans-unit id="cd7290dd76f46aa64bdbf468714a16cc5352938b" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="translated">Важно отметить, что он возвращает данный &lt;code&gt;item&lt;/code&gt; без изменений. Это позволяет &amp;laquo;шпионить&amp;raquo; за значениями, вставляя &lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt; почти в любом месте вашего кода, например, в середине конвейера.</target>
        </trans-unit>
        <trans-unit id="92b1830c83da0ae2da9d26b113dc7191ad06496e" translate="yes" xml:space="preserve">
          <source>It's just like &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Shell.IO.html&quot;&gt;&lt;code&gt;Mix.Shell.IO&lt;/code&gt;&lt;/a&gt;, but prints far less.</source>
          <target state="translated">Это похоже на &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Shell.IO.html&quot;&gt; &lt;code&gt;Mix.Shell.IO&lt;/code&gt; &lt;/a&gt; , но печатает гораздо меньше.</target>
        </trans-unit>
        <trans-unit id="55e677bb7fe63cf491955ddb64be33b944554c67" translate="yes" xml:space="preserve">
          <source>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</source>
          <target state="translated">Часто бывает полезно иметь AST для такого трубопровода в виде списка функциональных приложений.Эта функция делает именно это:</target>
        </trans-unit>
        <trans-unit id="b81b47272fec763e900d18ba6a1da4a3098cd954" translate="yes" xml:space="preserve">
          <source>Italic: on. Not widely supported. Sometimes treated as inverse.</source>
          <target state="translated">На курсив.Не пользуется широкой поддержкой.Иногда рассматривается как обратный.</target>
        </trans-unit>
        <trans-unit id="0418eaaa46e9aed5bab2054a496fec5d581658a8" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">Перебирает &lt;code&gt;enumerable&lt;/code&gt; и вызывает &lt;code&gt;fun&lt;/code&gt; для каждого элемента. Когда вызов &lt;code&gt;fun&lt;/code&gt; возвращает ложное значение ( &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; ), итерация немедленно останавливается, и возвращается &lt;code&gt;false&lt;/code&gt; . Во всех остальных случаях возвращается &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c421120e85b180763b71f08518f3f5d485454d1b" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Перебирает &lt;code&gt;enumerable&lt;/code&gt; и вызывает &lt;code&gt;fun&lt;/code&gt; для каждого элемента. Когда вызов &lt;code&gt;fun&lt;/code&gt; возвращает истинное значение (ни &lt;code&gt;false&lt;/code&gt; , ни &lt;code&gt;nil&lt;/code&gt; ), итерация немедленно останавливается, и возвращается &lt;code&gt;true&lt;/code&gt; . Во всех остальных случаях возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="translated">Его поля:</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="2e084df8c1f3d9f015ea6c2b99c3b679805e965a" translate="yes" xml:space="preserve">
          <source>Joins a list of paths.</source>
          <target state="translated">Присоединяется к списку путей.</target>
        </trans-unit>
        <trans-unit id="515c03874ab491d886e1d1d7b31a372bcd15aaca" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a binary using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="translated">Объединяет данное &lt;code&gt;enumerable&lt;/code&gt; в двоичный файл, используя &lt;code&gt;joiner&lt;/code&gt; в качестве разделителя.</target>
        </trans-unit>
        <trans-unit id="d5f55ddf6fc97ad5dc177a84ea138ceb1275620d" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a string using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="translated">Объединяет данное &lt;code&gt;enumerable&lt;/code&gt; в строку, используя &lt;code&gt;joiner&lt;/code&gt; в качестве разделителя.</target>
        </trans-unit>
        <trans-unit id="f5648a991099408fa47ca83f65efd1693d2a9815" translate="yes" xml:space="preserve">
          <source>Joins two paths.</source>
          <target state="translated">Соединяет два пути.</target>
        </trans-unit>
        <trans-unit id="48d488d22b9c11a34b40d4f43a44d7ca15f5548d" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. E.g. topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="translated">Так же, как &lt;a href=&quot;#runtime_info/0&quot;&gt; &lt;code&gt;runtime_info/0&lt;/code&gt; &lt;/a&gt; , за исключением того, что принимает тему или список тем. Например, тема &lt;code&gt;:applications&lt;/code&gt; будут отображать загруженные приложения.</target>
        </trans-unit>
        <trans-unit id="8adcf69a0184ea8241a6a5279c84b711dfcc1fd2" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. For example, topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="translated">Так же, как &lt;a href=&quot;#runtime_info/0&quot;&gt; &lt;code&gt;runtime_info/0&lt;/code&gt; &lt;/a&gt; , за исключением того, что принимает тему или список тем. Например, тема &lt;code&gt;:applications&lt;/code&gt; перечислит загруженные приложения.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="e51db24d55d9857675a12f93a5ceb2ca695225d3" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;@enforce_keys&lt;/code&gt; is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</source>
          <target state="translated">Помните, что &lt;code&gt;@enforce_keys&lt;/code&gt; - это простая гарантия времени компиляции, которая помогает разработчикам при создании структур. Он не применяется к обновлениям и не обеспечивает никакой проверки значений.</target>
        </trans-unit>
        <trans-unit id="47ce96738f59dcbe1277607a7b62401517ee71a9" translate="yes" xml:space="preserve">
          <source>Keep in mind errors in guards do not leak but simply make the guard fail:</source>
          <target state="translated">Имейте в виду,что ошибки в защитных приспособлениях не протекают,а просто приводят к выходу из строя защитного приспособления:</target>
        </trans-unit>
        <trans-unit id="019b3d215759f9f759de0ba07f898008173c2b71" translate="yes" xml:space="preserve">
          <source>Keep in mind reversing the same string twice does not necessarily yield the original string:</source>
          <target state="translated">Имейте в виду,что перевернув одну и ту же строку дважды,вы не обязательно получите исходную строку:</target>
        </trans-unit>
        <trans-unit id="11a21ef1004b00088384d2386c08e0ddfc5a422c" translate="yes" xml:space="preserve">
          <source>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types:</source>
          <target state="translated">Имейте в виду,что представления в одинарных и двойных кавычках не эквивалентны в Elixir,так как они представлены разными типами:</target>
        </trans-unit>
        <trans-unit id="26f5b5d2244e5042fbdc36e2b692a508ea25622f" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="translated">Имейте в виду, что &lt;a href=&quot;#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; запускается в процессе вызывающей стороны, блокируя вызывающую сторону во время цикла оценки. Вызывающий процесс можно освободить, вызвав &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt; , который запускает новый цикл оценки IEx, позволяя этому уйти:</target>
        </trans-unit>
        <trans-unit id="31048d175f380df1b961d6b1c2e7ff99e30846d1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="translated">Имейте в виду, что &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; запускается в процессе вызывающей стороны, блокируя вызывающую сторону во время цикла оценки. Вызывающий процесс можно освободить, вызвав &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt; , который запускает новый цикл оценки IEx, позволяя этому уйти:</target>
        </trans-unit>
        <trans-unit id="17dab74a9a2d31002a8d8b98ab8f2a1e7c69175a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;assert&lt;/code&gt; does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;assert&lt;/code&gt; не изменяет свою семантику в зависимости от выражения. Другими словами, выражение по-прежнему должно возвращать истинное значение. Например, следующее не удастся:</target>
        </trans-unit>
        <trans-unit id="bb7a4e2f437f89496ebbe986e5235a9983fd7b7c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;filter&lt;/code&gt; is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using &lt;a href=&quot;#flat_map/2&quot;&gt;&lt;code&gt;flat_map/2&lt;/code&gt;&lt;/a&gt;. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;filter&lt;/code&gt; не может фильтровать и преобразовывать элемент одновременно. Если вы хотите это сделать, подумайте об использовании &lt;a href=&quot;#flat_map/2&quot;&gt; &lt;code&gt;flat_map/2&lt;/code&gt; &lt;/a&gt; . Например, если вы хотите преобразовать все строки, представляющие целое число, и отбросить недопустимую за один проход:</target>
        </trans-unit>
        <trans-unit id="efcc18a9b0bcb482431019e0321fb20f799d7ca1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;refute&lt;/code&gt; does not change the semantics of the given expression. In other words, the following will fail:</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;refute&lt;/code&gt; не меняет семантику данного выражения. Другими словами, произойдет сбой:</target>
        </trans-unit>
        <trans-unit id="2711b72cad7dcad995d5896fe00c416e309a1ef1" translate="yes" xml:space="preserve">
          <source>Keep in mind that all tests are included by default, so unless they are excluded first, the &lt;code&gt;include&lt;/code&gt; option has no effect.</source>
          <target state="translated">Имейте в виду, что все тесты включены по умолчанию, поэтому, если они не были исключены первыми, опция &lt;code&gt;include&lt;/code&gt; не действует.</target>
        </trans-unit>
        <trans-unit id="681ff07e085798bf6140c0e48749d06c2f822db5" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always invoke the help task to list all available tasks:</source>
          <target state="translated">Имейте в виду,что вы всегда можете вызвать справочную задачу,чтобы перечислить все доступные задачи:</target>
        </trans-unit>
        <trans-unit id="725b47d6b2cb8b5dc76a5170928fd278550f1b34" translate="yes" xml:space="preserve">
          <source>Keep in mind that, by convention, whenever the inspected value starts with &lt;code&gt;#&lt;/code&gt;, it is representing a data structure in non-valid Elixir syntax. This means the inspect protocol is not reversible as information may be lost along the way:</source>
          <target state="translated">Имейте в виду, что по соглашению всякий раз, когда проверяемое значение начинается с символа &lt;code&gt;#&lt;/code&gt; , оно представляет структуру данных в недопустимом синтаксисе Elixir. Это означает, что протокол проверки не является обратимым, так как информация может быть потеряна в процессе:</target>
        </trans-unit>
        <trans-unit id="b83288ec921378850bb3f1fa7bae00089f1eb1e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</source>
          <target state="translated">Имейте в виду,что для того,чтобы знать,является ли элемент уникальным или нет,эта функция должна хранить все уникальные значения,излучаемые потоком.Поэтому,если поток бесконечен,то количество хранимых элементов будет бесконечно расти,никогда не собирая мусор.</target>
        </trans-unit>
        <trans-unit id="84d731972e42a11f20590eec71a88a83f6bff7df" translate="yes" xml:space="preserve">
          <source>Keep in mind that, regardless of how the task created with &lt;code&gt;async_nolink&lt;/code&gt; terminates, the caller's process will always receive a &lt;code&gt;:DOWN&lt;/code&gt; message with the same &lt;code&gt;ref&lt;/code&gt; value that is held by the task struct. If the task terminates normally, the reason in the &lt;code&gt;:DOWN&lt;/code&gt; message will be &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">Имейте в виду, что независимо от того, как завершается задача, созданная с помощью &lt;code&gt;async_nolink&lt;/code&gt; , вызывающий процесс всегда будет получать сообщение &lt;code&gt;:DOWN&lt;/code&gt; с тем же значением &lt;code&gt;ref&lt;/code&gt; , которое содержится в структуре задачи. Если задача завершается нормально, причина в сообщении &lt;code&gt;:DOWN&lt;/code&gt; будет &lt;code&gt;:normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43e72793cf5cb6c7b1a0ca2e28a8c6ee6025d9c8" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#open/0&quot;&gt;&lt;code&gt;open/0&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">Имейте в виду, что расположение &lt;a href=&quot;#open/0&quot;&gt; &lt;code&gt;open/0&lt;/code&gt; &lt;/a&gt; может не существовать при извлечении предварительно скомпилированного исходного кода, такого как сам Elixir.</target>
        </trans-unit>
        <trans-unit id="860e4edfbd6c5d2c7567e3d117fbea1f6f0c0f3d" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#whereami/1&quot;&gt;&lt;code&gt;whereami/1&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">Имейте в виду, что &lt;a href=&quot;#whereami/1&quot;&gt; &lt;code&gt;whereami/1&lt;/code&gt; &lt;/a&gt; может не существовать при извлечении предварительно скомпилированного исходного кода, такого как сам Elixir.</target>
        </trans-unit>
        <trans-unit id="5cf33f85cbcbea5e44750e3785093cd27fc2107f" translate="yes" xml:space="preserve">
          <source>Keep in mind the location may not exist when opening precompiled source code.</source>
          <target state="translated">Имейте в виду,что при открытии прекомпилированных исходных кодов местоположение может не существовать.</target>
        </trans-unit>
        <trans-unit id="9d158165f2fc0a37c72c714056603422cfd15842" translate="yes" xml:space="preserve">
          <source>Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by &lt;em&gt;shutting down&lt;/em&gt; some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module.</source>
          <target state="translated">Имейте в виду, что эта проблема также появляется при выполнении &amp;laquo;последовательного обновления&amp;raquo; с агентами. Под последовательными обновлениями мы понимаем следующую ситуацию: вы хотите развернуть новую версию своего программного обеспечения, &lt;em&gt;отключив&lt;/em&gt; некоторые из ваших узлов и заменив их узлами, на которых запущена новая версия программного обеспечения. В этой настройке часть вашей среды будет иметь одну версию данного модуля, а другая часть - другую версию (более новую) того же модуля.</target>
        </trans-unit>
        <trans-unit id="f0156c07b778f553fcac957532e2ebb3cd9d736c" translate="yes" xml:space="preserve">
          <source>Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt; use the first line to generate a summary.</source>
          <target state="translated">Сделайте первый абзац документации кратким и простым, обычно в одну строку. Такие инструменты, как &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc,&lt;/a&gt; используют первую строку для создания сводки.</target>
        </trans-unit>
        <trans-unit id="b89ed6c1e4d3aad0e25530664c1434bb7a8e1390" translate="yes" xml:space="preserve">
          <source>Keeping user's formatting</source>
          <target state="translated">Сохранение пользовательского форматирования</target>
        </trans-unit>
        <trans-unit id="74808d3df030e992e7b9444241625147986487c1" translate="yes" xml:space="preserve">
          <source>Kernel</source>
          <target state="translated">Kernel</target>
        </trans-unit>
        <trans-unit id="b4d54f6ec686d8eb5175caf8d65ba08cfce6e603" translate="yes" xml:space="preserve">
          <source>Kernel functions</source>
          <target state="translated">функции ядра</target>
        </trans-unit>
        <trans-unit id="aeaeca0ac29205e969d2b8226d57305ccdd9354c" translate="yes" xml:space="preserve">
          <source>Kernel.ParallelCompiler</source>
          <target state="translated">Kernel.ParallelCompiler</target>
        </trans-unit>
        <trans-unit id="397b329c326c86881a0889837339130cb1378ece" translate="yes" xml:space="preserve">
          <source>Kernel.SpecialForms</source>
          <target state="translated">Kernel.SpecialForms</target>
        </trans-unit>
        <trans-unit id="c8ca7c123549a6d988a750c2deb07a14cc7d13fe" translate="yes" xml:space="preserve">
          <source>Key and value in each tuple will be binaries and will be percent-unescaped.</source>
          <target state="translated">Ключ и значение в каждом кортеже будут двоичными и будут иметь процентную единицу.</target>
        </trans-unit>
        <trans-unit id="fa0ccdd4ef791d750570b7806e67eebc94ec0038" translate="yes" xml:space="preserve">
          <source>Key-based access to data structures.</source>
          <target state="translated">Ключевой доступ к структурам данных.</target>
        </trans-unit>
        <trans-unit id="156eb45dfef4d621a4d1c63e18132edae922c7ad" translate="yes" xml:space="preserve">
          <source>Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).</source>
          <target state="translated">Пары ключей-значений на карте не следуют никакой последовательности (поэтому распечатанная карта в приведенном выше примере имеет иной порядок,чем карта,которая была создана).</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="15dcfdc21056a09847eba4ff304e968ed3eb85e6" translate="yes" xml:space="preserve">
          <source>KeyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">KeyError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8ac2c89719f9c04525d63e66e24d2789f2aee53c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="translated">Ключи и значения могут быть любым термином, реализующим протокол &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; , за исключением списков, которые явно запрещены.</target>
        </trans-unit>
        <trans-unit id="9feb5a2ad29c5ac9a472aae0705f0b36f56f288c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="translated">Ключи и значения могут быть любым термином, реализующим протокол &lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; , за исключением списков, которые явно запрещены.</target>
        </trans-unit>
        <trans-unit id="c871f27e8a5b87eb6c4a04f8a42a4f6e2ea2d87a" translate="yes" xml:space="preserve">
          <source>Keys are ordered, as specified by the developer.</source>
          <target state="translated">Ключи заказываются в соответствии с указаниями разработчика.</target>
        </trans-unit>
        <trans-unit id="405b7423934af77dcf3ba5a20687064207764857" translate="yes" xml:space="preserve">
          <source>Keys can be given more than once.</source>
          <target state="translated">Ключи можно давать не один раз.</target>
        </trans-unit>
        <trans-unit id="c61607fe5f12600b764431ebe5f8131aa4311b82" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in &lt;code&gt;map&lt;/code&gt; are ignored.</source>
          <target state="translated">Ключи, для которых нет записей на &lt;code&gt;map&lt;/code&gt; , игнорируются.</target>
        </trans-unit>
        <trans-unit id="4694e757bfed2949bf57d46a766c250bec95d827" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in the keyword list are ignored.</source>
          <target state="translated">Ключи,для которых нет записей в списке ключевых слов,игнорируются.</target>
        </trans-unit>
        <trans-unit id="9070f3bb1af9cd3030e97dc551b3b692914950e9" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">К ключам в картах можно получить доступ через некоторые функции этого модуля (например, &lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;Map.get/3&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;Map.fetch/2&lt;/code&gt; &lt;/a&gt; ) или через синтаксис &lt;code&gt;map[]&lt;/code&gt; предоставляемый модулем &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5718a5ffdcdd81ef356ce973873d2a2560146789" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;map#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;map#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">К ключам на картах можно получить доступ через некоторые функции в этом модуле (например, &lt;a href=&quot;map#get/3&quot;&gt; &lt;code&gt;Map.get/3&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;map#fetch/2&quot;&gt; &lt;code&gt;Map.fetch/2&lt;/code&gt; &lt;/a&gt; ) или через синтаксис &lt;code&gt;map[]&lt;/code&gt; предоставляемый модулем &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b26620768b7c3d13232d03fbd0fd86edae1e9816" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</source>
          <target state="translated">Ключи в &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , которых нет в структуре, автоматически отбрасываются. Обратите внимание, что ключи должны быть атомами, поскольку при определении структуры разрешены только атомы.</target>
        </trans-unit>
        <trans-unit id="c2baa536dd3a58a170c5f916697821f33d1d1197" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct. If keys in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are duplicated, the last entry will be taken (same behaviour as &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#new/1&quot;&gt;&lt;code&gt;Map.new/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Ключи в &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , которых нет в структуре, автоматически отбрасываются. Обратите внимание, что ключи должны быть атомами, поскольку при определении структуры разрешены только атомы. Если ключи в &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; дублируются, будет взята последняя запись (такое же поведение, как у &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#new/1&quot;&gt; &lt;code&gt;Map.new/1&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="36720d74567b83e682047245f1678cc00bda2c58" translate="yes" xml:space="preserve">
          <source>Keys must be atoms.</source>
          <target state="translated">Ключи должны быть атомами.</target>
        </trans-unit>
        <trans-unit id="e9113610f402cf2ff1bf899fb9498e85baba2c5a" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ключи должны быть атомами. Ключи со значением &lt;code&gt;nil&lt;/code&gt; отбрасываются, логические значения преобразуются в &lt;code&gt;--key&lt;/code&gt; или --no &lt;code&gt;--no-key&lt;/code&gt; (если значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , соответственно), а все другие значения преобразуются с использованием &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b946356405330b9605587c00c959f1283c7ebe0c" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;kernel#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ключи должны быть атомами. Ключи со значением &lt;code&gt;nil&lt;/code&gt; отбрасываются, логические значения преобразуются в &lt;code&gt;--key&lt;/code&gt; или --no &lt;code&gt;--no-key&lt;/code&gt; (если значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , соответственно), а все другие значения преобразуются с использованием &lt;a href=&quot;kernel#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="7c134e1191dc5c44edbda73b442ec456eb6a71ed" translate="yes" xml:space="preserve">
          <source>Keyword lists</source>
          <target state="translated">Списки ключевых слов</target>
        </trans-unit>
        <trans-unit id="018e651a39aa7ad2ac64ac5eb40095fd4e7a830c" translate="yes" xml:space="preserve">
          <source>Keyword lists and maps</source>
          <target state="translated">Списки ключевых слов и карты</target>
        </trans-unit>
        <trans-unit id="392d9a31ec7b8f0bdc87d00f031b9e9bb8a73cb6" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep merged.</source>
          <target state="translated">Списки ключевых слов всегда глубоко слиты.</target>
        </trans-unit>
        <trans-unit id="4a8ca5bd3ccea7e0c7d15c67c55d6d098576d862" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep-merged.</source>
          <target state="translated">Списки ключевых слов всегда глубокие.</target>
        </trans-unit>
        <trans-unit id="ac0300b9a6363d2ecf2708a6271a27720466a909" translate="yes" xml:space="preserve">
          <source>Keyword lists are important because they have three special characteristics:</source>
          <target state="translated">Списки ключевых слов важны,так как они обладают тремя особыми характеристиками:</target>
        </trans-unit>
        <trans-unit id="f46ce1d1d7d871768a2c62a23f7074163ee126aa" translate="yes" xml:space="preserve">
          <source>Keyword lists play an important role in the language and are quite common in many functions and macros. We will explore them a bit more in a future chapter. Now it is time to talk about &amp;ldquo;Binaries, strings, and char lists&amp;rdquo;.</source>
          <target state="translated">Списки ключевых слов играют важную роль в языке и довольно часто используются во многих функциях и макросах. Мы рассмотрим их подробнее в следующей главе. Теперь пора поговорить о &amp;laquo;двоичных файлах, строках и списках символов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e5689d3967f1a5dbb297e088da0c45eb1176eca9" translate="yes" xml:space="preserve">
          <source>Keywords are mostly used to work with optional values.</source>
          <target state="translated">Ключевые слова в основном используются для работы с необязательными значениями.</target>
        </trans-unit>
        <trans-unit id="1ceb47d1e9d15d89ef0224d7d1b562dcf30b3896" translate="yes" xml:space="preserve">
          <source>Keywords as last arguments</source>
          <target state="translated">Ключевые слова в качестве последних аргументов</target>
        </trans-unit>
        <trans-unit id="c9a539f3ad19c8470b65f3028d300a7bb73e217a" translate="yes" xml:space="preserve">
          <source>Keywords in Elixir are a list of tuples of two elements where the first element is an atom. Using the base constructs, they would be represented as:</source>
          <target state="translated">Ключевые слова в Elixir представляют собой список кортежей из двух элементов,где первым элементом является атом.Используя базовые конструкции,они будут представлены как:</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">Известные проблемы</target>
        </trans-unit>
        <trans-unit id="c2843be90e040c2ace2b060340b9db40c6dbf4a3" translate="yes" xml:space="preserve">
          <source>Known tags</source>
          <target state="translated">Известные теги</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="9e805fe1256b3cb3351f4f100e6b23dfaed4c00e" translate="yes" xml:space="preserve">
          <source>Last time we fixed the race condition by replacing the asynchronous operation, a &lt;code&gt;cast&lt;/code&gt;, by a &lt;code&gt;call&lt;/code&gt;, which is synchronous. Unfortunately, the &lt;code&gt;handle_info/2&lt;/code&gt; callback we are using to receive the &lt;code&gt;:DOWN&lt;/code&gt; message and delete the entry from the ETS table does not have a synchronous equivalent. This time, we need to find a way to guarantee the registry has processed the &lt;code&gt;:DOWN&lt;/code&gt; notification sent when the bucket process terminated.</source>
          <target state="translated">В прошлый раз мы исправили состояние гонки, заменив асинхронную операцию &lt;code&gt;cast&lt;/code&gt; на &lt;code&gt;call&lt;/code&gt; , который является синхронным. К сожалению, &lt;code&gt;handle_info/2&lt;/code&gt; вызов handle_info / 2, который мы используем для получения сообщения &lt;code&gt;:DOWN&lt;/code&gt; и удаления записи из таблицы ETS, не имеет синхронного эквивалента. На этот раз нам нужно найти способ гарантировать, что реестр обработал уведомление &lt;code&gt;:DOWN&lt;/code&gt; , отправляемое при завершении процесса корзины.</target>
        </trans-unit>
        <trans-unit id="75acd19542cbb9fa88cdabbe078724acb812d8b1" translate="yes" xml:space="preserve">
          <source>Later on we will learn how to compile Elixir code (in &lt;a href=&quot;modules-and-functions&quot;&gt;Chapter 8&lt;/a&gt;) and how to use the Mix build tool (in the &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt;). For now, let&amp;rsquo;s move on to &lt;a href=&quot;basic-types&quot;&gt;Chapter 2&lt;/a&gt;.</source>
          <target state="translated">Позже мы узнаем, как скомпилировать код Elixir (в &lt;a href=&quot;modules-and-functions&quot;&gt;главе 8&lt;/a&gt; ) и как использовать инструмент сборки Mix (в руководстве &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP&lt;/a&gt; ). А пока перейдем к &lt;a href=&quot;basic-types&quot;&gt;главе 2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dec3727f52253a21a625cc6c295ee24dda78903b" translate="yes" xml:space="preserve">
          <source>Lazily drops elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">Лениво бросает элементы перечисляемого,в то время как заданная функция возвращает правдивое значение.</target>
        </trans-unit>
        <trans-unit id="ee9b58962b88fa77ea098c1b0d427e9f46c19021" translate="yes" xml:space="preserve">
          <source>Lazily drops the next &lt;code&gt;n&lt;/code&gt; elements from the enumerable.</source>
          <target state="translated">Лениво отбрасывает следующие &lt;code&gt;n&lt;/code&gt; элементов из перечислимого.</target>
        </trans-unit>
        <trans-unit id="69ade1dc23ccb5f3b64347640778d1f4fe8c44ae" translate="yes" xml:space="preserve">
          <source>Lazily intersperses &lt;code&gt;intersperse_element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">Лениво вкрапляет &lt;code&gt;intersperse_element&lt;/code&gt; между каждым элементом перечисления.</target>
        </trans-unit>
        <trans-unit id="fb2c9b6a976811f032d7cbfe8165bb5865150558" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes all values associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="translated">Лениво возвращает и удаляет все значения, связанные с &lt;code&gt;key&lt;/code&gt; в списке ключевых слов.</target>
        </trans-unit>
        <trans-unit id="b61c3c17ee3d10d7647d9803c70ba26ee27244c1" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">Лениво возвращает и удаляет значение, связанное с &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e92baedbf908cf61336dc397f7fe80981871f17" translate="yes" xml:space="preserve">
          <source>Lazily takes elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">Лениво берет элементы перечисляемого,в то время как заданная функция возвращает правдивое значение.</target>
        </trans-unit>
        <trans-unit id="450194d4d3b114b2c73dd825ab3cd48712daf267" translate="yes" xml:space="preserve">
          <source>Lazily takes the next &lt;code&gt;count&lt;/code&gt; elements from the enumerable and stops enumeration.</source>
          <target state="translated">Лениво берет следующие элементы &lt;code&gt;count&lt;/code&gt; из перечисляемого и останавливает перечисление.</target>
        </trans-unit>
        <trans-unit id="9fa3a1af379a945e27159d6cbd53b6758da22a91" translate="yes" xml:space="preserve">
          <source>Leap seconds are not taken into account.</source>
          <target state="translated">Високосные секунды не учитываются.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">Узнать больше</target>
        </trans-unit>
        <trans-unit id="34ce14772451e311453b61a1ddb8221e562b888f" translate="yes" xml:space="preserve">
          <source>Left to right</source>
          <target state="translated">Слева направо</target>
        </trans-unit>
        <trans-unit id="efe84e15d94659b1eca2695c2253c5d3775e58ca" translate="yes" xml:space="preserve">
          <source>Left to right arrow</source>
          <target state="translated">Стрелка влево-вправо</target>
        </trans-unit>
        <trans-unit id="1401741d3c80953c9e3f5d95f783a5ec74cfbaff" translate="yes" xml:space="preserve">
          <source>Less-than operator.</source>
          <target state="translated">Меньше чем оператор.</target>
        </trans-unit>
        <trans-unit id="25e1e02fa6fbaded2f6f1e2459649cc19db9b44a" translate="yes" xml:space="preserve">
          <source>Less-than or equal to operator.</source>
          <target state="translated">Меньше или равнозначно оператору.</target>
        </trans-unit>
        <trans-unit id="e68d562699894469c473720b475220fbf042128a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also add a test to &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; that guarantees the bucket is temporary:</source>
          <target state="translated">Давайте также добавим тест в &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; , который гарантирует, что ведро является временным:</target>
        </trans-unit>
        <trans-unit id="404b4b3a784b443893ff8bf31f1dd037577b8b2e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break that code apart a bit:</source>
          <target state="translated">Давайте немного разберем этот код:</target>
        </trans-unit>
        <trans-unit id="4729229379e49f59080304c7286d1586582b445a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change &lt;code&gt;start/2&lt;/code&gt; once again, to add a supervisor to our tree:</source>
          <target state="translated">Давайте еще раз изменим &lt;code&gt;start/2&lt;/code&gt; , чтобы добавить супервизора в наше дерево:</target>
        </trans-unit>
        <trans-unit id="1a65af3d4df3dd7789d08b039fbd9ffd187026b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;KV.Registry&lt;/code&gt; to use ETS tables. The first change is to modify our registry to require a name argument, we will use it to name the ETS table and the registry process itself. ETS names and process names are stored in different locations, so there is no chance of conflicts.</source>
          <target state="translated">Давайте изменим &lt;code&gt;KV.Registry&lt;/code&gt; , чтобы использовать таблицы ETS. Первое изменение состоит в том, чтобы изменить наш реестр так, чтобы он требовал аргумента имени, мы будем использовать его для именования таблицы ETS и самого процесса реестра. Имена ETS и имена процессов хранятся в разных местах, поэтому конфликтов нет.</target>
        </trans-unit>
        <trans-unit id="9e05a0ba8c59d0c8c376685e9addab95d169eccc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check each case, one by one.</source>
          <target state="translated">Давайте проверим каждый случай по очереди.</target>
        </trans-unit>
        <trans-unit id="c27f60b2e4915c4a82ea29d51d011f01772e3dd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new Mix project. We are going to creatively name it &lt;code&gt;kv_umbrella&lt;/code&gt;, and this new project will have both the existing &lt;code&gt;kv&lt;/code&gt; application and the new &lt;code&gt;kv_server&lt;/code&gt; application inside. The directory structure will look like this:</source>
          <target state="translated">Создадим новый проект Mix. Мы собираемся творчески называть его &lt;code&gt;kv_umbrella&lt;/code&gt; , и этот новый проект будет содержать как существующее приложение &lt;code&gt;kv&lt;/code&gt; ,так и новое приложение &lt;code&gt;kv_server&lt;/code&gt; . Структура каталогов будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="b9686ac5cd9d110e2280341ca7651f1e7a2c3a8f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our command parser at &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; and start with the doctest:</source>
          <target state="translated">Давайте создадим наш синтаксический анализатор команд в &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; и начнем с doctest:</target>
        </trans-unit>
        <trans-unit id="57da67e011a89dbbfb6c22ba016b496c2bf15d61" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our first project by invoking &lt;code&gt;mix new&lt;/code&gt; from the command line. We&amp;rsquo;ll pass the project name as the argument (&lt;code&gt;kv&lt;/code&gt;, in this case), and tell Mix that our main module should be the all-uppercase &lt;code&gt;KV&lt;/code&gt;, instead of the default, which would have been &lt;code&gt;Kv&lt;/code&gt;:</source>
          <target state="translated">Давайте создадим наш первый проект, вызвав &lt;code&gt;mix new&lt;/code&gt; из командной строки. Мы передадим имя проекта в качестве аргумента ( в данном случае &lt;code&gt;kv&lt;/code&gt; ) и сообщим Mix, что нашим основным модулем должен быть &lt;code&gt;KV&lt;/code&gt; с заглавными буквами вместо значения по умолчанию, которое было бы &lt;code&gt;Kv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="44ccaac6800d7e69a627f543507cef6aaa36f75a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a module named &lt;code&gt;Hello&lt;/code&gt; in this shell:</source>
          <target state="translated">Давайте определим модуль с именем &lt;code&gt;Hello&lt;/code&gt; в этой оболочке:</target>
        </trans-unit>
        <trans-unit id="c3e19d4b698bea8666353bff2803ed53fb2593f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both &amp;ldquo;remove&amp;rdquo; tests at &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt;:</source>
          <target state="translated">Давайте сделаем это, создав &amp;laquo;фиктивную&amp;raquo; корзину, которая является синхронным запросом, после &lt;code&gt;Agent.stop/2&lt;/code&gt; в обоих тестах &amp;laquo;remove&amp;raquo; в &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78d3183a361ff888bc82b3eb6a4eacbf2fa2a5c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both tests:</source>
          <target state="translated">Давайте сделаем это, создав &amp;laquo;фиктивную&amp;raquo; корзину, которая является синхронным запросом, после &lt;code&gt;Agent.stop/2&lt;/code&gt; в обоих тестах:</target>
        </trans-unit>
        <trans-unit id="52cc88c9ff893fa670f476f83f7e11b188b0c8fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do this.</source>
          <target state="translated">Давай сделаем это.</target>
        </trans-unit>
        <trans-unit id="87f2c21bc94f91beaecdd70cb4c1e04e5acba348" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first play with monitors by starting a new console with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">Давайте сначала поиграем с мониторами, запустив новую консоль с помощью &lt;code&gt;iex -S mix&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cfccd6e33d5a510641ee1fe031db4c15efbf06a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started!</source>
          <target state="translated">Давайте начнем!</target>
        </trans-unit>
        <trans-unit id="66bbb9d93128da50d0a5fd0f342b723836429324" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try by running &lt;code&gt;iex kv.exs&lt;/code&gt;:</source>
          <target state="translated">Давайте попробуем, запустив &lt;code&gt;iex kv.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5839691ae3f96ef964d421fd3acb9f807e8f4ab6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try. Open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;, and let&amp;rsquo;s change the supervisor in the &lt;code&gt;start/2&lt;/code&gt; function to the following:</source>
          <target state="translated">Давайте попробуем. Откройте &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; , и давайте изменим супервизор в функции &lt;code&gt;start/2&lt;/code&gt; на следующий:</target>
        </trans-unit>
        <trans-unit id="baa34105a5b53a50e8c2b4ac1b991daa285cda4f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the updated supervisor a try inside &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">Давайте попробуем обновленный супервизор внутри &lt;code&gt;iex -S mix&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56cfa20ba11b54abba073399ca2cc31a1beb82f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back to the &lt;code&gt;Math&lt;/code&gt; module defined in the previous chapters, add some documentation and save it to the &lt;code&gt;math.ex&lt;/code&gt; file:</source>
          <target state="translated">Вернемся к модулю &lt;code&gt;Math&lt;/code&gt; , определенному в предыдущих главах, добавим документацию и сохраним ее в файл &lt;code&gt;math.ex&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e193874a827cfe3989b47093b1f35bf1d889de9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the integration test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; as shown below:</source>
          <target state="translated">Давайте реализуем интеграционный тест в &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; , как показано ниже:</target>
        </trans-unit>
        <trans-unit id="f3d61bf295e16bbbb18d9e86a778638333f98c0d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement those steps. Move to the &lt;code&gt;apps/kv_server&lt;/code&gt; application, open up &lt;code&gt;lib/kv_server.ex&lt;/code&gt;, and add the following functions:</source>
          <target state="translated">Давайте реализуем эти шаги. Перейдите в &lt;code&gt;apps/kv_server&lt;/code&gt; , откройте &lt;code&gt;lib/kv_server.ex&lt;/code&gt; и добавьте следующие функции:</target>
        </trans-unit>
        <trans-unit id="39e760533fa67c3a16cee4f61982aced80e52f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s learn how to do that.</source>
          <target state="translated">Давайте узнаем, как это сделать.</target>
        </trans-unit>
        <trans-unit id="95fbfcaeec6c28ee848bbee5b849155b25cee14c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example to understand how to define more complex types. Say we have a &lt;code&gt;LousyCalculator&lt;/code&gt; module, which performs the usual arithmetic operations (sum, product, and so on) but, instead of returning numbers, it returns tuples with the result of an operation as the first element and a random remark as the second element.</source>
          <target state="translated">Давайте посмотрим на другой пример, чтобы понять, как определять более сложные типы. Скажем, у нас есть модуль &lt;code&gt;LousyCalculator&lt;/code&gt; , который выполняет обычные арифметические операции (сумма, произведение и т. Д.), Но вместо того, чтобы возвращать числа, он возвращает кортежи с результатом операции в качестве первого элемента и случайного примечания в качестве второго элемента. .</target>
        </trans-unit>
        <trans-unit id="cf8ebea7b04a470e898c361b3c01206eb4a8342a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make another example using streams. Since the &lt;code&gt;IO&lt;/code&gt; module provides streams (that are both &lt;code&gt;Enumerable&lt;/code&gt;s and &lt;code&gt;Collectable&lt;/code&gt;s), an echo terminal that echoes back the upcased version of whatever is typed can be implemented using comprehensions:</source>
          <target state="translated">Приведем еще один пример с использованием потоков. Поскольку модуль &lt;code&gt;IO&lt;/code&gt; предоставляет потоки (которые являются как &lt;code&gt;Enumerable&lt;/code&gt; ,так и &lt;code&gt;Collectable&lt;/code&gt; s), эхо-терминал, который возвращает эхом версию с преобразованным кодом, что бы ни было напечатано, может быть реализован с использованием представлений:</target>
        </trans-unit>
        <trans-unit id="ed8179b6236a6127fea762c1dc4859e7ff9ad41e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move inside the apps directory and start building &lt;code&gt;kv_server&lt;/code&gt;. This time, we are going to pass the &lt;code&gt;--sup&lt;/code&gt; flag, which will tell Mix to generate a supervision tree automatically for us, instead of building one manually as we did in previous chapters:</source>
          <target state="translated">Перейдем в каталог приложений и начнем строить &lt;code&gt;kv_server&lt;/code&gt; . На этот раз мы собираемся передать флаг &lt;code&gt;--sup&lt;/code&gt; , который укажет Mix автоматически сгенерировать для нас дерево надзора, вместо того, чтобы строить его вручную, как мы делали в предыдущих главах:</target>
        </trans-unit>
        <trans-unit id="9abc4b0404a0faf043a413238fb9c0b85596b7d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move to the next chapter. We will finally make our system distributed by adding a bucket routing mechanism. We will use this opportunity to also improve our testing chops.</source>
          <target state="translated">Переходим к следующей главе. Наконец, мы сделаем нашу систему распределенной, добавив механизм маршрутизации корзины. Мы будем использовать эту возможность, чтобы улучшить наши навыки тестирования.</target>
        </trans-unit>
        <trans-unit id="678e1823b091b3645ecead3457dcbde5e2e4d606" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;. Additionally we will set the &lt;code&gt;cookie&lt;/code&gt; option on both releases to &lt;code&gt;weknoweachother&lt;/code&gt; in order for them to allow connections from each other. See the &lt;a href=&quot;http://erlang.org/doc/reference_manual/distributed.html&quot;&gt;Distributed Erlang Documentation&lt;/a&gt; for further information on this topic:</source>
          <target state="translated">Теперь давайте определим выпуск для &lt;code&gt;:bar&lt;/code&gt; . Первым шагом может быть определение релиза в точности как &lt;code&gt;foo&lt;/code&gt; внутри &lt;code&gt;mix.exs&lt;/code&gt; . Кроме того, мы установим параметр &lt;code&gt;cookie&lt;/code&gt; в обоих выпусках, чтобы мы &lt;code&gt;weknoweachother&lt;/code&gt; друг друга, чтобы они разрешали соединения друг с другом. Дополнительную информацию по этой теме см. В &lt;a href=&quot;http://erlang.org/doc/reference_manual/distributed.html&quot;&gt;документации&lt;/a&gt; по распределенному Erlang :</target>
        </trans-unit>
        <trans-unit id="907c5a40686f1ad77133ab1fb7ed4fb9044e980b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Теперь давайте определим выпуск для &lt;code&gt;:bar&lt;/code&gt; . Первым шагом может быть определение релиза точно так же, как &lt;code&gt;foo&lt;/code&gt; внутри &lt;code&gt;mix.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a2917bda9d2d2ade9ad2c9418f4b2b9f81e1083" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now see how we can use the power of recursion to sum a list of numbers:</source>
          <target state="translated">Давайте теперь посмотрим, как мы можем использовать силу рекурсии для суммирования списка чисел:</target>
        </trans-unit>
        <trans-unit id="df2a11fdb0c0854864b329de4b39854b42d8a291" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s put it all together and send messages between processes:</source>
          <target state="translated">Соберем все вместе и отправим сообщения между процессами:</target>
        </trans-unit>
        <trans-unit id="2fe45cc7fb55e4c742c4dc05c2cb987f67c6d233" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="translated">Подведем итоги происходящего. Каждый раз, когда мы вызываем &lt;code&gt;iex -S mix&lt;/code&gt; , оно автоматически запускает наше приложение, вызывая &lt;code&gt;Application.start(:kv)&lt;/code&gt; , которое затем вызывает обратный вызов приложения. Задача обратного вызова приложения - запустить &lt;strong&gt;дерево контроля&lt;/strong&gt; . Сейчас у нас есть только один супервизор, но иногда супервизор также контролируется, придавая ему форму дерева. Пока у нашего супервизора есть единственный дочерний &lt;code&gt;KV.Registry&lt;/code&gt; , KV.Registry , который начинается с имени &lt;code&gt;KV.Registry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36a4ac644ae7aee151cedc8249d95bbb7eb1151f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback&amp;rsquo;s job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="translated">Подведем итоги того, что происходит. Всякий раз, когда мы вызываем &lt;code&gt;iex -S mix&lt;/code&gt; , он автоматически запускает наше приложение, вызывая &lt;code&gt;Application.start(:kv)&lt;/code&gt; , который затем вызывает обратный вызов приложения. Задача обратного вызова приложения - запустить &lt;strong&gt;дерево контроля&lt;/strong&gt; . Сейчас у нас есть только один супервизор, но иногда супервизор также контролируется, придавая ему форму дерева. Пока у нашего супервизора есть единственный дочерний &lt;code&gt;KV.Registry&lt;/code&gt; , KV.Registry , который начинается с имени &lt;code&gt;KV.Registry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="325ed6370b4676504d3b00af4ba0fd26fde98423" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two dictionaries: one that contains &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; and another that holds &lt;code&gt;ref -&amp;gt; name&lt;/code&gt;. Then we need to monitor the buckets on &lt;code&gt;handle_cast/2&lt;/code&gt; as well as implement a &lt;code&gt;handle_info/2&lt;/code&gt; callback to handle the monitoring messages. The full server callbacks implementation is shown below:</source>
          <target state="translated">Давайте повторно реализуем обратные вызовы сервера, чтобы исправить ошибку и пройти тест. Во-первых, мы изменим состояние GenServer на два словаря: один содержит &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; а другой &lt;code&gt;ref -&amp;gt; name&lt;/code&gt; . Затем нам нужно отслеживать сегменты на &lt;code&gt;handle_cast/2&lt;/code&gt; , а также реализовать &lt;code&gt;handle_info/2&lt;/code&gt; вызов handle_info / 2 для обработки сообщений мониторинга. Полная реализация обратных вызовов сервера показана ниже:</target>
        </trans-unit>
        <trans-unit id="5859e594dd7ff75c74328e1ec62ef118e79b5173" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite the test case to use callbacks:</source>
          <target state="translated">Давайте перепишем тестовый пример, чтобы использовать обратные вызовы:</target>
        </trans-unit>
        <trans-unit id="7af0235d132a57562aba639e633d1cb04c26a76e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the tests once again. This time though, we will pass the &lt;code&gt;--trace&lt;/code&gt; option:</source>
          <target state="translated">Давайте еще раз запустим тесты. Однако на этот раз мы &lt;code&gt;--trace&lt;/code&gt; опцию --trace :</target>
        </trans-unit>
        <trans-unit id="2aced57d244d27459d17d10f2ab48937597ad351" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see in more detail what happens when you request &lt;code&gt;IO.write(pid, binary)&lt;/code&gt;. The &lt;code&gt;IO&lt;/code&gt; module sends a message to the process identified by &lt;code&gt;pid&lt;/code&gt; with the desired operation. A small ad-hoc process can help us see it:</source>
          <target state="translated">Давайте посмотрим более подробно, что происходит, когда вы запрашиваете &lt;code&gt;IO.write(pid, binary)&lt;/code&gt; . Модуль &lt;code&gt;IO&lt;/code&gt; отправляет сообщение процессу, указанному &lt;code&gt;pid&lt;/code&gt; , с желаемой операцией. Небольшой специальный процесс может помочь нам в этом:</target>
        </trans-unit>
        <trans-unit id="67af3c48055ca2b3c2d9f546637c104f51f74e74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see this in practice. Start a console with &lt;code&gt;iex -S mix&lt;/code&gt; and try:</source>
          <target state="translated">Посмотрим на это на практике. Запустите консоль с помощью &lt;code&gt;iex -S mix&lt;/code&gt; и попробуйте:</target>
        </trans-unit>
        <trans-unit id="7dee2fe998155b6e01d27bc48c7887e983907b48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s slightly change our children definition (in &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt;) to be a list of tuples instead of a list of atoms:</source>
          <target state="translated">Давайте немного изменим определение наших дочерних &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt; (в KV.Supervisor.init / 1 ), чтобы оно было списком кортежей вместо списка атомов:</target>
        </trans-unit>
        <trans-unit id="1bd92f7c84f63683d6101c71449ed203a7800ec9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start &lt;code&gt;iex&lt;/code&gt; with the module above:</source>
          <target state="translated">Начнем &lt;code&gt;iex&lt;/code&gt; с модуля выше:</target>
        </trans-unit>
        <trans-unit id="9d1661fc8a81e848a401464f1c2a605c5da459d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project using &lt;code&gt;mix new&lt;/code&gt;. This new project will be named &lt;code&gt;kv_umbrella&lt;/code&gt; and we need to pass the &lt;code&gt;--umbrella&lt;/code&gt; option when creating it. Do not create this new project inside the existing &lt;code&gt;kv&lt;/code&gt; project!</source>
          <target state="translated">Начнем новый проект, используя &lt;code&gt;mix new&lt;/code&gt; . Этот новый проект будет называться &lt;code&gt;kv_umbrella&lt;/code&gt; , и нам необходимо передать параметр &lt;code&gt;--umbrella&lt;/code&gt; при его создании. Не создавайте этот новый проект внутри существующего проекта &lt;code&gt;kv&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="9f966b08bc66cb4042c8b3f3f1b9e2153b0cd851" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a module that defines and imports the &lt;code&gt;test&lt;/code&gt; macro when used:</source>
          <target state="translated">Начнем с создания модуля, который определяет и импортирует &lt;code&gt;test&lt;/code&gt; макрос при использовании:</target>
        </trans-unit>
        <trans-unit id="a0fddb1a8907c2cf50e04a25da3983ae6441dda6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a test that describes how we want the registry to behave if a bucket stops or crashes:</source>
          <target state="translated">Начнем с теста, который описывает, как мы хотим, чтобы реестр вел себя в случае остановки или сбоя корзины:</target>
        </trans-unit>
        <trans-unit id="1fa11d581397d95e04f2020a68e066fb3e60d04a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a brief look at those generated files.</source>
          <target state="translated">Давайте кратко рассмотрим эти сгенерированные файлы.</target>
        </trans-unit>
        <trans-unit id="4fd5f73d356b99a110fa9e76edf1bdd8cb9fd455" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt; and, while we&amp;rsquo;re at it, its lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;.</source>
          <target state="translated">Давайте подробнее рассмотрим &lt;code&gt;Enumerable&lt;/code&gt; и его ленивый аналог &lt;code&gt;Stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e68357588d11fea0410465b619814c2039a742" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt;s and, while we&amp;rsquo;re at it, their lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;s.</source>
          <target state="translated">Давайте более подробно рассмотрим &lt;code&gt;Enumerable&lt;/code&gt; s и, пока мы, их ленивый аналог &lt;code&gt;Stream&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="91b289146778a1a9ac545041f63405e023909059" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervior for a spin:</source>
          <target state="translated">Возьмем супервизора на спинку:</target>
        </trans-unit>
        <trans-unit id="753880cccfa8315b0ba2213f8e81608e972f525e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervisor for a spin:</source>
          <target state="translated">Возьмем супервайзера на пробу:</target>
        </trans-unit>
        <trans-unit id="3b01013918cb505bb54dd81a9af06894999c0120" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a test to verify our router works. Create a file named &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; containing:</source>
          <target state="translated">Напишем тест, чтобы убедиться, что наш роутер работает. Создайте файл с именем &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; , содержащий:</target>
        </trans-unit>
        <trans-unit id="fa012006b966bf0a6eab57a8968215cebf134379" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write some code!</source>
          <target state="translated">Напишем код!</target>
        </trans-unit>
        <trans-unit id="c67023947ca555b00e6d88ffa6d4701c0c3be370" translate="yes" xml:space="preserve">
          <source>Let's build a stream and then enumerate it:</source>
          <target state="translated">Давайте построим ручей,а затем перечислим его:</target>
        </trans-unit>
        <trans-unit id="af13b7ca9a49d1b748a7f4486807d45530939bbd" translate="yes" xml:space="preserve">
          <source>Let's create a document by concatenating two strings with a break between them:</source>
          <target state="translated">Создадим документ,объединив две строки с перерывом между ними:</target>
        </trans-unit>
        <trans-unit id="5d78dfa30452eb74635f4fb43b15b17251e16913" translate="yes" xml:space="preserve">
          <source>Let's explore the basic functions from the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; used for debugging:</source>
          <target state="translated">Давайте рассмотрим основные функции &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;модуля &lt;/a&gt; &lt;code&gt;:sys&lt;/code&gt; , используемые для отладки:</target>
        </trans-unit>
        <trans-unit id="688ee6c95315db8b18bfec15fee2dfd168073eec" translate="yes" xml:space="preserve">
          <source>Let's fix our macro:</source>
          <target state="translated">Давайте исправим наш макрос:</target>
        </trans-unit>
        <trans-unit id="d7fff4c2e7484327d49d843539125f18766ef59b" translate="yes" xml:space="preserve">
          <source>Let's give it a try. First start a new shell:</source>
          <target state="translated">Давай попробуем.Сначала запустите новую оболочку:</target>
        </trans-unit>
        <trans-unit id="385a594a813b358193b288faec070338a76a46ba" translate="yes" xml:space="preserve">
          <source>Let's look at a quick case study: we want to check that a function argument is an even or odd integer. With pattern matching, this is impossible to do since there are infinite integers, and thus we can't pattern match on the single even/odd numbers. Let's focus on checking for even numbers since checking for odd ones is almost identical.</source>
          <target state="translated">Рассмотрим небольшой пример:мы хотим проверить,что аргумент функции является четным или нечетным целым числом.При совпадении по шаблону это невозможно,так как существуют бесконечные целые числа,и поэтому мы не можем выполнить совпадение по шаблону для одиночных четных/объединенных чисел.Давайте сосредоточимся на проверке четных чисел,так как проверка на нечетные почти идентична.</target>
        </trans-unit>
        <trans-unit id="af9fd18fc73d83d65ff9f7021afd43158fe10001" translate="yes" xml:space="preserve">
          <source>Let's see a simple example that shows the difference between functions and macros:</source>
          <target state="translated">Рассмотрим простой пример,показывающий разницу между функциями и макросами:</target>
        </trans-unit>
        <trans-unit id="f17d3ddea9ff5b443102e2f1aa7d529504a09b53" translate="yes" xml:space="preserve">
          <source>Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">Посмотрим на простом примере. Представьте себе , что вы реализуете библиотеку , которая разбивает строку на две частей на основе первого появления тира &lt;code&gt;-&lt;/code&gt; символ:</target>
        </trans-unit>
        <trans-unit id="4c56c3643f8f926eb1db1e031cb602d1e685c584" translate="yes" xml:space="preserve">
          <source>Let's see an example &lt;code&gt;MyApp.application/0&lt;/code&gt; function:</source>
          <target state="translated">Давайте посмотрим на пример функции &lt;code&gt;MyApp.application/0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a086f0aa8dc3f13f368da5ddef024d84bd14e45f" translate="yes" xml:space="preserve">
          <source>Let's see an example of a guard used in a function clause:</source>
          <target state="translated">Рассмотрим пример защитника,используемого в пункте функции:</target>
        </trans-unit>
        <trans-unit id="eb3e603df7a85750e6414b0eb382239bbf870bfb" translate="yes" xml:space="preserve">
          <source>Let's see an example.</source>
          <target state="translated">Давайте посмотрим пример.</target>
        </trans-unit>
        <trans-unit id="2bb9a3671c7cc45e630956b53927eeec08220af2" translate="yes" xml:space="preserve">
          <source>Let's see how we could use those functions for debugging the stack server we defined earlier.</source>
          <target state="translated">Давайте посмотрим,как мы можем использовать эти функции для отладки сервера стека,который мы определили ранее.</target>
        </trans-unit>
        <trans-unit id="9944bcda5d8aef46440ac764e0d71869f8b3eb89" translate="yes" xml:space="preserve">
          <source>Let's see some examples. The code below:</source>
          <target state="translated">Давайте посмотрим несколько примеров.Код ниже:</target>
        </trans-unit>
        <trans-unit id="9a9747f9ce9d128c721ed4b062d8c863cdde1877" translate="yes" xml:space="preserve">
          <source>Let's start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop elements:</source>
          <target state="translated">Начнем с примера кода,а затем рассмотрим доступные обратные вызовы.Представьте,что нам нужен GenServer,который работает как стек,позволяя нам нажимать и нажимать элементы:</target>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="translated">Давайте начнем с примера:</target>
        </trans-unit>
        <trans-unit id="c1e622e103cbf1ed1953980d1ec1467158ec5553" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="translated">Предположим, вы создали свою собственную реализацию &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; в модуле &lt;code&gt;MyMacros&lt;/code&gt; . Если вы хотите вызвать его, вам нужно сначала явно потребовать &lt;code&gt;MyMacros&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c498b7be97563d9e009446e491717478748954ec" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="translated">Предположим, вы создали свою собственную реализацию &lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; в модуле &lt;code&gt;MyMacros&lt;/code&gt; . Если вы хотите вызвать его, вам нужно сначала явно потребовать &lt;code&gt;MyMacros&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a0f18507825fffb50cb06a0af30333ce99e8402" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="translated">Предположим, вы хотите исследовать, что происходит с какой-то конкретной функцией. Вызывая &lt;a href=&quot;#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; от функции, Iex позволит вам получить доступ к его связыванию (переменным), проверить свою лексическую информацию и доступ к информации процесса. Посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="167e9ac5d10b20cb0dda56b181fe66788b49d6e5" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="translated">Предположим, вы хотите исследовать, что происходит с какой-то конкретной функцией. Вызывая &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; от функции, Iex позволит вам получить доступ к его связыванию (переменным), проверить свою лексическую информацию и доступ к информации процесса. Посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="810f288f1e4fdf45c23a3b902942dd7960a5c22f" translate="yes" xml:space="preserve">
          <source>Let's understand what the &lt;code&gt;:shutdown&lt;/code&gt; and &lt;code&gt;:restart&lt;/code&gt; options control.</source>
          <target state="translated">Давайте разберемся, что контролируют параметры &lt;code&gt;:shutdown&lt;/code&gt; и &lt;code&gt;:restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="5ff76884a1b9f933647dc46c0efb08cd23ce4c72" translate="yes" xml:space="preserve">
          <source>Lexical scope</source>
          <target state="translated">Лексическая сфера</target>
        </trans-unit>
        <trans-unit id="b8100f5ba8bd048a7cf11d116fbbd73130c3c6f5" translate="yes" xml:space="preserve">
          <source>Library</source>
          <target state="translated">Library</target>
        </trans-unit>
        <trans-unit id="b7e01bf49268dbb685a7684daf71674fc58c2f88" translate="yes" xml:space="preserve">
          <source>Library Guidelines</source>
          <target state="translated">Библиотечные указания</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Лицензия Apache,версия 2.0.</target>
        </trans-unit>
        <trans-unit id="8c32d4b808a84de40c883809049bbfd2ca84a901" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">Как и в &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , функции в этом модуле работают в линейном времени. Это означает, что время, необходимое для выполнения операции, растет с той же скоростью, что и длина списка. Это ожидается в таких операциях, как &lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt; . В конце концов, если мы хотим пройти каждый элемент в потоке, чем длиннее поток, тем больше элементов нам нужно пройти и тем больше времени это займет.</target>
        </trans-unit>
        <trans-unit id="9a69b557caf2f4f9ed4d8f872b75f17d33faa2d9" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">Как и в &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , функции в этом модуле работают в линейном времени. Это означает, что время, необходимое для выполнения операции, растет с той же скоростью, что и длина списка. Это ожидается в таких операциях, как &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt; . В конце концов, если мы хотим пройти каждый элемент в потоке, чем длиннее поток, тем больше элементов нам нужно пройти, и тем больше времени это займет.</target>
        </trans-unit>
        <trans-unit id="e959a6b5621b2dae8ab30d3d3f44c9b21fd9caf5" translate="yes" xml:space="preserve">
          <source>Limit for when a certain time zone period begins or ends.</source>
          <target state="translated">Ограничение на время,когда начинается или заканчивается период определенного часового пояса.</target>
        </trans-unit>
        <trans-unit id="447809eeca7d1b001940f2b5c2552166d7274fa3" translate="yes" xml:space="preserve">
          <source>Line &lt;code&gt;0&lt;/code&gt; and column &lt;code&gt;0&lt;/code&gt; would mean the top left corner.</source>
          <target state="translated">Строка &lt;code&gt;0&lt;/code&gt; и столбец &lt;code&gt;0&lt;/code&gt; означают верхний левый угол.</target>
        </trans-unit>
        <trans-unit id="f75f7d7f1f9d02250730e14081c315ebe6091bed" translate="yes" xml:space="preserve">
          <source>Line numbers are one-based, and column numbers in a range are zero-based and refer to the cursor position at the start of the character at that index. For example, to indicate that a diagnostic applies to the first &lt;code&gt;n&lt;/code&gt; characters of the first line, the range would be &lt;code&gt;{1, 0, 1, n}&lt;/code&gt;.</source>
          <target state="translated">Номера строк начинаются с единицы, а номера столбцов в диапазоне отсчитываются от нуля и относятся к позиции курсора в начале символа в этом индексе. Например, чтобы указать, что диагностика применяется к первым &lt;code&gt;n&lt;/code&gt; символам первой строки, диапазон будет &lt;code&gt;{1, 0, 1, n}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88d6c7e0d9491c204ea28cf1ccec11cd1021b58d" translate="yes" xml:space="preserve">
          <source>Linked lists hold zero, one, or more elements in the chosen order.</source>
          <target state="translated">Связанные списки содержат ноль,один или несколько элементов в выбранном порядке.</target>
        </trans-unit>
        <trans-unit id="a5f54e0f2d31735fc8356d4c643062d7468cc599" translate="yes" xml:space="preserve">
          <source>Linking</source>
          <target state="translated">Linking</target>
        </trans-unit>
        <trans-unit id="fce9e7983aa4d178575a43583fbc0a75230dea86" translate="yes" xml:space="preserve">
          <source>Linking can also be done manually by calling &lt;code&gt;Process.link/1&lt;/code&gt;. We recommend that you take a look at &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;the &lt;code&gt;Process&lt;/code&gt; module&lt;/a&gt; for other functionality provided by processes.</source>
          <target state="translated">Связывание также можно выполнить вручную, вызвав &lt;code&gt;Process.link/1&lt;/code&gt; . Мы рекомендуем вам взглянуть на &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;в &lt;code&gt;Process&lt;/code&gt; модуля&lt;/a&gt; для других функциональных возможностей, предоставляемых процессов.</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="5bf3859293f6be21536ffe679146ee6401148648" translate="yes" xml:space="preserve">
          <source>Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.</source>
          <target state="translated">Ссылки двунаправленные.Если вы связываете два процесса и один из них выходит из строя,то и другая сторона тоже выходит из строя (если только это не выход из строя).Монитор является однонаправленным:только наблюдательный процесс будет получать уведомления о наблюдаемом.Другими словами:используйте ссылки,когда вам нужны связанные сбои,и отслеживайте,когда вы просто хотите быть информированным о сбоях,выходах и так далее.</target>
        </trans-unit>
        <trans-unit id="b3e008dc1478680d69d7d944ea5e97681e447863" translate="yes" xml:space="preserve">
          <source>Links are bidirectional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.</source>
          <target state="translated">Ссылки являются двунаправленными,что подразумевает,что сбой в ведре приведет к краху реестра.Хотя теперь у нас есть супервизор,который гарантирует,что реестр будет восстановлен и запущен,сбой в реестре все же означает потерю всех данных,связывающих имена ведер с соответствующими процессами.</target>
        </trans-unit>
        <trans-unit id="010816f5d4211c808577da6a4d3fff9e452bea0e" translate="yes" xml:space="preserve">
          <source>Links are bidirectional. Linked processes can be unlinked by using &lt;a href=&quot;#unlink/1&quot;&gt;&lt;code&gt;unlink/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ссылки двунаправленные. Связанные процессы можно отключить с помощью &lt;a href=&quot;#unlink/1&quot;&gt; &lt;code&gt;unlink/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="d8c15547c73710a89415334a00b0ee5a2c8790ae" translate="yes" xml:space="preserve">
          <source>List concatenation operator. Concatenates a proper list and a term, returning a list.</source>
          <target state="translated">Слушайте оператора конкатенации.Конкатенует соответствующий список и термин,возвращая список.</target>
        </trans-unit>
        <trans-unit id="5ea588245c39a0237a816a5a4b5f30b996ac4e47" translate="yes" xml:space="preserve">
          <source>List of allowed expressions</source>
          <target state="translated">Список разрешенных выражений</target>
        </trans-unit>
        <trans-unit id="3bc1afebc9f88b8646bec755bebbd01b76058e82" translate="yes" xml:space="preserve">
          <source>List of allowed functions and operators</source>
          <target state="translated">Список разрешенных функций и операторов</target>
        </trans-unit>
        <trans-unit id="e6fd9a7c630dc04fe44f8eceb64283a7b0d97ed2" translate="yes" xml:space="preserve">
          <source>List of supported keys in the keyword list:</source>
          <target state="translated">Список поддерживаемых ключей в списке ключевых слов:</target>
        </trans-unit>
        <trans-unit id="0b38e76a685c2b2df84a12add2cb4a8302d42bac" translate="yes" xml:space="preserve">
          <source>List operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are &lt;em&gt;immutable&lt;/em&gt;. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will mutate it in memory - only transform it.</source>
          <target state="translated">Операторы списков никогда не изменяют существующий список. Объединение или удаление элементов из списка возвращает новый список. Мы говорим, что структуры данных Elixir &lt;em&gt;неизменяемы&lt;/em&gt; . Одним из преимуществ неизменяемости является то, что она приводит к более ясному коду. Вы можете свободно передавать данные с гарантией, что никто не изменит их в памяти - только преобразовать их.</target>
        </trans-unit>
        <trans-unit id="ad56da9a17e3e3df18feffc154b101554e4c5019" translate="yes" xml:space="preserve">
          <source>List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right.</source>
          <target state="translated">Оператор вычитания списка.Удаляет первое появление элемента в левом списке для каждого элемента справа.</target>
        </trans-unit>
        <trans-unit id="b2eb00e5233b62475b0dc3d5e4e0b3fba8fb4994" translate="yes" xml:space="preserve">
          <source>List.Chars</source>
          <target state="translated">List.Chars</target>
        </trans-unit>
        <trans-unit id="9f9dce20c46fcd1c1728dc56a20927edd518996b" translate="yes" xml:space="preserve">
          <source>List.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Протокол&lt;/small&gt; List.Chars&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d03be4130ee5ad90ce04ed9ec5d74c5566fe35d8" translate="yes" xml:space="preserve">
          <source>List.Chars.t (0)</source>
          <target state="translated">List.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="360565f0168323951cb15fd7ca1982778f9a1e7d" translate="yes" xml:space="preserve">
          <source>List.Chars.to_charlist (1)</source>
          <target state="translated">List.Chars.to_charlist (1)</target>
        </trans-unit>
        <trans-unit id="f37415d7b26ed53d3baccb63f14d10f67a7f2022" translate="yes" xml:space="preserve">
          <source>Listens to a port until the port is available and it gets hold of the socket</source>
          <target state="translated">Слушает порт до тех пор,пока порт не станет доступен и не получит доступ к гнезду.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="30045b3ebb820da7e212b26c8d486fa6438d1b21" translate="yes" xml:space="preserve">
          <source>Lists all dependencies and their status.</source>
          <target state="translated">Перечисляет все зависимости и их статус.</target>
        </trans-unit>
        <trans-unit id="d0400b695b82b7f117940b8b0f5038dea1a03963" translate="yes" xml:space="preserve">
          <source>Lists all installed archives.</source>
          <target state="translated">Перечисляет все установленные архивы.</target>
        </trans-unit>
        <trans-unit id="ab1fcad81755990415fb928f4bb6482b9fa8177c" translate="yes" xml:space="preserve">
          <source>Lists all installed escripts.</source>
          <target state="translated">Перечисляет все установленные эскрипты.</target>
        </trans-unit>
        <trans-unit id="576be6f9e3cd2119a02b300937f31a0bfa25055f" translate="yes" xml:space="preserve">
          <source>Lists all required files.</source>
          <target state="translated">Перечисляет все необходимые файлы.</target>
        </trans-unit>
        <trans-unit id="e5fcc5c6ccb03f1f5363ab1add506f548d93b038" translate="yes" xml:space="preserve">
          <source>Lists all tasks and aliases or prints the documentation for a given task or alias.</source>
          <target state="translated">Перечисляет все задачи и псевдонимы или печатает документацию для данной задачи или псевдонима.</target>
        </trans-unit>
        <trans-unit id="4b514bc4e3164c52bfb95195bf0bb5ba74e08baf" translate="yes" xml:space="preserve">
          <source>Lists also implement the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, so many functions to work with lists are found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions and operators for lists are found in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Списки также реализуют протокол &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , поэтому многие функции для работы со списками находятся в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; . Кроме того, в &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; находятся следующие функции и операторы для списков :</target>
        </trans-unit>
        <trans-unit id="afec6cb6a10a87d6a4707e28871420191c221295" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element.</source>
          <target state="translated">Списки сравниваются по элементам.</target>
        </trans-unit>
        <trans-unit id="ab57d49cbf8304700835035bc3343277d30e43d1" translate="yes" xml:space="preserve">
          <source>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.</source>
          <target state="translated">Списки хранятся в памяти в виде связанных списков,что означает,что каждый элемент списка хранит свое значение и указывает на следующий элемент до тех пор,пока не будет достигнут конец списка.Это означает,что доступ к длине списка является линейной операцией:нам нужно пройти весь список,чтобы определить его размер.</target>
        </trans-unit>
        <trans-unit id="c01ea530434a00d0b1bc3bdc3aad101f3c850abd" translate="yes" xml:space="preserve">
          <source>Lists command line arguments.</source>
          <target state="translated">Списки аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="347e071fbc04592a3c2f0d22435ec182a39831ba" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:</source>
          <target state="translated">Списки в Elixir являются эффективно связанными списками,что означает,что они внутренне представлены парами,содержащими голову и хвост списка:</target>
        </trans-unit>
        <trans-unit id="1298ac093986653b2f114a6ee0f3b99d3384eec7" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are specified between square brackets:</source>
          <target state="translated">Списки в эликсире задаются между квадратными скобками:</target>
        </trans-unit>
        <trans-unit id="8b24ff6edd5f61dd85578b462cfb5ccb5e1d7ec5" translate="yes" xml:space="preserve">
          <source>Lists local tasks.</source>
          <target state="translated">Перечисляет местные задачи.</target>
        </trans-unit>
        <trans-unit id="de7c16fdcb7dbcdae885c936e8e70fdad2dfea81" translate="yes" xml:space="preserve">
          <source>Lists manifest files for the compiler.</source>
          <target state="translated">Списки декларируют файлы для компилятора.</target>
        </trans-unit>
        <trans-unit id="d0f09ee3032c9247a8875448970636dcb5d79ece" translate="yes" xml:space="preserve">
          <source>Lists may appear in patterns using the square brackets syntax (&lt;code&gt;[]&lt;/code&gt;). A list in a pattern will match only lists of the same size, where each individual list element must also match:</source>
          <target state="translated">Списки могут появляться в шаблонах с использованием синтаксиса квадратных скобок ( &lt;code&gt;[]&lt;/code&gt; ). Список в шаблоне будет соответствовать только спискам одинакового размера, где также должен совпадать каждый отдельный элемент списка:</target>
        </trans-unit>
        <trans-unit id="bca74458ce5102822957d2008558c1693dad3f4a" translate="yes" xml:space="preserve">
          <source>Lists or tuples?</source>
          <target state="translated">Списки или кортежи?</target>
        </trans-unit>
        <trans-unit id="c6c37e3f50d97e7e2b3eda7fd75f9f8b70fa1609" translate="yes" xml:space="preserve">
          <source>Lists, tuples and binaries</source>
          <target state="translated">Списки,кортежи и двоичные файлы</target>
        </trans-unit>
        <trans-unit id="d8107e4dcdc428ba751fa94c9e388d0ea60cfc3c" translate="yes" xml:space="preserve">
          <source>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</source>
          <target state="translated">Списки,кортежи,битовые строки,карты,структуры и вызовы функций будут разбиты на несколько строк,если за ними последует новая строка в открывающей скобке,а перед ней-новая строка в закрывающей скобке.</target>
        </trans-unit>
        <trans-unit id="5d726676b1647ae189afafe7c0135c21ac5baa4c" translate="yes" xml:space="preserve">
          <source>Literal &quot;%&quot; character</source>
          <target state="translated">буквальный &quot;%&quot; символ</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="7513abc36384d31942a5cf7f931786fd04bb1c73" translate="yes" xml:space="preserve">
          <source>Literals (numbers and atoms)</source>
          <target state="translated">Буквы (числа и атомы)</target>
        </trans-unit>
        <trans-unit id="91cb6ed4366e6af4c20b2f0bc91cc0d0ee8e284b" translate="yes" xml:space="preserve">
          <source>Loading an application &lt;em&gt;does not&lt;/em&gt; load its modules.</source>
          <target state="translated">Загрузка приложения &lt;em&gt;не&lt;/em&gt; загружает его модули.</target>
        </trans-unit>
        <trans-unit id="d0935c21f18347f738724d92e6a79d6627db8bae" translate="yes" xml:space="preserve">
          <source>Loading applications</source>
          <target state="translated">Загрузка приложений</target>
        </trans-unit>
        <trans-unit id="c59cbcfe056227b16292e8dcaf0f66d26224a608" translate="yes" xml:space="preserve">
          <source>Loading the application does not start it nor load its modules, but it does load its environment.</source>
          <target state="translated">Загрузка приложения не запускает его и не загружает его модули,а загружает его окружение.</target>
        </trans-unit>
        <trans-unit id="44008e484aac635c82b9da39454ca6c5bef5b635" translate="yes" xml:space="preserve">
          <source>Loads all tasks in all code paths.</source>
          <target state="translated">Загружает все задачи во все пути кода.</target>
        </trans-unit>
        <trans-unit id="1dbb1340da45613eb5e47a83d481795deec9b49b" translate="yes" xml:space="preserve">
          <source>Loads all tasks in the given &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">Загружает все задачи по указанным &lt;code&gt;paths&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b73d169b01f0a9c5dd68ce5c80ad0b78253a148" translate="yes" xml:space="preserve">
          <source>Loads and configures all registered apps.</source>
          <target state="translated">Загружает и настраивает все зарегистрированные приложения.</target>
        </trans-unit>
        <trans-unit id="6a92b205586e28caa29fbe576471eda29c1f626c" translate="yes" xml:space="preserve">
          <source>Loads and persists the given configuration.</source>
          <target state="translated">Загружает и сохраняет данную конфигурацию.</target>
        </trans-unit>
        <trans-unit id="d2d1c8786ab6d688901e2d0162afd3bc568f68c4" translate="yes" xml:space="preserve">
          <source>Loads configuration (typically during system boot).</source>
          <target state="translated">Загружает конфигурацию (обычно во время загрузки системы).</target>
        </trans-unit>
        <trans-unit id="0685e493c999d9e080786726a9b793b9cc769fbe" translate="yes" xml:space="preserve">
          <source>Loads the application and its dependencies paths.</source>
          <target state="translated">Загружает приложение и пути его зависимостей.</target>
        </trans-unit>
        <trans-unit id="d450693304ac525200ed85aa5542f49d5d24954d" translate="yes" xml:space="preserve">
          <source>Loads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">Загружает данное &lt;code&gt;app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fd578a7e27c9f4784b221dfd1d03ff6846abec8" translate="yes" xml:space="preserve">
          <source>Loads the given module's BEAM code (and ensures any previous old version was properly purged before).</source>
          <target state="translated">Загружает код BEAM данного модуля (и гарантирует,что любая предыдущая старая версия была правильно очищена).</target>
        </trans-unit>
        <trans-unit id="9e384585def890d25c96b1f4a34ccaee1ed94be4" translate="yes" xml:space="preserve">
          <source>Local dependencies (i.e. non-fetchable ones) are automatically recompiled every time the parent project is compiled.</source>
          <target state="translated">Локальные зависимости (т.е.не извлекаемые)автоматически перекомпилируются каждый раз при компиляции родительского проекта.</target>
        </trans-unit>
        <trans-unit id="e7dac36771b4d5bc036c611c2f7df6898fe52037" translate="yes" xml:space="preserve">
          <source>Local or imported functions, like &lt;code&gt;is_function/1&lt;/code&gt;, can be captured without the module:</source>
          <target state="translated">Локальные или импортированные функции, такие как &lt;code&gt;is_function/1&lt;/code&gt; , могут быть захвачены без модуля:</target>
        </trans-unit>
        <trans-unit id="432e91b2470debe1e676502753dc671697ff7218" translate="yes" xml:space="preserve">
          <source>Locates an executable on the system.</source>
          <target state="translated">Обнаруживает исполняемый файл в системе.</target>
        </trans-unit>
        <trans-unit id="e8a78f610457f7b34429c88bd804c091eff64c5b" translate="yes" xml:space="preserve">
          <source>Log Capture</source>
          <target state="translated">Захват журнала</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="e437244b86e77b12e48c1b63d73645f8df74961f" translate="yes" xml:space="preserve">
          <source>Logger allows developers to rewrite log messages provided by OTP applications into a format more compatible with Elixir log messages by providing a translator.</source>
          <target state="translated">Логгер позволяет разработчикам переписывать лог-сообщения,предоставляемые OTP-приложениями,в формат,более совместимый с лог-сообщениями Elixir,путем предоставления переводчика.</target>
        </trans-unit>
        <trans-unit id="36bf6b0f69a87a997107e50234a8ec7d11ea5aa8" translate="yes" xml:space="preserve">
          <source>Logger also allows log commands to be removed altogether via the &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; option (see below).</source>
          <target state="translated">Logger также позволяет полностью удалить команды журнала с помощью параметра &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="8a326883d3565753f9205b6be5a10ab0cd08e9df" translate="yes" xml:space="preserve">
          <source>Logger.Formatter</source>
          <target state="translated">Logger.Formatter</target>
        </trans-unit>
        <trans-unit id="c6794a4db89c0fa5b4754efb325fa721edd588e7" translate="yes" xml:space="preserve">
          <source>Logger.Translator</source>
          <target state="translated">Logger.Translator</target>
        </trans-unit>
        <trans-unit id="ca109e8fe3eb4c16a27a7e4635e900addd5e8cb0" translate="yes" xml:space="preserve">
          <source>Logging a message (string or iodata):</source>
          <target state="translated">Регистрация сообщения (строка или iodata):</target>
        </trans-unit>
        <trans-unit id="4791cfde57458131db6ad4f6f84effd24dfd10fe" translate="yes" xml:space="preserve">
          <source>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</source>
          <target state="translated">Ведение журнала полезно для отслеживания,когда в вашей системе происходит событие,представляющее интерес.Например,может быть полезно вести журнал всякий раз,когда пользователь удаляется.</target>
        </trans-unit>
        <trans-unit id="1deadf9242ff4446fca380a5ed4fc63d13e68620" translate="yes" xml:space="preserve">
          <source>Logs a alert message.</source>
          <target state="translated">Записывает предупреждающее сообщение.</target>
        </trans-unit>
        <trans-unit id="77f07031049dd01cb883823bd003f010766fb98e" translate="yes" xml:space="preserve">
          <source>Logs a critical message.</source>
          <target state="translated">Записывает критическое сообщение.</target>
        </trans-unit>
        <trans-unit id="d82e7897f57da03eff4b9dc774004c8bcf4326e9" translate="yes" xml:space="preserve">
          <source>Logs a debug message.</source>
          <target state="translated">Регистрирует отладочное сообщение.</target>
        </trans-unit>
        <trans-unit id="ec3ae95bdedeebd38a4944614cd25bc06633c042" translate="yes" xml:space="preserve">
          <source>Logs a emergency message.</source>
          <target state="translated">Записывает аварийное сообщение.</target>
        </trans-unit>
        <trans-unit id="fa35a8e5fcaecac8caac4e767a74fc390a160600" translate="yes" xml:space="preserve">
          <source>Logs a error message.</source>
          <target state="translated">Регистрирует сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="7c874de52b4d39e2e1de53a70efcaf18caaa4708" translate="yes" xml:space="preserve">
          <source>Logs a info message.</source>
          <target state="translated">Вход в информационное сообщение.</target>
        </trans-unit>
        <trans-unit id="b4f850d54fddb163d71bfcfbc339485cc6394592" translate="yes" xml:space="preserve">
          <source>Logs a message dynamically.</source>
          <target state="translated">Динамически регистрирует сообщение.</target>
        </trans-unit>
        <trans-unit id="06c091f6fe5aa4035d2433eb7a7a7cc257fb6374" translate="yes" xml:space="preserve">
          <source>Logs a message with the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">Регистрирует сообщение с заданным &lt;code&gt;level&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="420c25c0985bad40d128abfb9b86ebd0f486c510" translate="yes" xml:space="preserve">
          <source>Logs a notice message.</source>
          <target state="translated">Записывает сообщение об уведомлении.</target>
        </trans-unit>
        <trans-unit id="f285f97af4e85c90120c456b1bce9cedc8d1aeef" translate="yes" xml:space="preserve">
          <source>Logs a warning message.</source>
          <target state="translated">Записывает предупреждающее сообщение.</target>
        </trans-unit>
        <trans-unit id="a25a9314514d900aacc22fbb93de516450433e79" translate="yes" xml:space="preserve">
          <source>Logs an error message.</source>
          <target state="translated">Регистрирует сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="162237ff6bb976909c470a90784d4d60906673ae" translate="yes" xml:space="preserve">
          <source>Logs an info message.</source>
          <target state="translated">Регистрирует информационное сообщение.</target>
        </trans-unit>
        <trans-unit id="72bca69a37a582766cb9db5733429c69102e1391" translate="yes" xml:space="preserve">
          <source>Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation.</source>
          <target state="translated">Поиск,отправка и регистрация осуществляются эффективно и незамедлительно за счет задержек с отменой подписки.Например,в случае сбоя процесса его ключи автоматически удаляются из реестра,но изменение может распространиться не сразу.Это означает,что некоторые операции могут вернуть процессы,которые уже мертвы.Когда это может произойти,это будет явно указано в документации к функции.</target>
        </trans-unit>
        <trans-unit id="a76b17c2d110d14324113df51e0e794c11ea854e" translate="yes" xml:space="preserve">
          <source>Loops through recursion</source>
          <target state="translated">Петля через рекурсию</target>
        </trans-unit>
        <trans-unit id="ce14143dfcbe7563bba16cee9e6c1288ad57742d" translate="yes" xml:space="preserve">
          <source>Low-level function that parses one option.</source>
          <target state="translated">Низкоуровневая функция,которая анализирует один вариант.</target>
        </trans-unit>
        <trans-unit id="87c8129c4541d2520131c98fdc81bf241066a22c" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="translated">К счастью для нас, &lt;code&gt;use GenServer&lt;/code&gt; уже определяет &lt;code&gt;Stack.child_spec/1&lt;/code&gt; точно так же, как указано выше. Если вам нужно настроить &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , вы можете передать параметры напрямую, чтобы &lt;code&gt;use GenServer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e8fb2a57a7b8ddbc8b24f39765395e01d2d1bdb2" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="translated">К счастью для нас, &lt;code&gt;use GenServer&lt;/code&gt; уже определяет &lt;code&gt;Stack.child_spec/1&lt;/code&gt; точно так же, как указано выше. Если вам нужно настроить &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , вы можете передать параметры напрямую, чтобы &lt;code&gt;use GenServer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86ad4dfa78b62650b87ab367b0252fd1102bb2f8" translate="yes" xml:space="preserve">
          <source>Luckily, Elixir comes with the ability to package all of the code we have written so far into a single directory, that also includes Elixir and the Erlang Virtual Machine, that has a simple entry point and supports custom configuration. This feature is called releases and it provides many other benefits, which we will see next.</source>
          <target state="translated">К счастью,Elixir поставляется с возможностью упаковать весь код,который мы написали до сих пор в одну директорию,которая также включает в себя Elixir и виртуальную машину Erlang,которая имеет простую точку входа и поддерживает пользовательскую конфигурацию.Эта функция называется релизами,и она предоставляет много других преимуществ,которые мы увидим дальше.</target>
        </trans-unit>
        <trans-unit id="101e18c9daa819a9267241f7255d5c640b1be10f" translate="yes" xml:space="preserve">
          <source>Luckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags. We have already used the &lt;code&gt;:capture_log&lt;/code&gt; tag in the previous chapter, which has its semantics specified by ExUnit itself.</source>
          <target state="translated">К счастью, ExUnit поставляется с возможностью помечать тесты, что позволяет нам запускать определенные обратные вызовы или даже фильтровать тесты в целом на основе этих тегов. Мы уже использовали тег &lt;code&gt;:capture_log&lt;/code&gt; в предыдущей главе, семантика которого указана самим ExUnit.</target>
        </trans-unit>
        <trans-unit id="f6e05c123ace841510b2c0f0d5c37124c1c1ac0a" translate="yes" xml:space="preserve">
          <source>Luckily, comprehensions also support the &lt;code&gt;:reduce&lt;/code&gt; option, which would allow us to fuse both steps above into a single step:</source>
          <target state="translated">К счастью, понимание также поддерживает параметр &lt;code&gt;:reduce&lt;/code&gt; , который позволит нам объединить оба вышеуказанных шага в один шаг:</target>
        </trans-unit>
        <trans-unit id="9bf35e953e645f158229003437875eb9a242b162" translate="yes" xml:space="preserve">
          <source>Luckily, releases also provide runtime configuration, which we will see next.</source>
          <target state="translated">К счастью,релизы также предоставляют конфигурацию времени выполнения,которую мы увидим дальше.</target>
        </trans-unit>
        <trans-unit id="6a0e82f7ee7ffbbb6bfa830a8dab2a14c17f4f0b" translate="yes" xml:space="preserve">
          <source>Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of &lt;code&gt;[:hello]&lt;/code&gt;:</source>
          <target state="translated">К счастью, поскольку сервер находится под наблюдением супервизора, супервизор автоматически запустит новый с начальным стеком &lt;code&gt;[:hello]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="da945cd7b80c7fc643a9901f3920877667af55e2" translate="yes" xml:space="preserve">
          <source>Macro hygiene</source>
          <target state="translated">Макрогигиена</target>
        </trans-unit>
        <trans-unit id="5233ccb9ab0c07b3e0b3cdc52940cec0284d06af" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ярлык на основе &lt;a href=&quot;#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; для IEx.break! / 4 .</target>
        </trans-unit>
        <trans-unit id="d968e46fbcd656cb5ecfaafa8dee8956d86aa485" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ярлык на основе &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; для IEx.break! / 4 .</target>
        </trans-unit>
        <trans-unit id="7bc6dcd111ca7252229f4855c8539442f853483e" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ярлык на основе &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; для IEx.break! / 4 .</target>
        </trans-unit>
        <trans-unit id="56c6a3e6a300260cc21833777ce7d3713e7a1c93" translate="yes" xml:space="preserve">
          <source>Macro.Env</source>
          <target state="translated">Macro.Env</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="2deb7bcc40200f28604560fb6b4cce5afe26789d" translate="yes" xml:space="preserve">
          <source>Macros (local or remote)</source>
          <target state="translated">Макросы (локальные или удалённые)</target>
        </trans-unit>
        <trans-unit id="17db1c00f2577b6b0146445c282a04ec08ca8847" translate="yes" xml:space="preserve">
          <source>Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.</source>
          <target state="translated">Макросы представляют собой мощную конструкцию,и Elixir предоставляет множество механизмов,обеспечивающих их ответственное использование.</target>
        </trans-unit>
        <trans-unit id="ef424c7d55cc728523759a674154684c4f327b7f" translate="yes" xml:space="preserve">
          <source>Macros are also commonly used to implement custom sigils. To create a custom sigil, define a function with the name &lt;code&gt;sigil_{identifier}&lt;/code&gt; that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as &lt;code&gt;sigil_x&lt;/code&gt;) then the string argument will allow interpolation. If the sigil is upper case (such as &lt;code&gt;sigil_X&lt;/code&gt;) then the string will not be interpolated.</source>
          <target state="translated">Макросы также обычно используются для реализации специальных сигилов. Чтобы создать собственный сигил, определите функцию с именем &lt;code&gt;sigil_{identifier}&lt;/code&gt; которая принимает два аргумента. Первым аргументом будет строка, вторым - список символов, содержащий любые модификаторы. Если сигил в нижнем регистре (например, &lt;code&gt;sigil_x&lt;/code&gt; ), то строковый аргумент разрешает интерполяцию. Если сигил &lt;code&gt;sigil_X&lt;/code&gt; верхнем регистре (например, sigil_X ), то строка не будет интерполироваться.</target>
        </trans-unit>
        <trans-unit id="27ec1b0b3e3d4a112e7fe3bb95a5cd9f904ce5fc" translate="yes" xml:space="preserve">
          <source>Macros are compile-time constructs that are invoked with Elixir's AST as input and a superset of Elixir's AST as output.</source>
          <target state="translated">Макросы-это конструкции времени компиляции,которые вызываются с AST Эликсира в качестве входа и суперсет AST Эликсира в качестве выхода.</target>
        </trans-unit>
        <trans-unit id="00166ad41fa2f0b9c76fb59ee48021936b95d500" translate="yes" xml:space="preserve">
          <source>Macros are explicit: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.</source>
          <target state="translated">Макросы явно выражены:невозможно запустить макрос без явного обращения к нему.Например,некоторые языки позволяют разработчикам полностью переписывать функции за кулисами,часто с помощью трансформации разбора или некоторых механизмов отражения.В Elixir макрос должен быть явно вызван в вызывающем абоненте во время компиляции.</target>
        </trans-unit>
        <trans-unit id="e631dd92a600a70cff32b8106215cf69b67f9804" translate="yes" xml:space="preserve">
          <source>Macros are hygienic: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.</source>
          <target state="translated">Макросы гигиеничны:по умолчанию переменные,определенные внутри макроса,не будут влиять на код пользователя.Кроме того,вызовы функций и псевдонимы,доступные в макроконтексте,не будут утечканы в контекст пользователя.</target>
        </trans-unit>
        <trans-unit id="7c5ff8a95ca37f321e50193978d8305c5ccd794f" translate="yes" xml:space="preserve">
          <source>Macros are lexical: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the module that defines the macro.</source>
          <target state="translated">Макросы лексичны: глобально внедрить код или макросы невозможно. Чтобы использовать макрос, вам необходимо явно &lt;code&gt;require&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; модуль, который определяет макрос.</target>
        </trans-unit>
        <trans-unit id="78cdc77e6f4d92297e11673135be19d518a8e9cb" translate="yes" xml:space="preserve">
          <source>Macros cannot be overridden as functions and vice-versa.</source>
          <target state="translated">Макросы нельзя переопределить как функции и наоборот.</target>
        </trans-unit>
        <trans-unit id="c199f825b0b9d3f3318f2eda4ea955409324187c" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="translated">Макросы, составленные из любой комбинации вышеуказанных защитных устройств, также являются действительными &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt; - например, Integer.is_even / 1 . Для получения дополнительной информации см. Раздел &amp;laquo;Определение пользовательских выражений защиты&amp;raquo;, показанный ниже.</target>
        </trans-unit>
        <trans-unit id="46e2c2440131ab61167e8cad993833b1e1b2ca92" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="translated">Макросы, &lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt; из любой комбинации вышеуказанных защитных устройств, также являются действительными защитниками - например, Integer.is_even / 1 . Для получения дополнительной информации см. Раздел &amp;laquo;Определение пользовательских выражений защиты&amp;raquo;, показанный ниже.</target>
        </trans-unit>
        <trans-unit id="b376d89a5de38d7ee4620680cefcbdb63a1fa6c3" translate="yes" xml:space="preserve">
          <source>Macros in Elixir are defined via &lt;code&gt;defmacro/2&lt;/code&gt;.</source>
          <target state="translated">Макросы в &lt;code&gt;defmacro/2&lt;/code&gt; определяются через defmacro / 2 .</target>
        </trans-unit>
        <trans-unit id="8b493bc2b5a09e10063b11f52cb46148a75373e5" translate="yes" xml:space="preserve">
          <source>Macros must be defined before its usage.</source>
          <target state="translated">Макросы должны быть определены до их использования.</target>
        </trans-unit>
        <trans-unit id="f3a7dd931c836a0537e89bdd7c632c8f1674beb8" translate="yes" xml:space="preserve">
          <source>Macros receive quoted expressions and must return quoted expressions. However, sometimes during the execution of a macro, you may need to work with values and making a distinction between values and quoted expressions will be required.</source>
          <target state="translated">Макросы получают выражения в кавычках и должны возвращать выражения в кавычках.Однако иногда во время выполнения макроса может потребоваться работа со значениями,и потребуется провести различие между значениями и выражениями,заключенными в кавычки.</target>
        </trans-unit>
        <trans-unit id="1b8816a712333def9173d859165b24e9a1e3080d" translate="yes" xml:space="preserve">
          <source>Macros&amp;rsquo; language is clear: many languages provide syntax shortcuts for &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt;. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.</source>
          <target state="translated">Язык макросов ясен: многие языки предоставляют сокращения синтаксиса для &lt;code&gt;quote&lt;/code&gt; и &lt;code&gt;unquote&lt;/code&gt; . В Elixir мы предпочли, чтобы они были прописаны явно, чтобы четко разграничить границы определения макроса и его цитируемых выражений.</target>
        </trans-unit>
        <trans-unit id="38c7f5915403fb594e00a22038d846f701385048" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;server&lt;/code&gt; and waits for its reply.</source>
          <target state="translated">Совершает синхронный вызов &lt;code&gt;server&lt;/code&gt; и ожидает его ответа.</target>
        </trans-unit>
        <trans-unit id="d01394a676b90ea711ca71b9dfa799f50b31e6c1" translate="yes" xml:space="preserve">
          <source>Makes boot scripts.</source>
          <target state="translated">Делает скрипты загрузки.</target>
        </trans-unit>
        <trans-unit id="63d944684b8d8c1cbe7b41a5decc0950233badf7" translate="yes" xml:space="preserve">
          <source>Makes the &lt;code&gt;sys.config&lt;/code&gt; structure.</source>
          <target state="translated">Создает структуру &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ca136246f74496fc6eddff8b632654647bdfab" translate="yes" xml:space="preserve">
          <source>Makes the given functions in &lt;code&gt;module&lt;/code&gt; overridable.</source>
          <target state="translated">Делает данные функции в &lt;code&gt;module&lt;/code&gt; переопределяемыми.</target>
        </trans-unit>
        <trans-unit id="1d1d2f57486d38837141355b4d2874a9bddc93c3" translate="yes" xml:space="preserve">
          <source>Makes the given functions in the current module overridable.</source>
          <target state="translated">Делает данные функции в текущем модуле перезагрузочными.</target>
        </trans-unit>
        <trans-unit id="f520067303f9e8a9444961effdfbec09ca46a18f" translate="yes" xml:space="preserve">
          <source>Makes the start_erl.data file with the ERTS version and release versions.</source>
          <target state="translated">Делает файл start_erl.data с версией ERTS и версией release.</target>
        </trans-unit>
        <trans-unit id="dc0be1241754d06d600f6c1517dbc4ddf83878d3" translate="yes" xml:space="preserve">
          <source>Management scripts. Releases come with scripts to start, restart, connect to the running system remotely, execute RPC calls, run as daemon, run as a Windows service, and more.</source>
          <target state="translated">Скрипты управления.Выпускаются скрипты для запуска,перезагрузки,удаленного подключения к работающей системе,выполнения вызовов RPC,запуска в качестве демона,запуска в качестве службы Windows и многое другое.</target>
        </trans-unit>
        <trans-unit id="7fddc4eb9e8f75d21673b2839ad36111f23d7c3e" translate="yes" xml:space="preserve">
          <source>Manually implementing protocols for all types can quickly become repetitive and tedious. In such cases, Elixir provides two options: we can explicitly derive the protocol implementation for our types or automatically implement the protocol for all types. In both cases, we need to implement the protocol for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Внедрение протоколов для всех типов вручную может быстро стать однообразным и утомительным. В таких случаях Elixir предоставляет два варианта: мы можем явно определить реализацию протокола для наших типов или автоматически реализовать протокол для всех типов. В обоих случаях нам нужно реализовать протокол для &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d459cd939d93634c990e044cf24d22485f3ceefe" translate="yes" xml:space="preserve">
          <source>Manually it can be started as:</source>
          <target state="translated">Вручную его можно запустить как:</target>
        </trans-unit>
        <trans-unit id="c0e455aaea813fc20786176867857a89ebbb1b93" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="translated">Многие функции входят в пары, например &lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; вернет кортеж с успешным или неудачным результатом, тогда как &lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt; вернет простое значение или вызовет исключение:</target>
        </trans-unit>
        <trans-unit id="260e168370d5fc4a6827bad1c03fb6fbeedd23a4" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="translated">Многие функции входят в пары, например &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; вернет кортеж с успешным или неудачным результатом, тогда как &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt; вернет простое значение или вызовет исключение:</target>
        </trans-unit>
        <trans-unit id="df33d2958d307f1a594471fa7f01b0b82a2cb968" translate="yes" xml:space="preserve">
          <source>Many functions for maps, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Многие функции для карт, которые реализуют протокол &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , находятся в модуле &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; . Кроме того, в &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; следующие функции для карт :</target>
        </trans-unit>
        <trans-unit id="27ff6822734db6cb62b200fe4ffc5f764d2dde53" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">Многие функции в модуле &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; требуют базы данных часовых поясов. По умолчанию он использует базу данных часовых поясов по умолчанию, возвращаемую &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; , которая по умолчанию - &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; ,&lt;/a&gt; которая обрабатывает только даты в формате Etc / UTC и возвращает &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; для любого другого часового пояса.</target>
        </trans-unit>
        <trans-unit id="ad947ef91255ef33c3330d92501cc4ddd6db30bf" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">Многие функции в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; требуют базы данных часовых поясов. По умолчанию он использует базу данных часовых поясов по умолчанию, возвращаемую &lt;a href=&quot;#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; , которая по умолчанию - &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; ,&lt;/a&gt; которая обрабатывает только даты в формате Etc / UTC и возвращает &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; для любого другого часового пояса.</target>
        </trans-unit>
        <trans-unit id="4225573b276c588447af042b7625b6428887292b" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;code&gt;Stream&lt;/code&gt; module accept any enumerable as an argument and return a stream as a result. It also provides functions for creating streams. For example, &lt;code&gt;Stream.cycle/1&lt;/code&gt; can be used to create a stream that cycles a given enumerable infinitely. Be careful to not call a function like &lt;code&gt;Enum.map/2&lt;/code&gt; on such streams, as they would cycle forever:</source>
          <target state="translated">Многие функции в модуле &lt;code&gt;Stream&lt;/code&gt; принимают любое перечислимое значение в качестве аргумента и в результате возвращают поток. Он также предоставляет функции для создания потоков. Например, &lt;code&gt;Stream.cycle/1&lt;/code&gt; можно использовать для создания потока, который бесконечно циклирует заданное перечислимое число. Будьте осторожны, чтобы не вызывать функцию типа &lt;code&gt;Enum.map/2&lt;/code&gt; в таких потоках, поскольку они будут циклически повторяться бесконечно:</target>
        </trans-unit>
        <trans-unit id="76056aa626b027c1c23fdbd95796d51843ce0c06" translate="yes" xml:space="preserve">
          <source>Many functions in the standard library follow the pattern of having a counterpart that raises an exception instead of returning tuples to match against. The convention is to create a function (&lt;code&gt;foo&lt;/code&gt;) which returns &lt;code&gt;{:ok, result}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; tuples and another function (&lt;code&gt;foo!&lt;/code&gt;, same name but with a trailing &lt;code&gt;!&lt;/code&gt;) that takes the same arguments as &lt;code&gt;foo&lt;/code&gt; but which raises an exception if there&amp;rsquo;s an error. &lt;code&gt;foo!&lt;/code&gt; should return the result (not wrapped in a tuple) if everything goes fine. The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt; module&lt;/a&gt; is a good example of this convention.</source>
          <target state="translated">Многие функции в стандартной библиотеке следуют шаблону наличия аналога, который вызывает исключение вместо того, чтобы возвращать кортежи для сопоставления. По соглашению создается функция ( &lt;code&gt;foo&lt;/code&gt; ), которая возвращает кортежи &lt;code&gt;{:ok, result}&lt;/code&gt; или &lt;code&gt;{:error, reason}&lt;/code&gt; и другую функцию ( &lt;code&gt;foo!&lt;/code&gt; ,То же имя, но с завершающим &lt;code&gt;!&lt;/code&gt; ), Которая принимает те же аргументы, что и &lt;code&gt;foo&lt;/code&gt; , но которая вызывает исключение, если есть ошибка. &lt;code&gt;foo!&lt;/code&gt; должен возвращать результат (не заключенный в кортеж), если все идет нормально. &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; модуль&lt;/a&gt; является хорошим примером этой конвенции.</target>
        </trans-unit>
        <trans-unit id="3703d2917265895ef0ac89964db0000551fe6a21" translate="yes" xml:space="preserve">
          <source>Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides &lt;code&gt;:stdio&lt;/code&gt; and &lt;code&gt;:stderr&lt;/code&gt; as shortcuts to Erlang's &lt;code&gt;:standard_io&lt;/code&gt; and &lt;code&gt;:standard_error&lt;/code&gt;.</source>
          <target state="translated">Многие функции в этом модуле ожидают в качестве аргумента устройство ввода-вывода. Устройство ввода-вывода должно быть PID или атомом, представляющим процесс. Для удобства Elixir предоставляет &lt;code&gt;:stdio&lt;/code&gt; и &lt;code&gt;:stderr&lt;/code&gt; как ярлыки для Erlang's &lt;code&gt;:standard_io&lt;/code&gt; и &lt;code&gt;:standard_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f2d10ee74f910ee80e0d898322396bd24b9b002" translate="yes" xml:space="preserve">
          <source>Many functions in this module handle what to capture in a regex match via the &lt;code&gt;:capture&lt;/code&gt; option. The supported values are:</source>
          <target state="translated">Многие функции в этом модуле обрабатывают то, что нужно захватить при совпадении регулярного выражения, с помощью параметра &lt;code&gt;:capture&lt;/code&gt; . Поддерживаемые значения:</target>
        </trans-unit>
        <trans-unit id="d206ef06c5b999d69bec023c3ecff2ae2d89ff16" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">Многие функции этого модуля требуют базы данных часовых поясов. По умолчанию он использует базу данных часовых поясов по умолчанию, возвращаемую &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; , которая по умолчанию - &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; ,&lt;/a&gt; которая обрабатывает только даты в формате Etc / UTC и возвращает &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; для любого другого часового пояса.</target>
        </trans-unit>
        <trans-unit id="d4dd6fb3c009dd1400eb7be40f23b4fda3b4e022" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">Многие функции этого модуля требуют базы данных часовых поясов. По умолчанию он использует базу данных часовых поясов по умолчанию, возвращаемую &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; , которая по умолчанию - &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; ,&lt;/a&gt; которая обрабатывает только даты в формате Etc / UTC и возвращает &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; для любого другого часового пояса.</target>
        </trans-unit>
        <trans-unit id="0260e8c22bbeb10fe3ca38f76f4ac2485f643f27" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;String.split/3&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="translated">Многие функции в этом модуле работают с шаблонами. Например, &lt;a href=&quot;#split/3&quot;&gt; &lt;code&gt;String.split/3&lt;/code&gt; &lt;/a&gt; может разбить строку на несколько строк по шаблону. Этот шаблон может быть строкой, списком строк или скомпилированным шаблоном:</target>
        </trans-unit>
        <trans-unit id="94392a82be4b05528cead70b8bc5d289f9e18ce9" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;string#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="translated">Многие функции в этом модуле работают с шаблонами. Например, &lt;a href=&quot;string#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt; может разбить строку на несколько строк по шаблону. Этот шаблон может быть строкой, списком строк или скомпилированным шаблоном:</target>
        </trans-unit>
        <trans-unit id="90b7eedb69a34d71ed449486b5fd918febba2efc" translate="yes" xml:space="preserve">
          <source>Many modules share the same public API. Take a look at &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;, which, as its description states, is a &lt;strong&gt;specification&lt;/strong&gt; for composable modules in web applications. Each &lt;em&gt;plug&lt;/em&gt; is a module which &lt;strong&gt;has to&lt;/strong&gt; implement at least two public functions: &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;.</source>
          <target state="translated">Многие модули используют один и тот же общедоступный API. Взгляните на &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt; , который, как указано в его описании, является &lt;strong&gt;спецификацией&lt;/strong&gt; для составных модулей в веб-приложениях. Каждый &lt;em&gt;плагин&lt;/em&gt; - это модуль, который &lt;strong&gt;должен&lt;/strong&gt; реализовывать как минимум две публичные функции: &lt;code&gt;init/1&lt;/code&gt; и &lt;code&gt;call/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bad4be1f2158b40250d3557f87cd91435ba7e8c" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok, value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Многие функции, определенные в модуле &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; ,&lt;/a&gt; вызывают эту функцию изнутри. Эта функция также используется, когда используется синтаксис доступа в квадратных скобках ( &lt;code&gt;structure[key]&lt;/code&gt; ): вызывается обратный вызов &lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; ,&lt;/a&gt; реализованный модулем, который определяет &lt;code&gt;structure&lt;/code&gt; struct, и если он возвращает &lt;code&gt;{:ok, value}&lt;/code&gt; тогда &lt;code&gt;value&lt;/code&gt; равно возвращается, или, если он возвращает &lt;code&gt;:error&lt;/code&gt; , тогда возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4ca56f0d69fbdc55846e32a022e68f99af15e8" translate="yes" xml:space="preserve">
          <source>Many of the functions in the &lt;code&gt;Macro&lt;/code&gt; module expect an environment. You can read more about these functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;the docs for the &lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt; and learn more about the compilation environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;docs for &lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Многие функции в модуле &lt;code&gt;Macro&lt;/code&gt; ожидают окружения. Вы можете узнать больше об этих функциях в &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;документации для модуля &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt; и узнать больше о среде компиляции в &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;документации для &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4faffc8eead5983ad100523dbff786e387103bd2" translate="yes" xml:space="preserve">
          <source>Many of the functions provided for lists, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Многие функции, предоставляемые для списков, которые реализуют протокол &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , находятся в модуле &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa5e426d610f0d4aaac317eed422e316664919b2" translate="yes" xml:space="preserve">
          <source>Many of those can be used in guards; consult the &lt;a href=&quot;patterns-and-guards#list-of-allowed-functions-and-operators&quot;&gt;list of allowed guard functions and operators&lt;/a&gt;.</source>
          <target state="translated">Многие из них могут быть использованы в охране; ознакомьтесь со &lt;a href=&quot;patterns-and-guards#list-of-allowed-functions-and-operators&quot;&gt;списком разрешенных функций и операторов защиты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be6b19c2b27acff99f70a4437bfc926f0a1ca658" translate="yes" xml:space="preserve">
          <source>Many options can be given by using &lt;code&gt;-&lt;/code&gt; as separator. Order is arbitrary, so the following are all equivalent:</source>
          <target state="translated">Многие параметры можно указать, используя &lt;code&gt;-&lt;/code&gt; в качестве разделителя. Порядок может быть произвольным, поэтому все следующие варианты эквивалентны:</target>
        </trans-unit>
        <trans-unit id="330c1202fe630194f41c59eea84f6ea0bc1f1fd0" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">Во многих случаях проверка структуры может быть реализована в зависимости от существующих сущностей. Например, здесь &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; &amp;laquo;s &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt; реализации:</target>
        </trans-unit>
        <trans-unit id="76b2e23669853bc8630b7ea68a605ae31ce73aeb" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">Во многих случаях проверка структуры может быть реализована в функции существующих сущностей. Например, здесь &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; &amp;laquo;s &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt; реализации:</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c31339a8063fd1ca05b6a5ed0e592c82381795d2" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;enum#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Карта / словарь как второй аргумент в &lt;a href=&quot;enum#group_by/3&quot;&gt; &lt;code&gt;Enum.group_by/3&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea310bdd1d4cb6664bd2860f16abce50b8e7ac8b" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Карта / словарь как второй аргумент в &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#group_by/3&quot;&gt; &lt;code&gt;Enum.group_by/3&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f349d9040ff8d6dc02443f2129355396470884e" translate="yes" xml:space="preserve">
          <source>MapSet</source>
          <target state="translated">MapSet</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="faaabe818891c225544bd509dabd125356710ead" translate="yes" xml:space="preserve">
          <source>Maps allow any value as a key.</source>
          <target state="translated">Карты допускают любое значение в качестве ключа.</target>
        </trans-unit>
        <trans-unit id="7dc037a00a16f714fab195785c4e6e9d7695f9d0" translate="yes" xml:space="preserve">
          <source>Maps also implement the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, so many functions to work with maps are found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Карты также реализуют протокол &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; , поэтому многие функции для работы с картами находятся в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; . Кроме того, в &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; следующие функции для карт :</target>
        </trans-unit>
        <trans-unit id="d7aa9999474ccd32fc79bec268d52ee73d62bb49" translate="yes" xml:space="preserve">
          <source>Maps also support a specific update syntax to update the value stored under &lt;em&gt;existing&lt;/em&gt; atom keys:</source>
          <target state="translated">Карты также поддерживают особый синтаксис обновления для обновления значения, хранящегося в &lt;em&gt;существующих&lt;/em&gt; ключах атома:</target>
        </trans-unit>
        <trans-unit id="4f807f1c0861c6353d131aaf6d1b3433f38ae0fe" translate="yes" xml:space="preserve">
          <source>Maps and intersperses the given enumerable in one pass.</source>
          <target state="translated">Карты и перечисляются за один проход.</target>
        </trans-unit>
        <trans-unit id="23b5fbc085bbfa528c48b36100e97092a1cc1ad4" translate="yes" xml:space="preserve">
          <source>Maps and joins the given &lt;code&gt;enumerable&lt;/code&gt; in one pass.</source>
          <target state="translated">Отображает и объединяет данное &lt;code&gt;enumerable&lt;/code&gt; за один проход.</target>
        </trans-unit>
        <trans-unit id="5099fc13865ed694619ef238561f1ff1eb21e4ca" translate="yes" xml:space="preserve">
          <source>Maps and keyword lists</source>
          <target state="translated">Карты и списки ключевых слов</target>
        </trans-unit>
        <trans-unit id="382a893f2fca3eb55b96aa13fc13acceacd045d1" translate="yes" xml:space="preserve">
          <source>Maps and reduces an &lt;code&gt;enumerable&lt;/code&gt;, flattening the given results (only one level deep).</source>
          <target state="translated">Отображает и сокращает &lt;code&gt;enumerable&lt;/code&gt; , сглаживая полученные результаты (только на один уровень в глубину).</target>
        </trans-unit>
        <trans-unit id="f6cdae6c2a90bda1af5114211ccb41e8558a58da" translate="yes" xml:space="preserve">
          <source>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats.</source>
          <target state="translated">Карты сравниваются по размеру,затем по клавишам в порядке возрастания,затем по значениям в порядке возрастания.В конкретном случае порядка следования ключей карт,целые числа всегда считаются меньше плавающих.</target>
        </trans-unit>
        <trans-unit id="8c98c45a1d23b0146ef1d00e97519c4b3c41bb31" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir.</source>
          <target state="translated">Карты-это структура данных &quot;go to&quot; (перейти к)ключевого значения в Elixir.</target>
        </trans-unit>
        <trans-unit id="2c58aeb4eaddeb4b19dfc3e5c22984c273b6c491" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="translated">Карты - это структура данных &quot;ключ-значение&quot; в Elixir. Карты могут быть созданы с использованием синтаксиса &lt;code&gt;%{}&lt;/code&gt; , а пары ключ-значение могут быть выражены как &lt;code&gt;key =&amp;gt; value&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="70c51c829f32f40117be9c91f009f5fddc39b569" translate="yes" xml:space="preserve">
          <source>Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="translated">Карты могут быть созданы с использованием синтаксиса &lt;code&gt;%{}&lt;/code&gt; , а пары ключ-значение могут быть выражены как &lt;code&gt;key =&amp;gt; value&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c8f244270ac78647558651f3076ad4902cf12b49" translate="yes" xml:space="preserve">
          <source>Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.</source>
          <target state="translated">Карты могут быть сопоставлены по шаблону.Когда карта находится на левой стороне совмещения деталей,она будет совпадать,если на карте справа находятся клавиши с левой стороны,а их значения совпадают с значениями слева.Это означает,что пустая карта соответствует каждой карте.</target>
        </trans-unit>
        <trans-unit id="2f34883281b6a723f6b44b386e5d7882db692c68" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="translated">Карты не накладывают никаких ограничений на тип ключа: ключом на карте может быть что угодно. В качестве структуры &quot;ключ-значение&quot; карты не допускают дублирования ключей. Ключи сравниваются с помощью оператора точного равенства ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; ). Если конфликтующие ключи определены в литерале карты, последний из них имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="4bdce2ba7f6c277727a64d1e4440d7e5012f407e" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="translated">Карты не накладывают никаких ограничений на тип ключа: ключом на карте может быть что угодно. В качестве структуры &quot;ключ-значение&quot; карты не допускают дублирования ключей. Ключи сравниваются с помощью оператора точного равенства ( &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; ). Если конфликтующие ключи определены в литерале карты, последний из них имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="bd2672e5330a5447b3c12c9d7516bbd11a97aa64" translate="yes" xml:space="preserve">
          <source>Maps have the following syntax for updating a key&amp;rsquo;s value:</source>
          <target state="translated">Карты имеют следующий синтаксис для обновления значения ключа:</target>
        </trans-unit>
        <trans-unit id="df4d74f64dad54de9172b6ef5d50d38fbf79035b" translate="yes" xml:space="preserve">
          <source>Maps may appear in patterns using the percentage sign followed by the curly brackets syntax (&lt;code&gt;%{}&lt;/code&gt;). Opposite to lists and tuples, maps perform a subset match. This means a map pattern will match any other map that has at least all of the keys in the pattern.</source>
          <target state="translated">Карты могут появляться в шаблонах с использованием знака процента, за которым следует синтаксис фигурных скобок ( &lt;code&gt;%{}&lt;/code&gt; ). В отличие от списков и кортежей, карты выполняют сопоставление подмножеств. Это означает, что шаблон карты будет соответствовать любой другой карте, которая имеет по крайней мере все ключи в шаблоне.</target>
        </trans-unit>
        <trans-unit id="b18104f0603d252465f48bc07dbe82afd8a5d572" translate="yes" xml:space="preserve">
          <source>Maps the given &lt;code&gt;fun&lt;/code&gt; over &lt;code&gt;enumerable&lt;/code&gt; and flattens the result.</source>
          <target state="translated">Сопоставляет данное &lt;code&gt;fun&lt;/code&gt; с &lt;code&gt;enumerable&lt;/code&gt; и сглаживает результат.</target>
        </trans-unit>
        <trans-unit id="5204e90c54387d7f6b5371b939a57cc337fb682b" translate="yes" xml:space="preserve">
          <source>Maps use the &lt;code&gt;%{...}&lt;/code&gt; notation and each key-value is given by pairs marked with &lt;code&gt;=&amp;gt;&lt;/code&gt;, such as &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt;.</source>
          <target state="translated">Карты используют нотацию &lt;code&gt;%{...}&lt;/code&gt; и каждая пара &quot;ключ-значение&quot; задается парами, отмеченными знаком &lt;code&gt;=&amp;gt;&lt;/code&gt; , например &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b30399c385e93b1607671f629e3c17811777473" translate="yes" xml:space="preserve">
          <source>Maps&amp;rsquo; keys do not follow any ordering.</source>
          <target state="translated">Ключи карт не упорядочены.</target>
        </trans-unit>
        <trans-unit id="23e67fceae0d77dd571dd25695fc0499faf1bb77" translate="yes" xml:space="preserve">
          <source>Markdown</source>
          <target state="translated">Markdown</target>
        </trans-unit>
        <trans-unit id="ec2d3f7496eeae736a17fb6cfbbc3d6cec0ede8f" translate="yes" xml:space="preserve">
          <source>Markdown uses backticks (&lt;code&gt;`&lt;/code&gt;) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called &lt;code&gt;MyApp.Hello&lt;/code&gt;, always reference it as &lt;code&gt;`MyApp.Hello`&lt;/code&gt; and never as &lt;code&gt;`Hello`&lt;/code&gt;.</source>
          <target state="translated">Markdown использует обратные кавычки ( &lt;code&gt;`&lt;/code&gt; ) для цитирования кода. Elixir строится поверх этого, чтобы автоматически генерировать ссылки при обращении к именам модулей или функций. По этой причине всегда используйте полные имена модулей. Если у вас есть модуль &lt;code&gt;MyApp.Hello&lt;/code&gt; , всегда указывайте его как &lt;code&gt;`MyApp.Hello`&lt;/code&gt; а не как &lt;code&gt;`Hello`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217f8bccae9fba9687ba7ff03998f906b2857c1d" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;eex.syntaxerror&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Маркеры &lt;code&gt;&quot;/&quot;&lt;/code&gt; и &lt;code&gt;&quot;|&quot;&lt;/code&gt; предназначены только для использования в пользовательских механизмах EEx и не реализованы по умолчанию. &lt;a href=&quot;eex.syntaxerror&quot;&gt; &lt;code&gt;EEx.SyntaxError&lt;/code&gt; &lt;/a&gt; использование без соответствующей реализации вызывает ошибку EEx.SyntaxError .</target>
        </trans-unit>
        <trans-unit id="afbf70382126809dcc83d5a0baa9b100761627b8" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;https://hexdocs.pm/eex/EEx.SyntaxError.html&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Маркеры &lt;code&gt;&quot;/&quot;&lt;/code&gt; и &lt;code&gt;&quot;|&quot;&lt;/code&gt; предназначены только для использования в пользовательских механизмах EEx и не реализованы по умолчанию. &lt;a href=&quot;https://hexdocs.pm/eex/EEx.SyntaxError.html&quot;&gt; &lt;code&gt;EEx.SyntaxError&lt;/code&gt; &lt;/a&gt; использование без соответствующей реализации вызывает ошибку EEx.SyntaxError .</target>
        </trans-unit>
        <trans-unit id="caae004dd7762602ee13f32c3606f690c674cc52" translate="yes" xml:space="preserve">
          <source>Marks if the system should halt or not at the end of ARGV processing.</source>
          <target state="translated">Обозначает,должна ли система останавливаться или нет в конце обработки ARGV.</target>
        </trans-unit>
        <trans-unit id="daa3ede97b95d72b81888db9393f9e1bcea3ccac" translate="yes" xml:space="preserve">
          <source>Marks that the given variable should not be hygienized.</source>
          <target state="translated">Отметит,что данная переменная не должна быть гигиенизирована.</target>
        </trans-unit>
        <trans-unit id="e8df966767fbd3a383c53216799beb4b4564cb74" translate="yes" xml:space="preserve">
          <source>Mastering Markdown</source>
          <target state="translated">Мастерская уценка</target>
        </trans-unit>
        <trans-unit id="85919633d0c1a681dd648ed32addd8fdbee372f3" translate="yes" xml:space="preserve">
          <source>Match operator. Matches the value on the right against the pattern on the left.</source>
          <target state="translated">Матч-оператор.Сопоставляет значение справа с образцом слева.</target>
        </trans-unit>
        <trans-unit id="158acb8638a5ae524e2b6bf247590e2b87f6ec4d" translate="yes" xml:space="preserve">
          <source>MatchError</source>
          <target state="translated">MatchError</target>
        </trans-unit>
        <trans-unit id="96751a5eacdf747401e9907e7e83faf6f1a03e3b" translate="yes" xml:space="preserve">
          <source>MatchError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">MatchError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="2d84b42f8474be5f06fc1fe6eb6ae40c8a64822a" translate="yes" xml:space="preserve">
          <source>Matches on or builds a struct.</source>
          <target state="translated">Сопоставляет или строит структуру.</target>
        </trans-unit>
        <trans-unit id="d1c12ec871d541a72434054efa8076c09aed8fb5" translate="yes" xml:space="preserve">
          <source>Matches the given expression against the given clauses.</source>
          <target state="translated">Соответствует данному выражению в сравнении с данными пунктами.</target>
        </trans-unit>
        <trans-unit id="8b76a5c96001ffefea3cc84097a4d45e79f04e10" translate="yes" xml:space="preserve">
          <source>Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">Сопоставляет термин &lt;code&gt;left&lt;/code&gt; с регулярным выражением или строкой &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213cb6a13e45b535bfa6e1acc183ec880d53557f" translate="yes" xml:space="preserve">
          <source>Matches the value on the right against the pattern on the left.</source>
          <target state="translated">Сопоставляет значение справа с образцом слева.</target>
        </trans-unit>
        <trans-unit id="e5c433e838d8cf469d6f4b86a0a4976ce8db4a93" translate="yes" xml:space="preserve">
          <source>Matching &lt;code&gt;x&lt;/code&gt; against 2 would raise:</source>
          <target state="translated">Сопоставление &lt;code&gt;x&lt;/code&gt; против 2 повысит:</target>
        </trans-unit>
        <trans-unit id="b35bb5e881268b8de9b651fa2e51e3623ab167b7" translate="yes" xml:space="preserve">
          <source>Mechanism for handling behaviours.</source>
          <target state="translated">Механизм обращения с поведением.</target>
        </trans-unit>
        <trans-unit id="b873cd45985fe1c621dd194bc36973e23339f383" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="translated">Членство проверяется оператором соответствия ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f436c24ccfa651b93064f0d2e54084d164dc06e" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="translated">Членство проверяется оператором соответствия ( &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9184827d2046a26e76cbe3bdb691f2ddb10c2fb1" translate="yes" xml:space="preserve">
          <source>Membership operator. Checks if the element on the left-hand side is a member of the collection on the right-hand side.</source>
          <target state="translated">Членский оператор.Проверяет,если элемент с левой стороны является членом коллекции с правой стороны.</target>
        </trans-unit>
        <trans-unit id="d89ba7d209c7ddc88fd31bf2598cbf585fb0aa81" translate="yes" xml:space="preserve">
          <source>Merges two URIs.</source>
          <target state="translated">Соединяет два URI.</target>
        </trans-unit>
        <trans-unit id="4069e43ecbf8943679ac63e2d6e02de8e6a7137b" translate="yes" xml:space="preserve">
          <source>Merges two configurations.</source>
          <target state="translated">Объединяет две конфигурации.</target>
        </trans-unit>
        <trans-unit id="a9fa5b094d178e27f7bd2a2b568ea8b694678d55" translate="yes" xml:space="preserve">
          <source>Merges two keyword lists into one.</source>
          <target state="translated">Соединяет два списка ключевых слов в один.</target>
        </trans-unit>
        <trans-unit id="acf0cf4f2e4c966874470b9f049a43c211b544d9" translate="yes" xml:space="preserve">
          <source>Merges two maps into one, resolving conflicts through the given &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Объединяет две карты в одну, разрешая конфликты с помощью данной &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="472d94b64a8f716f1678ee270e1d1c87f01b9840" translate="yes" xml:space="preserve">
          <source>Merges two maps into one.</source>
          <target state="translated">Соединяет две карты в одну.</target>
        </trans-unit>
        <trans-unit id="243261baef2add3b3b97656268303e291d4fa8b4" translate="yes" xml:space="preserve">
          <source>Message and function APIs</source>
          <target state="translated">API сообщений и функций</target>
        </trans-unit>
        <trans-unit id="62a587d636afdda61a08b5027d8d771633fc5216" translate="yes" xml:space="preserve">
          <source>Message format</source>
          <target state="translated">Формат сообщения</target>
        </trans-unit>
        <trans-unit id="7d9a0f1c2be58d1d8ee9acd43a53bc9fde228a1e" translate="yes" xml:space="preserve">
          <source>Meta-programming</source>
          <target state="translated">Meta-programming</target>
        </trans-unit>
        <trans-unit id="9ce697e52d7e466c89411bf1535cdf6ff43e22f1" translate="yes" xml:space="preserve">
          <source>Meta-programming guide</source>
          <target state="translated">Руководство по мета-программированию</target>
        </trans-unit>
        <trans-unit id="fa22e0676cd79851be85b6434a7e6e08111fa009" translate="yes" xml:space="preserve">
          <source>Meta-programming in Elixir</source>
          <target state="translated">Мета-программирование в Эликсире</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7f0cf2cb1796c66f262f9ca3a16a007623f8614c" translate="yes" xml:space="preserve">
          <source>Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.</source>
          <target state="translated">Метаданные могут иметь любой ключ.Инструменты документирования часто используют метаданные,чтобы предоставить больше данных читателям и обогатить пользовательский опыт.</target>
        </trans-unit>
        <trans-unit id="2d84d1f82b3284c403ade0a511b9ae944c022317" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="translated">Метаданные, отправляемые в регистратор, могут быть прочитаны и записаны с помощью &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/0&quot;&gt; &lt;code&gt;Logger.metadata/0&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt; . Например, вы можете установить &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; для добавления метаданных user_id к текущему процессу. Пользователь может настроить серверную часть, чтобы выбрать, какие метаданные он хочет распечатать, и это заменит значение &lt;code&gt;$metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae75c0cef5625d04c957fd4d6945de2e3cb52281" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;logger#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="translated">Метаданные, отправляемые в регистратор, можно прочитать и записать с помощью &lt;a href=&quot;logger#metadata/0&quot;&gt; &lt;code&gt;Logger.metadata/0&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt; . Например, вы можете установить &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; для добавления метаданных user_id к текущему процессу. Пользователь может настроить серверную часть, чтобы выбрать, какие метаданные он хочет распечатать, и это заменит значение &lt;code&gt;$metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6e66778ed96781c28086fcc3541fc2af93e8299" translate="yes" xml:space="preserve">
          <source>Microseconds &lt;em&gt;(does not support width and padding modifiers)&lt;/em&gt;</source>
          <target state="translated">Микросекунды &lt;em&gt;(не поддерживает модификаторы ширины и заполнения)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="996eccb481568235d0a028deddc16efa49e5113a" translate="yes" xml:space="preserve">
          <source>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</source>
          <target state="translated">Микросекунды также могут быть даны с точностью,которая должна быть целым числом от 0 до 6.</target>
        </trans-unit>
        <trans-unit id="dfde79a8eeb31b646662fce17bc79e76db2d4ad1" translate="yes" xml:space="preserve">
          <source>Microseconds with stored precision.</source>
          <target state="translated">Микросекунды с сохраненной точностью.</target>
        </trans-unit>
        <trans-unit id="ae8f2632075078189571124ccbd2fa14d6202a8b" translate="yes" xml:space="preserve">
          <source>Migrating from &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="translated">Переход с &lt;code&gt;use Mix.Config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e092faa3e25342ecf5028acae902f24fdcd4cfc" translate="yes" xml:space="preserve">
          <source>Migrating from Supervisor's :simple_one_for_one</source>
          <target state="translated">Переход от супервизора :simple_one_for_one</target>
        </trans-unit>
        <trans-unit id="c1335d3e7a03c5a9cce93a720fba00fd5265fb99" translate="yes" xml:space="preserve">
          <source>Minute</source>
          <target state="translated">Minute</target>
        </trans-unit>
        <trans-unit id="c92a133e8e92ffcf0c9578a6d4506ea98170ba24" translate="yes" xml:space="preserve">
          <source>Mirrors</source>
          <target state="translated">Mirrors</target>
        </trans-unit>
        <trans-unit id="119fff5ad66da150ab8b91c4f195f7205786f58d" translate="yes" xml:space="preserve">
          <source>Missing parent directories are created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">Создаются отсутствующие родительские каталоги. Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха или &lt;code&gt;{:error, reason}&lt;/code&gt; случае ошибки.</target>
        </trans-unit>
        <trans-unit id="9e60798bf941d9439890dc6ea1e2b3874b037fa8" translate="yes" xml:space="preserve">
          <source>Missing parent directories are not created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">Отсутствующие родительские каталоги не создаются. Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха или &lt;code&gt;{:error, reason}&lt;/code&gt; случае ошибки.</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="8a48b8da8f54401b98b40a13634225508f5d8cd7" translate="yes" xml:space="preserve">
          <source>Mix Tasks</source>
          <target state="translated">Микс-задачи</target>
        </trans-unit>
        <trans-unit id="adf80b3737e1d992babad11068b089417997b0c6" translate="yes" xml:space="preserve">
          <source>Mix also falls back to the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; and &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variables when storing its contents and configuration.</source>
          <target state="translated">Mix также возвращается к переменным среды &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; и &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; при сохранении своего содержимого и конфигурации.</target>
        </trans-unit>
        <trans-unit id="fad17235fd472ad3a611eb5939096f52cba44598" translate="yes" xml:space="preserve">
          <source>Mix also generated a file named &lt;code&gt;test/test_helper.exs&lt;/code&gt; which is responsible for setting up the test framework:</source>
          <target state="translated">Mix также сгенерировал файл с именем &lt;code&gt;test/test_helper.exs&lt;/code&gt; , который отвечает за настройку тестовой среды:</target>
        </trans-unit>
        <trans-unit id="d5f417a1b2c5b2cf642913e1126e746153ac794c" translate="yes" xml:space="preserve">
          <source>Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; file in the &lt;code&gt;test&lt;/code&gt; directory for each file in the &lt;code&gt;lib&lt;/code&gt; directory. For this reason, we can already find a &lt;code&gt;test/kv_test.exs&lt;/code&gt; corresponding to our &lt;code&gt;lib/kv.ex&lt;/code&gt; file. It doesn&amp;rsquo;t do much at this point:</source>
          <target state="translated">Mix также сгенерировал подходящую структуру для запуска тестов нашего проекта. Проекты Mix обычно следуют соглашению о наличии &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; в каталоге &lt;code&gt;test&lt;/code&gt; для каждого файла в каталоге &lt;code&gt;lib&lt;/code&gt; . По этой причине мы уже можем найти &lt;code&gt;test/kv_test.exs&lt;/code&gt; , соответствующий нашему файлу &lt;code&gt;lib/kv.ex&lt;/code&gt; .На данный момент это не так много:</target>
        </trans-unit>
        <trans-unit id="e787071e1565ddba8a2e537f8771328f0ffb3a18" translate="yes" xml:space="preserve">
          <source>Mix also generates a file at &lt;code&gt;lib/kv.ex&lt;/code&gt; with a module containing exactly one function, called &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">Mix также создает файл в &lt;code&gt;lib/kv.ex&lt;/code&gt; с модулем, содержащим ровно одну функцию, называемую &lt;code&gt;hello&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="71bacf97d94e38a4255175d63dd82250400f8cac" translate="yes" xml:space="preserve">
          <source>Mix also manages your dependencies and integrates nicely with the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex package manager&lt;/a&gt;.</source>
          <target state="translated">Mix также управляет вашими зависимостями и прекрасно интегрируется с &lt;a href=&quot;https://hex.pm&quot;&gt;менеджером пакетов Hex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02fd3a28a69477778e8b16f7b3cce09332f74ae5" translate="yes" xml:space="preserve">
          <source>Mix also supports Git and path dependencies:</source>
          <target state="translated">Mix также поддерживает зависимости Git и path:</target>
        </trans-unit>
        <trans-unit id="04bb9bcfa3927d3cae40daaaa838d4ef230a39cd" translate="yes" xml:space="preserve">
          <source>Mix and OTP</source>
          <target state="translated">Смешивание и OTP</target>
        </trans-unit>
        <trans-unit id="d25cf695ebdb9d0aee542ce2f227391b7ee2bf55" translate="yes" xml:space="preserve">
          <source>Mix and OTP guide</source>
          <target state="translated">Руководство по смешиванию и OTP</target>
        </trans-unit>
        <trans-unit id="5fa528ba639f2c7c836de5f176cd81f9105e7965" translate="yes" xml:space="preserve">
          <source>Mix by default ships with a public key but new ones can be added on demand.</source>
          <target state="translated">Смешивать по умолчанию корабли с открытым ключом,но новые могут быть добавлены по требованию.</target>
        </trans-unit>
        <trans-unit id="3c49eb51ca3d0ac562423c46ed5a59028d459767" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Mix можно использовать для управления проектами Erlang, не имеющими кода на Elixir. Чтобы задачи Mix работали правильно для проекта Erlang, &lt;code&gt;language: :erlang&lt;/code&gt; должен быть частью конфигурации, возвращаемой &lt;code&gt;project/0&lt;/code&gt; . Этот параметр также гарантирует, что Эликсир не добавлен в качестве зависимости к сгенерированному файлу &lt;code&gt;.app&lt;/code&gt; или к скрипту, сгенерированному с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt; , и так далее.</target>
        </trans-unit>
        <trans-unit id="a2a56ce9bc8efd270013eaafce32886b18ad521f" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;mix.tasks.escript.build&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Mix можно использовать для управления проектами Erlang, в которых нет кода на Elixir. Чтобы задачи Mix правильно работали для проекта Erlang, &lt;code&gt;language: :erlang&lt;/code&gt; должен быть частью конфигурации, возвращаемой &lt;code&gt;project/0&lt;/code&gt; . Этот параметр также гарантирует, что Elixir не будет добавлен как зависимость к сгенерированному файлу &lt;code&gt;.app&lt;/code&gt; или к сценарию, сгенерированному с помощью &lt;a href=&quot;mix.tasks.escript.build&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt; , и так далее.</target>
        </trans-unit>
        <trans-unit id="2cdb0b1920ef5553ebcd1f21161694f9fc79e940" translate="yes" xml:space="preserve">
          <source>Mix is a build tool and, as such, it is not expected to be available in production. Therefore, it is recommended to access &lt;code&gt;Mix.env&lt;/code&gt; only in configuration files and inside &lt;code&gt;mix.exs&lt;/code&gt;, never in your application code (&lt;code&gt;lib&lt;/code&gt;).</source>
          <target state="translated">Mix - это инструмент для сборки, поэтому не ожидается, что он будет доступен в производственной среде. Поэтому рекомендуется обращаться к &lt;code&gt;Mix.env&lt;/code&gt; только в файлах конфигурации и внутри &lt;code&gt;mix.exs&lt;/code&gt; , а не в коде вашего приложения ( &lt;code&gt;lib&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c6da9856af4245149570c16ec4188fc5d3115e0f" translate="yes" xml:space="preserve">
          <source>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</source>
          <target state="translated">Mix-это инструмент построения,предоставляющий задачи по созданию,компиляции и тестированию проектов Elixir,управлению его зависимостями и многое другое.</target>
        </trans-unit>
        <trans-unit id="a0df83a511be738d9e0de24c58fdbe9cd553aa72" translate="yes" xml:space="preserve">
          <source>Mix is the project management and build tool for Elixir. Invoking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; from the command line will run the tests in each file matching the pattern &lt;code&gt;*_test.exs&lt;/code&gt; found in the &lt;code&gt;test&lt;/code&gt; directory of your project.</source>
          <target state="translated">Mix - это инструмент для управления проектами и сборки Elixir. Вызов &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; из командной строки запустит тесты в каждом файле, соответствующем шаблону &lt;code&gt;*_test.exs&lt;/code&gt; , найденному в каталоге &lt;code&gt;test&lt;/code&gt; вашего проекта.</target>
        </trans-unit>
        <trans-unit id="6efd811f3c57b4beedb58b4c74d9cfc0e7bd84d8" translate="yes" xml:space="preserve">
          <source>Mix makes a distinction between projects and applications. Based on the contents of our &lt;code&gt;mix.exs&lt;/code&gt; file, we would say we have a Mix project that defines the &lt;code&gt;:kv&lt;/code&gt; application. As we will see in later chapters, there are projects that don&amp;rsquo;t define any application.</source>
          <target state="translated">Mix делает различие между проектами и приложениями. Основываясь на содержимом нашего файла &lt;code&gt;mix.exs&lt;/code&gt; , мы можем сказать, что у нас есть проект Mix, который определяет приложение &lt;code&gt;:kv&lt;/code&gt; . Как мы увидим в следующих главах, есть проекты, которые не определяют никаких приложений.</target>
        </trans-unit>
        <trans-unit id="be2005a661cc869ecef72b52d2f918c6a1c2bad6" translate="yes" xml:space="preserve">
          <source>Mix projects can specify required archives using the &lt;code&gt;:archives&lt;/code&gt; option:</source>
          <target state="translated">В смешанных проектах можно указать необходимые архивы с помощью параметра &lt;code&gt;:archives&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="648fcb70fef0f7b235a3a4efb99b43d14093584b" translate="yes" xml:space="preserve">
          <source>Mix provides many tasks for working with dependencies, which can be seen in &lt;code&gt;mix help&lt;/code&gt;:</source>
          <target state="translated">Mix предоставляет множество задач для работы с зависимостями, которые можно увидеть в &lt;code&gt;mix help&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6ad0076d881adfffd287f386c898dd8d3dfe63d9" translate="yes" xml:space="preserve">
          <source>Mix provides the concept of &amp;ldquo;environments&amp;rdquo;. They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:</source>
          <target state="translated">Mix предоставляет понятие &amp;laquo;среды&amp;raquo;. Они позволяют разработчику настраивать компиляцию и другие параметры для конкретных сценариев. По умолчанию Mix понимает три среды:</target>
        </trans-unit>
        <trans-unit id="d0eb4f5b6efc2f498d0a43bf2cce656e8deeb64f" translate="yes" xml:space="preserve">
          <source>Mix responds to the following variables:</source>
          <target state="translated">Mix реагирует на следующие переменные:</target>
        </trans-unit>
        <trans-unit id="9083e0d8be0e72f0bd60c89828382861a3d53dd0" translate="yes" xml:space="preserve">
          <source>Mix shell that uses the current process mailbox for communication.</source>
          <target state="translated">Смешайте оболочку,которая использует текущий процессный почтовый ящик для связи.</target>
        </trans-unit>
        <trans-unit id="ad263de6a1ec790ca04b9e1c0d40a550701c6fa7" translate="yes" xml:space="preserve">
          <source>Mix ships with many tasks under the &lt;code&gt;profile&lt;/code&gt; namespace, such as &lt;code&gt;cprof&lt;/code&gt; and &lt;code&gt;fprof&lt;/code&gt;</source>
          <target state="translated">Mix поставляется со многими задачами в пространстве имен &lt;code&gt;profile&lt;/code&gt; , такими как &lt;code&gt;cprof&lt;/code&gt; и &lt;code&gt;fprof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34cf07547ba5e61214e86cb3580e3d48c9fa65b9" translate="yes" xml:space="preserve">
          <source>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</source>
          <target state="translated">Mix поддерживает различные среды.Среды позволяют разработчикам подготовить и организовать свой проект специально для различных сценариев.По умолчанию Mix предоставляет три окружения:</target>
        </trans-unit>
        <trans-unit id="83b58a0b5c1a90355989a0e6c6c83aa3b187f7ca" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Задачи смешивания предназначены для выполнения только один раз. Это предотвращает выполнение одной и той же задачи несколько раз. Например, если есть несколько задач в зависимости от &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; , код будет скомпилирован один раз. Задачи могут быть выполнены снова, если они явно &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html#reenable/1&quot;&gt; &lt;code&gt;Mix.Task.reenable/1&lt;/code&gt; &lt;/a&gt; с помощью Mix.Task.reenable / 1 :</target>
        </trans-unit>
        <trans-unit id="e1d70ab3fabbbe21fc38f850f28d9a31374f92fc" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;mix.task#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Задачи смешивания предназначены для выполнения только один раз. Это предотвращает выполнение одной и той же задачи несколько раз. Например, если есть несколько задач в зависимости от &lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; , код будет скомпилирован один раз. Задачи могут быть выполнены снова, если они явно повторно включены с помощью &lt;a href=&quot;mix.task#reenable/1&quot;&gt; &lt;code&gt;Mix.Task.reenable/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="afb48dfad219bb575ed5a6a2a2d6171fe59e0c43" translate="yes" xml:space="preserve">
          <source>Mix will create a directory named &lt;code&gt;kv&lt;/code&gt; with a few files in it:</source>
          <target state="translated">Mix создаст каталог с именем &lt;code&gt;kv&lt;/code&gt; с несколькими файлами:</target>
        </trans-unit>
        <trans-unit id="8fa02d3dbeffdcfedef855ce25999f5c0e80ec49" translate="yes" xml:space="preserve">
          <source>Mix will default to the &lt;code&gt;:dev&lt;/code&gt; environment, except for the &lt;code&gt;test&lt;/code&gt; task that will default to the &lt;code&gt;:test&lt;/code&gt; environment. The environment can be changed via the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable:</source>
          <target state="translated">Mix по умолчанию будет использовать среду &lt;code&gt;:dev&lt;/code&gt; , за исключением &lt;code&gt;test&lt;/code&gt; задачи, которая по умолчанию будет использовать среду &lt;code&gt;:test&lt;/code&gt; . &lt;code&gt;MIX_ENV&lt;/code&gt; можно изменить с помощью переменной окружения MIX_ENV :</target>
        </trans-unit>
        <trans-unit id="399305e4f380845bf197d5745b3fee53dc94ea53" translate="yes" xml:space="preserve">
          <source>Mix will load the &lt;code&gt;test_helper.exs&lt;/code&gt; file before executing the tests. It is not necessary to &lt;code&gt;require&lt;/code&gt; the &lt;code&gt;test_helper.exs&lt;/code&gt; file in your test files. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;Mix.Tasks.Test&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Mix загрузит файл &lt;code&gt;test_helper.exs&lt;/code&gt; перед выполнением тестов. Не нужно &lt;code&gt;require&lt;/code&gt; в &lt;code&gt;test_helper.exs&lt;/code&gt; файл тестовых файлов. См. &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;Mix.Tasks.Test&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ee77903e91bd71aaf1d44a1d48282536084b696b" translate="yes" xml:space="preserve">
          <source>Mix.Config</source>
          <target state="translated">Mix.Config</target>
        </trans-unit>
        <trans-unit id="e7628834f3db8ecf170e414a049c01be9012e895" translate="yes" xml:space="preserve">
          <source>Mix.ElixirVersionError</source>
          <target state="translated">Mix.ElixirVersionError</target>
        </trans-unit>
        <trans-unit id="5d3ee672a247963bfe70c641177c1ba0a41ff083" translate="yes" xml:space="preserve">
          <source>Mix.ElixirVersionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.ElixirVersionError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ba0c0d562a5605e3a981b412bfebf8f39b9cb8cd" translate="yes" xml:space="preserve">
          <source>Mix.Error</source>
          <target state="translated">Mix.Error</target>
        </trans-unit>
        <trans-unit id="2f66ee90982acc2333482e324e66f83680cb1f82" translate="yes" xml:space="preserve">
          <source>Mix.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.Error &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b88ebcf3bbdbb70cb1e50aee5837165ee0fe04e4" translate="yes" xml:space="preserve">
          <source>Mix.Generator</source>
          <target state="translated">Mix.Generator</target>
        </trans-unit>
        <trans-unit id="677bfdd437f39d48687e8e09deb896bdab1ffcab" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError</source>
          <target state="translated">Mix.InvalidTaskError</target>
        </trans-unit>
        <trans-unit id="73acde233ddd7f978233bc0c9c03ffcb591e4127" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.InvalidTaskError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5656de2d70dc1fd33545f113c9c31f4468c93c9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError</source>
          <target state="translated">Mix.NoProjectError</target>
        </trans-unit>
        <trans-unit id="a3cd7de13e58b68149c17286a492f048bc5a4f9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoProjectError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2296b8a4da20e50fc86db62a76ae3a0f21236d09" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError</source>
          <target state="translated">Mix.NoTaskError</target>
        </trans-unit>
        <trans-unit id="4758003c8f1681557fd809da1ff272c0a4bdc616" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoTaskError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f736ae59e13a4e4114e4af3bf6ddc51b25a5bb36" translate="yes" xml:space="preserve">
          <source>Mix.Project</source>
          <target state="translated">Mix.Project</target>
        </trans-unit>
        <trans-unit id="b27a97deee7753ee8eb8c3806c9cd74d0bb623c8" translate="yes" xml:space="preserve">
          <source>Mix.Release</source>
          <target state="translated">Mix.Release</target>
        </trans-unit>
        <trans-unit id="7bf1594ecaa648fd474444d9f33117c28b7ba143" translate="yes" xml:space="preserve">
          <source>Mix.SCM</source>
          <target state="translated">Mix.SCM</target>
        </trans-unit>
        <trans-unit id="12559e0f7b32d5fd2155ad9ecec382ea1f9fb246" translate="yes" xml:space="preserve">
          <source>Mix.SCM &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.SCM &lt;small&gt;поведение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="147dd88a75a0c786898d12b4f3b2f0d6509bdbbe" translate="yes" xml:space="preserve">
          <source>Mix.Shell</source>
          <target state="translated">Mix.Shell</target>
        </trans-unit>
        <trans-unit id="db6ddc34f19b653dd6682b35bc47a0feda16df77" translate="yes" xml:space="preserve">
          <source>Mix.Shell &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Shell &lt;small&gt;поведение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="467f63e6768ca92e850a24bb5559e6ceb3ff2d65" translate="yes" xml:space="preserve">
          <source>Mix.Shell.IO</source>
          <target state="translated">Mix.Shell.IO</target>
        </trans-unit>
        <trans-unit id="ae6604b3cc7069b10edb34181cf30fa1c7e69549" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Process</source>
          <target state="translated">Mix.Shell.Process</target>
        </trans-unit>
        <trans-unit id="c13560925a5e68a093665c40b5877151b400f1d5" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Quiet</source>
          <target state="translated">Mix.Shell.Quiet</target>
        </trans-unit>
        <trans-unit id="d04ad970550a78d0484fc6fba35ca08880a1b57f" translate="yes" xml:space="preserve">
          <source>Mix.Task</source>
          <target state="translated">Mix.Task</target>
        </trans-unit>
        <trans-unit id="426aac8f0abf87df945411bf3866831ccdd5ee99" translate="yes" xml:space="preserve">
          <source>Mix.Task &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Task &lt;small&gt;поведение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6f91ff2c65c62a79e11d8c360e69332bd77495df" translate="yes" xml:space="preserve">
          <source>Mix.Task.Compiler</source>
          <target state="translated">Mix.Task.Compiler</target>
        </trans-unit>
        <trans-unit id="53feeecd2c589ebee644042d57a6c38decab8485" translate="yes" xml:space="preserve">
          <source>Mix.Task.Compiler &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Task.Compiler &lt;small&gt;поведение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d2bcc64e4a2da01e6d8df9586fbe7326fe6c2619" translate="yes" xml:space="preserve">
          <source>Mix.Task.Compiler.Diagnostic</source>
          <target state="translated">Mix.Task.Compiler.Diagnostic</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="63368ee0cfe73d65555cc05d160f4780d59c63dd" translate="yes" xml:space="preserve">
          <source>Modifies command line arguments.</source>
          <target state="translated">Изменяет аргументы командной строки.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="9297e283a310f6ab7d943b5269f1a79016e762cb" translate="yes" xml:space="preserve">
          <source>Module &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Поведение&lt;/small&gt; модуля&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9c3f2aba6913de8da00faed8e2df2428bb1257b7" translate="yes" xml:space="preserve">
          <source>Module Attributes</source>
          <target state="translated">Атрибуты модуля</target>
        </trans-unit>
        <trans-unit id="974d46d1f85954ab50d762a7e03d4820f241857f" translate="yes" xml:space="preserve">
          <source>Module and describe tags</source>
          <target state="translated">Модуль и теги описания</target>
        </trans-unit>
        <trans-unit id="ff725127805595b93c72cd98d8e8f3dbd5984820" translate="yes" xml:space="preserve">
          <source>Module attribute unary operator. Reads and writes attributes in the current module.</source>
          <target state="translated">Атрибут модуля унарный оператор.Читает и записывает атрибуты в текущий модуль.</target>
        </trans-unit>
        <trans-unit id="330765efeb90ac3d911657d7500e925bd8f2537b" translate="yes" xml:space="preserve">
          <source>Module attributes</source>
          <target state="translated">Атрибуты модуля</target>
        </trans-unit>
        <trans-unit id="611dbb58b63e5a3205266276e6a852dcaa7a3969" translate="yes" xml:space="preserve">
          <source>Module attributes in Elixir serve three purposes:</source>
          <target state="translated">Атрибуты модулей в эликсире служат трем целям:</target>
        </trans-unit>
        <trans-unit id="e1e3ec1d59bfdc3e7d0eaa73499821e62209421e" translate="yes" xml:space="preserve">
          <source>Module attributes reader (&lt;code&gt;@foo&lt;/code&gt;)</source>
          <target state="translated">Считыватель атрибутов модуля ( &lt;code&gt;@foo&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ddfcf23684bdb5ef441d59b66364129fcb4f0309" translate="yes" xml:space="preserve">
          <source>Module nesting</source>
          <target state="translated">Модульное гнездование</target>
        </trans-unit>
        <trans-unit id="40144123a36c18a55943d34cbb9a342139e699ec" translate="yes" xml:space="preserve">
          <source>Module to work with, define, and import records.</source>
          <target state="translated">Модуль для работы с,определения и импорта записей.</target>
        </trans-unit>
        <trans-unit id="cc1693df58c9640eee91eb5bd91f74e7ad932311" translate="yes" xml:space="preserve">
          <source>Module-based supervisors</source>
          <target state="translated">Модульные супервайзеры</target>
        </trans-unit>
        <trans-unit id="82bcbad43b8fe828d8612d7cf59577c71448624a" translate="yes" xml:space="preserve">
          <source>Module.Types.Error</source>
          <target state="translated">Module.Types.Error</target>
        </trans-unit>
        <trans-unit id="2835d1253cc2dd6d4f2059714db091dee1de72c4" translate="yes" xml:space="preserve">
          <source>Module.Types.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Module.Types.Error &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f355677d6ea7dd474a7c5dc3db11334d6f6003dc" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; attribute. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; attribute we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="translated">Модули, использующие поведение &lt;code&gt;Parser&lt;/code&gt; , должны будут реализовать все функции, определенные с &lt;code&gt;@callback&lt;/code&gt; атрибута @callback . Как видите, &lt;code&gt;@callback&lt;/code&gt; ожидает имя функции, но также и спецификацию функции, подобную тем, которые используются с атрибутом &lt;code&gt;@spec&lt;/code&gt; ,который мы видели выше. Также обратите внимание, что &lt;code&gt;term&lt;/code&gt; тип используется для представления проанализированного значения. В Elixir &lt;code&gt;term&lt;/code&gt; тип - это ярлык для обозначения любого типа.</target>
        </trans-unit>
        <trans-unit id="2f22992ace2b7b2537bcbf08c8e4ceeca5300f8f" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; directive. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; directive we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="translated">Модули, использующие поведение &lt;code&gt;Parser&lt;/code&gt; , должны будут реализовать все функции, определенные с &lt;code&gt;@callback&lt;/code&gt; директивы @callback . Как видите, &lt;code&gt;@callback&lt;/code&gt; ожидает имя функции, но также и спецификацию функции, подобную тем, которые используются с директивой &lt;code&gt;@spec&lt;/code&gt; ,которую мы видели выше. Также обратите внимание, что &lt;code&gt;term&lt;/code&gt; тип используется для представления проанализированного значения. В Elixir &lt;code&gt;term&lt;/code&gt; тип - это ярлык для обозначения любого типа.</target>
        </trans-unit>
        <trans-unit id="dbf8ec2a137ea97fd047b1bf5fb0e081373aaeef" translate="yes" xml:space="preserve">
          <source>Modules and functions</source>
          <target state="translated">Модули и функции</target>
        </trans-unit>
        <trans-unit id="f95593466c9236f423e2ca78c791a9ed452a97e0" translate="yes" xml:space="preserve">
          <source>Modules compiled with HiPE would not call this hook.</source>
          <target state="translated">Модули,скомпилированные с HiPE,не будут вызывать этот крюк.</target>
        </trans-unit>
        <trans-unit id="5f7948a408bbeb081e3bf4398d0a06535fe04fa6" translate="yes" xml:space="preserve">
          <source>Modules that are not yet loaded won't show up. Check &lt;a href=&quot;#load_all/0&quot;&gt;&lt;code&gt;load_all/0&lt;/code&gt;&lt;/a&gt; if you want to preload all tasks.</source>
          <target state="translated">Модули, которые еще не загружены, не отображаются. Отметьте &lt;a href=&quot;#load_all/0&quot;&gt; &lt;code&gt;load_all/0&lt;/code&gt; ,&lt;/a&gt; если вы хотите предварительно загрузить все задачи.</target>
        </trans-unit>
        <trans-unit id="bda622c46b037f80824387d421dc386c6556e7d2" translate="yes" xml:space="preserve">
          <source>Modules that interface with the underlying system, such as:</source>
          <target state="translated">Модули,которые взаимодействуют с базовой системой,например:</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="49fb186a5c3efc09ccd0d283216aa3aefc8c1db1" translate="yes" xml:space="preserve">
          <source>Monitors or links?</source>
          <target state="translated">Мониторы или ссылки?</target>
        </trans-unit>
        <trans-unit id="b5af02a7afd8f398df475e389f375296b40fcadb" translate="yes" xml:space="preserve">
          <source>Monitors the status of the node.</source>
          <target state="translated">Наблюдает за состоянием узла.</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="531f01d1f3ee72b3521ad6573e9645c241df955d" translate="yes" xml:space="preserve">
          <source>More detailed information is returned if you provide the &lt;code&gt;--callers&lt;/code&gt; and &lt;code&gt;--details&lt;/code&gt; options.</source>
          <target state="translated">Более подробная информация будет возвращена, если вы &lt;code&gt;--details&lt;/code&gt; параметры &lt;code&gt;--callers&lt;/code&gt; и --details .</target>
        </trans-unit>
        <trans-unit id="679fb30706daaf38b9e2ca52a7581c5f7429d440" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;base#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;base#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Еще примеры парных функций: &lt;a href=&quot;base#decode16/2&quot;&gt; &lt;code&gt;Base.decode16/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;base#decode16!/2&quot;&gt; &lt;code&gt;Base.decode16!/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;file#cwd!/0&quot;&gt; &lt;code&gt;File.cwd!/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a76b5d6cb0550f163be45d1ffe3dd80feed4cca5" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Еще примеры парных функций: &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16/2&quot;&gt; &lt;code&gt;Base.decode16/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16!/2&quot;&gt; &lt;code&gt;Base.decode16!/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd!/0&quot;&gt; &lt;code&gt;File.cwd!/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b89d915a104252705d1f85ce849ed077d1dac0ac" translate="yes" xml:space="preserve">
          <source>More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;. The current Elixir version implements Extended Grapheme Cluster algorithm.</source>
          <target state="translated">Более подробную информацию о графемах можно найти в &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Приложении № 29&lt;/a&gt; к стандарту Unicode . В текущей версии Elixir реализован алгоритм Extended Grapheme Cluster.</target>
        </trans-unit>
        <trans-unit id="088ca4e64f0525b9190a46a6e7d28dc2bb334d89" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Tuple.html&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Более подробную информацию о типе данных кортеж и о функциях для управления кортежами можно найти в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Tuple.html&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; ; некоторые функции для работы с кортежами также доступны в &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; (например, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#elem/2&quot;&gt; &lt;code&gt;Kernel.elem/2&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a5e8684b13528d21f979a1818ef3d359d73c9599" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;kernel#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Более подробную информацию о типе данных кортежа и о функциях для управления кортежами можно найти в модуле &lt;a href=&quot;tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; ; некоторые функции для работы с кортежами также доступны в &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; (например, &lt;a href=&quot;kernel#elem/2&quot;&gt; &lt;code&gt;Kernel.elem/2&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="430a22fd9616cca59513735ab6a5d8e059b24d05" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о дате и времени можно найти в модуле &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e04894dfd3a6bb66a7491537a157990555658def" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о дате и времени можно найти в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a10a384a2270f2efaa542fb180ccc3a8a8fab8a8" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о датах можно найти в модуле &amp;laquo; &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ad7f92deccb05da471db41290bd58b1c393e4789" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о датах можно найти в модуле &amp;laquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="45f71097bb0f5266ed4f78a2e99026509e61b3b6" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о наивном времени дат можно найти в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d09563b1d7bf20501a96abf9b569ef7f610dceb" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о наивном датах можно найти в модуле &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fade606b3bd42ef1829481b3da2ebb0df791e41d" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Дополнительную информацию о регулярных выражениях можно найти в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c85521cfa0af914c1bfcc721a8420c6e8c54e6ca" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Дополнительную информацию о регулярных выражениях можно найти в модуле &lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e509c546dcb0afd4dc86df671153581bf407f3" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о регулярных выражениях можно найти в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="943682535e16011c70352d95eb0b5a94fc51f1ec" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о регулярных выражениях можно найти в модуле &lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57430af0cc488dc7ee178424fa4b1f09dd9b2473" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о времени можно найти в модуле &amp;laquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="74e1febe16a203d4cc3b9b43ca22bede1863da17" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Более подробную информацию о времени можно найти в модуле &amp;laquo; &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="47345d51b5c718e5874fcd01549e8be7ce1a8743" translate="yes" xml:space="preserve">
          <source>More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom &lt;code&gt;:ok&lt;/code&gt;:</source>
          <target state="translated">Что еще более интересно, мы можем сопоставить конкретные значения. В приведенном ниже примере утверждается, что левая сторона будет соответствовать правой только в том случае, если правая сторона представляет собой кортеж, начинающийся с атома &lt;code&gt;:ok&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="708db7ea87e7a72eeea9cb0dbb3ddbd4f2c25b4b" translate="yes" xml:space="preserve">
          <source>More options are available; for the comprehensive list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Доступны другие варианты; полный список доступных опций &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0761006711d858b0c2a58d2cbd1afefe913dcc42" translate="yes" xml:space="preserve">
          <source>Moreover, even when trapping exits, calling &lt;code&gt;await&lt;/code&gt; will still exit if the task has terminated without sending its result back.</source>
          <target state="translated">Более того, даже при выходе из перехвата вызов &lt;code&gt;await&lt;/code&gt; все равно завершится, если задача завершилась без отправки результата.</target>
        </trans-unit>
        <trans-unit id="7a438f48c599e07f621f37d7528ee6f6b3ed9813" translate="yes" xml:space="preserve">
          <source>Most Elixir code has a straight-forward translation to its underlying quoted expression. We recommend you try out different code samples and see what the results are. For example, what does &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; expand to? We have also learned that &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; is the same as &lt;code&gt;if true do :this else :that end&lt;/code&gt;. How does this affirmation hold with quoted expressions?</source>
          <target state="translated">Большая часть кода Elixir имеет прямой перевод на лежащее в основе выражение в кавычках. Мы рекомендуем вам попробовать разные образцы кода и посмотреть, каковы результаты. Например, до чего &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; ? Мы также узнали, что &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; совпадает с &lt;code&gt;if true do :this else :that end&lt;/code&gt; . Как это утверждение работает с цитируемыми выражениями?</target>
        </trans-unit>
        <trans-unit id="7ef32c667bd728bf6d46696a457f5ed0e7db5896" translate="yes" xml:space="preserve">
          <source>Most commonly, this module is used to define your own configuration:</source>
          <target state="translated">Чаще всего этот модуль используется для определения вашей собственной конфигурации:</target>
        </trans-unit>
        <trans-unit id="0687907a8d3988b5e082480eea48abedcef483ec" translate="yes" xml:space="preserve">
          <source>Most editors provide built-in integration with the formatter, allowing a file to be formatted on save or via a chosen keybinding. If you are learning Elixir, editor integration gives you useful and quick feedback when learning the Elixir syntax.</source>
          <target state="translated">Большинство редакторов обеспечивают встроенную интеграцию с форматировщиком,позволяя отформатировать файл при сохранении или с помощью выбранной связки клавиш.Если вы изучаете Elixir,то интеграция редактора дает вам полезную и быструю обратную связь при изучении синтаксиса Elixir.</target>
        </trans-unit>
        <trans-unit id="024156cd258aa614f1a1e84226c2405ec889367a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module return &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:ok, result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. Those functions also have a variant that ends with &lt;code&gt;!&lt;/code&gt; which returns the result (instead of the &lt;code&gt;{:ok, result}&lt;/code&gt; tuple) in case of success or raises an exception in case it fails. For example:</source>
          <target state="translated">Большинство функций в этом модуле возвращают &lt;code&gt;:ok&lt;/code&gt; или &lt;code&gt;{:ok, result}&lt;/code&gt; в случае успеха, &lt;code&gt;{:error, reason}&lt;/code&gt; противном случае. У этих функций также есть вариант, который заканчивается на &lt;code&gt;!&lt;/code&gt; который возвращает результат (вместо кортежа &lt;code&gt;{:ok, result}&lt;/code&gt; ) в случае успеха или вызывает исключение в случае неудачи. Например:</target>
        </trans-unit>
        <trans-unit id="fe4747de8e4154287a567beb557c39a3a7ea6b63" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="translated">Большинство функций в этом модуле работают в линейном времени. Это означает, что время, необходимое для выполнения операции, растет с той же скоростью, что и длина списка. Например, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#last/1&quot;&gt; &lt;code&gt;last/1&lt;/code&gt; &lt;/a&gt; будут выполняться за линейное время, потому что им нужно перебирать каждый элемент списка, но &lt;a href=&quot;#first/1&quot;&gt; &lt;code&gt;first/1&lt;/code&gt; &lt;/a&gt; будет выполняться за постоянное время, потому что ему нужен только первый элемент.</target>
        </trans-unit>
        <trans-unit id="dbffd668417f19cdbcd33d0162e5263a21e09ebf" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="translated">Большинство функций в этом модуле работают в линейном времени. Это означает, что время, необходимое для выполнения операции, растет с той же скоростью, что и длина списка. Например, &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#last/1&quot;&gt; &lt;code&gt;last/1&lt;/code&gt; &lt;/a&gt; будут выполняться за линейное время, потому что им нужно перебирать каждый элемент списка, но &lt;a href=&quot;#first/1&quot;&gt; &lt;code&gt;first/1&lt;/code&gt; &lt;/a&gt; будет выполняться за постоянное время, потому что ему нужен только первый элемент.</target>
        </trans-unit>
        <trans-unit id="ce9701b5552f6ac3d94cc4ca928ec6d05512ce0a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</source>
          <target state="translated">Большинство функций в этом модуле работают в линейном времени.Это означает,что время,необходимое для выполнения операции,растет с той же скоростью,что и длина списка.</target>
        </trans-unit>
        <trans-unit id="3fd0b4b5634fc00fd0cd07602c5fab763e2a315d" translate="yes" xml:space="preserve">
          <source>Most of the inlined functions can be seen in effect when capturing the function:</source>
          <target state="translated">Большинство встраиваемых функций можно увидеть в действии при захвате функции:</target>
        </trans-unit>
        <trans-unit id="650e20466b330f46fc9cd6f719b3f04d44e3661d" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="translated">Большинство операций в &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; реализованы в терминах сокращения. Эта функция должна применить данную функцию &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; к каждому элементу &lt;code&gt;enumerable&lt;/code&gt; и продолжить работу, как ожидается возвращенным аккумулятором.</target>
        </trans-unit>
        <trans-unit id="2bbbf699ba5529e80a9e0479fc3b9c7618a46171" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="translated">Большинство операций в &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; реализованы в терминах сокращения. Эта функция должна применить данную функцию &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; к каждому элементу &lt;code&gt;enumerable&lt;/code&gt; и продолжить работу, как ожидается возвращенным аккумулятором.</target>
        </trans-unit>
        <trans-unit id="24b137a5b6dba3724d546a7b4386d3d0c4f7db88" translate="yes" xml:space="preserve">
          <source>Most of the time it is convenient to write modules into files so they can be compiled and reused. Let&amp;rsquo;s assume we have a file named &lt;code&gt;math.ex&lt;/code&gt; with the following contents:</source>
          <target state="translated">В большинстве случаев удобно записывать модули в файлы, чтобы их можно было скомпилировать и использовать повторно. Предположим, у нас есть файл с именем &lt;code&gt;math.ex&lt;/code&gt; со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="629b5f27dd5283caadd5c5cbf0f295755b9869cd" translate="yes" xml:space="preserve">
          <source>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</source>
          <target state="translated">Большую часть времени существует одна,и только одна,действительная дата для определенной даты и времени в определенном часовом поясе.</target>
        </trans-unit>
        <trans-unit id="91857fb8fa18b4cfe30782a8862e99da6ebb9879" translate="yes" xml:space="preserve">
          <source>Most of the time, Elixir is going to guide you to do the right thing. For example, there is an &lt;code&gt;elem/2&lt;/code&gt; function to access a tuple item but there is no built-in equivalent for lists:</source>
          <target state="translated">В большинстве случаев Эликсир поможет вам поступить правильно. Например, есть функция &lt;code&gt;elem/2&lt;/code&gt; для доступа к элементу кортежа, но нет встроенного эквивалента для списков:</target>
        </trans-unit>
        <trans-unit id="cca16065899804f7768a7a1720aa616e84369d6b" translate="yes" xml:space="preserve">
          <source>Move the undocumented function to a module with &lt;code&gt;@moduledoc false&lt;/code&gt;, like &lt;code&gt;MyApp.Hidden&lt;/code&gt;, ensuring the function won't be accidentally exposed or imported. Remember you can use &lt;code&gt;@moduledoc false&lt;/code&gt; to hide a whole module and still document each function with &lt;code&gt;@doc&lt;/code&gt;. Tools will still ignore the module.</source>
          <target state="translated">Переместите недокументированную функцию в модуль с &lt;code&gt;@moduledoc false&lt;/code&gt; , например &lt;code&gt;MyApp.Hidden&lt;/code&gt; , чтобы функция не была случайно представлена ​​или импортирована. Помните, что вы можете использовать &lt;code&gt;@moduledoc false&lt;/code&gt; , чтобы скрыть весь модуль и при этом задокументировать каждую функцию с помощью &lt;code&gt;@doc&lt;/code&gt; . Инструменты по-прежнему будут игнорировать модуль.</target>
        </trans-unit>
        <trans-unit id="8ba586c26244aa844e20201d605ef816e569e0c3" translate="yes" xml:space="preserve">
          <source>Much better! &lt;code&gt;with&lt;/code&gt; will retrieve the value returned by the right-side of &lt;code&gt;&amp;lt;-&lt;/code&gt; and match it against the pattern on the left side. If the value matches the pattern, &lt;code&gt;with&lt;/code&gt; moves on to the next expression. In case there is no match, the non-matching value is returned.</source>
          <target state="translated">Намного лучше! &lt;code&gt;with&lt;/code&gt; будет извлекать значение, возвращаемое правой частью &lt;code&gt;&amp;lt;-&lt;/code&gt; , и сопоставлять его с шаблоном в левой части. Если значение соответствует шаблону, &lt;code&gt;with&lt;/code&gt; переходит к следующему выражению. Если совпадения нет, возвращается несоответствующее значение.</target>
        </trans-unit>
        <trans-unit id="aca1d8661416c63356922cc0e796c657256bdbf6" translate="yes" xml:space="preserve">
          <source>Multi alias/import/require/use</source>
          <target state="translated">Несколько псевдонимов/импорт/импорт/требование/использование</target>
        </trans-unit>
        <trans-unit id="56c84318ece5d60a2edc2a745e9430721117f115" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt; псевдонимы в OptionParser</target>
        </trans-unit>
        <trans-unit id="600851f745d8c6c136c80bb6740770dde7f94908" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt; псевдонимы в OptionParser</target>
        </trans-unit>
        <trans-unit id="cd897f3df67fae1b86657cd6f5002662e25d4a84" translate="yes" xml:space="preserve">
          <source>Multi-line charlists are written with three single-quotes (&lt;code&gt;'''&lt;/code&gt;), the same way multi-line strings are.</source>
          <target state="translated">Многострочные списки символов записываются с помощью трех одинарных кавычек ( &lt;code&gt;'''&lt;/code&gt; ), как и многострочные строки.</target>
        </trans-unit>
        <trans-unit id="7c20d594d29120427ee2ec63c03ac466e7b133f7" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, and the like</source>
          <target state="translated">Многострочные списки,карты,кортежи и т.п.</target>
        </trans-unit>
        <trans-unit id="971b1abcdb78d0f06496a5acd8f26ed4ec25bf2b" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, etc.</source>
          <target state="translated">Многострочные списки,карты,кортежи и т.д.</target>
        </trans-unit>
        <trans-unit id="387558e9801635e36ced6d8f96c29ddee6395ce1" translate="yes" xml:space="preserve">
          <source>Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is used to strip indentation from the inner string. For example:</source>
          <target state="translated">Многострочные строки в Elixir записываются с тремя двойными кавычками и могут иметь внутри себя неэкранированные кавычки. Результирующая строка будет заканчиваться новой строкой. Отступ последнего символа &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; используется для удаления отступа из внутренней строки. Например:</target>
        </trans-unit>
        <trans-unit id="f3b47d6814f63cc5e3bd080a55da0c264aee3d21" translate="yes" xml:space="preserve">
          <source>Multiple code points that may be perceived as a single character by readers</source>
          <target state="translated">Многочисленные пункты кода,которые могут восприниматься читателями как один символ</target>
        </trans-unit>
        <trans-unit id="4f0084cccc0c20805d1c2152e4b316e391ff55d4" translate="yes" xml:space="preserve">
          <source>Multiple elements may prefix the &lt;code&gt;| tail&lt;/code&gt; construct:</source>
          <target state="translated">Несколько элементов могут иметь префикс &lt;code&gt;| tail&lt;/code&gt; конструкция хвоста :</target>
        </trans-unit>
        <trans-unit id="6d1f745a36808f93bd028263c26703cfbaed268c" translate="yes" xml:space="preserve">
          <source>Multiple generators can also be used to calculate the cartesian product of two lists:</source>
          <target state="translated">Несколько генераторов также могут быть использованы для расчета картезианского продукта из двух списков:</target>
        </trans-unit>
        <trans-unit id="7fd421a1aa76b2a83bd80d007c37c141c303064d" translate="yes" xml:space="preserve">
          <source>Multiple guards in the same clause</source>
          <target state="translated">Несколько охранников в одном и том же пункте</target>
        </trans-unit>
        <trans-unit id="c528525d61b06dbc869c01826c97062225a9a675" translate="yes" xml:space="preserve">
          <source>Multiple implementations</source>
          <target state="translated">Многочисленные внедрения</target>
        </trans-unit>
        <trans-unit id="ff8681bd747154b9388af5f672277e70fb2f689c" translate="yes" xml:space="preserve">
          <source>Multiple instances of the same backend can be specified by adding tuples in the format &lt;code&gt;{BackendModuleName, :backend_name}&lt;/code&gt;:</source>
          <target state="translated">Можно указать несколько экземпляров одного и того же &lt;code&gt;{BackendModuleName, :backend_name}&lt;/code&gt; добавив кортежи в формате {BackendModuleName,: backend_name} :</target>
        </trans-unit>
        <trans-unit id="f43d8ba152323821f27a132f7581f8caab516e47" translate="yes" xml:space="preserve">
          <source>Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether.</source>
          <target state="translated">Несколько релизов.Вы можете собирать разные выпуски с разными конфигурациями для каждого приложения или даже для разных приложений в целом.</target>
        </trans-unit>
        <trans-unit id="7568f33631ddb2754ee748a9c6bc2f4f8eceabd0" translate="yes" xml:space="preserve">
          <source>Multiple results can be checked within the same test:</source>
          <target state="translated">В рамках одного и того же теста можно проверить несколько результатов:</target>
        </trans-unit>
        <trans-unit id="8f4cf21f4344405e752af495c43a5b7beb80cfa4" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@compile&lt;/code&gt; will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below.</source>
          <target state="translated">Многократное использование &lt;code&gt;@compile&lt;/code&gt; будет накапливаться вместо отмены предыдущих. См. Раздел &amp;laquo;Параметры компиляции&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="cbd5985b43b284860bef16f48015f61c53879304" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@dialyzer&lt;/code&gt; will accumulate instead of overriding previous ones.</source>
          <target state="translated">Многократное использование &lt;code&gt;@dialyzer&lt;/code&gt; будет накапливаться, а не отменять предыдущие.</target>
        </trans-unit>
        <trans-unit id="b5df1b82e3f5abfb84a6922491ed88fb7f160033" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, and others)</source>
          <target state="translated">Мутируемое состояние и доступ к общим ресурсам (таким как ETS,файлы и др.)</target>
        </trans-unit>
        <trans-unit id="4bc08a47511c7c5ad4c0a467eaca187d877e8749" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, etc.)</source>
          <target state="translated">Мутируемое состояние и доступ к общим ресурсам (таким как ETS,файлы и т.д.).</target>
        </trans-unit>
        <trans-unit id="74c5ad44b6579fcbcf0c6ec60e160908d2a983ce" translate="yes" xml:space="preserve">
          <source>My computer is named &lt;code&gt;jv&lt;/code&gt;, so I see &lt;code&gt;foo@jv&lt;/code&gt; in the example above, but you will get a different result. We will use &lt;code&gt;foo@computer-name&lt;/code&gt; in the following examples and you should update them accordingly when trying out the code.</source>
          <target state="translated">Мой компьютер называется &lt;code&gt;jv&lt;/code&gt; , поэтому в приведенном выше примере я вижу &lt;code&gt;foo@jv&lt;/code&gt; , но вы получите другой результат. В следующих примерах мы будем использовать &lt;code&gt;foo@computer-name&lt;/code&gt; и вам следует обновить их соответствующим образом при тестировании кода.</target>
        </trans-unit>
        <trans-unit id="a50f07a710ba62544947bf23759e42c6e82ff7d6" translate="yes" xml:space="preserve">
          <source>My particular telnet client can be exited by typing &lt;code&gt;ctrl + ]&lt;/code&gt;, typing &lt;code&gt;quit&lt;/code&gt;, and pressing &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;, but your client may require different steps.</source>
          <target state="translated">Из моего конкретного клиента telnet можно выйти, набрав &lt;code&gt;ctrl + ]&lt;/code&gt; , набрав &lt;code&gt;quit&lt;/code&gt; и нажав &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; , но вашему клиенту могут потребоваться другие шаги.</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="b897ebc1430a2e4abc81cf0b2714edf134f99207" translate="yes" xml:space="preserve">
          <source>NaiveDateTime</source>
          <target state="translated">NaiveDateTime</target>
        </trans-unit>
        <trans-unit id="d49675d6a7db398730976978d05575d69c0eb3c3" translate="yes" xml:space="preserve">
          <source>Name registration</source>
          <target state="translated">Регистрация имени</target>
        </trans-unit>
        <trans-unit id="368a0ab278773b445741a837271772d0936779aa" translate="yes" xml:space="preserve">
          <source>Named functions</source>
          <target state="translated">Названные функции</target>
        </trans-unit>
        <trans-unit id="b7cb86483160ed9ca9d1ab540d3476197e0162c0" translate="yes" xml:space="preserve">
          <source>Named functions in Elixir also support default arguments:</source>
          <target state="translated">Именованные функции в Elixir также поддерживают аргументы по умолчанию:</target>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">Конвенции по наименованию</target>
        </trans-unit>
        <trans-unit id="7c7072ebdd4d3d7903620768f687a8dfdcc8ce66" translate="yes" xml:space="preserve">
          <source>Naming processes</source>
          <target state="translated">Процессы наименования</target>
        </trans-unit>
        <trans-unit id="2dafad67b671623ab79a27e34be51e846c44fb41" translate="yes" xml:space="preserve">
          <source>Negation switches</source>
          <target state="translated">Переключатели отклонения</target>
        </trans-unit>
        <trans-unit id="69411c8fc84402fa538d77b5600d2c036cb1597e" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported up to -377705116800 seconds:</source>
          <target state="translated">Отрицательное Unix-времени поддерживается до -377705116800 секунд:</target>
        </trans-unit>
        <trans-unit id="6cf669c72f3ca4537fedf1a696188ac323c60bad" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported, up to -62167219200 seconds, which is equivalent to &quot;0000-01-01T00:00:00Z&quot; or 0 Gregorian seconds.</source>
          <target state="translated">Поддерживается отрицательное Unix-времени,до -62167219200 секунд,что эквивалентно &quot;0000-01-01T00:00:00Z&quot; или 0 григорианских секунд.</target>
        </trans-unit>
        <trans-unit id="a20bdc82e5703dd99f69be3ffeaf120ee97f50f4" translate="yes" xml:space="preserve">
          <source>Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;. If &lt;code&gt;index&lt;/code&gt; is out of bounds, the original &lt;code&gt;list&lt;/code&gt; is returned.</source>
          <target state="translated">Отрицательные индексы указывают на смещение от конца &lt;code&gt;list&lt;/code&gt; . Если &lt;code&gt;index&lt;/code&gt; выходит за границы, возвращается исходный &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4450fa2237a90a818e8d5b18c9055436f51758cb" translate="yes" xml:space="preserve">
          <source>Nerves fetches all dependencies and looks for the system specific deps</source>
          <target state="translated">Нервы извлекает все зависимости и ищет системные специфические депо</target>
        </trans-unit>
        <trans-unit id="0a5394a4bdb01b4c672f5bf8a58f03c03a747671" translate="yes" xml:space="preserve">
          <source>Nerves then clears the cache, forcing dependencies to be loaded again</source>
          <target state="translated">Нервы затем очищают кэш,заставляя зависимости быть загруженными снова.</target>
        </trans-unit>
        <trans-unit id="02f8888aa8ebd456306e0978a35197f74b636d4e" translate="yes" xml:space="preserve">
          <source>Nested data structures</source>
          <target state="translated">Вложенные структуры данных</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="230c22b07521849e4e1eb0ed24d083dc0b4e9329" translate="yes" xml:space="preserve">
          <source>Nesting a module inside another module affects the name of the nested module:</source>
          <target state="translated">Вложение модуля внутри другого модуля влияет на имя вложенного модуля:</target>
        </trans-unit>
        <trans-unit id="a0587b966ad1346723038626d25a39c4caf0fcf4" translate="yes" xml:space="preserve">
          <source>Nests the given document at the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">Размещает данный документ на заданном &lt;code&gt;level&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66de056dde6e1fb5274c22b3b843bcd5283eddba" translate="yes" xml:space="preserve">
          <source>New events may be added at any time in the future, therefore it is advised for the &lt;code&gt;trace/2&lt;/code&gt; function to have a &quot;catch-all&quot; clause.</source>
          <target state="translated">Новые события могут быть добавлены в любое время в будущем, поэтому рекомендуется, чтобы функция &lt;code&gt;trace/2&lt;/code&gt; имела предложение &quot;для всех&quot;.</target>
        </trans-unit>
        <trans-unit id="ac15dcab98b84e881f95ff7f13b6c27d1103008b" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">О новых выпусках объявляется в &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;списке рассылки объявлений&lt;/a&gt; только для чтения . Все выпуски безопасности &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;будут помечены тегом &lt;code&gt;[security]&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4091960ca8d66c5badd353d052ed80265508fa3" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%5Bsecurity%5D%7Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">О новых выпусках объявляется в &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;списке рассылки объявлений&lt;/a&gt; только для чтения . Все выпуски безопасности &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%5Bsecurity%5D%7Csort:date&quot;&gt;будут помечены тегом &lt;code&gt;[security]&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09050a709859e9c045fb8157c8d7649b286d2c98" translate="yes" xml:space="preserve">
          <source>Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators)</source>
          <target state="translated">Новейшие линии перед некоторыми операторами (например,операторами трубопроводов)и перед другими операторами (например,операторами сравнения)</target>
        </trans-unit>
        <trans-unit id="6de3ffff606ff25e1f43c0e5340bf371120e5de6" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for:</source>
          <target state="translated">Новые строки внутри блоков сохраняются,как и на входе,за исключением случаев:</target>
        </trans-unit>
        <trans-unit id="0c7d720a2e040b46c0d03386d11f05cbd66532dd" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for: 1) expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</source>
          <target state="translated">Новые строки внутри блоков сохраняются,как и на входе,за исключением случаев:1)выражения,которые берут несколько строк,всегда будут иметь пустую строку до и после и 2)пустые строки всегда сжимаются вместе в одну пустую строку</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">Следующие шаги</target>
        </trans-unit>
        <trans-unit id="750891f84c6b7eeddc41453bbdd8ec1255f11a42" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s discuss external and internal dependencies and how Mix helps us manage large codebases.</source>
          <target state="translated">Затем давайте обсудим внешние и внутренние зависимости и то, как Mix помогает нам управлять большими кодовыми базами.</target>
        </trans-unit>
        <trans-unit id="ec26ea6bcbb7c9f81e3f941cb690507a65daec00" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a feature central to Elixir, Processes, which allows us to write concurrent, parallel and distributed programs in an easy and understandable way.</source>
          <target state="translated">Далее мы рассмотрим центральную функцию Elixir, процессы, которая позволяет нам легко и понятно писать параллельные, параллельные и распределенные программы.</target>
        </trans-unit>
        <trans-unit id="41cb14263e20c4624e46c802b32ac0cf7c57a851" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Никакие вычисления не будут выполнены, пока мы не вызовем одну из функций &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; или не выполним &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac00c06be47df8189da7f703834d94ee1ef7d289" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Никакие вычисления не будут выполняться, пока мы не вызовем одну из функций &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; или не выполним &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="696cc484902450dc478328260fab02dcefae6c92" translate="yes" xml:space="preserve">
          <source>Non-map as 2nd argument in &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Не-карта как второй аргумент в &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6e83d3c9cef0e0783f020702595feef71f3f20e" translate="yes" xml:space="preserve">
          <source>Non-map as 2nd argument in &lt;a href=&quot;uri#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Non-map как второй аргумент в &lt;a href=&quot;uri#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="071e8151474691189ee1733bdecf01a3f3e2cb81" translate="yes" xml:space="preserve">
          <source>Non-qualified calls (local calls)</source>
          <target state="translated">Неквалифицированные звонки (местные звонки)</target>
        </trans-unit>
        <trans-unit id="53cb3754c560024cfd1bcc5260b860f30909000c" translate="yes" xml:space="preserve">
          <source>Non-qualified calls, such as &lt;code&gt;add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscore. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">Неквалифицированные вызовы, такие как &lt;code&gt;add(1, 2)&lt;/code&gt; , должны начинаться с подчеркивания или буквы Юникода, которая не должна быть прописной или заглавной. Вызов может продолжаться с использованием последовательности букв Юникода, цифр и подчеркивания. Звонки могут закончиться &lt;code&gt;?&lt;/code&gt; или &lt;code&gt;!&lt;/code&gt; , См. Формальную спецификацию в &lt;a href=&quot;unicode-syntax&quot;&gt;синтаксисе Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b40e406bdf08c15d5973db15d0796f73afa2bc3f" translate="yes" xml:space="preserve">
          <source>Normal color or intensity.</source>
          <target state="translated">Нормальный цвет или интенсивность.</target>
        </trans-unit>
        <trans-unit id="485af32f6fc1eec7f09815a3b0ede51b1a6f1fe7" translate="yes" xml:space="preserve">
          <source>Normalization forms &lt;code&gt;:nfkc&lt;/code&gt; and &lt;code&gt;:nfkd&lt;/code&gt; should not be blindly applied to arbitrary text. Because they erase many formatting distinctions, they will prevent round-trip conversion to and from many legacy character sets.</source>
          <target state="translated">Формы нормализации &lt;code&gt;:nfkc&lt;/code&gt; и &lt;code&gt;:nfkd&lt;/code&gt; не следует слепо применять к произвольному тексту. Поскольку они стирают многие различия форматирования, они предотвращают двустороннее преобразование во многие устаревшие наборы символов и обратно.</target>
        </trans-unit>
        <trans-unit id="522111b8eee38d26714335d6779562bdf0c0d1fc" translate="yes" xml:space="preserve">
          <source>Normalizes &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; filters to remove duplicates and keep precedence.</source>
          <target state="translated">Нормализует фильтры &lt;code&gt;include&lt;/code&gt; и &lt;code&gt;exclude&lt;/code&gt; для удаления дубликатов и сохранения приоритета.</target>
        </trans-unit>
        <trans-unit id="16efb8f5278c1947b297b82bf3c74d4bdac2d0d7" translate="yes" xml:space="preserve">
          <source>Normalizes an exception, converting Erlang exceptions to Elixir exceptions.</source>
          <target state="translated">Нормализует исключение,преобразовывая исключения из Erlang в исключения Elixir.</target>
        </trans-unit>
        <trans-unit id="ca65eca931881f00085a8c21384007ac72711fde" translate="yes" xml:space="preserve">
          <source>Normalizes and formats any throw/error/exit.</source>
          <target state="translated">Нормализует и форматирует любой бросок/ужас/выход.</target>
        </trans-unit>
        <trans-unit id="d040545513c396d6f00a60b9e02e4a5efcfb1b55" translate="yes" xml:space="preserve">
          <source>Normalizes and formats throw/errors/exits and stacktraces.</source>
          <target state="translated">Нормализует и форматирует метание/ошибки/выходы и стекировку.</target>
        </trans-unit>
        <trans-unit id="b4a7a922ef3ff8bef51868270a40e0256a78a3f8" translate="yes" xml:space="preserve">
          <source>Normally, repeating a module attribute will cause its value to be reassigned, but there are circumstances where you may want to &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;configure the module attribute&lt;/a&gt; so that its values are accumulated:</source>
          <target state="translated">Обычно повторение атрибута модуля приводит к переназначению его значения, но есть обстоятельства, при которых вы можете &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;настроить атрибут модуля&lt;/a&gt; таким образом, чтобы его значения накапливались:</target>
        </trans-unit>
        <trans-unit id="343f0ad200dae1f7321bdbca2861d3e1cec1c9d9" translate="yes" xml:space="preserve">
          <source>Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently.</source>
          <target state="translated">Не все выражения разрешены в охранной клаузуле,но только горстка из них.Это преднамеренный выбор.Таким образом,Эликсир (и Эрланг)могут гарантировать,что во время выполнения охранников не произойдет ничего плохого и нигде не произойдут мутации.Это также позволяет компилятору эффективно оптимизировать код,связанный с охранниками.</target>
        </trans-unit>
        <trans-unit id="63cc6d4577351584189eae49ee593bacbcaa1a41" translate="yes" xml:space="preserve">
          <source>Not allowed in guard clauses.</source>
          <target state="translated">Не разрешено в охранной клаузуле.</target>
        </trans-unit>
        <trans-unit id="7bbb840640c8ed788ab616e2c3f9edd23f97d87a" translate="yes" xml:space="preserve">
          <source>Not equal to operator.</source>
          <target state="translated">Не равна оператору.</target>
        </trans-unit>
        <trans-unit id="4f4ee146dc15494c81d4bd8a2a2759820080e7c5" translate="yes" xml:space="preserve">
          <source>Not framed or encircled.</source>
          <target state="translated">Не обрамлен и не окружен.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
