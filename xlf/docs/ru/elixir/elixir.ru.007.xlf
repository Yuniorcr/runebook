<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="1ac07c5c5d769c317e4ee149161ad79dd547886a" translate="yes" xml:space="preserve">
          <source>Function specifications</source>
          <target state="translated">Функциональные спецификации</target>
        </trans-unit>
        <trans-unit id="b1d1d233c6e9151086e11b68520f3c88ddfbfd71" translate="yes" xml:space="preserve">
          <source>FunctionClauseError</source>
          <target state="translated">FunctionClauseError</target>
        </trans-unit>
        <trans-unit id="59d46903ce38ffaa562b785d06c23f1fe1bd7e8e" translate="yes" xml:space="preserve">
          <source>FunctionClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">FunctionClauseError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="92264e6f77844330da044c87077edfa8088c62f8" translate="yes" xml:space="preserve">
          <source>Functionality to capture IO for testing.</source>
          <target state="translated">Функциональность для захвата ввода-вывода для тестирования.</target>
        </trans-unit>
        <trans-unit id="cd8664fa33698f4f620c47642dfd3e7413d9d1ec" translate="yes" xml:space="preserve">
          <source>Functionality to capture logs for testing.</source>
          <target state="translated">Функциональность для захвата журналов для тестирования.</target>
        </trans-unit>
        <trans-unit id="981f29fc45464a2117ff8d90e767ed44d91b4bb6" translate="yes" xml:space="preserve">
          <source>Functionality to render ANSI escape sequences.</source>
          <target state="translated">Функциональность для отображения ANSI-эвакуационных последовательностей.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="e331cf0e4275fe631ca417060a2f8f10e15a256d" translate="yes" xml:space="preserve">
          <source>Functions as keys</source>
          <target state="translated">Функции клавиш</target>
        </trans-unit>
        <trans-unit id="89eb4f89d38ca8beda2b5a23ae39ddc79a7e20dc" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="translated">Функции, определенные с помощью &lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; ,&lt;/a&gt; являются общедоступными и могут быть вызваны извне модуля, в котором они определены, как если бы они были определены с помощью &lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt; . Следовательно, &lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt; предназначен для расширения общедоступного API текущего модуля. Если вы хотите вызвать функцию, определенную в другом модуле, без использования ее полного имени модуля, используйте &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; чтобы сократить имя модуля, или используйте &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; ,&lt;/a&gt; чтобы иметь возможность вызывать функцию без имени модуля вообще.</target>
        </trans-unit>
        <trans-unit id="5b08dda4461297f97d2d935f4b6c312c57879282" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;kernel.specialforms#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="translated">Функции, определенные с помощью &lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; ,&lt;/a&gt; являются общедоступными и могут быть вызваны извне модуля, в котором они определены, как если бы они были определены с помощью &lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt; . Следовательно, &lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt; предназначен для расширения публичного API текущего модуля. Если вы хотите вызвать функцию, определенную в другом модуле, без использования ее полного имени модуля, используйте &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; чтобы сократить имя модуля, или используйте &lt;a href=&quot;kernel.specialforms#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; ,&lt;/a&gt; чтобы иметь возможность вызывать функцию вообще без имени модуля.</target>
        </trans-unit>
        <trans-unit id="5339f05867719070151c5f9212ec9691343c3dfd" translate="yes" xml:space="preserve">
          <source>Functions for creating and composing streams.</source>
          <target state="translated">Функции для создания и компоновки потоков.</target>
        </trans-unit>
        <trans-unit id="a92a126ef94a3c0fc6addeadb2500f9ae863a5be" translate="yes" xml:space="preserve">
          <source>Functions for interacting with the external world through ports.</source>
          <target state="translated">Функции для взаимодействия с внешним миром через порты.</target>
        </trans-unit>
        <trans-unit id="595e959d0a21e0d09abbd2c4fba3e39601ca613b" translate="yes" xml:space="preserve">
          <source>Functions for parsing and matching versions against requirements.</source>
          <target state="translated">Функции для разбора и сопоставления версий с требованиями.</target>
        </trans-unit>
        <trans-unit id="3f33806c59ce33f63b6d6eac23d2c5c308d0f02e" translate="yes" xml:space="preserve">
          <source>Functions for parsing command line arguments.</source>
          <target state="translated">Функции для разбора аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="be344dfaebcc716a7113914fb8d65d65aad9cdfb" translate="yes" xml:space="preserve">
          <source>Functions for working with floating-point numbers.</source>
          <target state="translated">Функции для работы с числами с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="4581129055260f253b0f9a10ce8940c3ae082007" translate="yes" xml:space="preserve">
          <source>Functions for working with integers.</source>
          <target state="translated">Функции для работы с целыми числами.</target>
        </trans-unit>
        <trans-unit id="ac038c429b16ac4da6a1c54de055fde121e86832" translate="yes" xml:space="preserve">
          <source>Functions for working with tuples.</source>
          <target state="translated">Функции для работы с кортежами.</target>
        </trans-unit>
        <trans-unit id="b012c35607b405f40246b484e5594c562e5fd7b1" translate="yes" xml:space="preserve">
          <source>Functions handling input/output (IO).</source>
          <target state="translated">Функции обработки входа/выхода (IO).</target>
        </trans-unit>
        <trans-unit id="120d9dcde7287a0528aec2f3d5f7e2e3f5cd376a" translate="yes" xml:space="preserve">
          <source>Functions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. &lt;code&gt;round/1&lt;/code&gt; identifies the function which is named &lt;code&gt;round&lt;/code&gt; and takes &lt;code&gt;1&lt;/code&gt; argument, whereas &lt;code&gt;round/2&lt;/code&gt; identifies a different (nonexistent) function with the same name but with an arity of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Функции в Elixir идентифицируются как по названию, так и по арности. Арность функции описывает количество аргументов, которые принимает функция. С этого момента мы будем использовать как имя функции, так и ее арность для описания функций в документации. &lt;code&gt;round/1&lt;/code&gt; идентифицирует функцию с именем &lt;code&gt;round&lt;/code&gt; и принимает &lt;code&gt;1&lt;/code&gt; аргумент, тогда как &lt;code&gt;round/2&lt;/code&gt; идентифицирует другую (несуществующую) функцию с тем же именем, но с арностью &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25a36a956214e3716b0faa690578d88a7316d2d1" translate="yes" xml:space="preserve">
          <source>Functions may be called when defining a module attribute, e.g.</source>
          <target state="translated">Функции могут вызываться при определении атрибута модуля,например</target>
        </trans-unit>
        <trans-unit id="18780274d7513230569a4133845253288a279bc6" translate="yes" xml:space="preserve">
          <source>Functions related to VM nodes.</source>
          <target state="translated">Функции,связанные с узлами ВМ.</target>
        </trans-unit>
        <trans-unit id="2ecc259041cce0328acd0d9abf2a78e6d378235f" translate="yes" xml:space="preserve">
          <source>Functions that return a boolean are named with a trailing question mark.</source>
          <target state="translated">Функции,возвращающие булевы,именуются со знаком вопроса.</target>
        </trans-unit>
        <trans-unit id="3abac8dc3938de4ae338c2914b66903b6d6216cf" translate="yes" xml:space="preserve">
          <source>Functions that work on (linked) lists.</source>
          <target state="translated">Функции,которые работают на (связанных)списках.</target>
        </trans-unit>
        <trans-unit id="d6d5cb54b94547b27cdb53ea8f156b69b0e891a7" translate="yes" xml:space="preserve">
          <source>Functions that work on sets.</source>
          <target state="translated">Функции,которые работают на съемочных площадках.</target>
        </trans-unit>
        <trans-unit id="c2171b2fcb9b756c41905c9675c92ab582aa67f4" translate="yes" xml:space="preserve">
          <source>Functions to format throw/catch/exit and exceptions.</source>
          <target state="translated">Функции форматирования throw/catch/exit и исключения.</target>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="translated">Дополнительная информация</target>
        </trans-unit>
        <trans-unit id="5d853e3f857a73da9a233be532bd545c49917d50" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="translated">Кроме того, &lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; может выйти из строя по одной из причин POSIX, описанных ниже:</target>
        </trans-unit>
        <trans-unit id="287db3c111ae0a4e9243da5209d0af176dba1c2f" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Translator.html&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; позволяет переводить сообщения, отправленные Erlang, в формат Elixir с помощью переводчиков. Переводчики могут быть добавлены в любое время с помощью &lt;a href=&quot;#add_translator/1&quot;&gt; &lt;code&gt;add_translator/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#remove_translator/1&quot;&gt; &lt;code&gt;remove_translator/1&lt;/code&gt; &lt;/a&gt; . Посетите &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Translator.html&quot;&gt; &lt;code&gt;Logger.Translator&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6d6208ba2074c10f21b8ca78cfba95b5238a4367" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;logger.translator&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; позволяет переводить сообщения, отправленные Erlang, в формат Elixir с помощью переводчиков. Переводчики могут быть добавлены в любое время с помощью &lt;a href=&quot;#add_translator/1&quot;&gt; &lt;code&gt;add_translator/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#remove_translator/1&quot;&gt; &lt;code&gt;remove_translator/1&lt;/code&gt; &lt;/a&gt; . Посетите &lt;a href=&quot;logger.translator&quot;&gt; &lt;code&gt;Logger.Translator&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f484c5ceae64ae91667e53e8fabec77fcc0eab91" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="translated">Кроме того, &lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; может выйти из строя по одной из причин POSIX, описанных ниже:</target>
        </trans-unit>
        <trans-unit id="186edc3e57a9d838cd0ada8549562af323cf60a5" translate="yes" xml:space="preserve">
          <source>Furthermore, a &lt;code&gt;:suspend&lt;/code&gt; call must always be followed by another call, eventually halting or continuing until the end.</source>
          <target state="translated">Кроме того, за вызовом &lt;code&gt;:suspend&lt;/code&gt; всегда должен следовать другой вызов, который в конечном итоге останавливается или продолжается до конца.</target>
        </trans-unit>
        <trans-unit id="c260bcd5ae1bdde9983d663eb92d5fcd82188b68" translate="yes" xml:space="preserve">
          <source>Furthermore, all applications listed in the &lt;code&gt;:applications&lt;/code&gt; key must be explicitly started before this application is. If not, &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; is returned, where &lt;code&gt;app&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">Кроме того, все приложения, перечисленные в ключе &lt;code&gt;:applications&lt;/code&gt; , должны быть явно запущены до запуска этого приложения. В противном случае возвращается &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; , где &lt;code&gt;app&lt;/code&gt; - это имя отсутствующего приложения.</target>
        </trans-unit>
        <trans-unit id="26e72ab288d2e99c66734f21d67d33280ac839df" translate="yes" xml:space="preserve">
          <source>Furthermore, backends can be configured via the &lt;a href=&quot;#configure_backend/2&quot;&gt;&lt;code&gt;configure_backend/2&lt;/code&gt;&lt;/a&gt; function which requires event handlers to handle calls of the following format:</source>
          <target state="translated">Кроме того, бэкенды можно настроить с помощью функции &lt;a href=&quot;#configure_backend/2&quot;&gt; &lt;code&gt;configure_backend/2&lt;/code&gt; ,&lt;/a&gt; которая требует, чтобы обработчики событий обрабатывали вызовы следующего формата:</target>
        </trans-unit>
        <trans-unit id="03045b903b2a4efd2fad95378e0e7416cbdc8700" translate="yes" xml:space="preserve">
          <source>Furthermore, because the state returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; can be written to text-based config files, it should be restricted only to simple data types, such as integers, strings, atoms, tuples, maps, and lists. Entries such as PIDs, references, and functions cannot be serialized.</source>
          <target state="translated">Кроме того, поскольку состояние, возвращаемое &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; ,&lt;/a&gt; может быть записано в текстовые файлы конфигурации, оно должно быть ограничено только простыми типами данных, такими как целые числа, строки, атомы, кортежи, карты и списки. Такие записи, как PID, ссылки и функции не могут быть сериализованы.</target>
        </trans-unit>
        <trans-unit id="e12a025bc34e52444d91865482fafd1b4bcb1476" translate="yes" xml:space="preserve">
          <source>Furthermore, if there is a failure when dispatching, due to a bad registration, dispatching will always fail and the registered process will not be notified. Therefore let's make sure we at least wrap and report those errors:</source>
          <target state="translated">Более того,если при отправке произошел сбой из-за плохой регистрации,отправка всегда будет неудачной и зарегистрированный процесс не будет уведомлен.Поэтому давайте,по крайней мере,завернем и сообщим об этих ошибках:</target>
        </trans-unit>
        <trans-unit id="3528255d6bac578fd573ffc86dde48159bf06389" translate="yes" xml:space="preserve">
          <source>Furthermore, metadata can be set per process with &lt;a href=&quot;#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Кроме того, метаданные могут быть установлены для каждого процесса с помощью &lt;a href=&quot;#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42529d32de08bd15f27eb4312be9cc48b68c13b2" translate="yes" xml:space="preserve">
          <source>Furthermore, they are composable because we can pipe many stream operations:</source>
          <target state="translated">Кроме того,они являются композитными,потому что мы можем прокладывать трубы для многих потоковых операций:</target>
        </trans-unit>
        <trans-unit id="3381a6c76f92b142faec11ca6cffe41f63f7d1f2" translate="yes" xml:space="preserve">
          <source>Furthermore, this module also presents the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, &quot;&amp;eacute;&quot; can be represented either as a single &quot;e with acute&quot; code point or as the letter &quot;e&quot; followed by a &quot;combining acute accent&quot; (two code points):</source>
          <target state="translated">Кроме того, этот модуль также представляет концепцию кластера графем (с этого момента именуемого графемами). Графемы могут состоять из нескольких кодовых точек, которые читатели могут воспринимать как один символ. Например, &amp;laquo;&amp;eacute;&amp;raquo; может быть представлено либо как одиночное &amp;laquo;e с острым ударением&amp;raquo;, либо как буква &amp;laquo;e&amp;raquo; с последующим &amp;laquo;комбинированным острым ударением&amp;raquo; (две кодовые точки):</target>
        </trans-unit>
        <trans-unit id="e25c00dc3897c6883dc4fe0f27096add3cc899e4" translate="yes" xml:space="preserve">
          <source>Furthermore, while &lt;code&gt;vm.args&lt;/code&gt; is static, you can use &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; to dynamically set VM options. For example, if you want to make sure the Erlang Distribution listens only on a given port known at runtime, you can set the following:</source>
          <target state="translated">Кроме того, хотя &lt;code&gt;vm.args&lt;/code&gt; статичен, вы можете использовать &lt;code&gt;env.sh&lt;/code&gt; и &lt;code&gt;env.bat&lt;/code&gt; для динамической установки параметров виртуальной машины. Например, если вы хотите убедиться, что дистрибутив Erlang прослушивает только заданный порт, известный во время выполнения, вы можете установить следующее:</target>
        </trans-unit>
        <trans-unit id="5c727a56b05e846df29f24d1daf2419df88964fa" translate="yes" xml:space="preserve">
          <source>Furthermore, with &lt;code&gt;@impl&lt;/code&gt; you can also make sure that you are implementing the &lt;strong&gt;correct&lt;/strong&gt; callbacks from the given behaviour in an explicit manner. For example, the following parser implements both &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;extensions&lt;/code&gt;, however thanks to a typo, &lt;code&gt;BADParser&lt;/code&gt; is implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;.</source>
          <target state="translated">Кроме того, с помощью &lt;code&gt;@impl&lt;/code&gt; вы также можете убедиться, что вы явно реализуете &lt;strong&gt;правильные&lt;/strong&gt; обратные вызовы из заданного поведения. Например, следующий синтаксический анализатор реализует как &lt;code&gt;parse&lt;/code&gt; и &lt;code&gt;extensions&lt;/code&gt; , однако из-за опечатки &lt;code&gt;BADParser&lt;/code&gt; реализует &lt;code&gt;parse/0&lt;/code&gt; вместо &lt;code&gt;parse/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae57bdba0f435d58b5575a45dc3b5fb6eb566cf8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can see that ExUnit prints a dot for each successful test and automatically randomizes tests too. Let&amp;rsquo;s make the test fail on purpose and see what happens.</source>
          <target state="translated">Кроме того, вы можете видеть, что ExUnit печатает точку для каждого успешного теста и автоматически рандомизирует тесты. Давайте намеренно провалим тест и посмотрим, что произойдет.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="26e2a4f823a98eca42ddcd53fd08f4fc5631d231" translate="yes" xml:space="preserve">
          <source>GenEvent</source>
          <target state="translated">GenEvent</target>
        </trans-unit>
        <trans-unit id="52f5451d0a005c032b5bd9e0f39e525431bee3e4" translate="yes" xml:space="preserve">
          <source>GenEvent &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenEvent &lt;small&gt;поведение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f1f7460d4b0df6c99ec51f3b8a78fab0ab241364" translate="yes" xml:space="preserve">
          <source>GenServer</source>
          <target state="translated">GenServer</target>
        </trans-unit>
        <trans-unit id="c41a8053324929c4122055404c6f497f28026d3e" translate="yes" xml:space="preserve">
          <source>GenServer - Elixir's Getting Started Guide</source>
          <target state="translated">GenServer-Руководство по началу работы с эликсиром.</target>
        </trans-unit>
        <trans-unit id="eca82733cdfcb3649b72cda06a30a922552032d8" translate="yes" xml:space="preserve">
          <source>GenServer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenServer &lt;small&gt;поведение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6b938fbce44ec15ef7cf28460d3d3a0b7b6e45c7" translate="yes" xml:space="preserve">
          <source>GenServer callbacks</source>
          <target state="translated">Обратные вызовы GenServer</target>
        </trans-unit>
        <trans-unit id="60a02fde0f842f29309800909cd00e720e3567d0" translate="yes" xml:space="preserve">
          <source>GenServers, as &lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;special processes&lt;/a&gt;, can be debugged using the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt;. Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes.</source>
          <target state="translated">GenServers, как &lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;особые процессы&lt;/a&gt; , можно отлаживать с помощью &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;модуля &lt;/a&gt; &lt;code&gt;:sys&lt;/code&gt; . С помощью различных ловушек этот модуль позволяет разработчикам анализировать состояние процесса и отслеживать системные события, происходящие во время его выполнения, такие как полученные сообщения, отправленные ответы и изменения состояния.</target>
        </trans-unit>
        <trans-unit id="8e2323fdcd5a3410a0abfe44a2176b41a6905683" translate="yes" xml:space="preserve">
          <source>GenStage</source>
          <target state="translated">GenStage</target>
        </trans-unit>
        <trans-unit id="92fde6e5cdcf695869dd7ece8642757211b43eff" translate="yes" xml:space="preserve">
          <source>General operators</source>
          <target state="translated">Генеральные операторы</target>
        </trans-unit>
        <trans-unit id="26811be9b4758ef85d12185318d245ac23863706" translate="yes" xml:space="preserve">
          <source>Generally speaking, filenames follow the &lt;code&gt;snake_case&lt;/code&gt; convention of the module they define. For example, &lt;code&gt;MyApp&lt;/code&gt; should be defined inside the &lt;code&gt;my_app.ex&lt;/code&gt; file. However, this is only a convention. At the end of the day, any filename can be used as they do not affect the compiled code in any way.</source>
          <target state="translated">Вообще говоря, имена файлов соответствуют соглашению &lt;code&gt;snake_case&lt;/code&gt; модуля, который они определяют. Например, &lt;code&gt;MyApp&lt;/code&gt; следует определить внутри файла &lt;code&gt;my_app.ex&lt;/code&gt; . Однако это только условность. В конце концов, можно использовать любое имя файла, поскольку они никоим образом не влияют на скомпилированный код.</target>
        </trans-unit>
        <trans-unit id="c4e59b7746a9b324c29c497d15613e18d32b2ec0" translate="yes" xml:space="preserve">
          <source>Generally speaking, the VM provides three time measurements:</source>
          <target state="translated">Вообще говоря,ВМ обеспечивает три измерения времени:</target>
        </trans-unit>
        <trans-unit id="ca8af8a9659e59f74154d217723284164924d905" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following files are available for customizing and configuring the running system:</source>
          <target state="translated">Вообще говоря,для настройки и конфигурирования работающей системы доступны следующие файлы:</target>
        </trans-unit>
        <trans-unit id="3853e87a8cfcd1a2826b60877e31dac6ddc354ee" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following module:</source>
          <target state="translated">Вообще говоря,следующий модуль:</target>
        </trans-unit>
        <trans-unit id="061ef8a9ec07ec601a5d20eb32a7f1c44a8e42be" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Создает узлы AST для заданного числа переменных обязательного аргумента с помощью &lt;a href=&quot;#var/2&quot;&gt; &lt;code&gt;Macro.var/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc78aa7ca2c1bb33572b17a7f6a38317ada6e607" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;macro#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Создает узлы AST для заданного количества переменных обязательного аргумента, используя &lt;a href=&quot;macro#var/2&quot;&gt; &lt;code&gt;Macro.var/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7914afeb7e94d7ae59d1fa355821ee7cf902a612" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the file contents.</source>
          <target state="translated">Генерирует определение функции из содержимого файла.</target>
        </trans-unit>
        <trans-unit id="6f28a47721aec6c56f1e4f3f4b046459fb2d421f" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the string.</source>
          <target state="translated">Генерирует определение функции из строки.</target>
        </trans-unit>
        <trans-unit id="3ed0a940ace5bee6a5a44c402162f201a0b4df48" translate="yes" xml:space="preserve">
          <source>Generates a macro suitable for use in guard expressions.</source>
          <target state="translated">Генерирует макрос,подходящий для использования в выражениях охраны.</target>
        </trans-unit>
        <trans-unit id="f89a805aedce9f9ff7961406995dc39283b2ba6f" translate="yes" xml:space="preserve">
          <source>Generates a private macro suitable for use in guard expressions.</source>
          <target state="translated">Генерирует частный макрос,подходящий для использования в выражениях охраны.</target>
        </trans-unit>
        <trans-unit id="d022a23ab156502d4cd22511016df2db248a08d8" translate="yes" xml:space="preserve">
          <source>Generates an AST node representing the variable given by the atoms &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">Создает узел AST, представляющий переменную, заданную атомами &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;context&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39399ecc6eafac75945962b0e75d0ddca1662821" translate="yes" xml:space="preserve">
          <source>Generates and returns an integer that is unique in the current runtime instance.</source>
          <target state="translated">Генерирует и возвращает целое число,уникальное в текущем экземпляре исполнения.</target>
        </trans-unit>
        <trans-unit id="1ad2ad1cc4377f21a03bdbb978029bcfeb4b2be2" translate="yes" xml:space="preserve">
          <source>Generates sample files for releases.</source>
          <target state="translated">Генерирует файлы-примеры для релизов.</target>
        </trans-unit>
        <trans-unit id="5539e5b1ece965094ab6defc81d9ab18e23afa6b" translate="yes" xml:space="preserve">
          <source>Generator expressions also support pattern matching on their left-hand side; all non-matching patterns are &lt;em&gt;ignored&lt;/em&gt;. Imagine that, instead of a range, we have a keyword list where the key is the atom &lt;code&gt;:good&lt;/code&gt; or &lt;code&gt;:bad&lt;/code&gt; and we only want to compute the square of the &lt;code&gt;:good&lt;/code&gt; values:</source>
          <target state="translated">Выражения генератора также поддерживают сопоставление с образцом в левой части; все несовпадающие шаблоны &lt;em&gt;игнорируются&lt;/em&gt; . Представьте себе, что вместо диапазона у нас есть список ключевых слов, в котором ключом является атом &lt;code&gt;:good&lt;/code&gt; или &lt;code&gt;:bad&lt;/code&gt; , и мы хотим вычислить только квадрат значений &lt;code&gt;:good&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="191fe63ca19d74852f4f8e0438c53a7c9f2fad58" translate="yes" xml:space="preserve">
          <source>Generators and filters</source>
          <target state="translated">Генераторы и фильтры</target>
        </trans-unit>
        <trans-unit id="b0f6dc9f4ecd590c4554fad6675925837bd4c03b" translate="yes" xml:space="preserve">
          <source>Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">Генераторы также могут использоваться для фильтрации, поскольку они удаляют любое значение, которое не соответствует шаблону в левой части &lt;code&gt;&amp;lt;-&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6a24751485eed378e568d03e0c111b00b1ca2106" translate="yes" xml:space="preserve">
          <source>Generic API for dictionaries.</source>
          <target state="translated">Общий API для словарей.</target>
        </trans-unit>
        <trans-unit id="f74ee225a82269c197985a3a933abeea994529f8" translate="yes" xml:space="preserve">
          <source>Generic API for sets.</source>
          <target state="translated">Общий API для наборов.</target>
        </trans-unit>
        <trans-unit id="342a929853c668da7bea5b8678d33654ddad6c44" translate="yes" xml:space="preserve">
          <source>Get all keys in the registry.</source>
          <target state="translated">Получите все ключи в реестре.</target>
        </trans-unit>
        <trans-unit id="15d4328951079f5b0c0d666980c03b21bfcda99d" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">Получает &lt;code&gt;filename&lt;/code&gt; и оценивает значения с помощью &lt;code&gt;bindings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e09423213d70047599b0fbcfb55a1d216ed0bceb" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">Получает &lt;code&gt;filename&lt;/code&gt; и генерирует выражение в кавычках, которое может быть вычислено Elixir или скомпилировано в функцию.</target>
        </trans-unit>
        <trans-unit id="11ce297c5b4ae23b4a6d01356ff4f29ad16e92ef" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from IO device &lt;code&gt;:stdio&lt;/code&gt;.</source>
          <target state="translated">Получает количество байтов от устройства ввода-вывода &lt;code&gt;:stdio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aef78a3cc35c0eec4a213bb06eb18783344f5a30" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">Получает количество байтов от &lt;code&gt;device&lt;/code&gt; ввода-вывода .</target>
        </trans-unit>
        <trans-unit id="464c10475e938f50f88715c59eebddca575584e5" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">Получает &lt;code&gt;source&lt;/code&gt; строки и оценивает значения с помощью &lt;code&gt;bindings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dce9c015f4c3caacfed76da20580dc567b349125" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">Получает &lt;code&gt;source&lt;/code&gt; строки и генерирует выражение в кавычках, которое может быть оценено Elixir или скомпилировано в функцию.</target>
        </trans-unit>
        <trans-unit id="77a47a00f7c2dc7431f1fd26f1f6a07c0721fc92" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested data structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Получает значение и обновляет вложенную структуру данных по заданному &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197bee8d14aabe7ecd2c0b8cae48772622a49701" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested structure.</source>
          <target state="translated">Получает значение и обновляет вложенную структуру.</target>
        </trans-unit>
        <trans-unit id="24fc43c308b364700a4a6b0c3e1ab5a6e0a34321" translate="yes" xml:space="preserve">
          <source>Gets a value from a nested structure.</source>
          <target state="translated">Получает значение из вложенной структуры.</target>
        </trans-unit>
        <trans-unit id="d58fdd9b7ac3d94d847bf7aa9396d3dd171627fa" translate="yes" xml:space="preserve">
          <source>Gets all compilation options from the code server.</source>
          <target state="translated">Получает все опции компиляции с сервера кода.</target>
        </trans-unit>
        <trans-unit id="9024c31b7473f5071a19da2642c254ca64dc5dcc" translate="yes" xml:space="preserve">
          <source>Gets all out of date dependencies, i.e. dependencies that are not available or have an invalid lock.</source>
          <target state="translated">Получает все устаревшие зависимости,т.е.те,которые недоступны или имеют недействительный замок.</target>
        </trans-unit>
        <trans-unit id="234783729be10591273a98e34996adf814d0af2b" translate="yes" xml:space="preserve">
          <source>Gets all values for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Получает все значения для определенного &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="337ee14d7455079870c96913a5344151625e3a44" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given anonymous function.</source>
          <target state="translated">Получает значение агента через данную анонимную функцию.</target>
        </trans-unit>
        <trans-unit id="cc4728d1ab03bf9e6b17772b1edd930d1db3e60f" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given function.</source>
          <target state="translated">Получает значение агента через данную функцию.</target>
        </trans-unit>
        <trans-unit id="7ccc56cd7cf9a38cdbce42e3b62827d91b072aca" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given anonymous function.</source>
          <target state="translated">Получает и обновляет состояние агента за одну операцию с помощью данной анонимной функции.</target>
        </trans-unit>
        <trans-unit id="8e2c80c38d6dbae8b378d7ea7441399c6dccc722" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given function.</source>
          <target state="translated">Получает и обновляет состояние агента за одну операцию с помощью данной функции.</target>
        </trans-unit>
        <trans-unit id="096ecee5005ebff9401bca63004bd1e4271d321f" translate="yes" xml:space="preserve">
          <source>Gets and updates the given key in a &lt;code&gt;container&lt;/code&gt; (a map, a keyword list, a struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">Получает и обновляет заданный ключ в &lt;code&gt;container&lt;/code&gt; (карта, список ключевых слов, структура, реализующая поведение &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3045c9e659f40b430ef7ec7c9aeaf689166b9794" translate="yes" xml:space="preserve">
          <source>Gets logging level for given module.</source>
          <target state="translated">Получает уровень протоколирования для данного модуля.</target>
        </trans-unit>
        <trans-unit id="87f10d7ccf1593e9cf40f6046fb73ed64260d10f" translate="yes" xml:space="preserve">
          <source>Gets preferred CLI environment for the task.</source>
          <target state="translated">Получает предпочитаемое CLI окружение для задачи.</target>
        </trans-unit>
        <trans-unit id="7ae776c4b4f195b1f36b2be173094733049a81b3" translate="yes" xml:space="preserve">
          <source>Gets the application for the given module.</source>
          <target state="translated">Получает приложение для данного модуля.</target>
        </trans-unit>
        <trans-unit id="a3186207a243a3a8619e9edb98a5c2ef194e1cbc" translate="yes" xml:space="preserve">
          <source>Gets the compilation options from the code server.</source>
          <target state="translated">Получает опции компиляции с сервера кода.</target>
        </trans-unit>
        <trans-unit id="224e4a732cfad5d058a4b2c327797e2a8a3c70d9" translate="yes" xml:space="preserve">
          <source>Gets the current time zone database.</source>
          <target state="translated">Получает базу данных текущего часового пояса.</target>
        </trans-unit>
        <trans-unit id="1f02096a4a7d41ef362ad56dd8a049be60b3048f" translate="yes" xml:space="preserve">
          <source>Gets the current working directory.</source>
          <target state="translated">Получает текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="8890fe17865bc33bcf4596b3f99ac374608009ec" translate="yes" xml:space="preserve">
          <source>Gets the directory for app.</source>
          <target state="translated">Получает каталог приложений.</target>
        </trans-unit>
        <trans-unit id="a0d384aa0e95a00ba787ac060a94eb0ed4d124ec" translate="yes" xml:space="preserve">
          <source>Gets the element at the zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">Получает элемент на основе нулевого &lt;code&gt;index&lt;/code&gt; в &lt;code&gt;tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff598d3e96b472f599f3428af98b3592d274ed04" translate="yes" xml:space="preserve">
          <source>Gets the given attribute from a module.</source>
          <target state="translated">Получает данный атрибут из модуля.</target>
        </trans-unit>
        <trans-unit id="c8c63585e58950af32a8c183dc234c637dbaf32b" translate="yes" xml:space="preserve">
          <source>Gets the list of requirements for the given task.</source>
          <target state="translated">Получает список требований к данной задаче.</target>
        </trans-unit>
        <trans-unit id="d86f7fa0e05aedae7d11fde1051d7047e16a9a64" translate="yes" xml:space="preserve">
          <source>Gets the message for an &lt;code&gt;exception&lt;/code&gt;.</source>
          <target state="translated">Получает сообщение об &lt;code&gt;exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d01b62b32cf43c3c1a84005842e75a1a8e58e56a" translate="yes" xml:space="preserve">
          <source>Gets the moduledoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Получает moduledoc для заданного &lt;code&gt;module&lt;/code&gt; задачи .</target>
        </trans-unit>
        <trans-unit id="b0dee9f2cb9d3796fb7a48d547b0b2fb9dd7e266" translate="yes" xml:space="preserve">
          <source>Gets the representation of any expression.</source>
          <target state="translated">Получает представление о любом выражении.</target>
        </trans-unit>
        <trans-unit id="aacf11051abfff1af3276a82387ff290a1040ef2" translate="yes" xml:space="preserve">
          <source>Gets the shortdoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Получает шортдок для заданного &lt;code&gt;module&lt;/code&gt; задачи .</target>
        </trans-unit>
        <trans-unit id="985fa8a31c64d1abf929750e6b62fcffb66d5d21" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">Получает значение для определенного &lt;code&gt;key&lt;/code&gt; на &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2670bc6c3a1d135ba35e9b1dd103fad35687d05" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Получает значение для определенного &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd6a6dd9113df059c87999c56f37603a31759691" translate="yes" xml:space="preserve">
          <source>Gets the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">Получает значение для данного ключа в контейнере (карту, список ключевых слов или структуру, реализующую поведение &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8bbd7b83737713a8cdf97c7e1c36926c053390c6" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass.</source>
          <target state="translated">Получает значение из &lt;code&gt;key&lt;/code&gt; и обновляет его за один проход.</target>
        </trans-unit>
        <trans-unit id="fb3ccba9209e0ea1faa8f2431f64136954cd5182" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Получает значение из &lt;code&gt;key&lt;/code&gt; и обновляет его за один проход. Повышает, если нет &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0a567720e720098dfad63e9f3f00ec9b4e381f" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Получает значение из &lt;code&gt;key&lt;/code&gt; и обновляет его. Повышает, если нет &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="efe79cf11081ba631fe2c7b862ea12b5382475d7" translate="yes" xml:space="preserve">
          <source>Getting started guide</source>
          <target state="translated">Руководство по началу работы</target>
        </trans-unit>
        <trans-unit id="621916a4cc49b2e7a0bda3364f0574a16aa3088a" translate="yes" xml:space="preserve">
          <source>Getting the head or the tail of an empty list throws an error:</source>
          <target state="translated">Получить голову или хвост пустого списка бросает ошибку:</target>
        </trans-unit>
        <trans-unit id="e8fbc4cd9319e626e1ccf7f2fcd4c822c8a5bcbe" translate="yes" xml:space="preserve">
          <source>Git options (&lt;code&gt;:git&lt;/code&gt;)</source>
          <target state="translated">Параметры Git ( &lt;code&gt;:git&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="37a8f2d730b24d981ab8fef7024613f2ad9ff494" translate="yes" xml:space="preserve">
          <source>Given a query string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt;, this function inserts each key-value pair in the query string as one entry in the given &lt;code&gt;map&lt;/code&gt;. Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped.</source>
          <target state="translated">Учитывая строку запроса в форме &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; , эта функция вставляет каждую пару ключ-значение в строку запроса как одну запись в данной &lt;code&gt;map&lt;/code&gt; . Ключи и значения в итоговой карте будут двоичными. Ключи и значения не будут экранированы в процентах.</target>
        </trans-unit>
        <trans-unit id="681fb9c4d5bed925cb73d7a24ad5b09e42d58e91" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements right before element &lt;code&gt;start_index&lt;/code&gt;, then takes &lt;code&gt;amount&lt;/code&gt; of elements, returning as many elements as possible if there are not enough elements.</source>
          <target state="translated">Учитывая &lt;code&gt;enumerable&lt;/code&gt; , он отбрасывает элементы прямо перед элементом &lt;code&gt;start_index&lt;/code&gt; , затем принимает &lt;code&gt;amount&lt;/code&gt; элементов, возвращая как можно больше элементов, если их недостаточно.</target>
        </trans-unit>
        <trans-unit id="9abc0837abc465b4295e2cadea49184fb4cb4c6a" translate="yes" xml:space="preserve">
          <source>Given an enumerable of enumerables, concatenates the &lt;code&gt;enumerables&lt;/code&gt; into a single list.</source>
          <target state="translated">Учитывая перечислимое количество перечислимых, объединяет &lt;code&gt;enumerables&lt;/code&gt; в один список.</target>
        </trans-unit>
        <trans-unit id="bae6dae6fe4dd518a111019522e41b9338d8da6a" translate="yes" xml:space="preserve">
          <source>Given charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt;&lt;code&gt;++&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Учитывая, что списки символов представлены как список целых чисел, можно также выполнить сопоставление префиксов для списков символов с помощью оператора конкатенации списков ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt; &lt;code&gt;++&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="318c3f40bcb691337e3daedb3433d603c4f8eada" translate="yes" xml:space="preserve">
          <source>Given items in an async stream are processed concurrently, doing &lt;code&gt;async_stream&lt;/code&gt; followed by &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt;&lt;code&gt;Enum.take/2&lt;/code&gt;&lt;/a&gt; may cause more items than requested to be processed. Let's see an example:</source>
          <target state="translated">Данные элементы в асинхронном потоке обрабатываются одновременно, выполнение &lt;code&gt;async_stream&lt;/code&gt; , за которым следует &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt; &lt;code&gt;Enum.take/2&lt;/code&gt; ,&lt;/a&gt; может вызвать большее количество элементов, чем было запрошено для обработки. Посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="6c7afd283b9c25ebdc6e3a55a4b68a33a103e346" translate="yes" xml:space="preserve">
          <source>Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as:</source>
          <target state="translated">При заказе не гарантируется,также не рекомендуется использовать шаблонное совпадение в списках ключевых слов.Например,такая функция как:</target>
        </trans-unit>
        <trans-unit id="b078a81a2e280f99fedc2be9c6836b96581c1c0d" translate="yes" xml:space="preserve">
          <source>Given that strings are binaries, we can also pattern match on strings:</source>
          <target state="translated">Учитывая,что строки являются двоичными,мы также можем сопоставлять их по шаблону:</target>
        </trans-unit>
        <trans-unit id="f3677630682772650b101e7db35f800ba5311f07" translate="yes" xml:space="preserve">
          <source>Given the anonymous function:</source>
          <target state="translated">Учитывая анонимную функцию:</target>
        </trans-unit>
        <trans-unit id="36db5dd9f19115507b73ab3e8430b31b4965279c" translate="yes" xml:space="preserve">
          <source>Given this function halts compilation, use it carefully. In particular, avoid using it to guess which modules are in the system. Overuse of this function can also lead to deadlocks, where two modules check at the same time if the other is compiled. This returns a specific unavailable error code, where we cannot successfully verify a module is available or not.</source>
          <target state="translated">Учитывая,что эта функция останавливает компиляцию,используйте ее осторожно.В частности,избегайте ее использования для того,чтобы угадать,какие модули находятся в системе.Чрезмерное использование этой функции также может привести к возникновению дедлоков,когда два модуля проверяют одновременно,не скомпилирован ли другой.Это возвращает определенный недоступный код ошибки,где мы не можем успешно проверить наличие или отсутствие модуля.</target>
        </trans-unit>
        <trans-unit id="41535529b54e3895b904cb50fa535652b69f1b5f" translate="yes" xml:space="preserve">
          <source>Given this is the default calendar used by Elixir, it has one difference compared to the ISO8601 specification in that it allows a whitespace instead of &lt;code&gt;T&lt;/code&gt; as a seperator between date and times both when parsing and formatting. Strict formatting can be done by using the &lt;code&gt;to_iso8601&lt;/code&gt; found in &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Учитывая, что это календарь по умолчанию, используемый Elixir, он имеет одно отличие от спецификации ISO8601 в том, что он позволяет использовать пробел вместо &lt;code&gt;T&lt;/code&gt; в качестве разделителя между датой и временем как при синтаксическом анализе, так и при форматировании. Строгое форматирование может быть сделано с помощью &lt;code&gt;to_iso8601&lt;/code&gt; найденной в &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1d5229cdbf0e79ed32d47a41c7e0424cb85df8" translate="yes" xml:space="preserve">
          <source>Given three vertices, find the shortest path from the first to the last.</source>
          <target state="translated">Учитывая три вершины,найдите кратчайший путь от первой до последней.</target>
        </trans-unit>
        <trans-unit id="6e14f8c349b7ea44c21dc9a2bb0f69f3be68850a" translate="yes" xml:space="preserve">
          <source>Giving a path is useful to let Elixir know that only certain paths in a large configuration are compile time dependent.</source>
          <target state="translated">Предоставление пути полезно для того,чтобы Elixir знал,что только определенные пути в большой конфигурации зависят от времени компиляции.</target>
        </trans-unit>
        <trans-unit id="eb698f945d96926994811a109269c63fcc2c2588" translate="yes" xml:space="preserve">
          <source>Giving an argument that does not match any of the clauses raises an error.</source>
          <target state="translated">Предоставление аргумента,который не соответствует ни одному из пунктов,приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="6962fecddec56252c7eb488f5a99ecedf3c0d3ff" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting a &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; given by &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">&lt;code&gt;doc1&lt;/code&gt; два документа ( doc1 и &lt;code&gt;doc2&lt;/code&gt; ), вставляя между ними &lt;a href=&quot;#flex_break/1&quot;&gt; &lt;code&gt;flex_break/1&lt;/code&gt; ,&lt;/a&gt; заданный &lt;code&gt;break_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a76459e82605f9a2f2ab9a4295c080bd4d42cf0" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting the given break &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">&lt;code&gt;doc1&lt;/code&gt; два документа ( doc1 и &lt;code&gt;doc2&lt;/code&gt; ), вставляя между ними заданный разрыв &lt;code&gt;break_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c91ff6d61d31b9a76a19683905991f494f51c9d2" translate="yes" xml:space="preserve">
          <source>Good! Now &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; requests are all routed to the approriate node. Let&amp;rsquo;s also make sure that when a new bucket is created it ends up on the correct node. Replace the &lt;code&gt;run/1&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt;, the one that matches the &lt;code&gt;:create&lt;/code&gt; command, with the following:</source>
          <target state="translated">Хорошо! Теперь все запросы &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; направляются на соответствующий узел. Давайте также позаботимся о том, чтобы при создании нового сегмента он попал на правильный узел. Замените функцию &lt;code&gt;run/1&lt;/code&gt; в &lt;code&gt;KVServer.Command&lt;/code&gt; , которая соответствует команде &lt;code&gt;:create&lt;/code&gt; , следующим:</target>
        </trans-unit>
        <trans-unit id="8bb7c805f7de70037ed1803ff9f5f16721be43e5" translate="yes" xml:space="preserve">
          <source>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider &quot;ch&quot; as a single character. However, since this information depends on the locale, it is not taken into account by this module.</source>
          <target state="translated">Граммы также могут быть двумя символами,которые интерпретируются как один в некоторых языках.Например,в некоторых языках &quot;ch&quot; может рассматриваться как один символ.Однако,так как эта информация зависит от локали,она не учитывается данным модулем.</target>
        </trans-unit>
        <trans-unit id="e786d50d22654cd173f8d3b62a2460772b2e8c56" translate="yes" xml:space="preserve">
          <source>Greater-than operator.</source>
          <target state="translated">Больше,чем оператор.</target>
        </trans-unit>
        <trans-unit id="7dae2a91a27873b3eab21af62f86fd6dd15e3eeb" translate="yes" xml:space="preserve">
          <source>Greater-than or equal to operator.</source>
          <target state="translated">Больше или равна оператору.</target>
        </trans-unit>
        <trans-unit id="d6bc40a0f5a48e1cfea2b0fd464f5f6f31570bd2" translate="yes" xml:space="preserve">
          <source>Guard clauses can also be given to the match:</source>
          <target state="translated">Охранные клаузулы также могут быть даны на матч:</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="142ddd2f53edae494acde2b741cff19a0327b789" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others.</source>
          <target state="translated">Охрана-это способ дополнения шаблона,совпадающего с более сложными проверками.Они разрешены в предопределенном наборе конструкций,где допустимо совпадение по образцам,таких как определения функций,регистры и другие.</target>
        </trans-unit>
        <trans-unit id="cd32950893cbba732683c916fdaa3f7721bfbc75" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed.</source>
          <target state="translated">Охрана-это способ дополнения шаблона,совпадающего с более сложными проверками.Они разрешены в предопределенном наборе конструкций,где допускается подгонка деталей.</target>
        </trans-unit>
        <trans-unit id="f51e7c885b3316cf13c1a89511ab0220e376f9ff" translate="yes" xml:space="preserve">
          <source>Guards can be used in patterns as well:</source>
          <target state="translated">Охрана также может быть использована в шаблонах:</target>
        </trans-unit>
        <trans-unit id="da2c059bdbc9e50988efa18e14c41ef3278c8017" translate="yes" xml:space="preserve">
          <source>Guards can be used to restrict type variables given as arguments to the function.</source>
          <target state="translated">Охрана может быть использована для ограничения переменных типа,приводимых в качестве аргументов функции.</target>
        </trans-unit>
        <trans-unit id="3d4e06fce5066ed597d68206744c09c068cc26cf" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; keyword, which is followed by a boolean expression (we will define the grammar of guards more formally later on).</source>
          <target state="translated">Стражи начинаются с ключевого слова &lt;code&gt;when&lt;/code&gt; , за которым следует логическое выражение (позже мы определим грамматику охранников более формально).</target>
        </trans-unit>
        <trans-unit id="00d836e676cdbf32c1fff6bdfc1dd47899a371d2" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns &lt;code&gt;true&lt;/code&gt;. Multiple boolean conditions can be combined with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#and/2&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#or/2&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt; operators.</source>
          <target state="translated">Охранники начинаются с оператора &lt;code&gt;when&lt;/code&gt; , за которым следует защитное выражение. Предложение будет выполнено тогда и только тогда, когда выражение защиты вернет &lt;code&gt;true&lt;/code&gt; . Несколько логических условий можно комбинировать с операторами &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#and/2&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#or/2&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="d645d6ef806b49668fa2c86b98204a1d0cbd439f" translate="yes" xml:space="preserve">
          <source>Guide: Metaprogramming</source>
          <target state="translated">Руководство:Метапрограммирование</target>
        </trans-unit>
        <trans-unit id="fc6d12560c986e5d173ff3f215b4fdc7dd78c449" translate="yes" xml:space="preserve">
          <source>Guide: Mix &amp;amp; OTP</source>
          <target state="translated">Руководство: Mix &amp;amp; OTP</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="1e562d47149e19ed5cad18f5c03b2789d427f02b" translate="yes" xml:space="preserve">
          <source>Handles assigns in quoted expressions.</source>
          <target state="translated">Ручки присваиваются в цитируемых выражениях.</target>
        </trans-unit>
        <trans-unit id="ddf833f3c5194a503cfbad70c99e1db7094771aa" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~C&lt;/code&gt; for charlists.</source>
          <target state="translated">Обрабатывает сигилу &lt;code&gt;~C&lt;/code&gt; для чарлистов.</target>
        </trans-unit>
        <trans-unit id="fb3ba3c1a95dbc32cd091a7bf8625e909b666103" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~D&lt;/code&gt; for dates.</source>
          <target state="translated">Обрабатывает сигилу &lt;code&gt;~D&lt;/code&gt; для дат.</target>
        </trans-unit>
        <trans-unit id="982325391ef0142622780269edf1546f73b262a3" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~N&lt;/code&gt; for naive date times.</source>
          <target state="translated">Обрабатывает сигил &lt;code&gt;~N&lt;/code&gt; для наивных дат.</target>
        </trans-unit>
        <trans-unit id="61bcb2084c564ad8723451ec89fc1bbe6d5b39d6" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~R&lt;/code&gt; for regular expressions.</source>
          <target state="translated">Обрабатывает сигил &lt;code&gt;~R&lt;/code&gt; для регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="ee65de02481e36f7795050fdcbac43c76b0097f0" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~S&lt;/code&gt; for strings.</source>
          <target state="translated">Обрабатывает сигил &lt;code&gt;~S&lt;/code&gt; для строк.</target>
        </trans-unit>
        <trans-unit id="021700491c061be385dd02126ab31483e68097c1" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~T&lt;/code&gt; for times.</source>
          <target state="translated">Обрабатывает сигилу &lt;code&gt;~T&lt;/code&gt; раз.</target>
        </trans-unit>
        <trans-unit id="2b0a2c1b8e946dd36ec07ae3f98021a22faab492" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обрабатывает сигил &lt;code&gt;~U&lt;/code&gt; для создания &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; в формате UTC .</target>
        </trans-unit>
        <trans-unit id="edea9c3c145eb520a4b09a9b6e8ef37e6cb7464e" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обрабатывает сигилу &lt;code&gt;~U&lt;/code&gt; чтобы создать &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; время в формате UTC .</target>
        </trans-unit>
        <trans-unit id="3f52b59decaffdf3dbd50c018dec832cff60ddfc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~W&lt;/code&gt; for list of words.</source>
          <target state="translated">Обрабатывает сигилу &lt;code&gt;~W&lt;/code&gt; для списка слов.</target>
        </trans-unit>
        <trans-unit id="3f9e6bb6b9375b71e2dd3e6c31781d8b7de4f2bc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~c&lt;/code&gt; for charlists.</source>
          <target state="translated">Ручки сигилу &lt;code&gt;~c&lt;/code&gt; для charlists.</target>
        </trans-unit>
        <trans-unit id="e93b408b9addb240b0d8fec06f1cc6fd6483cad8" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~r&lt;/code&gt; for regular expressions.</source>
          <target state="translated">Обрабатывает сигил &lt;code&gt;~r&lt;/code&gt; для регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="5c8529f6bd35c204f46a458ef8fe33f88fe57b75" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~s&lt;/code&gt; for strings.</source>
          <target state="translated">Рукоятки сигила &lt;code&gt;~s&lt;/code&gt; для строк.</target>
        </trans-unit>
        <trans-unit id="812d965b782f5a4cdb2aa6ca4e03193e8426a888" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~w&lt;/code&gt; for list of words.</source>
          <target state="translated">Ручки сигила &lt;code&gt;~w&lt;/code&gt; для списка слов.</target>
        </trans-unit>
        <trans-unit id="7849ebf167a97ce455aff4c671cafc34086c2adc" translate="yes" xml:space="preserve">
          <source>Happy coding!</source>
          <target state="translated">Счастливого кодирования!</target>
        </trans-unit>
        <trans-unit id="e74fbc6484fa15dc5415ec3ea61b85c17ae16042" translate="yes" xml:space="preserve">
          <source>HashDict</source>
          <target state="translated">HashDict</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b4f9c2553efc8e434d9a14c06152b8e6c5d5f2d5" translate="yes" xml:space="preserve">
          <source>Help for all of those functions can be consulted directly from the command line using the &lt;a href=&quot;#h/1&quot;&gt;&lt;code&gt;h/1&lt;/code&gt;&lt;/a&gt; helper itself. Try:</source>
          <target state="translated">Справку по всем этим функциям можно получить непосредственно из командной строки с помощью самого помощника &lt;a href=&quot;#h/1&quot;&gt; &lt;code&gt;h/1&lt;/code&gt; &lt;/a&gt; . Пытаться:</target>
        </trans-unit>
        <trans-unit id="3dc137e03814f2f8c65320b0dffc705dd74522ae" translate="yes" xml:space="preserve">
          <source>Helper functions for formatting and the formatting protocols.</source>
          <target state="translated">Функции помощника для форматирования и протоколов форматирования.</target>
        </trans-unit>
        <trans-unit id="6807f0882791439924cfe88b4665c74673dc2b7c" translate="yes" xml:space="preserve">
          <source>Helper module</source>
          <target state="translated">вспомогательный модуль</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="c42a25368aea44b1d8b6e2caeca032b5ca554730" translate="yes" xml:space="preserve">
          <source>Helpers for defining test cases.</source>
          <target state="translated">Помощники для определения тестовых случаев.</target>
        </trans-unit>
        <trans-unit id="d5c884b844c2ebd809f20b51b9edc72b238135da" translate="yes" xml:space="preserve">
          <source>Hence the name &quot;flex&quot;. they are more flexible when it comes to the document fitting. On the other hand, they are more expensive since each break needs to be re-evaluated.</source>
          <target state="translated">Отсюда и название &quot;flex&quot;.они более гибкие,когда речь идет о подгонке документов.С другой стороны,они дороже,так как каждый перерыв требует переоценки.</target>
        </trans-unit>
        <trans-unit id="b1aef6d0ceaad34efbe32b0b7338abfa12a31756" translate="yes" xml:space="preserve">
          <source>Here are some examples of working with different types and modifiers:</source>
          <target state="translated">Приведем несколько примеров работы с различными типами и модификаторами:</target>
        </trans-unit>
        <trans-unit id="42db1d3d86baee9f18579aec4c71f6475b37d168" translate="yes" xml:space="preserve">
          <source>Here are some invalid ones:</source>
          <target state="translated">Вот несколько недействительных:</target>
        </trans-unit>
        <trans-unit id="11442cf4a8b2c1cb2e42c80414e3bc9baaa0cb80" translate="yes" xml:space="preserve">
          <source>Here are some valid paths:</source>
          <target state="translated">Вот несколько правильных путей:</target>
        </trans-unit>
        <trans-unit id="352db02f68b7960ade3f7f5b302deb2325291825" translate="yes" xml:space="preserve">
          <source>Here is a better implementation of our Stack module:</source>
          <target state="translated">Вот лучшая реализация нашего модуля Стек:</target>
        </trans-unit>
        <trans-unit id="d3dfbcd6177f2eeaaed92da7d1fa4ce5d577524c" translate="yes" xml:space="preserve">
          <source>Here is a rundown of the life-cycle of the test process:</source>
          <target state="translated">Вот краткое описание жизненного цикла процесса тестирования:</target>
        </trans-unit>
        <trans-unit id="8b69e6d654ffc481049b79c6ad68ac13e993788a" translate="yes" xml:space="preserve">
          <source>Here is an example of a &lt;code&gt;.formatter.exs&lt;/code&gt; file that works as a starting point:</source>
          <target state="translated">Вот пример файла &lt;code&gt;.formatter.exs&lt;/code&gt; , который работает как отправная точка:</target>
        </trans-unit>
        <trans-unit id="b7fa9405686c3918f67bf3e27b8a6096e14cbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of how to configure the &lt;code&gt;:console&lt;/code&gt; backend in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">Вот пример того , как настроить &lt;code&gt;:console&lt;/code&gt; бэкенд в &lt;code&gt;config/config.exs&lt;/code&gt; файла:</target>
        </trans-unit>
        <trans-unit id="b3a43eba555f0c13a34172cd9439caffcb152633" translate="yes" xml:space="preserve">
          <source>Here is an example on how we mimic an echo server from the command line:</source>
          <target state="translated">Вот пример того,как мы имитируем эхо-сервер из командной строки:</target>
        </trans-unit>
        <trans-unit id="3edae206369380098d80617af169ddbd0abfffd5" translate="yes" xml:space="preserve">
          <source>Here is an example that traverses the list dropping even numbers and multiplying odd numbers by 2:</source>
          <target state="translated">Вот пример,который проходит через список,опуская четные числа и умножая нечетные числа на 2:</target>
        </trans-unit>
        <trans-unit id="719c74f661d33fc8656d2bb7f5d2aed1ea13f147" translate="yes" xml:space="preserve">
          <source>Here is an example where all keys match:</source>
          <target state="translated">Вот пример,где все ключи совпадают:</target>
        </trans-unit>
        <trans-unit id="050a27ec30c2a26d404808ec75322f708750e58e" translate="yes" xml:space="preserve">
          <source>Here is the full echo server implementation:</source>
          <target state="translated">Вот полная реализация эхо-сервера:</target>
        </trans-unit>
        <trans-unit id="6f777b3d9caee14d91c8f30553a83cea3e2dc561" translate="yes" xml:space="preserve">
          <source>Here is the updated code for the &lt;code&gt;TestCase&lt;/code&gt; module:</source>
          <target state="translated">Вот обновленный код модуля &lt;code&gt;TestCase&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a22b63cc9c9e1b1cf8079d3829c10b45935571fc" translate="yes" xml:space="preserve">
          <source>Here is when a subset of the keys match:</source>
          <target state="translated">Вот когда подмножество ключей совпадает:</target>
        </trans-unit>
        <trans-unit id="84bb9c9b475cb5ae8d6aa130c97b79761a44437b" translate="yes" xml:space="preserve">
          <source>Here we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and &lt;em&gt;mapping&lt;/em&gt; over it is known as a &lt;em&gt;map algorithm&lt;/em&gt;.</source>
          <target state="translated">Здесь мы использовали рекурсию для обхода списка, удвоения каждого элемента и возврата нового списка. Процесс создания списка и &lt;em&gt;сопоставления&lt;/em&gt; с ним известен как &lt;em&gt;алгоритм карты&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5c22f5f67bc89de4473d36dd5d40a24915681d3c" translate="yes" xml:space="preserve">
          <source>Here we will use Agents, and create a module named &lt;code&gt;KV.Bucket&lt;/code&gt;, responsible for storing our key-value entries in a way that allows them to be read and modified by other processes.</source>
          <target state="translated">Здесь мы будем использовать агентов и создадим модуль с именем &lt;code&gt;KV.Bucket&lt;/code&gt; , отвечающий за хранение наших записей ключ-значение таким образом, чтобы их могли читать и изменять другие процессы.</target>
        </trans-unit>
        <trans-unit id="3e5a3bc41bc733073ea1b7c356d6fc16ff9a31eb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how we could write the same &lt;code&gt;Utility.type/1&lt;/code&gt; functionality as a protocol:</source>
          <target state="translated">Вот как мы могли бы написать ту же функциональность &lt;code&gt;Utility.type/1&lt;/code&gt; в качестве протокола:</target>
        </trans-unit>
        <trans-unit id="4a4f491539740358c0862f6ed0caff8dd3eb4c91" translate="yes" xml:space="preserve">
          <source>Here, 257 in base 2 would be represented as &lt;code&gt;100000001&lt;/code&gt;, but since we have reserved only 8 bits for its representation (by default), the left-most bit is ignored and the value becomes truncated to &lt;code&gt;00000001&lt;/code&gt;, or simply &lt;code&gt;1&lt;/code&gt; in decimal.</source>
          <target state="translated">Здесь 257 в базе 2 будет представлено как &lt;code&gt;100000001&lt;/code&gt; , но поскольку мы зарезервировали только 8 бит для его представления (по умолчанию), крайний левый бит игнорируется, и значение становится усеченным до &lt;code&gt;00000001&lt;/code&gt; или просто &lt;code&gt;1&lt;/code&gt; в десятичном виде.</target>
        </trans-unit>
        <trans-unit id="bbd25c9ac39901e5a89af9e9cc14cd5e96101d55" translate="yes" xml:space="preserve">
          <source>Here, the arrow (&lt;code&gt;&amp;lt;--&lt;/code&gt;) indicates the &lt;strong&gt;marked&lt;/strong&gt; function - the function described by this paragraph. You also see its immediate callers (above) and called functions (below).</source>
          <target state="translated">Здесь стрелка ( &lt;code&gt;&amp;lt;--&lt;/code&gt; ) указывает &lt;strong&gt;отмеченную&lt;/strong&gt; функцию - функцию, описанную в этом параграфе. Вы также видите его непосредственных вызывающих (вверху) и вызываемых функций (внизу).</target>
        </trans-unit>
        <trans-unit id="f90a2dd87f0e0e5b3fc18bbdd374ab3f255b75b6" translate="yes" xml:space="preserve">
          <source>Hex options (&lt;code&gt;:hex&lt;/code&gt;)</source>
          <target state="translated">Параметры Hex ( &lt;code&gt;:hex&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="778ad2f9bcae03814f9abdf00cda4d6b0dd5b58c" translate="yes" xml:space="preserve">
          <source>Hexadecimals and Unicode code points will be escaped if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?x&lt;/code&gt;. Unicode code points if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?u&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатиричные и кодовые точки Unicode будут экранированы , если функция карты возвращает &lt;code&gt;true&lt;/code&gt; для &lt;code&gt;?x&lt;/code&gt; . Кодовые точки Unicode , если функция возвращает карту &lt;code&gt;true&lt;/code&gt; для &lt;code&gt;?u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26e85f63826bec68a04b03d81896950af6108f8b" translate="yes" xml:space="preserve">
          <source>Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial.</source>
          <target state="translated">Спячку не следует использовать агрессивно,так как слишком много времени можно потратить на сбор мусора.Обычно его следует использовать только тогда,когда сообщение не ожидается в ближайшее время и минимизация памяти процесса окажется полезной.</target>
        </trans-unit>
        <trans-unit id="86c45c0195b718d67c0a438292af56b71a044d2f" translate="yes" xml:space="preserve">
          <source>Hiding Internal Modules and Functions</source>
          <target state="translated">Скрытие внутренних модулей и функций</target>
        </trans-unit>
        <trans-unit id="0ea7288fabe36d1374b87e85268bd81849d9bced" translate="yes" xml:space="preserve">
          <source>History size</source>
          <target state="translated">Размер истории</target>
        </trans-unit>
        <trans-unit id="d5f481ffbf704bd71ae3b341524ffae254c4f8b3" translate="yes" xml:space="preserve">
          <source>Hot Code Upgrades</source>
          <target state="translated">Обновление горячего кода</target>
        </trans-unit>
        <trans-unit id="fc314201ff6cdd49c00bb54c2d3a38dc7360de1d" translate="yes" xml:space="preserve">
          <source>Hot code swapping</source>
          <target state="translated">Обмен &quot;горячими&quot; кодами</target>
        </trans-unit>
        <trans-unit id="5a2b9c570ab736a0a992067e06ddc44051493496" translate="yes" xml:space="preserve">
          <source>Hour using a 12-hour clock</source>
          <target state="translated">Час использования 12-часовых часов</target>
        </trans-unit>
        <trans-unit id="0b231acab966b52e86353b589bad7d81125cc30e" translate="yes" xml:space="preserve">
          <source>Hour using a 24-hour clock</source>
          <target state="translated">Час использования 24-часовой</target>
        </trans-unit>
        <trans-unit id="3935f3cf215c2daeec7c25cef51c0a03f6190f58" translate="yes" xml:space="preserve">
          <source>How can this line fail if we just created the bucket in the previous line?</source>
          <target state="translated">Как эта строка может выйти из строя,если мы только что создали ведро в предыдущей строке?</target>
        </trans-unit>
        <trans-unit id="04ccc44e58210facfedf9edfba2604fce3cfc2e4" translate="yes" xml:space="preserve">
          <source>How to supervise</source>
          <target state="translated">Как контролировать</target>
        </trans-unit>
        <trans-unit id="7cdfd34c64026a6f64366847c32473d397480980" translate="yes" xml:space="preserve">
          <source>However Elixir introduces a syntax sugar where the keywords above may be written as follows:</source>
          <target state="translated">Однако Elixir вводит синтаксис сахара,где ключевые слова,приведенные выше,могут быть написаны следующим образом:</target>
        </trans-unit>
        <trans-unit id="7d4e3b65932901a80bd0c8daa5e66bd16aedca07" translate="yes" xml:space="preserve">
          <source>However, a quoted variable is represented as:</source>
          <target state="translated">Тем не менее,котируемая переменная представлена как:</target>
        </trans-unit>
        <trans-unit id="057b67626d2f5f52a384b7c48714343f2812737b" translate="yes" xml:space="preserve">
          <source>However, after our project is compiled using a tool like Mix, we know all modules that have been defined, including protocols and their implementations. This way, the protocol can be consolidated into a very simple and fast dispatch module.</source>
          <target state="translated">Однако,после компиляции нашего проекта с помощью такого инструмента,как Mix,мы знаем все модули,которые были определены,включая протоколы и их реализацию.Таким образом,протокол может быть консолидирован в очень простой и быстрый модуль диспетчеризации.</target>
        </trans-unit>
        <trans-unit id="30b8c9087b77b2def4f60524eab486ec77b7882f" translate="yes" xml:space="preserve">
          <source>However, do not provide &lt;code&gt;__using__/1&lt;/code&gt; if all it does is to import, alias or require the module itself. For example, avoid this:</source>
          <target state="translated">Однако не предоставляйте &lt;code&gt;__using__/1&lt;/code&gt; если все, что он делает, - это импорт, псевдоним или требование самого модуля. Например, избегайте этого:</target>
        </trans-unit>
        <trans-unit id="ca0de7a0e18a5854d7abeb96c012e778937c81fc" translate="yes" xml:space="preserve">
          <source>However, for the tests in &lt;code&gt;KV.RouterTest&lt;/code&gt;, we effectively need two nodes in our routing table. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</source>
          <target state="translated">Однако для тестов в &lt;code&gt;KV.RouterTest&lt;/code&gt; нам фактически нужны два узла в нашей таблице маршрутизации. Для этого мы напишем блок настройки, который запускается перед всеми тестами в этом файле. Блок настройки изменит среду приложения и вернет ее обратно, как только мы закончим, например:</target>
        </trans-unit>
        <trans-unit id="82776ff5a87946e16cbe8e021db6c7eca6df82eb" translate="yes" xml:space="preserve">
          <source>However, functions that return booleans and are valid in guards follow another convention, described next.</source>
          <target state="translated">Однако,функции,которые возвращают булеан и действительны для охранников,следуют другой конвенции,описанной ниже.</target>
        </trans-unit>
        <trans-unit id="e2f8333bf85aa3e6557d871123f4e54aa89129c2" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will return &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Однако, если &amp;laquo;&amp;eacute;&amp;raquo; представлен одним символом &amp;laquo;e с острым ударением&amp;raquo;, тогда он вернет &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2dea6b01d6679272ba037abafc94d5ec1f3a1e91" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will split the string into just one part:</source>
          <target state="translated">Однако, если &amp;laquo;&amp;eacute;&amp;raquo; представлен одним символом &amp;laquo;e с острым ударением&amp;raquo;, тогда строка разделится только на одну часть:</target>
        </trans-unit>
        <trans-unit id="43d541b3bc1e148da1c64ef9ffa0bbfd2e7364f7" translate="yes" xml:space="preserve">
          <source>However, if flex breaks are used, then each break is re-evaluated when rendered, so the document could be possible rendered as:</source>
          <target state="translated">Однако,если используются гибкие перерывы,то каждый перерыв переоценивается при выводе документа на экран,так что документ может быть выполнен как таковой:</target>
        </trans-unit>
        <trans-unit id="e59920d8100c9a8114a12d93422f9d86a0ab473f" translate="yes" xml:space="preserve">
          <source>However, if there is a need to access the user variable, nil can be given:</source>
          <target state="translated">Однако,если необходимо получить доступ к пользовательской переменной,то можно дать nil:</target>
        </trans-unit>
        <trans-unit id="ebac26b5b96f39c6c425c9f7338b33aa11d33d44" translate="yes" xml:space="preserve">
          <source>However, if we use &lt;code&gt;string&lt;/code&gt;, then the string length is used, instead of byte size, correctly fitting:</source>
          <target state="translated">Однако, если мы используем &lt;code&gt;string&lt;/code&gt; , то вместо размера в байтах используется длина строки, правильно подходящая:</target>
        </trans-unit>
        <trans-unit id="163ec0dc8d44d05de91c4d5e307d82258afc33ad" translate="yes" xml:space="preserve">
          <source>However, if you expect the file to be there, the bang variation is more useful as it raises a meaningful error message. Avoid writing:</source>
          <target state="translated">Однако,если вы ожидаете,что файл будет там,вариация bang более полезна,так как она вызывает значимое сообщение об ошибке.Избегайте записи:</target>
        </trans-unit>
        <trans-unit id="b26ef74513acb14878e64cf7d06f11768d520400" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (e.g. if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="translated">Однако,если вы ожидаете,что результат всегда будет успешным (например,если вы ожидаете,что файл всегда будет существовать),вариация bang может быть более удобной и вызовет более полезное сообщение об ошибке (чем неудачное совпадение по шаблону)при неудаче.</target>
        </trans-unit>
        <trans-unit id="f76bd9d28fa6001b9c29fd594f3da25de0125efb" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="translated">Однако,если вы ожидаете,что результат всегда будет успешным (например,если вы ожидаете,что файл всегда будет существовать),вариация взрыва может быть более удобной и вызовет более полезное сообщение об ошибке (чем неудачное совпадение по шаблону)при неудаче.</target>
        </trans-unit>
        <trans-unit id="12f2ae0ce38b2739810767448aba2df24da58505" translate="yes" xml:space="preserve">
          <source>However, if you push every application as a separate project to a Git repository, your projects may become very hard to maintain as you will spend a lot of time managing those Git repositories rather than writing your code.</source>
          <target state="translated">Однако,если вы будете переносить каждое приложение как отдельный проект в Git-репозиторий,ваши проекты могут стать очень сложными в обслуживании,так как вы будете тратить много времени на управление этими Git-репозиториями вместо того,чтобы писать свой код.</target>
        </trans-unit>
        <trans-unit id="c4db01e79b2e5a22ecea1d3f50d5983cb25a53b4" translate="yes" xml:space="preserve">
          <source>However, if you want to invoke a specific module, function and arguments, or give the task process a name, you need to define the task in its own module:</source>
          <target state="translated">Однако,если вы хотите вызвать конкретный модуль,функцию и аргументы,или дать заданию имя,вам необходимо определить задание в его собственном модуле:</target>
        </trans-unit>
        <trans-unit id="d300780723b1e1d9cb8cf90e34f684379371fda8" translate="yes" xml:space="preserve">
          <source>However, if you want to re-use the sigil character itself on the string, you need to escape it:</source>
          <target state="translated">Однако,если вы хотите повторно использовать сам символ сигила на строке,вам необходимо его избежать:</target>
        </trans-unit>
        <trans-unit id="9832e5845d5128f4155ac9809559b224c95909bd" translate="yes" xml:space="preserve">
          <source>However, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_tuple/1&quot;&gt;&lt;code&gt;is_tuple/1&lt;/code&gt;&lt;/a&gt; before &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt;, otherwise the whole guard will fail if a tuple is not given. Alternatively your function clause can use multiple guards as shown in the following section.</source>
          <target state="translated">Однако, если ваш охранник имеет несколько условий, таких как проверка кортежей или карт, лучше всего вызывать функции проверки типов, такие как &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_tuple/1&quot;&gt; &lt;code&gt;is_tuple/1&lt;/code&gt; ,&lt;/a&gt; перед &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt; , иначе вся защита выйдет из строя, если кортеж не указан. В качестве альтернативы ваше функциональное предложение может использовать несколько защит, как показано в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="bbb15fb0156049fcce5c409f89352f9b00a36988" translate="yes" xml:space="preserve">
          <source>However, implementation-wise, they have the following differences:</source>
          <target state="translated">Однако,с точки зрения реализации,они имеют следующие различия:</target>
        </trans-unit>
        <trans-unit id="ab714719ee8f889dd923393f22c68b77c2b16ffe" translate="yes" xml:space="preserve">
          <source>However, in some cases it may be desired to associate a value to the process using the alternate &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; tuple:</source>
          <target state="translated">Однако в некоторых случаях может потребоваться связать значение с процессом с помощью альтернативного кортежа &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4761ed59b0d1afa93377c7f7b363dfb8fb4fda3" translate="yes" xml:space="preserve">
          <source>However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the &lt;code&gt;^&lt;/code&gt; special form, colloquially known as the pin operator:</source>
          <target state="translated">Однако в некоторых ситуациях полезно сопоставить с существующим значением вместо повторной привязки. Это можно сделать с помощью специальной формы &lt;code&gt;^&lt;/code&gt; , в просторечии известной как оператор булавки:</target>
        </trans-unit>
        <trans-unit id="96e149dd0b884d4a6fa96fb42e3515395245b191" translate="yes" xml:space="preserve">
          <source>However, in the majority of cases, you want to add the task supervisor to your supervision tree:</source>
          <target state="translated">Однако,в большинстве случаев,вы хотите добавить куратора задач в дерево наблюдений:</target>
        </trans-unit>
        <trans-unit id="dba0c307e5ca681865cce6227a859a96ae9a11f3" translate="yes" xml:space="preserve">
          <source>However, instead of adding more code to the &lt;code&gt;kv&lt;/code&gt; application, we are going to build the TCP server as another application that is a client of the &lt;code&gt;kv&lt;/code&gt; application. Since the whole runtime and Elixir ecosystem are geared towards applications, it makes sense to break our projects into smaller applications that work together rather than building a big, monolithic app.</source>
          <target state="translated">Однако вместо добавления кода в приложение &lt;code&gt;kv&lt;/code&gt; мы собираемся построить TCP-сервер как другое приложение, которое является клиентом приложения &lt;code&gt;kv&lt;/code&gt; . Поскольку вся среда выполнения и экосистема Elixir ориентированы на приложения, имеет смысл разбить наши проекты на более мелкие приложения, которые работают вместе, а не создавать большое монолитное приложение.</target>
        </trans-unit>
        <trans-unit id="d0b1ff55d618bd8bbea3c57925ed60e856baa189" translate="yes" xml:space="preserve">
          <source>However, instead of modifying those files after the release is built, the simplest way to customize those files is by running &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.Init.html&quot;&gt;&lt;code&gt;mix release.init&lt;/code&gt;&lt;/a&gt;. The Mix task will copy custom &lt;code&gt;rel/vm.args.eex&lt;/code&gt;, &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; files to your project root. You can modify those files and they will be evaluated every time you perform a new release. Those files are regular EEx templates and they have a single assign, called &lt;code&gt;@release&lt;/code&gt;, with the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Однако, вместо того, чтобы изменять эти файлы после сборки выпуска, самый простой способ настроить эти файлы - запустить &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.Init.html&quot;&gt; &lt;code&gt;mix release.init&lt;/code&gt; &lt;/a&gt; . Задача Mix скопирует пользовательские &lt;code&gt;rel/vm.args.eex&lt;/code&gt; , &lt;code&gt;rel/env.sh.eex&lt;/code&gt; и &lt;code&gt;rel/env.bat.eex&lt;/code&gt; в корень вашего проекта. Вы можете изменить эти файлы, и они будут оцениваться каждый раз, когда вы запускаете новый выпуск. Эти файлы являются обычными шаблонами EEx, и у них есть одно назначение, называемое &lt;code&gt;@release&lt;/code&gt; , со структурой &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f2acb719b57d971a999b6feb20a4c47ae5bfcf5" translate="yes" xml:space="preserve">
          <source>However, keep in mind that adding &lt;code&gt;@doc false&lt;/code&gt; does not make the function private. The function above can still be invoked as &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt;. Not only that, if &lt;code&gt;MyApp.Sample&lt;/code&gt; is imported, the &lt;code&gt;add/2&lt;/code&gt; function will also be imported into the caller. For those reasons, be cautious when adding &lt;code&gt;@doc false&lt;/code&gt; to functions, instead use one of these two options:</source>
          <target state="translated">Однако имейте в виду, что добавление &lt;code&gt;@doc false&lt;/code&gt; не делает функцию закрытой. Вышеупомянутую функцию по-прежнему можно вызывать как &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt; . Мало того, если &lt;code&gt;MyApp.Sample&lt;/code&gt; импортирован, функция &lt;code&gt;add/2&lt;/code&gt; также будет импортирована в вызывающую программу. По этим причинам будьте осторожны при добавлении &lt;code&gt;@doc false&lt;/code&gt; к функциям, вместо этого используйте один из этих двух вариантов:</target>
        </trans-unit>
        <trans-unit id="ce1e4503150dc2f3049f826f979cbe9905825d87" translate="yes" xml:space="preserve">
          <source>However, keep in mind that by making the test distributed, we will likely run it less frequently, since we may not do the distributed setup on every test run.</source>
          <target state="translated">Тем не менее,имейте в виду,что,сделав тест распределенным,мы,скорее всего,будем запускать его реже,так как мы можем не делать распределенную настройку при каждом запуске теста.</target>
        </trans-unit>
        <trans-unit id="3693f464a1590f76c7a514020cc3b6b0e554bf8d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="translated">Однако имейте в виду, что такие случаи обычно не являются проблемой. В конце концов, процесс, на который ссылается PID, может дать сбой в любой момент, в том числе между получением значения из реестра и отправкой ему сообщения. Многие части стандартной библиотеки предназначены для этого, например &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; ,&lt;/a&gt; который немедленно доставит сообщение &lt;code&gt;:DOWN&lt;/code&gt; , если отслеживаемый процесс уже мертв, и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; ,&lt;/a&gt; который действует как no-op для мертвых. процессы.</target>
        </trans-unit>
        <trans-unit id="f5ae69f63821cec3eb4f2016854327b6c5df477d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="translated">Однако имейте в виду, что такие случаи обычно не являются проблемой. В конце концов, процесс, на который ссылается PID, может дать сбой в любой момент, в том числе между получением значения из реестра и отправкой ему сообщения. Многие части стандартной библиотеки предназначены для этого, например &lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; ,&lt;/a&gt; который немедленно доставит сообщение &lt;code&gt;:DOWN&lt;/code&gt; , если отслеживаемый процесс уже мертв, и &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; ,&lt;/a&gt; который действует как no-op для мертвых процессы.</target>
        </trans-unit>
        <trans-unit id="ea02d735a03ee13559ceb754eeca6008810c2c76" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="translated">Однако в языке существует множество других перечислимых &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; , таких как MapSet и тип данных, возвращаемый &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; ,&lt;/a&gt; который позволяет перемещаться по файлу, как если бы он был перечислимым.</target>
        </trans-unit>
        <trans-unit id="9a395466f1651904a7d0044a0e96b1a814183371" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="translated">Однако в языке существует множество других перечислимых &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; , таких как MapSet и тип данных, возвращаемый &lt;a href=&quot;file#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; ,&lt;/a&gt; который позволяет перемещаться по файлу, как если бы он был перечислимым.</target>
        </trans-unit>
        <trans-unit id="1b496aae43041f07a94c194092a1ee0cf80d4eec" translate="yes" xml:space="preserve">
          <source>However, naming dynamic processes with atoms is a terrible idea! If we use atoms, we would need to convert the bucket name (often received from an external client) to atoms, and &lt;strong&gt;we should never convert user input to atoms&lt;/strong&gt;. This is because atoms are not garbage collected. Once an atom is created, it is never reclaimed. Generating atoms from user input would mean the user can inject enough different names to exhaust our system memory!</source>
          <target state="translated">Однако называть динамические процессы атомами - ужасная идея! Если мы используем атомы, нам нужно будет преобразовать имя корзины (часто полученное от внешнего клиента) в атомы, и &lt;strong&gt;мы никогда не должны преобразовывать вводимые пользователем данные в атомы&lt;/strong&gt; . Это потому, что атомы не собираются мусором. Созданный атом никогда не восстанавливается. Создание атомов из пользовательского ввода означало бы, что пользователь может ввести достаточно разных имен, чтобы исчерпать нашу системную память!</target>
        </trans-unit>
        <trans-unit id="df3b6ab895dd3f7bd985857fc1933851a28e562b" translate="yes" xml:space="preserve">
          <source>However, remember that binary pattern matching works on &lt;em&gt;bytes&lt;/em&gt;, so matching on the string like &amp;ldquo;&amp;uuml;ber&amp;rdquo; with multibyte characters won&amp;rsquo;t match on the &lt;em&gt;character&lt;/em&gt;, it will match on the &lt;em&gt;first byte of that character&lt;/em&gt;:</source>
          <target state="translated">Однако помните, что сопоставление двоичного шаблона работает с &lt;em&gt;байтами&lt;/em&gt; , поэтому сопоставление строки типа &amp;laquo;&amp;uuml;ber&amp;raquo; с многобайтовыми символами не будет соответствовать &lt;em&gt;символу&lt;/em&gt; , оно будет соответствовать &lt;em&gt;первому байту этого символа&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="77afe59f2cf778e4ba45a1656955754632ba1dec" translate="yes" xml:space="preserve">
          <source>However, should we be fine with the implementation for &lt;code&gt;Any&lt;/code&gt;, in order to use such implementation we would need to tell our struct to explicitly derive the &lt;code&gt;Size&lt;/code&gt; protocol:</source>
          <target state="translated">Однако, если нас устраивает реализация для &lt;code&gt;Any&lt;/code&gt; , чтобы использовать такую ​​реализацию, нам нужно будет указать нашей структуре явно наследовать протокол &lt;code&gt;Size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f35366701d4be066fddfcbe4789ab0e44ff649f" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;KV.Registry.create/2&lt;/code&gt; is a cast operation, the command will return before we actually write to the table! In other words, this is happening:</source>
          <target state="translated">Однако, поскольку &lt;code&gt;KV.Registry.create/2&lt;/code&gt; - это операция приведения, команда вернется до того, как мы действительно запишем в таблицу! Другими словами, это происходит:</target>
        </trans-unit>
        <trans-unit id="b607bf41eed0b7acedbf1d601f4e6081a4cb7cfb" translate="yes" xml:space="preserve">
          <source>However, since structs are just maps, they work with the functions from the &lt;code&gt;Map&lt;/code&gt; module:</source>
          <target state="translated">Однако, поскольку структуры - это просто карты, они работают с функциями из модуля &lt;code&gt;Map&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e7b768f9063dad4bbd7d785c035b8dad45c243ae" translate="yes" xml:space="preserve">
          <source>However, specifying the child specification for each child as a map can be quite error prone, as we may change the Stack implementation and forget to update its specification. That's why Elixir allows you to pass a tuple with the module name and the &lt;code&gt;start_link&lt;/code&gt; argument instead of the specification:</source>
          <target state="translated">Однако указание дочерней спецификации для каждого дочернего элемента в виде карты может быть весьма подвержено ошибкам, поскольку мы можем изменить реализацию Stack и забыть обновить его спецификацию. Вот почему Elixir позволяет вам передавать кортеж с именем модуля и аргументом &lt;code&gt;start_link&lt;/code&gt; вместо спецификации:</target>
        </trans-unit>
        <trans-unit id="496f233e2f16ce1ec282e5a3228096d9e60212a4" translate="yes" xml:space="preserve">
          <source>However, strings are just part of the story. If a string is a binary, and we have used the &lt;code&gt;is_binary/1&lt;/code&gt; function, Elixir must have an underlying type empowering strings. And it does! Let&amp;rsquo;s talk about binaries.</source>
          <target state="translated">Однако струны - это лишь часть истории. Если строка является двоичной, и мы использовали &lt;code&gt;is_binary/1&lt;/code&gt; , Elixir должен иметь базовый тип, расширяющий возможности строки. И это так! Поговорим о двоичных файлах.</target>
        </trans-unit>
        <trans-unit id="dd71889ec3595479588d8ca1a2ca3333e184a132" translate="yes" xml:space="preserve">
          <source>However, the capturing of any other named device, such as &lt;code&gt;:stderr&lt;/code&gt;, happens globally and persists until the function has ended. While this means it is safe to run your tests with &lt;code&gt;async: true&lt;/code&gt; in many cases, captured output may include output from a different test and care must be taken when using &lt;code&gt;capture_io&lt;/code&gt; with a named process asynchronously.</source>
          <target state="translated">Однако захват любого другого именованного устройства, такого как &lt;code&gt;:stderr&lt;/code&gt; , происходит глобально и сохраняется до завершения функции. Хотя это означает, что во многих случаях можно безопасно запускать тесты с &lt;code&gt;async: true&lt;/code&gt; , захваченный вывод может включать вывод другого теста, и необходимо соблюдать осторожность при использовании &lt;code&gt;capture_io&lt;/code&gt; с именованным процессом в асинхронном режиме.</target>
        </trans-unit>
        <trans-unit id="82b09700b9bf9936f190f1106abb6ccb1f220f41" translate="yes" xml:space="preserve">
          <source>However, the code below would work as long as &lt;code&gt;:option_parser_example&lt;/code&gt; atom is used at some point later (or earlier) &lt;strong&gt;in the same module&lt;/strong&gt;. For example:</source>
          <target state="translated">Однако приведенный ниже код будет работать до тех пор, пока &lt;code&gt;:option_parser_example&lt;/code&gt; атом используется в какой-то момент позже (или раньше) &lt;strong&gt;в том же модуле&lt;/strong&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b357c81b8f132fc24fbf479211e75b269f8fae9b" translate="yes" xml:space="preserve">
          <source>However, the size cannot be defined in the match outside the binary/bitstring match:</source>
          <target state="translated">Тем не менее,размер не может быть определен в матче вне бинарного/битового совпадения:</target>
        </trans-unit>
        <trans-unit id="c0f50242052626c017e46fce09925693cd1c9dd3" translate="yes" xml:space="preserve">
          <source>However, there are times when we don&amp;rsquo;t want variables to be rebound.</source>
          <target state="translated">Однако бывают случаи, когда мы не хотим, чтобы переменные возвращались обратно.</target>
        </trans-unit>
        <trans-unit id="88399305a4f17930e312791fc1d3a07b6c89a0a2" translate="yes" xml:space="preserve">
          <source>However, there is a bug in our stack server. If we call &lt;code&gt;:pop&lt;/code&gt; and the stack is empty, it is going to crash because no clause matches:</source>
          <target state="translated">Однако в нашем стековом сервере есть ошибка. Если мы вызовем &lt;code&gt;:pop&lt;/code&gt; , а стек пуст, произойдет сбой, потому что ни одно предложение не соответствует:</target>
        </trans-unit>
        <trans-unit id="6b30a9e6e90f8ae42f6ce5f8d5d4ee4d68edc7af" translate="yes" xml:space="preserve">
          <source>However, there is still one concern left, which are the restart strategies. Tasks, by default, have the &lt;code&gt;:restart&lt;/code&gt; value set to &lt;code&gt;:temporary&lt;/code&gt;, which means they are not restarted. This is an excellent default for the connections started via the &lt;code&gt;Task.Supervisor&lt;/code&gt;, as it makes no sense to restart a failed connection, but it is a bad choice for the acceptor. If the acceptor crashes, we want to bring the acceptor up and running again.</source>
          <target state="translated">Однако остается одна проблема - стратегии перезапуска. Задачи по умолчанию имеют значение &lt;code&gt;:restart&lt;/code&gt; , равное &lt;code&gt;:temporary&lt;/code&gt; , что означает, что они не перезапускаются. Это отличный вариант по умолчанию для соединений, запущенных через &lt;code&gt;Task.Supervisor&lt;/code&gt; , поскольку нет смысла перезапускать неудачное соединение, но это плохой выбор для принимающей стороны. Если акцептор выходит из строя, мы хотим снова запустить акцептор.</target>
        </trans-unit>
        <trans-unit id="2654066a02c149d51e371eeaac885d94072a55a8" translate="yes" xml:space="preserve">
          <source>However, this module returns the proper length:</source>
          <target state="translated">Однако,этот модуль возвращает нужную длину:</target>
        </trans-unit>
        <trans-unit id="0458a5b82cdaf306b947332bf064e36f033492d1" translate="yes" xml:space="preserve">
          <source>However, this option can be expensive if you have multiple production nodes or if the release assembling process is a long one, as each node needs to individually assemble the release.</source>
          <target state="translated">Однако,этот вариант может быть дорогостоящим,если у вас несколько производственных узлов,или если процесс сборки релиза длительный,так как каждый узел должен собирать релиз индивидуально.</target>
        </trans-unit>
        <trans-unit id="41d8fdc77d8f21adeb6b27918df1a329fe13ff18" translate="yes" xml:space="preserve">
          <source>However, using lists in IO operations requires some attention. A list may represent either a bunch of bytes or a bunch of characters and which one to use depends on the encoding of the IO device. If the file is opened without encoding, the file is expected to be in raw mode, and the functions in the &lt;code&gt;IO&lt;/code&gt; module starting with &lt;code&gt;bin*&lt;/code&gt; must be used. Those functions expect an &lt;code&gt;iodata&lt;/code&gt; as an argument; i.e., they expect a list of integers representing bytes or binaries to be given.</source>
          <target state="translated">Однако использование списков в операциях ввода-вывода требует некоторого внимания. Список может представлять собой набор байтов или набор символов, и какой из них использовать, зависит от кодировки устройства ввода-вывода. Если файл открывается без кодирования, ожидается, что файл будет в необработанном режиме, и должны использоваться функции в модуле &lt;code&gt;IO&lt;/code&gt; начинающиеся с &lt;code&gt;bin*&lt;/code&gt; . Эти функции ожидают в качестве аргумента &lt;code&gt;iodata&lt;/code&gt; ; т.е. они ожидают, что будет дан список целых чисел, представляющих байты или двоичные файлы.</target>
        </trans-unit>
        <trans-unit id="b77af23f35c905af8889b972cb68357936576822" translate="yes" xml:space="preserve">
          <source>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the &lt;code&gt;=&lt;/code&gt; operator):</source>
          <target state="translated">Однако переменные, назначенные в сопоставлении, не будут доступны вне вызова функции (в отличие от обычного сопоставления с шаблоном с оператором &lt;code&gt;=&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="5c24fd6169426183241dcc9a0bdf50f1c21b8290" translate="yes" xml:space="preserve">
          <source>However, variables explicitly bound in the clause &quot;body&quot; are accessible from the outer context:</source>
          <target state="translated">Однако переменные,явно связанные в пункте &quot;тело&quot;,доступны из внешнего контекста:</target>
        </trans-unit>
        <trans-unit id="a2b5a965ef9a419fe17594f66438c5b71c746d05" translate="yes" xml:space="preserve">
          <source>However, we can connect to the other shell remotely. Open up the &lt;code&gt;User switch command&lt;/code&gt; prompt (Ctrl+G) and type:</source>
          <target state="translated">Однако мы можем подключиться к другой оболочке удаленно. Откройте &lt;code&gt;User switch command&lt;/code&gt; строку пользовательского переключателя (Ctrl + G) и введите:</target>
        </trans-unit>
        <trans-unit id="b76f1491e39a30e4f05d47d9af534982461917de" translate="yes" xml:space="preserve">
          <source>However, we can spawn a new process on &lt;code&gt;foo@computer-name&lt;/code&gt; from &lt;code&gt;bar@computer-name&lt;/code&gt;! Let&amp;rsquo;s give it a try (where &lt;code&gt;@computer-name&lt;/code&gt; is the one you see locally):</source>
          <target state="translated">Однако мы можем создать новый процесс для &lt;code&gt;foo@computer-name&lt;/code&gt; из &lt;code&gt;bar@computer-name&lt;/code&gt; ! Давайте попробуем (где &lt;code&gt;@computer-name&lt;/code&gt; - тот, который вы видите локально):</target>
        </trans-unit>
        <trans-unit id="f37bd2760f0cfed52b63715c0c0ee324352998b9" translate="yes" xml:space="preserve">
          <source>However, we can't invoke it as follows:</source>
          <target state="translated">Однако,мы не можем ссылаться на это следующим образом:</target>
        </trans-unit>
        <trans-unit id="693f31cc1e3b5ed02531511f77198af8ecfd7ceb" translate="yes" xml:space="preserve">
          <source>However, when an &lt;code&gt;else&lt;/code&gt; clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;rescue&lt;/code&gt; in the same &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">Однако, когда присутствует предложение &lt;code&gt;else&lt;/code&gt; , но результат выражения не соответствует ни одному из шаблонов, возникает исключение. Это исключение не будет перехвачено &lt;code&gt;catch&lt;/code&gt; или &lt;code&gt;rescue&lt;/code&gt; при той же &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c77097fa9973bf214463e34dd009d5f8b620b4e" translate="yes" xml:space="preserve">
          <source>However, when the supervisor restarts the new bucket, the registry does not know about it. So we will have an empty bucket in the supervisor that nobody can access! To solve this, we want to say that buckets are actually temporary. If they crash, regardless of the reason, they should not be restarted.</source>
          <target state="translated">Однако,когда супервайзер перезапускает новое ведро,реестр не знает об этом.Поэтому в супервизоре будет пустое ведро,к которому никто не сможет получить доступ! Чтобы решить эту проблему,мы хотим сказать,что ведра на самом деле временные.Если они разбиваются,независимо от причины,их не следует перезапускать.</target>
        </trans-unit>
        <trans-unit id="aaa0ec2494f85dbc09c2cf136ebd0615520b8aec" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause simply fails to match:</source>
          <target state="translated">Однако,при использовании в охране,соответствующее положение просто не соответствует:</target>
        </trans-unit>
        <trans-unit id="194ca3b5d1e99777f19c355cce6d59f573e1d740" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause will fail to match instead of raising an error:</source>
          <target state="translated">Однако,при использовании в охране,соответствующее условие не будет соответствовать,вместо того,чтобы вызвать ошибку:</target>
        </trans-unit>
        <trans-unit id="659be2322a62899199e6224a02bca5b99ed29e51" translate="yes" xml:space="preserve">
          <source>However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in &lt;code&gt;:raw&lt;/code&gt; mode. The options &lt;code&gt;:read_ahead&lt;/code&gt; and &lt;code&gt;:delayed_write&lt;/code&gt; are also useful when operating on large files or working with files in tight loops.</source>
          <target state="translated">Однако вы не всегда можете захотеть расплачиваться за эту абстракцию. В таких случаях файл можно открыть в &lt;code&gt;:raw&lt;/code&gt; режиме. Параметры &lt;code&gt;:read_ahead&lt;/code&gt; и &lt;code&gt;:delayed_write&lt;/code&gt; также полезны при работе с большими файлами или при работе с файлами в тесных циклах.</target>
        </trans-unit>
        <trans-unit id="f893640c0df5ffde8dd2c6fee00f09a1846f23f1" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could do:</source>
          <target state="translated">Однако у вашей производственной среды могут быть особые потребности. Например, прямо сейчас мы жестко кодируем таблицу маршрутизации, но на производстве вам может потребоваться прочитать таблицу маршрутизации с диска, из другой службы или даже обратиться к вашему инструменту оркестровки, например Kubernetes. Это можно сделать, добавив &lt;code&gt;config/releases.exs&lt;/code&gt; . Как следует из названия, этот файл запускается каждый раз при запуске выпуска. Например, вы можете:</target>
        </trans-unit>
        <trans-unit id="edea2ca00218d63cdd854e8d487aa95dfd59b53c" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</source>
          <target state="translated">Однако у вашей производственной среды могут быть особые потребности. Например, прямо сейчас мы жестко кодируем таблицу маршрутизации, но на производстве вам может потребоваться прочитать таблицу маршрутизации с диска, из другой службы или даже обратиться к вашему инструменту оркестровки, например Kubernetes. Это можно сделать, добавив &lt;code&gt;config/releases.exs&lt;/code&gt; . Как следует из названия, этот файл запускается каждый раз при запуске выпуска. Например, вы можете сделать порт &lt;code&gt;KVServer&lt;/code&gt; настраиваемым, и значение порта будет указано только во время выполнения:</target>
        </trans-unit>
        <trans-unit id="5ff8ae7f9913820c4cc328c8f087e28f17634493" translate="yes" xml:space="preserve">
          <source>Hygiene in aliases</source>
          <target state="translated">Гигиена в псевдонимах</target>
        </trans-unit>
        <trans-unit id="93c4bc3fa55a161e49f6a7b16214db78fe9e8cb2" translate="yes" xml:space="preserve">
          <source>Hygiene in imports</source>
          <target state="translated">Гигиена в импорте</target>
        </trans-unit>
        <trans-unit id="2569893e8a4ee578273b8aabe0ac087b41daa61c" translate="yes" xml:space="preserve">
          <source>Hygiene in variables</source>
          <target state="translated">Гигиена в переменных</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="a8882cab0a9a900efc9a6181ff8e693783509bb4" translate="yes" xml:space="preserve">
          <source>IANA provides time zone data that includes data about different UTC offsets and standard offsets for time zones.</source>
          <target state="translated">IANA предоставляет данные о часовых поясах,которые включают данные о различных UTC-смещениях и стандартных смещениях для часовых поясов.</target>
        </trans-unit>
        <trans-unit id="c31397c072d7bdb4a10bd53b1d1d02f67a9c1ce2" translate="yes" xml:space="preserve">
          <source>ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus &lt;code&gt;Other_ID_Continue&lt;/code&gt;, minus &lt;code&gt;Pattern_Syntax&lt;/code&gt; and &lt;code&gt;Pattern_White_Space&lt;/code&gt; code points.</source>
          <target state="translated">Символы ID_Start, плюс символы, имеющие общую категорию Unicode, состоящую из знаков без пробелов, знаков объединения интервалов, десятичного числа, знаков препинания соединителя, плюс &lt;code&gt;Other_ID_Continue&lt;/code&gt; , минус кодовые точки &lt;code&gt;Pattern_Syntax&lt;/code&gt; и &lt;code&gt;Pattern_White_Space&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2ad7abf6ecd35c09ec969d6e5c5f626d2f547e0" translate="yes" xml:space="preserve">
          <source>IEx</source>
          <target state="translated">IEx</target>
        </trans-unit>
        <trans-unit id="bfd7d496a0b2c2b60b82d2300407f3ae22ad37d7" translate="yes" xml:space="preserve">
          <source>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</source>
          <target state="translated">IEx позволяет подключаться к другому узлу в двух модах.Прежде всего,мы можем подключиться к оболочке только в том случае,если дадим имена как текущей оболочке,так и оболочке,к которой хотим подключиться.</target>
        </trans-unit>
        <trans-unit id="8d4f60e469c0e609dec1269dbd88a28be0de6f53" translate="yes" xml:space="preserve">
          <source>IEx also has the ability to set breakpoints on Elixir code and &quot;pry&quot; into running processes. This allows the developer to have an IEx session run inside a given function.</source>
          <target state="translated">IEx также имеет возможность устанавливать точки останова на Elixir-коде и &quot;подглядывать&quot; в запущенные процессы.Это позволяет разработчику иметь IEx-сессию,запущенную внутри заданной функции.</target>
        </trans-unit>
        <trans-unit id="de2b6b57cb35a438bfce75b9ed0826e918fad577" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">IEx оценивает свой ввод построчно с нетерпением, что означает, что если в конце строки код, который мы видели до сих пор, является полным выражением, IEx будет оценивать его в этой точке. Такое поведение может приводить к ошибкам для выражений, отформатированных в несколько строк, что часто имеет место для выражений с конвейером. Рассмотрим следующее выражение с помощью оператора &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt; &lt;code&gt;|&amp;gt;/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="33ef030b61ea454aec0cec73bb460dee37b9c1bf" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">IEx оценивает свой ввод построчно с нетерпением, что означает, что если в конце строки код, который мы видели до сих пор, является полным выражением, IEx оценит его в этой точке. Такое поведение может привести к ошибкам для выражений, которые были отформатированы в несколько строк, что часто имеет место для выражений с конвейером. Рассмотрим следующее выражение с помощью оператора &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt; &lt;code&gt;|&amp;gt;/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="54729610ac51af0b9971d9467c379b62a1eb9d65" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="translated">Помощники IEx включают множество удобств, связанных с точками останова. Ниже они перечислены с полным модулем, например &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt; &lt;/a&gt; , но помните, что он может вызываться напрямую как &lt;code&gt;breaks()&lt;/code&gt; внутри IEx. Они есть:</target>
        </trans-unit>
        <trans-unit id="64c5dfd453f493f03e877d65639ce61fedbb37bc" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;iex.helpers#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="translated">Помощники IEx включают множество удобств, связанных с точками останова. Ниже они перечислены с полным модулем, например &lt;a href=&quot;iex.helpers#breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt; &lt;/a&gt; , но помните, что он может вызываться напрямую как &lt;code&gt;breaks()&lt;/code&gt; внутри IEx. Они есть:</target>
        </trans-unit>
        <trans-unit id="8f54609a357af7036d3341f02f1a23c3b68eda40" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">IEx предоставляет множество помощников. Доступ к ним можно получить, набрав &lt;code&gt;h()&lt;/code&gt; в оболочке или в качестве документации для модуля &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c364f03a852b53d4a7a502b57654a110b1cce03" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;iex.helpers&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">IEx предоставляет множество помощников. Доступ к ним можно получить, набрав &lt;code&gt;h()&lt;/code&gt; в оболочке или в качестве документации для модуля &lt;a href=&quot;iex.helpers&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fbe836e228d1004a30dd6875de1a22111586f81" translate="yes" xml:space="preserve">
          <source>IEx will also color inspected expressions using the &lt;code&gt;:syntax_colors&lt;/code&gt; option. Such can be disabled with:</source>
          <target state="translated">IEx также раскрасит проверенные выражения с помощью параметра &lt;code&gt;:syntax_colors&lt;/code&gt; . Это можно отключить с помощью:</target>
        </trans-unit>
        <trans-unit id="f04ddcbeb347ea8a966dd445a3b79f8b70364e41" translate="yes" xml:space="preserve">
          <source>IEx.Helpers</source>
          <target state="translated">IEx.Helpers</target>
        </trans-unit>
        <trans-unit id="c73133afe4ab05b736cba2f1d5c857bb84e93876" translate="yes" xml:space="preserve">
          <source>IEx.Info</source>
          <target state="translated">IEx.Info</target>
        </trans-unit>
        <trans-unit id="569138c9005aad9a2a791088d7d0e2cc45e36512" translate="yes" xml:space="preserve">
          <source>IEx.Info &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Протокол&lt;/small&gt; IEx.Info&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="40b4a890c64ba73558ed867016246c3ef597f257" translate="yes" xml:space="preserve">
          <source>IEx.Info.info (1)</source>
          <target state="translated">IEx.Info.info (1)</target>
        </trans-unit>
        <trans-unit id="5cbc0090e36bb601365004561eedb21e95b78b48" translate="yes" xml:space="preserve">
          <source>IEx.Info.t (0)</source>
          <target state="translated">IEx.Info.t (0)</target>
        </trans-unit>
        <trans-unit id="17bd8ed5133e3af7e767eaf3cc19dbec1b565da7" translate="yes" xml:space="preserve">
          <source>IEx.Pry</source>
          <target state="translated">IEx.Pry</target>
        </trans-unit>
        <trans-unit id="785a031a616ad88bcb1b2cd5dbbc60681be53958" translate="yes" xml:space="preserve">
          <source>IEx.Server</source>
          <target state="translated">IEx.Server</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="5b2f49f5a657a5ef736fa25eed6851c434d0dac3" translate="yes" xml:space="preserve">
          <source>IO and the file system</source>
          <target state="translated">IO и файловая система</target>
        </trans-unit>
        <trans-unit id="bbc4e8881ad6a75f10bb6ea9bff4b74783ee6ecc" translate="yes" xml:space="preserve">
          <source>IO data</source>
          <target state="translated">данные ввода-вывода</target>
        </trans-unit>
        <trans-unit id="ec099c7a428e418929af391ebb305d925a77dc9c" translate="yes" xml:space="preserve">
          <source>IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary.</source>
          <target state="translated">Данные ввода-вывода существуют потому,что часто необходимо выполнять множество операций добавления над небольшими кусочками двоичных файлов,чтобы создать более крупный двоичный файл.Однако,в Erlang и Elixir конкатенированные двоичные файлы будут скопированы в новый двоичный файл.</target>
        </trans-unit>
        <trans-unit id="9d9b6408eac92df9305226b9c32fd45d1762d634" translate="yes" xml:space="preserve">
          <source>IO data is a data type that can be used as a more efficient alternative to binaries in certain situations.</source>
          <target state="translated">Данные ввода-вывода-это тип данных,который в определенных ситуациях может быть использован в качестве более эффективной альтернативы двоичным файлам.</target>
        </trans-unit>
        <trans-unit id="370428fc749a05dd70935487b7d4064e7d83c3fb" translate="yes" xml:space="preserve">
          <source>IO devices</source>
          <target state="translated">IO-устройства</target>
        </trans-unit>
        <trans-unit id="d2ef1a7a2a7b43d0fc955e96e915a7dad9160987" translate="yes" xml:space="preserve">
          <source>IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt;&lt;code&gt;:file.position/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Устройства ввода-вывода сохраняют свое положение, что означает, что последующие вызовы любых функций чтения или записи будут начинаться с того места, где к устройству последний раз обращались. Положение файлов можно изменить с помощью функции &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt; &lt;code&gt;:file.position/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5cbeaffeb75ad57a2191d67bc818e573faa6d01" translate="yes" xml:space="preserve">
          <source>IO.ANSI</source>
          <target state="translated">IO.ANSI</target>
        </trans-unit>
        <trans-unit id="0089fd381dd7dfd8d488c15134d255be01885915" translate="yes" xml:space="preserve">
          <source>IO.Stream</source>
          <target state="translated">IO.Stream</target>
        </trans-unit>
        <trans-unit id="8139a358a2645d3cf610141a9bce4c7312be5781" translate="yes" xml:space="preserve">
          <source>IO.StreamError</source>
          <target state="translated">IO.StreamError</target>
        </trans-unit>
        <trans-unit id="3d7d3441a8eff66aaa0f0faa36a8a05b3a785de8" translate="yes" xml:space="preserve">
          <source>IO.StreamError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">IO.StreamError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="77802d65267b1d073f6e93dafd03f4d02d064153" translate="yes" xml:space="preserve">
          <source>IO.inspect/2</source>
          <target state="translated">IO.inspect/2</target>
        </trans-unit>
        <trans-unit id="c1f9284c3367b68f5c96129104a3a9d0f4c9d187" translate="yes" xml:space="preserve">
          <source>Identifiers in Elixir are case sensitive.</source>
          <target state="translated">Идентификаторы в эликсире чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="057deff008e9d8f83cd686c8b17c3d4c02169546" translate="yes" xml:space="preserve">
          <source>Identifying functions and documentation</source>
          <target state="translated">Идентификация функций и документация</target>
        </trans-unit>
        <trans-unit id="537a4055c25749aea0df46647a3ecdd449be90bb" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#after_suite/1&quot;&gt;&lt;code&gt;after_suite/1&lt;/code&gt;&lt;/a&gt; is called multiple times, the callbacks will be called in reverse order. In other words, the last callback set will be the first to be called.</source>
          <target state="translated">Если &lt;a href=&quot;#after_suite/1&quot;&gt; &lt;code&gt;after_suite/1&lt;/code&gt; &lt;/a&gt; вызывается несколько раз, обратные вызовы будут вызываться в обратном порядке. Другими словами, последний набор обратных вызовов будет вызван первым.</target>
        </trans-unit>
        <trans-unit id="c2d101d3a59aa29536cff11d9f78612ab949d729" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:code_change/3&quot;&gt;&lt;code&gt;code_change/3&lt;/code&gt;&lt;/a&gt; raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects.</source>
          <target state="translated">Если &lt;a href=&quot;#c:code_change/3&quot;&gt; &lt;code&gt;code_change/3&lt;/code&gt; &lt;/a&gt; вызывает ошибку, изменение кода завершается неудачей, и цикл продолжится в своем предыдущем состоянии. Поэтому этот обратный вызов обычно не содержит побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="50441c2fc5e3f35b8a96fa96c6320ab57738cfc1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; is invoked and there are no names, a release using the application name and default values is assembled.</source>
          <target state="translated">Если &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; и нет имен, собирается выпуск, использующий имя приложения и значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="eea2e17ca11f5963667c13624c09484704b91de8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, without a name, is invoked and there are multiple names, an error will be raised unless you set &lt;code&gt;default_release: NAME&lt;/code&gt; at the root of your project configuration.</source>
          <target state="translated">Если вызывается &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; без имени и имеется несколько имен, будет возникать ошибка, если вы не установите &lt;code&gt;default_release: NAME&lt;/code&gt; в корне конфигурации вашего проекта.</target>
        </trans-unit>
        <trans-unit id="1f1a0f874c702790d228021c47f6f58e4a98062d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt; is called before the application is loaded, the application environment values specified in the &lt;code&gt;.app&lt;/code&gt; file will override the ones previously set.</source>
          <target state="translated">Если &lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt; вызывается до загрузки приложения, значения среды приложения, указанные в файле &lt;code&gt;.app&lt;/code&gt; , переопределят ранее установленные.</target>
        </trans-unit>
        <trans-unit id="9f537d260ef97992e561be1422ea408f4c00b527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:abort&lt;/code&gt;, the runtime system aborts producing a core dump, if that is enabled in the operating system.</source>
          <target state="translated">Если &lt;code&gt;:abort&lt;/code&gt; , исполняющая система прекращает создание дампа ядра, если это разрешено в операционной системе.</target>
        </trans-unit>
        <trans-unit id="e351673ad711ca575120b265bcb522e29ffb1ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:all&lt;/code&gt; is given, &lt;code&gt;:eof&lt;/code&gt; is never returned, but an empty string in case the device has reached EOF.</source>
          <target state="translated">Если задано &lt;code&gt;:all&lt;/code&gt; , то &lt;code&gt;:eof&lt;/code&gt; никогда не возвращается, кроме пустой строки в случае, если устройство достигло EOF.</target>
        </trans-unit>
        <trans-unit id="664fc2657c2121b52010aad0e4fd4b13a3191a1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:build_per_environment&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it will create a new build per environment:</source>
          <target state="translated">Если для &lt;code&gt;:build_per_environment&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , будет создана новая сборка для каждой среды:</target>
        </trans-unit>
        <trans-unit id="1cd0a5e0adcba1255cdaf72cd16d9cb0159c0426" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:discard&lt;/code&gt; is given in &lt;code&gt;leftover&lt;/code&gt;, the last chunk is discarded unless it has exactly &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">Если &lt;code&gt;:discard&lt;/code&gt; задан как &lt;code&gt;leftover&lt;/code&gt; , последний кусок отбрасывается, если он не содержит точно &lt;code&gt;count&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="4ad666f68aa0c1c3e9b90d4547788465ffe950b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:stdio&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">Если &lt;code&gt;:stdio&lt;/code&gt; является устройством Unicode, &lt;code&gt;count&lt;/code&gt; подразумевает количество кодовых точек Unicode, которые необходимо получить. В противном случае &lt;code&gt;count&lt;/code&gt; - это количество необработанных байтов, которые нужно получить.</target>
        </trans-unit>
        <trans-unit id="1c37a0fde2ecc757cae6c2a1e1d8b99469865d32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@behaviour&lt;/code&gt; has been defined, &lt;code&gt;defoverridable&lt;/code&gt; can also be called with a module as an argument. All implemented callbacks from the behaviour above the call to &lt;code&gt;defoverridable&lt;/code&gt; will be marked as overridable.</source>
          <target state="translated">Если &lt;code&gt;@behaviour&lt;/code&gt; было определено, &lt;code&gt;defoverridable&lt;/code&gt; также может быть вызвана с модулем в качестве аргумента. Все реализованные обратные вызовы из поведения выше вызова &lt;code&gt;defoverridable&lt;/code&gt; будут помечены как заменяемые.</target>
        </trans-unit>
        <trans-unit id="0535dd7868286893881566e917783949810a614d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is a negative number, it starts counting from the back to the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; отрицательное число, он начинает отсчет от конца до начала &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="128e0031d4c1374c0210ba717199fde5a91caf98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is greater than the size of the rest of the &lt;code&gt;enumerable&lt;/code&gt;, then this function will reverse the rest of the enumerable.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; больше, чем размер остальной части &lt;code&gt;enumerable&lt;/code&gt; , то эта функция изменит на противоположную остальную часть перечислимого.</target>
        </trans-unit>
        <trans-unit id="64a4a2dc00ee57596c01d8e55272d16ee1731764" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is not provided, &lt;code&gt;nil&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;default&lt;/code&gt; не указано, используется &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4804fe88251de4efebed7a3b7f7ec9b900a0c7af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; is a PID, it must be the PID of a local process, dead or alive. If &lt;code&gt;dest&lt;/code&gt; is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process.</source>
          <target state="translated">Если &lt;code&gt;dest&lt;/code&gt; - это PID, это должен быть PID локального процесса, мертвого или активного. Если &lt;code&gt;dest&lt;/code&gt; является атомом, это должно быть имя зарегистрированного процесса, который просматривается во время доставки. Ошибка не возникает, если имя не относится к процессу.</target>
        </trans-unit>
        <trans-unit id="2650eb70496be023811483cdbe9dcf267336d48b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="translated">Если &lt;code&gt;flag&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , мониторинг включен. Если &lt;code&gt;flag&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; , контроль выключен.</target>
        </trans-unit>
        <trans-unit id="f1c832ccf95731edf1d63b91b33e2d1fe522cd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, acc}&lt;/code&gt; the reduction is halted and the function returns &lt;code&gt;acc&lt;/code&gt;. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;fun&lt;/code&gt; возвращает &lt;code&gt;{:halt, acc}&lt;/code&gt; сокращение останавливается, и функция возвращает &lt;code&gt;acc&lt;/code&gt; . В противном случае, если перечислимое количество исчерпано, функция возвращает аккумулятор последнего &lt;code&gt;{:cont, acc}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="448b014151f38127b8e5f6db3c5223d75cfbeb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index_range.last&lt;/code&gt; is out of bounds, then it is assigned as the index of the last element.</source>
          <target state="translated">Если &lt;code&gt;index_range.last&lt;/code&gt; выходит за пределы, то он назначается как индекс последнего элемента.</target>
        </trans-unit>
        <trans-unit id="f65e2abd74ff7207f89b8e63ffae32b6537b7ff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty string.</source>
          <target state="translated">Если &lt;code&gt;joiner&lt;/code&gt; вообще не передан, по умолчанию используется пустая строка.</target>
        </trans-unit>
        <trans-unit id="44dafce589cc2560c530b258260863b84a7ad4e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to the empty binary.</source>
          <target state="translated">Если &lt;code&gt;joiner&lt;/code&gt; вообще не передан, по умолчанию используется пустой двоичный файл.</target>
        </trans-unit>
        <trans-unit id="3055a00c41cda5c6ac1a36cb205d2baa4d5b0fc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возникает &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a91338d96953ddc227939bd5311d00c34a7770ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возникает &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e25538be406057a69443efa5940b2d432b4b6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, lazily evaluates &lt;code&gt;fun&lt;/code&gt; and returns its result.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, лениво оценивает &lt;code&gt;fun&lt;/code&gt; и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="0a81a69a6fcff94ffbea2c950485431c58d11511" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, return the default value (&lt;code&gt;nil&lt;/code&gt; if no default value).</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, вернуть значение по умолчанию ( &lt;code&gt;nil&lt;/code&gt; если значение по умолчанию отсутствует).</target>
        </trans-unit>
        <trans-unit id="670e493657f6e1800d6af7018ec7631dafc42777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; отсутствует в &lt;code&gt;keywords&lt;/code&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="ab5d096dab446f6e25ac353134ecfc0c4cc20f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; отсутствует в &lt;code&gt;keywords&lt;/code&gt; , &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="0aa66d148b2ac7a0571085f5d2ee7a7853bca2a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="b02bea90648629b86487eddfaee7cd58979250c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="0ec4f9859acc852c12bc2e32bac9f65f8ba4fa9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует на &lt;code&gt;map&lt;/code&gt; возвращается его &lt;code&gt;value&lt;/code&gt; . В противном случае возвращается &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0f7c37563cdb97d23ddfed9427894d235eabfd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует на &lt;code&gt;map&lt;/code&gt; возвращается его &lt;code&gt;value&lt;/code&gt; . В противном случае оценивается &lt;code&gt;fun&lt;/code&gt; и возвращается его результат.</target>
        </trans-unit>
        <trans-unit id="fb8ab7d4cb46594f50af6648151d0e98d320b934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then the existing value is passed to &lt;code&gt;fun&lt;/code&gt; and its result is used as the updated value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The default value will not be passed through the update function.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; то существующее значение передается в &lt;code&gt;fun&lt;/code&gt; , а его результат используется как обновленное значение &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; вставляется как значение &lt;code&gt;key&lt;/code&gt; . Значение по умолчанию не будет передано через функцию обновления.</target>
        </trans-unit>
        <trans-unit id="d36aa454c42946e2c34ba9f399b287cb43ac6ce3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then the existing value is passed to &lt;code&gt;fun&lt;/code&gt; and its result is used as the updated value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; то существующее значение передается в &lt;code&gt;fun&lt;/code&gt; , а его результат используется как обновленное значение &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="d4150f660167317dcaba9e8183ce3412c0294207" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The initial value will not be passed through the update function.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; со значением &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;fun&lt;/code&gt; вызывается со &lt;code&gt;value&lt;/code&gt; аргумента, и его результат используется как новое значение &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , в качестве значения &lt;code&gt;key&lt;/code&gt; вставляется &lt;code&gt;initial&lt;/code&gt; . Начальное значение не будет передано через функцию обновления.</target>
        </trans-unit>
        <trans-unit id="75a038e3ca604bf73652a1d5909bc26acc1aa307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; со значением &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;fun&lt;/code&gt; вызывается со &lt;code&gt;value&lt;/code&gt; аргумента, и его результат используется как новое значение &lt;code&gt;key&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="15c9a821a2b57a999e05676dbebd003979e0547e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; со значением &lt;code&gt;value&lt;/code&gt; , возвращается &lt;code&gt;{value, new_map}&lt;/code&gt; где &lt;code&gt;new_map&lt;/code&gt; - результат удаления &lt;code&gt;key&lt;/code&gt; с &lt;code&gt;map&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , возвращается &lt;code&gt;{default, map}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a0d4a917aec182ae2652ab6e3733862784d7df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; со значением &lt;code&gt;value&lt;/code&gt; , возвращается &lt;code&gt;{value, new_map}&lt;/code&gt; где &lt;code&gt;new_map&lt;/code&gt; - результат удаления &lt;code&gt;key&lt;/code&gt; с &lt;code&gt;map&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;{fun_result, map}&lt;/code&gt; , где &lt;code&gt;fun_result&lt;/code&gt; - результат применения &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be3edc2b3eeca76a785d6024f2cdb09fb2dfde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">Если в &lt;code&gt;map&lt;/code&gt; присутствует &lt;code&gt;key&lt;/code&gt; со значением &lt;code&gt;value&lt;/code&gt; , возвращается &lt;code&gt;value&lt;/code&gt; . В противном случае возвращается &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57db7be79a09b897065af1bdf410edac419b10e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="translated">Если в &lt;code&gt;map&lt;/code&gt; присутствует &lt;code&gt;key&lt;/code&gt; со значением &lt;code&gt;value&lt;/code&gt; , возвращается &lt;code&gt;value&lt;/code&gt; . В противном случае оценивается &lt;code&gt;fun&lt;/code&gt; и возвращается его результат.</target>
        </trans-unit>
        <trans-unit id="bd7fdb0ce9bd64671ab1efe4609aaa8d9539ced9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt;, it returns &lt;code&gt;{value, new_map}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value of the key and &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; , он возвращает &lt;code&gt;{value, new_map}&lt;/code&gt; где &lt;code&gt;value&lt;/code&gt; - это значение ключа, а &lt;code&gt;new_map&lt;/code&gt; - результат удаления &lt;code&gt;key&lt;/code&gt; с &lt;code&gt;map&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , возвращается &lt;code&gt;{default, map}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6833696c36f33582651db81f8d535239158d24e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt;, it returns &lt;code&gt;{value, new_map}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value of the key and &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; присутствует в &lt;code&gt;map&lt;/code&gt; , он возвращает &lt;code&gt;{value, new_map}&lt;/code&gt; где &lt;code&gt;value&lt;/code&gt; - это значение ключа, а &lt;code&gt;new_map&lt;/code&gt; - результат удаления &lt;code&gt;key&lt;/code&gt; с &lt;code&gt;map&lt;/code&gt; . Если &lt;code&gt;key&lt;/code&gt; отсутствует на &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;{fun_result, map}&lt;/code&gt; , где &lt;code&gt;fun_result&lt;/code&gt; - результат применения &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="022b1446733b2fda7810ec19631252125e1aa84b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keys&lt;/code&gt; contains keys that are not in &lt;code&gt;map&lt;/code&gt;, they're simply ignored.</source>
          <target state="translated">Если &lt;code&gt;keys&lt;/code&gt; содержат ключи, которых нет на &lt;code&gt;map&lt;/code&gt; , они просто игнорируются.</target>
        </trans-unit>
        <trans-unit id="9ec06751513a7783f95f06711b8c297f9eb8290a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keywords2&lt;/code&gt; has duplicate keys, the given function will be invoked for each matching pair in &lt;code&gt;keywords1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;keywords2&lt;/code&gt; имеют повторяющиеся ключи, данная функция будет вызываться для каждой совпадающей пары в &lt;code&gt;keywords1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cda0fc7deb1f2ca2778dbdfbc7cd47a0b34753a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kind&lt;/code&gt; is &lt;code&gt;{:EXIT, pid}&lt;/code&gt;, it does not generate a stacktrace, as such exits are retrieved as messages without stacktraces.</source>
          <target state="translated">Если &lt;code&gt;kind&lt;/code&gt; равно &lt;code&gt;{:EXIT, pid}&lt;/code&gt; , он не генерирует трассировку стека, поскольку такие выходы извлекаются как сообщения без трассировки стека.</target>
        </trans-unit>
        <trans-unit id="bfc34d2fd024a4826aee6c45876a01c2984997a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;left&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; ; в противном случае возвращается &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bbd966d4ee1229ab0c4a3f43a8067bf69d0b551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;left&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; , возвращает &lt;code&gt;true&lt;/code&gt; ; в противном случае возвращается &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e10ea7dbc53bb25e7807935c07de908ca7820b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is an integer, that's the indentation appended to line breaks whenever they occur. If the level is &lt;code&gt;:cursor&lt;/code&gt;, the current position of the &quot;cursor&quot; in the document becomes the nesting. If the level is &lt;code&gt;:reset&lt;/code&gt;, it is set back to 0.</source>
          <target state="translated">Если &lt;code&gt;level&lt;/code&gt; является целым числом, это отступ, добавляемый к разрывам строки всякий раз, когда они происходят. Если уровень &lt;code&gt;:cursor&lt;/code&gt; , текущая позиция &amp;laquo;курсора&amp;raquo; в документе становится вложенной. Если уровень &lt;code&gt;:reset&lt;/code&gt; , он возвращается к 0.</target>
        </trans-unit>
        <trans-unit id="b432fb4f2fd1db528a9d6842cc318272507dcd19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;map&lt;/code&gt; содержит &lt;code&gt;key&lt;/code&gt; , возвращается соответствующее значение. Если &lt;code&gt;map&lt;/code&gt; не содержит &lt;code&gt;key&lt;/code&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="1bef2ee214360ef957032a298b1eb3e6a4177ceb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; then its value is returned in the shape of &lt;code&gt;{:ok, value}&lt;/code&gt;. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;map&lt;/code&gt; содержит данный &lt;code&gt;key&lt;/code&gt; то его значение возвращается в виде &lt;code&gt;{:ok, value}&lt;/code&gt; . Если &lt;code&gt;map&lt;/code&gt; не содержит &lt;code&gt;key&lt;/code&gt; , возвращается &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="167313c87cdf050139328eaa55e0c8e46388fa2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;map&lt;/code&gt; содержит данный &lt;code&gt;key&lt;/code&gt; со значением &lt;code&gt;value&lt;/code&gt; , то возвращается &lt;code&gt;{:ok, value}&lt;/code&gt; . Если &lt;code&gt;map&lt;/code&gt; не содержит &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;:error&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="c6733d65c27213cccbcddb83b9fc95fccaae0b10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;map&lt;/code&gt; содержит данный &lt;code&gt;key&lt;/code&gt; , возвращается соответствующее значение. Если &lt;code&gt;map&lt;/code&gt; не содержит &lt;code&gt;key&lt;/code&gt; , &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError .</target>
        </trans-unit>
        <trans-unit id="35d7fd154ea4c9faf69570f99b8c5aa4a3ac9ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;match&lt;/code&gt; является &lt;code&gt;&quot;&quot;&lt;/code&gt; , эта функция поднимает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; исключение: это происходит потому , что эта функция заменяет &lt;strong&gt;все&lt;/strong&gt; вхождения &lt;code&gt;match&lt;/code&gt; в начале &lt;code&gt;string&lt;/code&gt; , и это невозможно заменить &amp;laquo;несколько&amp;raquo; вхождения &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b141a234955b46f94cdff6fb97f75b39d6831d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;match&lt;/code&gt; является &lt;code&gt;&quot;&quot;&lt;/code&gt; , эта функция поднимает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; исключение: это происходит потому , что эта функция заменяет &lt;strong&gt;все&lt;/strong&gt; вхождения &lt;code&gt;match&lt;/code&gt; в конце &lt;code&gt;string&lt;/code&gt; , и это невозможно заменить &amp;laquo;несколько&amp;raquo; вхождения &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0185f097241d680d296e419b968e47a3c5201c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;match&lt;/code&gt; является &lt;code&gt;&quot;&quot;&lt;/code&gt; , эта функция поднимает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; исключение: это происходит потому , что эта функция заменяет &lt;strong&gt;все&lt;/strong&gt; вхождения &lt;code&gt;match&lt;/code&gt; в начале &lt;code&gt;string&lt;/code&gt; , и это невозможно заменить &amp;laquo;несколько&amp;raquo; вхождения &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e72270cb672e9e4c9f071af85be8440eb64c674" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;match&lt;/code&gt; является &lt;code&gt;&quot;&quot;&lt;/code&gt; , эта функция поднимает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; исключение: это происходит потому , что эта функция заменяет &lt;strong&gt;все&lt;/strong&gt; вхождения &lt;code&gt;match&lt;/code&gt; в конце &lt;code&gt;string&lt;/code&gt; , и это невозможно заменить &amp;laquo;несколько&amp;raquo; вхождения &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9bdc0c8aedc4a0581ea9ca9cb9ad9a4fe54a0d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modifiers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer:</source>
          <target state="translated">Если &lt;code&gt;modifiers&lt;/code&gt; является &lt;code&gt;[]&lt;/code&gt; , то единственное число (которое может быть положительным или отрицательным) возвращается. Для изменения свойств возвращаемого целого числа можно передать другие модификаторы:</target>
        </trans-unit>
        <trans-unit id="ad9eab2323c428de698fefc4bfc22b40c45681ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is an Erlang module (as opposed to an Elixir module), this function always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;module&lt;/code&gt; является модулем Erlang (в отличие от модуля Elixir), эта функция всегда возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de03926a3208aa38b1bdc68fa4dd867a9992c7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;monitor_ref&lt;/code&gt; is a reference which the calling process obtained by calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;monitor/1&lt;/code&gt;&lt;/a&gt;, that monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">Если &lt;code&gt;monitor_ref&lt;/code&gt; - это ссылка, которую вызывающий процесс получил, вызвав &lt;a href=&quot;#monitor/1&quot;&gt; &lt;code&gt;monitor/1&lt;/code&gt; &lt;/a&gt; , этот мониторинг отключен. Если мониторинг уже отключен, ничего не происходит.</target>
        </trans-unit>
        <trans-unit id="a32f1f48118a9d4a2686cda59499e6684c476f2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an atom, it just calls &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; with the atom as the first argument and &lt;code&gt;[]&lt;/code&gt; as the second argument.</source>
          <target state="translated">Если &lt;code&gt;msg&lt;/code&gt; является атомом, он просто вызывает &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; с атомом в качестве первого аргумента и &lt;code&gt;[]&lt;/code&gt; в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="e2591f3e8296742e9e675974bb3bfcb35d27b411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an exception struct, it is raised as is.</source>
          <target state="translated">Если &lt;code&gt;msg&lt;/code&gt; является структурой исключения, она создается как есть.</target>
        </trans-unit>
        <trans-unit id="cefdb1ca1740aca5f5451a4dad984640e42d15f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Если &lt;code&gt;msg&lt;/code&gt; - что-то еще, &lt;code&gt;raise&lt;/code&gt; не удастся с исключением &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f440776b416dcca31a3b5404a0ec8e4143798ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Если &lt;code&gt;msg&lt;/code&gt; - что-то еще, &lt;code&gt;raise&lt;/code&gt; не удастся с исключением &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="737a631e71f8710e641fef02c56115e74ed17ea3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; равно &lt;code&gt;0&lt;/code&gt; , возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="bc62758814a2f1d1d281641eed97d732d6ff6ae5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned.</source>
          <target state="translated">Если &lt;code&gt;node&lt;/code&gt; не существует, возвращается бесполезный PID.</target>
        </trans-unit>
        <trans-unit id="63d9a61082e21b3845e40428cb3a08f3ea73ce2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;enumerable&lt;/code&gt; is directly converted to a list, without &lt;code&gt;fun&lt;/code&gt; being ever applied.</source>
          <target state="translated">Если &lt;code&gt;nth&lt;/code&gt; является &lt;code&gt;0&lt;/code&gt; , то &lt;code&gt;enumerable&lt;/code&gt; непосредственно преобразуется в список, не &lt;code&gt;fun&lt;/code&gt; быть когда - либо применяться.</target>
        </trans-unit>
        <trans-unit id="2840ae873ffd42facf8e147450543acef64559c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; exists and is a symlink, returns &lt;code&gt;{:ok, target}&lt;/code&gt;, otherwise returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; существует и является символической ссылкой, возвращает &lt;code&gt;{:ok, target}&lt;/code&gt; , иначе возвращает &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f340b85ba7c5a6e0ec3e07ae4245f7c6097e6db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является строкой, он будет использоваться как путь внутри &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;path&lt;/code&gt; - это список строк, он будет объединен (см. &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#join/1&quot;&gt; &lt;code&gt;Path.join/1&lt;/code&gt; &lt;/a&gt; ), и результат будет использован как путь внутри &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c154c595d1b4a01fb083386caa6ace778641f9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;path#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является строкой, он будет использоваться как путь внутри &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;path&lt;/code&gt; - это список строк, он будет объединен (см. &lt;a href=&quot;path#join/1&quot;&gt; &lt;code&gt;Path.join/1&lt;/code&gt; &lt;/a&gt; ), и результат будет использован как путь внутри &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30981afdf653766b4f2d8e17a8e76f8900fd6c71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored. See also &lt;a href=&quot;#relative_to/2&quot;&gt;&lt;code&gt;relative_to/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; уже является абсолютным путем, &lt;code&gt;relative_to&lt;/code&gt; игнорируется. См. Также &lt;a href=&quot;#relative_to/2&quot;&gt; &lt;code&gt;relative_to/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4964bfcbfec35a641632c64af60eb6aaa93a561b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; points to a file, prints its full path.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; указывает на файл, печатает его полный путь.</target>
        </trans-unit>
        <trans-unit id="4b1a93e9b2e0e773dda7a088ec139c68425c9cc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_wildcard&lt;/code&gt; is a wildcard, then all the files matching that wildcard will be imported; if no file matches the wildcard, no errors are raised. If &lt;code&gt;path_or_wildcard&lt;/code&gt; is not a wildcard but a path to a single file, then that file is imported; in case the file doesn't exist, an error is raised.</source>
          <target state="translated">Если &lt;code&gt;path_or_wildcard&lt;/code&gt; - это подстановочный знак, то все файлы, соответствующие этому подстановочному знаку , будут импортированы; если ни один файл не соответствует подстановочному знаку, ошибки не возникают. Если &lt;code&gt;path_or_wildcard&lt;/code&gt; не является подстановочным знаком, а является путем к одному файлу, то этот файл импортируется; если файл не существует, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="4ed36549216e7c96c0405d66d46c768efd40ee4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is not trapping exits, &lt;code&gt;pid&lt;/code&gt; will exit with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;pid&lt;/code&gt; не перехватывает выходы, &lt;code&gt;pid&lt;/code&gt; выйдет по указанной &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="633950331a76abae7c27012953c6b5ce717504f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;pid&lt;/code&gt; перехватывает выходы, сигнал выхода преобразуется в сообщение &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; и доставляется в очередь сообщений &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edb5e8ad174fd02444bbcb56b3f2079cf73580c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix&lt;/code&gt; is an empty list, it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;prefix&lt;/code&gt; - пустой список, он возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26bd0886bea64b0650f1573c9fd139f06c9e5d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is neither &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt;, nor &lt;code&gt;{:shutdown, term}&lt;/code&gt; an error is logged.</source>
          <target state="translated">Если &lt;code&gt;reason&lt;/code&gt; не является ни &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; , ни &lt;code&gt;{:shutdown, term}&lt;/code&gt; ошибка регистрируются.</target>
        </trans-unit>
        <trans-unit id="5c120fe241858b080c2215e59c9d1dfe3c97d43f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:kill&lt;/code&gt;, that is if &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;pid&lt;/code&gt; which will unconditionally exit with reason &lt;code&gt;:killed&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;reason&lt;/code&gt; - это atom &lt;code&gt;:kill&lt;/code&gt; , то есть если &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; , на &lt;code&gt;pid&lt;/code&gt; отправляется неотражаемый сигнал выхода, который безоговорочно завершает работу с причиной &lt;code&gt;:killed&lt;/code&gt; kill .</target>
        </trans-unit>
        <trans-unit id="c72ae981d0ae09b809a5b5a5aa46cd4ec885a9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;pid&lt;/code&gt; will not exit (unless &lt;code&gt;pid&lt;/code&gt; is the calling process, in which case it will exit with the reason &lt;code&gt;:normal&lt;/code&gt;). If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">Если &lt;code&gt;reason&lt;/code&gt; - атом &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;pid&lt;/code&gt; не завершится (если &lt;code&gt;pid&lt;/code&gt; не является вызывающим процессом, и в этом случае он выйдет с причиной &lt;code&gt;:normal&lt;/code&gt; ). Если это перехват выхода, сигнал выхода преобразуется в сообщение &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; и доставляется в его очередь сообщений.</target>
        </trans-unit>
        <trans-unit id="0983db92616650bea49a21e4bb3960c0964601e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;right&lt;/code&gt; is a regular expression, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; matches right.</source>
          <target state="translated">Если &lt;code&gt;right&lt;/code&gt; является регулярным выражением, возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;left&lt;/code&gt; соответствует right.</target>
        </trans-unit>
        <trans-unit id="d39df5af32cb5fb2bbe1045964270d68e1f1f5a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;right&lt;/code&gt; is a string, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; contains &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;right&lt;/code&gt; - строка, возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;left&lt;/code&gt; содержит &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def9dbc5ab56f1b825b6729ff4b5f2b1cf2751f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or &lt;code&gt;{:ok, keywords | map}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="translated">Если &lt;code&gt;setup_all&lt;/code&gt; или &lt;code&gt;setup&lt;/code&gt; возвращают список ключевых слов, карту или &lt;code&gt;{:ok, keywords | map}&lt;/code&gt; , список ключевых слов или карта будут объединены в текущий контекст и будут доступны во всех последующих &lt;code&gt;setup_all&lt;/code&gt; , &lt;code&gt;setup&lt;/code&gt; и самом &lt;code&gt;test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="427abb795faa00170a2a73c64fef9d4e09adf4d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or a tuple in the shape of &lt;code&gt;{:ok, keyword() | map()}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="translated">Если &lt;code&gt;setup_all&lt;/code&gt; или &lt;code&gt;setup&lt;/code&gt; возвращают список ключевых слов, карту или кортеж в форме &lt;code&gt;{:ok, keyword() | map()}&lt;/code&gt; , список ключевых слов или карта будут объединены в текущий контекст и будут доступны во всех последующих &lt;code&gt;setup_all&lt;/code&gt; , &lt;code&gt;setup&lt;/code&gt; и самом &lt;code&gt;test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="977e9939903f7075b75909cc132a74bc274c1bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a directory, or a symbolic link to it, then &lt;code&gt;destination&lt;/code&gt; must be an existent &lt;code&gt;directory&lt;/code&gt; or a symbolic link to one, or a path to a non-existent directory.</source>
          <target state="translated">Если &lt;code&gt;source&lt;/code&gt; является каталог или символическая ссылка на него, то &lt;code&gt;destination&lt;/code&gt; должен быть существующий &lt;code&gt;directory&lt;/code&gt; или символическая ссылка на него, или путь к несуществующему каталогу.</target>
        </trans-unit>
        <trans-unit id="1031bcdd561dcecee641f002ce883c7af7e61139" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a file or a symbolic link to it, &lt;code&gt;destination&lt;/code&gt; must be a path to an existent file, a symbolic link to one, or a path to a non-existent file.</source>
          <target state="translated">Если &lt;code&gt;source&lt;/code&gt; является файл или символическая ссылка на него, &lt;code&gt;destination&lt;/code&gt; должен быть путь к существующему файлу, символическая ссылка на него или путь к несуществующему файлу.</target>
        </trans-unit>
        <trans-unit id="e57c5ea9358fe4a917bdf2d9fa6f002a7ca491dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если ссылка на &lt;code&gt;start&lt;/code&gt; или &lt;code&gt;length&lt;/code&gt; каким-либо образом вне двоичного файла, возникает исключение &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc6be87bc2a88ec11feb6fb3046cd38c5b7a4a35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если ссылка на &lt;code&gt;start&lt;/code&gt; или &lt;code&gt;length&lt;/code&gt; каким-либо образом вне двоичного файла, возникает исключение &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="148baaf20a5501cf402aa842127aa44f861d748c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidRequirementError.html&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;string&lt;/code&gt; является недопустимым требованием, возникает &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidRequirementError.html&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd707d6ea9c236adf3d2d26891903697d910f532" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;version.invalidrequirementerror&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;string&lt;/code&gt; является недопустимым требованием, возникает &lt;a href=&quot;version.invalidrequirementerror&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8f525d0b692b55f071ed6b31ea8e88fb78dc738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;string&lt;/code&gt; является недопустимой версией, возникает &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f9f03b1dcc9dbff5dcc7644074dd977a2959ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;string&lt;/code&gt; является недопустимой версией, возникает &lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1f85d96ca473515ee41dccc4b5c470d6806e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; already exists and the contents are not the same, it asks for user confirmation.</source>
          <target state="translated">Если &lt;code&gt;target&lt;/code&gt; уже существует и ее содержимое не совпадает, она запрашивает подтверждение пользователя.</target>
        </trans-unit>
        <trans-unit id="ae363da5635ac26a38468a274fa68594bffd7223" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is already a list, it returns the list. If &lt;code&gt;term&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, it returns an empty list.</source>
          <target state="translated">Если &lt;code&gt;term&lt;/code&gt; уже является списком, он возвращает список. Если &lt;code&gt;term&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; , возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="c189d5b72f733627440a207910c642f9ff77e60b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;%URI{}&lt;/code&gt; struct is given to this function, this function returns it unmodified.</source>
          <target state="translated">Если этой функции передается структура &lt;code&gt;%URI{}&lt;/code&gt; , эта функция возвращает ее без изменений.</target>
        </trans-unit>
        <trans-unit id="abcc9ba322766c6ecd47929cf37e2de456cad2b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;:skip&lt;/code&gt; tag is found in &lt;code&gt;tags&lt;/code&gt;, &lt;code&gt;{:skipped, message}&lt;/code&gt; is returned if the test has been left after the &lt;code&gt;exclude&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt; filters. Otherwise &lt;code&gt;{:exclude, message}&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;:skip&lt;/code&gt; тег найден в &lt;code&gt;tags&lt;/code&gt; , &lt;code&gt;{:skipped, message}&lt;/code&gt; возвращается , если тест был оставлен после &lt;code&gt;exclude&lt;/code&gt; и &lt;code&gt;include&lt;/code&gt; фильтры. В противном случае возвращается &lt;code&gt;{:exclude, message}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae7e1652eb18779b4dcf4919c203ef71000bcfb9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;config/runtime.exs&lt;/code&gt; exists, it will be copied to your release and executed early in the boot process, when only Elixir and Erlang's main applications have been started. Once the configuration is loaded, the Erlang system will be restarted (within the same Operating System process) and the new configuration will take place.</source>
          <target state="translated">Если существует &lt;code&gt;config/runtime.exs&lt;/code&gt; , он будет скопирован в ваш выпуск и запущен в начале процесса загрузки, когда были запущены только основные приложения Elixir и Erlang. После загрузки конфигурации система Erlang будет перезапущена (в рамках того же процесса операционной системы), и будет выполнена новая конфигурация.</target>
        </trans-unit>
        <trans-unit id="9cb5769774bfa8aa4c65da1e51375f078f53a47d" translate="yes" xml:space="preserve">
          <source>If a byte has 8 bits, what happens if we pass a size of 1 bit?</source>
          <target state="translated">Если байт имеет 8 бит,что произойдет,если мы передадим размер в 1 бит?</target>
        </trans-unit>
        <trans-unit id="0ac581e270299e95270be44edc11d5d78635bdbb" translate="yes" xml:space="preserve">
          <source>If a callback is given, it is invoked for each received message.</source>
          <target state="translated">При получении обратного вызова он вызывается для каждого полученного сообщения.</target>
        </trans-unit>
        <trans-unit id="9510d4ce0d205517cf9f92994b15bfbfe1510aa1" translate="yes" xml:space="preserve">
          <source>If a callback module that implements a given behaviour doesn't export all the functions and macros defined by that behaviour, the user will be notified through warnings during the compilation process (no errors will happen).</source>
          <target state="translated">Если модуль обратного вызова,реализующий заданное поведение,не экспортирует все функции и макросы,определяемые этим поведением,пользователь будет уведомлен посредством предупреждений в процессе компиляции (ошибок не будет).</target>
        </trans-unit>
        <trans-unit id="69b52804cd17d7f8a0689854f3222713a2e4c149" translate="yes" xml:space="preserve">
          <source>If a child specification with the specified ID already exists, &lt;code&gt;child_spec&lt;/code&gt; is discarded and this function returns an error with &lt;code&gt;:already_started&lt;/code&gt; or &lt;code&gt;:already_present&lt;/code&gt; if the corresponding child process is running or not, respectively.</source>
          <target state="translated">Если &lt;code&gt;child_spec&lt;/code&gt; спецификация с указанным идентификатором уже существует, child_spec отбрасывается, и эта функция возвращает ошибку с &lt;code&gt;:already_started&lt;/code&gt; или &lt;code&gt;:already_present&lt;/code&gt; , если соответствующий дочерний процесс запущен или нет, соответственно.</target>
        </trans-unit>
        <trans-unit id="624738a0046889600ef5bfdcc03d5da8090ab0e9" translate="yes" xml:space="preserve">
          <source>If a cookie option was given, we compare it with the contents of the file (if any), and ask the user if they want to override.</source>
          <target state="translated">Если был задан параметр cookie,мы сравниваем его с содержимым файла (если таковой имеется),и спрашиваем пользователя,не хотят ли они переопределить его.</target>
        </trans-unit>
        <trans-unit id="4e2890f26410463009016ad753f613992362cbef" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes &lt;code&gt;callback&lt;/code&gt;. &lt;code&gt;callback&lt;/code&gt; must be a function that takes two arguments: &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;. The callback should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Если файл уже существует в месте назначения, он вызывает &lt;code&gt;callback&lt;/code&gt; . &lt;code&gt;callback&lt;/code&gt; должен быть функцией, которая принимает два аргумента: &lt;code&gt;source&lt;/code&gt; и &lt;code&gt;destination&lt;/code&gt; . Обратный вызов должен возвращать &lt;code&gt;true&lt;/code&gt; , если существующий файл должен быть перезаписан, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="cabdc7b8c3d548d6762d990a45e3c0db4093b48f" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes a callback which should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten, &lt;code&gt;false&lt;/code&gt; otherwise. The callback defaults to return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если файл уже существует в месте назначения, он вызывает обратный вызов, который должен вернуть &lt;code&gt;true&lt;/code&gt; , если существующий файл должен быть перезаписан, и &lt;code&gt;false&lt;/code&gt; в противном случае. По умолчанию обратный вызов возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f5282b08680f8cf98b1cf98c1763e902d8a8cf1" translate="yes" xml:space="preserve">
          <source>If a function is provided, the device will be created and sent to the function. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">Если функция предоставлена, устройство будет создано и отправлено в функцию. Когда функция вернется, устройство будет закрыто. Конечным результатом будет кортеж с &lt;code&gt;:ok&lt;/code&gt; и результатом функции.</target>
        </trans-unit>
        <trans-unit id="d38f06a2f29af4b9a58ad54b574b4b65c78e3313" translate="yes" xml:space="preserve">
          <source>If a function with default values has multiple clauses, it is required to create a function head (without an actual body) for declaring defaults:</source>
          <target state="translated">Если функция со значениями по умолчанию имеет несколько пунктов,то для объявления значений по умолчанию необходимо создать голову функции (без фактического тела):</target>
        </trans-unit>
        <trans-unit id="000c898cfeca7c250248fbd1fa1ca561171bdc1f" translate="yes" xml:space="preserve">
          <source>If a given line starts a &lt;code&gt;describe&lt;/code&gt; block, that line filter runs all tests in it. Otherwise, it runs the closest test on or before the given line number.</source>
          <target state="translated">Если данная строка начинает блок &lt;code&gt;describe&lt;/code&gt; , этот строковый фильтр запускает все тесты в ней. В противном случае он запускает ближайший тест на заданном номере строки или перед ним.</target>
        </trans-unit>
        <trans-unit id="d537fdd4d0b14a07a0a04df5203e5b0b7c078fd6" translate="yes" xml:space="preserve">
          <source>If a key in the pattern is not available in the map, then they won't match:</source>
          <target state="translated">Если ключ на карте недоступен,то он не будет совпадать:</target>
        </trans-unit>
        <trans-unit id="79925800db01e377c0a45bd22e7acc683fbfbe07" translate="yes" xml:space="preserve">
          <source>If a key is a function, the function will be invoked passing three arguments:</source>
          <target state="translated">Если ключ является функцией,то функция будет вызвана с передачей трех аргументов:</target>
        </trans-unit>
        <trans-unit id="29fd70a945f925cf23cc7e6f8035b1a44027a7d0" translate="yes" xml:space="preserve">
          <source>If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:</source>
          <target state="translated">Если список составлен из неотрицательных целых чисел,где каждое целое число представляет собой точку кода Юникода,то список также можно назвать charlist.Эти целые числа должны:</target>
        </trans-unit>
        <trans-unit id="459ad8c7d2d4dfeac7cad82c1512116c71e69047" translate="yes" xml:space="preserve">
          <source>If a list of dependencies is given, Mix will attempt to compile them as is. For example, if project &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt;, calling &lt;code&gt;mix deps.compile a&lt;/code&gt; will compile &lt;code&gt;a&lt;/code&gt; even if &lt;code&gt;b&lt;/code&gt; is out of date. This is to allow parts of the dependency tree to be recompiled without propagating those changes upstream. To ensure &lt;code&gt;b&lt;/code&gt; is included in the compilation step, pass &lt;code&gt;--include-children&lt;/code&gt;.</source>
          <target state="translated">Если указан список зависимостей, Mix попытается скомпилировать их как есть. Например, если проект &lt;code&gt;a&lt;/code&gt; зависит от &lt;code&gt;b&lt;/code&gt; , вызов &lt;code&gt;mix deps.compile a&lt;/code&gt; скомпилирует &lt;code&gt;a&lt;/code&gt; , даже если &lt;code&gt;b&lt;/code&gt; устарел. Это сделано для того, чтобы части дерева зависимостей можно было перекомпилировать без распространения этих изменений вверх по течению. Чтобы убедиться, что &lt;code&gt;b&lt;/code&gt; включен в шаг компиляции, передайте &lt;code&gt;--include-children&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b421abd37694bae36c7d25d86ffa518fdbbea4dd" translate="yes" xml:space="preserve">
          <source>If a module adopting a given behaviour doesn&amp;rsquo;t implement one of the callbacks required by that behaviour, a compile-time warning will be generated.</source>
          <target state="translated">Если модуль, использующий данное поведение, не реализует один из обратных вызовов, требуемых этим поведением, будет сгенерировано предупреждение во время компиляции.</target>
        </trans-unit>
        <trans-unit id="883d15353620b14cbb9c9d5a06e95f6b6c4d20b6" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of elements will be taken from the end. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">Если задано отрицательное &lt;code&gt;amount&lt;/code&gt; , &lt;code&gt;amount&lt;/code&gt; элементов будет снято с конца. &lt;code&gt;enumerable&lt;/code&gt; будут перечислены один раз , чтобы получить правильный индекс , а остальное вычисление выполняется с конца.</target>
        </trans-unit>
        <trans-unit id="6cc671d5a37ef968ded5582cc81fb0522d873170" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of last values will be dropped. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">Если задано отрицательное &lt;code&gt;amount&lt;/code&gt; , &lt;code&gt;amount&lt;/code&gt; последних значений будет отброшено. &lt;code&gt;enumerable&lt;/code&gt; будут перечислены один раз , чтобы получить правильный индекс , а остальное вычисление выполняется с конца.</target>
        </trans-unit>
        <trans-unit id="59caaee16729c3dbee5fe847e2d7d4842c9c683a" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;count&lt;/code&gt; is given, the last &lt;code&gt;count&lt;/code&gt; values will be taken. For such, the collection is fully enumerated keeping up to &lt;code&gt;2 * count&lt;/code&gt; elements in memory. Once the end of the collection is reached, the last &lt;code&gt;count&lt;/code&gt; elements will be executed. Therefore, using a negative &lt;code&gt;count&lt;/code&gt; on an infinite collection will never return.</source>
          <target state="translated">Если дан отрицательный &lt;code&gt;count&lt;/code&gt; , будут взяты последние значения &lt;code&gt;count&lt;/code&gt; . Для этого коллекция полностью пронумерована, сохраняя в памяти до &lt;code&gt;2 * count&lt;/code&gt; элементов count . По достижении конца коллекции будут выполнены последние элементы &lt;code&gt;count&lt;/code&gt; . Следовательно, использование отрицательного &lt;code&gt;count&lt;/code&gt; для бесконечной коллекции никогда не вернется.</target>
        </trans-unit>
        <trans-unit id="f69e4dbe00c1ada199c059c775f25efeb8310586" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;n&lt;/code&gt; is given, it will drop the last &lt;code&gt;n&lt;/code&gt; elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until &lt;code&gt;n&lt;/code&gt; additional elements have been emitted by the enum.</source>
          <target state="translated">Если задано отрицательное значение &lt;code&gt;n&lt;/code&gt; , из коллекции будут удалены последние &lt;code&gt;n&lt;/code&gt; элементов. Обратите внимание, что механизм, с помощью которого это реализовано, будет задерживать выдачу любого элемента до тех пор, пока перечисление не испустит &lt;code&gt;n&lt;/code&gt; дополнительных элементов.</target>
        </trans-unit>
        <trans-unit id="1945f4f47fb811a9fdec36bceacc04e13f4b23dd" translate="yes" xml:space="preserve">
          <source>If a non-unique registry is given, an error is raised.</source>
          <target state="translated">Если дается неуникальный реестр,то возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="7fe100a04f7f3c2228565ba1dad4a516ece48f3e" translate="yes" xml:space="preserve">
          <source>If a positive &lt;code&gt;amount&lt;/code&gt; is given, it takes the &lt;code&gt;amount&lt;/code&gt; elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Если задана положительная &lt;code&gt;amount&lt;/code&gt; , она берет элементы &lt;code&gt;amount&lt;/code&gt; с начала &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="273c42e7694ef6f6a0ae619fbbe7e5dc6c7edfb5" translate="yes" xml:space="preserve">
          <source>If a previous value is already stored, all entries are removed and the value is overridden.</source>
          <target state="translated">Если предыдущее значение уже сохранено,все записи удаляются,а значение переопределяется.</target>
        </trans-unit>
        <trans-unit id="44015a59f9f7a33ffc75deedd1425577f41943be" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="translated">Если реализация протокола не найдена для данного типа, вызов протокола будет вызван, если он не настроен на возврат к &lt;code&gt;Any&lt;/code&gt; . Также доступны удобства для создания реализаций поверх существующих, см. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о создании протоколов.</target>
        </trans-unit>
        <trans-unit id="43fc3383844fcfe72ece54d10710bd0bd9f25337" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="translated">Если реализация протокола не найдена для данного типа, вызов протокола будет вызван, если он не настроен на возврат к &lt;code&gt;Any&lt;/code&gt; . Также доступны удобства для создания реализаций поверх существующих, см. &lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о создании протоколов.</target>
        </trans-unit>
        <trans-unit id="a016d1410ce73603f7d41b32703713ab6681b5cb" translate="yes" xml:space="preserve">
          <source>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</source>
          <target state="translated">Если в функцию передается диапазон,то эта функция выберет случайное значение между пределами диапазона,не преодолевая при этом весь диапазон (таким образом,выполняясь в постоянном времени и постоянной памяти).</target>
        </trans-unit>
        <trans-unit id="4e6fe5e08b24cf20a9c0798353e64ac83dfa14b4" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="translated">Если запись определяет анонимную функцию в значениях по умолчанию, будет &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; . Это может произойти непреднамеренно при определении записи после ее извлечения из библиотеки Erlang, которая использует анонимные функции по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7d5db183ff92e0f2a4bace49c1074a0f1a8e87bc" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="translated">Если запись определяет анонимную функцию в значениях по умолчанию, будет &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; . Это может произойти непреднамеренно при определении записи после ее извлечения из библиотеки Erlang, которая использует анонимные функции по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a6abb6313f6cc1303f397ef517fbdc8da84732e6" translate="yes" xml:space="preserve">
          <source>If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1.</source>
          <target state="translated">Если строка,то выдается дамп падения Erlang со статусом слогана,а затем система завершает работу со статусом с кодом 1.</target>
        </trans-unit>
        <trans-unit id="126afd1abf58596ead958f3fd3541d1004b086cc" translate="yes" xml:space="preserve">
          <source>If a switch can't be parsed according to the given type, it is returned in the invalid options list.</source>
          <target state="translated">Если коммутатор не может быть обработан в соответствии с заданным типом,он возвращается в список недействительных опций.</target>
        </trans-unit>
        <trans-unit id="2b1173f30bab1103a16e4d18afe172d1cf1918aa" translate="yes" xml:space="preserve">
          <source>If a tag is given more than once, the last value wins.</source>
          <target state="translated">Если тег дается несколько раз,то выигрывает последнее значение.</target>
        </trans-unit>
        <trans-unit id="25bcdf5eebbd3c58586886d967dc6654eabd51f6" translate="yes" xml:space="preserve">
          <source>If a task crashes, the callers field is included as part of the log message metadata under the &lt;code&gt;:callers&lt;/code&gt; key.</source>
          <target state="translated">В случае сбоя задачи поле вызывающих абонентов включается как часть метаданных сообщения журнала под ключом &lt;code&gt;:callers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f25a0e999e5079ecb734e6ae102d4bb2431a7f" translate="yes" xml:space="preserve">
          <source>If a task has requirements, they can be listed using the &lt;code&gt;@requirements&lt;/code&gt; attribute. For example:</source>
          <target state="translated">Если у задачи есть требования, их можно перечислить с &lt;code&gt;@requirements&lt;/code&gt; атрибута @requirements . Например:</target>
        </trans-unit>
        <trans-unit id="05107c81774e13529708289068c52809a60e340f" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="translated">Если для задачи требуется определение проекта или требуется доступ к специальной функции внутри проекта, задача может вызвать &lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;Mix.Project.get!/0&lt;/code&gt; ,&lt;/a&gt; который завершится ошибкой &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt; в случае, если проект не определен.</target>
        </trans-unit>
        <trans-unit id="30a9473b0d912205c959737a706b0e7ee4a0ec9d" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;mix.project#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="translated">Если для задачи требуется определение проекта или требуется доступ к специальной функции в проекте, задача может вызвать &lt;a href=&quot;mix.project#get!/0&quot;&gt; &lt;code&gt;Mix.Project.get!/0&lt;/code&gt; ,&lt;/a&gt; который завершается ошибкой &lt;a href=&quot;mix.noprojecterror&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt; в случае, если проект не определен.</target>
        </trans-unit>
        <trans-unit id="c67bc32edf1527e959986e52e98d4224edd81679" translate="yes" xml:space="preserve">
          <source>If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return &lt;code&gt;{:exit, :noproc}&lt;/code&gt; as the result or exit reason can not be determined.</source>
          <target state="translated">Если монитор задачи уже был демонитирован или получен и в очереди сообщений нет ожидающего ответа, эта функция вернет &lt;code&gt;{:exit, :noproc}&lt;/code&gt; как результат или причину выхода определить невозможно.</target>
        </trans-unit>
        <trans-unit id="1a77a9db2807ea258346d1c8035a43bea2a0103f" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same pattern:</source>
          <target state="translated">Если переменная упоминается в детали более одного раза,все ссылки должны быть привязаны к одной и той же детали:</target>
        </trans-unit>
        <trans-unit id="8341a6ce2bd527f498f269d473191d8c74061cd6" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same value:</source>
          <target state="translated">Если переменная упоминается в шаблоне более одного раза,все ссылки должны быть привязаны к одному и тому же значению:</target>
        </trans-unit>
        <trans-unit id="2d5176a6bc70715553073a28b4fe06e7f78373b7" translate="yes" xml:space="preserve">
          <source>If all clauses match, the &lt;code&gt;do&lt;/code&gt; block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:</source>
          <target state="translated">Если все предложения совпадают, &lt;code&gt;do&lt;/code&gt; блок do , возвращающий свой результат. В противном случае цепочка прерывается и возвращается несоответствующее значение:</target>
        </trans-unit>
        <trans-unit id="e9c4638272580cddbbaefbc10d002d4b066670b8" translate="yes" xml:space="preserve">
          <source>If all of the conditions return &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, an error (&lt;code&gt;CondClauseError&lt;/code&gt;) is raised. For this reason, it may be necessary to add a final condition, equal to &lt;code&gt;true&lt;/code&gt;, which will always match:</source>
          <target state="translated">Если все условия возвращают &lt;code&gt;nil&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , возникает ошибка ( &lt;code&gt;CondClauseError&lt;/code&gt; ). По этой причине может потребоваться добавить последнее условие, равное &lt;code&gt;true&lt;/code&gt; , которое всегда будет соответствовать:</target>
        </trans-unit>
        <trans-unit id="1ce3955a535274dbe7df8b09ce910f413bd1bd52" translate="yes" xml:space="preserve">
          <source>If amount is &lt;code&gt;0&lt;/code&gt;, it returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Если сумма равна &lt;code&gt;0&lt;/code&gt; , возвращается &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="195d921f30b7ca6822ad57816fd9a2da342da9c2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is present, it will match on the results of the &lt;code&gt;try&lt;/code&gt; block whenever the &lt;code&gt;try&lt;/code&gt; block finishes without a throw or an error.</source>
          <target state="translated">Если присутствует блок &lt;code&gt;else&lt;/code&gt; , он будет соответствовать результатам блока &lt;code&gt;try&lt;/code&gt; всякий раз, когда блок &lt;code&gt;try&lt;/code&gt; завершается без выброса или ошибки.</target>
        </trans-unit>
        <trans-unit id="678b2cde87bb40ee90e01daea6daabd5a152129d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;https://hexdocs.pm/elixir/WithClauseError.html&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если используется блок &lt;code&gt;else&lt;/code&gt; и нет подходящих предложений, &lt;a href=&quot;https://hexdocs.pm/elixir/WithClauseError.html&quot;&gt; &lt;code&gt;WithClauseError&lt;/code&gt; &lt;/a&gt; исключение WithClauseError .</target>
        </trans-unit>
        <trans-unit id="570f497970d66b8882cf83a80169ce5e7a3f4622" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;withclauseerror&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если используется блок &lt;code&gt;else&lt;/code&gt; и нет подходящих предложений, &lt;a href=&quot;withclauseerror&quot;&gt; &lt;code&gt;WithClauseError&lt;/code&gt; &lt;/a&gt; исключение WithClauseError .</target>
        </trans-unit>
        <trans-unit id="de3cca2420a70cac7a0a92d8ce5ec9857a32f5c0" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; clause is not present and no exceptions are raised, the result of the expression will be returned:</source>
          <target state="translated">Если предложение &lt;code&gt;else&lt;/code&gt; отсутствует и исключения не возникают, будет возвращен результат выражения:</target>
        </trans-unit>
        <trans-unit id="e2d3671c086be455d33d12466d3540943c7f121c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;offset&lt;/code&gt; is given, we will index from the given offset instead of from zero.</source>
          <target state="translated">Если задано &lt;code&gt;offset&lt;/code&gt; , мы будем индексировать от данного смещения, а не от нуля.</target>
        </trans-unit>
        <trans-unit id="0a648b7fb5579eaba477422e6520374ab96f3bbc" translate="yes" xml:space="preserve">
          <source>If an application has included applications, they are also loaded. And the procedure recurses if they in turn have included applications. Included applications are unrelated to applications in Mix umbrella projects, they are an Erlang/OTP concept that has to do with coordinated starts.</source>
          <target state="translated">Если в приложение включены приложения,они также загружаются.И процедура повторяется,если они,в свою очередь,включили приложения.Включенные приложения не связаны с приложениями в проектах Mix umbrella,они являются Erlang/OTP концепция,которая имеет отношение к согласованным запускам.</target>
        </trans-unit>
        <trans-unit id="c19cd9003fb6605f04e0b314c975e08d6865c82c" translate="yes" xml:space="preserve">
          <source>If an argument is provided, it should be a local path to a prebuilt archive, a Git repository, a GitHub repository, or a Hex package.</source>
          <target state="translated">Если аргумент предоставлен,то это должен быть локальный путь к предварительно собранному архиву,Git-репозиторию,GitHub-репозиторию или Hex-пакету.</target>
        </trans-unit>
        <trans-unit id="8777f1d4410c11fe781472a9996f7abc7e9d0ee1" translate="yes" xml:space="preserve">
          <source>If an argument is provided, it should be a local path to a prebuilt escript, a Git repository, a GitHub repository, or a Hex package.</source>
          <target state="translated">Если аргумент предоставлен,то это должен быть локальный путь к предварительно скомпилированному эскрипту,Git-репозиторию,GitHub-репозиторию или пакету Hex.</target>
        </trans-unit>
        <trans-unit id="346e510adb982fcdef487692a01e3558f4f43dd0" translate="yes" xml:space="preserve">
          <source>If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed.</source>
          <target state="translated">Если дается атом,то предполагается,что он является модулем Elixir,поэтому он преобразуется в двоичный файл и затем обрабатывается.</target>
        </trans-unit>
        <trans-unit id="1dd9c12e4c69c00fd419e79703f50c2f1eb25bbf" translate="yes" xml:space="preserve">
          <source>If an empty string is given, returns an empty list.</source>
          <target state="translated">Если задана пустая строка,возвращает пустой список.</target>
        </trans-unit>
        <trans-unit id="b8c7e22d59114292a3302ce7be80d94101c6ff48" translate="yes" xml:space="preserve">
          <source>If an integer, the runtime system exits with the integer value which is returned to the operating system.</source>
          <target state="translated">Если используется целое число,то выполняющая система завершает работу с тем целым значением,которое возвращается в операционную систему.</target>
        </trans-unit>
        <trans-unit id="7d3f5440412ded7562694390034be201abb74a66" translate="yes" xml:space="preserve">
          <source>If an umbrella project reenables a task, it is reenabled for all child projects.</source>
          <target state="translated">Если зонтичный проект возобновляет задачу,то он возобновляется для всех дочерних проектов.</target>
        </trans-unit>
        <trans-unit id="a96ebc73b0c26a7d76054b4183ec0b8df86f83ca" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;--check-*&lt;/code&gt; options are given and a check fails, the formatted contents won't be written to disk nor printed to standard output.</source>
          <target state="translated">Если &lt;code&gt;--check-*&lt;/code&gt; какой-либо из параметров --check- * и проверка не удалась, отформатированное содержимое не будет записано на диск и не распечатано на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="642cb4f6ac7d478befb880a0aa0031be148b3d13" translate="yes" xml:space="preserve">
          <source>If any of the files is &lt;code&gt;-&lt;/code&gt;, then the output is read from stdin and written to stdout.</source>
          <target state="translated">Если какой-либо из файлов &lt;code&gt;-&lt;/code&gt; , то вывод считывается из стандартного ввода и записывается в стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="f55410e6ca8aea2aa1012bcfa7157dec87ff1c3f" translate="yes" xml:space="preserve">
          <source>If any of the task processes dies, the current process will exit with the same reason as that task.</source>
          <target state="translated">Если какой-нибудь из процессов задачи умрет,то текущий процесс завершит свою работу по той же причине,что и эта задача.</target>
        </trans-unit>
        <trans-unit id="ea3148cc3562102872f247d7ecd3f95cbb26a611" translate="yes" xml:space="preserve">
          <source>If any of the values are &lt;code&gt;nil&lt;/code&gt;, they are omitted.</source>
          <target state="translated">Если какое-либо из значений &lt;code&gt;nil&lt;/code&gt; , они опускаются.</target>
        </trans-unit>
        <trans-unit id="033137dbcc6d7e358cdff1f234f1f034d23cee4d" translate="yes" xml:space="preserve">
          <source>If anything had to be compiled, you see some informative text, and get the &lt;code&gt;:ok&lt;/code&gt; atom back, otherwise the function is silent, and returns &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">Если что-то нужно было скомпилировать, вы увидите некоторый информативный текст и получите обратно атом &lt;code&gt;:ok&lt;/code&gt; , в противном случае функция молчит и вернет &lt;code&gt;:noop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9330902fc087c329eff5fc5f2a0eba15cfef47c" translate="yes" xml:space="preserve">
          <source>If both options are set, &lt;code&gt;--force&lt;/code&gt; takes precedence.</source>
          <target state="translated">Если обе опции установлены, &lt;code&gt;--force&lt;/code&gt; имеет преимущество.</target>
        </trans-unit>
        <trans-unit id="7b4dc8078aeab160f01342b984c42012d0bb7fb7" translate="yes" xml:space="preserve">
          <source>If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</source>
          <target state="translated">Если данные отправляются в файл в формате,который не может быть преобразован в UTF-8,или если данные читаются функцией,которая возвращает данные в формате,который не может справиться с диапазоном символов данных,происходит ошибка,и файл закрывается.</target>
        </trans-unit>
        <trans-unit id="9cb11ee612f8a6fa1dc16b1180f3c60b5d1e6218" translate="yes" xml:space="preserve">
          <source>If desired, you could come up with your own semantics for the size of your struct. Not only that, you could use structs to build more robust data types, like queues, and implement all relevant protocols, such as &lt;code&gt;Enumerable&lt;/code&gt; and possibly &lt;code&gt;Size&lt;/code&gt;, for this data type.</source>
          <target state="translated">При желании вы можете придумать свою собственную семантику для размера вашей структуры. Мало того, вы можете использовать структуры для создания более надежных типов данных, таких как очереди, и реализовать все соответствующие протоколы, такие как &lt;code&gt;Enumerable&lt;/code&gt; и, возможно, &lt;code&gt;Size&lt;/code&gt; , для этого типа данных.</target>
        </trans-unit>
        <trans-unit id="ea1cd1f61403fdf9495800bfd2ea11cb562ca0b5" translate="yes" xml:space="preserve">
          <source>If duplicated entries exist, the first one is returned. Use &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; to retrieve all entries.</source>
          <target state="translated">Если существуют повторяющиеся записи, возвращается первая. Используйте &lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt; для получения всех записей.</target>
        </trans-unit>
        <trans-unit id="0b592a69d9d8fd53bf0bd9cbfc055db4e81ec7c8" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. So this function will not detect empty tuples:</source>
          <target state="translated">Если каждое выражение защиты всегда возвращает булев,то эти две формы эквивалентны.Однако следует помнить,что если при вызове любой функции в защитнике возникает исключение,то сбой не справляется весь защитник.Поэтому эта функция не будет обнаруживать пустые кортежи:</target>
        </trans-unit>
        <trans-unit id="5c3eed1e3cb4bd53836b71d67f974f0d1ba37310" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. To illustrate this, the following function will not detect empty tuples:</source>
          <target state="translated">Если каждое выражение защиты всегда возвращает булев,то эти две формы эквивалентны.Однако следует помнить,что если при вызове любой функции в защитнике возникает исключение,то сбой не справляется весь защитник.Чтобы проиллюстрировать это,следующая функция не будет обнаруживать пустые кортежи:</target>
        </trans-unit>
        <trans-unit id="dbe27cd775ccec3c6324b3d4efb95e206746dc7f" translate="yes" xml:space="preserve">
          <source>If file &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten by the contents in &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;destination&lt;/code&gt; файла уже существует, оно перезаписывается содержимым &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc28a9b8dcfe0a11c8bac1e062e822f6767ef47" translate="yes" xml:space="preserve">
          <source>If file is a relative, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="translated">Если файл является относительным,то он будет расширен относительно директории,в которой находится текущий конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="42ddc2f0c1e4117e2bba8be8a09c43a0ea2ed1bd" translate="yes" xml:space="preserve">
          <source>If for some reason the application needs to be configured before it is started, the &lt;code&gt;--no-start&lt;/code&gt; option can be used and you are then responsible for starting all applications by using functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt;&lt;code&gt;Application.ensure_all_started/1&lt;/code&gt;&lt;/a&gt;. For more information about the application life-cycle and dynamically configuring applications, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Если по какой-то причине приложение необходимо настроить перед его &lt;code&gt;--no-start&lt;/code&gt; можно использовать параметр --no-start, и тогда вы несете ответственность за запуск всех приложений с помощью таких функций, как &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt; &lt;code&gt;Application.ensure_all_started/1&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о жизненном цикле приложения и динамической настройке приложений см. В модуле &amp;laquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="52856e4d7670b4aabed44c6b796ec0f3b6c2451e" translate="yes" xml:space="preserve">
          <source>If for some reason you cannot take the elements before hand, you can use &lt;code&gt;:max_concurrency&lt;/code&gt; to limit how many elements may be over processed at the cost of reducing concurrency.</source>
          <target state="translated">Если по какой-то причине вы не можете взять элементы &lt;code&gt;:max_concurrency&lt;/code&gt; , вы можете использовать : max_concurrency, чтобы ограничить количество элементов, которые могут быть обработаны чрезмерно за счет уменьшения параллелизма.</target>
        </trans-unit>
        <trans-unit id="8fe39f85acaae7d9c0b9ede161359eb45dcac7a2" translate="yes" xml:space="preserve">
          <source>If injection is suddenly interrupted, &lt;code&gt;:halt&lt;/code&gt; is passed and the function can return any value as it won't be used.</source>
          <target state="translated">Если инъекция внезапно прерывается, передается &lt;code&gt;:halt&lt;/code&gt; , и функция может вернуть любое значение, так как оно не будет использоваться.</target>
        </trans-unit>
        <trans-unit id="2208d456a668339c9192b6d6af5ff93f1cbc3d73" translate="yes" xml:space="preserve">
          <source>If installing a precompiled Hex does not work, you can compile and install Hex directly with this command:</source>
          <target state="translated">Если установка прекомпилированного Hex не работает,вы можете скомпилировать и установить Hex непосредственно с помощью этой команды:</target>
        </trans-unit>
        <trans-unit id="e605c80e2a0c34a8e797284924c7ad11db4e6147" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="translated">Если вместо этого вам нужен &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; для той же точки в другом часовом поясе, см. Функцию &lt;a href=&quot;#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; ,&lt;/a&gt; которая преобразует 2018-08-24 10:00:00 в Копенгагене в 2018-08-24 08:00:00 в UTC.</target>
        </trans-unit>
        <trans-unit id="6ef0c2aa8f05db2c984cf1df62ac6db58c68621a" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;datetime#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="translated">Если вместо этого вам нужен &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; для той же точки в другом часовом поясе, см. Функцию &lt;a href=&quot;datetime#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; ,&lt;/a&gt; которая преобразует 2018-08-24 10:00:00 в Копенгагене в 2018-08-24 08:00:00 в UTC.</target>
        </trans-unit>
        <trans-unit id="d54c8e6a4382ff70ea26a411e39ab67c3f015ec3" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="translated">Если указаны недопустимые аргументы, &lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; вызывает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; также ожидает строгого набора параметров и будет повышаться, если указаны неизвестные или недопустимые параметры.</target>
        </trans-unit>
        <trans-unit id="f63070ccfff8927ca91b04ed194217d21f1511af" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="translated">Если указаны недопустимые аргументы, &lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; также ожидает строгого набора параметров и будет повышаться, если указаны неизвестные или недопустимые параметры.</target>
        </trans-unit>
        <trans-unit id="d184a96a7452ebbaa15d901cdfcd5646962e673b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="translated">Если невозможно однозначное преобразование между календарями (см. &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; ), возвращается кортеж &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf2413d6f2f1077cec728a8783f14bba8e944a5b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="translated">Если невозможно однозначное преобразование между календарями (см. &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; ), возникает ошибка ArgumentError.</target>
        </trans-unit>
        <trans-unit id="ecfddb3c801b4fad8012305968cb8bcbecf6fa13" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="translated">Если невозможно однозначное преобразование между календарями (см. &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; ), возвращается кортеж &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87471401848a097556118fe83e0d5466a1656985" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="translated">Если невозможно однозначное преобразование между календарями (см. &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; ), возникает ошибка ArgumentError.</target>
        </trans-unit>
        <trans-unit id="1b73ba22cd3093f832e74a316d5262bd0f987e0a" translate="yes" xml:space="preserve">
          <source>If it succeeds in loading the module, it returns &lt;code&gt;{:module, module}&lt;/code&gt;. If not, returns &lt;code&gt;{:error, reason}&lt;/code&gt; with the error reason.</source>
          <target state="translated">Если ему удалось загрузить модуль, он вернет &lt;code&gt;{:module, module}&lt;/code&gt; . Если нет, возвращает &lt;code&gt;{:error, reason}&lt;/code&gt; с причиной ошибки.</target>
        </trans-unit>
        <trans-unit id="375e4e6baa78eec72e85f76cd1b054d6bf11d173" translate="yes" xml:space="preserve">
          <source>If it succeeds opening the file, it returns the &lt;code&gt;function&lt;/code&gt; result on the IO device.</source>
          <target state="translated">Если ему удается открыть файл, он возвращает результат &lt;code&gt;function&lt;/code&gt; на устройстве ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="f34822921b36640bca1582de43cfc049c94f2bdc" translate="yes" xml:space="preserve">
          <source>If last is larger than first, the range will be increasing from first to last. If first is larger than last, the range will be decreasing from first to last. If first is equal to last, the range will contain one element, which is the number itself.</source>
          <target state="translated">Если последний больше первого,то диапазон будет увеличиваться от первого к последнему.Если последний больше последнего,то диапазон будет уменьшаться от первого к последнему.Если первая равна последней,то диапазон будет содержать один элемент-само число.</target>
        </trans-unit>
        <trans-unit id="235b771916ee54b0bdf0b8ac1f7f9a8b762d39f4" translate="yes" xml:space="preserve">
          <source>If module has &lt;code&gt;@compile {:autoload, false}&lt;/code&gt;, &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; will not be used.</source>
          <target state="translated">Если модуль имеет &lt;code&gt;@compile {:autoload, false}&lt;/code&gt; , &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; не будет использоваться.</target>
        </trans-unit>
        <trans-unit id="73ef68acbf89df4484fb1238776c874300f89fd7" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal or minimal, the first one that was found is returned.</source>
          <target state="translated">Если несколько элементов считаются максимальными или минимальными,то возвращается первый найденный элемент.</target>
        </trans-unit>
        <trans-unit id="1368a6e71ce1bea12a85b30b7509f054b5bc170d" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal, the first one that was found is returned.</source>
          <target state="translated">Если несколько элементов считаются максимальными,то возвращается первый найденный элемент.</target>
        </trans-unit>
        <trans-unit id="c6a9685a98347f5efadc0b8611df565d7f389d71" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered minimal, the first one that was found is returned.</source>
          <target state="translated">Если несколько элементов считаются минимальными,то возвращается первый найденный элемент.</target>
        </trans-unit>
        <trans-unit id="24628e265ef0842d90b32f3fc25fbf2867904597" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;rebar&lt;/code&gt; or &lt;code&gt;rebar3&lt;/code&gt; are specified, both versions will be fetched.</source>
          <target state="translated">Если ни один из &lt;code&gt;rebar&lt;/code&gt; или &lt;code&gt;rebar3&lt;/code&gt; указаны обе версии будут извлечены.</target>
        </trans-unit>
        <trans-unit id="3bba7183a7cbe4b26185332d90ef3cedae8fff5f" translate="yes" xml:space="preserve">
          <source>If nil is returned, it means no lock information is available.</source>
          <target state="translated">Если возвращается ноль,это означает,что информация о замке недоступна.</target>
        </trans-unit>
        <trans-unit id="038bfba61cc7a83ddd7d63b5a01873632ce42b48" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; exists, returns the keyword list unchanged.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; со &lt;code&gt;value&lt;/code&gt; существует, возвращает список ключевых слов без изменений.</target>
        </trans-unit>
        <trans-unit id="f84d674ad0c66434da7d8901f73f91feb00f3a76" translate="yes" xml:space="preserve">
          <source>If no application is given, it uses the current application defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">Если приложение не указано, используется текущее приложение, определенное в файле &lt;code&gt;mix.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c893bf9fd681a7f7a6fb13527c0cc5dfde15e8a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the value of the previous expression is used.</source>
          <target state="translated">Если аргумент не указан,то используется значение предыдущего выражения.</target>
        </trans-unit>
        <trans-unit id="44e1f09935bd0cbe5978c5fb2f1f11d782328422" translate="yes" xml:space="preserve">
          <source>If no argument is supplied but there is an archive in the project's root directory (created with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt;&lt;code&gt;mix archive.build&lt;/code&gt;&lt;/a&gt;), then the archive will be installed locally. For example:</source>
          <target state="translated">Если аргумент не указан, но в корневом каталоге проекта есть архив (созданный с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt; &lt;code&gt;mix archive.build&lt;/code&gt; &lt;/a&gt; ), то архив будет установлен локально. Например:</target>
        </trans-unit>
        <trans-unit id="1e6b21b04e9206b421a7dd9fd273e8d10651e36e" translate="yes" xml:space="preserve">
          <source>If no argument is supplied but there is an escript in the project's root directory (created with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;), then the escript will be installed locally. For example:</source>
          <target state="translated">Если аргумент не указан, но в корневом каталоге проекта есть эскрипт (созданный с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt; ), то эскрипт будет установлен локально. Например:</target>
        </trans-unit>
        <trans-unit id="1b6cea41585ef2678e551c971ce31fe417d9dd88" translate="yes" xml:space="preserve">
          <source>If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like &lt;code&gt;_&lt;/code&gt;) which will always match.</source>
          <target state="translated">Если ни одно предложение не соответствует, возникает ошибка. По этой причине может потребоваться добавить последнее универсальное предложение (например, &lt;code&gt;_&lt;/code&gt; ), которое всегда будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="fc7cd6fb4c53519f3c55037a05bd9ecc868e4492" translate="yes" xml:space="preserve">
          <source>If no configuration file is given, it loads the project's configuration file, &quot;config/config.exs&quot;, if it exists. Keep in mind that the &quot;config/config.exs&quot; file is always loaded by the CLI and invoking it is only required in cases you are starting Mix manually.</source>
          <target state="translated">Если конфигурационный файл не указан,он загружает конфигурационный файл проекта &quot;config/config.exs&quot;,если он существует.Помните,что файл &quot;config/config.exs&quot; всегда загружается по CLI,и его обращение к нему требуется только в том случае,если вы запускаете Mix вручную.</target>
        </trans-unit>
        <trans-unit id="b7eed02542b79da944224ca91fcc920777715fa8" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project is used.</source>
          <target state="translated">Если конфигурация не задана,то используется конфигурация для текущего проекта.</target>
        </trans-unit>
        <trans-unit id="87546bcf9e4f94845bd9b4719319d8f898876f32" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project will be used.</source>
          <target state="translated">Если конфигурация не задана,то будет использоваться конфигурация для текущего проекта.</target>
        </trans-unit>
        <trans-unit id="7b738bcb5763933041a695931c6cb78b2d2ed70e" translate="yes" xml:space="preserve">
          <source>If no dependency is given, it uses the tree defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">Если зависимость не указана, используется дерево, определенное в файле &lt;code&gt;mix.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8420e9f0ced4b5e2305fa85af7c948aac181698b" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">Если функция не задана, истинность каждого элемента проверяется во время итерации. Когда элемент имеет ложное значение ( &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; ) итерация немедленно останавливается, и возвращается &lt;code&gt;false&lt;/code&gt; . Во всех остальных случаях возвращается &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af73d9c2f1028c805fc39df68dad67f7b564dd8d" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Если функция не задана, истинность каждого элемента проверяется во время итерации. Когда элемент имеет истинное значение (ни &lt;code&gt;false&lt;/code&gt; ни &lt;code&gt;nil&lt;/code&gt; ) итерация немедленно останавливается, и возвращается &lt;code&gt;true&lt;/code&gt; . Во всех остальных случаях возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99cc65b0a766a1d7c750735c04a6ce040c2ecd5f" translate="yes" xml:space="preserve">
          <source>If no matching tuple is found, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">Если соответствующий кортеж не найден, возвращается &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db86456e3e6a45125baab8b1b669e7d382cc2ad8" translate="yes" xml:space="preserve">
          <source>If none of the clauses match, an error is raised:</source>
          <target state="translated">Если ни один из пунктов не совпадает,возникает ошибка:</target>
        </trans-unit>
        <trans-unit id="e2a4d7b7ce6ed34ac382f69616d43a496e285e59" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если таковой не существует, он будет прерван, поскольку не были заданы входные данные процесса оболочки. &lt;code&gt;value&lt;/code&gt; должно быть &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b534d3078a1eaf21555f5ec72f4135c6d9a40dd" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be a string.</source>
          <target state="translated">Если таковой не существует, он будет прерван, поскольку не были заданы входные данные процесса оболочки. &lt;code&gt;value&lt;/code&gt; должно быть строкой.</target>
        </trans-unit>
        <trans-unit id="bccd76edbf5bdad5646dc98c00f42c25e3b6a1a0" translate="yes" xml:space="preserve">
          <source>If one is already registered, it is replaced.</source>
          <target state="translated">Если он уже зарегистрирован,он заменяется.</target>
        </trans-unit>
        <trans-unit id="6d6821d80cd7273e1c9f60ea9b9bf87af913648b" translate="yes" xml:space="preserve">
          <source>If one is not registered, returns the word appended with an &quot;s&quot;.</source>
          <target state="translated">Если он не зарегистрирован,возвращает слово,дополненное буквой &quot;s&quot;.</target>
        </trans-unit>
        <trans-unit id="2a2ad82fe5366a9ffae6d450da5ae29fe95a85f3" translate="yes" xml:space="preserve">
          <source>If options are provided, the result will be &lt;code&gt;{:ok, pid}&lt;/code&gt;, returning the IO device created. The option &lt;code&gt;:capture_prompt&lt;/code&gt;, when set to &lt;code&gt;true&lt;/code&gt;, causes prompts (which are specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) to be included in the device's output.</source>
          <target state="translated">Если указаны параметры, результатом будет &lt;code&gt;{:ok, pid}&lt;/code&gt; , возвращающее созданное устройство ввода-вывода. Параметр &lt;code&gt;:capture_prompt&lt;/code&gt; , если он установлен в значение &lt;code&gt;true&lt;/code&gt; , заставляет запросы (которые указываются как аргументы для функций &lt;code&gt;IO.get*&lt;/code&gt; ) включаться в вывод устройства.</target>
        </trans-unit>
        <trans-unit id="3b66a164bf9c0ed9cfb3107b0900a5b27ed87c86" translate="yes" xml:space="preserve">
          <source>If part of a supervision tree, a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; will receive an exit signal when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be:</source>
          <target state="translated">Если это часть дерева надзора, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; получит сигнал выхода при завершении работы дерева. Сигнал выхода основан на стратегии выключения в спецификации дочернего элемента, где это значение может быть:</target>
        </trans-unit>
        <trans-unit id="c9b86f1b45462784068301d1b6133eb9cbdf0f18" translate="yes" xml:space="preserve">
          <source>If partitioning is enabled and &lt;code&gt;--cover&lt;/code&gt; is used, no cover reports are generated, as they only contain a subset of the coverage data. Instead, the coverage data is exported to files such as &lt;code&gt;cover/MIX_TEST_PARTITION.coverdata&lt;/code&gt;. Once you have the results of all partitions inside &lt;code&gt;cover/&lt;/code&gt;, you can run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.Coverage.html&quot;&gt;&lt;code&gt;mix test.coverage&lt;/code&gt;&lt;/a&gt; to get the unified report.</source>
          <target state="translated">Если разделение включено и используется &lt;code&gt;--cover&lt;/code&gt; , отчеты о покрытии не создаются, поскольку они содержат только подмножество данных покрытия. Вместо этого данные покрытия экспортируются в такие файлы, как &lt;code&gt;cover/MIX_TEST_PARTITION.coverdata&lt;/code&gt; . Когда у вас есть результаты всех разделов внутри &lt;code&gt;cover/&lt;/code&gt; , вы можете запустить &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.Coverage.html&quot;&gt; &lt;code&gt;mix test.coverage&lt;/code&gt; ,&lt;/a&gt; чтобы получить единый отчет.</target>
        </trans-unit>
        <trans-unit id="ee772fad171fd1b86c1fbf91441e33291245e16b" translate="yes" xml:space="preserve">
          <source>If path/wildcard is a relative path/wildcard, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="translated">Если путь/wildcard является относительным путем/wildcard,то он будет расширен относительно директории,в которой находится текущий конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="2c9a282865b6fe4119e199b1b0847cbb6040e103" translate="yes" xml:space="preserve">
          <source>If present, invoke the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если присутствует, вызовите необязательный обратный вызов &lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f857961c6609ab2fd7dcb4f431f75616d71eb634" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt;; when the binary cannot be coerced into a valid float, the atom &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">В случае успеха возвращает кортеж в виде &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt; ; когда двоичный файл не может быть преобразован в допустимое число с плавающей запятой, возвращается атом &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b120927e219fe332092528639b692b8090eba7eb" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt;. Otherwise &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">В случае успеха возвращает кортеж в виде &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt; . В противном случае &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b18774208db640d57cda0a230752786cd8f12b4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no child specification for the given child ID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">В случае успеха эта функция возвращает &lt;code&gt;:ok&lt;/code&gt; . Если &lt;code&gt;{:error, :not_found}&lt;/code&gt; спецификация для данного дочернего идентификатора отсутствует, эта функция возвращает {: error,: not_found} .</target>
        </trans-unit>
        <trans-unit id="b3f06ad98d27407a8302c766c4bf1a51ac8c90c4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no process with the given PID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">В случае успеха эта функция возвращает &lt;code&gt;:ok&lt;/code&gt; . Если нет процесса с данным PID, эта функция возвращает &lt;code&gt;{:error, :not_found}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b49684fdd544a95c54cc6ece8ce5787754e9bca3" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="translated">В случае успеха эта функция возвращает &lt;code&gt;:ok&lt;/code&gt; . Эта функция может вернуть ошибку с соответствующим кортежем ошибок, если &lt;code&gt;child_id&lt;/code&gt; не найден, или если текущий процесс запущен или перезапускается.</target>
        </trans-unit>
        <trans-unit id="94de3ea42072866e8652cd6fca38378bad81898f" translate="yes" xml:space="preserve">
          <source>If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen.</source>
          <target state="translated">Если такая связь уже существует,то эта функция ничего не делает,так как между двумя заданными процессами может быть только одна связь.Если процесс попытается создать связь с собой,ничего не произойдет.</target>
        </trans-unit>
        <trans-unit id="82ad4a438a65f14d6cc2e31d27dc219d76d8743c" translate="yes" xml:space="preserve">
          <source>If such a tuple is not found, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">Если такой кортеж не найден, будет возвращено &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="481e39df28a67eb2b33dd5d88bf3b6bd30ab02a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback fails with &lt;code&gt;reason&lt;/code&gt;, this function returns &lt;code&gt;{:error, reason}&lt;/code&gt;. Otherwise, if it returns &lt;code&gt;{:stop, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;{:error, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">Если обратный вызов &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; завершается неудачно по &lt;code&gt;reason&lt;/code&gt; , эта функция возвращает &lt;code&gt;{:error, reason}&lt;/code&gt; . В противном случае, если она возвращает &lt;code&gt;{:stop, reason}&lt;/code&gt; или &lt;code&gt;:ignore&lt;/code&gt; , процесс завершается, и эта функция возвращает &lt;code&gt;{:error, reason}&lt;/code&gt; или &lt;code&gt;:ignore&lt;/code&gt; , соответственно.</target>
        </trans-unit>
        <trans-unit id="dbcf489afc8a98baffdf14a35b5948b139352b97" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback returns &lt;code&gt;:ignore&lt;/code&gt;, this function returns &lt;code&gt;:ignore&lt;/code&gt; as well and the supervisor terminates with reason &lt;code&gt;:normal&lt;/code&gt;. If it fails or returns an incorrect value, this function returns &lt;code&gt;{:error, term}&lt;/code&gt; where &lt;code&gt;term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">Если обратный вызов &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; возвращает &lt;code&gt;:ignore&lt;/code&gt; , эта функция также возвращает &lt;code&gt;:ignore&lt;/code&gt; , и супервизор завершает работу с причиной &lt;code&gt;:normal&lt;/code&gt; . Если это не удается или возвращает неправильное значение, эта функция возвращает &lt;code&gt;{:error, term}&lt;/code&gt; , где &lt;code&gt;term&lt;/code&gt; является терм с информацией об ошибке и супервизор завершается причина &lt;code&gt;term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71d6d6b5b64b37312988e1b6e5df55a665e7fb1a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; receives an exit signal (that is not &lt;code&gt;:normal&lt;/code&gt;) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. Note that a process does &lt;em&gt;NOT&lt;/em&gt; trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected.</source>
          <target state="translated">Если &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; получает сигнал выхода (который не является &lt;code&gt;:normal&lt;/code&gt; ) от любого процесса, когда он не перехватывает выходы, он внезапно завершает работу по той же причине и поэтому не &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; вызов / 2 . Обратите внимание, что процесс &lt;em&gt;НЕ&lt;/em&gt; перехватывает выходы по умолчанию, и сигнал выхода отправляется, когда связанный процесс завершается или его узел отключен.</target>
        </trans-unit>
        <trans-unit id="6f9052b50ac29d05b6aa3acc2ac9400b5beedce0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--label compile&lt;/code&gt; flag is given with &lt;code&gt;--sink&lt;/code&gt;, then &lt;code&gt;lib/c.ex&lt;/code&gt; won't be shown, because no module has a compile time dependency on &lt;code&gt;lib/c.ex&lt;/code&gt; but &lt;code&gt;lib/a.ex&lt;/code&gt; still has an indirect compile time dependency on &lt;code&gt;lib/c.ex&lt;/code&gt; via &lt;code&gt;lib/b.ex&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;--label compile&lt;/code&gt; задан с помощью &lt;code&gt;--sink&lt;/code&gt; , то &lt;code&gt;lib/c.ex&lt;/code&gt; не будет отображаться, потому что ни один модуль не имеет зависимости времени компиляции от &lt;code&gt;lib/c.ex&lt;/code&gt; , но &lt;code&gt;lib/a.ex&lt;/code&gt; все еще имеет косвенное зависимость времени компиляции от &lt;code&gt;lib/c.ex&lt;/code&gt; через &lt;code&gt;lib/b.ex&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f3eabf6d5616bb794992bd7e46ea46c1c3f02463" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:capture_prompt&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;, prompts (specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) are captured in the output.</source>
          <target state="translated">Если для параметра &lt;code&gt;:capture_prompt&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , запросы (указанные в качестве аргументов для функций &lt;code&gt;IO.get*&lt;/code&gt; ) фиксируются в выходных данных.</target>
        </trans-unit>
        <trans-unit id="e863cbc73eabe13e90d2206b9738ad4d5bc8e2e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:debug&lt;/code&gt; option is present, the corresponding function in the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; will be invoked.</source>
          <target state="translated">Если присутствует параметр &lt;code&gt;:debug&lt;/code&gt; , будет вызвана соответствующая функция в &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;модуле &lt;/a&gt; &lt;code&gt;:sys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20dea358c75a21f536924752c1d8661c6611e5a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;:spawn_opt&lt;/code&gt; параметр : spawn_opt , его значение будет передано в качестве параметров базовому процессу, как в &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc9742b5fac276e3c5db68eba998892b5d16666" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;process#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;:spawn_opt&lt;/code&gt; параметр : spawn_opt , его значение будет передано в качестве параметров базовому процессу, как в &lt;a href=&quot;process#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a17a9b3957177b112bf526bb40068d405551156b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:timeout&lt;/code&gt; option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return &lt;code&gt;{:error, :timeout}&lt;/code&gt;.</source>
          <target state="translated">Если присутствует параметр &lt;code&gt;:timeout&lt;/code&gt; , агенту разрешено потратить не более заданного количества миллисекунд на инициализацию, в противном случае она будет завершена, а функция запуска вернет &lt;code&gt;{:error, :timeout}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb098adf69499ff7a9f9cec625ec93553830b541" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если модуль &lt;code&gt;Foo.Bar&lt;/code&gt; перемещен в другое место, ссылки на &lt;code&gt;Bar&lt;/code&gt; в модуле &lt;code&gt;Foo&lt;/code&gt; необходимо обновить до полного имени ( &lt;code&gt;Foo.Bar&lt;/code&gt; ) или псевдоним должен быть явно установлен в модуле &lt;code&gt;Foo&lt;/code&gt; с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14ac11fca560d2d149b007098ce38791dba90a1b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если модуль &lt;code&gt;Foo.Bar&lt;/code&gt; перемещен в другое место, ссылки на &lt;code&gt;Bar&lt;/code&gt; в модуле &lt;code&gt;Foo&lt;/code&gt; необходимо обновить до полного имени ( &lt;code&gt;Foo.Bar&lt;/code&gt; ) или псевдоним должен быть явно установлен в модуле &lt;code&gt;Foo&lt;/code&gt; с помощью &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a6368961da467df03a853267f8beaa74f1276b2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;app&lt;/code&gt; is not loaded, the application will first be loaded using &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt;. Any included application, defined in the &lt;code&gt;:included_applications&lt;/code&gt; key of the &lt;code&gt;.app&lt;/code&gt; file will also be loaded, but they won't be started.</source>
          <target state="translated">Если &lt;code&gt;app&lt;/code&gt; не загружено, оно сначала будет загружено с использованием &lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;load/1&lt;/code&gt; &lt;/a&gt; . Любые включены приложения, определенные в &lt;code&gt;:included_applications&lt;/code&gt; ключе &lt;code&gt;.app&lt;/code&gt; файл также будут загружены, но они не будут запущены.</target>
        </trans-unit>
        <trans-unit id="0c322faf190500e641ef7c48d9a94611219b9f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;debugger&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package.</source>
          <target state="translated">Если &lt;code&gt;debugger&lt;/code&gt; не запускается, то могло произойти вот что: некоторые менеджеры пакетов по умолчанию устанавливают свернутый Erlang без привязок WX для поддержки графического интерфейса. В некоторых менеджерах пакетов вы можете заменить безголовый Erlang более полным пакетом (ищите пакеты с именем &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; в Debian / Ubuntu / Arch). В других менеджерах вам может потребоваться установить отдельный пакет &lt;code&gt;erlang-wx&lt;/code&gt; (или пакет с аналогичным названием).</target>
        </trans-unit>
        <trans-unit id="cbb1dfcd54340620db2a4b1be8a4677dcef95965" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;element&lt;/code&gt; occurs more than once in the &lt;code&gt;list&lt;/code&gt;, just the first occurrence is removed.</source>
          <target state="translated">Если &lt;code&gt;element&lt;/code&gt; встречается в &lt;code&gt;list&lt;/code&gt; более одного раза , удаляется только первое вхождение.</target>
        </trans-unit>
        <trans-unit id="c08aca5a16d9dc35535dd8000df0a013cccceba1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, inserts the given &lt;code&gt;initial&lt;/code&gt; value.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, вставляет заданное &lt;code&gt;initial&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="51a63ed6ff743b76fcc933f16622e3ae8d826e4a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, it inserts the given &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, он вставляет заданное значение по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ce0dac723ef05f760f8c9731a754923353ba4a5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b90b4077be865683040b57e9dd5a794351c1f57" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, вызывает &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bce3fad01881435afa04eb9438e26f3f17ad50a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возвращается &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dbc4c11a6c23bf2afb4e21b6579dc04b19c27e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;map&lt;/code&gt; unchanged.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возвращает &lt;code&gt;map&lt;/code&gt; без изменений.</target>
        </trans-unit>
        <trans-unit id="f3debd0c004b80e32f0db2e8ec25052d54f08cfa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возвращает список ключевых слов без изменений.</target>
        </trans-unit>
        <trans-unit id="62f2f316a709eec98605c56cf7264dcfb2bde687" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged. Use &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; to delete just the first entry in case of duplicated keys.</source>
          <target state="translated">Если &lt;code&gt;key&lt;/code&gt; не существует, возвращает список ключевых слов без изменений. Используйте &lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; ,&lt;/a&gt; чтобы удалить только первую запись в случае дублирования ключей.</target>
        </trans-unit>
        <trans-unit id="d0667a096bf26c8f0e621f049599d4e22e6ac8ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;module&lt;/code&gt; is not instrumented or if the given &lt;code&gt;function&lt;/code&gt; does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;module&lt;/code&gt; не инструментирован или если данная &lt;code&gt;function&lt;/code&gt; не имеет точки останова, это не &lt;code&gt;:not_found&lt;/code&gt; и она возвращает : not_found . В противном случае возвращается &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03691d0408ebea241da0941314a2772b60f2370b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;right&lt;/code&gt; операнд не является правильным списком, он возвращает неправильный список. Если &lt;code&gt;left&lt;/code&gt; операнд не является правильным списком, он вызывает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6016e2f55c427f96fc5e301fda4f933dcb7f84cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;right&lt;/code&gt; операнд не является правильным списком, он возвращает неправильный список. Если &lt;code&gt;left&lt;/code&gt; операнд не является правильным списком, он вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37bfbc1115f3a777b2fb554294a534e238eccc25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unescape_map/1&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt;, the char is not escaped and the backslash is kept in the string.</source>
          <target state="translated">Если функция &lt;code&gt;unescape_map/1&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; , символ не экранируется, а обратная косая черта сохраняется в строке.</target>
        </trans-unit>
        <trans-unit id="001e53accbd81c0682a50b72be746960fd2af2c9" translate="yes" xml:space="preserve">
          <source>If the IO &lt;code&gt;device&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">Если &lt;code&gt;device&lt;/code&gt; ввода-вывода является устройством Unicode, &lt;code&gt;count&lt;/code&gt; подразумевает количество кодовых точек Unicode, которые необходимо получить. В противном случае &lt;code&gt;count&lt;/code&gt; - это количество необработанных байтов, которые нужно получить.</target>
        </trans-unit>
        <trans-unit id="8bc76fe61e905f5e8cd97c93427f5f8a0776bded" translate="yes" xml:space="preserve">
          <source>If the VM terminates programmatically, via &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;System.stop/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;System.halt/1&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#at_exit/1&quot;&gt;&lt;code&gt;at_exit/1&lt;/code&gt;&lt;/a&gt; callbacks are not executed.</source>
          <target state="translated">Если виртуальная машина завершается программно, через &lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;System.stop/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;System.halt/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#at_exit/1&quot;&gt; &lt;code&gt;at_exit/1&lt;/code&gt; &lt;/a&gt; вызовы at_exit / 1 не выполняются.</target>
        </trans-unit>
        <trans-unit id="00f4455df1d117303f7b4dec1a8e7c59907ae6e0" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="translated">Если на псевдоним еще не было ссылки, возникает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; . Он обрабатывает чарлисты, двоичные файлы и атомы.</target>
        </trans-unit>
        <trans-unit id="75f023f5a8fb5579a176722fb1ddcce792e96e4e" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="translated">Если псевдоним еще не упоминался, ошибка &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; . Он обрабатывает чарлисты, двоичные файлы и атомы.</target>
        </trans-unit>
        <trans-unit id="066a1698eac217d09441d2b5fb8b66f936f99de7" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback if invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="translated">Если в приложении не настроен модуль обратного вызова, на этом этапе выполняется запуск. В противном случае его обратный вызов &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; ,&lt;/a&gt; если он вызван. PID супервизора верхнего уровня, возвращаемый этой функцией, сохраняется средой выполнения для последующего использования, а также сохраняется возвращенное состояние приложения, если оно есть.</target>
        </trans-unit>
        <trans-unit id="e0a3a0af1299b136f054ee1bd9b8c1968e181e7d" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback is invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="translated">Если в приложении не настроен модуль обратного вызова, на этом этапе выполняется запуск. В противном случае вызывается его обратный вызов &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; . PID супервизора верхнего уровня, возвращаемый этой функцией, сохраняется средой выполнения для последующего использования, а также сохраняется возвращаемое состояние приложения, если оно есть.</target>
        </trans-unit>
        <trans-unit id="562962b2b4cc24713b05513158139365a944c86f" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;https://hexdocs.pm/elixir/RuntimeError.html&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="translated">Если аргумент &lt;code&gt;msg&lt;/code&gt; является двоичным, он вызывает исключение &lt;a href=&quot;https://hexdocs.pm/elixir/RuntimeError.html&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; ,&lt;/a&gt; используя данный аргумент как сообщение.</target>
        </trans-unit>
        <trans-unit id="df94a702176ed26ed614862093d3a9baa0557531" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;runtimeerror&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="translated">Если аргумент &lt;code&gt;msg&lt;/code&gt; является двоичным, он вызывает исключение &lt;a href=&quot;runtimeerror&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; ,&lt;/a&gt; используя данный аргумент как сообщение.</target>
        </trans-unit>
        <trans-unit id="7fd89e207521cfe8f1ffff76704430fa5d151c3b" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="translated">Если атрибут был помечен как &lt;code&gt;accumulate&lt;/code&gt; с &lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; , список всегда возвращается. &lt;code&gt;nil&lt;/code&gt; возвращается, если атрибут не был отмечен с помощью &lt;code&gt;accumulate&lt;/code&gt; и не был установлен на какое-либо значение.</target>
        </trans-unit>
        <trans-unit id="71a4ad2c3571e6dc0648a7ce18db0a118f1fca6f" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="translated">Если атрибут был помечен как &lt;code&gt;accumulate&lt;/code&gt; с &lt;a href=&quot;module#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; , список всегда возвращается. &lt;code&gt;nil&lt;/code&gt; возвращается, если атрибут не был отмечен с помощью &lt;code&gt;accumulate&lt;/code&gt; и не был установлен на какое-либо значение.</target>
        </trans-unit>
        <trans-unit id="adaf0c8947d55853c9d373e226af8475042db2c9" translate="yes" xml:space="preserve">
          <source>If the behaviour changes or &lt;code&gt;URI.HTTP&lt;/code&gt; does not implement one of the callbacks, a warning will be raised.</source>
          <target state="translated">Если поведение изменится или &lt;code&gt;URI.HTTP&lt;/code&gt; не реализует один из обратных вызовов, появится предупреждение.</target>
        </trans-unit>
        <trans-unit id="99a1391ef43bb72cc7d48f8ee9698b12d1d27ff4" translate="yes" xml:space="preserve">
          <source>If the child process is not trapping exits, it will shutdown immediately when it receives the first exit signal. If the child process is trapping exits, then the &lt;code&gt;terminate&lt;/code&gt; callback is invoked, and the child process must terminate in a reasonable time interval before being abruptly terminated by the supervisor.</source>
          <target state="translated">Если дочерний процесс не перехватывает выходы, он немедленно завершится, когда получит первый сигнал выхода. Если дочерний процесс перехватывает выходы, то вызывается обратный вызов &lt;code&gt;terminate&lt;/code&gt; , и дочерний процесс должен завершиться в разумный интервал времени, прежде чем он будет внезапно завершен супервизором.</target>
        </trans-unit>
        <trans-unit id="05268b70bba2052aa1ccd1488036cae6ea1aa300" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the PID remains set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;:ignore&lt;/code&gt; , PID остается установленным на &lt;code&gt;:undefined&lt;/code&gt; , и эта функция возвращает &lt;code&gt;{:ok, :undefined}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5c9cb2d2a33379f64c647839b2a1ab4dbc13e8f" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the child specification is added to the supervisor, the PID is set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;:ignore&lt;/code&gt; , дочерняя спецификация добавляется к супервизору, PID устанавливается на &lt;code&gt;:undefined&lt;/code&gt; , и эта функция возвращает &lt;code&gt;{:ok, :undefined}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef45b4e1f4c05bc44ee03bd5bad1f5e5a9ba93ef" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, then no child is added to the supervision tree and this function returns &lt;code&gt;:ignore&lt;/code&gt; too.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;:ignore&lt;/code&gt; , тогда в дерево надзора не добавляется дочерний процесс, и эта функция также возвращает &lt;code&gt;:ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93487fcca765523c971b5da517cfe6d46d7ca27a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, the PID is added to the supervisor and this function returns the same value.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;{:ok, child}&lt;/code&gt; или &lt;code&gt;{:ok, child, info}&lt;/code&gt; , PID добавляется к супервизору, и эта функция возвращает то же значение.</target>
        </trans-unit>
        <trans-unit id="92f41de707f645e7e03c7c77ffbddced905df221" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, then child specification and PID are added to the supervisor and this function returns the same value.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;{:ok, child}&lt;/code&gt; или &lt;code&gt;{:ok, child, info}&lt;/code&gt; , тогда к супервизору добавляются дочерняя спецификация и PID, и эта функция возвращает то же значение.</target>
        </trans-unit>
        <trans-unit id="8a7852d163c87ef12689fc28578feaecfcacfb9c" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает кортеж с ошибкой или ошибочное значение, или в случае сбоя, дочерняя спецификация отбрасывается, и эта функция возвращает &lt;code&gt;{:error, error}&lt;/code&gt; где &lt;code&gt;error&lt;/code&gt; - термин, содержащий информацию об ошибке и дочерней спецификации.</target>
        </trans-unit>
        <trans-unit id="971c2677787cebeaf5076ea02ea7abe46523d9e1" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is the error or erroneous value returned from child process start function, or failure reason if it fails.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает кортеж с ошибкой или ошибочное значение, или в случае сбоя, дочерняя спецификация отбрасывается, и эта функция возвращает &lt;code&gt;{:error, error}&lt;/code&gt; где &lt;code&gt;error&lt;/code&gt; - это ошибка или ошибочное значение, возвращаемое функцией запуска дочернего процесса, или причина отказа в случае отказа.</target>
        </trans-unit>
        <trans-unit id="4ed3068726af85a0584fbeb7b657ccca120db122" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns &lt;code&gt;{:error, error}&lt;/code&gt;.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает кортеж с ошибкой или ошибочное значение, или в случае сбоя, эта функция возвращает &lt;code&gt;{:error, error}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e556a251ad20ce02002d9e36048516e94aeb978" translate="yes" xml:space="preserve">
          <source>If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as &lt;code&gt;:'🌢 Elixir'&lt;/code&gt;, &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt;, and &lt;code&gt;:&quot;123&quot;&lt;/code&gt;.</source>
          <target state="translated">Если сразу после двоеточия следует пара двойных или одинарных кавычек, окружающих имя атома, атом считается заключенным в кавычки. В отличии с некотируемым атомом, это один может быть выполнено из любого символа Unicode (не только буква), такие как &lt;code&gt;:'🌢 Elixir'&lt;/code&gt; , &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt; , и &lt;code&gt;:&quot;123&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8941e9716f24149ae17a893ee971b4de7ba5c0c1" translate="yes" xml:space="preserve">
          <source>If the compiler uses manifest files to track stale sources, it should define &lt;code&gt;manifests/0&lt;/code&gt;, and if it writes any output to disk it should also define &lt;code&gt;clean/0&lt;/code&gt;.</source>
          <target state="translated">Если компилятор использует файлы манифеста для отслеживания устаревших источников, он должен определять &lt;code&gt;manifests/0&lt;/code&gt; , а если он записывает какие-либо выходные данные на диск, он также должен определять &lt;code&gt;clean/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56beff3afd9994ddacaef88c1f904aa35af05474" translate="yes" xml:space="preserve">
          <source>If the condition given to &lt;code&gt;if/2&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;, the body given between &lt;code&gt;do/end&lt;/code&gt; is not executed and instead it returns &lt;code&gt;nil&lt;/code&gt;. The opposite happens with &lt;code&gt;unless/2&lt;/code&gt;.</source>
          <target state="translated">Если условие, данное &lt;code&gt;if/2&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; , тело, указанное между &lt;code&gt;do/end&lt;/code&gt; , не выполняется, а вместо этого возвращает &lt;code&gt;nil&lt;/code&gt; . Противоположное происходит с &lt;code&gt;unless/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99b59e29ecc1dff1755220f8555df92bd2b4fe3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если параметр конфигурации не существует, вызывает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90ee89304a582019b79109925a1ae106da1b349f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если параметр конфигурации не существует, вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b800c2816d5b5f752096a4e8e30fb37f2f59391" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">Если параметр конфигурации не существует, функция возвращает &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a592ffaee07d8c5f17b9ba6b9f33ed8e98c54d6f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns the &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="translated">Если параметр конфигурации не существует, функция возвращает значение по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6759e47fd880f62f176d9957b609a75b5cf78194" translate="yes" xml:space="preserve">
          <source>If the day is already the first day of the week, it returns the day itself. For the built-in ISO calendar, the week starts on Monday. A weekday rather than &lt;code&gt;:default&lt;/code&gt; can be given as &lt;code&gt;starting_on&lt;/code&gt;.</source>
          <target state="translated">Если этот день уже является первым днем ​​недели, возвращается сам день. Для встроенного календаря ISO неделя начинается в понедельник. День недели , а не &lt;code&gt;:default&lt;/code&gt; может быть задана как &lt;code&gt;starting_on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7fc25fab05e3574194267d1e7b17bc5554868b2" translate="yes" xml:space="preserve">
          <source>If the day is already the last day of the week, it returns the day itself. For the built-in ISO calendar, the week ends on Sunday. A weekday rather than &lt;code&gt;:default&lt;/code&gt; can be given as &lt;code&gt;starting_on&lt;/code&gt;.</source>
          <target state="translated">Если этот день уже является последним днем ​​недели, он возвращает сам день. Для встроенного календаря ISO выходные дни заканчиваются в воскресенье. День недели , а не &lt;code&gt;:default&lt;/code&gt; может быть задана как &lt;code&gt;starting_on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3cb9f3017a3cd59ff39001a965e946f4fe46ba2" translate="yes" xml:space="preserve">
          <source>If the dependency is locked, a lock is received in &lt;code&gt;opts&lt;/code&gt; and the repository must be check out at the lock. Otherwise, no lock is given and the repository can be checked out to the latest version.</source>
          <target state="translated">Если зависимость заблокирована, блокировка получена в &lt;code&gt;opts&lt;/code&gt; , и репозиторий должен быть извлечен при блокировке. В противном случае блокировка не выполняется, и репозиторий можно проверить до последней версии.</target>
        </trans-unit>
        <trans-unit id="8f7a6151093f7c2a971f2852905fc785857fff18" translate="yes" xml:space="preserve">
          <source>If the element does not exist, it is added to the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">Если элемент не существует, он добавляется в конец &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3834eb098b76c8c7be976a57156c5a8c5b9abc11" translate="yes" xml:space="preserve">
          <source>If the enumerable is empty, the provided &lt;code&gt;empty_fallback&lt;/code&gt; is called. The default &lt;code&gt;empty_fallback&lt;/code&gt; raises &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если перечисляемое пусто, &lt;code&gt;empty_fallback&lt;/code&gt; предоставленный empty_fallback . По умолчанию &lt;code&gt;empty_fallback&lt;/code&gt; вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1b44730d66c61b1f7aa74b49b7cfff54912615" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;varname&lt;/code&gt; is set, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned where &lt;code&gt;value&lt;/code&gt; is a string. If &lt;code&gt;varname&lt;/code&gt; is not set, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">Если установлена ​​переменная окружения &lt;code&gt;varname&lt;/code&gt; , то возвращается &lt;code&gt;{:ok, value}&lt;/code&gt; где &lt;code&gt;value&lt;/code&gt; является строкой. Если имя &lt;code&gt;varname&lt;/code&gt; не задано, возвращается &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea743105c28535da020399869c10ba09ded50b63" translate="yes" xml:space="preserve">
          <source>If the exception module implements the optional &lt;a href=&quot;#c:blame/2&quot;&gt;&lt;code&gt;blame/2&lt;/code&gt;&lt;/a&gt; callback, it will be invoked to perform the computation.</source>
          <target state="translated">Если модуль исключения реализует необязательный обратный вызов &lt;a href=&quot;#c:blame/2&quot;&gt; &lt;code&gt;blame/2&lt;/code&gt; &lt;/a&gt; , он будет вызван для выполнения вычисления.</target>
        </trans-unit>
        <trans-unit id="6ba3395fcc44d77deb4fad259828439fe83f301c" translate="yes" xml:space="preserve">
          <source>If the exit reason is not &lt;code&gt;:normal&lt;/code&gt;, all the processes linked to the process that exited will crash (unless they are trapping exits).</source>
          <target state="translated">Если причина выхода не &lt;code&gt;:normal&lt;/code&gt; , все процессы, связанные с завершившимся процессом, выйдут из строя (если только они не перехватывают выходы).</target>
        </trans-unit>
        <trans-unit id="69bc5d1890437acbe1c535fa849ec2779651267d" translate="yes" xml:space="preserve">
          <source>If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">Если выражение не может быть расширено,оно возвращает само выражение.Эта функция не пересекает AST,расширяется только корневой узел.</target>
        </trans-unit>
        <trans-unit id="1d5138f099eddbd71facd7cd878f3e30168acb4c" translate="yes" xml:space="preserve">
          <source>If the external resource does not exist, the module still has a dependency on it, causing the module be recompiled as soon as the file is added.</source>
          <target state="translated">Если внешнего ресурса нет,то модуль все равно имеет зависимость от него,что приводит к перекомпиляции модуля при добавлении файла.</target>
        </trans-unit>
        <trans-unit id="9daaa1fc9c23e088e0d8755d3c8c12ee8baa78ff" translate="yes" xml:space="preserve">
          <source>If the file already exists and the contents are not the same, it asks for user confirmation.</source>
          <target state="translated">Если файл уже существует и его содержимое не совпадает,требуется подтверждение пользователя.</target>
        </trans-unit>
        <trans-unit id="dd469ee5a62e6b5a80b7c5e501b5ee43bbcd856c" translate="yes" xml:space="preserve">
          <source>If the file does exists, and if write is not combined with read, the file will be truncated.</source>
          <target state="translated">Если файл существует,а запись не совмещена с чтением,то файл будет усечен.</target>
        </trans-unit>
        <trans-unit id="4a926f33aaf552a1fcd49d45cc93ae59488a7d3e" translate="yes" xml:space="preserve">
          <source>If the file has been required, it returns &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">Если файл был необходим, он возвращает &lt;code&gt;nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5c19fb123316598a0d9b3638a762db6e8c9b35b" translate="yes" xml:space="preserve">
          <source>If the file has not been required, it returns the list of modules:</source>
          <target state="translated">Если файл не требуется,он возвращает список модулей:</target>
        </trans-unit>
        <trans-unit id="f8fd33f5966315da13c7c5967bb4b7033821bc3d" translate="yes" xml:space="preserve">
          <source>If the function does not return &lt;code&gt;true&lt;/code&gt; for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</source>
          <target state="translated">Если функция не возвращает &lt;code&gt;true&lt;/code&gt; для равных значений, сортировка нестабильна и порядок равных членов может быть перемешан. Например:</target>
        </trans-unit>
        <trans-unit id="46872c4f6b3b3d53e570bd775f9872272859aad0" translate="yes" xml:space="preserve">
          <source>If the function/macro being defined has multiple clauses, the hook will be called for each clause.</source>
          <target state="translated">Если определяемая функция/макро имеет несколько пунктов,то для каждого пункта будет вызываться крючок.</target>
        </trans-unit>
        <trans-unit id="49c229dbf0034a08eae6f9a0c1010fd39f336907" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;context&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; (by default it is), the binding for the current context is returned.</source>
          <target state="translated">Если данный &lt;code&gt;context&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; (по умолчанию это так), возвращается привязка для текущего контекста.</target>
        </trans-unit>
        <trans-unit id="6978259d37eaf03d5b3cc55b25024a1b3148e5a5" translate="yes" xml:space="preserve">
          <source>If the given function callback fails, the function returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">Если обратный вызов данной функции завершается неудачно, функция возвращает &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6ebfab2382584c9b3958f6f2fa9de700377fed5" translate="yes" xml:space="preserve">
          <source>If the given name does not exist, an error is raised.</source>
          <target state="translated">Если данное имя не существует,то возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="3af8970b7302792aa5fbcf15bf7d3816a9358c60" translate="yes" xml:space="preserve">
          <source>If the given project configuration does not identify an umbrella project, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Если данная конфигурация проекта не идентифицирует зонтичный проект, возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46533ec867c9435d899cb6828abb727c8f1630e2" translate="yes" xml:space="preserve">
          <source>If the given project configuration identifies an umbrella project, the return value is a map of &lt;code&gt;app =&amp;gt; path&lt;/code&gt; where &lt;code&gt;app&lt;/code&gt; is a child app of the umbrella and &lt;code&gt;path&lt;/code&gt; is its path relative to the root of the umbrella project.</source>
          <target state="translated">Если данная конфигурация проекта идентифицирует зонтичный проект, возвращаемое значение - это карта &lt;code&gt;app =&amp;gt; path&lt;/code&gt; где &lt;code&gt;app&lt;/code&gt; - дочернее приложение зонтика, а &lt;code&gt;path&lt;/code&gt; - его путь относительно корня зонтичного проекта.</target>
        </trans-unit>
        <trans-unit id="1a1e4f0e379f9bd60165b52c832ccce09165194e" translate="yes" xml:space="preserve">
          <source>If the given string is empty, an empty list is returned.</source>
          <target state="translated">Если заданная строка пуста,возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="b5fa7671aa9ac1c4f631b6b91cdd66f8be6d72c5" translate="yes" xml:space="preserve">
          <source>If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this:</source>
          <target state="translated">Если последним аргументом является структура данных,такая как карты и списки,а начало структуры данных помещается на той же строке,что и вызов функции,то отступов не происходит,это позволяет выполнить такой код:</target>
        </trans-unit>
        <trans-unit id="78f6031137384aa25684e5873b8f78717fddd500" translate="yes" xml:space="preserve">
          <source>If the last chunk does not have &lt;code&gt;count&lt;/code&gt; elements to fill the chunk, elements are taken from &lt;code&gt;leftover&lt;/code&gt; to fill in the chunk. If &lt;code&gt;leftover&lt;/code&gt; does not have enough elements to fill the chunk, then a partial chunk is returned with less than &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">Если в последнем фрагменте нет &lt;code&gt;count&lt;/code&gt; элементов для заполнения фрагмента, элементы берутся из &lt;code&gt;leftover&lt;/code&gt; для заполнения фрагмента. Если в &lt;code&gt;leftover&lt;/code&gt; недостаточно элементов для заполнения фрагмента, возвращается частичный фрагмент с меньшим &lt;code&gt;count&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="6d2f647fee30ac3b21a14f06f704594c6fc607f3" translate="yes" xml:space="preserve">
          <source>If the matching entry points to the node evaluating the request, then we&amp;rsquo;ve finished routing, and this node will perform the requested operation. If the matching entry points to a different node, we&amp;rsquo;ll pass the request to this node, which will look at its own routing table (which may be different from the one in the first node) and act accordingly. If no entry matches, an error will be raised.</source>
          <target state="translated">Если совпадающая точка входа указывает на узел, оценивающий запрос, значит, мы завершили маршрутизацию, и этот узел выполнит запрошенную операцию. Если соответствующая запись указывает на другой узел, мы передадим запрос этому узлу, который посмотрит на свою собственную таблицу маршрутизации (которая может отличаться от таблицы в первом узле) и будет действовать соответствующим образом. Если ни одна запись не совпадает, будет выдана ошибка.</target>
        </trans-unit>
        <trans-unit id="0e8da94808be345264b3caf7126393ed8c8b9f07" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this function returns &lt;code&gt;{:error, :unavailable}&lt;/code&gt;. Unavailable doesn't necessarily mean the module doesn't exist, just that it is not currently available, but it (or may not) become available in the future.</source>
          <target state="translated">Если проверяемый модуль в настоящее время находится в тупике компилятора, эта функция возвращает &lt;code&gt;{:error, :unavailable}&lt;/code&gt; . Недоступность не обязательно означает, что модуль не существует, просто он недоступен в настоящее время, но он (или может не стать) стать доступным в будущем.</target>
        </trans-unit>
        <trans-unit id="52158ebe3b1b3c65fb9901ffb1a952d081b6bc67" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this functions returns &lt;code&gt;{:error, :nofile}&lt;/code&gt;.</source>
          <target state="translated">Если проверяемый модуль в настоящее время находится в тупике компилятора, эта функция возвращает &lt;code&gt;{:error, :nofile}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2912dbde0fc1cf3c15e41a6a7b770a6ace8e7a" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not compiled yet, &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; halts the compilation of the caller until the module given to &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available, an error tuple is returned.</source>
          <target state="translated">Если модуль уже загружен, он не работает. Если модуль еще не был скомпилирован, &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; останавливает компиляцию вызывающей стороны до тех пор, пока не станет доступен модуль, заданный для &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; или не будут скомпилированы все файлы для текущего проекта. Если компиляция завершается и модуль недоступен, возвращается кортеж ошибки.</target>
        </trans-unit>
        <trans-unit id="4057f0905e6629307a032b9c000b6e956f9d35d4" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</source>
          <target state="translated">Если модуль уже загружен,то он работает без остановки.Если модуль еще не был загружен,он сначала проверяет,нужно ли его скомпилировать,а затем пытается его загрузить.</target>
        </trans-unit>
        <trans-unit id="e5e8ed6a3a6371fcd484a0f8c9f4271b4ee45925" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</source>
          <target state="translated">Если модуль уже загружен,то это работает как &quot;нет-нет-нет&quot;.Если модуль еще не был загружен,он пытается его загрузить.</target>
        </trans-unit>
        <trans-unit id="a53b9d6b0418ab1b2e4ace2c2f0d58e6dbe324b3" translate="yes" xml:space="preserve">
          <source>If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">Если модуль не инструментирован или данная функция не имеет точки останова, это не &lt;code&gt;:not_found&lt;/code&gt; и она возвращает : not_found . В противном случае возвращается &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b54c97a0a75e51befdfd85bfe55c94a87325400a" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="translated">Если модуль, для которого вы хотите вызвать функцию, имеет длинное имя, например &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt; , и вы находите его подробным, вы можете использовать специальную форму &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; и по-прежнему называть модуль &lt;code&gt;MyLib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3287b87c75de3c7f69ccf215597988b7b4d5d83" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="translated">Если модуль, для которого вы хотите вызвать функцию, имеет длинное имя, например &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt; , и вы считаете его подробным, вы можете использовать специальную форму &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; и по-прежнему называть модуль &lt;code&gt;MyLib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80bfedd28d224208419788d64b48145856d28f2e" translate="yes" xml:space="preserve">
          <source>If the normalized &lt;code&gt;index_range.first&lt;/code&gt; is out of bounds of the given &lt;code&gt;enumerable&lt;/code&gt;, or this one is greater than the normalized &lt;code&gt;index_range.last&lt;/code&gt;, then &lt;code&gt;[]&lt;/code&gt; is returned.</source>
          <target state="translated">Если нормализованный &lt;code&gt;index_range.first&lt;/code&gt; выходит за пределы заданного &lt;code&gt;enumerable&lt;/code&gt; или этот диапазон больше нормализованного &lt;code&gt;index_range.last&lt;/code&gt; , то возвращается &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08e33554a9805c7015a58e968e41eb7b15679006" translate="yes" xml:space="preserve">
          <source>If the number is equidistant to the two nearest integers, rounds away from zero.</source>
          <target state="translated">Если число равноудалено от двух ближайших целых чисел,округляется от нуля.</target>
        </trans-unit>
        <trans-unit id="1ada57e8ed2825b579416e3a51bc87db286561fd" translate="yes" xml:space="preserve">
          <source>If the offset is greater than string length, then it returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если смещение больше длины строки, возвращается &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Если переданная функция возвращает &lt;code&gt;:pop&lt;/code&gt; , возвращаемое значение этого обратного вызова должно быть &lt;code&gt;{value, new_data}&lt;/code&gt; где &lt;code&gt;value&lt;/code&gt; - это значение под &lt;code&gt;key&lt;/code&gt; (или &lt;code&gt;nil&lt;/code&gt; , если нет), а &lt;code&gt;new_data&lt;/code&gt; - это &lt;code&gt;data&lt;/code&gt; без &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">Если переданная функция возвращает &lt;code&gt;{get_value, update_value}&lt;/code&gt; , возвращаемое значение этого обратного вызова должно быть &lt;code&gt;{get_value, new_data}&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="f3dea051cec0438020d90f4862f83ccd43c6add8" translate="yes" xml:space="preserve">
          <source>If the path given to &lt;code&gt;File.read/1&lt;/code&gt; exists, it returns a tuple with the atom &lt;code&gt;:ok&lt;/code&gt; as the first element and the file contents as the second. Otherwise, it returns a tuple with &lt;code&gt;:error&lt;/code&gt; and the error description.</source>
          <target state="translated">Если путь, указанный в &lt;code&gt;File.read/1&lt;/code&gt; , существует, он возвращает кортеж с атомом &lt;code&gt;:ok&lt;/code&gt; в качестве первого элемента и содержимого файла в качестве второго. В противном случае он возвращает кортеж с &lt;code&gt;:error&lt;/code&gt; и описанием ошибки.</target>
        </trans-unit>
        <trans-unit id="53bd7b87b61d322c4fd45f7642221fa6272a8869" translate="yes" xml:space="preserve">
          <source>If the path is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored.</source>
          <target state="translated">Если путь уже является абсолютным путем, &lt;code&gt;relative_to&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="4146f9776d17822883d0a24f1d05b48694b8cdc9" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly (be it by failing or providing a sane default).</source>
          <target state="translated">Если предыдущее значение перед вызовом функции является &lt;code&gt;nil&lt;/code&gt; , то функция &lt;em&gt;будет&lt;/em&gt; получать &lt;code&gt;nil&lt;/code&gt; в качестве значения и должна обрабатывать его соответствующим образом (будьте то неудачей или предоставления вменяемого по умолчанию).</target>
        </trans-unit>
        <trans-unit id="4dbd652e27d03f3eda58f1454adbcc277b1cf2a2" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly.</source>
          <target state="translated">Если предыдущее значение перед вызовом функции является &lt;code&gt;nil&lt;/code&gt; , то функция &lt;em&gt;будет&lt;/em&gt; получать &lt;code&gt;nil&lt;/code&gt; в качестве значения и должен обрабатывать его соответствующим образом .</target>
        </trans-unit>
        <trans-unit id="c374c88228928cded93b273d043b81d7a9e4db50" translate="yes" xml:space="preserve">
          <source>If the process has no messages waiting when the timeout is set and the number of given milliseconds pass without any message arriving, then &lt;code&gt;handle_info/2&lt;/code&gt; will be called with &lt;code&gt;:timeout&lt;/code&gt; as the first argument. The timeout is cleared if any message is waiting or arrives before the given timeout.</source>
          <target state="translated">Если у процесса нет ожидающих сообщений, когда установлен тайм-аут, и количество заданных миллисекунд проходит без прибытия какого-либо сообщения, то &lt;code&gt;handle_info/2&lt;/code&gt; будет вызываться с &lt;code&gt;:timeout&lt;/code&gt; в качестве первого аргумента. Тайм-аут сбрасывается, если какое-либо сообщение ожидает или приходит до указанного тайм-аута.</target>
        </trans-unit>
        <trans-unit id="029b68fe64722c4e17e93dd0458f45ae756acd0b" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;pid&lt;/code&gt; is alive (that is, it's not exiting and has not exited yet) than this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если процесс, идентифицированный &lt;code&gt;pid&lt;/code&gt; , активен (то есть он не завершился и еще не завершился), эта функция возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f04e984ddcea311ccb003e5103d4ca1f57a069c" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="translated">Если процесс уже мертв при вызове &lt;a href=&quot;#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt; , немедленно доставляется сообщение &lt;code&gt;:DOWN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69f0fc29573a8d218a644c814446337651d8b2a1" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="translated">Если процесс уже мертв при вызове &lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt; , немедленно доставляется сообщение &lt;code&gt;:DOWN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25b64d8d09022ae8fa6be42d0e689d9f55f93a0d" translate="yes" xml:space="preserve">
          <source>If the registry has duplicate keys, multiple registrations from the current process under the same key are allowed.</source>
          <target state="translated">Если в реестре есть дубликаты ключей,то разрешается несколько регистраций из текущего процесса под одним и тем же ключом.</target>
        </trans-unit>
        <trans-unit id="296325dc97cde1334962459eb9c5ec5273a16093" translate="yes" xml:space="preserve">
          <source>If the registry has unique keys, it will return &lt;code&gt;{:ok, owner}&lt;/code&gt; unless the key is already associated to a PID, in which case it returns &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt;.</source>
          <target state="translated">Если в реестре есть уникальные ключи, он вернет &lt;code&gt;{:ok, owner}&lt;/code&gt; если ключ уже не связан с PID, и в этом случае он вернет &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86406b94fdf6d0355c113c51cd4e50d8ab966009" translate="yes" xml:space="preserve">
          <source>If the registry is partitioned, the callback is invoked multiple times per partition. If the registry is partitioned and &lt;code&gt;parallel: true&lt;/code&gt; is given as an option, the dispatching happens in parallel. In both cases, the callback is only invoked if there are entries for that partition.</source>
          <target state="translated">Если реестр разделен на разделы, обратный вызов вызывается несколько раз для каждого раздела. Если реестр разделен на разделы и в качестве опции задано значение &lt;code&gt;parallel: true&lt;/code&gt; , отправка выполняется параллельно. В обоих случаях обратный вызов вызывается только при наличии записей для этого раздела.</target>
        </trans-unit>
        <trans-unit id="ee4f792d4247d36f7519cbe4df3f7c9194b0d6d3" translate="yes" xml:space="preserve">
          <source>If the registry is unique, the keys are unique. Otherwise they may contain duplicates if the process was registered under the same key multiple times. The list will be empty if the process is dead or it has no keys in this registry.</source>
          <target state="translated">Если реестр уникален,то ключи уникальны.В противном случае они могут содержать дубликаты,если процесс был зарегистрирован под одним и тем же ключом несколько раз.Список будет пустым,если процесс не работает или у него нет ключей в этом реестре.</target>
        </trans-unit>
        <trans-unit id="cc9c622905709241fd4a039cba6efcb68b163916" translate="yes" xml:space="preserve">
          <source>If the repository is private though, you may need to specify the private URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt;. In any case, Mix will be able to fetch it for you as long as you have the proper credentials.</source>
          <target state="translated">Если репозиторий является частным, вам может потребоваться указать частный URL-адрес &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt; . В любом случае Mix сможет получить его для вас, если у вас есть соответствующие учетные данные.</target>
        </trans-unit>
        <trans-unit id="8f88ca4263ab5c36582e4eb171ede7757f5a8977" translate="yes" xml:space="preserve">
          <source>If the running process terminates, a new IEx session is started.</source>
          <target state="translated">Если запущенный процесс завершается,начинается новый IEx сеанс.</target>
        </trans-unit>
        <trans-unit id="85e3fc96a9666ea6c8e81e1cf2be2da940abf807" translate="yes" xml:space="preserve">
          <source>If the same key is set via &lt;code&gt;@tag&lt;/code&gt;, the &lt;code&gt;@tag&lt;/code&gt; value has higher precedence.</source>
          <target state="translated">Если тот же ключ установлен через &lt;code&gt;@tag&lt;/code&gt; , значение &lt;code&gt;@tag&lt;/code&gt; имеет более высокий приоритет.</target>
        </trans-unit>
        <trans-unit id="bba8e4c316db50e3c886fad2f7191375910352b7" translate="yes" xml:space="preserve">
          <source>If the same variable appears twice in the same pattern, then they must be bound to the same value:</source>
          <target state="translated">Если одна и та же переменная появляется дважды на одной и той же детали,то они должны быть привязаны к одному и тому же значению:</target>
        </trans-unit>
        <trans-unit id="c381bd34f0f516da0adf5a6559d1022816298c76" translate="yes" xml:space="preserve">
          <source>If the scheme is unknown to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module, this function returns &lt;code&gt;nil&lt;/code&gt;. The default port for any scheme can be configured globally via &lt;a href=&quot;#default_port/2&quot;&gt;&lt;code&gt;default_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если схема неизвестна модулю &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; , эта функция возвращает &lt;code&gt;nil&lt;/code&gt; . Порт по умолчанию для любой схемы можно настроить глобально через &lt;a href=&quot;#default_port/2&quot;&gt; &lt;code&gt;default_port/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cf20abb00a9c7eb91eeec27cb0a3c2044ccf845" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, the function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If an agent with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">Если сервер успешно создан и инициализирован, функция возвращает &lt;code&gt;{:ok, pid}&lt;/code&gt; , где &lt;code&gt;pid&lt;/code&gt; - это PID сервера. Если агент с указанным именем уже существует, функция возвращает &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; с PID этого процесса.</target>
        </trans-unit>
        <trans-unit id="6ae18b173fd4f257f191d68374b82b3609576f9a" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If a process with the specified server name already exists, this function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">Если сервер успешно создан и инициализирован, эта функция возвращает &lt;code&gt;{:ok, pid}&lt;/code&gt; , где &lt;code&gt;pid&lt;/code&gt; - это PID сервера. Если процесс с указанным именем сервера уже существует, эта функция возвращает &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; с PID этого процесса.</target>
        </trans-unit>
        <trans-unit id="9c79dacc73fa9835dcb970cb3bd153402ac7a2c0" translate="yes" xml:space="preserve">
          <source>If the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information:</source>
          <target state="translated">Если заглавная буква находится в верхнем регистре,то интерполяция в ней не допускается,иначе ее содержимое может быть динамическим.Для получения более подробной информации сравните результаты подписей,приведенные ниже:</target>
        </trans-unit>
        <trans-unit id="f0d8fa47818ba024a0ca6635125390659b191c06" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если размер с плавающей запятой превышает максимальный размер &lt;code&gt;1.7976931348623157e+308&lt;/code&gt; , возникает исключение &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afe9e25d91e6b6ca076f9ab983498ce202d449f4" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Если размер числа с плавающей запятой превышает максимальный размер &lt;code&gt;1.7976931348623157e+308&lt;/code&gt; , возникает исключение &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f18c5146917295cd360116e64980d6814f74742" translate="yes" xml:space="preserve">
          <source>If the source is a file, it copies &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;destination&lt;/code&gt;. If the &lt;code&gt;source&lt;/code&gt; is a directory, it copies the contents inside source into the &lt;code&gt;destination&lt;/code&gt; directory.</source>
          <target state="translated">Если источником является файл, он копирует &lt;code&gt;source&lt;/code&gt; в &lt;code&gt;destination&lt;/code&gt; . Если &lt;code&gt;source&lt;/code&gt; является каталог, он копирует содержимое внутри источника в &lt;code&gt;destination&lt;/code&gt; каталог.</target>
        </trans-unit>
        <trans-unit id="d79c1221466668c8f2fb37f46a9b0c4eff50c912" translate="yes" xml:space="preserve">
          <source>If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason &lt;code&gt;:shutdown&lt;/code&gt; all the child processes that have already been started, and then terminates itself and returns &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt;.</source>
          <target state="translated">Если функция запуска любого из дочерних процессов завершается с ошибкой или возвращает кортеж с ошибкой или ошибочное значение, супервизор сначала завершает работу с указанием причины &lt;code&gt;:shutdown&lt;/code&gt; всех дочерних процессов, которые уже были запущены, а затем завершает работу и возвращает &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95311d242d980eca3e042ab39a6d275172dd2491" translate="yes" xml:space="preserve">
          <source>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если начало диапазона не является допустимым смещением для данной строки или если диапазон находится в обратном порядке, возвращается &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdd805e8128eab933d8276c52b9cb625ab5fad9b" translate="yes" xml:space="preserve">
          <source>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</source>
          <target state="translated">Если начало или конец диапазона отрицательный,то сначала проходит вся строка,чтобы преобразовать отрицательные индексы в положительные.</target>
        </trans-unit>
        <trans-unit id="fa648af6a9f14eed70d03b7bbaf8c1091284802b" translate="yes" xml:space="preserve">
          <source>If the supervisor already has N children in a way that N exceeds the amount of &lt;code&gt;:max_children&lt;/code&gt; set on the supervisor initialization (see &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;), then this function returns &lt;code&gt;{:error, :max_children}&lt;/code&gt;.</source>
          <target state="translated">Если супервизор уже имеет N дочерних &lt;code&gt;:max_children&lt;/code&gt; таким образом, что N превышает количество : max_children, установленное при инициализации супервизора (см. &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; ), то эта функция возвращает &lt;code&gt;{:error, :max_children}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab3a50abd31e0fe599ff965258406372848105a0" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully spawned (if the start function of each child process returns &lt;code&gt;{:ok, child}&lt;/code&gt;, &lt;code&gt;{:ok, child, info}&lt;/code&gt;, or &lt;code&gt;:ignore&lt;/code&gt;) this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">Если супервизор и его дочерние процессы успешно созданы (если функция запуска каждого дочернего процесса возвращает &lt;code&gt;{:ok, child}&lt;/code&gt; , &lt;code&gt;{:ok, child, info}&lt;/code&gt; или &lt;code&gt;:ignore&lt;/code&gt; ), эта функция возвращает &lt;code&gt;{:ok, pid}&lt;/code&gt; , где &lt;code&gt;pid&lt;/code&gt; - это PID супервизора. Если супервизору присвоено имя и процесс с указанным именем уже существует, функция возвращает &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; , где &lt;code&gt;pid&lt;/code&gt; - это PID этого процесса.</target>
        </trans-unit>
        <trans-unit id="ba930cdc55e703dfc4d9bcd1944d94e721ba5186" translate="yes" xml:space="preserve">
          <source>If the supervisor is successfully spawned, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">Если супервизор успешно создан, эта функция возвращает &lt;code&gt;{:ok, pid}&lt;/code&gt; , где &lt;code&gt;pid&lt;/code&gt; - это PID супервизора. Если супервизору присвоено имя и процесс с указанным именем уже существует, функция возвращает &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; , где &lt;code&gt;pid&lt;/code&gt; - это PID этого процесса.</target>
        </trans-unit>
        <trans-unit id="a58325ece0282e34604d2c42efce1f2775632579" translate="yes" xml:space="preserve">
          <source>If the task or alias has already been invoked, subsequent calls to &lt;a href=&quot;#run/2&quot;&gt;&lt;code&gt;run/2&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;abort&lt;/em&gt; without executing and return &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">Если задача или псевдоним уже вызван, последующие вызовы для &lt;a href=&quot;#run/2&quot;&gt; &lt;code&gt;run/2&lt;/code&gt; &lt;/a&gt; будет &lt;em&gt;прервать&lt;/em&gt; без выполнения и возврата &lt;code&gt;:noop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e53af2f1716d98281bb0f2f71d348e2e0b0ca4dd" translate="yes" xml:space="preserve">
          <source>If the task or alias were already invoked, it does not run them again and simply aborts with &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">Если задача или псевдоним уже были вызваны, он не запускает их снова и просто прерывает выполнение с помощью &lt;code&gt;:noop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd5aaa87ae18322d70f284e647adedce16eae03" translate="yes" xml:space="preserve">
          <source>If the task was not yet invoked, it runs the task and returns the result.</source>
          <target state="translated">Если задача еще не была вызвана,она запускает задачу и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="1ffe14eba0b86eb2256ef62d3f747347750fc072" translate="yes" xml:space="preserve">
          <source>If the terms compare equal, the first one is returned.</source>
          <target state="translated">Если условия сравниваются равными,возвращается первый.</target>
        </trans-unit>
        <trans-unit id="76f5c2bf2f306f61b2cf3e6037db4001b825a0db" translate="yes" xml:space="preserve">
          <source>If the use case where you were using GenEvent requires more complex logic, &lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt; provides a great alternative. GenStage is an external Elixir library maintained by the Elixir team; it provides a tool to implement systems that exchange events in a demand-driven way with built-in support for backpressure. See the &lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Если вариант использования, в котором вы использовали GenEvent, требует более сложной логики, &lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt; предоставляет отличную альтернативу. GenStage - это внешняя библиотека Elixir, поддерживаемая командой Elixir; он предоставляет инструмент для реализации систем, которые обмениваются событиями по запросу, со встроенной поддержкой противодавления. Дополнительную информацию см. &lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;В документации GenStage&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dea741f0a7bd15d40b84d96d22a4ee172da3fb54" translate="yes" xml:space="preserve">
          <source>If the use of this module were confined to your own project, you would be able to keep defining new &lt;code&gt;type/1&lt;/code&gt; functions for each new data type. However, this code could be problematic if it were shared as a dependency by multiple apps because there would be no easy way to extend its functionality.</source>
          <target state="translated">Если бы использование этого модуля было ограничено вашим собственным проектом, вы могли бы продолжать определять новые функции &lt;code&gt;type/1&lt;/code&gt; для каждого нового типа данных. Однако этот код может быть проблематичным, если он будет использоваться в качестве зависимости несколькими приложениями, потому что не будет простого способа расширить его функциональность.</target>
        </trans-unit>
        <trans-unit id="a623a53d8f71f4bfc3e91a4b2fa820b73e9de973" translate="yes" xml:space="preserve">
          <source>If there are config providers, then a value is injected into the &lt;code&gt;:elixir&lt;/code&gt; application configuration in &lt;code&gt;sys_config&lt;/code&gt; to be read during boot and trigger the providers.</source>
          <target state="translated">Если есть конфигурации поставщиков, то значение вводится в &lt;code&gt;:elixir&lt;/code&gt; конфигурации приложения в &lt;code&gt;sys_config&lt;/code&gt; для чтения во время загрузки и запуска поставщиков.</target>
        </trans-unit>
        <trans-unit id="0f3ba34b6884281919234bd65a5c27e05d943121" translate="yes" xml:space="preserve">
          <source>If there are duplicated keys, they are all removed and only the first one is updated.</source>
          <target state="translated">Если есть дубликаты ключей,то все они удаляются и обновляется только первый.</target>
        </trans-unit>
        <trans-unit id="4cc5164cbf429134f06fc3a42dc1c775490799c5" translate="yes" xml:space="preserve">
          <source>If there are no errors, returns a &lt;code&gt;{parsed, rest}&lt;/code&gt; tuple where:</source>
          <target state="translated">Если ошибок нет, возвращает кортеж &lt;code&gt;{parsed, rest}&lt;/code&gt; где:</target>
        </trans-unit>
        <trans-unit id="5f562d79d2233001e164c67b307f491a4295de9f" translate="yes" xml:space="preserve">
          <source>If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below</source>
          <target state="translated">Если вокруг скобок нет новых строк,то форматировщик постарается подогнать все под одну строку,так,что фрагмент ниже</target>
        </trans-unit>
        <trans-unit id="ec750b5e724607eb9b83c43fb0d225987965cd76" translate="yes" xml:space="preserve">
          <source>If there exists a task matching the given task name and it has not yet been invoked, this will run the task with the given &lt;code&gt;args&lt;/code&gt; and return the result.</source>
          <target state="translated">Если существует задача, соответствующая данному имени задачи, и она еще не была вызвана, это запустит задачу с заданными &lt;code&gt;args&lt;/code&gt; и вернет результат.</target>
        </trans-unit>
        <trans-unit id="21bb1c823fd135c98a6434a0ecb8b17912934fc2" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;alias&lt;/a&gt; defined for the given task name, the alias will be invoked instead of the original task.</source>
          <target state="translated">Если есть &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;псевдоним&lt;/a&gt; , определенный для данного имени задачи, псевдоним будет вызываться вместо исходной задачи.</target>
        </trans-unit>
        <trans-unit id="8e379b9421d0be8405c193a1a3a55eda70ffe92a" translate="yes" xml:space="preserve">
          <source>If there is an alias with the same name, the alias will be invoked instead of the original task.</source>
          <target state="translated">Если есть псевдоним с тем же именем,то вместо исходной задачи будет вызван псевдоним.</target>
        </trans-unit>
        <trans-unit id="b8c630c661fb48b6b67b3b3185448712f080b96d" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Если есть интерес зарегистрировать динамические имена локально, не используйте атомы, поскольку атомы никогда не собираются сборщиком мусора и, следовательно, динамически сгенерированные атомы не будут сборщиком мусора. В таких случаях вы можете настроить свой собственный локальный реестр с помощью модуля &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="742d780da366c9749e094a3e2601e05af9f19b1c" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Если есть интерес зарегистрировать динамические имена локально, не используйте атомы, поскольку атомы никогда не собираются сборщиком мусора и, следовательно, динамически сгенерированные атомы не будут собираться сборщиком мусора. В таких случаях вы можете настроить свой собственный локальный реестр с помощью модуля &lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09ae9d40e8862f6952cd3759209cd2022fc6c81a" translate="yes" xml:space="preserve">
          <source>If there is an invalid dependency, its status is printed before aborting.</source>
          <target state="translated">Если существует недействительная зависимость,ее статус распечатывается перед прерыванием.</target>
        </trans-unit>
        <trans-unit id="1e0688b7a0e6bd6041bf3e04042b749415e0032c" translate="yes" xml:space="preserve">
          <source>If there is no current project, &lt;code&gt;nil&lt;/code&gt; is returned. This may happen in cases there is no &lt;code&gt;mix.exs&lt;/code&gt; in the current directory.</source>
          <target state="translated">Если текущего проекта &lt;code&gt;nil&lt;/code&gt; , возвращается nil . Это может произойти, &lt;code&gt;mix.exs&lt;/code&gt; в текущем каталоге нет файла mix.exs .</target>
        </trans-unit>
        <trans-unit id="c639ca5dfec4193385c0f9daeb2b1d4be710cc52" translate="yes" xml:space="preserve">
          <source>If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:</source>
          <target state="translated">Если в почтовом ящике нет сообщения,совпадающего ни с одним из шаблонов,то текущий процесс будет ждать,пока не поступит сообщение о совпадении.Также может быть указан таймаут:</target>
        </trans-unit>
        <trans-unit id="1cbcac0d0378ca0df3e990fb1469a678a45c89ea" translate="yes" xml:space="preserve">
          <source>If there is no option, we generate a random one the first time.</source>
          <target state="translated">Если опции нет,то в первый раз мы генерируем случайный вариант.</target>
        </trans-unit>
        <trans-unit id="8408450afd5b2f3e9042d1b8c13e9f58240f928f" translate="yes" xml:space="preserve">
          <source>If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project.</source>
          <target state="translated">Если проект не определен,он все равно возвращает список ключевых слов со значениями по умолчанию.Это позволяет многим Mix-задачам работать без необходимости в базовом проекте.</target>
        </trans-unit>
        <trans-unit id="6b4a62bcf57109f5efa07a74f29988033109640c" translate="yes" xml:space="preserve">
          <source>If there is no such link, this function does nothing. If &lt;code&gt;pid_or_port&lt;/code&gt; does not exist, this function does not produce any errors and simply does nothing.</source>
          <target state="translated">Если такой ссылки нет, эта функция ничего не делает. Если &lt;code&gt;pid_or_port&lt;/code&gt; не существует, эта функция не выдает ошибок и просто ничего не делает.</target>
        </trans-unit>
        <trans-unit id="690bb679a1fa855e4e7e99b242998643c82b454f" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, the a tuple with &lt;code&gt;:single&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="translated">Если существует только один возможный период для предоставленного &lt;code&gt;datetime&lt;/code&gt; , возвращается кортеж с &lt;code&gt;:single&lt;/code&gt; и &lt;code&gt;time_zone_period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="517af2219a54d5ffad122594bfbc6b466e49d962" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, then a tuple with &lt;code&gt;:ok&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="translated">Если существует только один возможный период для предоставленного &lt;code&gt;datetime&lt;/code&gt; , то возвращается кортеж с &lt;code&gt;:ok&lt;/code&gt; и &lt;code&gt;time_zone_period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f87cf65c1843c87f5a9fb595853f1c2faf34fb20" translate="yes" xml:space="preserve">
          <source>If this function receives a binary, the same binary is returned.</source>
          <target state="translated">Если эта функция получает двоичный файл,то возвращается тот же двоичный файл.</target>
        </trans-unit>
        <trans-unit id="8ec445d356d6135c24d3babce972b050d1a27a32" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="translated">Если это нежелательно, используйте &lt;a href=&quot;#start/1&quot;&gt; &lt;code&gt;Task.start/1&lt;/code&gt; &lt;/a&gt; или рассмотрите возможность запуска задачи под &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; ,&lt;/a&gt; используя &lt;code&gt;async_nolink&lt;/code&gt; или &lt;code&gt;start_child&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="722410509d91a2ea35d8481e8dcb2edd1a9471e8" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;task#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="translated">Если это нежелательно, используйте &lt;a href=&quot;task#start/1&quot;&gt; &lt;code&gt;Task.start/1&lt;/code&gt; &lt;/a&gt; или рассмотрите возможность запуска задачи под &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; ,&lt;/a&gt; используя &lt;code&gt;async_nolink&lt;/code&gt; или &lt;code&gt;start_child&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="885b568a39d2f2144bcbdbe9f088220630bb0f55" translate="yes" xml:space="preserve">
          <source>If those conditions are not met, the behaviour is undefined (on Erlang/OTP 21 and earlier) or will raise (on Erlang/OTP 22 and later).</source>
          <target state="translated">Если эти условия не выполняются,поведение не определено (на Erlang/OTP 21 и более ранних версиях)или будет повышаться (на Erlang/OTP 22 и более поздних версиях).</target>
        </trans-unit>
        <trans-unit id="c532c9eeb04daa8871cfe8c245158904c23d03c5" translate="yes" xml:space="preserve">
          <source>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">Если два календаря несовместимы,мы можем конвертировать только время и время между ними.Если они совместимы,это означает,что мы также можем конвертировать даты,а также наивные даты между ними.</target>
        </trans-unit>
        <trans-unit id="6230d8e63d2f6528e6ac7ed7bd4bbeed089d2da9" translate="yes" xml:space="preserve">
          <source>If two modules &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are imported and they both contain a &lt;code&gt;foo&lt;/code&gt; function with an arity of &lt;code&gt;1&lt;/code&gt;, an error is only emitted if an ambiguous call to &lt;code&gt;foo/1&lt;/code&gt; is actually made; that is, the errors are emitted lazily, not eagerly.</source>
          <target state="translated">Если импортируются два модуля &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , и оба они содержат функцию &lt;code&gt;foo&lt;/code&gt; с арностью &lt;code&gt;1&lt;/code&gt; , ошибка выдается только в том случае, если действительно выполняется неоднозначный вызов &lt;code&gt;foo/1&lt;/code&gt; ; то есть ошибки выдаются лениво, а не нетерпеливо.</target>
        </trans-unit>
        <trans-unit id="55cdfd10bc87ea7561c4ad8cc479f9faf3b27132" translate="yes" xml:space="preserve">
          <source>If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms:</source>
          <target state="translated">Если присутствуют заглавные символы,то они никоим образом не изменяются как механизм сохранения аббревиатур:</target>
        </trans-unit>
        <trans-unit id="1343958b023308460ee2f6f5daf43ba1fb660edd" translate="yes" xml:space="preserve">
          <source>If we save the code above in a file named &amp;ldquo;concat.ex&amp;rdquo; and compile it, Elixir will emit the following warning:</source>
          <target state="translated">Если мы сохраним приведенный выше код в файле с именем &amp;laquo;concat.ex&amp;raquo; и скомпилируем его, Elixir выдаст следующее предупреждение:</target>
        </trans-unit>
        <trans-unit id="8fc6b97491613a1b35780efb44cacd0f0d9099d1" translate="yes" xml:space="preserve">
          <source>If we start our server, we can now send commands to it. For now, we will get two different responses: &amp;ldquo;OK&amp;rdquo; when the command is known and &amp;ldquo;UNKNOWN COMMAND&amp;rdquo; otherwise:</source>
          <target state="translated">Если мы запустим наш сервер, теперь мы можем отправлять ему команды. На данный момент мы получим два разных ответа: &amp;laquo;ОК&amp;raquo;, если команда известна, и &amp;laquo;НЕИЗВЕСТНАЯ КОМАНДА&amp;raquo; в противном случае:</target>
        </trans-unit>
        <trans-unit id="74591893e85cc364e81b230bedab46ae114fe665" translate="yes" xml:space="preserve">
          <source>If we try to dispatch to &lt;code&gt;Hello.world&lt;/code&gt;, it won't be available as it was defined only in the other shell:</source>
          <target state="translated">Если мы попытаемся отправить в &lt;code&gt;Hello.world&lt;/code&gt; , он не будет доступен, поскольку он был определен только в другой оболочке:</target>
        </trans-unit>
        <trans-unit id="51c60bac3d7f07a69c2caf5416fb9b2fa0580339" translate="yes" xml:space="preserve">
          <source>If we use chardata instead, it will work as expected:</source>
          <target state="translated">Если мы будем использовать чардата вместо него,то он будет работать,как и ожидалось:</target>
        </trans-unit>
        <trans-unit id="5c38beec4d9e8627a3718fd3acf1efdd27ca154a" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;code&gt;:into&lt;/code&gt;, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.</source>
          <target state="translated">Если бы мы использовали &lt;code&gt;:into&lt;/code&gt; , нам понадобился бы тип данных, который вычисляет частоту каждого содержащегося в нем элемента. Хотя в Elixir нет такого типа данных, вы можете реализовать его самостоятельно.</target>
        </trans-unit>
        <trans-unit id="6b4e1d5251f6539ac9cb9db6500f4e6878385d0e" translate="yes" xml:space="preserve">
          <source>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</source>
          <target state="translated">Если вы используете псевдоним модуля и не используете псевдоним,Elixir выдаст предупреждение,подразумевающее,что псевдоним не используется.</target>
        </trans-unit>
        <trans-unit id="353408b9f20e6cd80af272ea14032adbf9497508" translate="yes" xml:space="preserve">
          <source>If you are connected to remote shell, it remains alive after disconnection.</source>
          <target state="translated">Если вы подключены к удалённой оболочке,она останется живой после отключения.</target>
        </trans-unit>
        <trans-unit id="6de1badf3f486dd7b08674c46aeede1396ae7af3" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;a href=&quot;https://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы заинтересованы во внедрении менеджера событий, прочтите раздел &amp;laquo;Альтернативы&amp;raquo; ниже. Если вам необходимо реализовать обработчик событий для интеграции с существующей системой, такой как Elixir's Logger, используйте вместо этого &lt;a href=&quot;https://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efc5604d31d0bf68a1f19a9b171547de1fbb3007" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;code&gt;:gen_event&lt;/code&gt; instead.</source>
          <target state="translated">Если вы заинтересованы во внедрении менеджера событий, прочтите раздел &amp;laquo;Альтернативы&amp;raquo; ниже. Если вам необходимо реализовать обработчик событий для интеграции с существующей системой, такой как Elixir's Logger, используйте вместо этого &lt;code&gt;:gen_event&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51ef50c4ad529792706bf2b89ce565387c1909b0" translate="yes" xml:space="preserve">
          <source>If you are looking for a distributed key-value store to use in production, you should definitely look into &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;, which also runs in the Erlang</source>
          <target state="translated">Если вы ищете распределенное хранилище ключей и значений для использования в производственной среде, вам обязательно стоит обратить внимание на &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt; , который также работает в Erlang.</target>
        </trans-unit>
        <trans-unit id="1c8bab3f8a9ae8447c6ed759b9dc3262c1eec9de" translate="yes" xml:space="preserve">
          <source>If you are on Windows, you will have to open up &lt;code&gt;rel/env.bat.eex&lt;/code&gt;, where you will find this:</source>
          <target state="translated">Если вы работаете в Windows, вам нужно открыть &lt;code&gt;rel/env.bat.eex&lt;/code&gt; , где вы найдете следующее:</target>
        </trans-unit>
        <trans-unit id="44c91ebf5be7f8382f751128810946bd95b4f4b2" translate="yes" xml:space="preserve">
          <source>If you are planning to write your first library for other developers to use, don&amp;rsquo;t forget to read our &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;Library Guidelines&lt;/a&gt;.</source>
          <target state="translated">Если вы планируете написать свою первую библиотеку для использования другими разработчиками, не забудьте прочитать наши &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;правила использования библиотеки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f27d0db77231a9a9fe1e42f70173831ee041fc6d" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt; or &lt;code&gt;@describetag&lt;/code&gt; attribute, you must set them after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">Если вы устанавливаете &lt;code&gt;@moduletag&lt;/code&gt; или &lt;code&gt;@describetag&lt;/code&gt; , вы должны установить их после вашего вызова, чтобы &lt;code&gt;use ExUnit.Case&lt;/code&gt; иначе вы увидите ошибки компиляции.</target>
        </trans-unit>
        <trans-unit id="2b2be79d72180600413436f842949c96ba6fb15b" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt;, you must set that after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">Если вы устанавливаете &lt;code&gt;@moduletag&lt;/code&gt; , вы должны установить его после вызова для &lt;code&gt;use ExUnit.Case&lt;/code&gt; иначе вы увидите ошибки компиляции.</target>
        </trans-unit>
        <trans-unit id="5362f8df1641dd054f73093e43438bbe86931ff4" translate="yes" xml:space="preserve">
          <source>If you are setting this option manually, we recommend the cookie option to be a long and randomly generated string, such as: &lt;code&gt;Base.url_encode64(:crypto.strong_rand_bytes(40))&lt;/code&gt;. We also recommend to restrict the characters in the cookie to the subset returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#url_encode64/1&quot;&gt;&lt;code&gt;Base.url_encode64/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы устанавливаете этот параметр вручную, мы рекомендуем, чтобы параметр cookie был длинной и случайно сгенерированной строкой, например: &lt;code&gt;Base.url_encode64(:crypto.strong_rand_bytes(40))&lt;/code&gt; . Мы также рекомендуем ограничить символы в cookie подмножеством, возвращаемым &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#url_encode64/1&quot;&gt; &lt;code&gt;Base.url_encode64/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84977d9680ddbf5de974cbe18e56c1d8e5ed315c" translate="yes" xml:space="preserve">
          <source>If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:</source>
          <target state="translated">Если вы используете альтернативные календари,можно использовать любое представление при условии,что вы следуете представлению одним пробелом и именем календаря:</target>
        </trans-unit>
        <trans-unit id="7fff90eb4ac49dc35b69d8799d504d16e31937d0" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">Если вы используете асинхронные задачи, вы &lt;strong&gt;должны дождаться&lt;/strong&gt; ответа, так как они &lt;em&gt;всегда&lt;/em&gt; отправляются. Если вы не ожидаете ответа, рассмотрите возможность использования &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; ,описанного&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="e14a93bec8f9e7583ef7d4636212d137d7df029a" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">Если вы используете асинхронные задачи, вы &lt;strong&gt;должны дождаться&lt;/strong&gt; ответа, так как они &lt;em&gt;всегда&lt;/em&gt; отправляются. Если вы не ожидаете ответа, рассмотрите возможность использования &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; ,описанного&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="f469101752f119e7e176bed241907b041da8adaa" translate="yes" xml:space="preserve">
          <source>If you are using releases, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, there another configuration file called &lt;code&gt;config/releases.exs&lt;/code&gt;. While &lt;code&gt;config/config.exs&lt;/code&gt; and friends mentioned in the previous section are executed whenever you run a Mix command, including when you assemble a release, &lt;code&gt;config/releases.exs&lt;/code&gt; is execute every time your production system boots. Since Mix is not available in a production system, &lt;code&gt;config/releases.exs&lt;/code&gt; must not use any of the functions from Mix.</source>
          <target state="translated">Если вы используете выпуски, см. &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; , там еще один файл конфигурации с именем &lt;code&gt;config/releases.exs&lt;/code&gt; . Хотя &lt;code&gt;config/config.exs&lt;/code&gt; и друзья, упомянутые в предыдущем разделе, выполняются всякий раз, когда вы запускаете команду Mix, в том числе при сборке выпуска, &lt;code&gt;config/releases.exs&lt;/code&gt; выполняется каждый раз при загрузке вашей производственной системы. Поскольку Mix недоступен в производственной системе, &lt;code&gt;config/releases.exs&lt;/code&gt; не должен использовать какие-либо функции из Mix.</target>
        </trans-unit>
        <trans-unit id="9e377e363c18762d6989f073da394e35ff6a1d87" translate="yes" xml:space="preserve">
          <source>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</source>
          <target state="translated">Если вы используете несколько функций из данного модуля,то вы можете импортировать эти функции и,например,ссылаться на них как на локальные функции:</target>
        </trans-unit>
        <trans-unit id="d9f991b27b559271b270b3fbea782f7486b09a69" translate="yes" xml:space="preserve">
          <source>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</source>
          <target state="translated">Если вы попытаетесь определить модуль,который уже существует,вы получите предупреждение о том,что модуль был переопределен.</target>
        </trans-unit>
        <trans-unit id="8adfc9342331c8cadc540a2cd5ed23c3faf380ba" translate="yes" xml:space="preserve">
          <source>If you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!</source>
          <target state="translated">Если вы еще раз подключитесь к локальному хосту и выполните еще один запрос,то теперь все должно работать,пока таблица маршрутизации содержит правильные имена узлов.Отлично!</target>
        </trans-unit>
        <trans-unit id="9a27ffb13441db905f42c43f88d86b47f09d7485" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Если вы создаете задачу с помощью &lt;code&gt;async_nolink&lt;/code&gt; внутри поведения OTP, такого как &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , вы должны сопоставить сообщение, исходящее от задачи, внутри вашего обратного вызова &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7afc1a9d68fb426d62d00d555f8cf086c3ea70ff" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Если вы создаете задачу с помощью &lt;code&gt;async_nolink&lt;/code&gt; внутри поведения OTP, такого как &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , вы должны сопоставить сообщение, исходящее от задачи, внутри вашего обратного вызова &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55b7d0164ac505a2fe344467d02c4867bf511345" translate="yes" xml:space="preserve">
          <source>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt;&lt;code&gt;:os.cmd/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите выполнить надежную команду внутри оболочки с &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt; &lt;code&gt;:os.cmd/1&lt;/code&gt; &lt;/a&gt; , перенаправлением и т. Д., Проверьте : os.cmd / 1 .</target>
        </trans-unit>
        <trans-unit id="0c4ee42b2a872c035a26a259f3f919efaaede387" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">Если вас не волнуют результаты вычислений, вы можете запустить поток с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; &lt;/a&gt; . Также установите order &lt;code&gt;ordered: false&lt;/code&gt; , так как порядок результатов вам тоже не важен:</target>
        </trans-unit>
        <trans-unit id="a07182ef0f8b88c81a61025e684458268493b23a" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;stream#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">Если вас не волнуют результаты вычислений, вы можете запустить поток с помощью &lt;a href=&quot;stream#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; &lt;/a&gt; . Также установите order &lt;code&gt;ordered: false&lt;/code&gt; , так как порядок результатов вам тоже не важен:</target>
        </trans-unit>
        <trans-unit id="368841cd2351fb8c28d9325238a5752ebba7a138" translate="yes" xml:space="preserve">
          <source>If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the &lt;code&gt;--option-parser-example&lt;/code&gt; switch because the &lt;code&gt;:option_parser_example&lt;/code&gt; atom is never used anywhere:</source>
          <target state="translated">Если вы хотите проанализировать неизвестные переключатели, помните, что Elixir преобразует переключатели в атомы. Поскольку атомы не собираются сборщиком мусора, OptionParser будет анализировать только переключатели, которые преобразуются в атомы, используемые средой выполнения, чтобы избежать утечки атомов. Например, приведенный ниже код отбрасывает &lt;code&gt;--option-parser-example&lt;/code&gt; потому что атом &lt;code&gt;:option_parser_example&lt;/code&gt; нигде не используется:</target>
        </trans-unit>
        <trans-unit id="bb3116d6b170b69080991a7150c103095c5454b2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have any use for the error, you don&amp;rsquo;t have to provide it:</source>
          <target state="translated">Если ошибка вам не нужна, указывать ее необязательно:</target>
        </trans-unit>
        <trans-unit id="c77ad5b32204a8ca68d3f5ddb986c84f0f9228ac" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a default key value when defining a struct, &lt;code&gt;nil&lt;/code&gt; will be assumed:</source>
          <target state="translated">Если вы не укажете значение ключа по умолчанию при определении структуры, будет принято значение &lt;code&gt;nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c6d6c827a17a1772b5dade87fd7f321c6f06b85" translate="yes" xml:space="preserve">
          <source>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</source>
          <target state="translated">Если тебе не нужен процесс,то тебе не нужен процесс.Используйте процессы только для моделирования исполнительных свойств,таких как мутируемое состояние,параллельность и сбои,никогда для организации кода.</target>
        </trans-unit>
        <trans-unit id="c5e7f3f6aaa70bf2b4b5317311d23bff5dd41301" translate="yes" xml:space="preserve">
          <source>If you don't want to assert for every result in a doctest, you can omit the result. You can do so between expressions:</source>
          <target state="translated">Если вы не хотите утверждать для каждого результата в док-тесте,вы можете пропустить результат.Вы можете сделать это между выражениями:</target>
        </trans-unit>
        <trans-unit id="55f782e4dd6bf586b9ca7b60f48c228585b2ac7c" translate="yes" xml:space="preserve">
          <source>If you don't want to import a function or macro from &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, use the &lt;code&gt;:except&lt;/code&gt; option and then list the function/macro by arity:</source>
          <target state="translated">Если вы не хотите импортировать функцию или макрос из &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; , используйте параметр &lt;code&gt;:except&lt;/code&gt; , а затем укажите функцию / макрос по арности:</target>
        </trans-unit>
        <trans-unit id="b4113a290da07af08fe359b9ce4d7fc5b55806b8" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы не хотите связывать вызывающего абонента с задачей, вы должны использовать контролируемую задачу с &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; и вызвать &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0fdad62ae1fb19bf40fae581950eb21ad57ac2c" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы не хотите связывать вызывающего абонента с задачей, вы должны использовать контролируемую задачу с &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; и вызвать &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b7f3eba3dd98ca6590eeed6ea68a53ee96f3d2" translate="yes" xml:space="preserve">
          <source>If you don't want to remove all the entries associated with &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; instead, that function will remove only the first entry.</source>
          <target state="translated">Если вы не хотите удалять все записи, связанные с &lt;code&gt;key&lt;/code&gt; используйте вместо этого &lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt; , эта функция удалит только первую запись.</target>
        </trans-unit>
        <trans-unit id="296ef732a2b3390cd10f991ad01cb9a80eb4f583" translate="yes" xml:space="preserve">
          <source>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;get!/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы ожидаете, что проект будет определен, т. Е. Это требование текущей задачи, вам следует вместо этого вызвать &lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;get!/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05da62df25733918acb3c100ca6eefcc7e8a9a05" translate="yes" xml:space="preserve">
          <source>If you find any errors in the tutorial or on the website, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;please report a bug or send a pull request to our issue tracker&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружите какие-либо ошибки в учебнике или на веб-сайте, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;сообщите об ошибке или отправьте запрос на перенос в нашу систему отслеживания проблем&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3352da2349194da360a70c60c5b2d7bfce63e72d" translate="yes" xml:space="preserve">
          <source>If you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.</source>
          <target state="translated">Если вы окажетесь в положении,когда вы хотите использовать различные конфигурации в каждом приложении для одной и той же зависимости или использовать различные версии зависимостей,то,скорее всего,ваша кодовая база выросла за пределы того,что зонты могут обеспечить.</target>
        </trans-unit>
        <trans-unit id="966f4145842556d60eacaa5cb05900d76971a573" translate="yes" xml:space="preserve">
          <source>If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;#async_stream_nolink/6&quot;&gt;&lt;code&gt;async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="translated">Если вы обнаружите, что перехватываете выходы для обработки выходов внутри асинхронного потока, подумайте об использовании &lt;a href=&quot;#async_stream_nolink/6&quot;&gt; &lt;code&gt;async_stream_nolink/6&lt;/code&gt; &lt;/a&gt; для запуска задач, которые не связаны с вызывающим процессом.</target>
        </trans-unit>
        <trans-unit id="4197dd8400c648df18d603e11d970a3cb8836276" translate="yes" xml:space="preserve">
          <source>If you forget to escape it, Elixir will raise an error when compiling the code.</source>
          <target state="translated">Если вы забудете избежать этого,Elixir поднимет ошибку при компиляции кода.</target>
        </trans-unit>
        <trans-unit id="56efc6ca629edeb2fce03d19b2bc73e5833972b7" translate="yes" xml:space="preserve">
          <source>If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments.</source>
          <target state="translated">Если у вас есть файл,который должен компилировать другие модули параллельно,порожденные процессы должны быть осведомлены об окружении компилятора.Эта функция позволяет разработчику создать задачу,которая осведомлена об этих средах.</target>
        </trans-unit>
        <trans-unit id="c5adbe460020f7a732f72beadb2bbe1b2658c06f" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть структура, и вы хотите объединить набор ключей в структуру, не используйте эту функцию, так как она объединит все ключи с правой стороны в структуру, даже если ключ не является частью структуры. Вместо этого используйте &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="772ddb24d9ed2ed3cd849be346856ed163202199" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть структура и вы хотите объединить набор ключей в структуру, не используйте эту функцию, так как она объединит все ключи с правой стороны в структуру, даже если ключ не является частью структуры. Вместо этого используйте &lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02d90c57cd4c0d17ad045bc9f12b98eb64e0aa31" translate="yes" xml:space="preserve">
          <source>If you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.</source>
          <target state="translated">Если у вас есть внутренняя зависимость,Mix поддерживает два метода работы с ними:Git-репозитории или зонтичные проекты.</target>
        </trans-unit>
        <trans-unit id="4e035a407e624050895eb31725f1748d9f855294" translate="yes" xml:space="preserve">
          <source>If you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don&amp;rsquo;t, you can start another IEx session in another terminal. In either case, give it the short name of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">Если у вас есть другой компьютер в той же сети, на котором установлены Erlang и Elixir, вы можете запустить на нем другую оболочку. Если вы этого не сделаете, вы можете запустить другой сеанс IEx в другом терминале. В любом случае дайте ему короткое имя &lt;code&gt;bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91e486a025ad182f48607bffbb20dc17512610a7" translate="yes" xml:space="preserve">
          <source>If you have any questions or improvements to the guide, please reach discussion channels such as the &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir Forum&lt;/a&gt; or the &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;issues tracker&lt;/a&gt;. Your input is really important to help us guarantee the guides are accessible and up to date!</source>
          <target state="translated">Если у вас есть какие-либо вопросы или улучшения в руководстве, обращайтесь к дискуссионным каналам, таким как &lt;a href=&quot;https://elixirforum.com&quot;&gt;форум Elixir&lt;/a&gt; или &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;средство отслеживания проблем&lt;/a&gt; . Ваш вклад действительно важен, чтобы помочь нам гарантировать доступность и актуальность руководств!</target>
        </trans-unit>
        <trans-unit id="aab49794b532da97c155763d4fee42c69953f3cd" translate="yes" xml:space="preserve">
          <source>If you have prior programming experience, you may be wondering: &amp;ldquo;could we just guarantee the bucket does not crash in the first place?&amp;rdquo;. As we will see, Elixir developers tend to refer to those practices as &amp;ldquo;defensive programming&amp;rdquo;. That&amp;rsquo;s because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!</source>
          <target state="translated">Если у вас есть предыдущий опыт программирования, вы можете спросить: &amp;laquo;Можем ли мы просто гарантировать, что корзина не выйдет из строя?&amp;raquo;. Как мы увидим, разработчики Elixir склонны называть эти методы &amp;laquo;защитным программированием&amp;raquo;. Это связано с тем, что у живой производственной системы есть десятки разных причин, по которым что-то может пойти не так. Диск может выйти из строя, память может быть повреждена, могут возникнуть ошибки, сеть может перестать работать на секунду и т. Д. Если бы мы написали программное обеспечение, которое пытается защитить или обойти все эти ошибки, мы бы потратили больше времени на обработку сбоев, чем на написание наших собственное ПО!</target>
        </trans-unit>
        <trans-unit id="4ff3bc0809c7cb590dd86540f6bc9220ad4b14e5" translate="yes" xml:space="preserve">
          <source>If you have skipped the Getting Started guide or read it long ago, be sure to re-read the &lt;a href=&quot;../processes&quot;&gt;Processes&lt;/a&gt; chapter. We will use it as a starting point.</source>
          <target state="translated">Если вы пропустили руководство по началу работы или прочитали его давно, обязательно перечитайте главу &amp;laquo; &lt;a href=&quot;../processes&quot;&gt;Процессы&amp;raquo;&lt;/a&gt; . Мы будем использовать это как отправную точку.</target>
        </trans-unit>
        <trans-unit id="d5e749fd5e08cb28911eb18410413620f0bb3b45" translate="yes" xml:space="preserve">
          <source>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</source>
          <target state="translated">Если необходимо,можно придумать поведение,подобное интерфейсам в объектно-ориентированных языках,таких как Java:набор функциональных сигнатур,которые модуль должен реализовать.</target>
        </trans-unit>
        <trans-unit id="775881310bd0276caea4cdc0616b4fb21efd691c" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed Elixir, visit our &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;installation page&lt;/a&gt;. Once you are done, you can run &lt;code&gt;elixir --version&lt;/code&gt; to get the current Elixir version.</source>
          <target state="translated">Если вы еще не установили Elixir, посетите нашу &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;страницу установки&lt;/a&gt; . Когда вы закончите, вы можете запустить &lt;code&gt;elixir --version&lt;/code&gt; , чтобы получить текущую версию Elixir.</target>
        </trans-unit>
        <trans-unit id="68dc8f62a9e86b3efbf7155da89ee4b3f7fa0def" translate="yes" xml:space="preserve">
          <source>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</source>
          <target state="translated">Если вы импортируете модуль и не используете ни одну из импортируемых функций или макросов из этого модуля,Elixir выдаст предупреждение,подразумевающее,что импорт не используется.</target>
        </trans-unit>
        <trans-unit id="dd8b4968a8e609a12b5b450ac372d4f06174ea20" translate="yes" xml:space="preserve">
          <source>If you intend to shut the task down if it has not responded within &lt;code&gt;timeout&lt;/code&gt; milliseconds, you should chain this together with &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="translated">Если вы собираетесь закрыть задачу, если она не ответила в течение миллисекунд &lt;code&gt;timeout&lt;/code&gt; , вы должны связать это вместе с &lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="d30e514f11705943605d282b2e9e021b246888e0" translate="yes" xml:space="preserve">
          <source>If you introduce custom keys into the AST metadata, please make sure to prefix them with the name of your library or application, so that they will not conflict with keys that could potentially be introduced by the compiler in the future.</source>
          <target state="translated">Если вы вводите пользовательские ключи в метаданные AST,убедитесь,что они префиксованы с именем вашей библиотеки или приложения,чтобы они не конфликтовали с ключами,которые потенциально могут быть введены компилятором в будущем.</target>
        </trans-unit>
        <trans-unit id="35ca2c3b656fa7f282e972b00616f04b656b2e75" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system than the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">Если вы знаете, что работаете в системе, отличной от текущей, и выполняете несколько совпадений с регулярным выражением, вы можете вручную вызвать &lt;a href=&quot;#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; ,&lt;/a&gt; чтобы выполнить проверку версии во время выполнения и перекомпилировать регулярное выражение если необходимо.</target>
        </trans-unit>
        <trans-unit id="83089d9b73e4091162a26829945c724a24daa00a" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system that the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;regex#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;regex#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">Если вы знаете, что работаете в системе, отличной от текущей, и выполняете несколько совпадений с регулярным выражением, вы можете вручную вызвать &lt;a href=&quot;regex#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;regex#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; ,&lt;/a&gt; чтобы выполнить проверку версии во время выполнения и перекомпилировать регулярное выражение. если необходимо.</target>
        </trans-unit>
        <trans-unit id="5923e8f45f692122d1145ed7532ef3732f1c075a" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужен общий словарь, используйте модуль &amp;laquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; &amp;raquo;. Если вам нужно управлять списками ключевых слов, используйте &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c864040fa40407fd79ba39543ee8e3143a0a20c" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужен общий словарь, используйте модуль &amp;laquo; &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; &amp;raquo;. Если вам нужно управлять списками ключевых слов, используйте &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="681b1d87291217ee1d95dbf7ef258360d3658bf7" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">Если вам нужно преобразовать кортеж или дочернюю спецификацию модуля в карту или изменить дочернюю спецификацию, вы можете использовать функцию &lt;a href=&quot;#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt; . Например, чтобы запустить стек с другим значением &lt;code&gt;:id&lt;/code&gt; и &lt;code&gt;:shutdown&lt;/code&gt; , равным 10 секундам (10_000 миллисекунд):</target>
        </trans-unit>
        <trans-unit id="89167dae9b93318185a943b4d7ef66af8fd1ecaf" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">Если вам нужно преобразовать кортеж или дочернюю спецификацию модуля в карту или изменить дочернюю спецификацию, вы можете использовать функцию &lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt; . Например, чтобы запустить стек с другим значением &lt;code&gt;:id&lt;/code&gt; и &lt;code&gt;:shutdown&lt;/code&gt; , равным 10 секундам (10_000 миллисекунд):</target>
        </trans-unit>
        <trans-unit id="5ad76921951319e02147caba8a55f21b979bd0dc" translate="yes" xml:space="preserve">
          <source>If you need to pass options to the Elixir executable at the same time you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, it can be done as follows:</source>
          <target state="translated">Если вам нужно передать параметры исполняемому файлу Elixir &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; , это можно сделать следующим образом:</target>
        </trans-unit>
        <trans-unit id="f6c0541d61f0fa3dc5971ad5a9aedc3239c20f25" translate="yes" xml:space="preserve">
          <source>If you open up &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, you will see:</source>
          <target state="translated">Если вы откроете &lt;code&gt;rel/env.sh.eex&lt;/code&gt; , вы увидите:</target>
        </trans-unit>
        <trans-unit id="54dbe001cacf2c5ab7935d57b0759fa2b1d3fbe5" translate="yes" xml:space="preserve">
          <source>If you partition your tests across multiple runs, you can unify the report as shown below:</source>
          <target state="translated">Если вы разбиваете тесты на несколько запусков,вы можете унифицировать отчет,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="13001202c030e74a6a243756fd13162b4aa903b4" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;:trim_bom&lt;/code&gt; in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</source>
          <target state="translated">Если вы передадите &lt;code&gt;:trim_bom&lt;/code&gt; в параметре mode , поток будет обрезать метки порядка байтов UTF-8, UTF-16 и UTF-32 при чтении из файла.</target>
        </trans-unit>
        <trans-unit id="ca5840e930e22f09ee97165c990a4a919232564f" translate="yes" xml:space="preserve">
          <source>If you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</source>
          <target state="translated">Если вы планируете сравнить несколько строк,несколько раз подряд,вы можете предварительно нормализовать их и напрямую сравнить,чтобы избежать многократных проходов нормализации.</target>
        </trans-unit>
        <trans-unit id="728af62f46ec9153dd25f06ee03542653209b55d" translate="yes" xml:space="preserve">
          <source>If you prefer to use only operators or skip them, you can pass the following options:</source>
          <target state="translated">Если вы предпочитаете использовать только операторов или пропускать их,вы можете передать следующие опции:</target>
        </trans-unit>
        <trans-unit id="ced663b6bbb3741a07875a23a42c76c24864c77e" translate="yes" xml:space="preserve">
          <source>If you prefer, you can also compile the release to a separate directory, so you can erase all source after the release is assembled:</source>
          <target state="translated">При желании вы также можете скомпилировать релиз в отдельном каталоге,так что вы сможете стереть все исходные тексты после того,как релиз будет собран:</target>
        </trans-unit>
        <trans-unit id="cd3676cec1bf0b821202c618090e6007102597bd" translate="yes" xml:space="preserve">
          <source>If you revisit the &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; implementation, you will remember it simply passes the options to GenServer:</source>
          <target state="translated">Если вы &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; к реализации KV.Registry.start_link / 1 , вы помните, что она просто передает параметры в GenServer:</target>
        </trans-unit>
        <trans-unit id="c5a45f99d559f9a09020a743643928ce3b42a8da" translate="yes" xml:space="preserve">
          <source>If you run &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix test.coverage&lt;/code&gt;&lt;/a&gt; inside an umbrella, it will automatically gather exported cover results from all umbrella children - as long as the coverage results have been exported, like this:</source>
          <target state="translated">Если вы запустите &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix test.coverage&lt;/code&gt; &lt;/a&gt; внутри зонта, он автоматически соберет экспортированные результаты покрытия от всех дочерних элементов зонтика - до тех пор, пока результаты покрытия были экспортированы, например:</target>
        </trans-unit>
        <trans-unit id="c5d6222828dfd649eaac97782a9142f48d5d1965" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;bin/foo start&lt;/code&gt;, it will start the system using a short name (&lt;code&gt;--sname&lt;/code&gt;) equal to the release name, which in this case is &lt;code&gt;foo&lt;/code&gt;. The next step is to start a system named &lt;code&gt;bar&lt;/code&gt;, so we can connect &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together, like we did in the previous chapter. But before we achieve this, let&amp;rsquo;s talk a bit about the benefits of releases.</source>
          <target state="translated">Если вы запустите &lt;code&gt;bin/foo start&lt;/code&gt; , он запустит систему с коротким именем ( &lt;code&gt;--sname&lt;/code&gt; ), равным имени выпуска, которым в данном случае является &lt;code&gt;foo&lt;/code&gt; . Следующим шагом будет запуск системы с именем &lt;code&gt;bar&lt;/code&gt; , чтобы мы могли соединить вместе &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; , как мы это делали в предыдущей главе. Но прежде чем мы добьемся этого, давайте немного поговорим о преимуществах релизов.</target>
        </trans-unit>
        <trans-unit id="b99f38f9001edc5d832c83870cb64c18a6a5f599" translate="yes" xml:space="preserve">
          <source>If you start &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; is still running, you will see an error like the error below happen 5 times, before the application finally shuts down:</source>
          <target state="translated">Если вы запустите &lt;code&gt;bar&lt;/code&gt; , когда &lt;code&gt;foo&lt;/code&gt; все еще работает, вы увидите ошибку, подобную приведенной ниже ошибке, которая произошла 5 раз, прежде чем приложение окончательно завершит работу:</target>
        </trans-unit>
        <trans-unit id="b481bb0915de73d372e211939b206d16352c309c" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;message&lt;/code&gt;, information about the values will automatically be appended to it.</source>
          <target state="translated">Если вы предоставите &lt;code&gt;message&lt;/code&gt; , информация о значениях будет автоматически добавлена ​​к нему.</target>
        </trans-unit>
        <trans-unit id="f285809f1a4da78d4627f76c40391bd1d6265ba1" translate="yes" xml:space="preserve">
          <source>If you try to match on such an expression, &lt;code&gt;doctest&lt;/code&gt; will fail to compile. There are two ways to resolve this.</source>
          <target state="translated">Если вы попытаетесь сопоставить такое выражение, &lt;code&gt;doctest&lt;/code&gt; не скомпилируется. Есть два способа решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="b5d18cb7539ec0d5066e34df4b08df26b2985b68" translate="yes" xml:space="preserve">
          <source>If you try to run our new macro, you will notice it won't even compile, complaining that the variables &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; do not exist. This is because of the ambiguity: &lt;code&gt;unquote(k)&lt;/code&gt; can either be an unquote fragment, as previously, or a regular unquote as in &lt;code&gt;unquote(kv)&lt;/code&gt;.</source>
          <target state="translated">Если вы попытаетесь запустить наш новый макрос, вы заметите, что он даже не скомпилируется, жалуясь, что переменные &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; не существуют. Это из-за двусмысленности: &lt;code&gt;unquote(k)&lt;/code&gt; может быть либо фрагментом unquote, как раньше, либо обычным unquote, как &lt;code&gt;unquote(kv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19c103426cd0a9b9cd1e418473a1f010bac3593" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a code point that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">Если вы попытаетесь использовать &lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; для chardata, это приведет к ошибке аргумента. Например, давайте попробуем поместить кодовую точку, которая не может быть представлена ​​одним байтом, например &lt;code&gt;?&amp;pi;&lt;/code&gt; , внутри данных ввода-вывода:</target>
        </trans-unit>
        <trans-unit id="3166b78eca5a26a7eac84dac5d70e8123ee75f4d" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a codepoint that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">Если вы попытаетесь использовать &lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; для chardata, это приведет к ошибке аргумента. Например, давайте попробуем поместить кодовую точку, которая не может быть представлена ​​одним байтом, например &lt;code&gt;?&amp;pi;&lt;/code&gt; , внутри данных ввода-вывода:</target>
        </trans-unit>
        <trans-unit id="6388f463dc6fcda17ad270beeb69b562f1892d55" translate="yes" xml:space="preserve">
          <source>If you want the task to always be restarted:</source>
          <target state="translated">Если вы хотите,чтобы задание всегда перезапускалось:</target>
        </trans-unit>
        <trans-unit id="2e6f3a865c14b0ab4a00bc5b2ae75499da91323c" translate="yes" xml:space="preserve">
          <source>If you want to capture a function from a module, you can do &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите захватить функцию из модуля, вы можете сделать &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6595a62e94b4f38dca60f0418e3d52b457c3e382" translate="yes" xml:space="preserve">
          <source>If you want to change the &lt;a href=&quot;https://repo.hex.pm&quot;&gt;default mirror&lt;/a&gt; to use for fetching &lt;code&gt;rebar&lt;/code&gt; please set the &lt;code&gt;HEX_MIRROR&lt;/code&gt; environment variable.</source>
          <target state="translated">Если вы хотите изменить &lt;a href=&quot;https://repo.hex.pm&quot;&gt;зеркало&lt;/a&gt; по умолчанию, которое будет использоваться для извлечения &lt;code&gt;rebar&lt;/code&gt; установите переменную среды &lt;code&gt;HEX_MIRROR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a8e46bf39b1daac7b96bda2ca9dc8fc521a77c9" translate="yes" xml:space="preserve">
          <source>If you want to change the &lt;a href=&quot;https://repo.hex.pm&quot;&gt;default mirror&lt;/a&gt; used for fetching Hex, set the &lt;code&gt;HEX_MIRROR&lt;/code&gt; environment variable.</source>
          <target state="translated">Если вы хотите изменить &lt;a href=&quot;https://repo.hex.pm&quot;&gt;зеркало&lt;/a&gt; по умолчанию, используемое для выборки Hex, установите переменную среды &lt;code&gt;HEX_MIRROR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2cc4b639048c80880ba05a591eea3c58b3d29d6" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">Если вы хотите преобразовать строковое число с плавающей запятой непосредственно в число с плавающей запятой, вместо этого можно использовать &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f5f07477ffa4335e8ddfc815683832c8430bb08" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;string#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">Если вы хотите преобразовать строковое значение с плавающей запятой непосредственно в число с плавающей запятой, вместо этого можно использовать &lt;a href=&quot;string#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08564e879edc0764f4906097067da72ec6372ab3" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">Если вы хотите преобразовать целое число в строковом формате напрямую в целое число, вместо него можно использовать &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1f915523fedc99105cfc5944c2a0f3c36308efa" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;string#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">Если вы хотите преобразовать целое число в строковом формате напрямую в целое число, вместо него можно использовать &lt;a href=&quot;string#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;string#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fea9eb1c1234b827775e497ef0f42a61c69dfa13" translate="yes" xml:space="preserve">
          <source>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите скопировать содержимое с устройства ввода-вывода на другое устройство или выполнить прямое копирование из источника в место назначения без сохранения режимов, вместо этого отметьте &lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b19bfe43f6139c3e91cf27f55ce846cdfcd3e3c1" translate="yes" xml:space="preserve">
          <source>If you want to customize formatting through a custom formatter, you can pass a &lt;code&gt;{module, function}&lt;/code&gt; tuple as the &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите настроить форматирование с помощью специального средства форматирования, вы можете передать кортеж &lt;code&gt;{module, function}&lt;/code&gt; в качестве &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65bb6ace50313174bd1da312015129749bbdebb7" translate="yes" xml:space="preserve">
          <source>If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите обозначить, что ключи, которые ранее не были определены в карте, разрешены, обычно завершают тип карты с помощью &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc7ce43a44c457f071e6a594b6c6aad38b49f886" translate="yes" xml:space="preserve">
          <source>If you want to get the current time in Unix seconds, do not do &lt;code&gt;DateTime.utc_now() |&amp;gt; DateTime.to_unix()&lt;/code&gt;. Simply call &lt;code&gt;System.os_time(:second)&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите получить текущее время в секундах Unix, не выполняйте &lt;code&gt;DateTime.utc_now() |&amp;gt; DateTime.to_unix()&lt;/code&gt; . Вместо этого просто вызовите &lt;code&gt;System.os_time(:second)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ffb28d4834a320bc72469ce99b22a133a75bf2e" translate="yes" xml:space="preserve">
          <source>If you want to invoke specific modules and functions in your release, you can do so in two ways: using &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;rpc&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите вызвать определенные модули и функции в своем выпуске, вы можете сделать это двумя способами: используя &lt;code&gt;eval&lt;/code&gt; или &lt;code&gt;rpc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5f2868ad75122ea25c9841323d0bc939ec4c117" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; attribute instead of &lt;code&gt;@type&lt;/code&gt;. The visibility also affects whether or not documentation will be generated by tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/readme.html&quot;&gt;ExDoc&lt;/a&gt;, Elixir&amp;rsquo;s documentation generator.</source>
          <target state="translated">Если вы хотите сохранить частный пользовательский тип, вы можете использовать атрибут &lt;code&gt;@typep&lt;/code&gt; вместо &lt;code&gt;@type&lt;/code&gt; . Видимость также влияет на то, будет ли документация создаваться такими инструментами, как &lt;a href=&quot;https://hexdocs.pm/ex_doc/readme.html&quot;&gt;ExDoc&lt;/a&gt; , генератор документации Elixir.</target>
        </trans-unit>
        <trans-unit id="c535a2a3105fc470fcf848d917b271f0d69918bc" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; directive instead of &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите сохранить частный пользовательский тип, вы можете использовать директиву &lt;code&gt;@typep&lt;/code&gt; вместо &lt;code&gt;@type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcbbba3c1ea50cbcd365e262b9d60f2feb2c65ed" translate="yes" xml:space="preserve">
          <source>If you want to keep any two tests separate, add an empty line between them:</source>
          <target state="translated">Если вы хотите,чтобы любые два теста были разделены,добавьте между ними пустую строку:</target>
        </trans-unit>
        <trans-unit id="6270ce3f8ed8957cf75b8c1784c6e548f99f8963" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%255E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">Если вы хотите сопоставить шаблон с существующей переменной, вам необходимо использовать оператор &lt;a href=&quot;#%255E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c8e1b5f66c0b107ff181c4a336661c05c7509728" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%5E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">Если вы хотите сопоставить шаблон с существующей переменной, вам необходимо использовать оператор &lt;a href=&quot;#%5E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0120649e8c4e2ba95fe6dca09a77ff652ec92d44" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="translated">Если вы хотите сопоставить шаблон с существующей переменной, вам нужно использовать оператор &lt;code&gt;^&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8611f45920c0ede3319c28e69a832c8f54905818" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;float#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить операцию ceil с другими десятичными &lt;a href=&quot;float#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; &lt;/a&gt; , используйте вместо этого Float.ceil / 2 .</target>
        </trans-unit>
        <trans-unit id="006d429609c2e4b18605e6317262f44f76104754" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить операцию ceil с другими десятичными &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; &lt;/a&gt; , используйте вместо этого Float.ceil / 2 .</target>
        </trans-unit>
        <trans-unit id="f71b7086446556c1e0c878a9ce96ae97c6d27fc0" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;float#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить операцию пола с другими десятичными знаками, используйте вместо этого &lt;a href=&quot;float#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da1610c8254e7b523adf724249920d8824d70e09" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить операцию пола с другими десятичными знаками, используйте вместо этого &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6176e9f771080616be12747b7598ac40675af864" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить целочисленное деление по &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; &lt;/a&gt; (округление в сторону отрицательной бесконечности), используйте вместо этого Integer.floor_div / 2 .</target>
        </trans-unit>
        <trans-unit id="e7d23f8f45e8ee5b1da8fce75c5c1d7be726d5c9" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;integer#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить целочисленное деление по &lt;a href=&quot;integer#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; &lt;/a&gt; (округление в сторону отрицательной бесконечности), используйте вместо этого Integer.floor_div / 2 .</target>
        </trans-unit>
        <trans-unit id="ea950ebad1bc7656ae137230492317baa7c6a6f0" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить усеченное целочисленное деление (округление до нуля), используйте вместо него &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d5cba5ee293ef2a94c294f0400855682db25758" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите выполнить усеченное целочисленное деление (округление до нуля), используйте вместо него &lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="097c0e312bb8668d5ea944da5700770a1becb6c4" translate="yes" xml:space="preserve">
          <source>If you want to purge all log calls from an application named &lt;code&gt;:foo&lt;/code&gt; and only keep errors from &lt;code&gt;Bar.foo/3&lt;/code&gt;, you can set up two different matches:</source>
          <target state="translated">Если вы хотите очистить все вызовы журнала из приложения с именем &lt;code&gt;:foo&lt;/code&gt; и сохранить только ошибки из &lt;code&gt;Bar.foo/3&lt;/code&gt; , вы можете настроить два разных совпадения:</target>
        </trans-unit>
        <trans-unit id="1d73b5161b517adda283c3e0c50a4ecfba748837" translate="yes" xml:space="preserve">
          <source>If you want to recompile an existing module, check &lt;a href=&quot;#r/1&quot;&gt;&lt;code&gt;r/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите перекомпилировать существующий модуль, проверьте вместо этого &lt;a href=&quot;#r/1&quot;&gt; &lt;code&gt;r/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1770175208fe6cb10e9c451baa7570e45537e962" translate="yes" xml:space="preserve">
          <source>If you want to reload a single module, consider using &lt;code&gt;r(ModuleName)&lt;/code&gt; instead.</source>
          <target state="translated">Если вы хотите перезагрузить один модуль, рассмотрите возможность использования вместо этого &lt;code&gt;r(ModuleName)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22937dca14ad8e678a5773e217bdaf60e9e08640" translate="yes" xml:space="preserve">
          <source>If you want to remove all duplicated elements, regardless of order, see &lt;a href=&quot;#uniq/1&quot;&gt;&lt;code&gt;uniq/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите удалить все повторяющиеся элементы, независимо от порядка, см. &lt;a href=&quot;#uniq/1&quot;&gt; &lt;code&gt;uniq/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ac9b92a3ff486c5ca2aa293f505af60c2ce005a" translate="yes" xml:space="preserve">
          <source>If you want to run tests manually, you can set the &lt;code&gt;:autorun&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; and use &lt;a href=&quot;#run/0&quot;&gt;&lt;code&gt;run/0&lt;/code&gt;&lt;/a&gt; to run tests.</source>
          <target state="translated">Если вы хотите запускать тесты вручную, вы можете установить для параметра &lt;code&gt;:autorun&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; и использовать &lt;a href=&quot;#run/0&quot;&gt; &lt;code&gt;run/0&lt;/code&gt; &lt;/a&gt; для запуска тестов.</target>
        </trans-unit>
        <trans-unit id="d9cfb2104d8a7fbed8970b4e565fd893c81bbbd7" translate="yes" xml:space="preserve">
          <source>If you want to search for both &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, you could do:</source>
          <target state="translated">Если вы хотите искать файлы &lt;code&gt;.beam&lt;/code&gt; и &lt;code&gt;.app&lt;/code&gt; , вы можете сделать:</target>
        </trans-unit>
        <trans-unit id="e842c7452c7ee7f8cc32ceae58854550ca1826ee" translate="yes" xml:space="preserve">
          <source>If you want to specify extra overlay directories, you can do so with the &lt;code&gt;:overlays&lt;/code&gt; option. If you need to copy files dynamically, see the &quot;Steps&quot; section.</source>
          <target state="translated">Если вы хотите указать дополнительные каталоги наложения, вы можете сделать это с помощью параметра &lt;code&gt;:overlays&lt;/code&gt; . Если вам нужно динамически копировать файлы, см. Раздел &amp;laquo;Действия&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e20d3f7642e2bc2878445510d6350ffeaed9f321" translate="yes" xml:space="preserve">
          <source>If you want to specify more than one variable, you separate them by a comma.</source>
          <target state="translated">Если вы хотите указать более одной переменной,вы разделяете их запятой.</target>
        </trans-unit>
        <trans-unit id="982a9cb228f92f03ac85417af3f281e259a660c2" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">Если вы хотите отменить кавычки для значения, которое не является выражением в кавычках, например map, вам нужно вызвать &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; перед:</target>
        </trans-unit>
        <trans-unit id="1680d4186a75a98ad990b5523a395b408476ac2a" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">Если вы хотите отменить кавычки для значения, которое не является выражением в кавычках, например map, вам нужно вызвать &lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; перед:</target>
        </trans-unit>
        <trans-unit id="bc958b979665c9c17d7950e0854fbc66f8ee61bb" translate="yes" xml:space="preserve">
          <source>If you were to perform a hot code upgrade in such an application, it would crash, because in the initial version the state was just a counter but in the new version the state is a tuple. Furthermore, you changed the format of the &lt;code&gt;call&lt;/code&gt; message from &lt;code&gt;:bump&lt;/code&gt; to &lt;code&gt;{:bump, by}&lt;/code&gt; and the process may have both old and new messages temporarily mixed, so we need to handle both. The final version would be:</source>
          <target state="translated">Если бы вы выполнили горячее обновление кода в таком приложении, оно бы вылетело из строя, потому что в начальной версии состояние было просто счетчиком, а в новой версии состоянием является кортеж. Кроме того, вы изменили формат сообщения &lt;code&gt;call&lt;/code&gt; с &lt;code&gt;:bump&lt;/code&gt; на &lt;code&gt;{:bump, by}&lt;/code&gt; и процесс может временно смешивать как старые, так и новые сообщения, поэтому нам нужно обрабатывать оба. Окончательная версия будет такой:</target>
        </trans-unit>
        <trans-unit id="b27dac4f0c111d42a9f9a5c0743a540f0cc92e81" translate="yes" xml:space="preserve">
          <source>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</source>
          <target state="translated">Если вы хотите узнать больше о серверах GenServers,руководство по началу работы с Elixir представляет собой учебное пособие,похожее на введение.Документация и ссылки в Erlang также могут дать дополнительную информацию.</target>
        </trans-unit>
        <trans-unit id="b974f9968697c318d27fe1bd482bc9d5a128ec60" translate="yes" xml:space="preserve">
          <source>If you wish to inspect the code points in a single-quoted literal, you can force this by passing the &lt;code&gt;charlists&lt;/code&gt; option to &lt;code&gt;IO.inspect/2&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите проверить кодовые точки в &lt;code&gt;charlists&lt;/code&gt; заключенном в одинарные кавычки, вы можете заставить это сделать это, передав параметр charlists в &lt;code&gt;IO.inspect/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="416d7a121c99b25e16e84560ead7cb67296777e6" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите использовать другое значение для аккумулятора, используйте &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d47bd8dadb23934d4b2666cf77ccc81ac30266c" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите использовать другое значение для аккумулятора, используйте &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0943f45dd0efc661e7f07bd6255b9ee24dc17524" translate="yes" xml:space="preserve">
          <source>If you would like to get the result of evaluating file rather than the modules defined in it, see &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите получить результат оценки файла, а не модулей, определенных в нем, см. &lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe37a76c869eaf7d64eb125b004dacbfd79cc33b" translate="yes" xml:space="preserve">
          <source>If you would rather enable it on your system as a whole, you can use the &lt;code&gt;ERL_AFLAGS&lt;/code&gt; environment variable and make sure that it is set accordingly on your terminal/shell configuration.</source>
          <target state="translated">Если вы предпочитаете включить его в своей системе в целом, вы можете использовать &lt;code&gt;ERL_AFLAGS&lt;/code&gt; среды ERL_AFLAGS и убедиться, что она установлена ​​соответствующим образом в конфигурации вашего терминала / оболочки.</target>
        </trans-unit>
        <trans-unit id="31456477d49264f6615f64085ad9c83e259679bd" translate="yes" xml:space="preserve">
          <source>If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control.</source>
          <target state="translated">Если ваш Git-репозиторий требует аутентификации,например,базовой HTTP-аутентификации по имени пользователя:паролю через URL,это может быть достигнуто с помощью Git-конфигурации,сохраняя правила доступа вне контроля источника.</target>
        </trans-unit>
        <trans-unit id="c5250542055685fe9ce8faf48f1dcf6cf349fd3b" translate="yes" xml:space="preserve">
          <source>If your application does not have a supervision tree, one can be added by changing &lt;code&gt;def application&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt; to include a &lt;code&gt;:mod&lt;/code&gt; key with the application callback name:</source>
          <target state="translated">Если ваше приложение не имеет дерева контроля, его можно добавить, изменив &lt;code&gt;def application&lt;/code&gt; внутри &lt;code&gt;mix.exs&lt;/code&gt; , включив ключ &lt;code&gt;:mod&lt;/code&gt; с именем обратного вызова приложения:</target>
        </trans-unit>
        <trans-unit id="79acd423fb1e6c91580bcc6a424e71a397cbe715" translate="yes" xml:space="preserve">
          <source>If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; to get the options that were passed.</source>
          <target state="translated">Если ваша реализация передает параметры или если вы генерируете собственный код на основе структуры, вам также потребуется реализовать макрос, определенный как &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; чтобы получить переданные параметры.</target>
        </trans-unit>
        <trans-unit id="1087391025d5c5314dde0fa06b5f87e55efb46aa" translate="yes" xml:space="preserve">
          <source>If your use case requires exactly what GenEvent provided, or you have to integrate with an existing &lt;code&gt;:gen_event&lt;/code&gt;-based system, you can still use the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; Erlang module.</source>
          <target state="translated">Если для вашего варианта использования требуется именно то, что предоставлено GenEvent, или вам необходимо выполнить интеграцию с существующей &lt;code&gt;:gen_event&lt;/code&gt; основе : gen_event , вы все равно можете использовать модуль &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; Erlang.</target>
        </trans-unit>
        <trans-unit id="6ef21699df7b35a736d32d74888718170a41c693" translate="yes" xml:space="preserve">
          <source>If, for some reason, the current working directory cannot be retrieved, this function returns the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Если по какой-либо причине текущий рабочий каталог не может быть получен, эта функция возвращает заданный &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3de6ae0bb7f57a373dcca73d61975801fe3edfc" translate="yes" xml:space="preserve">
          <source>If, for some reason, you must read the application environment at compile time, use &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/2&quot;&gt;&lt;code&gt;Application.compile_env/2&lt;/code&gt;&lt;/a&gt;. Read &lt;a href=&quot;application#module-compile-time-environment&quot;&gt;the &quot;Compile-time environment&quot; section of the Application docs&lt;/a&gt; for more information.</source>
          <target state="translated">Если по какой-то причине вам необходимо прочитать среду приложения во время компиляции, используйте &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/2&quot;&gt; &lt;code&gt;Application.compile_env/2&lt;/code&gt; &lt;/a&gt; . Прочтите &lt;a href=&quot;application#module-compile-time-environment&quot;&gt;раздел &amp;laquo;Среда времени компиляции&amp;raquo; документации&lt;/a&gt; по приложению для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7f29cc51be005a79b079e12bf1ac5f22f7d2dcb7" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at midnight, return {0, 1}.</source>
          <target state="translated">Если в вашем Календаре новый день начинается в полночь,вернитесь {0,1}.</target>
        </trans-unit>
        <trans-unit id="41c5fa5884384a5740f83d50fb3866ac1d3665b0" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at noon, return {1, 2}.</source>
          <target state="translated">Если в вашем Календаре новый день начинается в полдень,вернитесь {1,2}.</target>
        </trans-unit>
        <trans-unit id="8f85da886f46e171f187e86eea72582fd0f8930c" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</source>
          <target state="translated">Если в вашем Календаре новый день начинается с восхода солнца,вернитесь {1,4}.</target>
        </trans-unit>
        <trans-unit id="0d2c4953da7d60583c85fece795d7ebe8ed34cb1" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunset, return {3, 4}.</source>
          <target state="translated">Если в вашем Календаре новый день начинается на закате,вернитесь {3,4}.</target>
        </trans-unit>
        <trans-unit id="10cb7a9f4dc8fd31623acf09d7d8af1483fab624" translate="yes" xml:space="preserve">
          <source>If, later, the &lt;code&gt;Bar&lt;/code&gt; module is moved outside the &lt;code&gt;Foo&lt;/code&gt; module definition, it must be referenced by its full name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias must be set using the &lt;code&gt;alias&lt;/code&gt; directive discussed above.</source>
          <target state="translated">Если позже модуль &lt;code&gt;Bar&lt;/code&gt; перемещается за пределы определения модуля &lt;code&gt;Foo&lt;/code&gt; , на него следует ссылаться по его полному имени ( &lt;code&gt;Foo.Bar&lt;/code&gt; ) или должен быть установлен &lt;code&gt;alias&lt;/code&gt; директивы alias, описанной выше.</target>
        </trans-unit>
        <trans-unit id="5aadcd56db1850d0771fc6771663e100003c9ea8" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">Если во время выполнения кода системные часы изменяются, некоторый код, который выполняется за 1 секунду, может быть зарегистрирован как занимающий более 1 часа! Чтобы решить такие проблемы, виртуальная машина предоставляет монотонное время через &lt;a href=&quot;#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; ,&lt;/a&gt; которое никогда не уменьшается и не перескакивает:</target>
        </trans-unit>
        <trans-unit id="d7beb7df4077fd4d4544fa6a837476c871ba893d" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;system#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">Если во время выполнения кода системные часы изменяются, некоторый код, который выполняется за 1 секунду, может быть зарегистрирован как занимающий более 1 часа! Чтобы решить такие проблемы, виртуальная машина предоставляет монотонное время через &lt;a href=&quot;system#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; ,&lt;/a&gt; которое никогда не уменьшается и не перескакивает:</target>
        </trans-unit>
        <trans-unit id="acce89fb4ebef796946f7cb6a71ce1c0793fa8d9" translate="yes" xml:space="preserve">
          <source>Image: negative. Swap foreground and background.</source>
          <target state="translated">Изображение:отрицательное.Смена переднего плана и фона.</target>
        </trans-unit>
        <trans-unit id="2554c2edabb99cac5d1195a237820679f650e785" translate="yes" xml:space="preserve">
          <source>Image: positive. Normal foreground and background.</source>
          <target state="translated">Изображение:положительное.Нормальный передний план и фон.</target>
        </trans-unit>
        <trans-unit id="b4974ec0729731cbfc104f4eeb6f171651724046" translate="yes" xml:space="preserve">
          <source>Imagine a module uses a specialized list implemented in &lt;code&gt;Math.List&lt;/code&gt;. The &lt;code&gt;alias&lt;/code&gt; directive allows referring to &lt;code&gt;Math.List&lt;/code&gt; just as &lt;code&gt;List&lt;/code&gt; within the module definition:</source>
          <target state="translated">Представьте, что модуль использует специальный список, реализованный в &lt;code&gt;Math.List&lt;/code&gt; . &lt;code&gt;alias&lt;/code&gt; директива позволяет отнести к &lt;code&gt;Math.List&lt;/code&gt; так же , как &lt;code&gt;List&lt;/code&gt; в определении модуля:</target>
        </trans-unit>
        <trans-unit id="0c6d0807e9d9e68c71a2dfa2e6c744532d48a480" translate="yes" xml:space="preserve">
          <source>Imagine someone implements &lt;code&gt;Calendar.Holocene&lt;/code&gt;, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</source>
          <target state="translated">Представьте, что кто-то реализует &lt;code&gt;Calendar.Holocene&lt;/code&gt; , календарь, основанный на григорианском календаре, который добавляет ровно 10 000 лет к текущему григорианскому году:</target>
        </trans-unit>
        <trans-unit id="ae47eabc88af2ef4455eb932e8ea60f7ae332748" translate="yes" xml:space="preserve">
          <source>Imagine the given &quot;old&quot; code:</source>
          <target state="translated">Представьте себе этот &quot;старый&quot; код:</target>
        </trans-unit>
        <trans-unit id="52ac66ba0efe559bd54e9f534310fa769ff5fac4" translate="yes" xml:space="preserve">
          <source>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</source>
          <target state="translated">Представьте себе ситуацию,когда у вас есть цитируемое выражение,и вы хотите вставить его в какую-нибудь цитату.Первой попыткой будет:</target>
        </trans-unit>
        <trans-unit id="f60dc9c31d90f01f4ada0187787c8518ff7e6336" translate="yes" xml:space="preserve">
          <source>Imagine you have a directory called &lt;code&gt;projects&lt;/code&gt; with three Elixir projects inside of it: &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ex_doc&lt;/code&gt;, and &lt;code&gt;plug&lt;/code&gt;. You can find all &lt;code&gt;.beam&lt;/code&gt; files inside the &lt;code&gt;ebin&lt;/code&gt; directory of each project as follows:</source>
          <target state="translated">Представьте , у вас есть каталог под названием &lt;code&gt;projects&lt;/code&gt; с тремя проектами Эликсира внутри него: &lt;code&gt;elixir&lt;/code&gt; , &lt;code&gt;ex_doc&lt;/code&gt; и &lt;code&gt;plug&lt;/code&gt; . Вы можете найти все &lt;code&gt;.beam&lt;/code&gt; файлы внутри &lt;code&gt;ebin&lt;/code&gt; директории каждого проекта следующим образом :</target>
        </trans-unit>
        <trans-unit id="bbd38c599b5ec1ff1edb2d327d81cfb6d57d0ae9" translate="yes" xml:space="preserve">
          <source>Imagine you have a map that contains a MapSet and is printed as:</source>
          <target state="translated">Представьте,что у вас есть карта,которая содержит MapSet и печатается как:</target>
        </trans-unit>
        <trans-unit id="78e853aca214a1bc65ac8ef6110f03573d680e17" translate="yes" xml:space="preserve">
          <source>Imagine you have the following structure:</source>
          <target state="translated">Представьте,что у вас следующая структура:</target>
        </trans-unit>
        <trans-unit id="e874a03e71d708ca4e25914c4864e7d0682296da" translate="yes" xml:space="preserve">
          <source>Immediately halts the Erlang runtime system.</source>
          <target state="translated">Немедленно останавливает работу системы Erlang.</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="1ef5a932d18820b4b0e243f0726d914bc0a7ff10" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">Реализация &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5796eba4ad579f1726f97515a9ac4256c827ceb8" translate="yes" xml:space="preserve">
          <source>Implementing behaviours</source>
          <target state="translated">Внедрение моделей поведения</target>
        </trans-unit>
        <trans-unit id="4d98cf2da4c3ebd35020a6022935dad49c5720d8" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реализация таких функций, как &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; &lt;/a&gt; и другие, является хорошим упражнением для понимания мощи &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; . Если операция не может быть выражена ни одной из функций в модуле &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , разработчики, скорее всего, прибегнут к &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b465297e29160eecd675375f9f56fd85c2f30272" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реализация таких функций, как &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; &lt;/a&gt; и другие, - хорошее упражнение для понимания мощи &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; . Когда операция не может быть выражена ни одной из функций в модуле &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , разработчики, скорее всего, прибегнут к &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3e95d8cf32f54c45a81b4f1a57f15494498570" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">Явная реализация поведения без вызова &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt; (v1.0)</target>
        </trans-unit>
        <trans-unit id="a11cbfe39e0739e620b6472396d552890b65f2b5" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">Явная реализация поведения без вызова &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt; (v1.0)</target>
        </trans-unit>
        <trans-unit id="6ee8b57e8a1146e8195323d5ab0ac1b28d4bf4d5" translate="yes" xml:space="preserve">
          <source>Important: do &lt;strong&gt;not&lt;/strong&gt; use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.</source>
          <target state="translated">Важно: &lt;strong&gt;не&lt;/strong&gt; используйте эту функцию на устройствах ввода-вывода в режиме Unicode, так как она будет записывать неверные данные. В частности, стандартное устройство ввода-вывода по умолчанию настроено на Unicode, поэтому запись в stdio с помощью этой функции, скорее всего, приведет к отправке неправильных данных по сети.</target>
        </trans-unit>
        <trans-unit id="bdee98dcb44004b1533b9be7b352b94b0439a6f5" translate="yes" xml:space="preserve">
          <source>Importing dependencies configuration</source>
          <target state="translated">Конфигурация импортируемых зависимостей</target>
        </trans-unit>
        <trans-unit id="3e99e591c470385409fd87d84f7ea0fdc9e8826b" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file or files.</source>
          <target state="translated">Импортирует конфигурацию из данного файла или файлов.</target>
        </trans-unit>
        <trans-unit id="5ee893c3406c5d187c4ad8d2a37d2b2305b2b378" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file.</source>
          <target state="translated">Импортирует конфигурацию из данного файла.</target>
        </trans-unit>
        <trans-unit id="82d4e22f3ba03649c647ac0cbd6a6f1c75820475" translate="yes" xml:space="preserve">
          <source>Imports functions and macros from other modules.</source>
          <target state="translated">Импорт функций и макросов из других модулей.</target>
        </trans-unit>
        <trans-unit id="bb0b9afcb24ddc9f67176eeec399cead058aa4a9" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">Импорт: новые функции могут быть добавлены в модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; , который импортируется автоматически. Они могут конфликтовать с локальными функциями, определенными в ваших модулях. Конфликты могут быть разрешены обратно совместимым способом с использованием &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; со списком всех функций, которые вы не хотите импортировать из &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; . Мы оставляем за собой право вносить такие дополнения.</target>
        </trans-unit>
        <trans-unit id="ce9dd8afb038714101f1fa2419f409800104c52e" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">Импорт: новые функции могут быть добавлены в модуль &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; , который импортируется автоматически. Они могут конфликтовать с локальными функциями, определенными в ваших модулях. Коллизии могут быть разрешены обратно совместимым способом с использованием &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; со списком всех функций, которые вы не хотите импортировать из &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; . Мы оставляем за собой право вносить такие дополнения.</target>
        </trans-unit>
        <trans-unit id="6e98571e8ce38e7d695efe3ecee0b6e80bc755f3" translate="yes" xml:space="preserve">
          <source>Improper lists are never deemed as charlists.</source>
          <target state="translated">Неправильные списки никогда не считаются чарлистами.</target>
        </trans-unit>
        <trans-unit id="fee52b5aef3534510640142b73884d80c6b12f47" translate="yes" xml:space="preserve">
          <source>Improper lists are not printable, even if made only of ASCII characters:</source>
          <target state="translated">Неправильные списки не печатаются,даже если они сделаны только из ASCII-символов:</target>
        </trans-unit>
        <trans-unit id="1651a35afb019627c0965d85cc4992b58cfbc54d" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned a little bit about strings and we used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">В &lt;code&gt;is_binary/1&lt;/code&gt; &amp;laquo;Основные типы&amp;raquo; мы немного узнали о строках и использовали функцию is_binary / 1 для проверок:</target>
        </trans-unit>
        <trans-unit id="c0d4390b7f52bc3219b6b297954aa2698cd9b21f" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned about strings and used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">В &amp;laquo;Базовых типах&amp;raquo; мы узнали о строках и использовали &lt;code&gt;is_binary/1&lt;/code&gt; для проверки:</target>
        </trans-unit>
        <trans-unit id="96d506b973cc16f3c887c604680a4f164c5bcb6d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;keywords-and-maps&quot;&gt;chapter 7&lt;/a&gt; we learned about maps:</source>
          <target state="translated">В &lt;a href=&quot;keywords-and-maps&quot;&gt;главе 7&lt;/a&gt; мы узнали о картах:</target>
        </trans-unit>
        <trans-unit id="b97f6da29f9d3821af09c9644f82422d41ba54db" translate="yes" xml:space="preserve">
          <source>In Elixir we group several functions into modules. We&amp;rsquo;ve already used many different modules in the previous chapters such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">В Elixir мы группируем несколько функций в модули. Мы уже использовали множество различных модулей в предыдущих главах , такие как &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;в &lt;code&gt;String&lt;/code&gt; модуле&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f34428000982ff1805aac800f0ebed47748f3ab4" translate="yes" xml:space="preserve">
          <source>In Elixir you can use a &lt;code&gt;?&lt;/code&gt; in front of a character literal to reveal its code point:</source>
          <target state="translated">В Эликсире можно использовать &lt;code&gt;?&lt;/code&gt; перед символьным литералом, чтобы показать его кодовую точку:</target>
        </trans-unit>
        <trans-unit id="8852e2c2070399b66b8e6aac0c4ebb222e49ff1d" translate="yes" xml:space="preserve">
          <source>In Elixir, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; is defined as a macro so that it can be used as a guard. This means that, in order to invoke &lt;code&gt;Integer.is_odd/1&lt;/code&gt;, we need to first require the &lt;code&gt;Integer&lt;/code&gt; module.</source>
          <target state="translated">В Elixir &lt;code&gt;Integer.is_odd/1&lt;/code&gt; определен как макрос, поэтому его можно использовать в качестве защиты. Это означает, что для вызова &lt;code&gt;Integer.is_odd/1&lt;/code&gt; нам нужно сначала потребовать модуль &lt;code&gt;Integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84a15dcd0ed954400244a91382ebe28f35c7326d" translate="yes" xml:space="preserve">
          <source>In Elixir, a value can be thrown and later be caught. &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are reserved for situations where it is not possible to retrieve a value unless by using &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">В Elixir значение может быть выброшено, а затем обнаружено. &lt;code&gt;throw&lt;/code&gt; и &lt;code&gt;catch&lt;/code&gt; зарезервированы для ситуаций, когда невозможно получить значение, если не используются &lt;code&gt;throw&lt;/code&gt; и &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f7dc2374bd2e474c5f95f1dc00588968670f4e9" translate="yes" xml:space="preserve">
          <source>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</source>
          <target state="translated">В Эликсире весь код запускается внутри процессов.Процессы изолированы друг от друга,выполняются параллельно друг другу и общаются посредством передачи сообщений.Процессы являются не только основой для параллельности в Elixir,но и предоставляют средства для построения распределенных и отказоустойчивых программ.</target>
        </trans-unit>
        <trans-unit id="fcd7da208c379530ff673f8c5363361cec7ce112" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">В Elixir перечисляемым является любой тип данных, реализующий протокол &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;[1, 2, 3]&lt;/code&gt; ), &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ) и &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;1..3&lt;/code&gt; ) являются общими типами данных, используемыми в качестве перечислимых:</target>
        </trans-unit>
        <trans-unit id="a207968d5a8dba5d6352c7b46008a0e1ddc8ec1d" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">В Elixir перечисляемым является любой тип данных, реализующий протокол &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;[1, 2, 3]&lt;/code&gt; ), &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ) и &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;1..3&lt;/code&gt; ) являются общими типами данных, используемыми в качестве перечислимых:</target>
        </trans-unit>
        <trans-unit id="ad60a1595fcaea2abc6cfb534bb59968e6aa0a7d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В Elixir организация кода осуществляется модулями и функциями, в процессах нет необходимости. Например, представьте, что вы реализуете калькулятор и решаете поместить все операции калькулятора за &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7900ac30a1169c9e2266c3344cde6f7b66b7bf2b" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В Elixir организация кода осуществляется модулями и функциями, в процессах нет необходимости. Например, представьте, что вы реализуете калькулятор и решаете поместить все операции калькулятора за &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="aa0691e43ac9902c05a55318172be1be3b51602d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</source>
          <target state="translated">В Elixir организация кода осуществляется модулями и функциями,процессы не нужны.Например,представьте,что вы внедряете калькулятор,и вы решили поместить все операции калькулятора за GenServer:</target>
        </trans-unit>
        <trans-unit id="1a65801df985cbe3e3c9ee19ff7e4341c68a0a15" translate="yes" xml:space="preserve">
          <source>In Elixir, different data types can be compared using comparison operators:</source>
          <target state="translated">В Elixir можно сравнивать различные типы данных с помощью операторов сравнения:</target>
        </trans-unit>
        <trans-unit id="3ef291ece743ba126271fab00a84b2bf1cd10359" translate="yes" xml:space="preserve">
          <source>In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the &lt;code&gt;for&lt;/code&gt; special form.</source>
          <target state="translated">В Elixir обычно перебирают Enumerable, часто отфильтровывая некоторые результаты и отображая значения в другой список. Постижения являются синтаксическим сахаром для таких конструкций: они групповые эти общие задачи в &lt;code&gt;for&lt;/code&gt; специальной формы.</target>
        </trans-unit>
        <trans-unit id="92fa98b368b718157a766ec2a187b1b728ee06ed" translate="yes" xml:space="preserve">
          <source>In Elixir, records are used mostly in two situations:</source>
          <target state="translated">В Эликсире записи используются в основном в двух ситуациях:</target>
        </trans-unit>
        <trans-unit id="19e018a4aa4ddd6ea9b4d083bf7991661ac6f619" translate="yes" xml:space="preserve">
          <source>In Elixir, the &lt;code&gt;=&lt;/code&gt; operator is actually called &lt;em&gt;the match operator&lt;/em&gt;. Let&amp;rsquo;s see why:</source>
          <target state="translated">В Elixir оператор &lt;code&gt;=&lt;/code&gt; фактически называется &lt;em&gt;оператором сопоставления&lt;/em&gt; . Посмотрим, почему:</target>
        </trans-unit>
        <trans-unit id="482c60a7cfc2af43cfa398215016e9bcabca31ff" translate="yes" xml:space="preserve">
          <source>In Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life-cycle of any supervised processes, including startup and shutdown.</source>
          <target state="translated">В Эликсире это делает супервайзер.Супервайзер-это процесс,который контролирует другие процессы и перезапускает их всякий раз,когда они аварийно завершаются.Для этого супервайзеры управляют всем жизненным циклом любых контролируемых процессов,включая запуск и выключение.</target>
        </trans-unit>
        <trans-unit id="c6d542894f9023e77ee4252a95cfc7fdde16bf1f" translate="yes" xml:space="preserve">
          <source>In Elixir, we avoid using &lt;code&gt;try/rescue&lt;/code&gt; because &lt;strong&gt;we don&amp;rsquo;t use errors for control flow&lt;/strong&gt;. We take errors literally: they are reserved for unexpected and/or exceptional situations. In case you actually need flow control constructs, &lt;em&gt;throws&lt;/em&gt; should be used. That&amp;rsquo;s what we are going to see next.</source>
          <target state="translated">В Elixir мы избегаем использования &lt;code&gt;try/rescue&lt;/code&gt; , потому что &lt;strong&gt;мы не используем ошибки для потока управления&lt;/strong&gt; . Мы воспринимаем ошибки буквально: они предназначены для непредвиденных и / или исключительных ситуаций. Если вам действительно нужны конструкции управления потоком, следует использовать &lt;em&gt;броски&lt;/em&gt; . Вот что мы увидим дальше.</target>
        </trans-unit>
        <trans-unit id="b26350d75961840721899e4e896ada8152ee4ff0" translate="yes" xml:space="preserve">
          <source>In Elixir, we can compare two different data types:</source>
          <target state="translated">В Эликсире мы можем сравнить два разных типа данных:</target>
        </trans-unit>
        <trans-unit id="99415fb48cc7bcce7ee941711b73cb718fae4683" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two idioms for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is pre-computed in the data structure.</source>
          <target state="translated">В Elixir у нас есть две идиомы для проверки количества элементов в структуре данных: &lt;code&gt;length&lt;/code&gt; и &lt;code&gt;size&lt;/code&gt; . &lt;code&gt;length&lt;/code&gt; означает, что информация должна быть вычислена. Например, &lt;code&gt;length(list)&lt;/code&gt; должен пройти по всему списку, чтобы вычислить его длину. С другой стороны, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; и &lt;code&gt;byte_size(binary)&lt;/code&gt; не зависят от кортежа и двоичного размера, поскольку информация о размере предварительно вычисляется в структуре данных.</target>
        </trans-unit>
        <trans-unit id="f3be4753dceb5fddab1fdca38953766786eecc42" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two main associative data structures: keyword lists and maps. It&amp;rsquo;s time to learn more about them!</source>
          <target state="translated">В Elixir у нас есть две основные ассоциативные структуры данных: списки ключевых слов и карты. Пора узнать о них больше!</target>
        </trans-unit>
        <trans-unit id="6cb8d41ba02e8fc631535705b4f2e08988507e70" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two verbs for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is precomputed in the data structure.</source>
          <target state="translated">В Elixir есть два глагола для проверки количества элементов в структуре данных: &lt;code&gt;length&lt;/code&gt; и &lt;code&gt;size&lt;/code&gt; . &lt;code&gt;length&lt;/code&gt; означает, что информация должна быть вычислена. Например, &lt;code&gt;length(list)&lt;/code&gt; должен пройти по всему списку, чтобы вычислить его длину. С другой стороны, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; и &lt;code&gt;byte_size(binary)&lt;/code&gt; не зависят от кортежа и двоичного размера, поскольку информация о размере предварительно вычисляется в структуре данных.</target>
        </trans-unit>
        <trans-unit id="3e9adf90c14fca15cafcd8d80e7a0e62f3c9bd2b" translate="yes" xml:space="preserve">
          <source>In Elixir, you can define a binary using &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">В Elixir вы можете определить двоичный файл, используя &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3508879bcb04190c581cc69dedcf57a9400be46d" translate="yes" xml:space="preserve">
          <source>In Erlang, this struct is represented by a &lt;code&gt;:file_info&lt;/code&gt; record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</source>
          <target state="translated">В Erlang эта структура представлена записью &lt;code&gt;:file_info&lt;/code&gt; . Поэтому этот модуль также предоставляет функции для преобразования между записью Erlang и структурой Elixir.</target>
        </trans-unit>
        <trans-unit id="19ae95f1d5cbc8f9036da514524bab95b3e8521e" translate="yes" xml:space="preserve">
          <source>In Mix projects this function returns the environment this configuration file is executed on. In releases, the environment when &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; ran.</source>
          <target state="translated">В проектах Mix эта функция возвращает среду, в которой выполняется этот файл конфигурации. В выпусках среда при &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; запускалась.</target>
        </trans-unit>
        <trans-unit id="e341b5436849e02ad44c7ab5cb526b1b7ab5e415" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. For example, someone using your application can override its &lt;code&gt;:db_host&lt;/code&gt; environment variable as follows:</source>
          <target state="translated">В проектах Mix среда приложения и его зависимости могут быть переопределены с помощью файла &lt;code&gt;config/config.exs&lt;/code&gt; . Например, кто-то, использующий ваше приложение, может переопределить его &lt;code&gt;:db_host&lt;/code&gt; среды : db_host следующим образом:</target>
        </trans-unit>
        <trans-unit id="08902136d46a0efffdb0a07180738ce463f3cf44" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</source>
          <target state="translated">В проектах Mix среда приложения и его зависимости могут быть переопределены с помощью файла &lt;code&gt;config/config.exs&lt;/code&gt; . Если вы запускаете приложение с помощью Mix, эта конфигурация доступна во время компиляции и во время выполнения, но примите во внимание, что она не включена в сгенерированный файл ресурсов приложения и недоступна, если вы запускаете приложение без Mix.</target>
        </trans-unit>
        <trans-unit id="9174170a472a8f04a70eb2658745c2e8ceaf3c42" translate="yes" xml:space="preserve">
          <source>In Unix-like systems, changing the modification time may require you to be either &lt;code&gt;root&lt;/code&gt; or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with &lt;code&gt;{:error, :eperm}&lt;/code&gt;.</source>
          <target state="translated">В Unix-подобных системах для изменения времени модификации может потребоваться, чтобы вы были либо пользователем &lt;code&gt;root&lt;/code&gt; , либо владельцем файла. Доступа на запись может быть недостаточно. В этих случаях прикосновение к файлу в первый раз (для его создания) будет успешным, но касание существующего файла с ошибкой с &lt;code&gt;{:error, :eperm}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de5ec7fc6835af5a7c8c3ee0628180b848d8db4" translate="yes" xml:space="preserve">
          <source>In a GenServer, the code above would be two separate functions, roughly like this:</source>
          <target state="translated">В GenServer вышеприведенный код был бы двумя отдельными функциями,примерно так:</target>
        </trans-unit>
        <trans-unit id="bcadbac52f644d8178e01dd98a388d6072c88e19" translate="yes" xml:space="preserve">
          <source>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</source>
          <target state="translated">В распределенной установке с несколькими узлами API,принимающий анонимные функции,работает только в том случае,если вызывающий абонент (клиент)и агент имеют одну и ту же версию модуля вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="0fe49527fc564fb18ae1d9b47c99a05222fe3f97" translate="yes" xml:space="preserve">
          <source>In a hot code upgrade, you want to update a node from version A to version B. To do so, the first step is to write recipes for every application that changed between those two releases, telling exactly how the application changed between versions, those recipes are called &lt;code&gt;.appup&lt;/code&gt; files. While some of the steps in building &lt;code&gt;.appup&lt;/code&gt; files can be automated, not all of them can. Furthermore, each process in the application needs to be explicitly coded with hot code upgrades in mind. Let's see an example. Imagine your application has a counter process as a GenServer:</source>
          <target state="translated">При обновлении горячего кода вы хотите обновить узел с версии A до версии B. Для этого первым делом нужно написать рецепты для каждого приложения, которое изменилось между этими двумя выпусками, с точным указанием того, как приложение изменялось между версиями, т.е. рецепты называются файлами &lt;code&gt;.appup&lt;/code&gt; . Хотя некоторые этапы создания файлов &lt;code&gt;.appup&lt;/code&gt; можно автоматизировать, не все из них. Кроме того, каждый процесс в приложении должен быть явно закодирован с учетом обновлений горячего кода. Посмотрим на пример. Представьте, что ваше приложение имеет встречный процесс как GenServer:</target>
        </trans-unit>
        <trans-unit id="93de78b9e89412d553d71ba4abbfe5315731105f" translate="yes" xml:space="preserve">
          <source>In a nutshell, a version is represented by three numbers:</source>
          <target state="translated">В двух словах,версия представлена тремя цифрами:</target>
        </trans-unit>
        <trans-unit id="4de3e72994971159efbbfa51adb4f6daeb251a7f" translate="yes" xml:space="preserve">
          <source>In a nutshell, an application consists of all of the modules defined in the &lt;code&gt;.app&lt;/code&gt; file, including the &lt;code&gt;.app&lt;/code&gt; file itself. An application has generally only two directories: &lt;code&gt;ebin&lt;/code&gt;, for Elixir artefacts, such as &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;priv&lt;/code&gt;, with any other artefact or asset you may need in your application.</source>
          <target state="translated">Вкратце, приложение состоит из всех модулей, определенных в файле &lt;code&gt;.app&lt;/code&gt; , включая &lt;code&gt;.app&lt;/code&gt; файл .app . В приложении обычно есть только два каталога: &lt;code&gt;ebin&lt;/code&gt; для артефактов Elixir, таких как &lt;code&gt;.beam&lt;/code&gt; и &lt;code&gt;.app&lt;/code&gt; , и &lt;code&gt;priv&lt;/code&gt; , с любыми другими артефактами или ресурсами , которые могут понадобиться вашему приложению.</target>
        </trans-unit>
        <trans-unit id="8a78c9d971b121556059db385274a3963a89d465" translate="yes" xml:space="preserve">
          <source>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</source>
          <target state="translated">В двух словах,первый должен использоваться,когда вы хотите отслеживать файлы,обрабатываемые системой,чтобы избежать многократной компиляции одного и того же файла.Это распространено в скриптах.</target>
        </trans-unit>
        <trans-unit id="ba31b6b4506414b36091cbb58f049c0003b3112c" translate="yes" xml:space="preserve">
          <source>In a regular project, we can assemble a release by simply running &lt;code&gt;mix release&lt;/code&gt;. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let&amp;rsquo;s see what is necessary:</source>
          <target state="translated">В обычном проекте мы можем собрать релиз, просто запустив &lt;code&gt;mix release&lt;/code&gt; . Однако у нас есть зонтичный проект, и в таких случаях Elixir требует от нас дополнительных усилий. Посмотрим, что нужно:</target>
        </trans-unit>
        <trans-unit id="2066279752953073a6aab2adcefe389056d45238" translate="yes" xml:space="preserve">
          <source>In addition to matching the target triple, it is also important that the target has all of the system packages that your application will need at runtime. A common one is the need for OpenSSL when building an application that uses &lt;code&gt;:crypto&lt;/code&gt; or &lt;code&gt;:ssl&lt;/code&gt;, which is dynamically linked to ERTS. The other common source for native dependencies like this comes from dependencies containing NIFs (natively-implemented functions) which may expect to dynamically link to libraries they use.</source>
          <target state="translated">Помимо соответствия целевой тройке, также важно, чтобы у цели были все системные пакеты, которые потребуются вашему приложению во время выполнения. Распространенной является потребность в OpenSSL при создании приложения, использующего &lt;code&gt;:crypto&lt;/code&gt; или &lt;code&gt;:ssl&lt;/code&gt; , которое динамически связано с ERTS. Другой распространенный источник для таких собственных зависимостей - это зависимости, содержащие NIF (встроенные функции), которые могут ожидать динамического связывания с библиотеками, которые они используют.</target>
        </trans-unit>
        <trans-unit id="a9421fd8baf899a704905f1b7b921c58ff7bb458" translate="yes" xml:space="preserve">
          <source>In addition to the Elixir file extension &lt;code&gt;.ex&lt;/code&gt;, Elixir also supports &lt;code&gt;.exs&lt;/code&gt; files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. &lt;code&gt;.ex&lt;/code&gt; files are meant to be compiled while &lt;code&gt;.exs&lt;/code&gt; files are used for scripting. When executed, both extensions compile and load their modules into memory, although only &lt;code&gt;.ex&lt;/code&gt; files write their bytecode to disk in the format of &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">В дополнении к расширению файла Elixir &lt;code&gt;.ex&lt;/code&gt; , Elixir также поддерживает &lt;code&gt;.exs&lt;/code&gt; файлы для сценариев. Elixir обращается с обоими файлами одинаково, разница только в намерениях. &lt;code&gt;.ex&lt;/code&gt; файлы предназначены для компиляции , а &lt;code&gt;.exs&lt;/code&gt; файлы используются для написания сценариев. При запуске оба расширения компилируются и загружают свои модули в память, хотя только файлы &lt;code&gt;.ex&lt;/code&gt; записывают свой байт-код на диск в формате файлов &lt;code&gt;.beam&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11490d624ce7faa621bf11120bfb3fc20a3be0c2" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">В дополнение к встроенным атрибутам, описанным выше, также могут быть добавлены пользовательские атрибуты. Настраиваемые атрибуты выражаются с помощью оператора &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; ,&lt;/a&gt; за которым следует допустимое имя переменной. Значение, присвоенное настраиваемому атрибуту, должно быть допустимым значением Elixir:</target>
        </trans-unit>
        <trans-unit id="96148bc0703e1fb4ea78297b10992f7426df74e8" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;kernel#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">В дополнение к встроенным атрибутам, описанным выше, также могут быть добавлены пользовательские атрибуты. Настраиваемые атрибуты выражаются с помощью оператора &lt;a href=&quot;kernel#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; ,&lt;/a&gt; за которым следует допустимое имя переменной. Значение, присвоенное настраиваемому атрибуту, должно быть допустимым значением Elixir:</target>
        </trans-unit>
        <trans-unit id="3dfd563836d0d4567f592fdf1b54449f8fc77413" translate="yes" xml:space="preserve">
          <source>In addition to the keys provided by the user via &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;, the following extra keys are available to the &lt;code&gt;:metadata&lt;/code&gt; list:</source>
          <target state="translated">В дополнение к ключам, предоставленным пользователем через &lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt; , следующие дополнительные ключи доступны для &lt;code&gt;:metadata&lt;/code&gt; списка метаданных :</target>
        </trans-unit>
        <trans-unit id="f1d0e9c42e96c43f7a51f23eb3e0a63cd08fcabb" translate="yes" xml:space="preserve">
          <source>In addition to those, a double quote inside a double-quoted string needs to be escaped as &lt;code&gt;\&quot;&lt;/code&gt;, and, analogously, a single quote inside a single-quoted char list needs to be escaped as &lt;code&gt;\'&lt;/code&gt;. Nevertheless, it is better style to change delimiters as seen above than to escape them.</source>
          <target state="translated">В дополнение к этому, двойные кавычки внутри строки с двойными кавычками должны быть экранированы как &lt;code&gt;\&quot;&lt;/code&gt; , и, аналогично, одинарная кавычка внутри списка символов в одинарных кавычках должна быть экранирована как &lt;code&gt;\'&lt;/code&gt; . Тем не менее, это лучший стиль чтобы изменить разделители, как показано выше, чем избегать их.</target>
        </trans-unit>
        <trans-unit id="2b2826ef1e2ef7d4eb0ba033cc662710c67d0f81" translate="yes" xml:space="preserve">
          <source>In addition, every protocol implementation module contains the &lt;code&gt;__impl__/1&lt;/code&gt; function. The function takes one of the following atoms:</source>
          <target state="translated">Кроме того, каждый модуль реализации протокола содержит &lt;code&gt;__impl__/1&lt;/code&gt; . Функция принимает один из следующих атомов:</target>
        </trans-unit>
        <trans-unit id="81e21312ebc75f6d03fffd3a474b80ff1f053e1d" translate="yes" xml:space="preserve">
          <source>In all of the examples above, we used binaries when writing to files. In the chapter &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;Binaries, strings, and charlists&amp;rdquo;&lt;/a&gt;, we mentioned how strings are made of bytes while charlists are lists with Unicode codepoints.</source>
          <target state="translated">Во всех приведенных выше примерах мы использовали двоичные файлы при записи в файлы. В главе &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;laquo;Двоичные файлы, строки и списки символов&amp;raquo;&lt;/a&gt; мы упоминали, как строки состоят из байтов, а списки символов - это списки с кодовыми точками Unicode.</target>
        </trans-unit>
        <trans-unit id="8e799b4247b90ad4aaf06f6677263f125c9b2f4f" translate="yes" xml:space="preserve">
          <source>In any case, avoid any of the following:</source>
          <target state="translated">В любом случае,избегайте любого из нижеследующего:</target>
        </trans-unit>
        <trans-unit id="1589dd45f78cf7266ba6322f20d21e370ee7f5aa" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;Stack.start_link/1&lt;/code&gt; is always invoked.</source>
          <target state="translated">В обоих случаях всегда вызывается &lt;code&gt;Stack.start_link/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ea2013003c5c58a5c3f717cccfc60a91074f95a" translate="yes" xml:space="preserve">
          <source>In both cases, the command-line arguments for the script or expression are available in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt;&lt;code&gt;System.argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В обоих случаях аргументы командной строки для сценария или выражения доступны в &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt; &lt;code&gt;System.argv/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91806a81fe43b48626fc4b371025096ff818c577" translate="yes" xml:space="preserve">
          <source>In case ANSI is disabled, the ANSI escape sequences are simply discarded.</source>
          <target state="translated">В случае,если ANSI отключен,эвакуационные последовательности ANSI просто отбрасываются.</target>
        </trans-unit>
        <trans-unit id="6d33c9b688f2fa1ee1c39e6a6ee8a9eef85fb236" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns a &lt;code&gt;:suspend&lt;/code&gt; accumulator, it must be explicitly handled by the caller and never leak.</source>
          <target state="translated">В случае, если функция &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; возвращает аккумулятор &lt;code&gt;:suspend&lt;/code&gt; , он должен явно обрабатываться вызывающей стороной и не допускать утечки.</target>
        </trans-unit>
        <trans-unit id="02f1586eeab6e7c0484c69613b04bc3194eb4e79" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns the &lt;code&gt;:suspend&lt;/code&gt; accumulator, the &lt;code&gt;:suspended&lt;/code&gt; tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about &lt;code&gt;:done&lt;/code&gt; and &lt;code&gt;:halted&lt;/code&gt; results.</source>
          <target state="translated">В случае, если функция &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; возвращает аккумулятор &lt;code&gt;:suspend&lt;/code&gt; , кортеж &lt;code&gt;:suspended&lt;/code&gt; Suspend должен явно обрабатываться вызывающей стороной и не допускать утечки. На практике это означает, что обычные функции перечисления просто должны заботиться о результатах &lt;code&gt;:done&lt;/code&gt; и &lt;code&gt;:halted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3377f61918ce91a5a78e38bc72a8ef4ed3572f98" translate="yes" xml:space="preserve">
          <source>In case a direct relative path cannot be found, it returns the original path.</source>
          <target state="translated">В случае,если прямой относительный путь не может быть найден,он возвращает исходный путь.</target>
        </trans-unit>
        <trans-unit id="6c9cc568db359a5124dd032595b36cc1734cb7b5" translate="yes" xml:space="preserve">
          <source>In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests:</source>
          <target state="translated">В случае,если проверяется один файл,можно передать один или несколько конкретных номеров строк,чтобы запустить только те тесты,которые заданы:</target>
        </trans-unit>
        <trans-unit id="e8071ad6cb618eac03347482224d3c6ae15920db" translate="yes" xml:space="preserve">
          <source>In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: &lt;code&gt;&quot;this is a string with \&quot;double quotes\&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">В случае, если строка должна содержать двойные кавычки сама по себе, двойные кавычки должны быть экранированы обратной косой чертой, например: &lt;code&gt;&quot;this is a string with \&quot;double quotes\&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702e65eacb180decf2c9dac0a4fdd10013882322" translate="yes" xml:space="preserve">
          <source>In case a switch &lt;code&gt;SWITCH&lt;/code&gt; is specified to have type &lt;code&gt;:boolean&lt;/code&gt;, it may be passed as &lt;code&gt;--no-SWITCH&lt;/code&gt; as well which will set the option to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Если для переключателя &lt;code&gt;SWITCH&lt;/code&gt; указано значение type &lt;code&gt;:boolean&lt;/code&gt; , его также можно передать как &lt;code&gt;--no-SWITCH&lt;/code&gt; , что установит для параметра значение &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="888f992f5fc265705743ba6ca955221f42ebdba1" translate="yes" xml:space="preserve">
          <source>In case any entry returns &lt;code&gt;nil&lt;/code&gt;, its key will be removed and the deletion will be considered a success.</source>
          <target state="translated">Если какая-либо запись вернет &lt;code&gt;nil&lt;/code&gt; , ее ключ будет удален, и удаление будет считаться успешным.</target>
        </trans-unit>
        <trans-unit id="a72e1cfffefe65681b735eb6f7dbafbbce0c5ef9" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned as per the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">В случае, если какая-либо из записей в середине вернет &lt;code&gt;nil&lt;/code&gt; , будет возвращено &lt;code&gt;nil&lt;/code&gt; согласно модулю &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="de3e20065397014cb42d9b910dde02ad6289d161" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, an error will be raised when trying to access it next.</source>
          <target state="translated">В случае, если какая-либо из записей в середине возвращает &lt;code&gt;nil&lt;/code&gt; , при следующей попытке доступа к ней возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="14f58659a0439f1a109167c635ebf2ecb21a5dc3" translate="yes" xml:space="preserve">
          <source>In case any of the keys returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned:</source>
          <target state="translated">В случае , если какой - либо из ключей возвращает &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;nil&lt;/code&gt; будет возвращен:</target>
        </trans-unit>
        <trans-unit id="ffe6dece0fc6fa31895ca4664fd38ac481329ebd" translate="yes" xml:space="preserve">
          <source>In case it does exist, it is a no-op. Otherwise, it is built.</source>
          <target state="translated">В случае,если он существует,то это &quot;нет-нет-нет&quot;.В противном случае,он построен.</target>
        </trans-unit>
        <trans-unit id="75a8464fb2113eaca41fdf083e397d6efb34f66b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">Если кто-то хочет получить доступ к исходному &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; , это можно сделать, открыв &lt;code&gt;Elixir&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe785d8d01b549120d0fdba2f98502200395bc4b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">Если кто-то хочет получить доступ к исходному &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; , это можно сделать, открыв &lt;code&gt;Elixir&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a3773025824eaaa4fbaabc9e17eece745001ea94" translate="yes" xml:space="preserve">
          <source>In case something goes wrong, you can also use &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; with a different reason:</source>
          <target state="translated">Если что-то пойдет не так, вы также можете использовать &lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; &lt;/a&gt; по другой причине:</target>
        </trans-unit>
        <trans-unit id="2fa86b82adf3327a6ba51dace9ac5f0221aed458" translate="yes" xml:space="preserve">
          <source>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</source>
          <target state="translated">В случае,если псевдоним генерируется автоматически с помощью макроса,Elixir не будет выдавать никаких предупреждений,так как псевдоним не был явно определен.</target>
        </trans-unit>
        <trans-unit id="2b98ade5811cd318aeee5332f266a7b7225f7348" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;https://hexdocs.pm/elixir/UnicodeConversionError.html&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">В случае сбоя преобразования возникает &lt;a href=&quot;https://hexdocs.pm/elixir/UnicodeConversionError.html&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; &lt;/a&gt; . Если дана строка, она возвращает саму строку.</target>
        </trans-unit>
        <trans-unit id="c438ea8f1248a5429d6990102993e9d6dbcfa2ca" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;unicodeconversionerror&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">В случае сбоя преобразования возникает &lt;a href=&quot;unicodeconversionerror&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; &lt;/a&gt; . Если дана строка, она возвращает саму строку.</target>
        </trans-unit>
        <trans-unit id="a15baa5f03723748dcf10b5cb52af46c921885dc" translate="yes" xml:space="preserve">
          <source>In case the file doesn't exist, an error is raised.</source>
          <target state="translated">В случае отсутствия файла возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="9aefc659b37d49c39922094af9efb51756248b09" translate="yes" xml:space="preserve">
          <source>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</source>
          <target state="translated">В случае,если импорт генерируется автоматически с помощью макроса,Elixir не будет выдавать никаких предупреждений,так как импорт не был явно определен.</target>
        </trans-unit>
        <trans-unit id="8f7982ac3a103bc11a1e2ceb070d36fd43cc0956" translate="yes" xml:space="preserve">
          <source>In case the task process dies, the current process will exit with the same reason as the task.</source>
          <target state="translated">В случае умирания процесса задачи,текущий процесс завершится по той же причине,что и задача.</target>
        </trans-unit>
        <trans-unit id="5028298a69062b4bcef1005e365f72fcb9b4bd2c" translate="yes" xml:space="preserve">
          <source>In case the test crashes, you will see a report as follows:</source>
          <target state="translated">В случае сбоя теста вы увидите отчет,который будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="899b34a899719bbd8b066e45019119b52779572b" translate="yes" xml:space="preserve">
          <source>In case the value you want to interpolate cannot be converted to a string, because it doesn't have an human textual representation, a protocol error will be raised.</source>
          <target state="translated">В случае,если значение,которое вы хотите интерполировать,не может быть преобразовано в строку,так как она не имеет человеческого текстового представления,будет поднята ошибка протокола.</target>
        </trans-unit>
        <trans-unit id="94805569146261c99e1aba00cef7b14d9f604927" translate="yes" xml:space="preserve">
          <source>In case there are no config providers, it doesn't change &lt;code&gt;sys_config&lt;/code&gt;.</source>
          <target state="translated">В случае отсутствия поставщиков конфигурации это не меняет &lt;code&gt;sys_config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63f761d55661dfac505485cc96ef395b1517c85a" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">В случае возникновения ошибки во время проверки вашей структуры Elixir вызовет ошибку &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; и автоматически вернется к необработанному представлению для печати структуры.</target>
        </trans-unit>
        <trans-unit id="fd386531e2486b3f99bcfc36b0d8da5b224c20a5" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">В случае ошибки во время проверки вашей структуры Elixir вызовет ошибку &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; и автоматически вернется к необработанному представлению для печати структуры.</target>
        </trans-unit>
        <trans-unit id="05066096207f29449b516520b228a698f4b4f25c" translate="yes" xml:space="preserve">
          <source>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</source>
          <target state="translated">В случае отсутствия такого сообщения текущий процесс зависает,пока не поступит сообщение или не дождется заданного значения таймаута.</target>
        </trans-unit>
        <trans-unit id="4d02c8c3170ba0952169ceddc222a7d17ada7459" translate="yes" xml:space="preserve">
          <source>In case things are not working as expected, please include as much information as you can in your report, for example: your Elixir version, the code snippet and the error message alongside the error stacktrace. Use sites like &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; to paste this information.</source>
          <target state="translated">Если что-то не работает должным образом, включите в свой отчет как можно больше информации, например: вашу версию Elixir, фрагмент кода и сообщение об ошибке вместе с трассировкой стека ошибок. Используйте такие сайты, как &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist,&lt;/a&gt; чтобы вставить эту информацию.</target>
        </trans-unit>
        <trans-unit id="2d3cb03ba7258afff951799e09542865bc33c540" translate="yes" xml:space="preserve">
          <source>In case you are manually compiling protocols or building releases, you need to take the generated protocols into account. This can be done with:</source>
          <target state="translated">В случае,если вы вручную компилируете протоколы или собираете релизы,вам необходимо учитывать сгенерированные протоколы.Это можно сделать:</target>
        </trans-unit>
        <trans-unit id="03bcf5fae6ba2e97dc4c9b6b526c4e8e1ed5a2fc" translate="yes" xml:space="preserve">
          <source>In case you need to configure a process, the options should be passed when starting that process.</source>
          <target state="translated">В случае,если вам необходимо настроить процесс,опции должны быть переданы при запуске этого процесса.</target>
        </trans-unit>
        <trans-unit id="402b42bb4e09e34f8b56390600a6d4385db6ff6a" translate="yes" xml:space="preserve">
          <source>In case you need to work with bytes, take a look at the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно работать с байтами, взгляните на &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;модуль &lt;/a&gt; &lt;code&gt;:binary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc59a70627542b407463a1a5ab11815a7059a36" translate="yes" xml:space="preserve">
          <source>In case you want to automatically load &lt;strong&gt;and start&lt;/strong&gt; all of &lt;code&gt;app&lt;/code&gt;'s dependencies, see &lt;a href=&quot;#ensure_all_started/2&quot;&gt;&lt;code&gt;ensure_all_started/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите автоматически загружать &lt;strong&gt;и запускать&lt;/strong&gt; все зависимости &lt;code&gt;app&lt;/code&gt; , см. &lt;a href=&quot;#ensure_all_started/2&quot;&gt; &lt;code&gt;ensure_all_started/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f681ed2c3aa6661367fb62449b5900050c12c47" translate="yes" xml:space="preserve">
          <source>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; doesn't define the &lt;code&gt;test/3&lt;/code&gt; macro in the module that calls &lt;code&gt;use ExUnit.Case&lt;/code&gt;, but it defines &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; and just imports that into the caller when used.</source>
          <target state="translated">Если вы хотите предоставить некоторые существующие функциональные возможности пользовательскому модулю, определите их в модуле, который будет импортирован соответствующим образом; например, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; не определяет макрос &lt;code&gt;test/3&lt;/code&gt; в модуле, который вызывает &lt;code&gt;use ExUnit.Case&lt;/code&gt; , но он определяет &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; &lt;/a&gt; и просто импортирует его в вызывающую программу при использовании.</target>
        </trans-unit>
        <trans-unit id="8e67d2f3d283f6f03fc8ad3aba714edbb893d393" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">Если вы использовали устаревшую стратегию &lt;code&gt;:simple_one_for_one&lt;/code&gt; из модуля &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; , вы можете перейти на &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; за несколько шагов.</target>
        </trans-unit>
        <trans-unit id="3ff348aca712691651b4c435346c7c87f48a03c6" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">Если вы использовали устаревшую стратегию &lt;code&gt;:simple_one_for_one&lt;/code&gt; из модуля &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; , вы можете перейти на &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; за несколько шагов.</target>
        </trans-unit>
        <trans-unit id="aec959cd2637331d18fa672f762e0b85e128fa1c" translate="yes" xml:space="preserve">
          <source>In code, function specs are written with the &lt;code&gt;@spec&lt;/code&gt; attribute, typically placed immediately before the function definition. Specs can describe both public and private functions. The function name and the number of arguments used in the &lt;code&gt;@spec&lt;/code&gt; attribute must match the function it describes.</source>
          <target state="translated">В коде спецификации функций записываются с атрибутом &lt;code&gt;@spec&lt;/code&gt; , который обычно помещается непосредственно перед определением функции. Спецификации могут описывать как публичные, так и частные функции. Имя функции и количество аргументов, используемых в &lt;code&gt;@spec&lt;/code&gt; должны соответствовать функции, которую он описывает.</target>
        </trans-unit>
        <trans-unit id="e3fa04a38e1468a79c7262b85ac96321cc9efef6" translate="yes" xml:space="preserve">
          <source>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</source>
          <target state="translated">В отличие от списков ключевых слов,карты очень полезны при сопоставлении шаблонов.Когда карта используется в шаблоне,она всегда будет совпадать с подмножеством заданного значения:</target>
        </trans-unit>
        <trans-unit id="1a0cd3de6db0a42db7660ce1f70c833f42728634" translate="yes" xml:space="preserve">
          <source>In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that &lt;code&gt;Mod.called2/0&lt;/code&gt; was called once by &lt;code&gt;Mod.some_function/0&lt;/code&gt;, and in that case the total time spent in the function was 50ms.</source>
          <target state="translated">Напротив, значения для вызываемых функций описывают эти функции, но в контексте отмеченной функции. Например, последняя строка означает, что &lt;code&gt;Mod.called2/0&lt;/code&gt; был вызван один раз из &lt;code&gt;Mod.some_function/0&lt;/code&gt; , и в этом случае общее время, проведенное в функции, составило 50 мс.</target>
        </trans-unit>
        <trans-unit id="1bd204212246b87557a18b94547a4a49f3e0882e" translate="yes" xml:space="preserve">
          <source>In daemon mode, the system is started on the background via &lt;a href=&quot;http://erlang.org/doc/man/run_erl.html&quot;&gt;run_erl&lt;/a&gt;. You may also want to enable &lt;a href=&quot;http://erlang.org/doc/man/heart.html&quot;&gt;heart&lt;/a&gt; in daemon mode so it automatically restarts the system in case of crashes. See the generated &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; file.</source>
          <target state="translated">В режиме демона система запускается в фоновом режиме через &lt;a href=&quot;http://erlang.org/doc/man/run_erl.html&quot;&gt;run_erl&lt;/a&gt; . Вы также можете включить &lt;a href=&quot;http://erlang.org/doc/man/heart.html&quot;&gt;Heart&lt;/a&gt; в режиме демона, чтобы он автоматически перезагружал систему в случае сбоев. См. &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; файл Release / RELEASE_VSN / env.sh.</target>
        </trans-unit>
        <trans-unit id="fc4add0dde66d9d0296a0654de0562024d8f9f79" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">Фактически, &lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; может использоваться для исправления любой ошибки, которая не является правильной ошибкой Elixir. Например, его также можно использовать для восстановления предыдущей ошибки &lt;code&gt;:badarg&lt;/code&gt; до преобразования:</target>
        </trans-unit>
        <trans-unit id="3fc62d3ceab839ba2b910c33a7d8e5bd0aaee7f5" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">Фактически, &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; может использоваться для спасения любой ошибки, которая не является правильной ошибкой Elixir. Например, его также можно использовать для восстановления предыдущей ошибки &lt;code&gt;:badarg&lt;/code&gt; до преобразования:</target>
        </trans-unit>
        <trans-unit id="0899943a58fd70e4f3d0ccf56e136c5b02dd5f31" translate="yes" xml:space="preserve">
          <source>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</source>
          <target state="translated">На самом деле,подключение к удаленным оболочкам настолько распространено,что мы также предоставляем ярлык через командную строку:</target>
        </trans-unit>
        <trans-unit id="86d8ddd11e7d11d4d1da78d64c3d55a307dc74a3" translate="yes" xml:space="preserve">
          <source>In fact, let&amp;rsquo;s open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;:</source>
          <target state="translated">Фактически, давайте откроем &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61139d4b1bbde59322a4c8bca7a0561709d9841c" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;:bind_quoted&lt;/code&gt; option is recommended every time one desires to inject a value into the quote.</source>
          <target state="translated">Фактически, опция &lt;code&gt;:bind_quoted&lt;/code&gt; рекомендуется каждый раз, когда кто-то хочет вставить значение в цитату.</target>
        </trans-unit>
        <trans-unit id="e63bd9e9e19b982359b9cda4d5fcbeea34909a27" translate="yes" xml:space="preserve">
          <source>In fact, this pattern is so common that most of the times you will want to use the &lt;code&gt;bind_quoted&lt;/code&gt; option with &lt;a href=&quot;#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Фактически, этот шаблон настолько распространен, что в большинстве случаев вы захотите использовать параметр &lt;code&gt;bind_quoted&lt;/code&gt; с &lt;a href=&quot;#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">В общем, &lt;code&gt;underscore&lt;/code&gt; можно рассматривать как противоположность &lt;code&gt;camelize&lt;/code&gt; , однако в некоторых случаях форматирование может быть потеряно:</target>
        </trans-unit>
        <trans-unit id="6a3e2a29096c65e2eb89f937c17a4004e7ef7444" translate="yes" xml:space="preserve">
          <source>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</source>
          <target state="translated">В общем,разработчик должен использовать первую,если он хочет отреагировать,если файл не существует.Последнее следует использовать,когда разработчик ожидает,что его программное обеспечение выйдет из строя в случае,если файл не может быть прочитан (т.е.это буквально исключение).</target>
        </trans-unit>
        <trans-unit id="d16c9ac73c5397997e3e76ab325334e002852804" translate="yes" xml:space="preserve">
          <source>In general, a developer will want to use the general &lt;code&gt;assert&lt;/code&gt; macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; will fail (assuming &lt;code&gt;some_fun()&lt;/code&gt; returns &lt;code&gt;13&lt;/code&gt;):</source>
          <target state="translated">В общем, разработчик захочет использовать в тестах общий макрос &lt;code&gt;assert&lt;/code&gt; . Этот макрос анализирует ваш код и предоставляет хорошие отчеты в случае сбоя. Например, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; завершится ошибкой (при условии, что &lt;code&gt;some_fun()&lt;/code&gt; возвращает &lt;code&gt;13&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="9be20cb8cf2a5e21e25e5b415ec975c67912ed9d" translate="yes" xml:space="preserve">
          <source>In general, doctests are not recommended when your code examples contain side effects. For example, if a doctest prints to standard output, doctest will not try to capture the output.</source>
          <target state="translated">В целом,не рекомендуется проводить доктесты,когда примеры вашего кода содержат побочные эффекты.Например,если doctest печатает на стандартный вывод,doctest не будет пытаться захватить вывод.</target>
        </trans-unit>
        <trans-unit id="c3d41e104bfcea8fdabed0cd450572fc2e4bac9f" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</source>
          <target state="translated">В целом,функции в этом модуле полагаются на стандарт Юникода,но не содержат никаких специфических для данной локали поведений.</target>
        </trans-unit>
        <trans-unit id="1b51681509b0cc1251035f9253bdae711f905e3e" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour. More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;.</source>
          <target state="translated">В общем, функции в этом модуле основаны на стандарте Unicode, но не содержат поведения, зависящего от локали. Более подробную информацию о графемах можно найти в &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Приложении № 29&lt;/a&gt; к стандарту Unicode .</target>
        </trans-unit>
        <trans-unit id="9c9716a12a8a55aca30fe284f4ffccd27a063bec" translate="yes" xml:space="preserve">
          <source>In general, the tuples above are structured according to the following format:</source>
          <target state="translated">В целом,кортежи,приведенные выше,структурированы в соответствии со следующим форматом:</target>
        </trans-unit>
        <trans-unit id="6de751c2f24f5d6947a334c2b635bc5f4ec33c5a" translate="yes" xml:space="preserve">
          <source>In general, when the keyword list is the last argument of a function, the square brackets are optional.</source>
          <target state="translated">В общем случае,когда список ключевых слов является последним аргументом функции,квадратные скобки являются необязательными.</target>
        </trans-unit>
        <trans-unit id="aa567762586986c74d465d0aa8d43a9b014b6cd4" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead.</source>
          <target state="translated">В охранниках,когда функции,как правило,увеличивают исключения,они вызывают отказ охранника вместо этого.</target>
        </trans-unit>
        <trans-unit id="6bab1cb15297331e40b3f50701fea2260e1dfe89" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function only works with lists. If we use it with anything else, a runtime error is raised:</source>
          <target state="translated">В охранниках, когда функции обычно вызывают исключения, они вместо этого вызывают сбой защиты. Например, функция &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; работает только со списками. Если мы используем его с чем-то еще, возникает ошибка времени выполнения:</target>
        </trans-unit>
        <trans-unit id="a530de2468aeae84b5f9a5ab3d0835429e502343" translate="yes" xml:space="preserve">
          <source>In light of this observation, we should consider moving to another supervision strategy. The two other candidates are &lt;code&gt;:one_for_all&lt;/code&gt; and &lt;code&gt;:rest_for_one&lt;/code&gt;. A supervisor using the &lt;code&gt;:rest_for_one&lt;/code&gt; strategy will kill and restart child processes which were started &lt;em&gt;after&lt;/em&gt; the crashed child. In this case, we would want &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; to terminate if &lt;code&gt;KV.Registry&lt;/code&gt; terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.</source>
          <target state="translated">В свете этого наблюдения нам следует подумать о переходе к другой стратегии супервизии. Двумя другими кандидатами являются &lt;code&gt;:one_for_all&lt;/code&gt; и &lt;code&gt;:rest_for_one&lt;/code&gt; . Супервизор, использующий стратегию &lt;code&gt;:rest_for_one&lt;/code&gt; , убьет и перезапустит дочерние процессы, которые были запущены &lt;em&gt;после &lt;/em&gt;сбоя дочернего процесса . В этом случае мы хотели бы, чтобы &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; завершал свою работу, если &lt;code&gt;KV.Registry&lt;/code&gt; завершается. Это потребует размещения супервизора корзины после реестра, что нарушает ограничения порядка, которые мы установили двумя абзацами выше.</target>
        </trans-unit>
        <trans-unit id="505de6a8a3338b2af34fda74ec05eeff90a625d9" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macro-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">В &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt; означает, что &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macro-hygiene&quot;&gt;макро-гигиена&lt;/a&gt; отложена.</target>
        </trans-unit>
        <trans-unit id="287c5e7fdc75892fe61a19be625743d753001a1c" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;kernel#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">В &lt;a href=&quot;kernel#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;kernel#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt; означает, что &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;макро-гигиена&lt;/a&gt; отложена.</target>
        </trans-unit>
        <trans-unit id="32bcee841524dde12cdf73859245e9378a9b1abe" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">Во многих случаях удобнее передать ожидаемое значение для &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; и создания сообщения в &lt;a href=&quot;exception#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b6d866c1d491de63fc794b51b1fe651b6b2cf7a2" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">Во многих случаях удобнее передать ожидаемое значение для &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; и создания сообщения в &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="19dc1fd7cd1d8b39b9ff5dace65dcd36cc88f10b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt; to both check that the given value is a tuple &lt;em&gt;and&lt;/em&gt; check its size (instead of using &lt;code&gt;is_tuple(something) and tuple_size(something) == 2&lt;/code&gt;).</source>
          <target state="translated">Во многих случаях мы можем этим воспользоваться. В приведенном выше коде мы использовали &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt; как для проверки того, что данное значение является кортежем, так &lt;em&gt;и для&lt;/em&gt; проверки его размера (вместо использования &lt;code&gt;is_tuple(something) and tuple_size(something) == 2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f3a407dd1ba9629c2d87378f7214d938dbbf397b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; to both check that the given thing is a list &lt;em&gt;and&lt;/em&gt; check some properties of its length (instead of using &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt;).</source>
          <target state="translated">Во многих случаях мы можем этим воспользоваться. В приведенном выше коде мы использовали &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; как для проверки того, что данная вещь является списком, так &lt;em&gt;и для&lt;/em&gt; проверки некоторых свойств ее длины (вместо использования &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1718d61cb1f8d442d32bbf909dd936aa49ffeb46" translate="yes" xml:space="preserve">
          <source>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</source>
          <target state="translated">Во многих функциональных языках программирования в качестве представления структуры данных ключа-значения принято использовать список кортежей из 2-х пунктов.В Elixir,когда у нас есть список кортежей,а первый элемент кортежа (т.е.ключ)является атомом,мы называем его списком ключевых слов:</target>
        </trans-unit>
        <trans-unit id="68e23cbb5429660e2faf1806ef4a612c49708bf4" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; is enough. &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; must be used in rare cases, usually involving macros that need to invoke a module for callback information.</source>
          <target state="translated">В большинстве случаев достаточно &lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; следует использовать в редких случаях, обычно с макросами, которые должны вызывать модуль для информации обратного вызова.</target>
        </trans-unit>
        <trans-unit id="423cb3333a43148ea91fc3b7a37efcd42c886681" translate="yes" xml:space="preserve">
          <source>In order for the cache mechanism to work, the created ETS table needs to have access &lt;code&gt;:protected&lt;/code&gt; (the default), so all clients can read from it, while only the &lt;code&gt;KV.Registry&lt;/code&gt; process writes to it. We have also set &lt;code&gt;read_concurrency: true&lt;/code&gt; when starting the table, optimizing the table for the common scenario of concurrent read operations.</source>
          <target state="translated">Чтобы механизм кеширования работал, созданная таблица ETS должна иметь доступ &lt;code&gt;:protected&lt;/code&gt; (по умолчанию), чтобы все клиенты могли читать из нее, в то время как только процесс &lt;code&gt;KV.Registry&lt;/code&gt; записывает в нее. Мы также установили &lt;code&gt;read_concurrency: true&lt;/code&gt; при запуске таблицы, оптимизируя таблицу для обычного сценария одновременных операций чтения.</target>
        </trans-unit>
        <trans-unit id="c81c6a20ae394a892047f71306226257ed4ae14b" translate="yes" xml:space="preserve">
          <source>In order to be loaded, an &lt;code&gt;.app&lt;/code&gt; file must be in the load paths. All &lt;code&gt;:included_applications&lt;/code&gt; will also be loaded.</source>
          <target state="translated">Для загрузки в пути загрузки должен быть файл &lt;code&gt;.app&lt;/code&gt; . Все &lt;code&gt;:included_applications&lt;/code&gt; также будут загружены.</target>
        </trans-unit>
        <trans-unit id="0ce310cabbc38fde237e6f7456d065921f47f408" translate="yes" xml:space="preserve">
          <source>In order to better understand how macros work, let&amp;rsquo;s create a new module where we are going to implement &lt;code&gt;unless&lt;/code&gt;, which does the opposite of &lt;code&gt;if&lt;/code&gt;, as a macro and as a function:</source>
          <target state="translated">Чтобы лучше понять, как работают макросы, давайте создадим новый модуль, в котором мы собираемся реализовать &lt;code&gt;unless&lt;/code&gt; , который делает противоположность &lt;code&gt;if&lt;/code&gt; , как макрос и как функцию:</target>
        </trans-unit>
        <trans-unit id="167262643fd2c56cb15474799a3fefbbc20d320a" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Для создания переменной ожидается контекст. В большинстве случаев, чтобы сохранить гигиену, контекст должен быть &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="98bbe9c7dc0c95fe1893b767af4a2559d441e9f7" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Для создания переменной ожидается контекст. В большинстве случаев, чтобы сохранить гигиену, контекст должен быть &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="09c48209d831c8b2ec6ba4ec948897b23f18046a" translate="yes" xml:space="preserve">
          <source>In order to build our key-value application, we are going to use three main tools:</source>
          <target state="translated">Для того чтобы построить наше приложение с ключевым значением,мы будем использовать три основных инструмента:</target>
        </trans-unit>
        <trans-unit id="9a8e911427746c64d6627a4cd13981382e8cbad5" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">Чтобы сравнить более двух предложений, необходимо использовать макрос &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db1ca29d2377c1f8fa9329bcdb6aca022dc1f156" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">Чтобы сравнить более двух предложений, необходимо использовать макрос &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bdbf00ad68adfada8cf0d80c6af387a4904e12d" translate="yes" xml:space="preserve">
          <source>In order to configure Mix, the module that &lt;code&gt;use&lt;/code&gt;s &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; should export a &lt;code&gt;project/0&lt;/code&gt; function that returns a keyword list representing configuration for the project.</source>
          <target state="translated">Для того , чтобы настроить Mix, модуль, &lt;code&gt;use&lt;/code&gt; сек &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; должен экспортировать &lt;code&gt;project/0&lt;/code&gt; функцию , которая возвращает список ключевых слов , представляющий конфигурацию проекта.</target>
        </trans-unit>
        <trans-unit id="6eb392bb5990ef3fcaeb5fa0f99e17c04d60d3ab" translate="yes" xml:space="preserve">
          <source>In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &lt;a href=&quot;#deprecations&quot;&gt;&quot;Deprecations&quot; section&lt;/a&gt;.</source>
          <target state="translated">Чтобы продолжить развитие языка без внесения критических изменений, Elixir будет полагаться на устаревшие методы для понижения роли определенных практик и продвижения новых. Наша политика прекращения поддержки изложена в разделе &lt;a href=&quot;#deprecations&quot;&gt;&amp;laquo;Прекращение поддержки&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="642f4f188110996b3a0b6c3fdce8b893ead2d9fa" translate="yes" xml:space="preserve">
          <source>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</source>
          <target state="translated">Для того,чтобы справиться с загрузкой кода при разработке,протоколы в Elixir обеспечивают медленную реализацию диспетчеризации протоколов,специфичной для разработки.</target>
        </trans-unit>
        <trans-unit id="6a2b5841e9d7864def29c3c36d34a45ef5565969" translate="yes" xml:space="preserve">
          <source>In order to create our own modules in Elixir, we use the &lt;code&gt;defmodule&lt;/code&gt; macro. We use the &lt;code&gt;def&lt;/code&gt; macro to define functions in that module:</source>
          <target state="translated">Для создания собственных модулей в Elixir мы используем макрос &lt;code&gt;defmodule&lt;/code&gt; . Мы используем макрос &lt;code&gt;def&lt;/code&gt; для определения функций в этом модуле:</target>
        </trans-unit>
        <trans-unit id="2db428412e028f480fb253824aa4dbe3e8772fd9" translate="yes" xml:space="preserve">
          <source>In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The &lt;a href=&quot;https://unicode.org/standard/standard.html&quot;&gt;Unicode Standard&lt;/a&gt; acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.</source>
          <target state="translated">Чтобы облегчить осмысленную коммуникацию между компьютерами на нескольких языках, требуется стандарт, чтобы единицы и нули на одной машине означали одно и то же при передаче на другую. &lt;a href=&quot;https://unicode.org/standard/standard.html&quot;&gt;Стандарт Unicode&lt;/a&gt; выступает в качестве официального реестра практически всех персонажей , которых мы знаем: это включает в себя персонажей из классических и исторических текстов, смайликов и форматирования и управляющих символов , а также.</target>
        </trans-unit>
        <trans-unit id="4adfde6fe98ff6cd24536d794e886a1f37546977" translate="yes" xml:space="preserve">
          <source>In order to facilitate software reuse, Elixir provides three directives (&lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;) plus a macro called &lt;code&gt;use&lt;/code&gt; summarized below:</source>
          <target state="translated">Чтобы упростить повторное использование программного обеспечения, Elixir предоставляет три директивы ( &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; ), а также макрос под названием &lt;code&gt;use&lt;/code&gt; , кратко описанный ниже:</target>
        </trans-unit>
        <trans-unit id="06a700b11907ab62d5a4a0a6df97c7759ea5d0ae" translate="yes" xml:space="preserve">
          <source>In order to finish our &lt;code&gt;TestCase&lt;/code&gt; implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt;, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.</source>
          <target state="translated">Чтобы завершить реализацию &lt;code&gt;TestCase&lt;/code&gt; , нам нужно иметь доступ ко всем определенным тестовым случаям. Один из способов сделать это - получить тесты во время выполнения через &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt; , который возвращает список всех функций в данном модуле. Однако, учитывая, что мы можем захотеть хранить больше информации о каждом тесте, помимо имени теста, необходим более гибкий подход.</target>
        </trans-unit>
        <trans-unit id="c5a3e4590add882007f47566c77c18638d716efc" translate="yes" xml:space="preserve">
          <source>In order to fix the failing test, let&amp;rsquo;s create a file at &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; with the contents below. Feel free to give a try at implementing the &lt;code&gt;KV.Bucket&lt;/code&gt; module yourself using agents before peeking at the implementation below.</source>
          <target state="translated">Чтобы исправить ошибку теста, давайте создадим файл в &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; со следующим содержимым. Не стесняйтесь попробовать реализовать модуль &lt;code&gt;KV.Bucket&lt;/code&gt; самостоятельно с помощью агентов, прежде чем взглянуть на реализацию ниже.</target>
        </trans-unit>
        <trans-unit id="fc7b18c46cad921ea2c996d18c66b0c78849816d" translate="yes" xml:space="preserve">
          <source>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</source>
          <target state="translated">Чтобы исправить эту ошибку,нам нужно,чтобы реестр отслеживал каждое ведро,которое оно порождает.Как только мы настроим монитор,реестр будет получать уведомление каждый раз при выходе из ковша,что позволит нам очистить реестр.</target>
        </trans-unit>
        <trans-unit id="62bd04dae1b62f0c9a990b148f9408c4a2843b61" translate="yes" xml:space="preserve">
          <source>In order to generate the &lt;code&gt;.app&lt;/code&gt; file, Mix expects your project to have both &lt;code&gt;:app&lt;/code&gt; and &lt;code&gt;:version&lt;/code&gt; keys. Furthermore, you can configure the generated application by defining an &lt;code&gt;application/0&lt;/code&gt; function in your &lt;code&gt;mix.exs&lt;/code&gt; that returns a keyword list.</source>
          <target state="translated">Чтобы сгенерировать файл &lt;code&gt;.app&lt;/code&gt; , Mix ожидает, что ваш проект будет иметь ключи &lt;code&gt;:app&lt;/code&gt; и &lt;code&gt;:version&lt;/code&gt; . Кроме того, вы можете настроить сгенерированное приложение, определив функцию &lt;code&gt;application/0&lt;/code&gt; в вашем &lt;code&gt;mix.exs&lt;/code&gt; , которая возвращает список ключевых слов.</target>
        </trans-unit>
        <trans-unit id="5a956c6b95ce875304570bf71071ca672fa7f12b" translate="yes" xml:space="preserve">
          <source>In order to get your first project started, Elixir ships with a build tool called Mix. You can get your new project started by running:</source>
          <target state="translated">Для того,чтобы начать свой первый проект,Elixir поставляется со строительным инструментом под названием Mix.Вы можете начать свой новый проект,запустив его:</target>
        </trans-unit>
        <trans-unit id="017fd6a1081d196daafbd3b60fc590b568ac6071" translate="yes" xml:space="preserve">
          <source>In order to help IEx understand that an expression consists of multiple lines we can wrap it into parentheses:</source>
          <target state="translated">Чтобы помочь IEx понять,что выражение состоит из нескольких строк,мы можем заключить его в круглые скобки:</target>
        </trans-unit>
        <trans-unit id="06a43dffd10b2bfa3f19eb38d062aa6b636e0e88" translate="yes" xml:space="preserve">
          <source>In order to import configuration, &lt;code&gt;my_app&lt;/code&gt;'s &lt;code&gt;.formatter.exs&lt;/code&gt; would look like this:</source>
          <target state="translated">Для того , чтобы конфигурации импорта, &lt;code&gt;my_app&lt;/code&gt; &amp;laquo;s &lt;code&gt;.formatter.exs&lt;/code&gt; будет выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="a957b1a9d6df7d7ce8fa55bcc89ebc9a60d14634" translate="yes" xml:space="preserve">
          <source>In order to invoke the callbacks above, we need to go through the corresponding &lt;code&gt;GenServer&lt;/code&gt; functions. Let&amp;rsquo;s start a registry, create a named bucket, and then look it up:</source>
          <target state="translated">Чтобы вызвать вышеупомянутые обратные вызовы, нам нужно пройти через соответствующие функции &lt;code&gt;GenServer&lt;/code&gt; . Давайте запустим реестр, создадим именованную корзину, а затем найдем ее:</target>
        </trans-unit>
        <trans-unit id="af452841dd75bb4a44c38345c300f4a14d20c04a" translate="yes" xml:space="preserve">
          <source>In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:</source>
          <target state="translated">Чтобы заставить наш сервер обрабатывать одновременные соединения,нам нужно,чтобы один процесс работал как акцептор,который порождает другие процессы для обслуживания запросов.Одним из решений было бы изменение:</target>
        </trans-unit>
        <trans-unit id="e3a8a476eb42420a16666c234250ab684a970ce4" translate="yes" xml:space="preserve">
          <source>In order to manipulate keyword lists, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;the &lt;code&gt;Keyword&lt;/code&gt; module&lt;/a&gt;. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</source>
          <target state="translated">Для того , чтобы манипулировать списками ключевых слов, Elixir обеспечивает &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;в &lt;code&gt;Keyword&lt;/code&gt; модуль&lt;/a&gt; . Однако помните, что списки ключевых слов - это просто списки, и поэтому они обеспечивают те же линейные характеристики производительности, что и списки. Чем длиннее список, тем больше времени потребуется на поиск ключа, подсчет количества элементов и т. Д. По этой причине списки ключевых слов используются в Elixir в основном для передачи необязательных значений. Если вам нужно хранить много элементов или гарантировать связь с одним ключом максимум с одним значением, вам следует вместо этого использовать карты.</target>
        </trans-unit>
        <trans-unit id="af5b1e73788ff17dca0429ef7ffa66ff44df9939" translate="yes" xml:space="preserve">
          <source>In order to run distributed code, we need to start the</source>
          <target state="translated">Для того,чтобы запустить распределенный код,нам нужно запустить</target>
        </trans-unit>
        <trans-unit id="62c900a7e8363bd8d8183eca353b3f640ed385cc" translate="yes" xml:space="preserve">
          <source>In order to run the first test, we need to have two nodes running. Move into &lt;code&gt;apps/kv&lt;/code&gt; and let&amp;rsquo;s restart the node named &lt;code&gt;bar&lt;/code&gt; which is going to be used by tests.</source>
          <target state="translated">Чтобы запустить первый тест, нам нужно запустить два узла. Перейдите в &lt;code&gt;apps/kv&lt;/code&gt; и перезапустите узел с именем &lt;code&gt;bar&lt;/code&gt; , который будет использоваться тестами.</target>
        </trans-unit>
        <trans-unit id="e8a55d2f768aa9a90c3e47bbc22675a61941f5a4" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called &lt;em&gt;protocol consolidation&lt;/em&gt;. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">Чтобы ускорить диспетчеризацию в производственной среде, где все реализации известны заранее, Elixir предоставляет функцию, называемую &lt;em&gt;консолидацией протоколов&lt;/em&gt; . Консолидация напрямую связывает протоколы с их реализациями таким образом, что вызов функции из консолидированного протокола эквивалентен вызову двух удаленных функций.</target>
        </trans-unit>
        <trans-unit id="64a048080239b32ae9270b349a43b94c3e07e07c" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">Для ускорения диспетчеризации в производственных средах,где все реализации известны заранее,Elixir предоставляет функцию,называемую консолидацией протоколов.Консолидация напрямую связывает протоколы с их реализацией таким образом,что вызов функции из консолидированного протокола эквивалентен вызову двух удаленных функций.</target>
        </trans-unit>
        <trans-unit id="8d8b39acde42481af0b84b36b66305d49c434a4a" translate="yes" xml:space="preserve">
          <source>In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack:</source>
          <target state="translated">Для того,чтобы запустить супервайзера,нам необходимо сначала определить дочерний процесс,который будет контролироваться.В качестве примера,мы определим GenServer,который представляет собой стек:</target>
        </trans-unit>
        <trans-unit id="0dc599f69280e0654d0ad9b6739bad7864211d7c" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide and learn how to use module attributes as storage to allow developers to create DSLs.</source>
          <target state="translated">Чтобы понять основной код, нам понадобятся макросы, поэтому мы еще раз вернемся к этому шаблону в руководстве по метапрограммированию и узнаем, как использовать атрибуты модуля в качестве хранилища, чтобы позволить разработчикам создавать DSL.</target>
        </trans-unit>
        <trans-unit id="656310fbcb50af634eac84272798b02ab00dba6a" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide. However, the focus here is on how using module attributes as storage allows developers to create DSLs.</source>
          <target state="translated">Чтобы понять основной код, нам понадобятся макросы, поэтому мы еще вернемся к этому шаблону в руководстве по метапрограммированию. Однако здесь основное внимание уделяется тому, как использование атрибутов модуля в качестве хранилища позволяет разработчикам создавать DSL.</target>
        </trans-unit>
        <trans-unit id="1ca6c027f8dcdd141de11fbd20d5f0afb503fc0f" translate="yes" xml:space="preserve">
          <source>In order to use dependencies, you need to add a &lt;code&gt;:deps&lt;/code&gt; key to your project configuration. We often extract the list of dependencies into its own function:</source>
          <target state="translated">Чтобы использовать зависимости, вам необходимо добавить ключ &lt;code&gt;:deps&lt;/code&gt; в конфигурацию вашего проекта. Мы часто извлекаем список зависимостей в отдельную функцию:</target>
        </trans-unit>
        <trans-unit id="ea5cbfc0efc9a5e4905ac0bfbf89bf8917d5354f" translate="yes" xml:space="preserve">
          <source>In order to use the application environment in our code, we need to replace &lt;code&gt;KV.Router.table/0&lt;/code&gt; with the definition below:</source>
          <target state="translated">Чтобы использовать среду приложения в нашем коде, нам нужно заменить &lt;code&gt;KV.Router.table/0&lt;/code&gt; определением ниже:</target>
        </trans-unit>
        <trans-unit id="0e357d261c32f760a30d8b31568d4778e3817d29" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">Для записи и чтения файлов необходимо использовать функции модуля &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; . По умолчанию файл открывается в &lt;code&gt;:binary&lt;/code&gt; режиме, который требует, чтобы функции &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; взаимодействовали с файлом. Разработчик может передать &lt;code&gt;:utf8&lt;/code&gt; в качестве опции при открытии файла, и тогда будут доступны все другие функции из &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; , поскольку они работают напрямую с данными Unicode.</target>
        </trans-unit>
        <trans-unit id="579dc3768627dbc4d67a1e0757b95afdfeb30685" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">Для записи и чтения файлов необходимо использовать функции модуля &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; . По умолчанию файл открывается в двоичном режиме, который требует, чтобы функции &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; взаимодействовали с файлом. Разработчик может передать &lt;code&gt;:utf8&lt;/code&gt; в качестве опции при открытии файла, тогда должны использоваться более медленные функции &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; ,&lt;/a&gt; поскольку они отвечают за выполнение правильных преобразований и предоставление надлежащих гарантий данных.</target>
        </trans-unit>
        <trans-unit id="dcd42d7d1276fbdd4330c63012ce7d34e85da421" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">Для записи и чтения файлов необходимо использовать функции модуля &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; . По умолчанию файл открывается в &lt;code&gt;:binary&lt;/code&gt; режиме, который требует, чтобы функции &lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; взаимодействовали с файлом. Разработчик может передать &lt;code&gt;:utf8&lt;/code&gt; в качестве опции при открытии файла, и тогда будут доступны все другие функции из &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; , поскольку они работают напрямую с данными Unicode.</target>
        </trans-unit>
        <trans-unit id="82ce7a0943dbb663e7fc6760db6023cf3368a14d" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;io#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">Для записи и чтения файлов необходимо использовать функции модуля &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; . По умолчанию файл открывается в двоичном режиме, что требует, чтобы функции &lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; взаимодействовали с файлом. Разработчик может передать &lt;code&gt;:utf8&lt;/code&gt; в качестве опции при открытии файла, тогда должны использоваться более медленные функции &lt;a href=&quot;io#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;io#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; ,&lt;/a&gt; поскольку они отвечают за выполнение правильных преобразований и предоставление надлежащих гарантий данных.</target>
        </trans-unit>
        <trans-unit id="545dafe5c1ee7a1449e5b9b98c6c6db53caaf9f3" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">Другими словами, &lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; означает:</target>
        </trans-unit>
        <trans-unit id="31ee06abc4e001e3f6a5b13f3dfe4953038e624e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; is equivalent to &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt;.</source>
          <target state="translated">Другими словами, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; эквивалентно &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="886ca2f2765b1ff87730f7dc9a052f3a738d7792" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; translates to:</source>
          <target state="translated">Другими словами, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; переводится как:</target>
        </trans-unit>
        <trans-unit id="93125c6aa3c9fdcea503c87c1c3998ce536dbba7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;strong&gt;do not&lt;/strong&gt;:</source>
          <target state="translated">Другими словами, &lt;strong&gt;нельзя&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c7679a9328277147beb719edbd3a5a83c335113c" translate="yes" xml:space="preserve">
          <source>In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (&lt;code&gt;^&lt;/code&gt;):</source>
          <target state="translated">Другими словами, Elixir поддерживает повторную привязку. Если вы не хотите, чтобы значение переменной изменялось, вы можете использовать оператор булавки ( &lt;code&gt;^&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="6d77f8954062d90a90e9c6b5408cf752db4ed5cd" translate="yes" xml:space="preserve">
          <source>In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems.</source>
          <target state="translated">Другими словами, Elixir будет анализировать только те параметры, которые используются средой выполнения, игнорируя все остальные. Если вы хотите проанализировать все переключатели, независимо от того, существуют они или нет, вы можете принудительно создать атомы, передав &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; как параметр. Осторожно используйте эту опцию. Это полезно только при создании приложений командной строки, которые получают аргументы с динамическими именами, и этого следует избегать в долго работающих системах.</target>
        </trans-unit>
        <trans-unit id="38fe91f6b4425a57a05293a344c316d610b9df57" translate="yes" xml:space="preserve">
          <source>In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.</source>
          <target state="translated">Другими словами,функции,использующие слово &quot;размер&quot; в своем названии,займут столько же времени,будь то крошечная или огромная структура данных.И наоборот,функции,имеющие в своем названии слово &quot;length&quot; (длина),будут занимать больше времени по мере того,как структура данных будет увеличиваться в размерах.</target>
        </trans-unit>
        <trans-unit id="60a4e6e4835459586a75795caa4bfdc4a5131e02" translate="yes" xml:space="preserve">
          <source>In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper &lt;code&gt;:shutdown&lt;/code&gt; value, ensuring it terminates within a reasonable interval.</source>
          <target state="translated">Другими словами, если важно, чтобы процесс очищался после себя, когда ваше приложение или дерево наблюдения завершают работу, тогда этот процесс должен перехватывать выходы, а его дочерняя спецификация должна указывать правильное значение &lt;code&gt;:shutdown&lt;/code&gt; , гарантируя, что он завершится в течение разумного интервала. ,</target>
        </trans-unit>
        <trans-unit id="62c93298d745ed7ef2d4717535ac947d098645b2" translate="yes" xml:space="preserve">
          <source>In other words, if your configuration does something like:</source>
          <target state="translated">Другими словами,если ваша конфигурация делает что-то подобное:</target>
        </trans-unit>
        <trans-unit id="1f496a7679d30119adb2cc52d4073c178807ab2e" translate="yes" xml:space="preserve">
          <source>In other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, etc) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.</source>
          <target state="translated">Другими словами,важно проводить различие между обычным значением эликсира (например,список,карта,процесс,ссылка и т.д.)и цитируемым выражением.Некоторые значения,такие как целые числа,атомы и строки,имеют цитируемое выражение,равное самому значению.Другие значения,такие как карты,должны быть явно преобразованы.Наконец,такие значения,как функции и ссылки,вообще не могут быть преобразованы в выражение,заключенное в кавычки.</target>
        </trans-unit>
        <trans-unit id="8ea1895411f30c25b0c4e8a493357838af36b14b" translate="yes" xml:space="preserve">
          <source>In other words, patterns are allowed only on the left side of &lt;code&gt;=&lt;/code&gt;. The right side of &lt;code&gt;=&lt;/code&gt; follows the regular evaluation semantics of the language.</source>
          <target state="translated">Другими словами, шаблоны разрешены только в левой части &lt;code&gt;=&lt;/code&gt; . Правая часть &lt;code&gt;=&lt;/code&gt; соответствует обычной семантике оценки языка.</target>
        </trans-unit>
        <trans-unit id="6de004f8f04712ff0ec3d814c33ef7cd9f1fbc8d" translate="yes" xml:space="preserve">
          <source>In other words, the atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; can only be written with the code points &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt;. Using another normalization form will lead to a tokenizer error. On the other hand, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; may be written as &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; or &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt;, since it is written between quotes.</source>
          <target state="translated">Другими словами, атом &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; можно записать только с кодовыми точками &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; . Использование другой формы нормализации приведет к ошибке токенизатора. С другой стороны &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; может быть записано как &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; или &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt; , поскольку оно написано между кавычками.</target>
        </trans-unit>
        <trans-unit id="c5f854e2205df45f6200d8840717b4a209cfb3ea" translate="yes" xml:space="preserve">
          <source>In other words, the environment key &lt;code&gt;:db_host&lt;/code&gt; for application &lt;code&gt;:my_app&lt;/code&gt; will only be read when &lt;code&gt;MyApp.DBClient&lt;/code&gt; effectively starts. While reading the application environment at runtime is the preferred approach, in some rare occasions you may want to use the application environment to configure the compilation of a certain project. This is often done by calling &lt;a href=&quot;#get_env/3&quot;&gt;&lt;code&gt;get_env/3&lt;/code&gt;&lt;/a&gt; outside of a function:</source>
          <target state="translated">Другими словами, ключ среды &lt;code&gt;:db_host&lt;/code&gt; для application &lt;code&gt;:my_app&lt;/code&gt; будет прочитан только при эффективном запуске &lt;code&gt;MyApp.DBClient&lt;/code&gt; . Хотя чтение среды приложения во время выполнения является предпочтительным подходом, в некоторых редких случаях вы можете использовать среду приложения для настройки компиляции определенного проекта. Часто это делается путем вызова &lt;a href=&quot;#get_env/3&quot;&gt; &lt;code&gt;get_env/3&lt;/code&gt; &lt;/a&gt; вне функции:</target>
        </trans-unit>
        <trans-unit id="a46592ea6e94de48f6246d5ad4aa9e7f178675e1" translate="yes" xml:space="preserve">
          <source>In other words, the expression above simply translates to:</source>
          <target state="translated">Другими словами,вышеприведенное выражение просто переводится:</target>
        </trans-unit>
        <trans-unit id="39fc76a1a41dfb78eff4ab58bbe78f4df61a48df" translate="yes" xml:space="preserve">
          <source>In other words, there are multiple ways systems can be deployed and releases can be automated and incorporated into all of them as long as you remember to build the system in the same target triple.</source>
          <target state="translated">Другими словами,существует множество способов развертывания систем и выпуска релизов,которые можно автоматизировать и включить во все из них,если вы не забыли построить систему в одной целевой тройке.</target>
        </trans-unit>
        <trans-unit id="cf94a3991ed1b9e98b23fc9feebaf13e89fbcbfd" translate="yes" xml:space="preserve">
          <source>In other words, this function tries to strip the &lt;code&gt;from&lt;/code&gt; prefix from &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Другими словами, эта функция пытается обирать &lt;code&gt;from&lt;/code&gt; приставкой от &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44dd0ca7035bd0b6e8100243c91751e16aa983c2" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">Другими словами, этот модуль ожидает, что недопустимые данные будут обнаружены где-то еще, обычно при извлечении данных из внешнего источника. Например, драйвер, считывающий строки из базы данных, будет отвечать за проверку правильности кодировки. &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt; можно использовать для разбиения строки на допустимые и недопустимые части.</target>
        </trans-unit>
        <trans-unit id="05304a75e275a349e9ffa834cabff9641ce49488" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;string#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">Другими словами, этот модуль ожидает, что недопустимые данные будут обнаружены где-то еще, обычно при извлечении данных из внешнего источника. Например, драйвер, считывающий строки из базы данных, будет отвечать за проверку правильности кодировки. &lt;a href=&quot;string#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt; можно использовать для разбиения строки на допустимые и недопустимые части.</target>
        </trans-unit>
        <trans-unit id="558d46588b101dc23bc0d5fd0f4acaf2b4c0f74f" translate="yes" xml:space="preserve">
          <source>In other words, we converted each expression given to &lt;code&gt;case/2&lt;/code&gt; as a step in &lt;code&gt;with&lt;/code&gt;. As soon as any of the steps return something that does not match &lt;code&gt;{:ok, x}&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; aborts, and returns the non-matching value.</source>
          <target state="translated">Другими словами, мы преобразовали каждое выражение , приведенное в &lt;code&gt;case/2&lt;/code&gt; в качестве шага в &lt;code&gt;with&lt;/code&gt; . Как только любой из шагов возвращает что-то, что не соответствует &lt;code&gt;{:ok, x}&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; прерыванием и возвращает несоответствующее значение.</target>
        </trans-unit>
        <trans-unit id="9b5785a062ee13450968c9614ec6ca20310e34ad" translate="yes" xml:space="preserve">
          <source>In other words, we want the registry to keep on running even if a bucket crashes. Let&amp;rsquo;s write a new registry test:</source>
          <target state="translated">Другими словами, мы хотим, чтобы реестр продолжал работать даже в случае сбоя корзины. Напишем новый тест реестра:</target>
        </trans-unit>
        <trans-unit id="eae49db7d30fd64b6cfb19732b20c2216ea90d4c" translate="yes" xml:space="preserve">
          <source>In other words, what we would expect to be a single character, such as &lt;code&gt;&amp;eacute;&lt;/code&gt; or &lt;code&gt;ł&lt;/code&gt;, can in practice be multiple characters, each represented by potentially multiple bytes. Consider the following:</source>
          <target state="translated">Другими словами, то, что мы ожидали бы быть одним символом, например &lt;code&gt;&amp;eacute;&lt;/code&gt; или &lt;code&gt;ł&lt;/code&gt; , на практике может быть несколькими символами, каждый из которых потенциально представлен несколькими байтами. Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="32be3988a4bf49863fd56d4a7249dcf02990b46b" translate="yes" xml:space="preserve">
          <source>In other words, when invoked as:</source>
          <target state="translated">Другими словами,при вызове как:</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">Другими словами:</target>
        </trans-unit>
        <trans-unit id="49d20f893de0acff7f5dc08503dbde4a71a0e1bc" translate="yes" xml:space="preserve">
          <source>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</source>
          <target state="translated">В частности,charlists по умолчанию будет распечатан обратно в одинарных кавычках,если они содержат только печатаемые ASCII-символы:</target>
        </trans-unit>
        <trans-unit id="3467114e6e90f4dae7f2e188d401c44475293e7c" translate="yes" xml:space="preserve">
          <source>In practice, charlists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="translated">На практике списки символов используются в основном при взаимодействии с Erlang, в частности, старые библиотеки, которые не принимают двоичные файлы в качестве аргументов. Вы можете преобразовать список символов в строку и обратно с помощью &lt;code&gt;to_string/1&lt;/code&gt; и &lt;code&gt;to_charlist/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b004abb70250b3f1e68f41dcfedc223284b584eb" translate="yes" xml:space="preserve">
          <source>In practice, however, Elixir developers rarely use the &lt;code&gt;try/rescue&lt;/code&gt; construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a &lt;code&gt;File.read/1&lt;/code&gt; function which returns a tuple containing information about whether the file was opened successfully:</source>
          <target state="translated">Однако на практике разработчики Elixir редко используют конструкцию &lt;code&gt;try/rescue&lt;/code&gt; . Например, многие языки заставят вас исправить ошибку, если файл не может быть успешно открыт. Вместо этого в Elixir есть функция &lt;code&gt;File.read/1&lt;/code&gt; , которая возвращает кортеж, содержащий информацию об успешном открытии файла:</target>
        </trans-unit>
        <trans-unit id="8e292cda7fd341df2ad10ad68515a260c1f9ceca" translate="yes" xml:space="preserve">
          <source>In practice, if you find yourself in a position where you need a process registry for dynamic processes, you should use &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;the &lt;code&gt;Registry&lt;/code&gt; module&lt;/a&gt; provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + &lt;code&gt;:ets&lt;/code&gt; while also being able to perform both writes and reads concurrently. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;It has been benchmarked to scale across all cores even on machines with 40 cores&lt;/a&gt;.</source>
          <target state="translated">На практике, если вы окажетесь в положении , когда вам нужен реестр процесса для динамических процессов, следует использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;в &lt;code&gt;Registry&lt;/code&gt; модуль&lt;/a&gt; поставляется как часть эликсира. Он обеспечивает функциональность, аналогичную той, которую мы создали с использованием GenServer + &lt;code&gt;:ets&lt;/code&gt; , а также возможность одновременного выполнения операций записи и чтения. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;Он был протестирован на масштабирование для всех ядер даже на машинах с 40 ядрами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db0e725bf7fce8e6792fe7c1b5f4904976e1c8d" translate="yes" xml:space="preserve">
          <source>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</source>
          <target state="translated">На практике принято иметь в одном модуле как серверную,так и клиентскую функции.Если реализация сервера и/или клиента становится все более сложной,возможно,вы захотите,чтобы они находились в разных модулях.</target>
        </trans-unit>
        <trans-unit id="70101e1c300d630f1ea86765138df21a3dc6ed93" translate="yes" xml:space="preserve">
          <source>In practice, it is more likely you will reach the Erlang</source>
          <target state="translated">На практике,более вероятно,что вы доберетесь до Эрланга.</target>
        </trans-unit>
        <trans-unit id="cafbb493cd44c8e665619ace61e6011a8cdce243" translate="yes" xml:space="preserve">
          <source>In practice, our tools always start our applications for us, but there is an API available if you need fine-grained control.</source>
          <target state="translated">На практике,наши инструменты всегда запускают наши приложения для нас,но есть API,если вам нужен тонкий контроль.</target>
        </trans-unit>
        <trans-unit id="c83f942e405f3eb5ce3163220a02a8f1db134d20" translate="yes" xml:space="preserve">
          <source>In practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.</source>
          <target state="translated">На практике мы не ожидаем,что процессы,работающие как ведра,выйдут из строя.Но,если это все же произойдет,по какой бы то ни было причине,мы можем быть уверены,что наша система будет продолжать работать так,как и планировалось.</target>
        </trans-unit>
        <trans-unit id="bcd76319c1bff6236a950ae66cde047b189b7040" translate="yes" xml:space="preserve">
          <source>In practice, you rarely load applications by hand because that is part of the start process, explained next.</source>
          <target state="translated">На практике,вы редко загружаете приложения вручную,потому что это часть процесса запуска,объяснено далее.</target>
        </trans-unit>
        <trans-unit id="719d5c0677afb6db6737335d9338844042ab8998" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix-like systems. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">В редких случаях эта функция может не работать в Unix-подобных системах. Это может произойти, если разрешения на чтение не существуют для родительских каталогов текущего каталога. По этой причине в случае успеха возвращает &lt;code&gt;{:ok, cwd}&lt;/code&gt; в противном случае - &lt;code&gt;{:error, reason}&lt;/code&gt; cause} .</target>
        </trans-unit>
        <trans-unit id="b81ae9e0c2bb006469e999756d7c827614795f38" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">В редких случаях эта функция может не работать в Unix. Это может произойти, если разрешения на чтение не существуют для родительских каталогов текущего каталога. По этой причине в случае успеха возвращает &lt;code&gt;{:ok, cwd}&lt;/code&gt; в противном случае - &lt;code&gt;{:error, reason}&lt;/code&gt; cause} .</target>
        </trans-unit>
        <trans-unit id="acd5d3b4600c9d05bb359546d1009f1e407c770b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">В установленной записи: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f49cbc94b22c26f24f368405117b1889a3c176b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">В обозначении набора: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2ccee93d894b5296828c59c78b91159cd164712" translate="yes" xml:space="preserve">
          <source>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the &lt;code&gt;@fallback_to_any&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">В некоторых случаях может быть удобно предоставить реализацию по умолчанию для всех типов. Этого можно добиться, установив для атрибута &lt;code&gt;@fallback_to_any&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; в определении протокола:</target>
        </trans-unit>
        <trans-unit id="371305821a86a1fd6063efb5d024b0464bdede1a" translate="yes" xml:space="preserve">
          <source>In some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing &lt;code&gt;[1, 2, 6]&lt;/code&gt; and we want to inject &lt;code&gt;[3, 4, 5]&lt;/code&gt; into it. Using &lt;code&gt;unquote&lt;/code&gt; won&amp;rsquo;t yield the desired result:</source>
          <target state="translated">В некоторых случаях может потребоваться ввести много значений в список. Например, представьте, что у вас есть список, содержащий &lt;code&gt;[1, 2, 6]&lt;/code&gt; и мы хотим вставить в него &lt;code&gt;[3, 4, 5]&lt;/code&gt; . Использование &lt;code&gt;unquote&lt;/code&gt; не даст желаемого результата:</target>
        </trans-unit>
        <trans-unit id="606ff8e75aa81c7c8c049f5b60f58898dddc0286" translate="yes" xml:space="preserve">
          <source>In some cases, this may lead to undesired formatting. Therefore, &lt;strong&gt;some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer&lt;/strong&gt;. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</source>
          <target state="translated">В некоторых случаях это может привести к нежелательному форматированию. Поэтому &lt;strong&gt;некоторый код, сгенерированный средством форматирования, может быть не эстетичным и может потребовать явного вмешательства со стороны разработчика&lt;/strong&gt; . Вот почему мы не рекомендуем запускать форматировщик вслепую в существующей кодовой базе. Вместо этого вам следует отформатировать и проверить работоспособность каждого отформатированного файла.</target>
        </trans-unit>
        <trans-unit id="e9e037bc0aa6cd7738573dffae9758c75aa58f06" translate="yes" xml:space="preserve">
          <source>In some cases, you don&amp;rsquo;t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, &lt;code&gt;_&lt;/code&gt;. For example, if only the head of the list matters to us, we can assign the tail to underscore:</source>
          <target state="translated">В некоторых случаях вас не волнует конкретное значение в шаблоне. Обычно эти значения привязываются к символу подчеркивания &lt;code&gt;_&lt;/code&gt; . Например, если для нас важен только заголовок списка, мы можем назначить хвост для подчеркивания:</target>
        </trans-unit>
        <trans-unit id="4bf473ae676eadb3b6d9002d5044ddc6e88467a0" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to inject such &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;quoted expressions&lt;/em&gt;. To do that, we need to first escape those values into quoted expressions with the help of &lt;code&gt;Macro.escape/1&lt;/code&gt;:</source>
          <target state="translated">В некоторых случаях вам может потребоваться вставить такие &lt;em&gt;значения&lt;/em&gt; в &lt;em&gt;цитируемые выражения&lt;/em&gt; . Для этого нам нужно сначала преобразовать эти значения в цитируемые выражения с помощью &lt;code&gt;Macro.escape/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f72fba3c3196c1696a309102e4d11fa8e7e9ddc2" translate="yes" xml:space="preserve">
          <source>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the &lt;code&gt;alias!&lt;/code&gt; macro:</source>
          <target state="translated">В некоторых случаях вы хотите получить доступ к псевдониму или модулю, определенному в вызывающей стороне. Для таких можно использовать &lt;code&gt;alias!&lt;/code&gt; макрос:</target>
        </trans-unit>
        <trans-unit id="ba5d8febe75db79d78b1632bb42524ac427524c5" translate="yes" xml:space="preserve">
          <source>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</source>
          <target state="translated">В некоторых ситуациях можно использовать тот факт,что форматировщик не генерирует элегантный код в качестве подсказки для рефакторинга.Возьмите этот код:</target>
        </trans-unit>
        <trans-unit id="fa2a12aa6aedffdc527ed2aeaa4a499eafdd3bd3" translate="yes" xml:space="preserve">
          <source>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В таких случаях разработчики должны вместо этого напрямую импортировать или использовать псевдоним модуля, чтобы они могли настраивать их по своему усмотрению, без косвенного указания на &lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="459d38c03bf669f90bbbe671db50188607d62696" translate="yes" xml:space="preserve">
          <source>In such cases, using the capture operator is no different than using &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">В таких случаях использование оператора захвата ничем не отличается от использования &lt;code&gt;fn&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
