<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="91158d4ebf885b7c2cce115618384afcd3d60c6c" translate="yes" xml:space="preserve">
          <source>Not italic.</source>
          <target state="translated">Не курсив.</target>
        </trans-unit>
        <trans-unit id="e8cbaff7c13d97516b633b0d9d10f2ab0d66c800" translate="yes" xml:space="preserve">
          <source>Not only that, as you create new buckets on the terminal, you should see new processes spawned in the supervision tree shown in Observer:</source>
          <target state="translated">Мало того,что по мере создания новых ведер на терминале,в дереве наблюдения,показанном в Observer,должны появляться новые процессы:</target>
        </trans-unit>
        <trans-unit id="8ece420ef660602018d9d85c815c1206e83a9313" translate="yes" xml:space="preserve">
          <source>Not overlined.</source>
          <target state="translated">Не перекрыт.</target>
        </trans-unit>
        <trans-unit id="12d014121a6d98d766e19560d6f8af18c0e40cbc" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;Process.monitor(pid)&lt;/code&gt; returns a unique reference that allows us to match upcoming messages to that monitoring reference. After we stop the agent, we can &lt;code&gt;flush/0&lt;/code&gt; all messages and notice a &lt;code&gt;:DOWN&lt;/code&gt; message arrived, with the exact reference returned by &lt;code&gt;monitor&lt;/code&gt;, notifying that the bucket process exited with reason &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">Примечание. &lt;code&gt;Process.monitor(pid)&lt;/code&gt; возвращает уникальную ссылку, которая позволяет нам сопоставлять предстоящие сообщения с этой ссылкой мониторинга. После остановки агента мы можем &lt;code&gt;flush/0&lt;/code&gt; все сообщения и заметить, что пришло сообщение &lt;code&gt;:DOWN&lt;/code&gt; с точной ссылкой, возвращенной &lt;code&gt;monitor&lt;/code&gt; , уведомляющей о том, что процесс корзины завершился по причине &lt;code&gt;:normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de7935fb5d91c63f4d9cbe857464e2239ca741ed" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;[head | tail]&lt;/code&gt; does not match empty lists:</source>
          <target state="translated">Примечание &lt;code&gt;[head | tail]&lt;/code&gt; не соответствует пустым спискам:</target>
        </trans-unit>
        <trans-unit id="fb3f40b5039d7c318694befb342ce3f4c9f0f60a" translate="yes" xml:space="preserve">
          <source>Note a tag can be set in two different ways:</source>
          <target state="translated">Обратите внимание,что тег может быть установлен двумя различными способами:</target>
        </trans-unit>
        <trans-unit id="c3377b2b2eb71be892a3e682ccebe7f9b31d7572" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;:transient&lt;/code&gt; type is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;:shutdown&lt;/code&gt;, not &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что тип &lt;code&gt;:transient&lt;/code&gt; имеет мало практического применения, так как, когда дерево наблюдения завершается, причина устанавливается в &lt;code&gt;:shutdown&lt;/code&gt; , а не &lt;code&gt;:normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c528946c2af34a0e5a1e8d711f96487c6c795447" translate="yes" xml:space="preserve">
          <source>Note anonymous functions can also have multiple clauses and guards:</source>
          <target state="translated">Обратите внимание,что анонимные функции могут также иметь несколько пунктов и охранников:</target>
        </trans-unit>
        <trans-unit id="a47f7c7dcfbb9a451fa8f8f1b6ccc971c2608e3d" translate="yes" xml:space="preserve">
          <source>Note by default Mix releases supports runtime configuration via a &lt;code&gt;config/runtime.exs&lt;/code&gt;. If a &lt;code&gt;config/runtime.exs&lt;/code&gt; exists in your application, it is automatically copied inside the release and automatically set as a config provider.</source>
          <target state="translated">Обратите внимание: по умолчанию выпуски Mix поддерживают настройку среды выполнения через &lt;code&gt;config/runtime.exs&lt;/code&gt; . Если в вашем приложении существует файл &lt;code&gt;config/runtime.exs&lt;/code&gt; , он автоматически копируется в выпуск и автоматически устанавливается в качестве поставщика конфигурации.</target>
        </trans-unit>
        <trans-unit id="3d3adc9c8853ececa9befa7c8ce8ff49c5919675" translate="yes" xml:space="preserve">
          <source>Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, developers should build on top of named setups. For example:</source>
          <target state="translated">Обратите внимание,что блоки не могут быть вложены.Вместо того,чтобы полагаться на иерархию для составления описания,разработчики должны опираться на именованные установки.Например:</target>
        </trans-unit>
        <trans-unit id="e1825e354b3ce5f016786c4903b91e7f6fa4d294" translate="yes" xml:space="preserve">
          <source>Note designations for year, month, day, and the like, are overspecified (i.e. an integer instead of &lt;code&gt;1..12&lt;/code&gt; for months) because different calendars may have a different number of days per month, months per year and so on.</source>
          <target state="translated">Обозначения заметок для года, месяца, дня и т. П. Заданы чрезмерно (т.е. целое число вместо &lt;code&gt;1..12&lt;/code&gt; для месяцев), потому что разные календари могут иметь разное количество дней в месяц, месяцев в году и так далее.</target>
        </trans-unit>
        <trans-unit id="a5ca0f4688d0116095aeec4a9d739e406b9afeec" translate="yes" xml:space="preserve">
          <source>Note each entry in the binary pattern is expected to match exactly 8 bits. If we want to match on a binary of unknown size, it is possible by using the binary modifier at the end of the pattern:</source>
          <target state="translated">Обратите внимание,что каждая запись в двоичном шаблоне должна точно совпадать с 8 битами.Если мы хотим получить совпадение с бинаром неизвестного размера,то это можно сделать с помощью бинарного модификатора в конце шаблона:</target>
        </trans-unit>
        <trans-unit id="fde64f5bd0b64f802365ea88627dc67abb203122" translate="yes" xml:space="preserve">
          <source>Note each release definition can be given as an anonymous function. This is useful if some release attributes are expensive to compute:</source>
          <target state="translated">Обратите внимание,что каждое определение версии может быть дано как анонимная функция.Это полезно,если некоторые атрибуты релиза дороги для вычисления:</target>
        </trans-unit>
        <trans-unit id="7f5cc73ccd142703d404f49e852f936b5ae2bdd1" translate="yes" xml:space="preserve">
          <source>Note it is generally not advised to use &lt;code&gt;\xNN&lt;/code&gt; in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as &lt;code&gt;\uNNNN&lt;/code&gt;. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.</source>
          <target state="translated">Обратите внимание, что обычно не рекомендуется использовать &lt;code&gt;\xNN&lt;/code&gt; в строках Elixir, так как введение недопустимой последовательности байтов сделает строку недействительной. Если вам нужно ввести символ в его шестнадцатеричном представлении, лучше всего работать с кодовыми точками Unicode, такими как &lt;code&gt;\uNNNN&lt;/code&gt; . Фактически, понимание кодовых точек Unicode может быть важным при выполнении низкоуровневых манипуляций со строкой, поэтому давайте рассмотрим их подробнее далее.</target>
        </trans-unit>
        <trans-unit id="e1393c185477299f5e854d4848419bacfa99c239" translate="yes" xml:space="preserve">
          <source>Note it is important to recompile a file's dependencies as there are often compile time dependencies between them.</source>
          <target state="translated">Обратите внимание,что важно перекомпилировать зависимости файла,так как между ними часто встречаются зависимости по времени компиляции.</target>
        </trans-unit>
        <trans-unit id="427d850ea29351ec5b9c38bb55119b54d0306d63" translate="yes" xml:space="preserve">
          <source>Note that &quot;config/config.exs&quot; is always loaded automatically by the Mix CLI when it boots. &quot;config/runtime.exs&quot; is loaded automatically by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.App.Config.html&quot;&gt;&lt;code&gt;mix app.config&lt;/code&gt;&lt;/a&gt; before starting the current application. Therefore there is no need to load those config files directly.</source>
          <target state="translated">Обратите внимание, что &quot;config / config.exs&quot; всегда автоматически загружается Mix CLI при загрузке. config / runtime.exs загружается автоматически с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.App.Config.html&quot;&gt; &lt;code&gt;mix app.config&lt;/code&gt; &lt;/a&gt; перед запуском текущего приложения. Следовательно, нет необходимости загружать эти файлы конфигурации напрямую.</target>
        </trans-unit>
        <trans-unit id="127cdeb36c75a2e9ea3ccb032068074d455163d3" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt; is typically invoked very early in the boot process, therefore if you need to use an application in the provider, it is your responsibility to start it.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt; обычно вызывается очень рано в процессе загрузки, поэтому, если вам нужно использовать приложение в поставщике, вы обязаны запустить его.</target>
        </trans-unit>
        <trans-unit id="98fcc4c0b233355a84f821a3c513063ad4e24444" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt; can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the &lt;code&gt;from&lt;/code&gt; argument somehow).</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt; может быть вызван из любого процесса, а не только из GenServer, который первоначально получил вызов (если этот GenServer каким-то образом передал аргумент &lt;code&gt;from&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2d02d2557aff8e189d210c2d08f3cf6abe1f8379" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;.&lt;/code&gt; is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom:</source>
          <target state="translated">Обратите внимание на это &lt;code&gt;.&lt;/code&gt; тоже оператор. Удаленные вызовы используют точку в AST с двумя аргументами, где второй аргумент всегда является атомом:</target>
        </trans-unit>
        <trans-unit id="e1626fef0c1a33798d2c34dfc74515bf8d5c377d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;String.t()&lt;/code&gt; и &lt;code&gt;binary()&lt;/code&gt; эквивалентны инструментам анализа. Хотя для тех, кто читает документацию, &lt;code&gt;String.t()&lt;/code&gt; подразумевает, что это двоичный код в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="8ceb120a9be7ed748230ca821c05f6918e48cd56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\\&lt;/code&gt; can't be used with anonymous functions because they can only have a sole arity.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\\&lt;/code&gt; нельзя использовать с анонимными функциями, потому что они могут иметь только единственную арность.</target>
        </trans-unit>
        <trans-unit id="284b6400c5d9fc089c636125d995e2b0e56e6990" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;^x&lt;/code&gt; always refers to the value of &lt;code&gt;x&lt;/code&gt; prior to the match. The following example will match:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;^x&lt;/code&gt; всегда относится к значению &lt;code&gt;x&lt;/code&gt; до совпадения. Следующий пример будет соответствовать:</target>
        </trans-unit>
        <trans-unit id="2319e8ea6dc2453b7cac37ef1761f4dadaf1a473" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;__STACKTRACE__&lt;/code&gt; can be used inside catch/rescue to retrieve the current stacktrace.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;__STACKTRACE__&lt;/code&gt; можно использовать внутри catch / rescue для получения текущей трассировки стека.</target>
        </trans-unit>
        <trans-unit id="c1877a8124459f28213b53d05b5f96adf2e6ee0c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;alias&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt;, which allows you to set aliases inside specific functions:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;alias&lt;/code&gt; имеет &lt;strong&gt;лексическую область видимости&lt;/strong&gt; , что позволяет вам устанавливать псевдонимы внутри определенных функций:</target>
        </trans-unit>
        <trans-unit id="5684572f42db95ac181baf9058ba1bcc12e51cad" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cast&lt;/code&gt; returns &lt;code&gt;:ok&lt;/code&gt; immediately, regardless of whether &lt;code&gt;agent&lt;/code&gt; (or the node it should live on) exists.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;cast&lt;/code&gt; немедленно возвращает &lt;code&gt;:ok&lt;/code&gt; , независимо от того, существует ли &lt;code&gt;agent&lt;/code&gt; (или узел, на котором он должен работать).</target>
        </trans-unit>
        <trans-unit id="c5c4acc72c847b14f34cef90da2dbdafe8c0f864" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;defines?&lt;/code&gt; returns false for functions and macros that have been defined but then marked as overridable and no other implementation has been provided. You can check the overridable status by calling &lt;a href=&quot;#overridable?/2&quot;&gt;&lt;code&gt;overridable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;defines?&lt;/code&gt; возвращает false для функций и макросов, которые были определены, но затем помечены как переопределяемые, и никакой другой реализации не было предоставлено. Вы можете проверить статус переопределения, вызвав &lt;a href=&quot;#overridable?/2&quot;&gt; &lt;code&gt;overridable?/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90f8221caf1663dc39261548c92a478da7147d51" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;do/end&lt;/code&gt; become delimiters. The second example would translate to:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;do/end&lt;/code&gt; становятся разделителями. Второй пример можно перевести как:</target>
        </trans-unit>
        <trans-unit id="d9f98e56a6b073dedf21c4fd7053a53e9bd1aea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt; too. This means that we can import specific macros or functions inside function definitions:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;import&lt;/code&gt; имеет &lt;strong&gt;лексическую область видимости&lt;/strong&gt; . Это означает, что мы можем импортировать определенные макросы или функции внутри определений функций:</target>
        </trans-unit>
        <trans-unit id="7d91cdd66170ee21978845d99279b84980730cb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt;ing a module automatically &lt;code&gt;require&lt;/code&gt;s it.</source>
          <target state="translated">Обратите внимание, что для &lt;code&gt;import&lt;/code&gt; модуля он &lt;code&gt;require&lt;/code&gt; автоматически .</target>
        </trans-unit>
        <trans-unit id="ab30e5a1bc4b404e7cb3f7adf25fbc460e6c3561" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;index&lt;/code&gt; is capped at the list length. Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;index&lt;/code&gt; ограничен длиной списка. Отрицательные индексы указывают на смещение от конца &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12525ea5b78a44ac5eef68af6cc8e0ed2ce006ea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;serve/1&lt;/code&gt; is an infinite loop called sequentially inside &lt;code&gt;loop_acceptor/1&lt;/code&gt;, so the tail call to &lt;code&gt;loop_acceptor/1&lt;/code&gt; is never reached and could be avoided. However, as we shall see, we will need to execute &lt;code&gt;serve/1&lt;/code&gt; in a separate process, so we will need that tail call soon.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;serve/1&lt;/code&gt; - это бесконечный цикл, который последовательно &lt;code&gt;loop_acceptor/1&lt;/code&gt; внутри loop_acceptor / 1 , поэтому хвостовой вызов &lt;code&gt;loop_acceptor/1&lt;/code&gt; никогда не достигается, и его можно избежать. Однако, как мы увидим, нам нужно будет выполнить &lt;code&gt;serve/1&lt;/code&gt; в отдельном процессе, поэтому нам скоро понадобится этот хвостовой вызов.</target>
        </trans-unit>
        <trans-unit id="de063b80d08dcad20f96832929534bd43e718138" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; started with &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the &lt;code&gt;:normal&lt;/code&gt; reasons in case it is configured to trap exits in the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; ,&lt;/a&gt; запущенный с &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; , связан с родительским процессом и выйдет из него в случае сбоя родительского процесса. GenServer также завершит работу по &lt;code&gt;:normal&lt;/code&gt; причинам, если он настроен на перехват выходов в обратном вызове &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08443544f9b5807d8ae2ca59e1cdfa2a987f5f51" translate="yes" xml:space="preserve">
          <source>Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with &lt;code&gt;:normal&lt;/code&gt; reason.</source>
          <target state="translated">Обратите внимание, что супервизор, запущенный с помощью этой функции, связан с родительским процессом и завершает работу не только при сбоях, но также и в случае завершения родительского процесса с &lt;code&gt;:normal&lt;/code&gt; причиной.</target>
        </trans-unit>
        <trans-unit id="954d4540ce99f199a6a0a382f7d567881ea15fd5" translate="yes" xml:space="preserve">
          <source>Note that all Elixir operators are also valid atoms. Therefore &lt;code&gt;:+&lt;/code&gt;, &lt;code&gt;:@&lt;/code&gt;, &lt;code&gt;:|&amp;gt;&lt;/code&gt;, and others are all valid atoms. The full description of valid atoms is available in the Syntax Reference, this document covers only the rules for identifier-based atoms.</source>
          <target state="translated">Обратите внимание, что все операторы Elixir также являются допустимыми атомами. Поэтому &lt;code&gt;:+&lt;/code&gt; , &lt;code&gt;:@&lt;/code&gt; , &lt;code&gt;:|&amp;gt;&lt;/code&gt; , и другие являются все действительные атомы. Полное описание допустимых атомов доступно в Справочнике по синтаксису, этот документ охватывает только правила для атомов на основе идентификаторов.</target>
        </trans-unit>
        <trans-unit id="59807d7115e84e3f04fec688f18ad915d1e01400" translate="yes" xml:space="preserve">
          <source>Note that all metadata is optional and may not always be available. The &lt;code&gt;:mfa&lt;/code&gt;, &lt;code&gt;:file&lt;/code&gt;, &lt;code&gt;:line&lt;/code&gt;, and similar metadata are automatically included when using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; macros. &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt; does not include any metadata beyond the &lt;code&gt;:pid&lt;/code&gt; by default. Other metadata, such as &lt;code&gt;:crash_reason&lt;/code&gt;, &lt;code&gt;:initial_call&lt;/code&gt;, and &lt;code&gt;:registered_name&lt;/code&gt; are available only inside behaviours such as GenServer, Supervisor, and others.</source>
          <target state="translated">Обратите внимание, что все метаданные необязательны и не всегда могут быть доступны. &lt;code&gt;:mfa&lt;/code&gt; , &lt;code&gt;:file&lt;/code&gt; , &lt;code&gt;:line&lt;/code&gt; , и подобные метаданные автоматически включаются при использовании &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; макросов. &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt; по умолчанию не включает никаких метаданных, кроме &lt;code&gt;:pid&lt;/code&gt; . Другие метаданные, такие как &lt;code&gt;:crash_reason&lt;/code&gt; , &lt;code&gt;:initial_call&lt;/code&gt; и &lt;code&gt;:registered_name&lt;/code&gt; доступны только внутри поведения , таких как GenServer, руководитель и другие.</target>
        </trans-unit>
        <trans-unit id="ac0b3ec8f1db4589a8f8e1eb136c0f7227194b62" translate="yes" xml:space="preserve">
          <source>Note that all metadata is optional and may not always be available. The &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:function&lt;/code&gt;, &lt;code&gt;:line&lt;/code&gt;, and similar metadata are automatically included when using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; macros. &lt;a href=&quot;logger#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt; does not include any metadata beyond the &lt;code&gt;:pid&lt;/code&gt; by default. Other metadata, such as &lt;code&gt;:crash_reason&lt;/code&gt;, &lt;code&gt;:initial_call&lt;/code&gt;, and &lt;code&gt;:registered_name&lt;/code&gt; are extracted from Erlang/OTP crash reports and available only in those cases.</source>
          <target state="translated">Обратите внимание, что все метаданные необязательны и не всегда могут быть доступны. &lt;code&gt;:module&lt;/code&gt; , &lt;code&gt;:function&lt;/code&gt; , &lt;code&gt;:line&lt;/code&gt; , и подобные метаданные автоматически включаются при использовании &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; макросов. &lt;a href=&quot;logger#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt; по умолчанию не включает никаких метаданных, кроме &lt;code&gt;:pid&lt;/code&gt; . Другие метаданные, такие как &lt;code&gt;:crash_reason&lt;/code&gt; , &lt;code&gt;:initial_call&lt;/code&gt; , и &lt;code&gt;:registered_name&lt;/code&gt; извлекаются из отчетов о сбоях Erlang / OTP и доступны только в тех случаях.</target>
        </trans-unit>
        <trans-unit id="76c7fd844c6a4b97c6af78f0323e658a0263e3d7" translate="yes" xml:space="preserve">
          <source>Note that all tests are included by default, so unless they are excluded first (either in the test helper or via the &lt;code&gt;--exclude&lt;/code&gt; option) the &lt;code&gt;--include&lt;/code&gt; option has no effect.</source>
          <target state="translated">Обратите внимание, что все тесты включены по умолчанию, поэтому, если они не были исключены первыми (либо в помощнике тестирования, либо с помощью параметра &lt;code&gt;--exclude&lt;/code&gt; ), параметр &lt;code&gt;--include&lt;/code&gt; не действует.</target>
        </trans-unit>
        <trans-unit id="764accc79b7e7fbac8971b738cd4bab00fe7637c" translate="yes" xml:space="preserve">
          <source>Note that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">Обратите внимание,что поток ввода-вывода имеет побочные эффекты и каждый раз,когда вы проходите по потоку,вы можете получить разные результаты.</target>
        </trans-unit>
        <trans-unit id="edad52b62a5c2594d2df1d229d1b57a6b8821bde" translate="yes" xml:space="preserve">
          <source>Note that both UTC and Standard offsets will be taken into account when comparison is done.</source>
          <target state="translated">Обратите внимание,что при сравнении будут учитываться как UTC,так и стандартные смещения.</target>
        </trans-unit>
        <trans-unit id="e39927967b57d902ab4163f9f2cb6338d710bb58" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;code&gt;alias&lt;/code&gt; without the &lt;code&gt;:as&lt;/code&gt; option automatically sets an alias based on the last part of the module. For example:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;alias&lt;/code&gt; вызова без опции &lt;code&gt;:as&lt;/code&gt; автоматически устанавливает псевдоним на основе последней части модуля. Например:</target>
        </trans-unit>
        <trans-unit id="dc0e0b9356beddc60c2573a3330e2dc896252a2e" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;code&gt;except&lt;/code&gt; is always exclusive on a previously declared &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt;. If there is no previous import, then it applies to all functions and macros in the module. For example:</source>
          <target state="translated">Обратите внимание, что вызов &lt;code&gt;except&lt;/code&gt; всегда эксклюзивен для ранее объявленного &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; . Если предыдущего импорта нет, он применяется ко всем функциям и макросам в модуле. Например:</target>
        </trans-unit>
        <trans-unit id="406fc1b32b85677464e45a089ad7df7b494e5b86" translate="yes" xml:space="preserve">
          <source>Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">Обратите внимание,что вызов этой функции при работе с большим количеством детей в условиях нехватки памяти может привести к исключению из памяти.</target>
        </trans-unit>
        <trans-unit id="810d95d9fca7c3168a855c66f8ec239c21983136" translate="yes" xml:space="preserve">
          <source>Note that different engines may have different rules for each tag. Other tags may be added in future versions.</source>
          <target state="translated">Обратите внимание,что разные двигатели могут иметь разные правила для каждого тега.Другие теги могут быть добавлены в будущих версиях.</target>
        </trans-unit>
        <trans-unit id="b1375989f15fb775da5bd1afcc5b55b1b8ca50c6" translate="yes" xml:space="preserve">
          <source>Note that doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">Обратите внимание, что у доктестов есть ограничения. Если вы не можете документально протестировать функцию, потому что она зависит от состояния или побочных эффектов, мы рекомендуем разработчикам включать примеры напрямую, без &lt;code&gt;iex&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fabe66319df854999ff8cf0e3d6fa8aaf6d30285" translate="yes" xml:space="preserve">
          <source>Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.</source>
          <target state="translated">Обратите внимание,что имена файлов,если они заданы в качестве чарлистов в Elixir'е,всегда рассматриваются как UTF-8.В частности,мы ожидаем,что оболочка и операционная система настроены на использование кодировки UTF-8.Двоичные имена файлов считаются необработанными и передаются операционной системе как есть.</target>
        </trans-unit>
        <trans-unit id="103cdbd91afa6836ea7762204d98d6131437f8ac" translate="yes" xml:space="preserve">
          <source>Note that for large registries with many partitions this will be costly as it builds the result by concatenating all the partitions.</source>
          <target state="translated">Обратите внимание,что для больших реестров с большим количеством разделов это будет дорогостоящим,так как это построит результат путем конкапсуляции всех разделов.</target>
        </trans-unit>
        <trans-unit id="f080d783bf0fd06342e1a61dcd384d6c89650c0e" translate="yes" xml:space="preserve">
          <source>Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children.</source>
          <target state="translated">Обратите внимание,что для временных детей спецификация ребенка автоматически удаляется,когда ребенок прекращает свое существование,и,таким образом,перезапустить таких детей невозможно.</target>
        </trans-unit>
        <trans-unit id="377cc6cbec36c42c5ad3eb7ca6f0b2467fdc4772" translate="yes" xml:space="preserve">
          <source>Note that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is invoked by different processes concurrently, the first process to invoke &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; acquires a lock and the remaining ones will block until the file is available. This means that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is called more than once with a given file, that file will be compiled only once. The first process to call &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; will get the list of loaded modules, others will get &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; вызывается разными процессами одновременно, первый процесс, вызывающий &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; ,&lt;/a&gt; получает блокировку, а остальные будут блокироваться до тех пор, пока файл не станет доступным. Это означает, что если &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; вызывается более одного раза с данным файлом, этот файл будет скомпилирован только один раз. Первый процесс, который вызовет &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; , получит список загруженных модулей, другие - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ac0f2db57c845b53edfac58671ccc0da1b912b7" translate="yes" xml:space="preserve">
          <source>Note that if a backend fails to start by returning &lt;code&gt;{:error, :ignore}&lt;/code&gt; from its &lt;code&gt;init/1&lt;/code&gt; callback, then it's not added to the backends but nothing fails. If a backend fails to start by returning &lt;code&gt;{:error, reason}&lt;/code&gt; from its &lt;code&gt;init/1&lt;/code&gt; callback, the &lt;code&gt;:logger&lt;/code&gt; application will fail to start.</source>
          <target state="translated">Обратите внимание, что если бэкэнд не запускается, возвращая &lt;code&gt;{:error, :ignore}&lt;/code&gt; из его обратного вызова &lt;code&gt;init/1&lt;/code&gt; , то он не добавляется в бэкенд, но ничего не происходит. Если бэкэнд не запускается, возвращая &lt;code&gt;{:error, reason}&lt;/code&gt; из его обратного вызова &lt;code&gt;init/1&lt;/code&gt; , приложение &lt;code&gt;:logger&lt;/code&gt; не запустится.</target>
        </trans-unit>
        <trans-unit id="997a3967a5f4bb658a4ce5f677487cb8a5c8fec2" translate="yes" xml:space="preserve">
          <source>Note that if a process is exiting, it is considered to exist but not be alive. This means that for such process, &lt;a href=&quot;#alive?/1&quot;&gt;&lt;code&gt;alive?/1&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; but its PID will be part of the list of PIDs returned by this function.</source>
          <target state="translated">Обратите внимание, что если процесс завершается, он считается существующим, но не живым. Это означает, что для такого процесса &lt;a href=&quot;#alive?/1&quot;&gt; &lt;code&gt;alive?/1&lt;/code&gt; &lt;/a&gt; вернет &lt;code&gt;false&lt;/code&gt; , но его PID будет частью списка PID, возвращаемого этой функцией.</target>
        </trans-unit>
        <trans-unit id="a43e287fde89bfb0a88b95e0c986594cfaffdabd" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;:delayed_write&lt;/code&gt; was used when opening the file, &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; might return an old write error and not even try to close the file. See &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Обратите внимание, что если при открытии файла использовалась опция &lt;code&gt;:delayed_write&lt;/code&gt; , &lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt; может вернуть старую ошибку записи и даже не пытаться закрыть файл. См. &lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="821ad9a9b64479995767f73e56a4365e2e36ccc1" translate="yes" xml:space="preserve">
          <source>Note that if you pass a &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct as first argument while also passing &lt;code&gt;opts&lt;/code&gt;, they will be merged with &lt;code&gt;opts&lt;/code&gt; having precedence.</source>
          <target state="translated">Обратите внимание , что если вы передаете &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; - структуру в качестве первого аргумента , а также прохождение &lt;code&gt;opts&lt;/code&gt; , они будут объединены с &lt;code&gt;opts&lt;/code&gt; имея преимущество.</target>
        </trans-unit>
        <trans-unit id="2f646c93d4eef7c70fd05d7240d6a69876a9baf5" translate="yes" xml:space="preserve">
          <source>Note that if you pass a &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct as first argument while also passing &lt;code&gt;opts&lt;/code&gt;, they will be merged with &lt;code&gt;opts&lt;/code&gt; having precedence.</source>
          <target state="translated">Обратите внимание, что если вы передаете структуру &lt;a href=&quot;macro.env&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; в&lt;/a&gt; качестве первого аргумента, одновременно передавая &lt;code&gt;opts&lt;/code&gt; , они будут объединены с &lt;code&gt;opts&lt;/code&gt; имеющими приоритет.</target>
        </trans-unit>
        <trans-unit id="64b52ff72a460cecc390aabeeeee6af670211c1b" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check &lt;a href=&quot;#get_and_update_in/2&quot;&gt;&lt;code&gt;get_and_update_in/2&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">Обратите внимание, что для того, чтобы этот макрос работал, полный путь должен всегда быть видимым для этого макроса. Дополнительные сведения о поддерживаемых выражениях пути см. В документации &lt;a href=&quot;#get_and_update_in/2&quot;&gt; &lt;code&gt;get_and_update_in/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b84e74a3f06c5b64c9f3f50fab344006da217376" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. See the &quot;Paths&quot; section below.</source>
          <target state="translated">Обратите внимание,что для того,чтобы данный макрос работал,полный путь всегда должен быть виден с помощью данного макроса.См.раздел &quot;Траектории&quot; ниже.</target>
        </trans-unit>
        <trans-unit id="9e49d404776bcbe0ae060a73286ea9c896eb6178" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. See the Paths section below.</source>
          <target state="translated">Обратите внимание,что для того,чтобы данный макрос работал,полный путь всегда должен быть виден с помощью данного макроса.См.раздел Контуры ниже.</target>
        </trans-unit>
        <trans-unit id="bcf88d15a7510f97dbf0ab0147120a93a4cb3ae1" translate="yes" xml:space="preserve">
          <source>Note that in our macro implementation, the sentence was not printed, although it was printed in our function implementation. That&amp;rsquo;s because the arguments to a function call are evaluated before calling the function. However, macros do not evaluate their arguments. Instead, they receive the arguments as quoted expressions which are then transformed into other quoted expressions. In this case, we have rewritten our &lt;code&gt;unless&lt;/code&gt; macro to become an &lt;code&gt;if&lt;/code&gt; behind the scenes.</source>
          <target state="translated">Обратите внимание, что в нашей реализации макроса предложение не было напечатано, хотя оно было напечатано в нашей реализации функции. Это потому, что аргументы вызова функции оцениваются перед вызовом функции. Однако макросы не оценивают свои аргументы. Вместо этого они получают аргументы в виде выражений в кавычках, которые затем преобразуются в другие выражения в кавычках. В этом случае, мы переписали не наш , &lt;code&gt;unless&lt;/code&gt; макрос , чтобы стать , &lt;code&gt;if&lt;/code&gt; за кулисами.</target>
        </trans-unit>
        <trans-unit id="3281f1a5f02ddec5e1056940255b1750f3ee3ceb" translate="yes" xml:space="preserve">
          <source>Note that in this case we don't have to explicitly import &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor.Spec&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;use Supervisor&lt;/code&gt; automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#c:init/1&quot;&gt;&lt;code&gt;Supervisor.init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Обратите внимание, что в этом случае нам не нужно явно импортировать &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor.Spec&lt;/code&gt; ,&lt;/a&gt; поскольку &lt;code&gt;use Supervisor&lt;/code&gt; делает это автоматически. Определение супервизора на основе модуля может быть полезно, например, для выполнения задач инициализации в &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#c:init/1&quot;&gt; &lt;code&gt;Supervisor.init/1&lt;/code&gt; &lt;/a&gt; вызове Supervisor.init / 1 .</target>
        </trans-unit>
        <trans-unit id="457d54652787a94a3f6b0231b5aed3d435010820" translate="yes" xml:space="preserve">
          <source>Note that inside this new IEx session, we cannot access &lt;code&gt;Hello.world/0&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что внутри этого нового сеанса IEx мы не можем получить доступ к &lt;code&gt;Hello.world/0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f17b233403875e96f2f86d0e5be296449a5c7be6" translate="yes" xml:space="preserve">
          <source>Note that installing via Git, GitHub, or Hex fetches the source of the archive and builds it, while using local path uses a pre-built archive.</source>
          <target state="translated">Обратите внимание,что при установке с помощью Git'а,GitHub'а или Hex'а получается исходный текст архива и производится его сборка с использованием локального пути с использованием предварительно собранного архива.</target>
        </trans-unit>
        <trans-unit id="501337e40a037ada414b45561640d40bc9bd67c7" translate="yes" xml:space="preserve">
          <source>Note that it is always possible to stop an application explicitly by calling &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;. Regardless of the type of the application, no other applications will be affected.</source>
          <target state="translated">Обратите внимание, что всегда можно явно остановить приложение, вызвав &lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; . Независимо от типа приложения, никакие другие приложения не пострадают.</target>
        </trans-unit>
        <trans-unit id="ff7bd5f130ea7db15204ea66bfeb9aa5a7e91245" translate="yes" xml:space="preserve">
          <source>Note that like the &lt;code&gt;alias&lt;/code&gt; directive, &lt;code&gt;require&lt;/code&gt; is also lexically scoped. We will talk more about macros in a later chapter.</source>
          <target state="translated">Обратите внимание, что, как и директива &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; также имеет лексическую область видимости. Подробнее о макросах мы поговорим в следующей главе.</target>
        </trans-unit>
        <trans-unit id="30dc33cdf6ccf0b16cb5002caa6c225d66067c88" translate="yes" xml:space="preserve">
          <source>Note that most Unicode code charts will refer to a code point by its hexadecimal representation, e.g. &lt;code&gt;97&lt;/code&gt; translates to &lt;code&gt;0061&lt;/code&gt; in hex, and we can represent any Unicode character in an Elixir string by using the &lt;code&gt;\u&lt;/code&gt; notation and the hex representation of its code point number:</source>
          <target state="translated">Обратите внимание, что большинство кодовых диаграмм Unicode будут ссылаться на кодовую точку в шестнадцатеричном представлении, например, &lt;code&gt;97&lt;/code&gt; переводится в &lt;code&gt;0061&lt;/code&gt; в шестнадцатеричном формате , и мы можем представить любой символ Unicode в строке Elixir, используя нотацию &lt;code&gt;\u&lt;/code&gt; и шестнадцатеричное представление его кодовой точки. количество:</target>
        </trans-unit>
        <trans-unit id="609fc4219e4f54367072ec4d02e01c554eb9955f" translate="yes" xml:space="preserve">
          <source>Note that on many platforms, only the status codes 0-255 are supported by the operating system.</source>
          <target state="translated">Обратите внимание,что на многих платформах операционная система поддерживает только коды состояния 0-255.</target>
        </trans-unit>
        <trans-unit id="058e024bfd4088c93bb70a9d4486efc9cfc43198" translate="yes" xml:space="preserve">
          <source>Note that only integers can be considered inside a range by &lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что только целые числа можно рассматривать внутри диапазона &lt;code&gt;in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3b3ddc90ecac73bf6bd80a621ca3d36de3d554d" translate="yes" xml:space="preserve">
          <source>Note that passing a non-empty list as the &lt;code&gt;collectable&lt;/code&gt; is deprecated. If you're collecting into a non-empty keyword list, consider using &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#merge/2&quot;&gt;&lt;code&gt;Keyword.merge/2&lt;/code&gt;&lt;/a&gt;. If you're collecting into a non-empty list, consider something like &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что передача непустого списка в качестве &lt;code&gt;collectable&lt;/code&gt; не рекомендуется. Если вы собираетесь в непустой список ключевых слов, рассмотрите возможность использования &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#merge/2&quot;&gt; &lt;code&gt;Keyword.merge/2&lt;/code&gt; &lt;/a&gt; . Если вы собираете в непустой список, рассмотрите что-то вроде &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3610787e239696d5d39dc8faf6f13f31e98d9fd3" translate="yes" xml:space="preserve">
          <source>Note that passing a non-empty list as the &lt;code&gt;collectable&lt;/code&gt; is deprecated. If you're collecting into a non-empty keyword list, consider using &lt;a href=&quot;keyword#merge/2&quot;&gt;&lt;code&gt;Keyword.merge/2&lt;/code&gt;&lt;/a&gt;. If you're collecting into a non-empty list, consider something like &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что передача непустого списка в качестве &lt;code&gt;collectable&lt;/code&gt; не рекомендуется. Если вы собираете непустой список ключевых слов, рассмотрите возможность использования &lt;a href=&quot;keyword#merge/2&quot;&gt; &lt;code&gt;Keyword.merge/2&lt;/code&gt; &lt;/a&gt; . Если вы собираете в непустой список, подумайте о чем-то вроде &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66a707c89c7a375b67feac5256ea470e5723f333" translate="yes" xml:space="preserve">
          <source>Note that popping elements out of tuples is not possible and raises an error.</source>
          <target state="translated">Обратите внимание,что вытаскивание элементов из кортежей невозможно и приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="1829a61daf7b4386ac742e8edeb6408f81010c1d" translate="yes" xml:space="preserve">
          <source>Note that setting any of the values above overrides Elixir's default values. For example, setting &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; will no longer automatically require the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module. In the same way setting &lt;code&gt;:macros&lt;/code&gt; will no longer auto-import &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; macros like &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;Kernel.if/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#case/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Обратите внимание, что установка любого из приведенных выше значений переопределяет значения Elixir по умолчанию. Например, для параметра &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; больше не будет автоматически требоваться модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; . Таким же образом настройка &lt;code&gt;:macros&lt;/code&gt; больше не будут автоматически импортировать макросы &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; такие как &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;Kernel.if/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#case/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt; &lt;/a&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="dcdb0a0d3694177344abe742c5030d4133620456" translate="yes" xml:space="preserve">
          <source>Note that since the compiler also defines some additional metadata, there are a few reserved keys that will be ignored and warned if used. Currently these are: &lt;code&gt;:opaque&lt;/code&gt; and &lt;code&gt;:defaults&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание: поскольку компилятор также определяет некоторые дополнительные метаданные, есть несколько зарезервированных ключей, которые будут проигнорированы и предупреждены при использовании. В настоящее время это &lt;code&gt;:opaque&lt;/code&gt; и &lt;code&gt;:defaults&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b75c0042cd08ee62bad4db6cb1d7ba8606cfb304" translate="yes" xml:space="preserve">
          <source>Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, &lt;code&gt;:erlc_paths&lt;/code&gt; is used by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt;&lt;code&gt;mix compile.erlang&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Yecc.html&quot;&gt;&lt;code&gt;mix compile.yecc&lt;/code&gt;&lt;/a&gt;, and other tasks).</source>
          <target state="translated">Обратите внимание, что иногда один и тот же параметр конфигурации упоминается в документации для разных задач; это просто потому, что для многих задач обычно используется один и тот же параметр конфигурации (например &lt;code&gt;:erlc_paths&lt;/code&gt; используется &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt; &lt;code&gt;mix compile.erlang&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Yecc.html&quot;&gt; &lt;code&gt;mix compile.yecc&lt;/code&gt; &lt;/a&gt; и другими задачами).</target>
        </trans-unit>
        <trans-unit id="3f7174f1e0891c9c315cf26472dfe8e8d467ed7d" translate="yes" xml:space="preserve">
          <source>Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, &lt;code&gt;:erlc_paths&lt;/code&gt; is used by &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;mix compile.erlang&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt;&lt;code&gt;mix compile.yecc&lt;/code&gt;&lt;/a&gt;, and other tasks).</source>
          <target state="translated">Обратите внимание, что иногда один и тот же параметр конфигурации упоминается в документации для разных задач; это просто потому, что для многих задач обычно используется один и тот же параметр конфигурации (например &lt;code&gt;:erlc_paths&lt;/code&gt; используется в &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt; &lt;code&gt;mix compile.erlang&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt; &lt;code&gt;mix compile.yecc&lt;/code&gt; &lt;/a&gt; и других задачах).</target>
        </trans-unit>
        <trans-unit id="3f0f13b3768bb3f2f5261f8bf7014c2406c92785" translate="yes" xml:space="preserve">
          <source>Note that stacktraces in Elixir are only available inside catch and rescue by using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">Обратите внимание, что трассировки стека в Elixir доступны только внутри функции catch and rescue с использованием переменной &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4e3794b5d058074ae9fb619182bee5deeb2d26" translate="yes" xml:space="preserve">
          <source>Note that stacktraces in Elixir are only available inside catch and rescue by using the &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">Обратите внимание, что трассировки стека в Elixir доступны только внутри функции catch and rescue с использованием переменной &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e85b6039665bee3ec9b0d680c01e0c9c21351cc3" translate="yes" xml:space="preserve">
          <source>Note that supervisor that reached maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only restart if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">Обратите внимание, что супервизор, который достиг максимальной интенсивности перезапуска, выйдет с &lt;code&gt;:shutdown&lt;/code&gt; причина выключения . В этом случае супервизор перезапустится только в том случае, если его дочерняя спецификация была определена с параметром &lt;code&gt;:restart&lt;/code&gt; , установленным на &lt;code&gt;:permanent&lt;/code&gt; (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="936b4b3bd1216dcefa77865d707c7482829eb4f4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with &lt;code&gt;#&lt;/code&gt;. For example, inspecting a function will return:</source>
          <target state="translated">Обратите внимание , что &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; протокола не обязательно возвращает действительное представление в срок Elixir. В таких случаях проверяемый результат должен начинаться с &lt;code&gt;#&lt;/code&gt; . Например, проверка функции вернет:</target>
        </trans-unit>
        <trans-unit id="552be8eaba50f8b9cb5e15b8c46f2e1519134f1f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with &lt;code&gt;#&lt;/code&gt;. For example, inspecting a function will return:</source>
          <target state="translated">Обратите внимание , что &lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; протокола не обязательно возвращает действительное представление в срок Elixir. В таких случаях проверяемый результат должен начинаться с &lt;code&gt;#&lt;/code&gt; . Например, проверка функции вернет:</target>
        </trans-unit>
        <trans-unit id="a210d5a52a6f0f763cbec85671fca9f2120de279" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;start_link&lt;/code&gt; function starts a new process that runs the &lt;code&gt;loop/1&lt;/code&gt; function, starting with an empty map. The &lt;code&gt;loop/1&lt;/code&gt; (private) function then waits for messages and performs the appropriate action for each message. We made &lt;code&gt;loop/1&lt;/code&gt; private by using &lt;code&gt;defp&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;. In the case of a &lt;code&gt;:get&lt;/code&gt; message, it sends a message back to the caller and calls &lt;code&gt;loop/1&lt;/code&gt; again, to wait for a new message. While the &lt;code&gt;:put&lt;/code&gt; message actually invokes &lt;code&gt;loop/1&lt;/code&gt; with a new version of the map, with the given &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; stored.</source>
          <target state="translated">Обратите внимание, что функция &lt;code&gt;start_link&lt;/code&gt; запускает новый процесс, который запускает функцию &lt;code&gt;loop/1&lt;/code&gt; , начиная с пустой карты. Затем функция &lt;code&gt;loop/1&lt;/code&gt; (private) ожидает сообщений и выполняет соответствующее действие для каждого сообщения. Мы сделали &lt;code&gt;loop/1&lt;/code&gt; закрытым, используя &lt;code&gt;defp&lt;/code&gt; вместо &lt;code&gt;def&lt;/code&gt; . В случае сообщения &lt;code&gt;:get&lt;/code&gt; он отправляет сообщение вызывающему абоненту и снова вызывает &lt;code&gt;loop/1&lt;/code&gt; , чтобы дождаться нового сообщения. В то время как сообщение &lt;code&gt;:put&lt;/code&gt; фактически вызывает &lt;code&gt;loop/1&lt;/code&gt; с новой версией карты с сохраненным заданным &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9f3b685f288df2ac141b75c4120d3ea4cba1aee" translate="yes" xml:space="preserve">
          <source>Note that the Erlang VM (and therefore this function) does not return the current stacktrace but rather the stacktrace of the latest exception. To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="translated">Обратите внимание, что Erlang VM (и, следовательно, эта функция) возвращает не текущую трассировку стека, а трассировку стека последнего исключения. Чтобы получить трассировку стека текущего процесса, используйте &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc53bfc2363fa69016517d06be9fddf805a65c1d" translate="yes" xml:space="preserve">
          <source>Note that the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">Обратите внимание,что разрыв был представлен как есть,потому что мы не достигли лимита строки.Как только мы это делаем,он заменяется на новую строку:</target>
        </trans-unit>
        <trans-unit id="6b74fe0466cf2ea8dc50231e02541ba1b836c60b" translate="yes" xml:space="preserve">
          <source>Note that the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">Обратите внимание,что разрыв был представлен данной строкой,так как мы не достигли лимита строки.Как только мы это делаем,он заменяется на новую строку:</target>
        </trans-unit>
        <trans-unit id="8c25d0b631147ff8a481e4dcb175efe3a2f931b4" translate="yes" xml:space="preserve">
          <source>Note that the empty map will match all maps, which is a contrast to tuples and lists, where an empty tuple or an empty list will only match empty tuples and empty lists respectively:</source>
          <target state="translated">Обратите внимание,что пустая карта будет соответствовать всем картам,что является контрастом к кортежам и спискам,где пустой кортеж или пустой список будет соответствовать только пустым кортежам и пустым спискам соответственно:</target>
        </trans-unit>
        <trans-unit id="61118c7f53d4bda89916029a3a51c482ae9250a8" translate="yes" xml:space="preserve">
          <source>Note that the functions in &lt;code&gt;:digraph&lt;/code&gt; alter the graph structure in-place, this is possible because they are implemented as ETS tables, explained next.</source>
          <target state="translated">Обратите внимание, что функции в &lt;code&gt;:digraph&lt;/code&gt; изменяют структуру графа на месте, это возможно, потому что они реализованы в виде таблиц ETS, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="8627c831d93f41d528783ce65921c7ddd4b6fc21" translate="yes" xml:space="preserve">
          <source>Note that the match operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/a&gt;) does &lt;em&gt;not&lt;/em&gt; support guards:</source>
          <target state="translated">Обратите внимание, что оператор соответствия ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt; &lt;code&gt;=&lt;/code&gt; &lt;/a&gt; ) &lt;em&gt;не&lt;/em&gt; поддерживает охранников:</target>
        </trans-unit>
        <trans-unit id="642c83993efe9994a761915e7e921044f5f85c3c" translate="yes" xml:space="preserve">
          <source>Note that the purpose of the test is to check whether the registry processes the bucket&amp;rsquo;s shutdown message correctly. The fact that the &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sends us a valid bucket does not mean that the bucket is still alive by the time you call it. For example, it might have crashed for some reason. The following test depicts this situation:</source>
          <target state="translated">Обратите внимание, что цель теста - проверить, правильно ли реестр обрабатывает сообщение о завершении работы корзины. Тот факт, что &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; отправляет нам действительный бакет , не означает, что бакет еще жив к тому моменту, когда вы его вызываете. Например, по какой-то причине он мог разбиться. Следующий тест показывает эту ситуацию:</target>
        </trans-unit>
        <trans-unit id="67d98e4f2d8bcb03260e0b9f2837377ff066ec7f" translate="yes" xml:space="preserve">
          <source>Note that the registry uses one ETS table plus two ETS tables per partition.</source>
          <target state="translated">Обратите внимание,что реестр использует одну таблицу ETS плюс две таблицы ETS на раздел.</target>
        </trans-unit>
        <trans-unit id="d23b68f4a034d408b5f29d2cab465dee9b0485c0" translate="yes" xml:space="preserve">
          <source>Note that the returned result is incorrect, because &lt;a href=&quot;#sort/1&quot;&gt;&lt;code&gt;sort/1&lt;/code&gt;&lt;/a&gt; by default uses &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;, which will compare their structure. When comparing structures, the fields are compared in alphabetical order, which means the dates above will be compared by &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; and then &lt;code&gt;year&lt;/code&gt;, which is the opposite of what we want.</source>
          <target state="translated">Обратите внимание, что возвращенный результат неверен, потому что &lt;a href=&quot;#sort/1&quot;&gt; &lt;code&gt;sort/1&lt;/code&gt; &lt;/a&gt; по умолчанию использует &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt; &lt;code&gt;&amp;lt;=/2&lt;/code&gt; &lt;/a&gt; , что будет сравнивать их структуру. При сравнении структур поля сравниваются в алфавитном порядке, что означает, что даты, указанные выше, будут сравниваться по &lt;code&gt;day&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; и &lt;code&gt;year&lt;/code&gt; , что противоположно тому, что мы хотим.</target>
        </trans-unit>
        <trans-unit id="ec636350f4f8e5f34aed230627c7cf0452577a12" translate="yes" xml:space="preserve">
          <source>Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and does not need to report back to the caller.</source>
          <target state="translated">Обратите внимание,что порожденный процесс связан не с вызывающим а только с начальником.Эта команда полезна в том случае,если задаче необходимо выполнить побочные эффекты (например,ввод/вывод)и не нужно сообщать вызывающему абоненту.</target>
        </trans-unit>
        <trans-unit id="3e2844dc57fe394fb1d784abea5572c60fbbc883" translate="yes" xml:space="preserve">
          <source>Note that the supervisor that reaches maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">Обратите внимание, что супервизор, который достигает максимальной интенсивности перезапуска, выйдет с &lt;code&gt;:shutdown&lt;/code&gt; причина выключения . В этом случае супервизор будет перезапущен только в том случае, если его дочерняя спецификация была определена с параметром &lt;code&gt;:restart&lt;/code&gt; , установленным на &lt;code&gt;:permanent&lt;/code&gt; (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="b127c6ea8c064847d709c284556ed56f2833bb8b" translate="yes" xml:space="preserve">
          <source>Note that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt;, not &lt;code&gt;%{}&lt;/code&gt;. The notation &lt;code&gt;%{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">Обратите внимание, что синтаксическое представление &lt;code&gt;map()&lt;/code&gt; - &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt; , а не &lt;code&gt;%{}&lt;/code&gt; . Обозначение &lt;code&gt;%{}&lt;/code&gt; указывает одноэлементный тип для пустой карты.</target>
        </trans-unit>
        <trans-unit id="91f3a52cafb20592b005962fff487b0f78c38ad7" translate="yes" xml:space="preserve">
          <source>Note that the user-supplied function is wrapped into a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function must return a tagged tuple after each step, as described in the &lt;a href=&quot;#t:acc/0&quot;&gt;&lt;code&gt;acc/0&lt;/code&gt;&lt;/a&gt; type. At the end, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что функция, предоставляемая пользователем, заключена в функцию &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; . Функция &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; должна возвращать помеченный кортеж после каждого шага, как описано в типе &lt;a href=&quot;#t:acc/0&quot;&gt; &lt;code&gt;acc/0&lt;/code&gt; &lt;/a&gt; . В конце &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; возвращает &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd0116a55dff5f2bacdff852b6887f33db51d12e" translate="yes" xml:space="preserve">
          <source>Note that this applies only to the tuple itself, not its contents. For instance, when you update a tuple, all entries are shared between the old and the new tuple, except for the entry that has been replaced. In other words, tuples and lists in Elixir are capable of sharing their contents. This reduces the amount of memory allocation the language needs to perform and is only possible thanks to the immutable semantics of the language.</source>
          <target state="translated">Обратите внимание,что это относится только к кортежу,а не к его содержимому.Например,при обновлении кортежа все записи разделяются между старым и новым кортежом,за исключением записи,которая была заменена.Другими словами,кортежи и списки в Elixir могут совместно использовать их содержимое.Это сокращает объем памяти,необходимый для работы языка,и возможно только благодаря неизменной семантике языка.</target>
        </trans-unit>
        <trans-unit id="772fcfd84a5f9fd2ad0b735b0a19d01baa41c4ae" translate="yes" xml:space="preserve">
          <source>Note that this function does not load the module in case it is not loaded. Check &lt;a href=&quot;code#ensure_loaded/1&quot;&gt;&lt;code&gt;Code.ensure_loaded/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Обратите внимание, что эта функция не загружает модуль, если он не загружен. Проверьте &lt;a href=&quot;code#ensure_loaded/1&quot;&gt; &lt;code&gt;Code.ensure_loaded/1&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="eea6328af931fedba539b796b9a7e26ee026accb" translate="yes" xml:space="preserve">
          <source>Note that this function does not load the module in case it is not loaded. Check &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#ensure_loaded/1&quot;&gt;&lt;code&gt;Code.ensure_loaded/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Обратите внимание, что эта функция не загружает модуль, если он не загружен. Проверьте &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#ensure_loaded/1&quot;&gt; &lt;code&gt;Code.ensure_loaded/1&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3a93b64ce36dbd9e66bfd7a4794eac8913433ad9" translate="yes" xml:space="preserve">
          <source>Note that this function does not try to discover the file encoding basing on BOM.</source>
          <target state="translated">Обратите внимание,что эта функция не пытается обнаружить кодировку файла на основе BOM.</target>
        </trans-unit>
        <trans-unit id="daa070decb7d61349ea0b25d0768f92d17f5b20c" translate="yes" xml:space="preserve">
          <source>Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта функция ожидает список целых чисел, представляющих кодовые точки Unicode. Если у вас есть список байтов, вы должны вместо этого использовать &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; модуль&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7297e7a168339d862010e69cb4610a576f96e0" translate="yes" xml:space="preserve">
          <source>Note that this function treats a &lt;code&gt;path&lt;/code&gt; with a leading &lt;code&gt;~&lt;/code&gt; as an absolute one.</source>
          <target state="translated">Обратите внимание, что эта функция рассматривает &lt;code&gt;path&lt;/code&gt; с начальным знаком &lt;code&gt;~&lt;/code&gt; как абсолютный.</target>
        </trans-unit>
        <trans-unit id="5dc2b06327128a221483a845cf466f49fa39da58" translate="yes" xml:space="preserve">
          <source>Note that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; instead. For more information about IO data and chardata, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">Обратите внимание, что эта функция обрабатывает целые числа в заданных данных ввода-вывода как необработанные байты и не выполняет никакого преобразования кодировки. Если вы хотите преобразовать из списка символов в строку в кодировке UTF-8, используйте вместо этого &lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о данных ввода-вывода и chardata см. В разделе &lt;a href=&quot;#module-io-data&quot;&gt;&amp;laquo;Данные ввода-вывода&amp;raquo;&lt;/a&gt; документации модуля.</target>
        </trans-unit>
        <trans-unit id="9f46bc01d34c1a8f27d34a80d0611920215b1706" translate="yes" xml:space="preserve">
          <source>Note that this function will traverse the whole &lt;code&gt;enumerable&lt;/code&gt; to get the random sublist.</source>
          <target state="translated">Обратите внимание, что эта функция будет проходить по всему &lt;code&gt;enumerable&lt;/code&gt; чтобы получить случайный подсписок.</target>
        </trans-unit>
        <trans-unit id="1cfa9837195cf9c63349ac44a72cf8140752983a" translate="yes" xml:space="preserve">
          <source>Note that this not only works with single expressions but also with arbitrary code blocks.</source>
          <target state="translated">Обратите внимание,что это работает не только с отдельными выражениями,но и с произвольными блоками кода.</target>
        </trans-unit>
        <trans-unit id="bd78885c92dbd33a6356c7fbcb303ca6f0a8b88a" translate="yes" xml:space="preserve">
          <source>Note that those functions are polymorphic - not only do they convert charlists to strings, they also operate on integers, atoms, and so on.</source>
          <target state="translated">Обратите внимание,что эти функции полиморфны-они не только преобразуют charlists в строки,но и оперируют целыми числами,атомами и так далее.</target>
        </trans-unit>
        <trans-unit id="14ce19a4da0f58dcf26e71e7c820a5ec0bbf379f" translate="yes" xml:space="preserve">
          <source>Note that those functions are polymorphic. They not only convert charlists to strings, but also integers to strings, atoms to strings, and so on.</source>
          <target state="translated">Обратите внимание,что эти функции являются полиморфными.Они преобразуют charlists не только в строки,но и целые числа в строки,атомы в строки и так далее.</target>
        </trans-unit>
        <trans-unit id="43c532218f4ed686a0d71d554c91a77ee3c049fb" translate="yes" xml:space="preserve">
          <source>Note that type checks that are not valid in guard clauses do not follow this convention. Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;regex#regex?/1&quot;&gt;&lt;code&gt;Regex.regex?/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Обратите внимание, что проверки типов, недопустимые в защитных предложениях, не соответствуют этому соглашению. Примеры: &lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;regex#regex?/1&quot;&gt; &lt;code&gt;Regex.regex?/1&lt;/code&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d1ab8bb1656e345421bed44fb85cdb6b3df0a91" translate="yes" xml:space="preserve">
          <source>Note that type checks that are not valid in guard clauses do not follow this convention. For example: &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что проверки типов, недопустимые в защитных предложениях, не соответствуют этому соглашению. Например: &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0b8f286916684b88b0a25d36d8f780a42be1ba5" translate="yes" xml:space="preserve">
          <source>Note that unless you explicitly use &lt;code&gt;::&lt;/code&gt; modifiers, each entry in the binary pattern is expected to match a single byte (exactly 8 bits). If we want to match on a binary of unknown size, we can use the &lt;code&gt;binary&lt;/code&gt; modifier at the end of the pattern:</source>
          <target state="translated">Обратите внимание, что если вы явно не используете &lt;code&gt;::&lt;/code&gt; модификаторы, ожидается, что каждая запись в двоичном шаблоне будет соответствовать одному байту (ровно 8 бит). Если мы хотим сопоставить двоичный файл неизвестного размера, мы можем использовать модификатор &lt;code&gt;binary&lt;/code&gt; в конце шаблона:</target>
        </trans-unit>
        <trans-unit id="174cbc748d572204ea1540b27cb5cc59e7b6deca" translate="yes" xml:space="preserve">
          <source>Note that values added to the front are the ones fetched on lookup:</source>
          <target state="translated">Обратите внимание,что значения,добавляемые спереди,являются теми,которые извлекаются при поиске:</target>
        </trans-unit>
        <trans-unit id="4534808d0e30c2a0c89aefa00459683895b7a5d4" translate="yes" xml:space="preserve">
          <source>Note that variables bound in a clause do not leak to the outer context:</source>
          <target state="translated">Обратите внимание,что переменные,связанные в пункте,не утечка во внешний контекст:</target>
        </trans-unit>
        <trans-unit id="99c494f8c4b42bfb58605596ab066b0cd0beb517" translate="yes" xml:space="preserve">
          <source>Note that we didn't implement it for lists as we don't have the &lt;code&gt;size&lt;/code&gt; information on lists, rather its value needs to be computed with &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы не реализовали его для списков, так как у нас нет информации о &lt;code&gt;size&lt;/code&gt; в списках, скорее его значение должно быть вычислено с &lt;code&gt;length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e821d9d1f900f549c2c76e6f6522fe28ec874c0" translate="yes" xml:space="preserve">
          <source>Note that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:</source>
          <target state="translated">Обратите внимание,что сначала мы распечатывали каждый элемент списка,затем умножали каждый элемент на 2 и,наконец,распечатывали каждое новое значение.В этом примере список был перечислен три раза.Рассмотрим пример с потоками:</target>
        </trans-unit>
        <trans-unit id="ff6a8b672135b387d9a90d6cece502b550379161" translate="yes" xml:space="preserve">
          <source>Note that we had to escape the backslash escape character (i.e., we used &lt;code&gt;\\N&lt;/code&gt; instead of just &lt;code&gt;\N&lt;/code&gt; to escape the backslash; same thing for &lt;code&gt;\\g{N}&lt;/code&gt;). By giving &lt;code&gt;\0&lt;/code&gt;, one can inject the whole match in the replacement string.</source>
          <target state="translated">Обратите внимание, что нам пришлось экранировать escape-символ обратной косой черты (т.е. мы использовали &lt;code&gt;\\N&lt;/code&gt; вместо просто &lt;code&gt;\N&lt;/code&gt; чтобы избежать обратной косой черты; то же самое для &lt;code&gt;\\g{N}&lt;/code&gt; ). Задав &lt;code&gt;\0&lt;/code&gt; , можно ввести полное совпадение в заменяющую строку.</target>
        </trans-unit>
        <trans-unit id="7c321fccec9582dfce9477fe7768165a7a09b608" translate="yes" xml:space="preserve">
          <source>Note that we have also defined a private function named &lt;code&gt;lookup/2&lt;/code&gt; to help with the common functionality of looking up a bucket and returning its &lt;code&gt;pid&lt;/code&gt; if it exists, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">Обратите внимание, что мы также определили частную функцию с именем &lt;code&gt;lookup/2&lt;/code&gt; , чтобы помочь с общими функциями поиска сегмента и возврата его &lt;code&gt;pid&lt;/code&gt; , если он существует, в противном случае &lt;code&gt;{:error, :not_found}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4e347dc2a26896b5ad2dd01746e3c38cd3e50c6" translate="yes" xml:space="preserve">
          <source>Note that we have an inner tuple, containing the atom &lt;code&gt;:.&lt;/code&gt; representing the dot as first element:</source>
          <target state="translated">Обратите внимание, что у нас есть внутренний кортеж, содержащий атом &lt;code&gt;:.&lt;/code&gt; представляя точку как первый элемент:</target>
        </trans-unit>
        <trans-unit id="9412a4887f881774fae5591b90049312660e64f3" translate="yes" xml:space="preserve">
          <source>Note that we need a mechanism to pass the &lt;code&gt;bucket&lt;/code&gt; pid from the callback to the test. We do so by using the &lt;em&gt;test context&lt;/em&gt;. When we return &lt;code&gt;%{bucket: bucket}&lt;/code&gt; from the callback, ExUnit will merge this map into the test context. Since the test context is a map itself, we can pattern match the bucket out of it, providing access to the bucket inside the test:</source>
          <target state="translated">Обратите внимание , что нам нужен механизм , чтобы передать &lt;code&gt;bucket&lt;/code&gt; PID от обратного вызова теста. Мы делаем это с помощью &lt;em&gt;тестового контекста&lt;/em&gt; . Когда мы возвращаем &lt;code&gt;%{bucket: bucket}&lt;/code&gt; из обратного вызова, ExUnit объединит эту карту с тестовым контекстом. Поскольку тестовый контекст - это сама карта, мы можем сопоставить с ней бакет по шаблону, предоставив доступ к бакету внутри теста:</target>
        </trans-unit>
        <trans-unit id="ec1e62d0fd9ece09297d2ef01c229bd24cfed25d" translate="yes" xml:space="preserve">
          <source>Note that we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;lazy&lt;/em&gt; and the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;eager&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что мы начали с диапазона, а затем создали поток, предназначенный для умножения каждого элемента в диапазоне на 2. На этом этапе вычислений не производилось. Только тогда , когда &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; называется мы на самом деле перечислять через каждый элемент в диапазоне, умножая его на 2 и добавление 1. Будет говорить , что функции в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; являются &lt;em&gt;ленивыми&lt;/em&gt; и функция в &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; являются &lt;em&gt;нетерпеливой&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3e819f2e65aae690b63c5af560e6444ef3c30ff3" translate="yes" xml:space="preserve">
          <source>Note that when creating this string representation, the &lt;code&gt;:authority&lt;/code&gt; value will be used if the &lt;code&gt;:host&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Otherwise, the &lt;code&gt;:userinfo&lt;/code&gt;, &lt;code&gt;:host&lt;/code&gt;, and &lt;code&gt;:port&lt;/code&gt; will be used.</source>
          <target state="translated">Обратите внимание , что при создании этого строкового представления, то &lt;code&gt;:authority&lt;/code&gt; значение будет использоваться , если &lt;code&gt;:host&lt;/code&gt; является &lt;code&gt;nil&lt;/code&gt; . В противном случае &lt;code&gt;:userinfo&lt;/code&gt; , &lt;code&gt;:host&lt;/code&gt; , и &lt;code&gt;:port&lt;/code&gt; будет использоваться.</target>
        </trans-unit>
        <trans-unit id="059596cc4da0ec6ea079bfeb0987398e72e24193" translate="yes" xml:space="preserve">
          <source>Note that when keyword lists are passed as the last argument to a function, if the short-hand syntax is used then the square brackets around the keyword list can be omitted as well. For example, the following:</source>
          <target state="translated">Обратите внимание,что при передаче списков ключевых слов в качестве последнего аргумента функции,если используется короткий синтаксис,то квадратные скобки вокруг списка ключевых слов также могут быть опущены.Например,следующее:</target>
        </trans-unit>
        <trans-unit id="91d528c940d56f0624ee74f03dcdf3ce64881a92" translate="yes" xml:space="preserve">
          <source>Note that when starting the GenServer, we are registering it with name &lt;code&gt;Stack&lt;/code&gt;, which allows us to call it directly and get what is on the stack:</source>
          <target state="translated">Обратите внимание, что при запуске GenServer мы регистрируем его с именем &lt;code&gt;Stack&lt;/code&gt; , что позволяет нам вызывать его напрямую и получать то, что находится в стеке:</target>
        </trans-unit>
        <trans-unit id="76e1ebe73da349bd10b0f0a0d1133669ff102e7d" translate="yes" xml:space="preserve">
          <source>Note that when the &lt;code&gt;async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the messages from another test might be captured. This is OK as long you consider such cases in your assertions.</source>
          <target state="translated">Обратите внимание, что когда для &lt;code&gt;async&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , могут быть захвачены сообщения из другого теста. Это нормально, пока вы учитываете такие случаи в своих утверждениях.</target>
        </trans-unit>
        <trans-unit id="51593dd72717840f7fb2a715f89be6d7c2e52241" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times and datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir.</source>
          <target state="translated">Обратите внимание,что в то время как ISO 8601 позволяет указывать время и дату 24:00:00 в качестве нулевого часа следующего дня,эта нотация не поддерживается Elixir.</target>
        </trans-unit>
        <trans-unit id="10328798e18043813d96248d25cbd19fb081be9c" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Leap seconds are not supported as well by the built-in Calendar.ISO.</source>
          <target state="translated">Обратите внимание,что в то время как ISO 8601 позволяет указывать время 24:00:00 в качестве нулевого часа следующего дня,эта нотация не поддерживается Elixir.Високосные секунды также не поддерживаются встроенным Calendar.ISO.</target>
        </trans-unit>
        <trans-unit id="674d928e8930fc373a1ecef037a0add8d70944ab" translate="yes" xml:space="preserve">
          <source>Note that you should only supply the &lt;code&gt;:switches&lt;/code&gt; or the &lt;code&gt;:strict&lt;/code&gt; option. If you supply both, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception will be raised.</source>
          <target state="translated">Обратите внимание, что вам следует указать только &lt;code&gt;:switches&lt;/code&gt; или параметр &lt;code&gt;:strict&lt;/code&gt; . Если вы укажете оба, возникнет исключение &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eec8afe83887288b4e571792afdfd03698308c34" translate="yes" xml:space="preserve">
          <source>Note that you should only supply the &lt;code&gt;:switches&lt;/code&gt; or the &lt;code&gt;:strict&lt;/code&gt; option. If you supply both, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception will be raised.</source>
          <target state="translated">Обратите внимание, что вы должны указывать только &lt;code&gt;:switches&lt;/code&gt; или параметр &lt;code&gt;:strict&lt;/code&gt; . Если вы укажете оба &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; возникнет исключение ArgumentError .</target>
        </trans-unit>
        <trans-unit id="a66941b089effbcc609ab8e5c6d8166e34e89b1f" translate="yes" xml:space="preserve">
          <source>Note that, even though the alias &lt;code&gt;M&lt;/code&gt; is not available in the context the macro is expanded, the code above works because &lt;code&gt;M&lt;/code&gt; still expands to &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что, хотя псевдоним &lt;code&gt;M&lt;/code&gt; недоступен в контексте раскрытия макроса, приведенный выше код работает, потому что &lt;code&gt;M&lt;/code&gt; по- прежнему расширяется до &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5618ec783469ef4c54ca8326a639f6727694278b" translate="yes" xml:space="preserve">
          <source>Note that, however, the struct fields are private and must not be accessed directly; use the functions in this module to perform operations on sets.</source>
          <target state="translated">Обратите внимание,что поля структуры являются приватными и не должны быть доступны напрямую;используйте функции в этом модуле для выполнения операций с множествами.</target>
        </trans-unit>
        <trans-unit id="43d19607ee0a232b2886e30e288770f0a0223896" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">Обратите внимание, что, в отличие от &lt;a href=&quot;#and/2&quot;&gt; &lt;code&gt;and/2&lt;/code&gt; &lt;/a&gt; , этот оператор принимает в качестве первого аргумента любое выражение, а не только логические.</target>
        </trans-unit>
        <trans-unit id="904787334ac92370c9a9993f8474d839a9d2466c" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#or/2&quot;&gt;&lt;code&gt;or/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">Обратите внимание, что, в отличие от &lt;a href=&quot;#or/2&quot;&gt; &lt;code&gt;or/2&lt;/code&gt; &lt;/a&gt; , этот оператор принимает в качестве первого аргумента любое выражение, а не только логические.</target>
        </trans-unit>
        <trans-unit id="5ae63c410e0feddfea821d9a3ebf91fa6fffb5c3" translate="yes" xml:space="preserve">
          <source>Note that, when working with distributed tasks, one should use the &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/4&quot;&gt;&lt;code&gt;Task.Supervisor.async/4&lt;/code&gt;&lt;/a&gt; function that expects explicit module, function and arguments, instead of &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/2&quot;&gt;&lt;code&gt;Task.Supervisor.async/2&lt;/code&gt;&lt;/a&gt; that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</source>
          <target state="translated">Обратите внимание, что при работе с распределенными задачами следует использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/4&quot;&gt; &lt;code&gt;Task.Supervisor.async/4&lt;/code&gt; &lt;/a&gt; которая ожидает явного модуля, функции и аргументов, вместо &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/2&quot;&gt; &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; ,&lt;/a&gt; которая работает с анонимными функциями. Это потому, что анонимные функции ожидают, что одна и та же версия модуля будет существовать на всех задействованных узлах. Проверьте &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; документацию модуля для получения дополнительной информации о распределенных процессах , как ограничения описано здесь применяется ко всей экосистеме.</target>
        </trans-unit>
        <trans-unit id="08cd47820e470aeb0ed46fa6530b94a8d0d659ed" translate="yes" xml:space="preserve">
          <source>Note that, when working with distributed tasks, one should use the &lt;a href=&quot;task.supervisor#async/4&quot;&gt;&lt;code&gt;Task.Supervisor.async/4&lt;/code&gt;&lt;/a&gt; function that expects explicit module, function and arguments, instead of &lt;a href=&quot;task.supervisor#async/2&quot;&gt;&lt;code&gt;Task.Supervisor.async/2&lt;/code&gt;&lt;/a&gt; that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</source>
          <target state="translated">Обратите внимание, что при работе с распределенными задачами следует использовать &lt;a href=&quot;task.supervisor#async/4&quot;&gt; &lt;code&gt;Task.Supervisor.async/4&lt;/code&gt; &lt;/a&gt; которая ожидает явного модуля, функции и аргументов, вместо &lt;a href=&quot;task.supervisor#async/2&quot;&gt; &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; ,&lt;/a&gt; которая работает с анонимными функциями. Это потому, что анонимные функции ожидают, что одна и та же версия модуля будет существовать на всех задействованных узлах. Обратитесь к документации модуля &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о распределенных процессах, поскольку описанные там ограничения применяются ко всей экосистеме.</target>
        </trans-unit>
        <trans-unit id="e1a5de811a65c6ac8bdd702e32d5c21604ebf82d" translate="yes" xml:space="preserve">
          <source>Note that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</source>
          <target state="translated">Обратите внимание,что хотя шаблоны могут быть заданы для макросов,помните,что макросы получают AST в качестве аргументов,а не значений.Например,если попытаться разбить макрос по следующему шаблону:</target>
        </trans-unit>
        <trans-unit id="f98570973aa7e2132e68496b2b9ad6d68c9748d2" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;:deprecated&lt;/code&gt; key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the &lt;code&gt;@deprecated&lt;/code&gt; attribute:</source>
          <target state="translated">Обратите внимание &lt;code&gt;:deprecated&lt;/code&gt; ключ не предупреждает, когда разработчик вызывает функции. Если вы хотите, чтобы код также &lt;code&gt;@deprecated&lt;/code&gt; предупреждение, вы можете использовать атрибут @deprecated :</target>
        </trans-unit>
        <trans-unit id="fbe12959616fed170330064dc85549503954ef06" translate="yes" xml:space="preserve">
          <source>Note the British spelling!</source>
          <target state="translated">Обратите внимание на британское правописание!</target>
        </trans-unit>
        <trans-unit id="b1c5d08584d148be13f621a2c51eacad30bf0769" translate="yes" xml:space="preserve">
          <source>Note the behaviour of those classes may change according to the Unicode and other modifiers:</source>
          <target state="translated">Обратите внимание,что поведение этих классов может меняться в соответствии с Юникодом и другими модификаторами:</target>
        </trans-unit>
        <trans-unit id="79e188c7e768551ff604bcf40bceebdb7a51cda8" translate="yes" xml:space="preserve">
          <source>Note the capture syntax can also be used as a shortcut for creating functions:</source>
          <target state="translated">Обратите внимание,что синтаксис захвата может также использоваться в качестве ярлыка для создания функций:</target>
        </trans-unit>
        <trans-unit id="5f21e2c658fa1b5b1502e58a82469aca236223e3" translate="yes" xml:space="preserve">
          <source>Note the convention in Elixir is to name functions/macros allowed in guards with the &lt;code&gt;is_&lt;/code&gt; prefix, such as &lt;a href=&quot;#is_list/1&quot;&gt;&lt;code&gt;is_list/1&lt;/code&gt;&lt;/a&gt;. If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что в Elixir принято называть функции / макросы, разрешенные в охранниках, префиксом &lt;code&gt;is_&lt;/code&gt; , например &lt;a href=&quot;#is_list/1&quot;&gt; &lt;code&gt;is_list/1&lt;/code&gt; &lt;/a&gt; . Однако, если функция / макрос возвращает логическое значение и не разрешено в охранниках, у нее не должно быть префикса и заканчиваться вопросительным знаком, например &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc7df408c1b6e9e0aa62f81ee99961007e92e471" translate="yes" xml:space="preserve">
          <source>Note the convention in Elixir is to name functions/macros allowed in guards with the &lt;code&gt;is_&lt;/code&gt; prefix, such as &lt;a href=&quot;#is_list/1&quot;&gt;&lt;code&gt;is_list/1&lt;/code&gt;&lt;/a&gt;. If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что в Elixir принято называть функции / макросы, разрешенные в охранниках, префиксом &lt;code&gt;is_&lt;/code&gt; , например &lt;a href=&quot;#is_list/1&quot;&gt; &lt;code&gt;is_list/1&lt;/code&gt; &lt;/a&gt; . Если, однако, функция / макрос возвращает логическое значение и не допускается в охранниках, у нее не должно быть префикса и заканчиваться вопросительным знаком, например &lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02e568f28639d3d3cf9153ba1f47b6ffc7ed4a33" translate="yes" xml:space="preserve">
          <source>Note the environment is not returned as it can be accessed via &lt;a href=&quot;#fetch_env/2&quot;&gt;&lt;code&gt;fetch_env/2&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if the application is not loaded.</source>
          <target state="translated">Обратите внимание, что среда не возвращается, так как к ней можно получить доступ через &lt;a href=&quot;#fetch_env/2&quot;&gt; &lt;code&gt;fetch_env/2&lt;/code&gt; &lt;/a&gt; . Возвращает &lt;code&gt;nil&lt;/code&gt; , если приложение не загружено.</target>
        </trans-unit>
        <trans-unit id="8291debf84c93cf7420e870a4723eb8919b7abde" translate="yes" xml:space="preserve">
          <source>Note the file is deleted even if in read-only mode.</source>
          <target state="translated">Обратите внимание,что файл удаляется,даже если он находится в режиме только для чтения.</target>
        </trans-unit>
        <trans-unit id="20b9a7e0e7cfbc515eb86ff67eaa5244b2827ea0" translate="yes" xml:space="preserve">
          <source>Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.</source>
          <target state="translated">Обратите внимание,что функции в этом модуле гарантированно возвращают списки.Так как перечисления могут иметь различные формы (структуры,анонимные функции и т.д.),функции в этом модуле могут возвращать любую из этих форм,и это может измениться в любое время.Например,функция,которая сегодня возвращает анонимную функцию,может возвращать структуру в будущих выпусках.</target>
        </trans-unit>
        <trans-unit id="d438d99970ff0575f83b52d72a57ff8778a28621" translate="yes" xml:space="preserve">
          <source>Note the hook receives the quoted arguments and it is invoked before the function is stored in the module. So &lt;a href=&quot;module#defines?/2&quot;&gt;&lt;code&gt;Module.defines?/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; for the first clause of every function.</source>
          <target state="translated">Обратите внимание, что ловушка получает аргументы в кавычках и вызывается до того, как функция сохраняется в модуле. Итак, &lt;a href=&quot;module#defines?/2&quot;&gt; &lt;code&gt;Module.defines?/2&lt;/code&gt; &lt;/a&gt; вернет &lt;code&gt;false&lt;/code&gt; для первого предложения каждой функции.</target>
        </trans-unit>
        <trans-unit id="50c96e7409829996141bb668b995e2b96d78e115" translate="yes" xml:space="preserve">
          <source>Note the lock may also belong to another SCM and as such, an structural check is required. A structural mismatch should always return &lt;code&gt;:outdated&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что блокировка также может принадлежать другому SCM, и поэтому требуется структурная проверка. Всегда должно возвращаться структурное несоответствие &lt;code&gt;:outdated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fc73248c724a3a7729fc783a9f3f7c1f0c33c3b" translate="yes" xml:space="preserve">
          <source>Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use &lt;a href=&quot;#remove_breaks/1&quot;&gt;&lt;code&gt;remove_breaks/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Обратите внимание, что модуль остается &amp;laquo;оснащенным&amp;raquo; при сбросе. Если вы хотите эффективно удалить все точки останова и код инструментария из модуля, используйте вместо этого &lt;a href=&quot;#remove_breaks/1&quot;&gt; &lt;code&gt;remove_breaks/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78022746bf120fb73527ad51647d6b12ba5c9e69" translate="yes" xml:space="preserve">
          <source>Note the program above hijacks stdin, so you won't be able to communicate with the underlying software via stdin (on the positive side, software that reads from stdin typically terminates when stdin closes).</source>
          <target state="translated">Обратите внимание на программу,описанную выше,которая перехватывает stdin,поэтому вы не сможете общаться с базовым программным обеспечением через stdin (с положительной стороны,программное обеспечение,которое читает из stdin,обычно прекращает работу,когда stdin закрывается).</target>
        </trans-unit>
        <trans-unit id="db9c44355a667468b5a8a0fc6d5bc95bf927d9a1" translate="yes" xml:space="preserve">
          <source>Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar.</source>
          <target state="translated">Обратите внимание,что значение результата представляет собой время суток,т.е.оно циклично,например,для календаря ISO оно никогда не превысит 24 часов.</target>
        </trans-unit>
        <trans-unit id="bcdf2418808bb9ad9b914fb25ca7111d444ec598" translate="yes" xml:space="preserve">
          <source>Note the year, month, day, etc. designations are overspecified (i.e. an integer instead of &lt;code&gt;1..12&lt;/code&gt; for months) because different calendars may have a different number of days per month, months per year and so on.</source>
          <target state="translated">Обратите внимание на то, что обозначения года, месяца, дня и т. Д. Заданы чрезмерно (т.е. целое число вместо &lt;code&gt;1..12&lt;/code&gt; для месяцев), потому что разные календари могут иметь разное количество дней в месяц, месяцев в году и т. Д.</target>
        </trans-unit>
        <trans-unit id="3ccd699f8c48bd34a5a8a8648d6828c7250f9900" translate="yes" xml:space="preserve">
          <source>Note this configuration is cached once the project is pushed onto the stack. Calling it multiple times won't cause it to be recomputed.</source>
          <target state="translated">Обратите внимание,что эта конфигурация кэшируется,как только проект попадает в стек.Многократные вызовы не приведут к его пересчету.</target>
        </trans-unit>
        <trans-unit id="9d029ff8336c9288d7f18814c831f1d16b88a78a" translate="yes" xml:space="preserve">
          <source>Note this function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">Обратите внимание,что эта функция не пересекает AST,расширяется только корневой узел.</target>
        </trans-unit>
        <trans-unit id="4362db14fb11f2864280f428b48d005c5873f981" translate="yes" xml:space="preserve">
          <source>Note this function expects a well-formed URI and does not perform any validation. See the &quot;Examples&quot; section below for examples of how &lt;a href=&quot;#parse/1&quot;&gt;&lt;code&gt;URI.parse/1&lt;/code&gt;&lt;/a&gt; can be used to parse a wide range of URIs.</source>
          <target state="translated">Обратите внимание, что эта функция ожидает правильно сформированный URI и не выполняет никаких проверок. В разделе &amp;laquo;Примеры&amp;raquo; ниже приведены примеры того, как &lt;a href=&quot;#parse/1&quot;&gt; &lt;code&gt;URI.parse/1&lt;/code&gt; &lt;/a&gt; можно использовать для синтаксического анализа широкого диапазона URI.</target>
        </trans-unit>
        <trans-unit id="3f1cee9305c51b1d0d2373452f46efc36d69c692" translate="yes" xml:space="preserve">
          <source>Note this function expects a well-formed URI and does not perform any validation. See the &quot;Examples&quot; section below for examples of how &lt;a href=&quot;uri#parse/1&quot;&gt;&lt;code&gt;URI.parse/1&lt;/code&gt;&lt;/a&gt; can be used to parse a wide range of URIs.</source>
          <target state="translated">Обратите внимание, что эта функция ожидает правильно сформированный URI и не выполняет никакой проверки. В разделе &amp;laquo;Примеры&amp;raquo; ниже приведены примеры того, как &lt;a href=&quot;uri#parse/1&quot;&gt; &lt;code&gt;URI.parse/1&lt;/code&gt; &lt;/a&gt; можно использовать для синтаксического анализа широкого диапазона URI.</target>
        </trans-unit>
        <trans-unit id="a6f74ff98cf77b2a5593760e563d32600a4851c6" translate="yes" xml:space="preserve">
          <source>Note this function requires the task supervisor to have &lt;code&gt;:temporary&lt;/code&gt; as the &lt;code&gt;:restart&lt;/code&gt; option (the default), as &lt;a href=&quot;#async_nolink/4&quot;&gt;&lt;code&gt;async_nolink/4&lt;/code&gt;&lt;/a&gt; keeps a direct reference to the task which is lost if the task is restarted.</source>
          <target state="translated">Обратите внимание, что эта функция требует, чтобы супервизор задач имел &lt;code&gt;:temporary&lt;/code&gt; параметр &lt;code&gt;:restart&lt;/code&gt; (по умолчанию), поскольку &lt;a href=&quot;#async_nolink/4&quot;&gt; &lt;code&gt;async_nolink/4&lt;/code&gt; &lt;/a&gt; сохраняет прямую ссылку на задачу, которая теряется при перезапуске задачи.</target>
        </trans-unit>
        <trans-unit id="ad3d41e55f91873f9f2759e06026d6db997aaba7" translate="yes" xml:space="preserve">
          <source>Note we do not recommend configuring Erlang/OTP's logger directly under the &lt;code&gt;:kernel&lt;/code&gt; application in your &lt;code&gt;config/config.exs&lt;/code&gt;, like this:</source>
          <target state="translated">Обратите внимание, что мы не рекомендуем настраивать регистратор Erlang / OTP непосредственно под приложением &lt;code&gt;:kernel&lt;/code&gt; в вашем &lt;code&gt;config/config.exs&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="670fcc75233bb15545426defd664d58989830420" translate="yes" xml:space="preserve">
          <source>Note we have wrapped it in a &lt;code&gt;Mix.env() == :prod&lt;/code&gt; check, so this configuration does not apply to other environments.</source>
          <target state="translated">Обратите внимание, что мы заключили его в &lt;code&gt;Mix.env() == :prod&lt;/code&gt; , поэтому эта конфигурация не применяется к другим средам.</target>
        </trans-unit>
        <trans-unit id="94cf8d3395ef431ef4381beb9ead018cca5e96ef" translate="yes" xml:space="preserve">
          <source>Note we only set the port on start/daemon commands. If you also limit the port on other commands, such as &lt;code&gt;rpc&lt;/code&gt;, then you will be unable to establish a remote connection as the port will already be in use by the node.</source>
          <target state="translated">Обратите внимание, что мы устанавливаем порт только для команд start / daemon. Если вы также ограничиваете порт другими командами, такими как &lt;code&gt;rpc&lt;/code&gt; , вы не сможете установить удаленное соединение, так как порт уже будет использоваться узлом.</target>
        </trans-unit>
        <trans-unit id="aa4a640e0a030948b5a35ad9f1605a103aa1b3ef" translate="yes" xml:space="preserve">
          <source>Note we removed &lt;code&gt;async: true&lt;/code&gt; from &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Since the application environment is a global storage, tests that modify it cannot run concurrently. With all changes in place, all tests should pass, including the distributed one.</source>
          <target state="translated">Обратите внимание, что мы удалили &lt;code&gt;async: true&lt;/code&gt; из &lt;code&gt;use ExUnit.Case&lt;/code&gt; . Поскольку среда приложения представляет собой глобальное хранилище, тесты, изменяющие ее, не могут выполняться одновременно. При внесении всех изменений должны пройти все тесты, в том числе распределенный.</target>
        </trans-unit>
        <trans-unit id="eac2c1b3b01e930084b33fb0d5edbf4e23375457" translate="yes" xml:space="preserve">
          <source>Note you can also start it simply as &lt;code&gt;Stack&lt;/code&gt;, which is the same as &lt;code&gt;{Stack, []}&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что вы также можете запустить его просто как &lt;code&gt;Stack&lt;/code&gt; , что совпадает с &lt;code&gt;{Stack, []}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="002eb13193e06aa56b8ea00565416925c92cd1a9" translate="yes" xml:space="preserve">
          <source>Note you don&amp;rsquo;t need to define a behaviour in order to dynamically dispatch on a module, but those features often go hand in hand.</source>
          <target state="translated">Обратите внимание, что вам не нужно определять поведение для динамической отправки модуля, но эти функции часто идут рука об руку.</target>
        </trans-unit>
        <trans-unit id="010ffd58d35ff5aa8ceade9793ef288a87b30082" translate="yes" xml:space="preserve">
          <source>Note you don't need to define all applications in &lt;code&gt;:applications&lt;/code&gt;, only the entry points. Also remember that the recommended mode for all applications in the system is &lt;code&gt;:permanent&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что вам не нужно определять все приложения в &lt;code&gt;:applications&lt;/code&gt; , только точки входа. Также помните, что рекомендуемый режим для всех приложений в системе &lt;code&gt;:permanent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7fe1cc0f5eaee6fed761d78f416437776eb240f" translate="yes" xml:space="preserve">
          <source>Note, however, some configuration files, such as &lt;code&gt;config/runtime.exs&lt;/code&gt; does not support imports, as they are meant to be copied across systems.</source>
          <target state="translated">Однако обратите внимание, что некоторые файлы конфигурации, такие как &lt;code&gt;config/runtime.exs&lt;/code&gt; , не поддерживают импорт, поскольку они предназначены для копирования между системами.</target>
        </trans-unit>
        <trans-unit id="ccaa9177febc5965f3a6e9991d73e149b8c2b3d0" translate="yes" xml:space="preserve">
          <source>Note: All modules defined in Elixir are defined inside the main &lt;code&gt;Elixir&lt;/code&gt; namespace. However, for convenience, you can omit &amp;ldquo;Elixir.&amp;rdquo; when referencing them.</source>
          <target state="translated">Примечание: все модули, определенные в Elixir, определены в основном пространстве имен &lt;code&gt;Elixir&lt;/code&gt; . Однако для удобства вы можете опустить &amp;laquo;Эликсир&amp;raquo;. при обращении к ним.</target>
        </trans-unit>
        <trans-unit id="f9375188837fda1326cbb4f55c2eddcde5896357" translate="yes" xml:space="preserve">
          <source>Note: An interesting note regarding &lt;code&gt;if/2&lt;/code&gt; and &lt;code&gt;unless/2&lt;/code&gt; is that they are implemented as macros in the language; they aren&amp;rsquo;t special language constructs as they would be in many languages. You can check the documentation and the source of &lt;code&gt;if/2&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;the &lt;code&gt;Kernel&lt;/code&gt; module docs&lt;/a&gt;. The &lt;code&gt;Kernel&lt;/code&gt; module is also where operators like &lt;code&gt;+/2&lt;/code&gt; and functions like &lt;code&gt;is_function/2&lt;/code&gt; are defined, all automatically imported and available in your code by default.</source>
          <target state="translated">Примечание. Интересное замечание относительно &lt;code&gt;if/2&lt;/code&gt; и &lt;code&gt;unless/2&lt;/code&gt; состоит в том, что они реализованы в языке как макросы; это не особые языковые конструкции, как во многих языках. Вы можете проверить документацию и источник &lt;code&gt;if/2&lt;/code&gt; в &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;с &lt;code&gt;Kernel&lt;/code&gt; модуля документации&lt;/a&gt; . В модуле &lt;code&gt;Kernel&lt;/code&gt; также определены такие операторы, как &lt;code&gt;+/2&lt;/code&gt; и функции, такие как &lt;code&gt;is_function/2&lt;/code&gt; , которые автоматически импортируются и доступны в вашем коде по умолчанию.</target>
        </trans-unit>
        <trans-unit id="333c3af19d66fc17e99fc5af70f1d710e9bfc88f" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;observer&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package. Alternatively, you can skip this section and continue the guide.</source>
          <target state="translated">Примечание. Если &lt;code&gt;observer&lt;/code&gt; не запускается, то могло произойти вот что: некоторые менеджеры пакетов по умолчанию устанавливают минимизированный Erlang без привязок WX для поддержки графического интерфейса. В некоторых менеджерах пакетов вы можете заменить безголовый Erlang более полным пакетом (ищите пакеты с именем &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; в Debian / Ubuntu / Arch). В других менеджерах вам может потребоваться установить отдельный пакет &lt;code&gt;erlang-wx&lt;/code&gt; (или пакет с аналогичным названием). Кроме того, вы можете пропустить этот раздел и продолжить руководство.</target>
        </trans-unit>
        <trans-unit id="1d918daa7b1094720a58030ddd5f21024965cb9a" translate="yes" xml:space="preserve">
          <source>Note: If you are an Erlang developer, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; in Elixir actually map to the &lt;code&gt;andalso&lt;/code&gt; and &lt;code&gt;orelse&lt;/code&gt; operators in Erlang.</source>
          <target state="translated">Примечание: Если вы разработчик Erlang, &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; в Elixir фактически карту к &lt;code&gt;andalso&lt;/code&gt; и &lt;code&gt;orelse&lt;/code&gt; операторов в Erlang.</target>
        </trans-unit>
        <trans-unit id="ff9e17f09f7587478a4a85a5f5ba16eb3160272e" translate="yes" xml:space="preserve">
          <source>Note: Maps were recently introduced into the Erlang</source>
          <target state="translated">Примечание:Карты были недавно введены в Эрланге.</target>
        </trans-unit>
        <trans-unit id="96f2bbaf73f21c5d620e6ce00661ef3a7f853b26" translate="yes" xml:space="preserve">
          <source>Note: Mix is an Elixir executable. This means that in order to run &lt;code&gt;mix&lt;/code&gt;, you need to have both &lt;code&gt;mix&lt;/code&gt; and &lt;code&gt;elixir&lt;/code&gt; executables in your PATH. That&amp;rsquo;s what happens when you install Elixir.</source>
          <target state="translated">Примечание: Mix - это исполняемый файл Elixir. Это означает, что для запуска &lt;code&gt;mix&lt;/code&gt; вам необходимо иметь исполняемые файлы &lt;code&gt;mix&lt;/code&gt; и &lt;code&gt;elixir&lt;/code&gt; в вашем PATH. Вот что происходит при установке Эликсира.</target>
        </trans-unit>
        <trans-unit id="ccb589e6f497a521acf64f009eba87d24abf9844" translate="yes" xml:space="preserve">
          <source>Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the &lt;code&gt;time: :posix&lt;/code&gt; option.</source>
          <target state="translated">Примечание. Поскольку время файлов хранится в формате времени POSIX в большинстве операционных систем, быстрее получить информацию о файле с параметром &lt;code&gt;time: :posix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85c13b1aace1377737ca0a9ef86cd79955430879" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;destination&lt;/code&gt; is an existing directory or not. We have chosen to explicitly disallow this behaviour. If &lt;code&gt;source&lt;/code&gt; is a &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">Примечание. Команда &lt;code&gt;cp&lt;/code&gt; в системах Unix ведет себя по-разному в зависимости от того, является ли &lt;code&gt;destination&lt;/code&gt; существующим каталогом или нет. Мы решили явно запретить такое поведение. Если &lt;code&gt;source&lt;/code&gt; является &lt;code&gt;file&lt;/code&gt; а &lt;code&gt;destination&lt;/code&gt; является каталог, будет возвращено &lt;code&gt;{:error, :eisdir}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="587e5cfb89d0a03b03528404235c890650244b41" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.</source>
          <target state="translated">Примечание. Команда &lt;code&gt;cp&lt;/code&gt; в системах Unix ведет себя по-разному в зависимости от того, является ли адрес назначения существующим каталогом или нет. Мы решили явно запретить копирование в место назначения, которое является каталогом, и при попытке будет возвращена ошибка.</target>
        </trans-unit>
        <trans-unit id="bc27a55b2f54548178ef196dd8d09255e8434e41" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix-like systems behaves differently depending on whether &lt;code&gt;destination&lt;/code&gt; is an existing directory or not. We have chosen to explicitly disallow this behaviour. If &lt;code&gt;source&lt;/code&gt; is a &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">Примечание. Команда &lt;code&gt;cp&lt;/code&gt; в Unix-подобных системах ведет себя по-разному в зависимости от того, является ли &lt;code&gt;destination&lt;/code&gt; существующим каталогом или нет. Мы решили явно запретить такое поведение. Если &lt;code&gt;source&lt;/code&gt; является &lt;code&gt;file&lt;/code&gt; а &lt;code&gt;destination&lt;/code&gt; является каталог, будет возвращено &lt;code&gt;{:error, :eisdir}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c1c6fecf03bb5a6c13228be756f3823698bbd1" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix-like systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.</source>
          <target state="translated">Примечание. Команда &lt;code&gt;cp&lt;/code&gt; в Unix-подобных системах ведет себя по-разному в зависимости от того, является ли адрес назначения существующим каталогом или нет. Мы решили явно запретить копирование в место назначения, которое является каталогом, и при попытке будет возвращена ошибка.</target>
        </trans-unit>
        <trans-unit id="2412c082ee9452e0961827f93fc820b4560394ce" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;mv&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;source&lt;/code&gt; is a file and the &lt;code&gt;destination&lt;/code&gt; is an existing directory. We have chosen to explicitly disallow this behaviour.</source>
          <target state="translated">Примечание. Команда &lt;code&gt;mv&lt;/code&gt; в системах Unix ведет себя по-разному в зависимости от того, является ли &lt;code&gt;source&lt;/code&gt; файлом, а &lt;code&gt;destination&lt;/code&gt; - существующий каталог. Мы решили явно запретить такое поведение.</target>
        </trans-unit>
        <trans-unit id="d7aaf6f04ff253bbc95b6fc72d0ff877c2ac6e9f" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;mv&lt;/code&gt; in Unix-like systems behaves differently depending on whether &lt;code&gt;source&lt;/code&gt; is a file and the &lt;code&gt;destination&lt;/code&gt; is an existing directory. We have chosen to explicitly disallow this behaviour.</source>
          <target state="translated">Примечание. Команда &lt;code&gt;mv&lt;/code&gt; в Unix-подобных системах ведет себя по-разному в зависимости от того, является ли &lt;code&gt;source&lt;/code&gt; файлом, а &lt;code&gt;destination&lt;/code&gt; - существующий каталог. Мы решили явно запретить такое поведение.</target>
        </trans-unit>
        <trans-unit id="318ba01affa2cb83a445a4ffd6d8bf1dd6eb9f01" translate="yes" xml:space="preserve">
          <source>Note: Unlike Erlang, user defined attributes are not stored in the module by default. The value exists only during compilation time. A developer can configure an attribute to behave closer to Erlang by calling &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Примечание. В отличие от Erlang, определенные пользователем атрибуты по умолчанию не хранятся в модуле. Значение существует только во время компиляции. Разработчик может настроить атрибут так, чтобы он соответствовал Erlang, вызвав &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efbaf6796d8f2470a0ab3f99e235b2791b2fba4b" translate="yes" xml:space="preserve">
          <source>Note: do not add parens when accessing fields, such as in &lt;code&gt;data.key()&lt;/code&gt;. If parenthesis are used, Elixir will consider it to be a function call on &lt;code&gt;data&lt;/code&gt;, which would be expected to be an atom.</source>
          <target state="translated">Примечание: не добавляйте скобки при доступе к полям, например, в &lt;code&gt;data.key()&lt;/code&gt; . Если используются круглые скобки, Elixir будет считать, что это вызов функции для &lt;code&gt;data&lt;/code&gt; , которые, как ожидается, будут атомом.</target>
        </trans-unit>
        <trans-unit id="d6501e4eb8325e3aa1733c1d78f4786f805cb16e" translate="yes" xml:space="preserve">
          <source>Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="translated">Примечание:не используйте эту функцию на IO устройствах в режиме Юникод,так как она вернет неверный результат.</target>
        </trans-unit>
        <trans-unit id="767ed77ecda9bec0c064d33f222982b4d00c82a3" translate="yes" xml:space="preserve">
          <source>Note: escripts do not support projects and dependencies that need to store or read artifacts from the priv directory.</source>
          <target state="translated">Замечание:эскрипты не поддерживают проекты и зависимости,которые должны хранить или читать артефакты из приватного каталога.</target>
        </trans-unit>
        <trans-unit id="87f046ebf1cef9cc4aa9894db1ed9941904ef965" translate="yes" xml:space="preserve">
          <source>Note: if you are on Windows, you can also try &lt;code&gt;iex --werl&lt;/code&gt; (&lt;code&gt;iex.bat --werl&lt;/code&gt; on PowerShell) which may provide a better experience depending on which console you are using.</source>
          <target state="translated">Примечание: если вы работаете в Windows, вы также можете попробовать &lt;code&gt;iex --werl&lt;/code&gt; ( &lt;code&gt;iex.bat --werl&lt;/code&gt; в PowerShell), который может улучшить работу в зависимости от того, какую консоль вы используете.</target>
        </trans-unit>
        <trans-unit id="dc1575464df3ee39226b1eec5b01c029bb5c0bef" translate="yes" xml:space="preserve">
          <source>Note: if you are on Windows, you can also try &lt;code&gt;iex.bat --werl&lt;/code&gt; which may provide a better experience depending on which console you are using.</source>
          <target state="translated">Примечание: если вы работаете в Windows, вы также можете попробовать &lt;code&gt;iex.bat --werl&lt;/code&gt; , который может улучшить работу в зависимости от того, какую консоль вы используете.</target>
        </trans-unit>
        <trans-unit id="912e5c0c98d6ca0f341e5fc328517d2b1fabbcad" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering &lt;code&gt;iex&lt;/code&gt; (&lt;code&gt;iex.bat&lt;/code&gt;).</source>
          <target state="translated">Примечание: если вы работаете в Windows, есть вероятность, что ваш терминал по умолчанию не использует UTF-8. Вы можете изменить кодировку текущего сеанса, запустив &lt;code&gt;chcp 65001&lt;/code&gt; перед входом в &lt;code&gt;iex&lt;/code&gt; ( &lt;code&gt;iex.bat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4dbeaf674e0eb7ea6925af7a2318ed6c85002a1" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering IEx.</source>
          <target state="translated">Примечание: если вы работаете в Windows, есть вероятность, что ваш терминал по умолчанию не использует UTF-8. Вы можете изменить кодировку текущего сеанса, запустив &lt;code&gt;chcp 65001&lt;/code&gt; перед вводом IEx.</target>
        </trans-unit>
        <trans-unit id="8e6389ccfd4efe5ada7d55d154db6d0a4d03109a" translate="yes" xml:space="preserve">
          <source>Note: if you set this to &lt;code&gt;false&lt;/code&gt; for an Elixir project, you will have to add paths to Elixir's &lt;code&gt;ebin&lt;/code&gt; directories to &lt;code&gt;ERL_LIBS&lt;/code&gt; environment variable when running the resulting escript, in order for the code loader to be able to find &lt;code&gt;:elixir&lt;/code&gt; application and its children applications (if they are used).</source>
          <target state="translated">Примечание: если вы установите это значение &lt;code&gt;false&lt;/code&gt; для проекта Elixir, вам придется добавить пути к эликсиру в &lt;code&gt;ebin&lt;/code&gt; каталоги &lt;code&gt;ERL_LIBS&lt;/code&gt; переменной среды при работе в результате escript, для того , чтобы код загрузчика , чтобы иметь возможность найти &lt;code&gt;:elixir&lt;/code&gt; приложение и его дети приложения (если они используются).</target>
        </trans-unit>
        <trans-unit id="8ccad6d1cb0c1e92a31e2fb1270a6789b9c4f735" translate="yes" xml:space="preserve">
          <source>Note: if you want to find and execute a given script in PATH so it will be loaded in &lt;code&gt;iex&lt;/code&gt; use: &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt;. Later you&amp;rsquo;ll learn about &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix&lt;/a&gt;, Elixir&amp;rsquo;s build tool, and how you can compile and load entire applications with &lt;code&gt;iex -S mix run&lt;/code&gt;. See &lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;Supervisor and application&lt;/a&gt; for more details.</source>
          <target state="translated">Примечание: если вы хотите найти и выполнить данный скрипт в PATH, чтобы он был загружен в &lt;code&gt;iex&lt;/code&gt; , используйте: &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt; . Позже вы узнаете о &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix&lt;/a&gt; , инструменте сборки Elixir, а также о том, как вы можете компилировать и загружать целые приложения с помощью &lt;code&gt;iex -S mix run&lt;/code&gt; . Для получения более подробной информации см. &lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;Супервайзер и приложение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a231dc0df4ef51799726d55cc38b62b732c2965c" translate="yes" xml:space="preserve">
          <source>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Примечание: имейте в виду, что эта функция разбивается на графемы, и для этого она должна линейно перемещаться по строке. Если вы хотите разделить строку или двоичный файл в зависимости от количества байтов, используйте вместо этого &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a2b2736d0228ed219724e9f93f70ec1ac8cd179" translate="yes" xml:space="preserve">
          <source>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Примечание: имейте в виду, что эта функция разбивается на графемы, и для этого она должна линейно перемещаться по строке. Если вы хотите разбить строку или двоичный файл в зависимости от количества байтов, используйте вместо этого &lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57e11fb647c860e43cb9b2c5f6c254e9e56dfddb" translate="yes" xml:space="preserve">
          <source>Note: the Debugger snippet above was retrieved from &lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;&amp;ldquo;Debugging techniques in Elixir&amp;rdquo; by Plataformatec&lt;/a&gt;.</source>
          <target state="translated">Примечание: приведенный выше фрагмент отладчика был получен из &lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;&amp;laquo;Методы отладки в Эликсире&amp;raquo; компании Plataformatec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="455360e26c9eab98077492b42dd026c45ea2e164" translate="yes" xml:space="preserve">
          <source>Note: this function is equivalent to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#flat_map_reduce/3&quot;&gt;&lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt;&lt;/a&gt;, except this function does not return the accumulator once the stream is processed.</source>
          <target state="translated">Примечание: эта функция эквивалентна &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#flat_map_reduce/3&quot;&gt; &lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt; &lt;/a&gt; , за исключением того, что эта функция не возвращает аккумулятор после обработки потока.</target>
        </trans-unit>
        <trans-unit id="92f2e22007c90b9cbb55bb29dc07138d25f25b5c" translate="yes" xml:space="preserve">
          <source>Note: this function is similar to &lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt;&lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt;&lt;/a&gt; except the latter returns both the flat list and accumulator, while this one returns only the stream.</source>
          <target state="translated">Примечание: эта функция похожа на &lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt; &lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt; ,&lt;/a&gt; за исключением того, что последний возвращает как плоский список, так и аккумулятор, тогда как этот возвращает только поток.</target>
        </trans-unit>
        <trans-unit id="1838e9e0c7c7ddb2da84c8c70085cf8301982628" translate="yes" xml:space="preserve">
          <source>Note: we will be using two nodes in the same machine throughout this chapter. You are free to use two (or more) different machines on the same network but you need to do some prep work. First of all, you need to ensure all machines have a &lt;code&gt;~/.erlang.cookie&lt;/code&gt; file with exactly the same value. Second, you need to guarantee &lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt; is running on a port that is not blocked (you can run &lt;code&gt;epmd -d&lt;/code&gt; for debug info). Third, if you want to learn more about distribution in general, we recommend &lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;this great Distribunomicon chapter from Learn You Some Erlang&lt;/a&gt;.</source>
          <target state="translated">Примечание: в этой главе мы будем использовать два узла на одной машине. Вы можете использовать две (или более) разные машины в одной сети, но вам необходимо выполнить некоторую подготовительную работу. Прежде всего, вам необходимо убедиться, что на всех машинах есть файл &lt;code&gt;~/.erlang.cookie&lt;/code&gt; с точно таким же значением. Во-вторых, вам нужно гарантировать, что &lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt; работает на незаблокированном порту (вы можете запустить &lt;code&gt;epmd -d&lt;/code&gt; для получения отладочной информации). В-третьих, если вы хотите узнать больше о дистрибутиве в целом, мы рекомендуем &lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;эту замечательную главу о Distribunomicon из Learn You Some Erlang&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1f1223d3d0c72df45c1e2b35a2ccf27e67399b" translate="yes" xml:space="preserve">
          <source>Note: you will likely get different process identifiers than the ones we are getting in this guide.</source>
          <target state="translated">Замечание:вы,скорее всего,получите идентификаторы процессов,отличные от тех,которые мы получаем в этом руководстве.</target>
        </trans-unit>
        <trans-unit id="e501dc317df6513b552e6ef09f3d93b0d31cfc45" translate="yes" xml:space="preserve">
          <source>Nothing really exciting happens but it shows how we can control our application.</source>
          <target state="translated">Ничего по-настоящему захватывающего не происходит,но это показывает,как мы можем контролировать наше приложение.</target>
        </trans-unit>
        <trans-unit id="3f9f6ccaa3929763f1f8329a0cf42d1567c947e3" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;spawn/1&lt;/code&gt; returns a PID (process identifier). At this point, the process you spawned is very likely dead. The spawned process will execute the given function and exit after the function is done:</source>
          <target state="translated">Уведомление &lt;code&gt;spawn/1&lt;/code&gt; возвращает PID (идентификатор процесса). На этом этапе процесс, который вы создали, скорее всего, мертв. Созданный процесс выполнит заданную функцию и завершит работу после ее завершения:</target>
        </trans-unit>
        <trans-unit id="28bdc086982ce6f35c77fe8c28e2ce539fb72e7b" translate="yes" xml:space="preserve">
          <source>Notice doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">Обратите внимание, что у тестов есть ограничения. Если вы не можете доктестировать функцию, потому что она зависит от состояния или побочных эффектов, мы рекомендуем разработчикам включать примеры напрямую, без &lt;code&gt;iex&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b421e9b5a288fb270e5d94ac8ec254970e093c" translate="yes" xml:space="preserve">
          <source>Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:</source>
          <target state="translated">Обратите внимание,что &quot;Возвращение 5&quot; было напечатано дважды,а не один раз.Это связано с тем,что макрос получает выражение,а не значение (что и следовало ожидать в регулярной функции).Это означает,что:</target>
        </trans-unit>
        <trans-unit id="1f183e763daf66a140719d8dda2839335bb5a222" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; even though the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt; function is not imported. In fact, even if &lt;code&gt;return_length/0&lt;/code&gt; imported a function with the same name and arity from another module, it wouldn't affect the function result:</source>
          <target state="translated">Обратите внимание, как &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; возвращает &lt;code&gt;3&lt;/code&gt; , хотя &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt; не импортирована. Фактически, даже если &lt;code&gt;return_length/0&lt;/code&gt; импортировал функцию с тем же именем и арностью из другого модуля, это не повлияет на результат функции:</target>
        </trans-unit>
        <trans-unit id="3892c7952171348da3fa8fc4e90871b3d046b9b8" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; even though the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt; function is not imported. In fact, even if &lt;code&gt;return_length/0&lt;/code&gt; imported a function with the same name and arity from another module, it wouldn't affect the function result:</source>
          <target state="translated">Обратите внимание, как &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; возвращает &lt;code&gt;3&lt;/code&gt; , хотя &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt; не импортирована. Фактически, даже если &lt;code&gt;return_length/0&lt;/code&gt; импортировал функцию с тем же именем и арностью из другого модуля, это не повлияет на результат функции:</target>
        </trans-unit>
        <trans-unit id="86cf6571366da66046772448d17be71c9b8bac4d" translate="yes" xml:space="preserve">
          <source>Notice how the example above has a comma between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;do:&lt;/code&gt;, that&amp;rsquo;s because it is using Elixir&amp;rsquo;s regular syntax where each argument is separated by a comma. We say this syntax is using &lt;em&gt;keyword lists&lt;/em&gt;. We can pass &lt;code&gt;else&lt;/code&gt; using keywords too:</source>
          <target state="translated">Обратите внимание, что в приведенном выше примере есть запятая между &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;do:&lt;/code&gt; , потому что он использует обычный синтаксис Elixir, в котором каждый аргумент разделен запятой. Мы говорим, что этот синтаксис использует &lt;em&gt;списки ключевых слов&lt;/em&gt; . Мы также можем передать &lt;code&gt;else&lt;/code&gt; используя ключевые слова:</target>
        </trans-unit>
        <trans-unit id="089ef5aec5dcab204a4dde60fdae6b22199f9d60" translate="yes" xml:space="preserve">
          <source>Notice how the process is keeping a state and we can get and update this state by sending the process messages. In fact, any process that knows the &lt;code&gt;pid&lt;/code&gt; above will be able to send it messages and manipulate the state.</source>
          <target state="translated">Обратите внимание, как процесс сохраняет состояние, и мы можем получить и обновить это состояние, отправив сообщения процесса. Фактически, любой процесс, который знает указанный выше &lt;code&gt;pid&lt;/code&gt; , сможет отправлять ему сообщения и управлять состоянием.</target>
        </trans-unit>
        <trans-unit id="68d3a08b640aa9ec43f4df6e72697d747babcab8" translate="yes" xml:space="preserve">
          <source>Notice how the supervisor automatically started a new registry, with a new PID, in place of the first one once we caused it to crash due to a bad input.</source>
          <target state="translated">Обратите внимание,как супервайзер автоматически запустил новый реестр,с новым PID,вместо первого,как только мы вызвали его аварийное завершение из-за плохого ввода данных.</target>
        </trans-unit>
        <trans-unit id="9a6c5a958a0495f608cd080595362cf8cc21a5de" translate="yes" xml:space="preserve">
          <source>Notice how we were able to elegantly parse the commands without adding a bunch of &lt;code&gt;if/else&lt;/code&gt; clauses that check the command name and number of arguments!</source>
          <target state="translated">Обратите внимание, как мы смогли элегантно анализировать команды, не добавляя кучу предложений &lt;code&gt;if/else&lt;/code&gt; , которые проверяют имя команды и количество аргументов!</target>
        </trans-unit>
        <trans-unit id="6dfab922fecade531cb4dec0d9405839ea8b9d8a" translate="yes" xml:space="preserve">
          <source>Notice in this case we don't have to explicitly import &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor.Spec&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;use Supervisor&lt;/code&gt; automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the &lt;code&gt;c:init/1&lt;/code&gt; callback.</source>
          <target state="translated">Обратите внимание, что в этом случае нам не нужно явно импортировать &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor.Spec&lt;/code&gt; ,&lt;/a&gt; поскольку &lt;code&gt;use Supervisor&lt;/code&gt; делает это автоматически. Определение супервизора на основе модуля может быть полезно, например, для выполнения задач инициализации в &lt;code&gt;c:init/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c882f5ebb65100a3d2f1cd2368d20ea86c511dfc" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;.&lt;/code&gt; is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom:</source>
          <target state="translated">Обратите внимание на это &lt;code&gt;.&lt;/code&gt; тоже оператор. Удаленные вызовы используют точку в AST с двумя аргументами, где второй аргумент всегда является атомом:</target>
        </trans-unit>
        <trans-unit id="df067cb31b582b9b17b8ec8909cd436d56688f8e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;1 = x&lt;/code&gt; is a valid expression, and it matched because both the left and right side are equal to 1. When the sides do not match, a &lt;code&gt;MatchError&lt;/code&gt; is raised.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;1 = x&lt;/code&gt; - допустимое выражение, и оно совпадает, потому что левая и правая стороны равны 1. Когда стороны не совпадают, возникает &lt;code&gt;MatchError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea49ec32721d567bfbb9765cea3e755b4c4e02a9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;10 / 2&lt;/code&gt; returned a float &lt;code&gt;5.0&lt;/code&gt; instead of an integer &lt;code&gt;5&lt;/code&gt;. This is expected. In Elixir, the operator &lt;code&gt;/&lt;/code&gt; always returns a float. If you want to do integer division or get the division remainder, you can invoke the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; functions:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;10 / 2&lt;/code&gt; вернул число с плавающей запятой &lt;code&gt;5.0&lt;/code&gt; вместо целого числа &lt;code&gt;5&lt;/code&gt; . Это ожидаемо. В Эликсире оператор &lt;code&gt;/&lt;/code&gt; всегда возвращает число с плавающей точкой. Если вы хотите выполнить целочисленное деление или получить остаток от деления, вы можете вызвать функции &lt;code&gt;div&lt;/code&gt; и &lt;code&gt;rem&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="887a696d47512286eb5278c149faaa334a09a281" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;__STACKTRACE__&lt;/code&gt; can be used inside catch/rescue to retrieve the current stacktrace.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;__STACKTRACE__&lt;/code&gt; можно использовать внутри catch / rescue для получения текущей трассировки стека.</target>
        </trans-unit>
        <trans-unit id="d8d5e7850b7bd8f241d8a1343704189a623bfa62" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;put_elem/3&lt;/code&gt; returned a new tuple. The original tuple stored in the &lt;code&gt;tuple&lt;/code&gt; variable was not modified. Like lists, tuples are also immutable. Every operation on a tuple returns a new tuple, it never changes the given one.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;put_elem/3&lt;/code&gt; вернул новый кортеж. Исходный кортеж, хранящийся в переменной &lt;code&gt;tuple&lt;/code&gt; не был изменен. Как и списки, кортежи также неизменны. Каждая операция над кортежем возвращает новый кортеж, но никогда не изменяет данный.</target>
        </trans-unit>
        <trans-unit id="5b802bfe2367dd2e9b70b08829bc0a53825dc5da" translate="yes" xml:space="preserve">
          <source>Notice that Elixir allows you to drop the parentheses when invoking named functions. This feature gives a cleaner syntax when writing declarations and control-flow constructs.</source>
          <target state="translated">Обратите внимание,что Elixir позволяет опускать скобки при вызове именованных функций.Эта функция дает более чистый синтаксис при написании деклараций и конструкций потока управления.</target>
        </trans-unit>
        <trans-unit id="45ddeb0507e2941d4064cc4fd963a7f2bec2af71" translate="yes" xml:space="preserve">
          <source>Notice that before our changes &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That&amp;rsquo;s the main idea behind the cache mechanism we are implementing.</source>
          <target state="translated">Обратите внимание, что до наших изменений &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; отправлял запросы на сервер, но теперь он читает непосредственно из таблицы ETS, которая является общей для всех процессов. Это основная идея реализуемого нами механизма кеширования.</target>
        </trans-unit>
        <trans-unit id="6a0f0c1ec687f2ea0cd8655129747b9d7cd3f754" translate="yes" xml:space="preserve">
          <source>Notice that by running &lt;code&gt;mix test&lt;/code&gt;, Mix has compiled the source files and generated the application manifest once again. This happens because Mix supports multiple environments, which we will discuss later in this chapter.</source>
          <target state="translated">Обратите внимание, что, запустив &lt;code&gt;mix test&lt;/code&gt; , Mix скомпилировал исходные файлы и снова сгенерировал манифест приложения. Это происходит потому, что Mix поддерживает несколько сред, которые мы обсудим позже в этой главе.</target>
        </trans-unit>
        <trans-unit id="57e1fb0b39317bc0fdf150c6ab3ed9709eedac00" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;alias&lt;/code&gt; without the &lt;code&gt;:as&lt;/code&gt; option automatically sets an alias based on the last part of the module. For example:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;alias&lt;/code&gt; вызова без опции &lt;code&gt;:as&lt;/code&gt; автоматически устанавливает псевдоним на основе последней части модуля. Например:</target>
        </trans-unit>
        <trans-unit id="9daf8eefb4c15d859869ea5da53757de4d79f368" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;except&lt;/code&gt; is always exclusive on a previously declared &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt;. If there is no previous import, then it applies to all functions and macros in the module. For example:</source>
          <target state="translated">Обратите внимание, что вызов &lt;code&gt;except&lt;/code&gt; всегда эксклюзивен для ранее объявленного &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; . Если предыдущего импорта нет, то он применяется ко всем функциям и макросам в модуле. Например:</target>
        </trans-unit>
        <trans-unit id="4d111052cc1acb6679f60941ac62aab89e4c9ddf" translate="yes" xml:space="preserve">
          <source>Notice that different engines may have different rules for each tag. Other tags may be added in future versions.</source>
          <target state="translated">Обратите внимание,что разные двигатели могут иметь разные правила для каждого тега.Другие теги могут быть добавлены в будущих версиях.</target>
        </trans-unit>
        <trans-unit id="347481b6b324efbcacea6f493fbe1e9b884fc181" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is invoked by different processes concurrently, the first process to invoke &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; acquires a lock and the remaining ones will block until the file is available. This means that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is called more than once with a given file, that file will be compiled only once. The first process to call &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; will get the list of loaded modules, others will get &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; вызывается разными процессами одновременно, первый процесс, вызывающий &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; ,&lt;/a&gt; получает блокировку, а остальные будут блокироваться, пока файл не станет доступным. Это означает, что если &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; вызывается более одного раза с данным файлом, этот файл будет скомпилирован только один раз. Первый процесс, который вызовет &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; , получит список загруженных модулей, остальные - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e78784f8ee1baee6a6b68c15d6d35bbd3682972" translate="yes" xml:space="preserve">
          <source>Notice that it defines the application callback function, &lt;code&gt;start/2&lt;/code&gt;, and instead of defining a supervisor named &lt;code&gt;KVServer.Supervisor&lt;/code&gt; that uses the &lt;code&gt;Supervisor&lt;/code&gt; module, it conveniently defined the supervisor inline! You can read more about such supervisors by reading &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;the Supervisor module documentation&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что он определяет функцию обратного вызова приложения, &lt;code&gt;start/2&lt;/code&gt; , и вместо определения супервизора с именем &lt;code&gt;KVServer.Supervisor&lt;/code&gt; , который использует модуль &lt;code&gt;Supervisor&lt;/code&gt; , он удобно определил встроенный супервизор! Вы можете узнать больше о таких супервизорах, прочитав &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;документацию модуля супервизора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54b8e7a6900c64697dfb761c739ce312b8b3c54e" translate="yes" xml:space="preserve">
          <source>Notice that setting any of the values above overrides Elixir's default values. For example, setting &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; will no longer automatically require the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module. In the same way setting &lt;code&gt;:macros&lt;/code&gt; will no longer auto-import &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; macros like &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;Kernel.if/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#case/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Обратите внимание, что установка любого из значений выше переопределяет значения по умолчанию в Elixir. Например, для параметра &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; больше не будет автоматически требоваться модуль &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; . Таким же образом настройка &lt;code&gt;:macros&lt;/code&gt; больше не будут автоматически импортировать макросы &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; такие как &lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;Kernel.if/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#case/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt; &lt;/a&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="6e1f199b3af38598b79e950aaf97a0eca8c4b82c" translate="yes" xml:space="preserve">
          <source>Notice that string interpolation in Elixir calls the &lt;code&gt;to_string&lt;/code&gt; function:</source>
          <target state="translated">Обратите внимание, что интерполяция строк в Elixir вызывает функцию &lt;code&gt;to_string&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="840aa4d2de3105a50a863883569231610137217c" translate="yes" xml:space="preserve">
          <source>Notice that supervisor that reached maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option is set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">Обратите внимание, что супервизор, который достиг максимальной интенсивности перезапуска, выйдет с &lt;code&gt;:shutdown&lt;/code&gt; причиной выключения . В этом случае супервизор будет перезапущен только в том случае, если его дочерняя спецификация была определена с параметром &lt;code&gt;:restart&lt;/code&gt; , установленным на &lt;code&gt;:permanent&lt;/code&gt; (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="80888ed7f572f5d6e47653c01243b5f16e08dc6e" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;IO.puts/1&lt;/code&gt; function returns the atom &lt;code&gt;:ok&lt;/code&gt; after printing.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;IO.puts/1&lt;/code&gt; после печати возвращает атом &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e928f1dda24dbbefd3436c4e0da759a5854ad46" translate="yes" xml:space="preserve">
          <source>Notice that the number of bytes in that string is 6, even though it has 5 characters. That&amp;rsquo;s because the character &amp;ldquo;&amp;ouml;&amp;rdquo; takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of characters, by using the &lt;code&gt;String.length/1&lt;/code&gt; function:</source>
          <target state="translated">Обратите внимание, что количество байтов в этой строке равно 6, хотя она состоит из 5 символов. Это потому, что символ &amp;laquo;&amp;ouml;&amp;raquo; занимает 2 байта для представления в UTF-8. Мы можем получить фактическую длину строки, основанную на количестве символов, с помощью функции &lt;code&gt;String.length/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b70cce683e94cd3e61bbd344224ed09711c0bbe6" translate="yes" xml:space="preserve">
          <source>Notice that the number of bytes in that string is 6, even though it has 5 graphemes. That&amp;rsquo;s because the grapheme &amp;ldquo;&amp;ouml;&amp;rdquo; takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of graphemes, by using the &lt;code&gt;String.length/1&lt;/code&gt; function:</source>
          <target state="translated">Обратите внимание, что количество байтов в этой строке равно 6, хотя в ней 5 графем. Это потому, что графема &amp;laquo;&amp;ouml;&amp;raquo; занимает 2 байта для представления в UTF-8. Мы можем получить фактическую длину строки, основанную на количестве графем, используя функцию &lt;code&gt;String.length/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8942e3ca27cf75b423a37d9bfb02178064e23332" translate="yes" xml:space="preserve">
          <source>Notice that the supervisor that reaches maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">Обратите внимание, что супервизор, который достиг максимальной интенсивности перезапуска, выйдет с &lt;code&gt;:shutdown&lt;/code&gt; причина выключения . В этом случае супервизор будет перезапущен только в том случае, если его дочерняя спецификация была определена с параметром &lt;code&gt;:restart&lt;/code&gt; , установленным на &lt;code&gt;:permanent&lt;/code&gt; (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="46c8a4ba57727e7ee215c034d3fe51bd425fdf82" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt;, not &lt;code&gt;%{}&lt;/code&gt;. The notation &lt;code&gt;%{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">Обратите внимание, что синтаксическим представлением &lt;code&gt;map()&lt;/code&gt; является &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt; , а не &lt;code&gt;%{}&lt;/code&gt; . Обозначение &lt;code&gt;%{}&lt;/code&gt; указывает одноэлементный тип для пустой карты.</target>
        </trans-unit>
        <trans-unit id="bdf28662e920e08a018b921e52faac2f13427657" translate="yes" xml:space="preserve">
          <source>Notice that the third element in the quoted variable is the atom &lt;code&gt;Sample&lt;/code&gt;, instead of &lt;code&gt;nil&lt;/code&gt;, which marks the variable as coming from the &lt;code&gt;Sample&lt;/code&gt; module. Therefore, Elixir considers these two variables as coming from different contexts and handles them accordingly.</source>
          <target state="translated">Обратите внимание, что третий элемент в переменной в кавычках - это атом &lt;code&gt;Sample&lt;/code&gt; , а не &lt;code&gt;nil&lt;/code&gt; , который отмечает переменную как поступающую из модуля &lt;code&gt;Sample&lt;/code&gt; . Таким образом, Elixir считает эти две переменные происходящими из разных контекстов и обрабатывает их соответственно.</target>
        </trans-unit>
        <trans-unit id="6c70c0b543ddc39b4906e53100736219e7d916c9" translate="yes" xml:space="preserve">
          <source>Notice that the version with &lt;code&gt;!&lt;/code&gt; returns the contents of the file instead of a tuple, and if anything goes wrong the function raises an error.</source>
          <target state="translated">Обратите внимание, что версия с &lt;code&gt;!&lt;/code&gt; возвращает содержимое файла вместо кортежа, и если что-то пойдет не так, функция выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="ac1edafa4a033fbb4dca78373c1cefb5a29180a1" translate="yes" xml:space="preserve">
          <source>Notice that this function expects a list of integers representing UTF-8 code points. If you have a list of bytes, you must instead use the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта функция ожидает список целых чисел, представляющих кодовые точки UTF-8. Если у вас есть список байтов, вы должны вместо этого использовать &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; модуль&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdf2f5ea01fa067c0fbde027a86184d517fa295" translate="yes" xml:space="preserve">
          <source>Notice that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; instead. For more information about IO data and chardata, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">Обратите внимание, что эта функция обрабатывает целые числа в заданных данных ввода-вывода как необработанные байты и не выполняет никакого преобразования кодировки. Если вы хотите преобразовать из списка символов в строку в кодировке UTF-8, используйте вместо этого &lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о данных ввода-вывода и chardata см. В разделе &lt;a href=&quot;#module-io-data&quot;&gt;&amp;laquo;Данные ввода-вывода&amp;raquo;&lt;/a&gt; документации модуля.</target>
        </trans-unit>
        <trans-unit id="da2e36451104accdab1f135698969f5dbb62ea72" translate="yes" xml:space="preserve">
          <source>Notice that variables bound in a clause &quot;head&quot; do not leak to the outer context:</source>
          <target state="translated">Обратите внимание,что переменные,связанные в пункте &quot;head&quot;,не утечка во внешний контекст:</target>
        </trans-unit>
        <trans-unit id="8abda6194ee78d8c7b6bf446172dbd06081bc75a" translate="yes" xml:space="preserve">
          <source>Notice that we even see the exact same error message.</source>
          <target state="translated">Заметьте,что мы даже видим точно такое же сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="f18296fb1e15bf91d08f40da7cae0240a810e85c" translate="yes" xml:space="preserve">
          <source>Notice that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:</source>
          <target state="translated">Обратите внимание,что сначала мы распечатывали каждый элемент списка,затем умножали каждый элемент на 2 и,наконец,распечатывали каждое новое значение.В этом примере список был переписан три раза.Рассмотрим пример с потоками:</target>
        </trans-unit>
        <trans-unit id="e80454db9add600d6dd12ebc0cf1ec2362e0064d" translate="yes" xml:space="preserve">
          <source>Notice that we referred to structs as &lt;strong&gt;bare&lt;/strong&gt; maps because none of the protocols implemented for maps are available for structs. For example, you can neither enumerate nor access a struct:</source>
          <target state="translated">Обратите внимание , что мы упоминали как структуры &lt;strong&gt;голых&lt;/strong&gt; карт , потому что ни один из протоколов , реализованных для карт не доступны для структур. Например, вы не можете ни перечислить, ни получить доступ к структуре:</target>
        </trans-unit>
        <trans-unit id="e7bd2d8499eb11634d1cac7e077fdc215c19c9e6" translate="yes" xml:space="preserve">
          <source>Notice that when starting the GenServer, we are registering it with name &lt;code&gt;Stack&lt;/code&gt;, which allows us to call it directly and get what is on the stack:</source>
          <target state="translated">Обратите внимание, что при запуске GenServer мы регистрируем его с именем &lt;code&gt;Stack&lt;/code&gt; , что позволяет нам вызывать его напрямую и получать то, что находится в стеке:</target>
        </trans-unit>
        <trans-unit id="57f35a2e632227e4c4fd62aa0253d676ce9ec766" translate="yes" xml:space="preserve">
          <source>Notice that, even though the alias &lt;code&gt;M&lt;/code&gt; is not available in the context the macro is expanded, the code above works because &lt;code&gt;M&lt;/code&gt; still expands to &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что, хотя псевдоним &lt;code&gt;M&lt;/code&gt; недоступен в контексте раскрытия макроса, приведенный выше код работает, потому что &lt;code&gt;M&lt;/code&gt; по- прежнему расширяется до &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6878fe98d8554fc9f432df2a9141f6399af678" translate="yes" xml:space="preserve">
          <source>Notice that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</source>
          <target state="translated">Обратите внимание,что хотя шаблоны могут быть заданы для макросов,помните,что макросы получают AST в качестве аргументов,а не значений.Например,если попытаться разбить макрос на следующий шаблон:</target>
        </trans-unit>
        <trans-unit id="5cf97154e72e91b95ed319e84cacaa08b368821a" translate="yes" xml:space="preserve">
          <source>Notice the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">Заметьте,что перерыв был представлен как есть,потому что мы не достигли лимита линии.Как только мы это делаем,он заменяется новой линией:</target>
        </trans-unit>
        <trans-unit id="496f1449954afceaf9beb520372d8e05f415dd6b" translate="yes" xml:space="preserve">
          <source>Notice the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">Обратите внимание,что разрыв был представлен данной строкой,потому что мы не достигли предела строки.Как только мы это делаем,она заменяется новой строкой:</target>
        </trans-unit>
        <trans-unit id="3e4325519e924c99a829325af4cfbcadb94f2b5a" translate="yes" xml:space="preserve">
          <source>Notice the user-supplied function is wrapped into a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function must return a tagged tuple after each step, as described in the &lt;a href=&quot;#t:acc/0&quot;&gt;&lt;code&gt;acc/0&lt;/code&gt;&lt;/a&gt; type. At the end, &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что функция, предоставляемая пользователем, заключена в функцию &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; . Функция &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; должна возвращать помеченный кортеж после каждого шага, как описано в типе &lt;a href=&quot;#t:acc/0&quot;&gt; &lt;code&gt;acc/0&lt;/code&gt; &lt;/a&gt; . В конце &lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; возвращает &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07069adb0c1e46329be40dc3e44e76edaef1ef62" translate="yes" xml:space="preserve">
          <source>Notice this function will traverse the whole &lt;code&gt;enumerable&lt;/code&gt; to get the random sublist.</source>
          <target state="translated">Обратите внимание, что эта функция будет проходить по всему &lt;code&gt;enumerable&lt;/code&gt; чтобы получить случайный подсписок.</target>
        </trans-unit>
        <trans-unit id="89e0bc5cd464e7720b387f9becc6e78a50eb339c" translate="yes" xml:space="preserve">
          <source>Notice we didn't implement it for lists as we don't have the &lt;code&gt;size&lt;/code&gt; information on lists, rather its value needs to be computed with &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы не реализовали его для списков, поскольку у нас нет информации о &lt;code&gt;size&lt;/code&gt; в списках, скорее, его значение должно быть вычислено с &lt;code&gt;length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03afe8d614ca6b25d6bf98b3847bcf90d9034dfa" translate="yes" xml:space="preserve">
          <source>Notice we had to escape the backslash escape character (i.e., we used &lt;code&gt;\\N&lt;/code&gt; instead of just &lt;code&gt;\N&lt;/code&gt; to escape the backslash; same thing for &lt;code&gt;\\g{N}&lt;/code&gt;). By giving &lt;code&gt;\0&lt;/code&gt;, one can inject the whole matched pattern in the replacement string.</source>
          <target state="translated">Обратите внимание, что нам пришлось избегать escape-символа обратной косой черты (т.е. мы использовали &lt;code&gt;\\N&lt;/code&gt; вместо просто &lt;code&gt;\N&lt;/code&gt; чтобы избежать обратной косой черты; то же самое для &lt;code&gt;\\g{N}&lt;/code&gt; ). Задав &lt;code&gt;\0&lt;/code&gt; , можно вставить весь совпадающий шаблон в строку замены.</target>
        </trans-unit>
        <trans-unit id="f85b4b1b8fafa24d41295fda0f44252f687ca128" translate="yes" xml:space="preserve">
          <source>Notice we have an inner tuple, containing the atom &lt;code&gt;:.&lt;/code&gt; representing the dot as first element:</source>
          <target state="translated">Обратите внимание, что у нас есть внутренний кортеж, содержащий атом &lt;code&gt;:.&lt;/code&gt; представляя точку как первый элемент:</target>
        </trans-unit>
        <trans-unit id="6c69e6930b5bc92d057ccefe34bb93eda478134f" translate="yes" xml:space="preserve">
          <source>Notice we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;lazy&lt;/em&gt; and the functions in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;eager&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что мы начали с диапазона, а затем создали поток, предназначенный для умножения каждого элемента в диапазоне на 2. На этом этапе вычислений не производилось. Только тогда , когда &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; называется мы на самом деле перечислять через каждый элемент в диапазоне, умножая его на 2 и добавление 1. Будет говорить , что функции в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; являются &lt;em&gt;ленивыми&lt;/em&gt; и функция в &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; являются &lt;em&gt;нетерпеливой&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ba47ef34cc51f70a00d9e0a27391c8b89cac3f5e" translate="yes" xml:space="preserve">
          <source>Now a struct can be created as follows:</source>
          <target state="translated">Теперь можно создать структуру следующим образом:</target>
        </trans-unit>
        <trans-unit id="ac6a27b4457ccc07e2ad2cacdcc3e23c4356feaa" translate="yes" xml:space="preserve">
          <source>Now all data types (including structs) that have not implemented the &lt;code&gt;Size&lt;/code&gt; protocol will be considered to have a size of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Теперь все типы данных (включая структуры), в которых не реализован протокол &lt;code&gt;Size&lt;/code&gt; , будут считаться имеющими размер &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89083d1bc146a648411e0ff3f2366a0deb9fa8b8" translate="yes" xml:space="preserve">
          <source>Now if you run the tests, you will see the test that checks the server interaction will fail, as it will attempt to use the routing table. To address this failure, add &lt;code&gt;@tag :distributed&lt;/code&gt; to this test too:</source>
          <target state="translated">Теперь, если вы запустите тесты, вы увидите, что тест, который проверяет взаимодействие с сервером, завершится ошибкой, поскольку он попытается использовать таблицу маршрутизации. Чтобы устранить эту ошибку, добавьте в этот тест также &lt;code&gt;@tag :distributed&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="07a537a78322242c13cbe0fc9e189cb95c551f62" translate="yes" xml:space="preserve">
          <source>Now imagine someone wants to split the string in three parts. You decide to make the number of parts configurable via the application environment:</source>
          <target state="translated">А теперь представьте,что кто-то хочет разделить струну на три части.Вы решаете сделать количество частей настраиваемыми через среду приложений:</target>
        </trans-unit>
        <trans-unit id="0d4fb1978dc93bf23ded5fbfb72b901b0ff9b3c1" translate="yes" xml:space="preserve">
          <source>Now imagine that this code does not fit its line. The code formatter introduces breaks inside &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; and inside &lt;code&gt;%{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. Therefore the document would break as:</source>
          <target state="translated">А теперь представьте, что этот код не умещается в своей строке. Средство форматирования кода вводит разрывы внутри &lt;code&gt;(&lt;/code&gt; и &lt;code&gt;)&lt;/code&gt; и внутри &lt;code&gt;%{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; . Следовательно, документ будет разбит как:</target>
        </trans-unit>
        <trans-unit id="1776285a5ee5e0cd2e476a5e17548b25cf3e7965" translate="yes" xml:space="preserve">
          <source>Now instead of:</source>
          <target state="translated">Теперь вместо этого:</target>
        </trans-unit>
        <trans-unit id="b2edaaf4e4c37a573a2f4175b7fb677e22086d38" translate="yes" xml:space="preserve">
          <source>Now invoking &lt;code&gt;squared(my_number.())&lt;/code&gt; as before will print the value just once.</source>
          <target state="translated">Теперь, как и раньше, &lt;code&gt;squared(my_number.())&lt;/code&gt; значение только один раз.</target>
        </trans-unit>
        <trans-unit id="b50389659966a7555212a28c84596f8d8bad4035" translate="yes" xml:space="preserve">
          <source>Now it is your turn to write a test for the functionality above! Also, be sure to explore &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;the documentation for the &lt;code&gt;Agent&lt;/code&gt; module&lt;/a&gt; to learn more about them.</source>
          <target state="translated">Теперь ваша очередь написать тест на функциональность, указанную выше! Кроме того, не забудьте изучить &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;документацию к модулю &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; чтобы узнать о них больше.</target>
        </trans-unit>
        <trans-unit id="cac6639a99e22abeb99b7c1fe3b72525b3c0d41b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s make the doctest pass. Let&amp;rsquo;s implement the &lt;code&gt;parse/1&lt;/code&gt; function:</source>
          <target state="translated">Теперь давайте пройдем доктест. Реализуем функцию &lt;code&gt;parse/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="76db12a2c71759a37e441cf80092642d7e2be4dd" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s start an IEx session to compile the file and start the debugger:</source>
          <target state="translated">Теперь давайте запустим сеанс IEx для компиляции файла и запуска отладчика:</target>
        </trans-unit>
        <trans-unit id="b328e1c1e09f5be9d544c4ae079f35bf00604c7a" translate="yes" xml:space="preserve">
          <source>Now let's cover the pattern matching rules for each construct and then for each relevant data-types.</source>
          <target state="translated">Теперь рассмотрим правила сопоставления шаблонов для каждой конструкции,а затем для каждого соответствующего типа данных.</target>
        </trans-unit>
        <trans-unit id="e3bb6483a50754a9a9376b80f656c2eee83a90ac" translate="yes" xml:space="preserve">
          <source>Now let's give it a try:</source>
          <target state="translated">Теперь давайте попробуем:</target>
        </trans-unit>
        <trans-unit id="a06cdb0293b3c757aef93c1695a911a48f527d99" translate="yes" xml:space="preserve">
          <source>Now once the system boots, it will invoke the provider early in the boot process, save the merged configuration to the disk, and reboot the system with the new values in place.</source>
          <target state="translated">Теперь,как только система загрузится,она вызовет провайдера на ранней стадии загрузки,сохранит объединенную конфигурацию на диске и перезагрузит систему с новыми значениями.</target>
        </trans-unit>
        <trans-unit id="f8e788006f30e3c08108a5e67aea31d230a97139" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;mix test&lt;/code&gt; again (notice this time there will be no compilation):</source>
          <target state="translated">Теперь снова запустите &lt;code&gt;mix test&lt;/code&gt; (обратите внимание, на этот раз компиляции не будет):</target>
        </trans-unit>
        <trans-unit id="19fa598d84faa6a938161fe34822951938d13086" translate="yes" xml:space="preserve">
          <source>Now run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">Теперь запустим тесты с &lt;code&gt;mix test&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="edc3c0311fb8d8402744a5dc3b64fa6e7d3ee61a" translate="yes" xml:space="preserve">
          <source>Now run the shell:</source>
          <target state="translated">Теперь запустите снаряд:</target>
        </trans-unit>
        <trans-unit id="46c1aa1ce075b93b2b67727f3d1580cca77b1e86" translate="yes" xml:space="preserve">
          <source>Now that our application runs distributed, you may be wondering how we can package our application to run in production. After all, all of our code so far depends on Erlang and Elixir versions that are installed in your current system. To achieve this goal, Elixir provides releases.</source>
          <target state="translated">Теперь,когда наше приложение работает в дистрибутиве,вы можете поинтересоваться,как мы можем упаковать наше приложение для запуска в производство.В конце концов,весь наш код до сих пор зависит от версий Erlang и Elixir,которые установлены в вашей текущей системе.Для достижения этой цели Elixir предоставляет релизы.</target>
        </trans-unit>
        <trans-unit id="19a25f5fcd5f38d10706db44b6313eed285f06df" translate="yes" xml:space="preserve">
          <source>Now that our buckets are properly linked and supervised, let&amp;rsquo;s see how we can speed things up.</source>
          <target state="translated">Теперь, когда наши корзины правильно связаны и контролируются, давайте посмотрим, как мы можем ускорить работу.</target>
        </trans-unit>
        <trans-unit id="9e53f2ea82a2cf9a10ea7d3d3f281c742019f84a" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;KV.Bucket&lt;/code&gt; module has been defined, our test should pass! You can try it yourself by running: &lt;code&gt;mix test&lt;/code&gt;.</source>
          <target state="translated">Теперь, &lt;code&gt;KV.Bucket&lt;/code&gt; модуль KV.Bucket определен, наш тест должен пройти! Вы можете попробовать это сами, запустив: &lt;code&gt;mix test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7df359bcf6fd7b6b53a7f0116a2c64cf244a918" translate="yes" xml:space="preserve">
          <source>Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:</source>
          <target state="translated">Теперь,когда протокол может быть реализован для каждой структуры данных,он может иметь соответствующую реализацию:</target>
        </trans-unit>
        <trans-unit id="08d686a4ce79ab4cc9d9c6a38ea87b99a5fd278a" translate="yes" xml:space="preserve">
          <source>Now that the server is part of the supervision tree, it should start automatically when we run the application. Start your server, now passing the port, and once again use the &lt;code&gt;telnet&lt;/code&gt; client to make sure that everything still works:</source>
          <target state="translated">Теперь, когда сервер является частью дерева надзора, он должен запускаться автоматически при запуске приложения. Запустите свой сервер, теперь передавая порт, и еще раз используйте клиент &lt;code&gt;telnet&lt;/code&gt; , чтобы убедиться, что все по-прежнему работает:</target>
        </trans-unit>
        <trans-unit id="e7e80fb6ff6e247ded63d0bdc578c34f9a1551f2" translate="yes" xml:space="preserve">
          <source>Now that we have defined our supervision tree, it is a great opportunity to introduce the Observer tool that ships with Erlang. Start your application with &lt;code&gt;iex -S mix&lt;/code&gt; and key this in:</source>
          <target state="translated">Теперь, когда мы определили наше дерево надзора, это прекрасная возможность представить инструмент Observer, который поставляется с Erlang. Запустите свое приложение с помощью &lt;code&gt;iex -S mix&lt;/code&gt; и введите следующее:</target>
        </trans-unit>
        <trans-unit id="65521a82582c996b661e688c57efd31c9126bde0" translate="yes" xml:space="preserve">
          <source>Now that we have talked about aliases, we can talk about nesting and how it works in Elixir. Consider the following example:</source>
          <target state="translated">Теперь,когда мы поговорили о псевдонимах,мы можем поговорить о гнездовании и о том,как оно работает в Эликсире.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="bab99d6cee3867d995c14e2d5733f4da26449910" translate="yes" xml:space="preserve">
          <source>Now that we understand what the Unicode standard is and what code points are, we can finally talk about encodings. Whereas the code point is &lt;strong&gt;what&lt;/strong&gt; we store, an encoding deals with &lt;strong&gt;how&lt;/strong&gt; we store it: encoding is an implementation. In other words, we need a mechanism to convert the code point numbers into bytes so they can be stored in memory, written to disk, etc.</source>
          <target state="translated">Теперь, когда мы понимаем, что такое стандарт Unicode и что такое кодовые точки, мы наконец можем поговорить о кодировках. В то время как кодовая точка - это &lt;strong&gt;то, что&lt;/strong&gt; мы храним, кодировка имеет дело с тем, &lt;strong&gt;как&lt;/strong&gt; мы ее храним: кодировка - это реализация. Другими словами, нам нужен механизм для преобразования номеров кодовых точек в байты, чтобы их можно было хранить в памяти, записывать на диск и т. Д.</target>
        </trans-unit>
        <trans-unit id="ac080018201e9a042de2521194aa2396dd3f6137" translate="yes" xml:space="preserve">
          <source>Now that you have defined an application callback which starts our supervisor, we expect the &lt;code&gt;KV.Registry&lt;/code&gt; process to be up and running as soon we start &lt;code&gt;iex -S mix&lt;/code&gt;. Let&amp;rsquo;s give it another try:</source>
          <target state="translated">Теперь, когда вы определили обратный вызов приложения, который запускает наш супервизор, мы ожидаем, что процесс &lt;code&gt;KV.Registry&lt;/code&gt; будет запущен, как только мы запустим &lt;code&gt;iex -S mix&lt;/code&gt; . Давайте попробуем еще раз:</target>
        </trans-unit>
        <trans-unit id="30b5dae909c9821ba155153ad42cdbcfe385f30c" translate="yes" xml:space="preserve">
          <source>Now that you have seen an example of the type of problem protocols help solve and how they solve them, let&amp;rsquo;s look at a more in-depth example.</source>
          <target state="translated">Теперь, когда вы увидели пример того, как протоколы проблем помогают решить и как они их решают, давайте рассмотрим более подробный пример.</target>
        </trans-unit>
        <trans-unit id="328f3af23181b7aed869a7baf3feac133b09d35c" translate="yes" xml:space="preserve">
          <source>Now trying to build a struct without the name key will fail:</source>
          <target state="translated">Теперь попытка построить структуру без ключа имени будет неудачной:</target>
        </trans-unit>
        <trans-unit id="f61f095187bf437534acdc98989a52599f7a57e0" translate="yes" xml:space="preserve">
          <source>Now type any string into the terminal and you will see that the same value will be printed in upper-case. Unfortunately, this example also got your IEx shell stuck in the comprehension, so you will need to hit &lt;code&gt;Ctrl+C&lt;/code&gt; twice to get out of it. :)</source>
          <target state="translated">Теперь введите любую строку в терминал, и вы увидите, что то же значение будет напечатано в верхнем регистре. К сожалению, в этом примере ваша оболочка IEx застряла в понимании, поэтому вам нужно будет дважды нажать &lt;code&gt;Ctrl+C&lt;/code&gt; , чтобы выйти из него. :)</target>
        </trans-unit>
        <trans-unit id="46bc283c29ce2ecc43ead7d1d61cfa31cca09a7d" translate="yes" xml:space="preserve">
          <source>Now users can configure your library in their &lt;code&gt;config/config.exs&lt;/code&gt; file as follows:</source>
          <target state="translated">Теперь пользователи могут настроить вашу библиотеку в своем файле &lt;code&gt;config/config.exs&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b17fce085e9d552d0a9af3234c3cdfba2da82bb3" translate="yes" xml:space="preserve">
          <source>Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there:</source>
          <target state="translated">Теперь мы подключены к удаленному узлу,как показывает подсказка,и можем получить доступ к информации и модулям,определенным там:</target>
        </trans-unit>
        <trans-unit id="57fd8f624da2baf5d7aba96d024c13b21b6b8eeb" translate="yes" xml:space="preserve">
          <source>Now we can start our debugger:</source>
          <target state="translated">Теперь мы можем начать отладку:</target>
        </trans-unit>
        <trans-unit id="ff52cd0aed65a9dce91b318e1c1c0dbc4e09358d" translate="yes" xml:space="preserve">
          <source>Now we get an error because an application that &lt;code&gt;:kv&lt;/code&gt; depends on (&lt;code&gt;:logger&lt;/code&gt; in this case) isn&amp;rsquo;t started. We need to either start each application manually in the correct order or call &lt;code&gt;Application.ensure_all_started&lt;/code&gt; as follows:</source>
          <target state="translated">Теперь мы получаем ошибку, потому что приложение, которое &lt;code&gt;:kv&lt;/code&gt; зависит от ( в данном случае &lt;code&gt;:logger&lt;/code&gt; ), не запускается. Нам нужно либо запустить каждое приложение вручную в правильном порядке, либо вызвать &lt;code&gt;Application.ensure_all_started&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="ce58c619fafb232c624235ba4ccf102d6952d45a" translate="yes" xml:space="preserve">
          <source>Now we need to change &lt;code&gt;loop_acceptor/1&lt;/code&gt; to use &lt;code&gt;Task.Supervisor&lt;/code&gt; to serve each request:</source>
          <target state="translated">Теперь нам нужно изменить &lt;code&gt;loop_acceptor/1&lt;/code&gt; , чтобы использовать &lt;code&gt;Task.Supervisor&lt;/code&gt; для обслуживания каждого запроса:</target>
        </trans-unit>
        <trans-unit id="fdeab946c4d9329d156b88e77a2ec9ecfeddcfa0" translate="yes" xml:space="preserve">
          <source>Now we only need to make &lt;code&gt;KV.RouterTest&lt;/code&gt; pass once again. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</source>
          <target state="translated">Теперь нам нужно только сделать &lt;code&gt;KV.RouterTest&lt;/code&gt; еще раз пройти. Для этого мы напишем блок установки, который запускается перед всеми тестами в этом файле. Блок настройки изменит среду приложения и вернет ее обратно, как только мы закончим, например:</target>
        </trans-unit>
        <trans-unit id="616d9118cd5824c6691d30e8ef906dec071996ec" translate="yes" xml:space="preserve">
          <source>Now with our routing system in place, let&amp;rsquo;s change &lt;code&gt;KVServer&lt;/code&gt; to use the router. Replace the &lt;code&gt;lookup/2&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt; by the following one:</source>
          <target state="translated">Теперь, когда наша система маршрутизации установлена, давайте изменим &lt;code&gt;KVServer&lt;/code&gt; на использование маршрутизатора. Замените функцию &lt;code&gt;lookup/2&lt;/code&gt; в &lt;code&gt;KVServer.Command&lt;/code&gt; следующей:</target>
        </trans-unit>
        <trans-unit id="473b17993b7eb7156690a660695f0604c4095a5c" translate="yes" xml:space="preserve">
          <source>Now with the protocol defined and implementations in hand, we can start using it:</source>
          <target state="translated">Теперь,когда протокол определен и реализован,мы можем приступить к его использованию:</target>
        </trans-unit>
        <trans-unit id="8ac19fd0e99d45eb3bb8a29a0a874c8bc60bad1b" translate="yes" xml:space="preserve">
          <source>Now you can dynamically start supervised tasks:</source>
          <target state="translated">Теперь вы можете динамически запускать задания под наблюдением:</target>
        </trans-unit>
        <trans-unit id="4b14c8fa9966018b287124d6f5b635e573f91762" translate="yes" xml:space="preserve">
          <source>Now you can proceed to list this process in the &lt;code&gt;.appup&lt;/code&gt; file and hot code upgrade it. This is one of the many steps necessary to perform hot code upgrades and it must be taken into account by every process and application being upgraded in the system. The &lt;a href=&quot;http://erlang.org/doc/design_principles/appup_cookbook.html&quot;&gt;&lt;code&gt;.appup&lt;/code&gt; cookbook&lt;/a&gt; provides a good reference and more examples.</source>
          <target state="translated">Теперь вы можете перейти к перечислению этого процесса в файле &lt;code&gt;.appup&lt;/code&gt; и обновить его горячим кодом. Это один из многих шагов, необходимых для выполнения обновлений &amp;laquo;горячего&amp;raquo; кода, и его необходимо учитывать при каждом обновлении процесса и приложения в системе. &lt;a href=&quot;http://erlang.org/doc/design_principles/appup_cookbook.html&quot;&gt; &lt;code&gt;.appup&lt;/code&gt; поваренные&lt;/a&gt; обеспечивает хорошие ссылки и другие примеры.</target>
        </trans-unit>
        <trans-unit id="32df2513a243e616c099ce25eeecd29f8971c442" translate="yes" xml:space="preserve">
          <source>Now you can run tests for both projects from the umbrella root with &lt;code&gt;mix test&lt;/code&gt;. Sweet!</source>
          <target state="translated">Теперь вы можете запускать тесты для обоих проектов из корневого зонтика с помощью &lt;code&gt;mix test&lt;/code&gt; . Сладкий!</target>
        </trans-unit>
        <trans-unit id="07b0131f4deaf329edfa37832794fd47dac09e81" translate="yes" xml:space="preserve">
          <source>Now you want to make the &lt;code&gt;heavy_fun()&lt;/code&gt; async:</source>
          <target state="translated">Теперь вы хотите сделать &lt;code&gt;heavy_fun()&lt;/code&gt; асинхронным:</target>
        </trans-unit>
        <trans-unit id="476ae1fa4f615cd4311df04dc7c8a801b6354a43" translate="yes" xml:space="preserve">
          <source>Now, an entity interested in dispatching events for a given key may call &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; passing in the key and a callback. This callback will be invoked with a list of all the values registered under the requested key, alongside the PID of the process that registered each value, in the form of &lt;code&gt;{pid, value}&lt;/code&gt; tuples. In our example, &lt;code&gt;value&lt;/code&gt; will be the &lt;code&gt;{module, function}&lt;/code&gt; tuple in the code above:</source>
          <target state="translated">Теперь объект, заинтересованный в отправке событий для данного ключа, может вызвать &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; ,&lt;/a&gt; передав ключ и обратный вызов. Этот обратный вызов будет вызываться со списком всех значений, зарегистрированных под запрошенным ключом, вместе с PID процесса, который зарегистрировал каждое значение, в виде кортежей &lt;code&gt;{pid, value}&lt;/code&gt; . В нашем примере &lt;code&gt;value&lt;/code&gt; будет кортеж &lt;code&gt;{module, function}&lt;/code&gt; в приведенном выше коде:</target>
        </trans-unit>
        <trans-unit id="363b2b445a852adb051cab43c32dcbd46d0ab5b3" translate="yes" xml:space="preserve">
          <source>Now, in your application, you can read this environment by using functions such as &lt;a href=&quot;#fetch_env!/2&quot;&gt;&lt;code&gt;fetch_env!/2&lt;/code&gt;&lt;/a&gt; and friends:</source>
          <target state="translated">Теперь в вашем приложении вы можете прочитать эту среду с помощью таких функций, как &lt;a href=&quot;#fetch_env!/2&quot;&gt; &lt;code&gt;fetch_env!/2&lt;/code&gt; &lt;/a&gt; и других:</target>
        </trans-unit>
        <trans-unit id="d99570fbe4495eecd768739b59540e2e4e121132" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s start two named nodes again, but inside the &lt;code&gt;:kv&lt;/code&gt; application:</source>
          <target state="translated">Теперь давайте снова запустим два именованных узла, но внутри приложения: &lt;code&gt;:kv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7056385a9cb5c062d2f526a7af092bf8f6c98b17" translate="yes" xml:space="preserve">
          <source>Now, let's roll back to the first shell:</source>
          <target state="translated">Теперь,давайте вернемся к первой оболочке:</target>
        </trans-unit>
        <trans-unit id="8883bbf72dbea8b7c2911dc4d03827a0ab88aa71" translate="yes" xml:space="preserve">
          <source>Now, let's start another shell, giving it a name as well:</source>
          <target state="translated">А теперь давайте начнем еще одну оболочку,дав ей еще и название:</target>
        </trans-unit>
        <trans-unit id="b8f14e00a9ee1de5622bfa894ce44aa7673c9977" translate="yes" xml:space="preserve">
          <source>Now, try to access the &lt;code&gt;hello&lt;/code&gt; variable again:</source>
          <target state="translated">Теперь попробуйте снова получить доступ к переменной &lt;code&gt;hello&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f02afe5290423ebf3ed89e90bd9b4662ee206e07" translate="yes" xml:space="preserve">
          <source>Now, we will get an error if we try to use this operator &quot;out of the box&quot;:</source>
          <target state="translated">Теперь мы получим ошибку,если попытаемся использовать этот оператор &quot;из коробки&quot;:</target>
        </trans-unit>
        <trans-unit id="a053460549010159dc2b6fda3731de548204bf3f" translate="yes" xml:space="preserve">
          <source>Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited.</source>
          <target state="translated">Количество выражений и их результаты для хранения в истории.Значение является целым числом.Когда оно отрицательное,история неограничена.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="ff5e98caf48c434c6264af1a2c308ac24882bda5" translate="yes" xml:space="preserve">
          <source>OTP</source>
          <target state="translated">OTP</target>
        </trans-unit>
        <trans-unit id="fa8fe915548f0e22ce68e5cf32adf85a38cb0334" translate="yes" xml:space="preserve">
          <source>OTP exits</source>
          <target state="translated">выходы OTP</target>
        </trans-unit>
        <trans-unit id="9ebb04f1d502294523ffc0d5654291733158f382" translate="yes" xml:space="preserve">
          <source>OWN - time spent in the function, excluding the time of called functions</source>
          <target state="translated">OWN-время,проведенное в функции,исключая время вызова функций.</target>
        </trans-unit>
        <trans-unit id="5170a26358c94cd0c4d86fad3a0f89ca90839e4e" translate="yes" xml:space="preserve">
          <source>Observe that we were able to considerably change the server implementation without changing any of the client API. That&amp;rsquo;s one of the benefits of explicitly segregating the server and the client.</source>
          <target state="translated">Обратите внимание, что мы смогли значительно изменить реализацию сервера без изменения клиентского API. Это одно из преимуществ явного разделения сервера и клиента.</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="c85a3d54e191da03c6d7794a838fbe85cdb51bc7" translate="yes" xml:space="preserve">
          <source>Of all the approaches above, the first is definitely the most flexible. If our domain rules can be encoded with data structures, they are by far the easiest to compose and implement, as Elixir&amp;rsquo;s standard library is filled with functions for manipulating different data types.</source>
          <target state="translated">Из всех вышеперечисленных подходов первый, безусловно, наиболее гибкий. Если наши правила предметной области могут быть закодированы с помощью структур данных, их гораздо проще составить и реализовать, поскольку стандартная библиотека Elixir наполнена функциями для управления различными типами данных.</target>
        </trans-unit>
        <trans-unit id="902cb7ed7bd72ac12ba23366c9ffb04891ee4dcb" translate="yes" xml:space="preserve">
          <source>Of course, Elixir can be used for much more than distributed key-value stores. Embedded systems, data-processing and data-ingestion, web applications, streaming system, and others are many of the different domains Elixir excels at. We hope this guide has prepared you to explore any of those domains or any future domain you may desire to bring Elixir into.</source>
          <target state="translated">Конечно же,Elixir можно использовать для гораздо большего,чем распределенные магазины с ключами.Встраиваемые системы,обработка и обработка данных,веб-приложения,потоковая система и другие-многие из различных доменов,в которых Elixir превосходит по качеству.Мы надеемся,что это руководство подготовило вас к изучению любого из этих доменов или любого будущего домена,в который вы захотите внедрить Elixir.</target>
        </trans-unit>
        <trans-unit id="443083dbfa08188532e9cc376bf3569c4852013f" translate="yes" xml:space="preserve">
          <source>Of course, Elixir can be used for much more than distributed key-value stores. Embedded systems, data-processing and data-ingestion, web applications, streaming systems, and others are many of the different domains Elixir excels at. We hope this guide has prepared you to explore any of those domains or any future domain you may desire to bring Elixir into.</source>
          <target state="translated">Конечно же,Elixir можно использовать для гораздо большего,чем распределенные магазины с ключами.Встраиваемые системы,обработка и обработка данных,веб-приложения,потоковые системы и другие-многие из различных доменов,в которых Elixir превосходит по качеству.Мы надеемся,что это руководство подготовило вас к изучению любого из этих доменов или любого будущего домена,в который вы захотите внедрить Elixir.</target>
        </trans-unit>
        <trans-unit id="52497f8ab2a182c2ef6faac3953c494cb81f3fad" translate="yes" xml:space="preserve">
          <source>Of course, if you want to actually partition the tests, you can also do:</source>
          <target state="translated">Конечно,если вы хотите разбить тесты на разделы,вы также можете это сделать:</target>
        </trans-unit>
        <trans-unit id="c032c26697f2670cfce67357d79c2f377064ccf1" translate="yes" xml:space="preserve">
          <source>Of course, some operating systems and package managers can differ between versions, so if your goal is to have full compatibility between host and target, it is best to ensure the operating system and system package manager have the same versions on host and target. This may even be a requirement in some systems, especially so with package managers that try to create fully reproducible environments (Nix, Guix).</source>
          <target state="translated">Конечно,некоторые операционные системы и менеджеры пакетов могут различаться в разных версиях,поэтому если вашей целью является полная совместимость между хостом и целью,лучше всего убедиться,что операционная система и менеджер пакетов системы имеют одинаковые версии на хосте и цели.Это может быть даже требованием в некоторых системах,особенно в случае менеджеров пакетов,которые пытаются создать полностью воспроизводимую среду (Nix,Guix).</target>
        </trans-unit>
        <trans-unit id="c9c303f80906a94bd84edefa290936f6df4b3704" translate="yes" xml:space="preserve">
          <source>Official #elixir-lang on freenode IRC</source>
          <target state="translated">Официальный #elixir-lang на фриноде IRC</target>
        </trans-unit>
        <trans-unit id="5ad3a32fb5de6c096b01951e5ee3be528054408f" translate="yes" xml:space="preserve">
          <source>Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time.</source>
          <target state="translated">Часто в Elixir необходимо совместно использовать или хранить состояние,к которому необходимо получить доступ из разных процессов или от одного и того же процесса в разные моменты времени.</target>
        </trans-unit>
        <trans-unit id="264e7ceb5e0be0af540c0e1efdf61cc8febc63a9" translate="yes" xml:space="preserve">
          <source>Often it is necessary to copy extra files to the release root after the release is assembled. This can be easily done by placing such files in the &lt;code&gt;rel/overlays&lt;/code&gt; directory. Any file in there is copied as is to the release root. For example, if you have placed a &quot;rel/overlays/Dockerfile&quot; file, the &quot;Dockerfile&quot; will be copied as is to the release root.</source>
          <target state="translated">Часто бывает необходимо скопировать дополнительные файлы в корневой каталог выпуска после его сборки. Это легко сделать, поместив такие файлы в каталог &lt;code&gt;rel/overlays&lt;/code&gt; . Любой файл там копируется как есть в корень выпуска. Например, если вы разместили файл &amp;laquo;rel / overlays / Dockerfile&amp;raquo;, &amp;laquo;Dockerfile&amp;raquo; будет скопирован в корень выпуска без изменений.</target>
        </trans-unit>
        <trans-unit id="9f4e555dd4a0b214fc42c4fafafd47bf3b759ac6" translate="yes" xml:space="preserve">
          <source>Often there are errors/exceptions inside exits. Exits are often wrapped by the caller and provide stacktraces too. This function formats exits in a way to nicely show the exit reason, caller and stacktrace.</source>
          <target state="translated">Часто встречаются ошибки/исключения внутри выходов.Выходы часто обертываются вызывающим абонентом и также предоставляют стековые дорожки.Эта функция форматирует выходы таким образом,чтобы красиво показать причину выхода,вызывающего абонента и стековую траекторию.</target>
        </trans-unit>
        <trans-unit id="9323e6675acdba059cc7528c84326fb722f7cf8a" translate="yes" xml:space="preserve">
          <source>Often they are used to express the state of an operation, by using values such as &lt;code&gt;:ok&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">Часто они используются для выражения состояния операции с использованием таких значений, как &lt;code&gt;:ok&lt;/code&gt; и &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c02ae25b9dec2dd8be94787202587f35da019d9" translate="yes" xml:space="preserve">
          <source>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the &lt;code&gt;put_in/2&lt;/code&gt;, &lt;code&gt;update_in/2&lt;/code&gt; and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</source>
          <target state="translated">Часто у нас есть карты внутри карт или даже списки ключевых слов внутри карт и так далее. Elixir обеспечивает удобство для управления вложенными структурами данных с помощью &lt;code&gt;put_in/2&lt;/code&gt; , &lt;code&gt;update_in/2&lt;/code&gt; и других, предоставляя те же удобства, что и в императивных языках, при сохранении неизменных свойств языка.</target>
        </trans-unit>
        <trans-unit id="a567fc96e505fa689fb781ec6b8b66b74eefd6f8" translate="yes" xml:space="preserve">
          <source>On Unix-like / Bash:</source>
          <target state="translated">На Unix-подобном/Bash:</target>
        </trans-unit>
        <trans-unit id="74b298f2360ded6dbf3b3733dbfa18ae283fccd2" translate="yes" xml:space="preserve">
          <source>On Windows 10 / PowerShell:</source>
          <target state="translated">На Windows 10/PowerShell:</target>
        </trans-unit>
        <trans-unit id="010a92ca285536db23a909835a24cc3bbd247a77" translate="yes" xml:space="preserve">
          <source>On Windows, path is split on both &quot;\&quot; and &quot;/&quot; separators and the driver letter, if there is one, is always returned in lowercase.</source>
          <target state="translated">В Windows путь разделен на разделители &quot;\&quot; и &quot;/&quot;,а буква драйвера,если она есть,всегда возвращается в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="ccfc5256f8269b091cc2f1bb3b3686fb247d7897" translate="yes" xml:space="preserve">
          <source>On Windows, your &lt;code&gt;env.bat&lt;/code&gt; would look like this:</source>
          <target state="translated">В Windows ваш &lt;code&gt;env.bat&lt;/code&gt; будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">На Windows:</target>
        </trans-unit>
        <trans-unit id="2779b0cd51a2b5987b501d655bc5be3263bd37e4" translate="yes" xml:space="preserve">
          <source>On its turn, the port will send the connected process the following messages:</source>
          <target state="translated">В свою очередь,порт отправит подключенному процессу следующие сообщения:</target>
        </trans-unit>
        <trans-unit id="1c4b199ab2a5a87b093d5ef5b68e83e8d35a8454" translate="yes" xml:space="preserve">
          <source>On the language homepage, we mention that Elixir makes documentation a first-class citizen in the language. We have explored this concept many times throughout this guide, be it via &lt;code&gt;mix help&lt;/code&gt; or by typing &lt;code&gt;h Enum&lt;/code&gt; or another module in an IEx console.</source>
          <target state="translated">На домашней странице языка мы упоминаем, что Elixir делает документацию первоклассным гражданином языка. Мы много раз изучали эту концепцию в этом руководстве, будь то с помощью &lt;code&gt;mix help&lt;/code&gt; по микшированию или путем ввода &lt;code&gt;h Enum&lt;/code&gt; или другого модуля в консоли IEx.</target>
        </trans-unit>
        <trans-unit id="de96232518520933630bd7c423b5ed4b701f263c" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;:stdio&lt;/code&gt; and files opened with &lt;code&gt;:utf8&lt;/code&gt; encoding work with the remaining functions in the &lt;code&gt;IO&lt;/code&gt; module. Those functions expect a &lt;code&gt;char_data&lt;/code&gt; as an argument, that is, a list of characters or strings.</source>
          <target state="translated">С другой стороны &lt;code&gt;:stdio&lt;/code&gt; и файлы, открытые с кодировкой &lt;code&gt;:utf8&lt;/code&gt; , работают с остальными функциями модуля &lt;code&gt;IO&lt;/code&gt; . Эти функции ожидают &lt;code&gt;char_data&lt;/code&gt; в качестве аргумента, то есть списка символов или строк.</target>
        </trans-unit>
        <trans-unit id="df2f9b99e7ba432ec596beb6110247ffca71c5ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;Stream.unfold/2&lt;/code&gt; can be used to generate values from a given initial value:</source>
          <target state="translated">С другой стороны, &lt;code&gt;Stream.unfold/2&lt;/code&gt; можно использовать для генерации значений из заданного начального значения:</target>
        </trans-unit>
        <trans-unit id="2b8b9378d09ed0fb2e04b62c07969de258d132e4" translate="yes" xml:space="preserve">
          <source>On the other hand, aliases hold some properties:</source>
          <target state="translated">С другой стороны,псевдонимы обладают некоторыми свойствами:</target>
        </trans-unit>
        <trans-unit id="cde8a500ad1f4f8eca18ffea106e75b93a90386b" translate="yes" xml:space="preserve">
          <source>On the other hand, function calls without parens are always indented by the function call length itself, like this:</source>
          <target state="translated">С другой стороны,вызовы функций без пар всегда отступают от самой длины вызова функции,подобно этому:</target>
        </trans-unit>
        <trans-unit id="bc0c4bbb18d6918bd36e9cad44b9402719c305e1" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want partitioned tests but per-app reports, you can do:</source>
          <target state="translated">С другой стороны,если вам нужны разбитые на разделы тесты,но отчеты для каждого приложения,вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="bf1909c9266c5b60bc634c9c3fd56fa5d862b1a5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want to dynamically slice a string based on an integer value, then using &lt;a href=&quot;#slice/3&quot;&gt;&lt;code&gt;String.slice/3&lt;/code&gt;&lt;/a&gt; is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes.</source>
          <target state="translated">С другой стороны, если вы хотите динамически разрезать строку на основе целочисленного значения, то использование &lt;a href=&quot;#slice/3&quot;&gt; &lt;code&gt;String.slice/3&lt;/code&gt; &lt;/a&gt; - лучший вариант, поскольку он гарантирует, что мы не будем неправильно разбивать действительный код на несколько байтов.</target>
        </trans-unit>
        <trans-unit id="77e130342c984a0c62222639f83873c823bfc21f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want to dynamically slice a string based on an integer value, then using &lt;a href=&quot;string#slice/3&quot;&gt;&lt;code&gt;String.slice/3&lt;/code&gt;&lt;/a&gt; is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes.</source>
          <target state="translated">С другой стороны, если вы хотите динамически разрезать строку на основе целочисленного значения, то использование &lt;a href=&quot;string#slice/3&quot;&gt; &lt;code&gt;String.slice/3&lt;/code&gt; &lt;/a&gt; - лучший вариант, поскольку он гарантирует, что мы не будем неправильно разбивать действительный код на несколько байтов.</target>
        </trans-unit>
        <trans-unit id="96440900cf2787b3d188e44fb23cf1e92e8dffd8" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt; function in this protocol should be implemented whenever you can count the number of elements in the collection.</source>
          <target state="translated">С другой стороны, функция &lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; в этом протоколе должна быть реализована всякий раз, когда вы можете подсчитать количество элементов в коллекции.</target>
        </trans-unit>
        <trans-unit id="8c1c5ce2343c9ac12f7a79c1b7dce77805906dc2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;.appup&lt;/code&gt;s are created, the next step is to create a &lt;code&gt;.relup&lt;/code&gt; file with all instructions necessary to update the release itself. Erlang documentation does provide a chapter on &lt;a href=&quot;http://erlang.org/doc/system_principles/create_target.html&quot;&gt;Creating and Upgrading a Target System&lt;/a&gt;. &lt;a href=&quot;https://learnyousomeerlang.com/relups&quot;&gt;Learn You Some Erlang has a chapter on hot code upgrades&lt;/a&gt;.</source>
          <target state="translated">После &lt;code&gt;.appup&lt;/code&gt; следующим шагом будет создание файла &lt;code&gt;.relup&lt;/code&gt; со всеми инструкциями, необходимыми для обновления самого выпуска. В документации Erlang есть глава о &lt;a href=&quot;http://erlang.org/doc/system_principles/create_target.html&quot;&gt;создании и обновлении целевой системы&lt;/a&gt; . &lt;a href=&quot;https://learnyousomeerlang.com/relups&quot;&gt;В Learn You Some Erlang есть глава, посвященная обновлению горячего кода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4bdbe00967c62a4c537ba3d468fbab141586df1" translate="yes" xml:space="preserve">
          <source>Once a case template is used, the regular functionality in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; plus the functionality defined in the template will become available.</source>
          <target state="translated">После использования шаблона дела станут доступны обычные функции &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; плюс функции, определенные в шаблоне.</target>
        </trans-unit>
        <trans-unit id="f5fb3909173c7fa57bb02b51698a4f60c66497d6" translate="yes" xml:space="preserve">
          <source>Once a configuration is written to a file, the functions in this module can be used to read and merge said configuration. The &lt;a href=&quot;#eval!/2&quot;&gt;&lt;code&gt;eval!/2&lt;/code&gt;&lt;/a&gt; function allows you to evaluate a given configuration file and the &lt;a href=&quot;#merge/2&quot;&gt;&lt;code&gt;merge/2&lt;/code&gt;&lt;/a&gt; function allows you to deep merge the results of multiple configurations. Those functions should not be invoked by users writing configurations but rather by library authors.</source>
          <target state="translated">После того, как конфигурация записана в файл, функции этого модуля можно использовать для чтения и объединения указанной конфигурации. Функция &lt;a href=&quot;#eval!/2&quot;&gt; &lt;code&gt;eval!/2&lt;/code&gt; &lt;/a&gt; позволяет вам оценивать данный файл конфигурации, а функция &lt;a href=&quot;#merge/2&quot;&gt; &lt;code&gt;merge/2&lt;/code&gt; &lt;/a&gt; позволяет выполнять глубокое слияние результатов нескольких конфигураций. Эти функции должны вызываться не пользователями, пишущими конфигурации, а авторами библиотеки.</target>
        </trans-unit>
        <trans-unit id="423d94dfd3979b636b7fca2ef0b1fc6c8a58898a" translate="yes" xml:space="preserve">
          <source>Once a function or a macro is marked as overridable, it will no longer be listed under &lt;a href=&quot;#definitions_in/1&quot;&gt;&lt;code&gt;definitions_in/1&lt;/code&gt;&lt;/a&gt; or return true when given to &lt;a href=&quot;#defines?/2&quot;&gt;&lt;code&gt;defines?/2&lt;/code&gt;&lt;/a&gt; until another implementation is given.</source>
          <target state="translated">После того, как функция или макрос помечены как переопределяемые, они больше не будут отображаться в списке &lt;a href=&quot;#definitions_in/1&quot;&gt; &lt;code&gt;definitions_in/1&lt;/code&gt; &lt;/a&gt; и не будут возвращать истину, если заданы в &lt;a href=&quot;#defines?/2&quot;&gt; &lt;code&gt;defines?/2&lt;/code&gt; &lt;/a&gt; пока не будет предоставлена ​​другая реализация.</target>
        </trans-unit>
        <trans-unit id="95b80a8a26d020722b0a90ff95e49a9e574ce8e4" translate="yes" xml:space="preserve">
          <source>Once a release is assembled, it can be packaged and deployed to a target, as long as the target runs on the same operating system (OS) distribution and version as the machine running the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">После того, как выпуск собран, его можно упаковать и развернуть на целевом объекте, если цель работает в том же дистрибутиве и версии операционной системы (ОС), что и компьютер, на котором выполняется команда &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="765bea4530a733a2df7a7f9dcd62a6ce9ae623bf" translate="yes" xml:space="preserve">
          <source>Once a release is assembled, you can start it by calling &lt;code&gt;bin/RELEASE_NAME start&lt;/code&gt; inside the release. In production, you would do:</source>
          <target state="translated">Как только выпуск собран, вы можете запустить его, вызвав &lt;code&gt;bin/RELEASE_NAME start&lt;/code&gt; внутри выпуска. В процессе производства вы должны:</target>
        </trans-unit>
        <trans-unit id="735a41bc25bec8dcef14df71df3ea20b9b58a5eb" translate="yes" xml:space="preserve">
          <source>Once a system is deployed, shutting down the system can be done by sending SIGINT/SIGTERM to the system, which is what most containers, platforms and tools do, or by explicitly invoking &lt;code&gt;bin/RELEASE_NAME stop&lt;/code&gt;. Once the system receives the shutdown request, each application and their respective supervision trees will stop, one by one, in the opposite order that they were started.</source>
          <target state="translated">После развертывания системы ее выключение может быть выполнено путем отправки SIGINT / SIGTERM в систему, что и делают большинство контейнеров, платформ и инструментов, или путем явного вызова &lt;code&gt;bin/RELEASE_NAME stop&lt;/code&gt; . Как только система получит запрос на отключение, каждое приложение и их соответствующие деревья надзора будут останавливаться одно за другим в порядке, обратном их запуску.</target>
        </trans-unit>
        <trans-unit id="4be2f449756ad52de4a6efae2bb582fc005c9362" translate="yes" xml:space="preserve">
          <source>Once again, uncomment the last two lines by removing the leading &lt;code&gt;rem &lt;/code&gt; to enable full distribution. And that&amp;rsquo;s all!</source>
          <target state="translated">Еще раз раскомментируйте последние две строки, удалив ведущий &lt;code&gt;rem &lt;/code&gt; , чтобы обеспечить полное распределение. И это все!</target>
        </trans-unit>
        <trans-unit id="cfc893eec70ab96edd7de58796885efa4ba9d8ca" translate="yes" xml:space="preserve">
          <source>Once everything was done, we closed the port.</source>
          <target state="translated">Как только все было сделано,мы закрыли порт.</target>
        </trans-unit>
        <trans-unit id="1621bce168937a18a32ac1d0bc7a6f51d70958e6" translate="yes" xml:space="preserve">
          <source>Once initialized, the handler should be designed to handle events in the following format:</source>
          <target state="translated">После инициализации обработчик должен быть спроектирован так,чтобы обрабатывать события в следующем формате:</target>
        </trans-unit>
        <trans-unit id="d84e7ded08fc9663ca1a6cc34b5179a1a792130f" translate="yes" xml:space="preserve">
          <source>Once initialized, the handler should be designed to handle the following events:</source>
          <target state="translated">После инициализации обработчик должен быть сконструирован так,чтобы обрабатывать следующие события:</target>
        </trans-unit>
        <trans-unit id="4f4d9f717239aa6329a574afa1566ba1188bc9fa" translate="yes" xml:space="preserve">
          <source>Once installed, the service must be explicitly managed via the &lt;code&gt;erlsrv&lt;/code&gt; executable, which is included in the &lt;code&gt;erts-VSN/bin&lt;/code&gt; directory. The service is not started automatically after installing.</source>
          <target state="translated">После установки служба должна управляться явно через исполняемый файл &lt;code&gt;erlsrv&lt;/code&gt; , который находится в &lt;code&gt;erts-VSN/bin&lt;/code&gt; . После установки служба не запускается автоматически.</target>
        </trans-unit>
        <trans-unit id="ea66816b8bd63ab93fda46bbd8289f6bc75e7802" translate="yes" xml:space="preserve">
          <source>Once multiple test runs are exported, this task can be used to generate an aggregated report.</source>
          <target state="translated">После экспорта нескольких тестов эта задача может быть использована для создания агрегированного отчета.</target>
        </trans-unit>
        <trans-unit id="290699e39f3ba4de6a466924dff98cd449d552b7" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;:logger&lt;/code&gt; application starts, it installs all event handlers listed under the &lt;code&gt;:backends&lt;/code&gt; configuration into the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; event manager. The event manager and all added event handlers are automatically supervised by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">После запуска &lt;code&gt;:logger&lt;/code&gt; приложение устанавливает все обработчики событий, перечисленные в конфигурации &lt;code&gt;:backends&lt;/code&gt; , в диспетчер событий &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; . Диспетчер событий и все добавленные обработчики событий автоматически контролируются &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bba6866fbd0a67ef6097d91ded25789c9452b004" translate="yes" xml:space="preserve">
          <source>Once the agent is spawned, the given function &lt;code&gt;fun&lt;/code&gt; is invoked in the server process, and should return the initial agent state. Note that &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; does not return until the given function has returned.</source>
          <target state="translated">После создания агента данная функция &lt;code&gt;fun&lt;/code&gt; вызывается в серверном процессе и должна возвращать начальное состояние агента. Обратите внимание, что &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; не возвращается, пока данная функция не вернется.</target>
        </trans-unit>
        <trans-unit id="ef9558c468b285f17bba1e7f8e7c4f2000f27cc1" translate="yes" xml:space="preserve">
          <source>Once the code above is executed inside an &lt;code&gt;iex&lt;/code&gt; session, IEx will ask if we want to pry into the current code. If accepted, we will be able to access all variables, as well as imports and aliases from the code, directly From IEx. While pry is running, the code execution stops, until &lt;code&gt;continue&lt;/code&gt; is called. Remember you can always run &lt;code&gt;iex&lt;/code&gt; in the context of a project with &lt;code&gt;iex -S mix TASK&lt;/code&gt;.</source>
          <target state="translated">Как только приведенный выше код будет выполнен в сеансе &lt;code&gt;iex&lt;/code&gt; , IEx спросит, хотим ли мы вмешаться в текущий код. В случае принятия мы сможем получить доступ ко всем переменным, а также к импорту и псевдонимам из кода непосредственно из IEx. Пока pry запущен, выполнение кода останавливается до &lt;code&gt;continue&lt;/code&gt; . Помните, что вы всегда можете запустить &lt;code&gt;iex&lt;/code&gt; в контексте проекта с помощью &lt;code&gt;iex -S mix TASK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="408c96ed6cd23c6d64030f673253fb9a91f2d8a7" translate="yes" xml:space="preserve">
          <source>Once the current application and its dependencies have been started, you can run a script in its context by passing a filename:</source>
          <target state="translated">После запуска текущего приложения и его зависимостей вы можете запустить скрипт в его контексте,передав имя файла:</target>
        </trans-unit>
        <trans-unit id="e4b8a6b7ad11f7671cb5874e92543fc2ebfae2db" translate="yes" xml:space="preserve">
          <source>Once the dynamic supervisor is running, we can start children with &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;, which receives a child specification:</source>
          <target state="translated">Как только динамический супервизор запущен, мы можем запускать дочерние &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; с start_child / 2 , который получает спецификацию дочернего элемента :</target>
        </trans-unit>
        <trans-unit id="a1cbb39ac09f145cd85ea1aba9ba9ce063b8a462" translate="yes" xml:space="preserve">
          <source>Once the monitored port process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">После того,как процесс контролируемого порта умирает,на процесс контроля поступает сообщение в форме:</target>
        </trans-unit>
        <trans-unit id="4f02c5f9ebc7bb88dcb63507719013ed2066f7bf" translate="yes" xml:space="preserve">
          <source>Once the monitored process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">После того,как контролируемый процесс умирает,на процесс мониторинга поступает сообщение в форме:</target>
        </trans-unit>
        <trans-unit id="4605c758e24d4c33ee6d08e933b8102e776e5d52" translate="yes" xml:space="preserve">
          <source>Once the project is compiled, you can start an &lt;code&gt;iex&lt;/code&gt; session inside the project by running:</source>
          <target state="translated">После компиляции проекта вы можете запустить сеанс &lt;code&gt;iex&lt;/code&gt; внутри проекта, запустив:</target>
        </trans-unit>
        <trans-unit id="e867373ffe7847f2db5130572df5f531464178dc" translate="yes" xml:space="preserve">
          <source>Once the project is defined, a number of default Mix tasks can be run directly from the command line:</source>
          <target state="translated">Как только проект определен,ряд задач по умолчанию Mix может быть запущен непосредственно из командной строки:</target>
        </trans-unit>
        <trans-unit id="e79a17078f1ff880495dbda73a3e3a89834328f1" translate="yes" xml:space="preserve">
          <source>Once the registry is started with a given name using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;Registry.start_link/1&lt;/code&gt;&lt;/a&gt;, it can be used to register and access named processes using the &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; tuple:</source>
          <target state="translated">После запуска реестра с заданным именем с помощью &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;Registry.start_link/1&lt;/code&gt; &lt;/a&gt; его можно использовать для регистрации и доступа к именованным процессам с &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; кортежа {: via, Registry, {registry, key}} :</target>
        </trans-unit>
        <trans-unit id="a6aa7b033fd85bf146e14a8c7160118f513bc8d6" translate="yes" xml:space="preserve">
          <source>Once the registry is started with a given name using &lt;a href=&quot;registry#start_link/1&quot;&gt;&lt;code&gt;Registry.start_link/1&lt;/code&gt;&lt;/a&gt;, it can be used to register and access named processes using the &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; tuple:</source>
          <target state="translated">После запуска реестра с заданным именем с помощью &lt;a href=&quot;registry#start_link/1&quot;&gt; &lt;code&gt;Registry.start_link/1&lt;/code&gt; &lt;/a&gt; его можно использовать для регистрации и доступа к именованным процессам с &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; кортежа {: via, Registry, {registry, key}} :</target>
        </trans-unit>
        <trans-unit id="3120d183e67a369d29bc150b0338b6b8abb5d5d0" translate="yes" xml:space="preserve">
          <source>Once the server is started, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function of the given &lt;code&gt;module&lt;/code&gt; is called with &lt;code&gt;init_arg&lt;/code&gt; as its argument to initialize the server. To ensure a synchronized start-up procedure, this function does not return until &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; has returned.</source>
          <target state="translated">После запуска сервера функция &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; данного &lt;code&gt;module&lt;/code&gt; вызывается с &lt;code&gt;init_arg&lt;/code&gt; в качестве аргумента для инициализации сервера. Чтобы гарантировать синхронизированную процедуру запуска, эта функция не возвращается, пока не вернется &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="737b5a76c492695b1fb2a3499dcde47a6c323b7a" translate="yes" xml:space="preserve">
          <source>Once the server is started, the remaining functions in this module (&lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt;, and friends) will also accept an atom, or any &lt;code&gt;{:global, ...}&lt;/code&gt; or &lt;code&gt;{:via, ...}&lt;/code&gt; tuples. In general, the following formats are supported:</source>
          <target state="translated">После запуска сервера остальные функции в этом модуле ( &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt; и другие) также будут принимать атом или любые кортежи &lt;code&gt;{:global, ...}&lt;/code&gt; или &lt;code&gt;{:via, ...}&lt;/code&gt; , Как правило, поддерживаются следующие форматы:</target>
        </trans-unit>
        <trans-unit id="6cbe4f06fe95e311cfe10127074ff0ebc20f68e2" translate="yes" xml:space="preserve">
          <source>Once the supervisor starts, it will traverse the list of children and it will invoke the &lt;code&gt;child_spec/1&lt;/code&gt; function on each module.</source>
          <target state="translated">После запуска супервизор будет &lt;code&gt;child_spec/1&lt;/code&gt; список дочерних элементов и вызывать функцию child_spec / 1 для каждого модуля.</target>
        </trans-unit>
        <trans-unit id="357e8b193ba3f628daabb2992835552bd8ea2347" translate="yes" xml:space="preserve">
          <source>Once the system specific dep is found, it loads it alongside env vars</source>
          <target state="translated">После того,как найден системный депо,он загружает его вместе с антивом &quot;env vars&quot;.</target>
        </trans-unit>
        <trans-unit id="1aa3fd67c8a0dadb7a1b2d1e3ee5265a0b531a76" translate="yes" xml:space="preserve">
          <source>Once this module is compiled, this information becomes available via the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">После компиляции этого модуля эта информация становится доступной через &lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a684f0cbbb273de72ab550d4274ba6c60e61a1" translate="yes" xml:space="preserve">
          <source>Once this module is compiled, this information becomes available via the &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">После компиляции этого модуля эта информация становится доступной через &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddada7d31dcc026dad66a50326650a75cc9cbb38" translate="yes" xml:space="preserve">
          <source>Once we change &lt;code&gt;setup&lt;/code&gt;, some tests will continue to fail. You may even notice tests pass and fail inconsistently between runs. For example, the &amp;ldquo;spawns buckets&amp;rdquo; test:</source>
          <target state="translated">Как только мы изменим &lt;code&gt;setup&lt;/code&gt; , некоторые тесты по-прежнему не пройдут. Вы даже можете заметить, что тесты проходят и не проходят между запусками. Например, тест &amp;laquo;порождает ведра&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="1fb2639015e7a539ce9fee1573b15649d727fb15" translate="yes" xml:space="preserve">
          <source>Once you exit the telnet client, you will likely see an error in the IEx session:</source>
          <target state="translated">Как только вы выйдете из клиента telnet,вы,скорее всего,увидите ошибку в IEx сессии:</target>
        </trans-unit>
        <trans-unit id="66b9a98849835ca0ccdcfc637fc20489cc149751" translate="yes" xml:space="preserve">
          <source>Once your application is compiled, running your system is a matter of starting your current application and its dependencies. Differently from other languages, Elixir does not have a &lt;code&gt;main&lt;/code&gt; procedure that is responsible for starting your system. Instead, you start one or more applications, each with their own initialization and termination logic.</source>
          <target state="translated">После того, как ваше приложение скомпилировано, запуск вашей системы зависит от запуска вашего текущего приложения и его зависимостей. В отличие от других языков, в Elixir нет &lt;code&gt;main&lt;/code&gt; процедуры, отвечающей за запуск вашей системы. Вместо этого вы запускаете одно или несколько приложений, каждое со своей собственной логикой инициализации и завершения.</target>
        </trans-unit>
        <trans-unit id="42b067f2517980dc4135d671302e4a77495e8c98" translate="yes" xml:space="preserve">
          <source>Once your library is configured, it will change the behaviour of all users of your library. If a library was expecting it to split the string in 2 parts, since the configuration is global, it will now split it in 3 parts.</source>
          <target state="translated">Как только ваша библиотека будет настроена,она изменит поведение всех пользователей вашей библиотеки.Если библиотека ожидала,что она разделит строку на 2 части,так как конфигурация глобальная,то теперь она разделит ее на 3 части.</target>
        </trans-unit>
        <trans-unit id="818ac58ed024c39752c7d32f5237a41c15a038fb" translate="yes" xml:space="preserve">
          <source>One alternative to GenEvent is a very minimal solution consisting of using a supervisor and multiple GenServers started under it. The supervisor acts as the &quot;event manager&quot; and the children GenServers act as the &quot;event handlers&quot;. This approach has some shortcomings (it provides no backpressure for example) but can still replace GenEvent for low-profile usages of it. &lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;This blog post by Jos&amp;eacute; Valim&lt;/a&gt; has more detailed information on this approach.</source>
          <target state="translated">Альтернативой GenEvent является очень минимальное решение, состоящее из использования супервизора и нескольких запущенных под ним GenServer. Супервизор действует как &amp;laquo;менеджер событий&amp;raquo;, а дочерние GenServers действуют как &amp;laquo;обработчики событий&amp;raquo;. Этот подход имеет некоторые недостатки (например, он не обеспечивает противодавления), но все же может заменить GenEvent для его низкопрофильного использования. &lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;В этом сообщении блога Хосе Валима&lt;/a&gt; есть более подробная информация об этом подходе.</target>
        </trans-unit>
        <trans-unit id="936a273dad718f4cb0bdcd05e022e88904985504" translate="yes" xml:space="preserve">
          <source>One drawback of IO data is that you can't do things like pattern match on the first part of a piece of IO data like you can with a binary, because you usually don't know the shape of the IO data. In those cases, you may need to convert it to a binary by calling &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt;, which is reasonably efficient since it's implemented natively in C. Other functionality, like computing the length of IO data, can be computed directly on the iodata by calling &lt;a href=&quot;#iodata_length/1&quot;&gt;&lt;code&gt;iodata_length/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Одним из недостатков данных ввода-вывода является то, что вы не можете делать такие вещи, как сопоставление с образцом в первой части части данных ввода-вывода, как вы можете с двоичными данными, потому что обычно вы не знаете форму данных ввода-вывода. В этих случаях вам может потребоваться преобразовать его в двоичный файл, вызвав &lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; , что достаточно эффективно, поскольку оно реализовано изначально на C. Другие функции, такие как вычисление длины данных ввода-вывода, могут быть вычислены непосредственно на iodata путем вызова &lt;a href=&quot;#iodata_length/1&quot;&gt; &lt;code&gt;iodata_length/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="959154f571cdda30a77c0e7157ebda7245e313d8" translate="yes" xml:space="preserve">
          <source>One example of optional callback in Elixir's standard library is &lt;a href=&quot;genserver#c:format_status/2&quot;&gt;&lt;code&gt;GenServer.format_status/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Одним из примеров необязательного обратного вызова в стандартной библиотеке Elixir является &lt;a href=&quot;genserver#c:format_status/2&quot;&gt; &lt;code&gt;GenServer.format_status/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d674767cbf01026585b7b15f455dcf774fdcde40" translate="yes" xml:space="preserve">
          <source>One example of optional callback in Elixir's standard library is &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:format_status/2&quot;&gt;&lt;code&gt;GenServer.format_status/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Одним из примеров необязательного обратного вызова в стандартной библиотеке Elixir является &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:format_status/2&quot;&gt; &lt;code&gt;GenServer.format_status/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="682598a408460f45c2b269ef31f62c8ef9525a00" translate="yes" xml:space="preserve">
          <source>One flaw that shows up right away is the ordering issue. Since &lt;code&gt;KV.Registry&lt;/code&gt; invokes &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;, then the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; must be started before &lt;code&gt;KV.Registry&lt;/code&gt;. Otherwise, it may happen that the registry attempts to reach the bucket supervisor before it has started.</source>
          <target state="translated">Один недостаток, который проявляется сразу, - это проблема с заказом. Поскольку &lt;code&gt;KV.Registry&lt;/code&gt; вызывает &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; , то &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; должен быть запущен до &lt;code&gt;KV.Registry&lt;/code&gt; . В противном случае может случиться так, что реестр попытается связаться с супервизором корзины до его запуска.</target>
        </trans-unit>
        <trans-unit id="6e4f2997cd25bc613534eada98471130bd76e1d1" translate="yes" xml:space="preserve">
          <source>One may also consider passing the &lt;code&gt;:delayed_write&lt;/code&gt; option if the stream is meant to be written to under a tight loop.</source>
          <target state="translated">Можно также рассмотреть возможность передачи опции &lt;code&gt;:delayed_write&lt;/code&gt; , если поток предназначен для записи в рамках жесткого цикла.</target>
        </trans-unit>
        <trans-unit id="cfde78399ed297a92cd58c53e350baeaf0f353fe" translate="yes" xml:space="preserve">
          <source>One may be tempted to write:</source>
          <target state="translated">Может возникнуть соблазн писать:</target>
        </trans-unit>
        <trans-unit id="1781595a1670e5536e6aa5b4d9e3408ffa2c5bc3" translate="yes" xml:space="preserve">
          <source>One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behaviour above.</source>
          <target state="translated">Можно было ожидать,что она перестанет быть -12.52.Это не ошибка.Большинство десятичных дробей не может быть представлено в виде двоичной плавающей точки,поэтому приведенное выше число внутренне представлено в виде -12.51999999,что объясняет поведение,приведенное выше.</target>
        </trans-unit>
        <trans-unit id="243a9890c71db8191808f5cd66bd3e2313e581bb" translate="yes" xml:space="preserve">
          <source>One may have expected it to floor to 12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 12.51999999, which explains the behaviour above.</source>
          <target state="translated">Можно было ожидать,что он пролетит до 12.52.Это не ошибка.Большинство десятичных дробей не может быть представлено как двоичная плавающая запятая,и поэтому вышеприведенное число внутренне представлено как 12.51999999,что объясняет поведение,описанное выше.</target>
        </trans-unit>
        <trans-unit id="35c338e7afb24d2e6ec4b29eabef0038bd79d2c7" translate="yes" xml:space="preserve">
          <source>One may have expected it to round to the half up 5.568. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 5.567499999, which explains the behaviour above. If you want exact rounding for decimals, you must use a decimal library. The behaviour above is also in accordance to reference implementations, such as &quot;Correctly Rounded Binary-Decimal and Decimal-Binary Conversions&quot; by David M. Gay.</source>
          <target state="translated">Можно было ожидать,что он округляется до половины вверх на 5.568.Это не ошибка.Большинство десятичных дробей не может быть представлено в виде двоичной плавающей точки,поэтому вышеприведенное число внутренне представлено в виде 5.567499999,что объясняет поведение,описанное выше.Если вам нужно точное округление для десятичных дробей,вы должны использовать десятичную библиотеку.Поведение,описанное выше,также соответствует эталонным реализациям,таким как &quot;Правильно округленные двоично-десятичные и десятичные двоичные преобразования&quot; Дэвида М.Гея.</target>
        </trans-unit>
        <trans-unit id="8d7bc5e861299f07fac2c27f8474b114a4a1611a" translate="yes" xml:space="preserve">
          <source>One of Elixir&amp;rsquo;s goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle all aspects of it as part of its core. Instead, Elixir aims to make itself extensible so developers, companies, and communities can extend the language to their relevant domains.</source>
          <target state="translated">Одна из целей Elixir - расширяемость: разработчики должны иметь возможность расширять язык для соответствия любой конкретной области. Информатика стала настолько обширной областью, что язык не может охватить все ее аспекты как часть его ядра. Вместо этого Elixir стремится сделать себя расширяемым, чтобы разработчики, компании и сообщества могли распространять язык на свои соответствующие области.</target>
        </trans-unit>
        <trans-unit id="75e244bba7b8a676a5ca57c1abcc6a33d031ea31" translate="yes" xml:space="preserve">
          <source>One of Elixir&amp;rsquo;s goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle many fields as part of its core. Rather, our best bet is to make the language extensible, so developers, companies, and communities can extend the language to their relevant domains.</source>
          <target state="translated">Одна из целей Elixir - расширяемость: разработчики должны иметь возможность расширять язык для соответствия любой конкретной области. Информатика стала такой обширной областью, что язык не может охватить многие области как часть своего ядра. Лучше всего сделать язык расширяемым, чтобы разработчики, компании и сообщества могли распространять язык на свои соответствующие области.</target>
        </trans-unit>
        <trans-unit id="f12014f3377101a9cac5f1547fca32045e59771c" translate="yes" xml:space="preserve">
          <source>One of the common uses of tasks is to convert sequential code into concurrent code with &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</source>
          <target state="translated">Одно из распространенных применений задач - преобразование последовательного кода в параллельный код с помощью &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; с сохранением его семантики. При вызове новый процесс будет создан, связан и отслеживаться вызывающим. После завершения действия задачи вызывающему абоненту будет отправлено сообщение с результатом.</target>
        </trans-unit>
        <trans-unit id="442f0d53f86c717b454c40ddbdea4b216903b62b" translate="yes" xml:space="preserve">
          <source>One of the common uses of tasks is to convert sequential code into concurrent code with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</source>
          <target state="translated">Одно из распространенных применений задач - преобразование последовательного кода в параллельный код с помощью &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; при сохранении его семантики. При вызове новый процесс будет создан, связан и отслеживаться вызывающим. После завершения действия задачи вызывающему абоненту будет отправлено сообщение с результатом.</target>
        </trans-unit>
        <trans-unit id="45e3c4f5c17e2b30b01adb9fc6c7523fd8a1551d" translate="yes" xml:space="preserve">
          <source>One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes &quot;time warps&quot;. In order to understand how such changes may be harmful, imagine the following code:</source>
          <target state="translated">Одна из сложностей в зависимости от системного времени заключается в том,что они могут быть скорректированы.Например,при входе и выходе из летнего времени системные часы будут настраиваться,часто добавляя или удаляя один час.Мы называем такие изменения &quot;искажениями времени&quot;.Чтобы понять,как такие изменения могут быть вредными,представьте себе следующий код:</target>
        </trans-unit>
        <trans-unit id="4db2b2faba0190fda13833749f4659dabf9003b6" translate="yes" xml:space="preserve">
          <source>One of the few times where it is acceptable to start a process outside of a supervision tree is with &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;. Opposite to &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;async/await&lt;/code&gt; mechanism gives you full control over the spawned process life cycle - which is also why you must always call &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; after starting a task with &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;. Even though, if your application is spawning multiple async processes, you should consider using &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for better visibility when instrumenting and monitoring the system.</source>
          <target state="translated">Один из немногих случаев, когда допустимо запускать процесс вне дерева надзора, - это &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; . В &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; от Task.start_link / 1 , механизм &lt;code&gt;async/await&lt;/code&gt; дает вам полный контроль над жизненным циклом порожденного процесса - именно поэтому вы всегда должны вызывать &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; после запуска задачи с &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; . Даже если ваше приложение порождает несколько асинхронных процессов, вам следует рассмотреть возможность использования &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; для лучшей видимости при инструментировании и мониторинге системы.</target>
        </trans-unit>
        <trans-unit id="70db34f5d258e3970e35422bd42e5f7aa8840920" translate="yes" xml:space="preserve">
          <source>One of the few times where it is acceptable to start a process outside of a supervision tree is with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;. Opposite to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;async/await&lt;/code&gt; mechanism gives you full control over the spawned process life cycle - which is also why you must always call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; after starting a task with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;. Even though, if your application is spawning multiple async processes, you should consider using &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for better visibility when instrumenting and monitoring the system.</source>
          <target state="translated">Один из немногих случаев, когда допустимо запускать процесс вне дерева наблюдения, - это &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; . В &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; от Task.start_link / 1 , механизм &lt;code&gt;async/await&lt;/code&gt; дает вам полный контроль над жизненным циклом порожденного процесса - именно поэтому вы всегда должны вызывать &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; после запуска задачи с &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; . Даже если ваше приложение порождает несколько асинхронных процессов, вам следует рассмотреть возможность использования &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; для лучшей видимости при инструментировании и мониторинге системы.</target>
        </trans-unit>
        <trans-unit id="50df693ec447426e4660f01fa52af9e0c7763ea8" translate="yes" xml:space="preserve">
          <source>One of the files generated by &lt;code&gt;mix new&lt;/code&gt; is the &lt;code&gt;.formatter.exs&lt;/code&gt;. Elixir ships with a code formatter that is capable of automatically formatting our codebase according to a consistent style. The formatter is triggered with the &lt;code&gt;mix format&lt;/code&gt; task. The generated &lt;code&gt;.formatter.exs&lt;/code&gt; file configures which files should be formatted when &lt;code&gt;mix format&lt;/code&gt; runs.</source>
          <target state="translated">Один из файлов, созданных с помощью &lt;code&gt;mix new&lt;/code&gt; , - это &lt;code&gt;.formatter.exs&lt;/code&gt; . Elixir поставляется с модулем форматирования кода, который может автоматически форматировать нашу кодовую базу в соответствии с единым стилем. Средство форматирования запускается с задачей &lt;code&gt;mix format&lt;/code&gt; . Сгенерированный файл &lt;code&gt;.formatter.exs&lt;/code&gt; определяет, какие файлы следует форматировать при запуске формата &lt;code&gt;mix format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23789ea13a63764ed754dab1a42ca60802bf16ed" translate="yes" xml:space="preserve">
          <source>One of the most common protocols you may encounter is the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol: implementing its &lt;code&gt;to_string/1&lt;/code&gt; function for your custom structs will tell the Elixir kernel how to represent them as strings. We will explore all built-in protocols later. For now, let&amp;rsquo;s implement our own.</source>
          <target state="translated">Одним из наиболее распространенных протоколов, с которыми вы можете столкнуться, является протокол &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; : реализация его функции &lt;code&gt;to_string/1&lt;/code&gt; для ваших пользовательских структур укажет ядру Elixir, как представлять их в виде строк. Позже мы рассмотрим все встроенные протоколы. А пока реализуем нашу собственную.</target>
        </trans-unit>
        <trans-unit id="e9bea613040d7bfb9b683e8ec5d094125d04fc14" translate="yes" xml:space="preserve">
          <source>One of the projects in the Elixir organization is &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;the &lt;code&gt;Plug&lt;/code&gt; project&lt;/a&gt;, which is meant to be a common foundation for building web libraries and frameworks in Elixir.</source>
          <target state="translated">Один из проектов в организации Elixir является &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; проект , который призван стать основой общего для создания веб - библиотеки и рамки в эликсира.</target>
        </trans-unit>
        <trans-unit id="8bc47161c9d9f59158e06bc671097821742b5b3c" translate="yes" xml:space="preserve">
          <source>One should not rely on the specific formats returned by each of those fields. Instead one should use specialized functions, such as &lt;a href=&quot;#version/0&quot;&gt;&lt;code&gt;version/0&lt;/code&gt;&lt;/a&gt; to retrieve the Elixir version and &lt;a href=&quot;#otp_release/0&quot;&gt;&lt;code&gt;otp_release/0&lt;/code&gt;&lt;/a&gt; to retrieve the Erlang/OTP release.</source>
          <target state="translated">Не следует полагаться на конкретные форматы, возвращаемые каждым из этих полей. Вместо этого следует использовать специализированные функции, такие как &lt;a href=&quot;#version/0&quot;&gt; &lt;code&gt;version/0&lt;/code&gt; &lt;/a&gt; для получения версии Elixir и &lt;a href=&quot;#otp_release/0&quot;&gt; &lt;code&gt;otp_release/0&lt;/code&gt; &lt;/a&gt; для получения версии Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="3debe928eb1b5c8e87fe15888723579e1f0c4c11" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the &lt;code&gt;kv&lt;/code&gt; representation into the tree. That's when the &lt;code&gt;:bind_quoted&lt;/code&gt; option comes to the rescue (again!). By using &lt;code&gt;:bind_quoted&lt;/code&gt;, we can automatically disable unquoting while still injecting the desired variables into the tree:</source>
          <target state="translated">Одним из решений этой проблемы является отключение выделения кавычек в макросе, однако это сделает невозможным внедрение представления &lt;code&gt;kv&lt;/code&gt; в дерево. Вот когда &lt;code&gt;:bind_quoted&lt;/code&gt; вариант приходит на помощь (опять же !). Используя &lt;code&gt;:bind_quoted&lt;/code&gt; , мы можем автоматически отключить снятие кавычек, по-прежнему вставляя нужные переменные в дерево:</target>
        </trans-unit>
        <trans-unit id="d34436b8b519d619492a7f6d60f8ee6b7577de85" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind when using &lt;code&gt;do/end&lt;/code&gt; blocks is they are always bound to the outermost function call. For example, the following expression:</source>
          <target state="translated">При использовании блоков &lt;code&gt;do/end&lt;/code&gt; следует помнить одну вещь : они всегда привязаны к внешнему вызову функции. Например, следующее выражение:</target>
        </trans-unit>
        <trans-unit id="6e4d62621d7dc89fa232dc83ec13aa33f3a32463" translate="yes" xml:space="preserve">
          <source>One-liner examples</source>
          <target state="translated">Примеры из одной строки</target>
        </trans-unit>
        <trans-unit id="fb233acd325ac5f63323e72a517a0c2a9f0f950a" translate="yes" xml:space="preserve">
          <source>One-off commands (eval and rpc)</source>
          <target state="translated">Разовые команды (eval и rpc)</target>
        </trans-unit>
        <trans-unit id="76d560c48bdb5ca6e530c94b3e593f70eea7f4cf" translate="yes" xml:space="preserve">
          <source>Only a single break point can be set per function. So if you call &lt;code&gt;IEx.break!&lt;/code&gt; multiple times with different patterns, only the last pattern is kept.</source>
          <target state="translated">Для каждой функции может быть установлена ​​только одна точка останова. Так что если вы &lt;code&gt;IEx.break!&lt;/code&gt; несколько раз с разными узорами, сохраняется только последний узор.</target>
        </trans-unit>
        <trans-unit id="91104ae4893712c54ab7b2c242913ddbdd74161a" translate="yes" xml:space="preserve">
          <source>Only registries with unique keys can be used in &lt;code&gt;:via&lt;/code&gt;. If the name is already taken, the case-specific &lt;code&gt;start_link&lt;/code&gt; function (&lt;a href=&quot;agent#start_link/2&quot;&gt;&lt;code&gt;Agent.start_link/2&lt;/code&gt;&lt;/a&gt; in the example above) will return &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt;.</source>
          <target state="translated">Только реестры с уникальными ключами могут использоваться в &lt;code&gt;:via&lt;/code&gt; . Если имя уже занято, &lt;code&gt;start_link&lt;/code&gt; функция start_link ( &lt;a href=&quot;agent#start_link/2&quot;&gt; &lt;code&gt;Agent.start_link/2&lt;/code&gt; &lt;/a&gt; в приведенном выше примере) вернет &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb293d4932d22a7b3abc1156a1928937b5c2868e" translate="yes" xml:space="preserve">
          <source>Only registries with unique keys can be used in &lt;code&gt;:via&lt;/code&gt;. If the name is already taken, the case-specific &lt;code&gt;start_link&lt;/code&gt; function (&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#start_link/2&quot;&gt;&lt;code&gt;Agent.start_link/2&lt;/code&gt;&lt;/a&gt; in the example above) will return &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt;.</source>
          <target state="translated">Только реестры с уникальными ключами могут использоваться в &lt;code&gt;:via&lt;/code&gt; . Если имя уже занято, функция &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#start_link/2&quot;&gt; &lt;code&gt;Agent.start_link/2&lt;/code&gt; &lt;/a&gt; конкретного &lt;code&gt;start_link&lt;/code&gt; ( Agent.start_link / 2 в приведенном выше примере) вернет &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8370e504155b094c81379fca456a5fed9430a083" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поддерживает преобразование только дат, которые находятся в календаре ISO или других календарях, в которых дни также начинаются с полуночи. Попытка преобразовать даты из других календарей вызовет ошибку &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0fb72f3a11be642bad272639e9d74eca399f26a" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поддерживает преобразование только дат, которые находятся в календаре ISO или других календарях, в которых дни также начинаются с полуночи. Попытка преобразовать даты из других календарей вызовет ошибку &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46f4e449cb60e2a60400c8cc32b9bd80531293a3" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise.</source>
          <target state="translated">Поддерживается только конвертирование дат,которые находятся в календаре ISO или в других календарях,в которых дни также начинаются в полночь.Попытка конвертировать даты из других календарей повысится.</target>
        </trans-unit>
        <trans-unit id="9f0d1de9c28799182839cd339d3cb6bcc84675dc" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple.</source>
          <target state="translated">Поддерживается только конвертирование дат,которые находятся в календаре ISO или в других календарях,в которых дни также начинаются в полночь.Попытка конвертировать даты из других календарей вернет кортеж ошибки.</target>
        </trans-unit>
        <trans-unit id="30f7e5d05978072f24365b5caff95955f0fd6ddc" translate="yes" xml:space="preserve">
          <source>Only supports converting datetimes which are in the ISO calendar, attempting to convert datetimes from other calendars will raise.</source>
          <target state="translated">Поддерживается преобразование только тех дат,которые есть в календаре ISO,при попытке преобразовать даты из других календарей повысится.</target>
        </trans-unit>
        <trans-unit id="22f0d29bfd1420b0788307cfc97c7fee840e6505" translate="yes" xml:space="preserve">
          <source>Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise.</source>
          <target state="translated">Поддерживается только преобразование наивных дат,которые есть в календаре ISO,попытка преобразовать наивные даты из других календарей повысится.</target>
        </trans-unit>
        <trans-unit id="d3045ee98cfbc830389c9723770392a552b836ee" translate="yes" xml:space="preserve">
          <source>Only the constructs listed in this page are allowed in patterns and guards. However, we can take advantage of macros to write custom patterns guards that can simplify our programs or make them more domain-specific. At the end of the day, what matters is that the &lt;em&gt;output&lt;/em&gt; of the macros boils down to a combination of the constructs above.</source>
          <target state="translated">В выкройках и щитках разрешены только конструкции, перечисленные на этой странице. Тем не менее, мы можем использовать макросы для написания настраиваемых защитных шаблонов, которые могут упростить наши программы или сделать их более специфичными для предметной области. В конце концов, важно то, что &lt;em&gt;вывод&lt;/em&gt; макросов сводится к комбинации описанных выше конструкций.</target>
        </trans-unit>
        <trans-unit id="332d85692072489eba14a228f056afbb7b36291a" translate="yes" xml:space="preserve">
          <source>Only the result of the tried expression falls down to the &lt;code&gt;else&lt;/code&gt; clause. If the &lt;code&gt;try&lt;/code&gt; ends up in the &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; clauses, their result will not fall down to &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">Только результат проверенного выражения попадает в предложение &lt;code&gt;else&lt;/code&gt; . Если &lt;code&gt;try&lt;/code&gt; заканчивается в предложениях &lt;code&gt;rescue&lt;/code&gt; или &lt;code&gt;catch&lt;/code&gt; , их результат не будет падать на &lt;code&gt;else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6a0905b9fcc638e0a1fca8f76bccd9e9d7434ee" translate="yes" xml:space="preserve">
          <source>Only two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the &lt;code&gt;:{}&lt;/code&gt; special form.</source>
          <target state="translated">Только двухэлементные кортежи считаются в Elixir литералами и возвращаются в кавычки. Следовательно, все другие кортежи представлены в AST как вызовы специальной формы &lt;code&gt;:{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16aa064c9dc61340a6a7ced2fa58dff653a9081d" translate="yes" xml:space="preserve">
          <source>Oops, it&amp;rsquo;s already started. Mix normally starts the whole hierarchy of applications defined in our project&amp;rsquo;s &lt;code&gt;mix.exs&lt;/code&gt; file and it does the same for all dependencies if they depend on other applications.</source>
          <target state="translated">Ой, это уже началось. Mix обычно запускает всю иерархию приложений, определенных в файле &lt;code&gt;mix.exs&lt;/code&gt; нашего проекта, и делает то же самое для всех зависимостей, если они зависят от других приложений.</target>
        </trans-unit>
        <trans-unit id="5d42424300a2c91f547136c88eca4a886647949b" translate="yes" xml:space="preserve">
          <source>Oops, it&amp;rsquo;s already started. Mix starts the current application and all of its dependencies automatically. This is also true for &lt;code&gt;mix test&lt;/code&gt; and many other Mix commands.</source>
          <target state="translated">Ой, это уже началось. Mix автоматически запускает текущее приложение и все его зависимости. Это также верно для &lt;code&gt;mix test&lt;/code&gt; и многих других команд смешивания .</target>
        </trans-unit>
        <trans-unit id="b63fb954cf2f2503038e51c96f877372b330207c" translate="yes" xml:space="preserve">
          <source>Opaque types</source>
          <target state="translated">непрозрачные типы</target>
        </trans-unit>
        <trans-unit id="626c544948c998858d0a89d08603d35b395d1a8e" translate="yes" xml:space="preserve">
          <source>Open mechanisms</source>
          <target state="translated">Открытые механизмы</target>
        </trans-unit>
        <trans-unit id="3f9c7fb45e8ae0a5da7732a25ef64d2dd5e2f563" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; and change the &lt;code&gt;application/0&lt;/code&gt; function to return the following:</source>
          <target state="translated">Откройте &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; и измените функцию &lt;code&gt;application/0&lt;/code&gt; , чтобы она возвращала следующее:</target>
        </trans-unit>
        <trans-unit id="11e01c21d7ba4061c620362e2623f958eae1be36" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;iex&lt;/code&gt; and type the following expressions:</source>
          <target state="translated">Откройте &lt;code&gt;iex&lt;/code&gt; и введите следующие выражения:</target>
        </trans-unit>
        <trans-unit id="d7a32c8b909bef4e4cf763fd044d2d69bd11d7c1" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/registry.ex&lt;/code&gt;, and let&amp;rsquo;s change its implementation. We&amp;rsquo;ve added comments to the source code to highlight the changes we&amp;rsquo;ve made:</source>
          <target state="translated">Откройте &lt;code&gt;lib/kv/registry.ex&lt;/code&gt; , и давайте изменим его реализацию. Мы добавили комментарии к исходному коду, чтобы выделить внесенные нами изменения:</target>
        </trans-unit>
        <trans-unit id="d182cf46ee852ebeb083e187ed597b6979eb7f37" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; and add the dynamic supervisor as a child as follows:</source>
          <target state="translated">Откройте &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; и добавьте динамический супервизор как дочерний, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="27d3d6fb25a7f593cdb34dc77c7c498cc6061a34" translate="yes" xml:space="preserve">
          <source>Open up a file, replace all &lt;code&gt;#&lt;/code&gt; by &lt;code&gt;%&lt;/code&gt; and stream to another file without loading the whole file in memory:</source>
          <target state="translated">Откройте файл, замените все &lt;code&gt;#&lt;/code&gt; на &lt;code&gt;%&lt;/code&gt; и выполните потоковую передачу в другой файл без загрузки всего файла в память:</target>
        </trans-unit>
        <trans-unit id="ece7b632859c06af3b4a35143bf4f0fa432ea01f" translate="yes" xml:space="preserve">
          <source>Opens a port given a tuple &lt;code&gt;name&lt;/code&gt; and a list of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">Открывает порт по &lt;code&gt;name&lt;/code&gt; кортежа и списку &lt;code&gt;options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf9b6c6020d1727c93ab3183dfda7cf9cd39780" translate="yes" xml:space="preserve">
          <source>Opens the current prying location.</source>
          <target state="translated">Открывает текущее место для подслушивания.</target>
        </trans-unit>
        <trans-unit id="7ac9350441fbbb582d3cc2a8956eb86730e74983" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;module.function/arity&lt;/code&gt;, or &lt;code&gt;{file, line}&lt;/code&gt;.</source>
          <target state="translated">Открывает указанный &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;module.function/arity&lt;/code&gt; или &lt;code&gt;{file, line}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5014597cdb33f83d370a77bd5b4dfd1154807086" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Открывает указанный &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11fb7a6db2170c9e59b49c5c2c758efde86398a0" translate="yes" xml:space="preserve">
          <source>Operating System environment configuration</source>
          <target state="translated">Конфигурация среды операционной системы</target>
        </trans-unit>
        <trans-unit id="46f4a92cf29f486cc2b970f2c56e3de24e2e02fa" translate="yes" xml:space="preserve">
          <source>Operating system process partitioning</source>
          <target state="translated">Разбиение процесса операционной системы</target>
        </trans-unit>
        <trans-unit id="56954dba5681f277cf4bb9e00fa07ee2810296a2" translate="yes" xml:space="preserve">
          <source>Operating the stream can fail on open for the same reasons as &lt;a href=&quot;#open!/2&quot;&gt;&lt;code&gt;File.open!/2&lt;/code&gt;&lt;/a&gt;. Note that the file is automatically opened each time streaming begins. There is no need to pass &lt;code&gt;:read&lt;/code&gt; and &lt;code&gt;:write&lt;/code&gt; modes, as those are automatically set by Elixir.</source>
          <target state="translated">Работа с потоком может завершиться ошибкой при открытии по тем же причинам, что и &lt;a href=&quot;#open!/2&quot;&gt; &lt;code&gt;File.open!/2&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что файл автоматически открывается каждый раз, когда начинается потоковая передача. Нет необходимости передавать режимы &lt;code&gt;:read&lt;/code&gt; и &lt;code&gt;:write&lt;/code&gt; , так как они автоматически устанавливаются Elixir.</target>
        </trans-unit>
        <trans-unit id="46f82301da497c0a0c802e4991b6eca2df33534d" translate="yes" xml:space="preserve">
          <source>Operating the stream can fail on open for the same reasons as &lt;a href=&quot;file#open!/2&quot;&gt;&lt;code&gt;File.open!/2&lt;/code&gt;&lt;/a&gt;. Note that the file is automatically opened each time streaming begins. There is no need to pass &lt;code&gt;:read&lt;/code&gt; and &lt;code&gt;:write&lt;/code&gt; modes, as those are automatically set by Elixir.</source>
          <target state="translated">Работа с потоком может завершиться ошибкой при открытии по тем же причинам, что и &lt;a href=&quot;file#open!/2&quot;&gt; &lt;code&gt;File.open!/2&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что файл автоматически открывается каждый раз, когда начинается потоковая передача. Нет необходимости передавать режимы &lt;code&gt;:read&lt;/code&gt; и &lt;code&gt;:write&lt;/code&gt; , так как они автоматически устанавливаются Elixir.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="0c395ef963d75a809b690d9db937d93c13ee8b98" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity</source>
          <target state="translated">Первенство и ассоциативность оператора</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e0733d98d125d129b916b0d8e46a91b56da34c0e" translate="yes" xml:space="preserve">
          <source>Operators are also represented as such tuples:</source>
          <target state="translated">Операторы также представлены в качестве таких кортежей:</target>
        </trans-unit>
        <trans-unit id="15dcbf2455ba217cc0f09140af8c2a19b7a3afae" translate="yes" xml:space="preserve">
          <source>Operators are treated as non-qualified calls:</source>
          <target state="translated">Операторы рассматриваются как неквалифицированные звонки:</target>
        </trans-unit>
        <trans-unit id="4a5600ebb83847e5cb5c012f92e0a86888c5caba" translate="yes" xml:space="preserve">
          <source>Opposite of &lt;a href=&quot;#zip/2&quot;&gt;&lt;code&gt;zip/2&lt;/code&gt;&lt;/a&gt;. Extracts two-element tuples from the given &lt;code&gt;enumerable&lt;/code&gt; and groups them together.</source>
          <target state="translated">Напротив &lt;a href=&quot;#zip/2&quot;&gt; &lt;code&gt;zip/2&lt;/code&gt; &lt;/a&gt; . Извлекает двухэлементные кортежи из заданного &lt;code&gt;enumerable&lt;/code&gt; и группирует их вместе.</target>
        </trans-unit>
        <trans-unit id="c4b9a19c8a84c9a632d32f40f93da320901bb185" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;#log/3&quot;&gt;&lt;code&gt;log/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and friends, the arguments given to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; are always evaluated. However, you can pass anonymous functions to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; and they will only be evaluated if there is something to be logged.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#log/3&quot;&gt; &lt;code&gt;log/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt; и друзей, аргументы, переданные &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt; , всегда оцениваются. Однако вы можете передавать анонимные функции в &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; ,&lt;/a&gt; и они будут оцениваться только в том случае, если есть что-то для регистрации.</target>
        </trans-unit>
        <trans-unit id="ea31b9298bd98dc4502fbe718b66df80ca6668b5" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, a Task has a default &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt;. This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do:</source>
          <target state="translated">Напротив &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; , задача имеет значение по умолчанию &lt;code&gt;:restart&lt;/code&gt; из &lt;code&gt;:temporary&lt;/code&gt; . Это означает, что задача не будет перезапущена даже в случае сбоя. Если вы хотите, чтобы задача была перезапущена при неудачных выходах, выполните:</target>
        </trans-unit>
        <trans-unit id="30b26a276b20cf62a74d08b15c4bd86b1da666ec" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, a Task has a default &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt;. This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do:</source>
          <target state="translated">Напротив &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; , задача имеет значение по умолчанию &lt;code&gt;:restart&lt;/code&gt; из &lt;code&gt;:temporary&lt;/code&gt; . Это означает, что задача не будет перезапущена даже в случае сбоя. Если вы хотите, чтобы задача была перезапущена при неудачных выходах, выполните:</target>
        </trans-unit>
        <trans-unit id="9edd3623396f77bd089667c715207bed5bf71fe2" translate="yes" xml:space="preserve">
          <source>Opposite to compile, dependencies are not attempted to be automatically solved between files.</source>
          <target state="translated">В отличие от компиляции,между файлами не предпринимается попытка автоматического решения зависимостей.</target>
        </trans-unit>
        <trans-unit id="193e97763df56d56d3233c109f6911eac927d080" translate="yes" xml:space="preserve">
          <source>Opposite to tuples, lists also allow matching on non-empty lists by using the &lt;code&gt;[head | tail]&lt;/code&gt; notation, which matches on the &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; of a list:</source>
          <target state="translated">В отличие от кортежей, списки также позволяют сопоставление непустых списков с помощью &lt;code&gt;[head | tail]&lt;/code&gt; , которое соответствует &lt;code&gt;head&lt;/code&gt; и &lt;code&gt;tail&lt;/code&gt; списка:</target>
        </trans-unit>
        <trans-unit id="e639bcdcf91aa8ac42e5d8553bb30970a11ad173" translate="yes" xml:space="preserve">
          <source>Option values used by &lt;code&gt;start_link&lt;/code&gt;</source>
          <target state="translated">Значения параметров, используемые &lt;code&gt;start_link&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4c508aa8815a1256a35a88886de2b38e1af4a2a" translate="yes" xml:space="preserve">
          <source>Option values used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">Значения опций, используемые функциями &lt;code&gt;start*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c404768d955448d9b6f90547eff35b8e6696cf8" translate="yes" xml:space="preserve">
          <source>OptionParser</source>
          <target state="translated">OptionParser</target>
        </trans-unit>
        <trans-unit id="e0257ae00caf99998e2d72ed84d9c0a4e5e38be0" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError</source>
          <target state="translated">OptionParser.ParseError</target>
        </trans-unit>
        <trans-unit id="418ba9c55c2dcefb7a2a957a84d702de99023f76" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">OptionParser.ParseError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="515bcb488bbc0e14192e6cad5140e9aea8b7fd33" translate="yes" xml:space="preserve">
          <source>Optional callbacks</source>
          <target state="translated">Дополнительные обратные вызовы</target>
        </trans-unit>
        <trans-unit id="113505cb0d224659da22493acb19fb684482f1d3" translate="yes" xml:space="preserve">
          <source>Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt;&lt;code&gt;function_exported?/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt;&lt;code&gt;macro_exported?/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Необязательные обратные вызовы - это обратные вызовы, которые модули обратного вызова могут реализовать, если захотят, но не обязательны. Обычно модули поведения знают, должны ли они вызывать эти обратные вызовы на основе конфигурации, или они проверяют, определены ли обратные вызовы с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt; &lt;code&gt;function_exported?/3&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt; &lt;code&gt;macro_exported?/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac614b09920ca40871efbb0a82438a90f0dbe49b" translate="yes" xml:space="preserve">
          <source>Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;function_exported?/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;macro_exported?/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Необязательные обратные вызовы - это обратные вызовы, которые модули обратного вызова могут реализовать, если захотят, но не обязательны. Обычно модули поведения знают, должны ли они вызывать эти обратные вызовы на основе конфигурации, или они проверяют, определены ли обратные вызовы с помощью &lt;a href=&quot;kernel#function_exported?/3&quot;&gt; &lt;code&gt;function_exported?/3&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt; &lt;code&gt;macro_exported?/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec7e5f711e91c3eb5ab6694cb992141e2b1d0f09" translate="yes" xml:space="preserve">
          <source>Optional callbacks can be defined through the &lt;code&gt;@optional_callbacks&lt;/code&gt; module attribute, which has to be a keyword list with function or macro name as key and arity as value. For example:</source>
          <target state="translated">Необязательные обратные вызовы могут быть определены через &lt;code&gt;@optional_callbacks&lt;/code&gt; модуля @optional_callbacks , который должен быть списком ключевых слов с именем функции или макроса в качестве ключа и арностью в качестве значения. Например:</target>
        </trans-unit>
        <trans-unit id="f6499468fb5a027c6923e49d62405caa882b21c9" translate="yes" xml:space="preserve">
          <source>Optional parentheses</source>
          <target state="translated">Дополнительные скобки</target>
        </trans-unit>
        <trans-unit id="f2868f090f8a4f2b92c94adec1efa9d97208896a" translate="yes" xml:space="preserve">
          <source>Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, and so forth. Avoid usage of special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because it might not work as expected.</source>
          <target state="translated">При желании можно передать список охранных условий для более точного сопоставления. Каждый сторож - это кортеж, в котором описаны проверки, которые должна пройти назначенная часть шаблона. Например, условие защиты &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; будет выражено как кортеж &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; . Пожалуйста , обратите внимание , что условия охраны будут работать только для выделенных переменных , таких как &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; , &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; , и так далее. Избегайте использования специальных переменных соответствия &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; и &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; , потому что это может работать не так, как ожидалось.</target>
        </trans-unit>
        <trans-unit id="1d0891bf09a71f28636a589d4b0d02b002898904" translate="yes" xml:space="preserve">
          <source>Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc. Avoid usage of special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because it might not work as expected.</source>
          <target state="translated">При желании можно передать список охранных условий для более точного сопоставления. Каждый сторож - это кортеж, который описывает проверки, которые должна проходить назначенная часть шаблона. Например, условие защиты &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; будет выражено как кортеж &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; . Пожалуйста , обратите внимание , что условия охраны будут работать только для выделенных переменных , таких как &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; , &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; и т.д. использование Избегайте специальных переменных спичечных &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; и &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; , потому что он не может работать , как ожидалось.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="cf952a9fe5b6f3faba42bc98e0ad5176e7e0c07e" translate="yes" xml:space="preserve">
          <source>Options can also be given:</source>
          <target state="translated">Могут быть также даны опции:</target>
        </trans-unit>
        <trans-unit id="7a09f1485253101de1cd882c67ecfea3b7b67e2b" translate="yes" xml:space="preserve">
          <source>Options can be:</source>
          <target state="translated">Опции могут быть:</target>
        </trans-unit>
        <trans-unit id="f27e7e03a3ca6748e6baeb02a0f8a56e6603e040" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Параметры для &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="efaa2b27718160760d18ba74e06c5819b7a4ab29" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Параметры для &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5eae55a87aa27e83c0b98f403b07f3b4076428b4" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Параметры для &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="058eb4cd0ba0f3ab247b93a59c7b6bffee0a4161" translate="yes" xml:space="preserve">
          <source>Options used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">Параметры, используемые функциями &lt;code&gt;start*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a54fa3d94cab5b1a4217c700bb98f7a74c5eeec" translate="yes" xml:space="preserve">
          <source>Options used for &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Параметры, используемые для &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f3f8106feac737e0576442e94ddc74fd873217" translate="yes" xml:space="preserve">
          <source>Or also on pattern matching to extract values out:</source>
          <target state="translated">Или также на соответствие шаблонов для извлечения значений:</target>
        </trans-unit>
        <trans-unit id="110400c4fdb0f6e57b930554b0298f99e6f6579b" translate="yes" xml:space="preserve">
          <source>Or also via pattern matching:</source>
          <target state="translated">Или также через подгонку по шаблону:</target>
        </trans-unit>
        <trans-unit id="2b8a5d79778b4d39ad8915654992a0b6572ea485" translate="yes" xml:space="preserve">
          <source>Or as a part of function definitions to pattern match:</source>
          <target state="translated">Или как часть определения функций для соответствия шаблону:</target>
        </trans-unit>
        <trans-unit id="81b6497bf8a349effd8966b9cdac67662ea19529" translate="yes" xml:space="preserve">
          <source>Or even use the async/await pattern:</source>
          <target state="translated">Или даже используйте шаблон асинхронизации и ожидания:</target>
        </trans-unit>
        <trans-unit id="cbf79603a9a0d1cebbf945b6fa826e23c8db59d3" translate="yes" xml:space="preserve">
          <source>Or if you want to read a custom path inside the release:</source>
          <target state="translated">Или если вы хотите прочитать пользовательский путь внутри релиза:</target>
        </trans-unit>
        <trans-unit id="379f3dfc84af41e8ced43be0f50303277e4d6e2f" translate="yes" xml:space="preserve">
          <source>Or in umbrellas:</source>
          <target state="translated">Или в зонтах:</target>
        </trans-unit>
        <trans-unit id="df3698d69c7b1187df56c2f297fdade2ea595981" translate="yes" xml:space="preserve">
          <source>Or on Windows:</source>
          <target state="translated">Или на Windows:</target>
        </trans-unit>
        <trans-unit id="c55b30b404c72029dc39b6c0373f88b3c2117b45" translate="yes" xml:space="preserve">
          <source>Or perhaps you want to make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</source>
          <target state="translated">Или, возможно, вы хотите сделать порт &lt;code&gt;KVServer&lt;/code&gt; настраиваемым, а значение порта будет указано только во время выполнения:</target>
        </trans-unit>
        <trans-unit id="b3c1ba6ffcae31c642695b4056ca652b985d821d" translate="yes" xml:space="preserve">
          <source>Or simply use pattern matching:</source>
          <target state="translated">Или просто используйте совпадение шаблонов:</target>
        </trans-unit>
        <trans-unit id="2e2e0dde765341b0ca22014d3a7b90bc8ecdc978" translate="yes" xml:space="preserve">
          <source>Or to import all functions, you could write:</source>
          <target state="translated">Или импортировать все функции,можно написать:</target>
        </trans-unit>
        <trans-unit id="7f4e1686a5722761b70122d53c4e0b6fffa922b0" translate="yes" xml:space="preserve">
          <source>Or to import files from children in umbrella projects:</source>
          <target state="translated">Или для импорта файлов от детей в зонтичных проектах:</target>
        </trans-unit>
        <trans-unit id="f146bf6e3a2ae8c150e0ba215da5069807c64480" translate="yes" xml:space="preserve">
          <source>Or to set a breakpoint that will stop 10 times:</source>
          <target state="translated">Или установить точку останова,которая будет останавливаться 10 раз:</target>
        </trans-unit>
        <trans-unit id="3d348d5449f71e35f5ea0982362377c8a421346b" translate="yes" xml:space="preserve">
          <source>Or to trigger it whenever the second argument is a map with more than one element:</source>
          <target state="translated">Или запускать его всякий раз,когда второй аргумент-карта с более чем одним элементом:</target>
        </trans-unit>
        <trans-unit id="e6af120ddb5b0c93752c9382e27cf7b178db5d6d" translate="yes" xml:space="preserve">
          <source>Or use &lt;code&gt;:asc&lt;/code&gt; and &lt;code&gt;:desc&lt;/code&gt;:</source>
          <target state="translated">Или используйте &lt;code&gt;:asc&lt;/code&gt; и &lt;code&gt;:desc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8b5320509e4f05f8ea43bb4f458da443d14575a8" translate="yes" xml:space="preserve">
          <source>Or, even better:</source>
          <target state="translated">Или,даже лучше:</target>
        </trans-unit>
        <trans-unit id="7346db833d750efbcd6fcd51d602e24a6966464d" translate="yes" xml:space="preserve">
          <source>Or, using the capture syntax:</source>
          <target state="translated">Или,используя синтаксис захвата:</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="c45740924e5d354064b64521e5aaf12582061570" translate="yes" xml:space="preserve">
          <source>Other agent actions</source>
          <target state="translated">Иные действия агента</target>
        </trans-unit>
        <trans-unit id="cd6ecf7baf7f186954c254a45288721bbe3e452f" translate="yes" xml:space="preserve">
          <source>Other caveats are the impossibility to call count trace BIFs, since breakpoints can only be set on BEAM code; functions calls performed by &lt;code&gt;:cprof&lt;/code&gt; are not traced; the maximum size of a call counter is equal to the host machine's word size (for example, 2147483647 in a 32-bit host).</source>
          <target state="translated">Другими предостережениями являются невозможность вызова BIF трассировки подсчета, поскольку точки останова могут быть установлены только в коде BEAM; вызовы функций, выполняемые &lt;code&gt;:cprof&lt;/code&gt; , не отслеживаются; максимальный размер счетчика вызовов равен размеру слова хост-машины (например, 2147483647 в 32-битном хосте).</target>
        </trans-unit>
        <trans-unit id="dbe1399abe277751b991272fda96ac3cb3827543" translate="yes" xml:space="preserve">
          <source>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: &lt;code&gt;&quot;a&quot;&lt;/code&gt; will not match &lt;code&gt;&quot;A&quot;&lt;/code&gt;.</source>
          <target state="translated">Другие персонажи представляют себя. Подходят только пути, содержащие одинаковые символы в одной и той же позиции. Обратите внимание, что соответствие чувствительно к регистру: &lt;code&gt;&quot;a&quot;&lt;/code&gt; не будет соответствовать &lt;code&gt;&quot;A&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ce1008fe24127bd6a35c9e94fa13e898855bf85" translate="yes" xml:space="preserve">
          <source>Other constructs are &lt;a href=&quot;kernel.specialforms#for/1&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#with/1&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;try/rescue/catch/else&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;kernel#match?/2&quot;&gt;&lt;code&gt;match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Другие конструкции предназначены &lt;a href=&quot;kernel.specialforms#for/1&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#with/1&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;try/rescue/catch/else&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;kernel#match?/2&quot;&gt; &lt;code&gt;match?/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32b26031f2d4ec505f1490c8e029cbbddc736c20" translate="yes" xml:space="preserve">
          <source>Other errors can be raised with &lt;code&gt;raise/2&lt;/code&gt; passing the error name and a list of keyword arguments:</source>
          <target state="translated">Другие ошибки могут быть вызваны с помощью метода &lt;code&gt;raise/2&lt;/code&gt; , передающего имя ошибки и список аргументов ключевого слова:</target>
        </trans-unit>
        <trans-unit id="f6f1d0ed197e63f74804e7083d76174b0a502dfb" translate="yes" xml:space="preserve">
          <source>Other options include:</source>
          <target state="translated">Другие варианты включают в себя:</target>
        </trans-unit>
        <trans-unit id="dd317e6d04c14a2ed23576c03ddc173b8001094a" translate="yes" xml:space="preserve">
          <source>Other time zone databases (including ones provided by packages) can be configure as default either via configuration:</source>
          <target state="translated">Другие базы данных часовых поясов (включая базы данных,предоставляемые пакетами)могут быть настроены по умолчанию либо через конфигурацию:</target>
        </trans-unit>
        <trans-unit id="ede73ee447530b341b516cdc557113ccf7679079" translate="yes" xml:space="preserve">
          <source>Other time zone databases (including ones provided by packages) can be configured as default either via configuration:</source>
          <target state="translated">Другие базы данных часовых поясов (включая базы данных,предоставляемые пакетами)могут быть настроены по умолчанию либо через конфигурацию:</target>
        </trans-unit>
        <trans-unit id="103386501b54ba75aa5753f09965431aa8e69dfa" translate="yes" xml:space="preserve">
          <source>Other time zone databases can also be configured. For example, two of the available options are:</source>
          <target state="translated">Также можно настроить базы данных других часовых поясов.Например,два из доступных вариантов:</target>
        </trans-unit>
        <trans-unit id="3cad5a00eec7472c9a3591c446721f3e6c58c845" translate="yes" xml:space="preserve">
          <source>Other tools and community</source>
          <target state="translated">Другие инструменты и сообщество</target>
        </trans-unit>
        <trans-unit id="d9b0ed607a935499601e4fd42e28be80554ff28b" translate="yes" xml:space="preserve">
          <source>Otherwise it should return &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; and a default algorithm built on top of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; that runs in linear time will be used.</source>
          <target state="translated">В противном случае он должен вернуть &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; и будет использован алгоритм по умолчанию, построенный на основе &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; ,&lt;/a&gt; который выполняется за линейное время.</target>
        </trans-unit>
        <trans-unit id="1c81b36166b2eaba733a51d04e61d3fe880c8923" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;nil&lt;/code&gt; in case the module exists, but it isn't a task or cannot be found.</source>
          <target state="translated">В противном случае возвращает &lt;code&gt;nil&lt;/code&gt; , если модуль существует, но не является задачей или не может быть найден.</target>
        </trans-unit>
        <trans-unit id="aa826b74ad8c081871b116d8c34cb3e95cd21b98" translate="yes" xml:space="preserve">
          <source>Otherwise the message is sent and &lt;code&gt;:ok&lt;/code&gt; is returned.</source>
          <target state="translated">В противном случае сообщение отправляется и возвращается &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1247b12cce6e0be8066f8c9a379932aa1ec5d1" translate="yes" xml:space="preserve">
          <source>Otherwise we get an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when construcing the binary:</source>
          <target state="translated">В противном случае мы получим &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; при построении двоичного файла:</target>
        </trans-unit>
        <trans-unit id="9cafb8b841614ef77e86d7299d3dbf34c38a0e86" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;KV.Registry&lt;/code&gt; process received a cast with &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; and a call with &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt;, in this sequence. &lt;code&gt;GenServer.cast&lt;/code&gt; will immediately return, as soon as the message is sent to the &lt;code&gt;registry&lt;/code&gt;. The &lt;code&gt;GenServer.call&lt;/code&gt; on the other hand, is where we would be waiting for an answer, provided by the above &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; callback.</source>
          <target state="translated">Наш процесс &lt;code&gt;KV.Registry&lt;/code&gt; получил приведение с &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; и вызов с &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt; в этой последовательности. &lt;code&gt;GenServer.cast&lt;/code&gt; вернется сразу же, как только сообщение будет отправлено в &lt;code&gt;registry&lt;/code&gt; . С другой стороны, &lt;code&gt;GenServer.call&lt;/code&gt; - это то место, где мы будем ждать ответа, предоставленного вышеуказанным &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; вызовом KV.Registry.handle_call .</target>
        </trans-unit>
        <trans-unit id="32cb7dd97d5b5169235f629b257bf4b1bebebde0" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;kv&lt;/code&gt; application is complete, so it&amp;rsquo;s time to implement the server that will handle the requests we defined in the first chapter:</source>
          <target state="translated">Наше приложение &lt;code&gt;kv&lt;/code&gt; готово , поэтому пришло время реализовать сервер, который будет обрабатывать запросы, которые мы определили в первой главе:</target>
        </trans-unit>
        <trans-unit id="fae76d2c8957b5d3f77fc1cdf6ba676bd9429aa5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;macro_unless&lt;/code&gt; macro received the following:</source>
          <target state="translated">Наш макрос &lt;code&gt;macro_unless&lt;/code&gt; получил следующее:</target>
        </trans-unit>
        <trans-unit id="d411cc3e34a79409af812e8a3926471d9c1101c5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;mix.exs&lt;/code&gt; defines two public functions: &lt;code&gt;project&lt;/code&gt;, which returns project configuration like the project name and version, and &lt;code&gt;application&lt;/code&gt;, which is used to generate an application file.</source>
          <target state="translated">Наш &lt;code&gt;mix.exs&lt;/code&gt; определяет две общедоступные функции: &lt;code&gt;project&lt;/code&gt; , который возвращает конфигурацию проекта, такую ​​как имя и версия проекта, и &lt;code&gt;application&lt;/code&gt; , которое используется для создания файла приложения.</target>
        </trans-unit>
        <trans-unit id="4263c0c28d87ce16526214a430448dce9d929e50" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;msg&lt;/code&gt; is printed and &lt;code&gt;print_multiple_times/2&lt;/code&gt; is called again, this time with the second argument set to &lt;code&gt;1&lt;/code&gt;. Because &lt;code&gt;n&lt;/code&gt; is now set to &lt;code&gt;1&lt;/code&gt;, the guard in our first definition of &lt;code&gt;print_multiple_times/2&lt;/code&gt; evaluates to true, and we execute this particular definition. The &lt;code&gt;msg&lt;/code&gt; is printed, and there is nothing left to execute.</source>
          <target state="translated">Наше &lt;code&gt;msg&lt;/code&gt; печатается, и &lt;code&gt;print_multiple_times/2&lt;/code&gt; , на этот раз со вторым аргументом, равным &lt;code&gt;1&lt;/code&gt; . Поскольку &lt;code&gt;n&lt;/code&gt; теперь установлено в &lt;code&gt;1&lt;/code&gt; , сторож в нашем первом определении &lt;code&gt;print_multiple_times/2&lt;/code&gt; оценивается как true, и мы выполняем это конкретное определение. &lt;code&gt;msg&lt;/code&gt; печатается, и нет ничего, чтобы исполнить.</target>
        </trans-unit>
        <trans-unit id="ade0f4f0153f3ee46feb17f06f5a697e3ea8100e" translate="yes" xml:space="preserve">
          <source>Our database engine used by &lt;code&gt;:my_app&lt;/code&gt; needs to know what databases exist, and what the database configurations are. The database engine can make a call to &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; to retrieve the list of databases (specified by module names). Our database engine can then traverse each repository in the list and then call &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; and so forth to retrieve the configuration of each one.</source>
          <target state="translated">Наш движок базы данных, используемый &lt;code&gt;:my_app&lt;/code&gt; , должен знать, какие базы данных существуют и каковы конфигурации базы данных. &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; базы данных может вызвать get_env (: my_app,: my_app_databases), чтобы получить список баз данных (заданный именами модулей). Затем наш механизм базы данных может просмотреть каждый репозиторий в списке, а затем вызвать &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; и так далее, чтобы получить конфигурацию каждого из них.</target>
        </trans-unit>
        <trans-unit id="a2f6d0c933af7daca11ac7f7ad70a0c3c2249028" translate="yes" xml:space="preserve">
          <source>Our first distributed code</source>
          <target state="translated">Наш первый распространяемый код</target>
        </trans-unit>
        <trans-unit id="9e84809a7c397a309ce96164f5cacbbeaf21e474" translate="yes" xml:space="preserve">
          <source>Our first distributed task retrieves the name of the node the task is running on. Notice we have given an anonymous function to &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; but, in distributed cases, it is preferable to give the module, function, and arguments explicitly:</source>
          <target state="translated">Наша первая распределенная задача извлекает имя узла, на котором выполняется задача. Обратите внимание, что мы предоставили анонимную функцию для &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; , но в распределенных случаях предпочтительнее явно указывать модуль, функцию и аргументы:</target>
        </trans-unit>
        <trans-unit id="87ced78c461b132d154e8f4cf702fd7438182b7f" translate="yes" xml:space="preserve">
          <source>Our first macro</source>
          <target state="translated">Наш первый макрос</target>
        </trans-unit>
        <trans-unit id="a44749c5086277b1e9b2d47d74121d2d8219a432" translate="yes" xml:space="preserve">
          <source>Our first project</source>
          <target state="translated">Наш первый проект</target>
        </trans-unit>
        <trans-unit id="b27267683384fbe26b34a46fe89e40b87ffb846e" translate="yes" xml:space="preserve">
          <source>Our first supervisor</source>
          <target state="translated">Наш первый руководитель</target>
        </trans-unit>
        <trans-unit id="08203c924a4f2f9eb683fc56d049d3e81c8b3b3e" translate="yes" xml:space="preserve">
          <source>Our first test starts a new &lt;code&gt;KV.Bucket&lt;/code&gt; by calling the &lt;code&gt;start_link/1&lt;/code&gt; and passing an empty list of options. Then we perform some &lt;code&gt;get/2&lt;/code&gt; and &lt;code&gt;put/3&lt;/code&gt; operations on it, asserting the result.</source>
          <target state="translated">Наш первый тест запускает новый &lt;code&gt;KV.Bucket&lt;/code&gt; , вызывая &lt;code&gt;start_link/1&lt;/code&gt; и передавая пустой список параметров. Затем мы выполняем некоторые операции &lt;code&gt;get/2&lt;/code&gt; и &lt;code&gt;put/3&lt;/code&gt; , утверждая результат.</target>
        </trans-unit>
        <trans-unit id="219a6c3d5bbb168da4e01962d5ac3a3beba4fafe" translate="yes" xml:space="preserve">
          <source>Our implementation splits the line on whitespace and then matches the command against a list. Using &lt;code&gt;String.split/1&lt;/code&gt; means our commands will be whitespace-insensitive. Leading and trailing whitespace won&amp;rsquo;t matter, nor will consecutive spaces between words. Let&amp;rsquo;s add some new doctests to test this behaviour along with the other commands:</source>
          <target state="translated">Наша реализация разбивает строку на пробелы, а затем сопоставляет команду со списком. Использование &lt;code&gt;String.split/1&lt;/code&gt; означает, что наши команды будут нечувствительны к пробелам . Начальные и конечные пробелы не имеют значения, равно как и последовательные пробелы между словами. Давайте добавим несколько новых тестов, чтобы проверить это поведение вместе с другими командами:</target>
        </trans-unit>
        <trans-unit id="4bada33605b3d0085e74cd5e28e1db60fae2e0fd" translate="yes" xml:space="preserve">
          <source>Our integration test checks all server interaction, including unknown commands and not found errors. It is worth noting that, as with</source>
          <target state="translated">Наш интеграционный тест проверяет все взаимодействие с сервером,включая неизвестные команды и не найденные ошибки.Стоит отметить,что,как и в случае с</target>
        </trans-unit>
        <trans-unit id="34a1175408d05bc3f9db3276c1dc05ef2699c1bd" translate="yes" xml:space="preserve">
          <source>Our integration test will use a TCP client that sends commands to our server and assert we are getting the desired responses.</source>
          <target state="translated">Наш интеграционный тест будет использовать TCP клиент,который посылает команды на наш сервер и утверждает,что мы получаем желаемые ответы.</target>
        </trans-unit>
        <trans-unit id="95fe1b352417a55c924d64b21f5c78849cba47c1" translate="yes" xml:space="preserve">
          <source>Our requirements are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">Наши требования (см. &lt;code&gt;elixir -v&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="535edfb81d4d7fba2950c82c04bae85d9dfbc680" translate="yes" xml:space="preserve">
          <source>Our server functionality is almost complete. Only tests are missing. This time, we have left tests for last because there are some important considerations to be made.</source>
          <target state="translated">Функциональность нашего сервера практически завершена.Пропущены только тесты.На этот раз мы оставили тесты на последний раз,потому что есть некоторые важные соображения,которые должны быть сделаны.</target>
        </trans-unit>
        <trans-unit id="0dd5b4064e68f8312097cf4592e8701596b6f591" translate="yes" xml:space="preserve">
          <source>Our supervisor has a single child so far: &lt;code&gt;KV.Registry&lt;/code&gt;. After we define a list of children, we call &lt;code&gt;Supervisor.init/2&lt;/code&gt;, passing the children and the supervision strategy.</source>
          <target state="translated">У нашего супервайзера пока единственный ребенок: &lt;code&gt;KV.Registry&lt;/code&gt; . После определения списка детей мы вызываем &lt;code&gt;Supervisor.init/2&lt;/code&gt; , передавая детей и стратегию наблюдения.</target>
        </trans-unit>
        <trans-unit id="26dc3ca3dc381ac59a2d936b2680d93266f92db5" translate="yes" xml:space="preserve">
          <source>Our test case first asserts there&amp;rsquo;s no buckets in our registry, creates a named bucket, looks it up, and asserts it behaves as a bucket.</source>
          <target state="translated">Наш тестовый пример сначала утверждает, что в нашем реестре нет сегментов, создает именованный сегмент, просматривает его и утверждает, что он ведет себя как сегмент.</target>
        </trans-unit>
        <trans-unit id="e4223734c95ebae3d84c8793615e9933ad56a2e5" translate="yes" xml:space="preserve">
          <source>Our test uses the &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; function to retrieve the child specification out of a module and then assert its restart value is &lt;code&gt;:temporary&lt;/code&gt;. At this point, you may be wondering why use a supervisor if it never restarts its children. It happens that supervisors provide more than restarts, they are also responsible for guaranteeing proper startup and shutdown, especially in case of crashes in a supervision tree.</source>
          <target state="translated">В нашем тесте используется функция &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; для извлечения дочерней спецификации из модуля и затем утверждения, что его значение перезапуска &lt;code&gt;:temporary&lt;/code&gt; . На этом этапе вам может быть интересно, зачем использовать супервизор, если он никогда не перезапускает своих дочерних элементов. Бывает, что супервизоры предоставляют больше, чем просто перезапуск, они также несут ответственность за обеспечение правильного запуска и завершения работы, особенно в случае сбоев в дереве надзора.</target>
        </trans-unit>
        <trans-unit id="281569899b0bc371294904a4302b498cefdffdc9" translate="yes" xml:space="preserve">
          <source>Our tests should now (always) pass!</source>
          <target state="translated">Наши тесты теперь (всегда)должны пройти!</target>
        </trans-unit>
        <trans-unit id="dd930034e08621d48c502a8e5b49b585b03bd10c" translate="yes" xml:space="preserve">
          <source>Our tour of our bitstrings, binaries, and strings is nearly complete, but we have one more data type to explain: the charlist.</source>
          <target state="translated">Наш тур по нашим бит-стрингам,двоичным файлам и строкам почти закончен,но у нас есть ещё один тип данных,который можно объяснить:charlist.</target>
        </trans-unit>
        <trans-unit id="9355be26c14e0bdd29f4d7a6d45fdd30c549218b" translate="yes" xml:space="preserve">
          <source>Outdated functions for building child specifications.</source>
          <target state="translated">Устаревшие функции для построения спецификаций для детей.</target>
        </trans-unit>
        <trans-unit id="5df6c70d9444e37439ecf0bf6ba4e2daf5ce369f" translate="yes" xml:space="preserve">
          <source>Over the course of this section, we will explore many Elixir syntax constructs alongside their AST representations.</source>
          <target state="translated">В этом разделе мы рассмотрим многие синтаксические конструкции Elixir наряду с их представлениями AST.</target>
        </trans-unit>
        <trans-unit id="68809f406eda501cceb8a0a76b54d32562163e04" translate="yes" xml:space="preserve">
          <source>Over the next section, we will explore many of Elixir syntax constructs alongside their AST representation.</source>
          <target state="translated">В следующем разделе мы рассмотрим многие синтаксические конструкции Elixir наряду с их представлением AST.</target>
        </trans-unit>
        <trans-unit id="746205fc2b470e87484b958a27628c930425ad5e" translate="yes" xml:space="preserve">
          <source>Overall, the child specification can be one of the following:</source>
          <target state="translated">В целом,спецификация ребенка может быть одной из следующих:</target>
        </trans-unit>
        <trans-unit id="13623c607be82141b2d26706e3445ad9261b3cc0" translate="yes" xml:space="preserve">
          <source>Overall, there are many steps, complexities and assumptions made during hot code upgrades, which is ultimately why they are not provided by Elixir out of the box. However, hot code upgrades can still be achieved by teams who desire to implement those steps on top of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; in their projects or as separate libraries.</source>
          <target state="translated">В целом, существует множество шагов, сложностей и предположений, сделанных во время обновления горячего кода, поэтому в конечном итоге они не предоставляются Elixir из коробки. Тем не менее, горячие обновления кода по-прежнему могут быть выполнены командами, которые хотят реализовать эти шаги поверх &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; в своих проектах или в виде отдельных библиотек.</target>
        </trans-unit>
        <trans-unit id="30f888d222b77006610001ff65a62036e76c8b9f" translate="yes" xml:space="preserve">
          <source>Overlays</source>
          <target state="translated">Overlays</target>
        </trans-unit>
        <trans-unit id="c2d12ad6c158fff98834c1728a418fadd8e620d7" translate="yes" xml:space="preserve">
          <source>Overlined.</source>
          <target state="translated">Overlined.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="4678bc356cc17efccf9b8f5a4945bc7564b32a23" translate="yes" xml:space="preserve">
          <source>Parens and no parens in function calls</source>
          <target state="translated">Парни и не парни в вызовах функций</target>
        </trans-unit>
        <trans-unit id="3e3d2061650e6bfafddfcb21f5627e4ae2f724ca" translate="yes" xml:space="preserve">
          <source>Parentheses are important to support multiple expressions. This:</source>
          <target state="translated">Круглые скобки важны для поддержки множественных выражений.Это:</target>
        </trans-unit>
        <trans-unit id="67051571e99ef0293cfd4d98dce041f6d2d0079b" translate="yes" xml:space="preserve">
          <source>Parentheses for non-qualified calls are optional, except for zero-arity calls, which would then be ambiguous with variables. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;. For example, &lt;code&gt;add (1, 2)&lt;/code&gt; is a syntax error, since &lt;code&gt;(1, 2)&lt;/code&gt; is treated as an invalid block which is attempted to be given as a single argument to &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">Скобки для неквалифицированных вызовов необязательны, за исключением вызовов с нулевой арностью, которые в этом случае могут быть неоднозначными с переменными. Если используются круглые скобки, они должны следовать сразу за именем функции &lt;em&gt;без пробелов&lt;/em&gt; . Например, &lt;code&gt;add (1, 2)&lt;/code&gt; является синтаксической ошибкой, поскольку &lt;code&gt;(1, 2)&lt;/code&gt; обрабатывается как недопустимый блок, который пытаются передать как единственный аргумент для &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaccd27612cf8e4c36fdcb2e213e4f30e8b614a2" translate="yes" xml:space="preserve">
          <source>Parentheses for qualified calls are optional. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;.</source>
          <target state="translated">Скобки для квалифицированных вызовов необязательны. Если используются круглые скобки, они должны следовать сразу за именем функции &lt;em&gt;без пробелов&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5051b701bae8cfb193958fe123047596e7c8c957" translate="yes" xml:space="preserve">
          <source>Parenthesised arguments after the anonymous function indicate that we want the function to be evaluated, not just its definition returned. Note that a dot (&lt;code&gt;.&lt;/code&gt;) between the variable and parentheses is required to invoke an anonymous function. The dot ensures there is no ambiguity between calling the anonymous function matched to a variable &lt;code&gt;add&lt;/code&gt; and a named function &lt;code&gt;add/2&lt;/code&gt;. We will explore named functions when dealing with &lt;a href=&quot;modules-and-functions&quot;&gt;Modules and Functions&lt;/a&gt;, since named functions can only be defined within a module. For now, just remember that Elixir makes a clear distinction between anonymous functions and named functions.</source>
          <target state="translated">Аргументы в скобках после анонимной функции показывают, что мы хотим, чтобы функция оценивалась, а не только возвращалось ее определение. Обратите внимание, что для вызова анонимной функции требуется точка ( &lt;code&gt;.&lt;/code&gt; ) Между переменной и круглыми скобками. Точка гарантирует отсутствие двусмысленности между вызовом анонимной функции, соответствующей переменной &lt;code&gt;add&lt;/code&gt; , и именованной функции &lt;code&gt;add/2&lt;/code&gt; . Мы будем исследовать именованные функции при работе с &lt;a href=&quot;modules-and-functions&quot;&gt;модулями и функциями&lt;/a&gt; , поскольку именованные функции могут быть определены только внутри модуля. На данный момент просто помните, что Elixir четко различает анонимные функции и именованные функции.</target>
        </trans-unit>
        <trans-unit id="c6e0c54097c1addd54979adc1a31105e2aaa679a" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;argv&lt;/code&gt; into a keyword list.</source>
          <target state="translated">Преобразует &lt;code&gt;argv&lt;/code&gt; в список ключевых слов.</target>
        </trans-unit>
        <trans-unit id="b2037b766a0218a36e31bca7df8250924234fc50" translate="yes" xml:space="preserve">
          <source>Parses a UTC datetime string.</source>
          <target state="translated">Разбирает UTC строку даты.</target>
        </trans-unit>
        <trans-unit id="7a373d2047627c546c74f485fe9ab21c42c1df91" translate="yes" xml:space="preserve">
          <source>Parses a binary into a float.</source>
          <target state="translated">Разбивает двоичный файл на плавучий.</target>
        </trans-unit>
        <trans-unit id="4e1561f231d7c4a89caf62da9c6db3000588afc3" translate="yes" xml:space="preserve">
          <source>Parses a date string.</source>
          <target state="translated">Разбирает строку даты.</target>
        </trans-unit>
        <trans-unit id="6802e6f6d63cb578d3a12f5a6a70ff5a85e6ff68" translate="yes" xml:space="preserve">
          <source>Parses a naive datetime string.</source>
          <target state="translated">Разбирает наивную строку даты.</target>
        </trans-unit>
        <trans-unit id="9e7e6f51d7020e3f9b0b2f42aa838f86dc50638c" translate="yes" xml:space="preserve">
          <source>Parses a text representation of an integer.</source>
          <target state="translated">Разбирает текстовое представление целого числа.</target>
        </trans-unit>
        <trans-unit id="22b615713c9b3099aeebc79b91026e9ad53274f2" translate="yes" xml:space="preserve">
          <source>Parses a time string.</source>
          <target state="translated">Разбирает временную строку.</target>
        </trans-unit>
        <trans-unit id="6b888a6d93a31ed5b9a23109d66831029d658dad" translate="yes" xml:space="preserve">
          <source>Parses a version requirement string into a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.Requirement.html&quot;&gt;&lt;code&gt;Version.Requirement&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Анализирует строку требований к версии в структуру &lt;a href=&quot;https://hexdocs.pm/elixir/Version.Requirement.html&quot;&gt; &lt;code&gt;Version.Requirement&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1305b49b9db63d6a1fa5dcb852df3de639b5f930" translate="yes" xml:space="preserve">
          <source>Parses a version requirement string into a &lt;a href=&quot;version.requirement&quot;&gt;&lt;code&gt;Version.Requirement&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Анализирует строку требований к версии в структуру &lt;a href=&quot;version.requirement&quot;&gt; &lt;code&gt;Version.Requirement&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6e9a74770159628fab2a719bf1edd0a31ffec3a" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Анализирует строку &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; структуре Version .</target>
        </trans-unit>
        <trans-unit id="fe3857b9469595509888a047a6bc4d80e1165c97" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Преобразует строку версии в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9418b6ddc34fc34c1a8273ea4a0f4abcb6241047" translate="yes" xml:space="preserve">
          <source>Parses a well-formed URI reference into its components.</source>
          <target state="translated">Разбирает хорошо сформированную ссылку URI на его компоненты.</target>
        </trans-unit>
        <trans-unit id="686ba7b9fd41ec3d8f6bc66004e216b5e44cf683" translate="yes" xml:space="preserve">
          <source>Parses filters out of a path.</source>
          <target state="translated">Парсес отфильтровывает путь.</target>
        </trans-unit>
        <trans-unit id="79bbadda560fc2696985637c3dcd5d5d75b852e1" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Date and time of day&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">Анализирует расширенный формат &amp;laquo;Дата и время дня&amp;raquo;, описанный в &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601: 2004&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dea4a820a2ed56415d65f399d0de1e2f38a6464c" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Dates&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">Анализирует расширенный формат &amp;laquo;Даты&amp;raquo;, описанный в &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601: 2004&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c980fd66c48ae19c95734093b045d1485842675" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Local time&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">Анализирует расширенный формат &amp;laquo;Местное время&amp;raquo;, описанный в &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601: 2004&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efff6c3f2bc39a4e56110039d1eb0a786e002449" translate="yes" xml:space="preserve">
          <source>Parses the given filters, as one would receive from the command line.</source>
          <target state="translated">Анализирует данные фильтры,как это делается в командной строке.</target>
        </trans-unit>
        <trans-unit id="892eaf14a29daaf63957591cf27bb62e4caabbd0" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a date returned by &lt;a href=&quot;#c:date_to_string/3&quot;&gt;&lt;code&gt;date_to_string/3&lt;/code&gt;&lt;/a&gt; into a date-tuple.</source>
          <target state="translated">Анализирует строковое представление даты, возвращаемой &lt;a href=&quot;#c:date_to_string/3&quot;&gt; &lt;code&gt;date_to_string/3&lt;/code&gt; ,&lt;/a&gt; в кортеж даты.</target>
        </trans-unit>
        <trans-unit id="4b4e3c1faebbc8667d93f77a51121878e06bc6a9" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a datetime returned by &lt;a href=&quot;#c:datetime_to_string/11&quot;&gt;&lt;code&gt;datetime_to_string/11&lt;/code&gt;&lt;/a&gt; into a datetime-tuple.</source>
          <target state="translated">Анализирует строковое представление даты и времени, возвращаемой &lt;a href=&quot;#c:datetime_to_string/11&quot;&gt; &lt;code&gt;datetime_to_string/11&lt;/code&gt; &lt;/a&gt; в кортеж даты и времени.</target>
        </trans-unit>
        <trans-unit id="4fab8e44f873693695decedf8d84e5501e79169f" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a naive datetime returned by &lt;a href=&quot;#c:naive_datetime_to_string/7&quot;&gt;&lt;code&gt;naive_datetime_to_string/7&lt;/code&gt;&lt;/a&gt; into a naive-datetime-tuple.</source>
          <target state="translated">Разбирает строковое представление наивного datetime, возвращаемого &lt;a href=&quot;#c:naive_datetime_to_string/7&quot;&gt; &lt;code&gt;naive_datetime_to_string/7&lt;/code&gt; ,&lt;/a&gt; в наивный-datetime-tuple.</target>
        </trans-unit>
        <trans-unit id="001eefa6a8d8771c20892e67001091ddcc53e435" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a time returned by &lt;a href=&quot;#c:time_to_string/4&quot;&gt;&lt;code&gt;time_to_string/4&lt;/code&gt;&lt;/a&gt; into a time-tuple.</source>
          <target state="translated">Разбирает строковое представление для времени, возвращаемого &lt;a href=&quot;#c:time_to_string/4&quot;&gt; &lt;code&gt;time_to_string/4&lt;/code&gt; ,&lt;/a&gt; в кортеж времени.</target>
        </trans-unit>
        <trans-unit id="4a7afa8fbef89e323ac662c4af9fe0a43a7660ee" translate="yes" xml:space="preserve">
          <source>Parsing unknown switches</source>
          <target state="translated">Разбор неизвестных переключателей</target>
        </trans-unit>
        <trans-unit id="058a972530d049d8d1939ad7fe7fdd2aa895b37b" translate="yes" xml:space="preserve">
          <source>Passed (also represented by &lt;code&gt;nil&lt;/code&gt;)</source>
          <target state="translated">Пройден (также обозначается &lt;code&gt;nil&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="882a18ee47ec2d79a2be50dc7a03c9a397028b1f" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;:insert_replaced&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#replace/4&quot;&gt;&lt;code&gt;String.replace/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Передача &lt;code&gt;:insert_replaced&lt;/code&gt; в &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#replace/4&quot;&gt; &lt;code&gt;String.replace/4&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c66f210cd28e106c39212344286cce106c8d0d7" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;:insert_replaced&lt;/code&gt; to &lt;a href=&quot;string#replace/4&quot;&gt;&lt;code&gt;String.replace/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Передача &lt;code&gt;:insert_replaced&lt;/code&gt; в &lt;a href=&quot;string#replace/4&quot;&gt; &lt;code&gt;String.replace/4&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89a8204a98999b2bee00cea4fbc5d899e83daf17" translate="yes" xml:space="preserve">
          <source>Passing a &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; automatically converts it to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, discarding the time zone information:</source>
          <target state="translated">Передача &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; автоматически преобразует его в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; , отбрасывая информацию о часовом поясе:</target>
        </trans-unit>
        <trans-unit id="dcab25bbe23a69b39dd307ea8cbb6e91f311b31b" translate="yes" xml:space="preserve">
          <source>Passing a &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; automatically converts it to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, discarding the time zone information:</source>
          <target state="translated">Передача &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; автоматически преобразует его в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; , отбрасывая информацию о часовом поясе:</target>
        </trans-unit>
        <trans-unit id="4b3cf5e91c7ff130bc822fb2e1808168e930f058" translate="yes" xml:space="preserve">
          <source>Passing a data type that doesn&amp;rsquo;t implement the protocol raises an error:</source>
          <target state="translated">Передача типа данных, который не реализует протокол, вызывает ошибку:</target>
        </trans-unit>
        <trans-unit id="f791e277d4e887df822880f6ea245d3e768dd518" translate="yes" xml:space="preserve">
          <source>Passing a list of strings as &lt;code&gt;padding&lt;/code&gt; will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string &lt;code&gt;padding&lt;/code&gt; is equivalent to passing the list of graphemes in it. If no &lt;code&gt;padding&lt;/code&gt; is given, it defaults to whitespace.</source>
          <target state="translated">Передача списка строк в качестве &lt;code&gt;padding&lt;/code&gt; займет один элемент списка для каждой отсутствующей записи. Если список короче, чем количество вставок, заполнение начнется заново с начала списка. Передача строкового &lt;code&gt;padding&lt;/code&gt; эквивалентна передаче в нем списка графем. Если &lt;code&gt;padding&lt;/code&gt; не задано, по умолчанию используется пробел.</target>
        </trans-unit>
        <trans-unit id="5e3fd8ecb92634cc65268b6d4476c69ed28e51d4" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Передача непустого списка в &lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32def6a06615a71c67376a3230bf64c2a28b2da1" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Передача непустого списка в &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab4dc6f7d4a4079d2fdd62825de517a50ea365e8" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;code&gt;:into&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Передача непустого списка в &lt;code&gt;:into&lt;/code&gt; в &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc442b60927fa3cedca5b49645dcda347c68d43b" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;code&gt;:into&lt;/code&gt; in &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">Передача непустого списка в &lt;code&gt;:into&lt;/code&gt; в &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0e56540195473b76b76bc99aa7381097cd9285" translate="yes" xml:space="preserve">
          <source>Passing a string that does not represent an integer leads to an error:</source>
          <target state="translated">Передача строки,не представляющей собой целое число,приводит к ошибке:</target>
        </trans-unit>
        <trans-unit id="acb63ddcebf2320404185b69bfeb6451c7f0ec89" translate="yes" xml:space="preserve">
          <source>Passing non-chardata to &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#log/2&quot;&gt;&lt;code&gt;Logger.log/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Передача не-chardata в &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#log/2&quot;&gt; &lt;code&gt;Logger.log/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd3e8286d4953766dd3b3f6ceafaf9431e925e06" translate="yes" xml:space="preserve">
          <source>Pasting multiline expressions into IEx</source>
          <target state="translated">Вставка многострочных выражений в IEx</target>
        </trans-unit>
        <trans-unit id="91b58c214080204a7a5e383388a515d0a4b74b02" translate="yes" xml:space="preserve">
          <source>Patch segments are compared lexicographically if they are alphanumeric, and numerically otherwise.</source>
          <target state="translated">Сегменты патчей сравниваются лексикографически,если они буквенно-цифровые,и численно иначе.</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c0c3abe147a53151f7b15d4fc13e0b6734b3694d" translate="yes" xml:space="preserve">
          <source>Path and in umbrella dependencies are automatically recompiled by the parent project whenever they change. While fetchable dependencies, like the ones using &lt;code&gt;:git&lt;/code&gt;, are recompiled only when fetched/updated.</source>
          <target state="translated">Зависимости пути и зонтика автоматически перекомпилируются родительским проектом при изменении. В то время как извлекаемые зависимости, такие как те, что используют &lt;code&gt;:git&lt;/code&gt; , перекомпилируются только при извлечении / обновлении.</target>
        </trans-unit>
        <trans-unit id="8ed7d3defaf72b508bfd8cf537c7e823fe6bd6aa" translate="yes" xml:space="preserve">
          <source>Path options (&lt;code&gt;:path&lt;/code&gt;)</source>
          <target state="translated">Параметры пути ( &lt;code&gt;:path&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="13e7e11722f7d8309c367ea7823bd6cd32011ced" translate="yes" xml:space="preserve">
          <source>Paths</source>
          <target state="translated">Paths</target>
        </trans-unit>
        <trans-unit id="ab86e3764103c0dcee9253b7a3012684d2a9d25d" translate="yes" xml:space="preserve">
          <source>Paths given to functions in this module can be either relative to the current working directory (as returned by &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt;), or absolute paths. Shell conventions like &lt;code&gt;~&lt;/code&gt; are not expanded automatically. To use paths like &lt;code&gt;~/Downloads&lt;/code&gt;, you can use &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/2&quot;&gt;&lt;code&gt;Path.expand/2&lt;/code&gt;&lt;/a&gt; to expand your path to an absolute path.</source>
          <target state="translated">Пути, заданные функциям в этом модуле, могут быть относительными к текущему рабочему каталогу (возвращаемому &lt;a href=&quot;#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt; ) или абсолютными путями. Условные обозначения оболочки, такие как &lt;code&gt;~&lt;/code&gt; , не расширяются автоматически. Чтобы использовать такие пути, как &lt;code&gt;~/Downloads&lt;/code&gt; , вы можете использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/2&quot;&gt; &lt;code&gt;Path.expand/2&lt;/code&gt; ,&lt;/a&gt; чтобы расширить свой путь до абсолютного пути.</target>
        </trans-unit>
        <trans-unit id="d5e92258ff6b2634e28eb6ffcaf62f5681cd01e9" translate="yes" xml:space="preserve">
          <source>Paths given to functions in this module can be either relative to the current working directory (as returned by &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt;), or absolute paths. Shell conventions like &lt;code&gt;~&lt;/code&gt; are not expanded automatically. To use paths like &lt;code&gt;~/Downloads&lt;/code&gt;, you can use &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;path#expand/2&quot;&gt;&lt;code&gt;Path.expand/2&lt;/code&gt;&lt;/a&gt; to expand your path to an absolute path.</source>
          <target state="translated">Пути, заданные функциям в этом модуле, могут быть относительными к текущему рабочему каталогу (возвращенному &lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt; ) или абсолютными путями. Условные обозначения оболочки, такие как &lt;code&gt;~&lt;/code&gt; , не расширяются автоматически. Чтобы использовать такие пути, как &lt;code&gt;~/Downloads&lt;/code&gt; , вы можете использовать &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;path#expand/2&quot;&gt; &lt;code&gt;Path.expand/2&lt;/code&gt; ,&lt;/a&gt; чтобы расширить свой путь до абсолютного пути.</target>
        </trans-unit>
        <trans-unit id="ec64f6b78a78d3e0e77305e0657675859b2e9902" translate="yes" xml:space="preserve">
          <source>Pattern match on &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt;&lt;code&gt;_.._&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt; &lt;code&gt;_.._&lt;/code&gt; &lt;/a&gt; шаблону на _.._ (v1.0)</target>
        </trans-unit>
        <trans-unit id="1e99640fa7e7a52ff09113ed1f71e7b10259e02c" translate="yes" xml:space="preserve">
          <source>Pattern match on &lt;code&gt;_.._&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;_.._&lt;/code&gt; шаблону на _.._ (v1.0)</target>
        </trans-unit>
        <trans-unit id="4a4ff6f40515d80959eb2891b1a4f521722adb61" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
          <target state="translated">Совпадение с образцом</target>
        </trans-unit>
        <trans-unit id="762812440ca2ae94a95f89714b7b124251968b01" translate="yes" xml:space="preserve">
          <source>Pattern matching allows developers to easily destructure data types such as tuples and lists. As we will see in the following chapters, it is one of the foundations of recursion in Elixir and applies to other types as well, like maps and binaries.</source>
          <target state="translated">Сопоставление с образцами позволяет разработчикам легко разрушать такие типы данных,как кортежи и списки.Как мы увидим в следующих главах,это одна из основ рекурсии в Elixir и применяется и к другим типам,таким как карты и двоичные файлы.</target>
        </trans-unit>
        <trans-unit id="fdff00e56a789a8726c9da949b09dd98bd5ff2f6" translate="yes" xml:space="preserve">
          <source>Pattern matching on struct names</source>
          <target state="translated">Сопоставление схем по названиям структур</target>
        </trans-unit>
        <trans-unit id="2a4de85389e0a217d14b9f1582fdf6651995191b" translate="yes" xml:space="preserve">
          <source>Pattern matching.</source>
          <target state="translated">Совпадение образов.</target>
        </trans-unit>
        <trans-unit id="d6028e13dbd229af93277e237b2c16fbf94be2cb" translate="yes" xml:space="preserve">
          <source>Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison.</source>
          <target state="translated">Шаблон должен быть атомом или кортежем, который будет соответствовать структуре значения, хранящегося в реестре. Атом &lt;code&gt;:_&lt;/code&gt; можно использовать для игнорирования данного значения или элемента кортежа, а атом &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; можно использовать для временного присвоения части шаблона переменной для последующего сравнения.</target>
        </trans-unit>
        <trans-unit id="5137df8a74cffc5ca199358452463a9c6bfb9074" translate="yes" xml:space="preserve">
          <source>Pattern used in functions like &lt;a href=&quot;#replace/3&quot;&gt;&lt;code&gt;replace/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#split/2&quot;&gt;&lt;code&gt;split/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Шаблон, используемый в таких функциях, как &lt;a href=&quot;#replace/3&quot;&gt; &lt;code&gt;replace/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#split/2&quot;&gt; &lt;code&gt;split/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="152c399b42d0887a104c4b86c4c12a82f3f47730" translate="yes" xml:space="preserve">
          <source>Pattern used in functions like &lt;a href=&quot;#replace/4&quot;&gt;&lt;code&gt;replace/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;split/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Шаблон, используемый в таких функциях, как &lt;a href=&quot;#replace/4&quot;&gt; &lt;code&gt;replace/4&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#split/3&quot;&gt; &lt;code&gt;split/3&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="7fb0897a2aed04de147811e0b885403806796d4f" translate="yes" xml:space="preserve">
          <source>Patterns and Guards</source>
          <target state="translated">Узоры и охрана</target>
        </trans-unit>
        <trans-unit id="d8f5c8436b5f5097fc1e0b09aadfb6092ac6af0f" translate="yes" xml:space="preserve">
          <source>Patterns and guards</source>
          <target state="translated">Узоры и охранники</target>
        </trans-unit>
        <trans-unit id="baf8b0aa8fb4b54076ac712a4dbf108691e81606" translate="yes" xml:space="preserve">
          <source>Patterns are not bidirectional. If you have a variable &lt;code&gt;y&lt;/code&gt; that was never assigned to (often called an unbound variable) and you write &lt;code&gt;1 = y&lt;/code&gt;, an error will be raised:</source>
          <target state="translated">Шаблоны не являются двунаправленными. Если у вас есть переменная &lt;code&gt;y&lt;/code&gt; , которая никогда не была назначена (часто называемая несвязанной переменной), и вы пишете &lt;code&gt;1 = y&lt;/code&gt; , возникает ошибка:</target>
        </trans-unit>
        <trans-unit id="3b9d994ed3cc433e46c8856ab6068dddc28124e9" translate="yes" xml:space="preserve">
          <source>Patterns in Elixir are made of variables, literals, and data-structure specific syntax. One of the most used constructs to perform pattern matching is the match operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Шаблоны в Elixir состоят из переменных, литералов и синтаксиса, специфичного для структуры данных. Одна из наиболее часто используемых конструкций для сопоставления с образцом - оператор сопоставления ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt; &lt;code&gt;=&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="5c540b06ef6678db51d87771fe4d3939cf8a2687" translate="yes" xml:space="preserve">
          <source>Percent-escapes all characters that require escaping in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Процентное экранирование всех символов в &lt;code&gt;string&lt;/code&gt; , требующих экранирования .</target>
        </trans-unit>
        <trans-unit id="0c2d8594907eb7e308e53ec4869ee6591cd32868" translate="yes" xml:space="preserve">
          <source>Percent-unescapes a URI.</source>
          <target state="translated">Процентный анализ УРТ.</target>
        </trans-unit>
        <trans-unit id="e179944907d404a0c32e7b8b6d4faf26105d3528" translate="yes" xml:space="preserve">
          <source>Performance &amp;amp; Optimizations</source>
          <target state="translated">Производительность и оптимизация</target>
        </trans-unit>
        <trans-unit id="c275fdf2e3e600505a75a54526cffcdd6b781bbb" translate="yes" xml:space="preserve">
          <source>Performs a cast (&lt;em&gt;fire and forget&lt;/em&gt;) operation on the agent state.</source>
          <target state="translated">Выполняет операцию приведения ( &lt;em&gt;выстрелил и забыл&lt;/em&gt; ) в состоянии агента.</target>
        </trans-unit>
        <trans-unit id="2dda6078e429a5da67f4d4b2be41fa1f081b1311" translate="yes" xml:space="preserve">
          <source>Performs a depth-first traversal of quoted expressions using an accumulator.</source>
          <target state="translated">Выполняет первый глубокий обход цитируемых выражений с помощью аккумулятора.</target>
        </trans-unit>
        <trans-unit id="4785eea6c091478238fb008cdd410304fdd8d0f0" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">Выполняет глубинный,постордерный обход цитируемых выражений с помощью аккумулятора.</target>
        </trans-unit>
        <trans-unit id="32814ff09b644963df4e222c005f1c731fb50119" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions.</source>
          <target state="translated">Выполняет глубинный,постордерный обход цитируемых выражений.</target>
        </trans-unit>
        <trans-unit id="7b7923e80f9004780986d78cff2f797fee5928bf" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">Выполняет глубинный,предзаказной обход котируемых выражений с помощью аккумулятора.</target>
        </trans-unit>
        <trans-unit id="53d43f5532c10b67e765cd88c0ddb300fe2d8aba" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions.</source>
          <target state="translated">Выполняет глубинный,предзаказной обход кавычек выражений.</target>
        </trans-unit>
        <trans-unit id="039534a957eec2fa34791db81532382c587d8245" translate="yes" xml:space="preserve">
          <source>Performs a floored integer division.</source>
          <target state="translated">Выполняет целочисленное деление с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="458261426d9d27cb74c83066a9b390fab831f47c" translate="yes" xml:space="preserve">
          <source>Performs an integer division.</source>
          <target state="translated">Выполняет целочисленное деление.</target>
        </trans-unit>
        <trans-unit id="d5fa7b7265385a6a4338c08984b01ec783651ffb" translate="yes" xml:space="preserve">
          <source>Performs cross reference checks between modules.</source>
          <target state="translated">Выполняет перекрестные проверки между модулями.</target>
        </trans-unit>
        <trans-unit id="11854d0712971b76c41b6ad9d5a606d865ee7453" translate="yes" xml:space="preserve">
          <source>Performs remote dispatch checking.</source>
          <target state="translated">Выполняет дистанционную диспетчерскую проверку.</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="35f1c5990cc168fdf4f91ba17d0cf4c3bd708a54" translate="yes" xml:space="preserve">
          <source>Persists the given configuration by modifying the configured applications environment.</source>
          <target state="translated">Перенаправляет данную конфигурацию путем изменения настроенной среды приложений.</target>
        </trans-unit>
        <trans-unit id="1299c5da4d36f7c6543acebafdc41ccf1b565939" translate="yes" xml:space="preserve">
          <source>Phases</source>
          <target state="translated">Phases</target>
        </trans-unit>
        <trans-unit id="a6c6db8bc84509e69b9d23d41b0e1fc7fcdce78a" translate="yes" xml:space="preserve">
          <source>Pin operator. Accesses an already bound variable in match clauses.</source>
          <target state="translated">Пин-оператор.Обращается к уже связанной переменной в клаузулах соответствия.</target>
        </trans-unit>
        <trans-unit id="0b7522b2ee55a89f041eb7221911aa0a0e32f37f" translate="yes" xml:space="preserve">
          <source>Pipe operator.</source>
          <target state="translated">Трубник.</target>
        </trans-unit>
        <trans-unit id="3854cbad98a94ad36b9fbd34a9d7759251a83644" translate="yes" xml:space="preserve">
          <source>Pipes &lt;code&gt;expr&lt;/code&gt; into the &lt;code&gt;call_args&lt;/code&gt; at the given &lt;code&gt;position&lt;/code&gt;.</source>
          <target state="translated">Передает &lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;call_args&lt;/code&gt; в заданной &lt;code&gt;position&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ef57d28e73677c96993fd2b8445c1eec249cdff" translate="yes" xml:space="preserve">
          <source>Pitfalls</source>
          <target state="translated">Pitfalls</target>
        </trans-unit>
        <trans-unit id="e5a7b226404fec963975ee16c6feacd0bed5537d" translate="yes" xml:space="preserve">
          <source>Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause.</source>
          <target state="translated">Поместите документацию перед первым пунктом о функциях с несколькими пунктами.Документация всегда касается функции и arity,а не пункта.</target>
        </trans-unit>
        <trans-unit id="225a7f9c31a9e433302718633fe4e93f7a51a743" translate="yes" xml:space="preserve">
          <source>Please note that all the modules defined in the same file as &lt;code&gt;module&lt;/code&gt; are recompiled and reloaded.</source>
          <target state="translated">Обратите внимание, что все модули, определенные в том же файле, что и &lt;code&gt;module&lt;/code&gt; , перекомпилируются и перезагружаются.</target>
        </trans-unit>
        <trans-unit id="39c9a395b7a75f7f91d5c9d082bddd97314589a3" translate="yes" xml:space="preserve">
          <source>Please note that by doing this, we are breaking the boilerplate test case which tested the &lt;code&gt;hello&lt;/code&gt; function in &lt;code&gt;KV&lt;/code&gt;. You can simply remove that test case.</source>
          <target state="translated">Обратите внимание, что тем самым мы нарушаем шаблонный тестовый пример, который тестировал функцию &lt;code&gt;hello&lt;/code&gt; в &lt;code&gt;KV&lt;/code&gt; . Вы можете просто удалить этот тестовый пример.</target>
        </trans-unit>
        <trans-unit id="5389d292ea210e333906a47db99429702756329e" translate="yes" xml:space="preserve">
          <source>Please note that some details like version numbers may differ a bit in your session; that&amp;rsquo;s not important. From now on &lt;code&gt;iex&lt;/code&gt; sessions will be stripped down to focus on the code. To exit &lt;code&gt;iex&lt;/code&gt; press &lt;code&gt;Ctrl+C&lt;/code&gt; twice.</source>
          <target state="translated">Обратите внимание, что некоторые детали, такие как номера версий, могут немного отличаться в вашем сеансе; это не важно. Отныне сеансы &lt;code&gt;iex&lt;/code&gt; будут сокращены, чтобы сосредоточиться на коде. Для выхода &lt;code&gt;iex&lt;/code&gt; нажмите &lt;code&gt;Ctrl+C&lt;/code&gt; дважды.</target>
        </trans-unit>
        <trans-unit id="cdcdcf740b9da96cd544682ab9e49f434e891d96" translate="yes" xml:space="preserve">
          <source>Please note the following functions for tuples are found in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Обратите внимание, что в &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; следующие функции для кортежей :</target>
        </trans-unit>
        <trans-unit id="d11ad5116bd8c797fe89a4d35824e7ca4c61f131" translate="yes" xml:space="preserve">
          <source>Please note the following functions for tuples are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Обратите внимание, что в &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; следующие функции для кортежей :</target>
        </trans-unit>
        <trans-unit id="3de0c7e157c52cc856a0f62d452060f6a5131f16" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;the GenServer module documentation&lt;/a&gt; for an overview if you haven&amp;rsquo;t yet. Once you do so, we are ready to proceed.</source>
          <target state="translated">Пожалуйста, прочтите &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;документацию модуля GenServer&lt;/a&gt; для обзора, если вы еще не сделали этого. Как только вы это сделаете, мы готовы продолжить.</target>
        </trans-unit>
        <trans-unit id="34c26932c8bdaaf11dbb3279895024633d9ddf5b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect/2&lt;/a&gt; to read more about other ways in which one could use this function. Also, in order to find a full list of other formatting options that one can use alongside &lt;code&gt;IO.inspect/2&lt;/code&gt;, see &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect / 2,&lt;/a&gt; чтобы узнать больше о других способах использования этой функции. Кроме того, чтобы найти полный список других параметров форматирования, которые можно использовать вместе с &lt;code&gt;IO.inspect/2&lt;/code&gt; , см. &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e45979c3d32e2c27b3aeac1606c58bb2e6186e8" translate="yes" xml:space="preserve">
          <source>Plugs into Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt;&lt;code&gt;:logger&lt;/code&gt;&lt;/a&gt; (from Erlang/OTP 21) to convert terms to Elixir syntax or wraps Erlang's &lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt;&lt;code&gt;:error_logger&lt;/code&gt;&lt;/a&gt; in earlier Erlang/OTP versions to prevent it from overflowing.</source>
          <target state="translated">Подключается к Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt; &lt;code&gt;:logger&lt;/code&gt; &lt;/a&gt; (из Erlang / OTP 21) для преобразования терминов в синтаксис Elixir или обертывает Erlang's &lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt; &lt;code&gt;:error_logger&lt;/code&gt; &lt;/a&gt; в более ранних версиях Erlang / OTP, чтобы предотвратить его переполнение.</target>
        </trans-unit>
        <trans-unit id="22f9e4899d5a9f9e7d7ac5fc03923347cf0dd256" translate="yes" xml:space="preserve">
          <source>Plus a number of functions for working with binaries (bytes) in the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;</source>
          <target state="translated">Плюс ряд функций для работы с двоичными файлами (байтами) в &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;модуле &lt;/a&gt; &lt;code&gt;:binary&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb9cf1418089b3356038fdd24fcbdc9d1a7c42a5" translate="yes" xml:space="preserve">
          <source>Policy</source>
          <target state="translated">Policy</target>
        </trans-unit>
        <trans-unit id="5b184d613e5dc77792a5b77d4c71d9a8f5805d12" translate="yes" xml:space="preserve">
          <source>Pops a key from the given nested structure.</source>
          <target state="translated">Выводит ключ из заданной вложенной структуры.</target>
        </trans-unit>
        <trans-unit id="f3dbd54145fe56b947320097710efe3fb212dea0" translate="yes" xml:space="preserve">
          <source>Pops a key from the nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Извлекает ключ из вложенной структуры по заданному &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="b33456701a07c78fe5d71eef1faf59492a293d96" translate="yes" xml:space="preserve">
          <source>Ports provide a mechanism to start operating system processes external to the Erlang VM and communicate with them via message passing.</source>
          <target state="translated">Порты обеспечивают механизм запуска процессов операционной системы,внешних по отношению к виртуальной машине Erlang,и связь с ними посредством передачи сообщений.</target>
        </trans-unit>
        <trans-unit id="49af11ce7ff963467dab9d145b8d28e88fbf86cb" translate="yes" xml:space="preserve">
          <source>Possible time zone periods for a certain time zone and wall clock date and time.</source>
          <target state="translated">Возможные периоды часового пояса для определенного часового пояса и даты и времени настенных часов.</target>
        </trans-unit>
        <trans-unit id="9af262a428ebb097a2a816a84db97bdefe0b3f35" translate="yes" xml:space="preserve">
          <source>Pre-releases are strictly less than their corresponding release versions.</source>
          <target state="translated">Предварительные релизы строго меньше их соответствующих версий.</target>
        </trans-unit>
        <trans-unit id="bda9c25c561aec987e1b78e68cb3669014cebe8e" translate="yes" xml:space="preserve">
          <source>Pre-releases are supported by optionally appending a hyphen and a series of period-separated identifiers immediately following the patch version. Identifiers consist of only ASCII alphanumeric characters and hyphens (&lt;code&gt;[0-9A-Za-z-]&lt;/code&gt;):</source>
          <target state="translated">Предварительные выпуски поддерживаются путем факультативного добавления дефиса и ряда идентификаторов, разделенных точками, сразу после версии исправления. Идентификаторы состоят только из буквенно-цифровых символов ASCII и дефисов ( &lt;code&gt;[0-9A-Za-z-]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="1d2dd642b809a9afa37c5b34ef9ccae95e253485" translate="yes" xml:space="preserve">
          <source>Precompilation</source>
          <target state="translated">Precompilation</target>
        </trans-unit>
        <trans-unit id="0b8da57c3b77645c7f2cae0807da41d055f68ad1" translate="yes" xml:space="preserve">
          <source>Prefer using &lt;a href=&quot;datetime#utc_now/0&quot;&gt;&lt;code&gt;DateTime.utc_now/0&lt;/code&gt;&lt;/a&gt; when possible as, opposite to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, it will keep the time zone information.</source>
          <target state="translated">По возможности предпочитайте использовать &lt;a href=&quot;datetime#utc_now/0&quot;&gt; &lt;code&gt;DateTime.utc_now/0&lt;/code&gt; ,&lt;/a&gt; поскольку, в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; от NaiveDateTime , он сохранит информацию о часовом поясе.</target>
        </trans-unit>
        <trans-unit id="1c8b2f7521e20b88ce608e018b5a7663333ca930" translate="yes" xml:space="preserve">
          <source>Prefer using &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/0&quot;&gt;&lt;code&gt;DateTime.utc_now/0&lt;/code&gt;&lt;/a&gt; when possible as, opposite to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, it will keep the time zone information.</source>
          <target state="translated">По возможности предпочитайте использовать &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/0&quot;&gt; &lt;code&gt;DateTime.utc_now/0&lt;/code&gt; ,&lt;/a&gt; поскольку, в &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; от NaiveDateTime , он сохранит информацию о часовом поясе.</target>
        </trans-unit>
        <trans-unit id="24a52cada612d997ea6ace1f1cca2bd40a581254" translate="yes" xml:space="preserve">
          <source>Preferred date (without time) representation</source>
          <target state="translated">Предпочтительная дата (без времени)представление</target>
        </trans-unit>
        <trans-unit id="523d7d1c8d156006cfdc5d6b7a6759d22cf010f1" translate="yes" xml:space="preserve">
          <source>Preferred date+time representation</source>
          <target state="translated">Предпочитаемое представление дата+время</target>
        </trans-unit>
        <trans-unit id="efc0bf801074207be31f8c48b25bd5b7b7ac758d" translate="yes" xml:space="preserve">
          <source>Preferred time (without date) representation</source>
          <target state="translated">Предпочтительное время (без даты)представительства</target>
        </trans-unit>
        <trans-unit id="193093334a57781999b3ba39585e6cbf824ef0f0" translate="yes" xml:space="preserve">
          <source>Prefix (unary) operator; calculates the bitwise NOT of its argument.</source>
          <target state="translated">Префиксный (унарный)оператор;вычисляет битовое NOT своего аргумента.</target>
        </trans-unit>
        <trans-unit id="eea84a143a5c43eba7121b69efd8599881cd4e88" translate="yes" xml:space="preserve">
          <source>Prepends a path to the beginning of the Erlang VM code path list.</source>
          <target state="translated">Подготавливает путь к началу списка путей к VM-коду Erlang.</target>
        </trans-unit>
        <trans-unit id="d43f430611481683290048b50760bd71f76a2c55" translate="yes" xml:space="preserve">
          <source>Prepends the given SCM module to the list of available SCMs.</source>
          <target state="translated">Готовит данный модуль SCM к списку доступных SCM.</target>
        </trans-unit>
        <trans-unit id="ad7544451a00457faefe5c90802b235432b07208" translate="yes" xml:space="preserve">
          <source>Pries into the process environment.</source>
          <target state="translated">Попадает в технологическую среду.</target>
        </trans-unit>
        <trans-unit id="c650d1681f475d556e0741952be9bdbed39b594a" translate="yes" xml:space="preserve">
          <source>Prints VM/runtime information such as versions, memory usage and statistics. Additional topics are available via &lt;a href=&quot;#runtime_info/1&quot;&gt;&lt;code&gt;runtime_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Печатает информацию о виртуальной машине и времени выполнения, такую ​​как версии, использование памяти и статистику. Дополнительные темы доступны через &lt;a href=&quot;#runtime_info/1&quot;&gt; &lt;code&gt;runtime_info/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2dbcf9bebb8d76fc78e7c60efbed06c652a712" translate="yes" xml:space="preserve">
          <source>Prints a file dependency graph where an edge from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt; indicates that &lt;code&gt;A&lt;/code&gt; (source) depends on &lt;code&gt;B&lt;/code&gt; (sink).</source>
          <target state="translated">Печатает граф зависимостей файлов, где ребро от &lt;code&gt;A&lt;/code&gt; до &lt;code&gt;B&lt;/code&gt; указывает, что &lt;code&gt;A&lt;/code&gt; (источник) зависит от &lt;code&gt;B&lt;/code&gt; (приемник).</target>
        </trans-unit>
        <trans-unit id="f89b78f661ed94f4f3264cf20d49cfe3b2271d25" translate="yes" xml:space="preserve">
          <source>Prints a list of all the functions and macros exported by the given module.</source>
          <target state="translated">Распечатывает список всех функций и макросов,экспортируемых данным модулем.</target>
        </trans-unit>
        <trans-unit id="21cf1dbac4d05fa2e897c927750d4ec851dfdfa6" translate="yes" xml:space="preserve">
          <source>Prints a list of the given directory's contents.</source>
          <target state="translated">Распечатывает список содержимого данной директории.</target>
        </trans-unit>
        <trans-unit id="816fa4a9573b3d1eade5973479c5d434df6932d3" translate="yes" xml:space="preserve">
          <source>Prints a message and asks the user if they want to proceed.</source>
          <target state="translated">Печатает сообщение и спрашивает пользователя,хочет ли он продолжить.</target>
        </trans-unit>
        <trans-unit id="e2ec3a4dfe86c240d136373ea35a884bf200c540" translate="yes" xml:space="preserve">
          <source>Prints a message and prompts the user for input.</source>
          <target state="translated">Печатает сообщение и предлагает пользователю ввести данные.</target>
        </trans-unit>
        <trans-unit id="ddd0491656e97dc3bcc73b8c0fac99539b89b38e" translate="yes" xml:space="preserve">
          <source>Prints all breakpoints to the terminal.</source>
          <target state="translated">Печатает все точки останова на терминал.</target>
        </trans-unit>
        <trans-unit id="d45ac7d4540637c6fdc232c2b99937de0319a5e3" translate="yes" xml:space="preserve">
          <source>Prints all callers of the given &lt;code&gt;CALLEE&lt;/code&gt;, which can be one of: &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Module.function&lt;/code&gt;, or &lt;code&gt;Module.function/arity&lt;/code&gt;. Examples:</source>
          <target state="translated">Печатает всех вызывающих абонентов данного &lt;code&gt;CALLEE&lt;/code&gt; , который может быть одним из: &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Module.function&lt;/code&gt; или &lt;code&gt;Module.function/arity&lt;/code&gt; . Примеры:</target>
        </trans-unit>
        <trans-unit id="809386d6073ab7bf681b254f1d8ce9b7df690096" translate="yes" xml:space="preserve">
          <source>Prints all callers of the given &lt;code&gt;MODULE&lt;/code&gt;. Example:</source>
          <target state="translated">Печатает всех абонентов данного &lt;code&gt;MODULE&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="fb7b5b8ff071f99cadfdd753b83a8dcfd047d61c" translate="yes" xml:space="preserve">
          <source>Prints all deprecated &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">Распечатывает все устаревшие записи &quot;file:line:module.function/arity&quot;:</target>
        </trans-unit>
        <trans-unit id="c1327228921868a454a53046edb632efd4b315a2" translate="yes" xml:space="preserve">
          <source>Prints all unreachable &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">Распечатывает все недоступные записи &quot;file:line:module.function/arity&quot;:</target>
        </trans-unit>
        <trans-unit id="b8f021dfa5efe59a9f253cec7d84c691f6f573bb" translate="yes" xml:space="preserve">
          <source>Prints cross reference information between modules.</source>
          <target state="translated">Печатает перекрестные ссылки на информацию между модулями.</target>
        </trans-unit>
        <trans-unit id="971f6a2d9c15e227f73c83c32352ffad4dff563e" translate="yes" xml:space="preserve">
          <source>Prints information about the data type of any given term.</source>
          <target state="translated">Печатает информацию о типе данных любого данного термина.</target>
        </trans-unit>
        <trans-unit id="c1fb53812afe31e50bbaad2c2a262be107aad858" translate="yes" xml:space="preserve">
          <source>Prints nothing to the shell.</source>
          <target state="translated">Ничего не печатает на оболочке.</target>
        </trans-unit>
        <trans-unit id="df10c0d38c5c33dd31ff77c2596b2889339e3e88" translate="yes" xml:space="preserve">
          <source>Prints the application tree.</source>
          <target state="translated">Распечатывает дерево приложений.</target>
        </trans-unit>
        <trans-unit id="3d707a33372771d97f7c17fb4637c172eed3bdd3" translate="yes" xml:space="preserve">
          <source>Prints the current application if it was not printed yet.</source>
          <target state="translated">Печатает текущее приложение,если оно еще не было распечатано.</target>
        </trans-unit>
        <trans-unit id="f8ad915e9dada2c1aa7c7f28d88b5ad48d5e62fb" translate="yes" xml:space="preserve">
          <source>Prints the current application to the shell if it was not printed yet.</source>
          <target state="translated">Печатает текущее приложение в оболочку,если оно еще не было распечатано.</target>
        </trans-unit>
        <trans-unit id="b0cbd5cf2d2d3e1ca6d472dc9fce84b12f99639e" translate="yes" xml:space="preserve">
          <source>Prints the current location and stacktrace in a pry session.</source>
          <target state="translated">Распечатайте текущее местоположение и укладывайте данные в стек во время сеанса связи.</target>
        </trans-unit>
        <trans-unit id="b874478af7120eec5906930f8fa90e197ddb0f5c" translate="yes" xml:space="preserve">
          <source>Prints the current working directory.</source>
          <target state="translated">Печатает текущую рабочую директорию.</target>
        </trans-unit>
        <trans-unit id="e2927c6e9ca9a7624f08be74d01a105931872b70" translate="yes" xml:space="preserve">
          <source>Prints the dependency tree.</source>
          <target state="translated">Распечатывает дерево зависимости.</target>
        </trans-unit>
        <trans-unit id="f23662b711ee1f5d4b42e4d3962ce84c2e247563" translate="yes" xml:space="preserve">
          <source>Prints the documentation for &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Распечатывает документацию для &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7891ced35c9c114c80c5ffbd1f3c76e017520d37" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given callback function.</source>
          <target state="translated">Распечатывает документацию для данной функции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="435df0bab4049f4242469a352be410f6392ff49a" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given module or for the given &lt;code&gt;function/arity&lt;/code&gt; pair.</source>
          <target state="translated">Печатает документацию для данного модуля или для данной пары &lt;code&gt;function/arity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4e5b715823a81af2f3bf4f64cb361cb0e6cdd53" translate="yes" xml:space="preserve">
          <source>Prints the error to the shell followed by a newline.</source>
          <target state="translated">Печатает ошибку в оболочку,за которой следует новая строка.</target>
        </trans-unit>
        <trans-unit id="520d57f3ac5af5ff431571387cb13b8f42ac807d" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI error to the shell followed by a newline.</source>
          <target state="translated">Распечатывает данную ANSI-ошибку в оболочке,за которой следует новая строка.</target>
        </trans-unit>
        <trans-unit id="6f73495e34df8eb42235ec69b623fa2416a182ff" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI error to the shell.</source>
          <target state="translated">Печатает данную ANSI-ошибку в оболочку.</target>
        </trans-unit>
        <trans-unit id="1bafbf3ef8eb7159086bd97a24eb4f293f1a5373" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI message to the shell followed by a newline.</source>
          <target state="translated">Распечатывает заданное ANSI-сообщение в оболочке,за которым следует новая строка.</target>
        </trans-unit>
        <trans-unit id="8369f83188dc1b52c0cc18c00adcce18fe776b89" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI message to the shell.</source>
          <target state="translated">Печатает данное сообщение ANSI на оболочку.</target>
        </trans-unit>
        <trans-unit id="499ef41bb785f746215b5a24160f51ee0f225759" translate="yes" xml:space="preserve">
          <source>Prints the types for the given module or for the given function/arity pair.</source>
          <target state="translated">Выдает типы для данного модуля или для данной пары функция/часть.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="05530a9faf598937d4f4978efcc1c34117c9ea75" translate="yes" xml:space="preserve">
          <source>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an &lt;a href=&quot;https://hexdocs.pm/elixir/UndefinedFunctionError.html&quot;&gt;&lt;code&gt;UndefinedFunctionError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Частные функции доступны только из модуля, в котором они определены. Попытка получить доступ к частной функции извне модуля, который она определена, приводит к исключению &lt;a href=&quot;https://hexdocs.pm/elixir/UndefinedFunctionError.html&quot;&gt; &lt;code&gt;UndefinedFunctionError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb2a8bb0b4b97049a59dbbb6853799ec628b02bc" translate="yes" xml:space="preserve">
          <source>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an &lt;a href=&quot;undefinedfunctionerror&quot;&gt;&lt;code&gt;UndefinedFunctionError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Частные функции доступны только из модуля, в котором они определены. Попытка получить доступ к частной функции извне модуля, который она определена, приводит к исключению &lt;a href=&quot;undefinedfunctionerror&quot;&gt; &lt;code&gt;UndefinedFunctionError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ca7456031219f8f2eeb5d52b9d37db3106da6e2" translate="yes" xml:space="preserve">
          <source>Private macros</source>
          <target state="translated">Частные макросы</target>
        </trans-unit>
        <trans-unit id="df9584791f632e79823605fbe6e78ca4839179b5" translate="yes" xml:space="preserve">
          <source>Private macros are only accessible from the same module in which they are defined.</source>
          <target state="translated">Приватные макросы доступны только из того же модуля,в котором они определены.</target>
        </trans-unit>
        <trans-unit id="46cd46eb7732031c3d6591214da75d5f59059290" translate="yes" xml:space="preserve">
          <source>Private macros must be defined before its usage.</source>
          <target state="translated">Приватные макросы должны быть определены до их использования.</target>
        </trans-unit>
        <trans-unit id="12f4c13a6a06f999cc56eb966c94f71ef2658a3f" translate="yes" xml:space="preserve">
          <source>Process</source>
          <target state="translated">Process</target>
        </trans-unit>
        <trans-unit id="5eaa8e263e7efadbe9297d9c15fb6812d4c60c3a" translate="yes" xml:space="preserve">
          <source>Process-based and application-centric functionality</source>
          <target state="translated">Функциональность,основанная на процессах и ориентированная на приложения</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="a808861bbe2c82040e69c3e43be934abe883b545" translate="yes" xml:space="preserve">
          <source>Processes and group leaders</source>
          <target state="translated">Процессы и руководители групп</target>
        </trans-unit>
        <trans-unit id="64cc2973345456132597091b2640ba2a85719adb" translate="yes" xml:space="preserve">
          <source>Processes and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don&amp;rsquo;t share anything by default. Therefore, a failure in a process will never crash or corrupt the state of another process. Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.</source>
          <target state="translated">Процессы и ссылки играют важную роль при построении отказоустойчивых систем. Процессы Elixir изолированы и по умолчанию ничего не разделяют. Следовательно, сбой в процессе никогда не приведет к сбою или повреждению состояния другого процесса. Однако ссылки позволяют процессам устанавливать отношения в случае сбоя. Мы часто связываем наши процессы с супервизорами, которые обнаруживают, когда процесс умирает, и запускают новый процесс на его месте.</target>
        </trans-unit>
        <trans-unit id="76f3f8bdca9664b89ee735acfb5e747a8d6c7222" translate="yes" xml:space="preserve">
          <source>Processes and raw files</source>
          <target state="translated">Процессы и исходные файлы</target>
        </trans-unit>
        <trans-unit id="23eeb001c70f95660b354880626576dbb1964408" translate="yes" xml:space="preserve">
          <source>Processes are the most common answer to this question. We can write processes that loop infinitely, maintain state, and send and receive messages. As an example, let&amp;rsquo;s write a module that starts new processes that work as a key-value store in a file named &lt;code&gt;kv.exs&lt;/code&gt;:</source>
          <target state="translated">Процессы - наиболее частый ответ на этот вопрос. Мы можем писать процессы, которые зацикливаются бесконечно, поддерживают состояние и отправляют и получают сообщения. В качестве примера напишем модуль, запускающий новые процессы, которые работают как хранилище значений ключей в файле с именем &lt;code&gt;kv.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="098f80f89b609eb84c8d74bbd2be6927723c925d" translate="yes" xml:space="preserve">
          <source>Processes get much more interesting when we are able to send and receive messages.</source>
          <target state="translated">Процессы становятся намного интереснее,когда мы можем отправлять и получать сообщения.</target>
        </trans-unit>
        <trans-unit id="1c4a0da5abc99ecc4244180ae622b35cf0c5d24f" translate="yes" xml:space="preserve">
          <source>Produces a new list by removing the value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Создает новый список, удаляя значение по указанному &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e60eab60abd9957404c62c1a08f6416ba3bd550" translate="yes" xml:space="preserve">
          <source>Profile output</source>
          <target state="translated">Вывод профиля</target>
        </trans-unit>
        <trans-unit id="17a20ce2ecdf2e690491227f705d6a39b4f49280" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;cprof&lt;/code&gt; tool.</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; данный файл или выражение с помощью инструмента Erlang cprof .</target>
        </trans-unit>
        <trans-unit id="9e9508bf92bb3b0baebd12f499bb465caddb8d1d" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;eprof&lt;/code&gt; tool.</source>
          <target state="translated">&lt;code&gt;eprof&lt;/code&gt; данный файл или выражение с помощью инструмента Erlang eprof .</target>
        </trans-unit>
        <trans-unit id="7f5a56d02582dfbf0f39138c52e7854843f56715" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;fprof&lt;/code&gt; tool.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; данный файл или выражение с помощью инструмента Erlang fprof .</target>
        </trans-unit>
        <trans-unit id="a3eb4c5dc8ed98fadb3285836002a5d71bcb1221" translate="yes" xml:space="preserve">
          <source>Project compilation</source>
          <target state="translated">Компиляция проекта</target>
        </trans-unit>
        <trans-unit id="c948166b923ec0b7f32efdb8807735735dd8fe86" translate="yes" xml:space="preserve">
          <source>Projects are often made available to other developers &lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;by publishing a Hex package&lt;/a&gt;. Hex also &lt;a href=&quot;https://hex.pm/pricing&quot;&gt;supports private packages for organizations&lt;/a&gt;. If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to &lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs&lt;/a&gt;.</source>
          <target state="translated">Проекты часто становятся доступными другим разработчикам &lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;путем публикации шестнадцатеричного пакета&lt;/a&gt; . Hex также &lt;a href=&quot;https://hex.pm/pricing&quot;&gt;поддерживает частные пакеты для организаций&lt;/a&gt; . Если ExDoc настроен для проекта Mix, публикация пакета в Hex также автоматически опубликует созданную документацию в &lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="928902bdb5cb34c32542be3d749f35a31372f0b9" translate="yes" xml:space="preserve">
          <source>Projects can extend Mix behaviour by adding their own tasks. For example, adding the task below inside your project will make it available to everyone that uses your project:</source>
          <target state="translated">Проекты могут расширять поведение Mix,добавляя свои собственные задачи.Например,добавление задачи внутри вашего проекта сделает ее доступной для всех,кто использует ваш проект:</target>
        </trans-unit>
        <trans-unit id="baaca8514e96b4b82b5f18247ed0611dd75c38c5" translate="yes" xml:space="preserve">
          <source>Projects or applications?</source>
          <target state="translated">Проекты или заявки?</target>
        </trans-unit>
        <trans-unit id="a817d7eb8e0f1dab755ab5203a082e5c3c094fce" translate="yes" xml:space="preserve">
          <source>Prompt</source>
          <target state="translated">Prompt</target>
        </trans-unit>
        <trans-unit id="7a0dec5bd8beaf8966c20643c7460723312db52e" translate="yes" xml:space="preserve">
          <source>Prompts the user for confirmation.</source>
          <target state="translated">Подтверждает пользователя.</target>
        </trans-unit>
        <trans-unit id="2aca8f27d240f670b5c2dd5bad2b1c492e8b548c" translate="yes" xml:space="preserve">
          <source>Prompts the user for input.</source>
          <target state="translated">Подталкивает пользователя к вводу.</target>
        </trans-unit>
        <trans-unit id="7606ab4ce07f68998f8ea0ae42c453b5c637eccf" translate="yes" xml:space="preserve">
          <source>Prompts the user to overwrite the file if it exists.</source>
          <target state="translated">Указывает пользователю перезаписать файл,если он существует.</target>
        </trans-unit>
        <trans-unit id="1ed77c3f7ffc41a33eadccef5727dc7c97079235" translate="yes" xml:space="preserve">
          <source>Protocol</source>
          <target state="translated">Protocol</target>
        </trans-unit>
        <trans-unit id="c95299144f537818ea4ffc62edc9baddb79ff9f1" translate="yes" xml:space="preserve">
          <source>Protocol consolidation</source>
          <target state="translated">объединение протоколов</target>
        </trans-unit>
        <trans-unit id="4924211f292b499a01c2e195003fc6016713268f" translate="yes" xml:space="preserve">
          <source>Protocol consolidation is applied by default to all Mix projects during compilation. This may be an issue during test. For instance, if you want to implement a protocol during test, the implementation will have no effect, as the protocol has already been consolidated. One possible solution is to include compilation directories that are specific to your test environment in your mix.exs:</source>
          <target state="translated">Консолидация протоколов применяется по умолчанию ко всем проектам Mix во время компиляции.Это может быть проблемой во время тестирования.Например,если вы хотите реализовать протокол во время тестирования,реализация не будет иметь никакого эффекта,так как протокол уже был консолидирован.Одним из возможных решений является включение в mix.exs каталогов компиляции,специфичных для вашей тестовой среды:</target>
        </trans-unit>
        <trans-unit id="56899eca0f5c92aaef991d6556116246dc1628dd" translate="yes" xml:space="preserve">
          <source>Protocol consolidation is useful in production when no dynamic code loading will happen, effectively optimizing protocol dispatches by not accounting for code loading.</source>
          <target state="translated">Консолидация протоколов полезна в производстве,когда не происходит динамической загрузки кода,эффективно оптимизируя рассылку протоколов,не учитывая загрузку кода.</target>
        </trans-unit>
        <trans-unit id="38f75fd9978f6b7ab60b40a58bd29ed87ef1c6c3" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError</source>
          <target state="translated">Protocol.UndefinedError</target>
        </trans-unit>
        <trans-unit id="b22941c869e24046b71f5c52bd523b215a22df33" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Protocol.UndefinedError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2a6e3082f7bd2a56b001fbb1624e361e5599002d" translate="yes" xml:space="preserve">
          <source>Protocols</source>
          <target state="translated">Protocols</target>
        </trans-unit>
        <trans-unit id="e4df956dc0223cfa164303e687c5a225641ae40e" translate="yes" xml:space="preserve">
          <source>Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See &lt;a href=&quot;#defprotocol/2&quot;&gt;&lt;code&gt;defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on protocols. Elixir provides the following protocols in the standard library:</source>
          <target state="translated">Протоколы добавляют в Эликсир полиморфную рассылку. Это контракты, реализуемые по типам данных. См. &lt;a href=&quot;#defprotocol/2&quot;&gt; &lt;code&gt;defprotocol/2&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о протоколах. В стандартной библиотеке Elixir есть следующие протоколы:</target>
        </trans-unit>
        <trans-unit id="1def0a70d708cdb3bbc2385a4c6d0ac221d9e809" translate="yes" xml:space="preserve">
          <source>Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt; for more information on protocols. Elixir provides the following protocols in the standard library:</source>
          <target state="translated">Протоколы добавляют в Эликсир полиморфную рассылку. Это контракты, реализуемые по типам данных. См. &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о протоколах. В стандартной библиотеке Elixir есть следующие протоколы:</target>
        </trans-unit>
        <trans-unit id="36627e2d6127b7bd708517ebecfa2ad88acfd239" translate="yes" xml:space="preserve">
          <source>Protocols and Structs</source>
          <target state="translated">Протоколы и структуры</target>
        </trans-unit>
        <trans-unit id="bf8ab3000b321cfc5656321edcc2397588fbb0c7" translate="yes" xml:space="preserve">
          <source>Protocols and structs</source>
          <target state="translated">Протоколы и структуры</target>
        </trans-unit>
        <trans-unit id="802592c2ba86a4f47efd17972c7a0ca39d7a2c72" translate="yes" xml:space="preserve">
          <source>Protocols are a mechanism to achieve polymorphism in Elixir when you want behavior to vary depending on the data type. We are already familiar with one way of solving this type of problem: via pattern matching and guard clauses. Consider a simple utility module that would tell us the type of input variable:</source>
          <target state="translated">Протоколы-это механизм достижения полиморфизма в эликсире,когда вы хотите,чтобы поведение варьировалось в зависимости от типа данных.Мы уже знакомы с одним из способов решения такого рода проблем:через подгонку шаблонов и положения о защите.Рассмотрим простой утилитный модуль,который сообщит нам тип входной переменной:</target>
        </trans-unit>
        <trans-unit id="8ae27a72345a1064a4d3cc2a284758812ffebfda" translate="yes" xml:space="preserve">
          <source>Protocols are a mechanism to achieve polymorphism in Elixir. Dispatching on a protocol is available to any data type as long as it implements the protocol. Let&amp;rsquo;s see an example.</source>
          <target state="translated">Протоколы - это механизм для достижения полиморфизма в Elixir. Диспетчеризация по протоколу доступна для любого типа данных, если он реализует протокол. Посмотрим на пример.</target>
        </trans-unit>
        <trans-unit id="77f08665fbb2d92871b41b859bb9813256bbb73a" translate="yes" xml:space="preserve">
          <source>Protocols can also be implemented for multiple types at once:</source>
          <target state="translated">Протоколы также могут быть реализованы для нескольких типов одновременно:</target>
        </trans-unit>
        <trans-unit id="e0a4f154e26e2407d7bcfe638361358c2a738cf2" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string, but not yet implemented. The resulting test will always fail and print a &quot;Not implemented&quot; error message. The resulting test case is also tagged with &lt;code&gt;:not_implemented&lt;/code&gt;.</source>
          <target state="translated">Предоставляет удобный макрос, который позволяет определить тест со строкой, но еще не реализован. Результирующий тест всегда будет терпеть неудачу и вывести сообщение об ошибке &amp;laquo;Не реализовано&amp;raquo;. Результирующий тестовый пример также помечен &lt;code&gt;:not_implemented&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28a92a1009021c22f4256b929d5eb72a49f595b7" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string. This macro automatically inserts the atom &lt;code&gt;:ok&lt;/code&gt; as the last line of the test. That said, a passing test always returns &lt;code&gt;:ok&lt;/code&gt;, but, more importantly, it forces Elixir to not tail call optimize the test and therefore avoids hiding lines from the backtrace.</source>
          <target state="translated">Предоставляет удобный макрос, который позволяет определять тест со строкой. Этот макрос автоматически вставляет атом &lt;code&gt;:ok&lt;/code&gt; в последнюю строку теста. Тем не менее, пройденный тест всегда возвращает &lt;code&gt;:ok&lt;/code&gt; , но, что более важно, он заставляет Elixir не выполнять хвостовой вызов, оптимизируя тест и, следовательно, избегает сокрытия строк из обратной трассировки.</target>
        </trans-unit>
        <trans-unit id="f485c4915018382897d623e74fdf4c922f5ba9de" translate="yes" xml:space="preserve">
          <source>Provides a set of algorithms to work with enumerables.</source>
          <target state="translated">Предоставляет набор алгоритмов для работы с перечислениями.</target>
        </trans-unit>
        <trans-unit id="f7babca163a5798352d200c29bbb4727f2713232" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">Предоставляет оператор короткого замыкания, который оценивает и возвращает второе выражение только в том случае, если первое выражение не дает истинного значения (то есть оно либо равно &lt;code&gt;nil&lt;/code&gt; либо &lt;code&gt;false&lt;/code&gt; ). В противном случае возвращает первое выражение.</target>
        </trans-unit>
        <trans-unit id="35075f345dd0aedc6d466cfa0aae79a32f0d1a0f" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">Предоставляет оператор короткого замыкания, который оценивает и возвращает второе выражение, только если первое выражение дает истинное значение (ни &lt;code&gt;false&lt;/code&gt; ни &lt;code&gt;nil&lt;/code&gt; ). В противном случае возвращает первое выражение.</target>
        </trans-unit>
        <trans-unit id="5c97af16a870f773f7d8298f32114ae521e291d7" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">Предоставляет оператор короткого замыкания, который оценивает и возвращает второе выражение только в том случае, если первое выражение дает истинное значение (ни &lt;code&gt;false&lt;/code&gt; ни &lt;code&gt;nil&lt;/code&gt; ). В противном случае возвращает первое выражение.</target>
        </trans-unit>
        <trans-unit id="bb1c1ada41fd138777281c5c60f4b0fbeb1252f7" translate="yes" xml:space="preserve">
          <source>Provides an &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">Предоставляет макрос &lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7f5e01f31db2b96487f259d6815fc4f44d1641" translate="yes" xml:space="preserve">
          <source>Provides an &lt;code&gt;unless&lt;/code&gt; macro.</source>
          <target state="translated">Обеспечивает &lt;code&gt;unless&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="45d5f5b4aef56cec5f198053345c927c66a7c8fe" translate="yes" xml:space="preserve">
          <source>Provides conveniences for creating, loading, and manipulating Mix tasks.</source>
          <target state="translated">Предоставляет удобства для создания,загрузки и управления задачами Mix.</target>
        </trans-unit>
        <trans-unit id="cc5d7dd7b7f78c70f93425bf23e7c1767df559e1" translate="yes" xml:space="preserve">
          <source>Provides debug, info, warn, and error levels.</source>
          <target state="translated">Обеспечивает уровни отладки,информации,предупреждений и ошибок.</target>
        </trans-unit>
        <trans-unit id="9d218d5f6be5831e733b2aadef5482b512cca16e" translate="yes" xml:space="preserve">
          <source>Provides documentation for the current module.</source>
          <target state="translated">Предоставляет документацию по текущему модулю.</target>
        </trans-unit>
        <trans-unit id="da7b097fc28ffbab2557a5f2b082e76f4d69bde6" translate="yes" xml:space="preserve">
          <source>Provides documentation for the entity that follows the attribute. &lt;code&gt;@doc&lt;/code&gt; is to be used with a function, macro, callback, or macrocallback, while &lt;code&gt;@typedoc&lt;/code&gt; with a type (public or opaque).</source>
          <target state="translated">Предоставляет документацию для объекта, следующего за атрибутом. &lt;code&gt;@doc&lt;/code&gt; должен использоваться с функцией, макросом, обратным вызовом или &lt;code&gt;@typedoc&lt;/code&gt; , а @typedoc - с типом (общедоступным или непрозрачным).</target>
        </trans-unit>
        <trans-unit id="fdadc7bd29e445ef99b6104b5a2b2b038e10ffe9" translate="yes" xml:space="preserve">
          <source>Provides functions to deal with modules during compilation time.</source>
          <target state="translated">Предоставляет функции для работы с модулями во время компиляции.</target>
        </trans-unit>
        <trans-unit id="df51d0334cfd857e80339917423d4fb2e1cef1c7" translate="yes" xml:space="preserve">
          <source>Provides regular expressions for Elixir.</source>
          <target state="translated">Предоставляет регулярные выражения для Эликсира.</target>
        </trans-unit>
        <trans-unit id="d02201797a586702284442194cb247908230a636" translate="yes" xml:space="preserve">
          <source>Provides runtime information about functions, macros, and other information defined by the module.</source>
          <target state="translated">Предоставляет информацию о функциях,макросах и другую информацию,определяемую модулем.</target>
        </trans-unit>
        <trans-unit id="cc9cbca5a4e02cf60536136ef9f3c6d625c70f6c" translate="yes" xml:space="preserve">
          <source>Provides the deprecation reason for a function. For example:</source>
          <target state="translated">Предоставляет причину для разрушения функции.Например:</target>
        </trans-unit>
        <trans-unit id="eb509e3cef4b01a2055df90985ae11c420fddff2" translate="yes" xml:space="preserve">
          <source>Providing a non-boolean will raise an exception:</source>
          <target state="translated">При условии,что не булевка,будет сделано исключение:</target>
        </trans-unit>
        <trans-unit id="0e15e7e0c2b4f977b6843784ea894879b5494e87" translate="yes" xml:space="preserve">
          <source>Prunes invalid Unicode code points from lists and invalid UTF-8 bytes.</source>
          <target state="translated">Вырезает из списков недействительные точки кода Юникода и недействительные UTF-8 байт.</target>
        </trans-unit>
        <trans-unit id="fdaf9976e20d314713bf8ad08c1c0453b92492e1" translate="yes" xml:space="preserve">
          <source>Prunes non-valid UTF-8 code points.</source>
          <target state="translated">Обрезает недействительный точечный код UTF-8.</target>
        </trans-unit>
        <trans-unit id="fb5dee80e4520a5f254d6238153c6dc561e1cf68" translate="yes" xml:space="preserve">
          <source>Pry and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; и смешивание</target>
        </trans-unit>
        <trans-unit id="54ec660e29ebb5bec957ff2cb42e6a129ef66da9" translate="yes" xml:space="preserve">
          <source>Pry and macros</source>
          <target state="translated">Совать нос не в своё дело</target>
        </trans-unit>
        <trans-unit id="1c9019872a4bbfd06ad7b17c0bee064d866590d1" translate="yes" xml:space="preserve">
          <source>Prying and breakpoints</source>
          <target state="translated">точки соприкосновения и перерывов</target>
        </trans-unit>
        <trans-unit id="4b2535c1fee183c38427a7089cd2b388b925985a" translate="yes" xml:space="preserve">
          <source>Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.</source>
          <target state="translated">Публичные функции в модулях доступны в глобальном масштабе,но для того,чтобы использовать макросы,необходимо подписаться,потребовав модуль,в котором они определены.</target>
        </trans-unit>
        <trans-unit id="b8b838dadc80d5fdf978ad61a556c571858f9ea4" translate="yes" xml:space="preserve">
          <source>Public keys are by default stored in your MIX_HOME under the public_keys directory.</source>
          <target state="translated">По умолчанию открытые ключи хранятся в Вашем MIX_HOME в каталоге public_keys.</target>
        </trans-unit>
        <trans-unit id="a8c75b8cc2fd8745681c0480ca03a865e4064f2c" translate="yes" xml:space="preserve">
          <source>Public keys are used by Mix to install packages like Rebar and Hex.</source>
          <target state="translated">Открытые ключи используются Mix для установки таких пакетов,как Rebar и Hex.</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="25d4b8eeccc56c0cd4a7d514c04c9c3ae243c619" translate="yes" xml:space="preserve">
          <source>Purge compiler modules.</source>
          <target state="translated">Модули компилятора очистки.</target>
        </trans-unit>
        <trans-unit id="b90fc74c10d02d502db87680f321a47d69aa7a2c" translate="yes" xml:space="preserve">
          <source>Puts &lt;code&gt;value&lt;/code&gt; at the given zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">Помещает &lt;code&gt;value&lt;/code&gt; в заданный отсчитываемый от нуля &lt;code&gt;index&lt;/code&gt; в &lt;code&gt;tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec1e5d54e71eec9873cec8ecdadb097c2ae427d5" translate="yes" xml:space="preserve">
          <source>Puts a module attribute with &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; in the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Помещает атрибут модуля с &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; в данный &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4acfce1f0b23360b26c12b5e6c7bf2a6bf918d25" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Помещает значение во вложенную структуру по заданному &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c0b337e86b25912f1d42a657325dc6d8a9a7246" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure.</source>
          <target state="translated">Поставляет значение во вложенную структуру.</target>
        </trans-unit>
        <trans-unit id="4865e7e25231ab9477efccfa0577bb1695cee9b1" translate="yes" xml:space="preserve">
          <source>Puts a value under &lt;code&gt;key&lt;/code&gt; only if the &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">Помещает значение под &lt;code&gt;key&lt;/code&gt; только если &lt;code&gt;key&lt;/code&gt; уже существует в &lt;code&gt;keywords&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ce204eaabed7443e91511f145c78e913dad9c8" translate="yes" xml:space="preserve">
          <source>Puts a value under &lt;code&gt;key&lt;/code&gt; only if the &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">Помещает значение под &lt;code&gt;key&lt;/code&gt; только если &lt;code&gt;key&lt;/code&gt; уже существует на &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c400abfe3b82b8ea0f8b25008c2bc562a136778b" translate="yes" xml:space="preserve">
          <source>Puts logging level for given module.</source>
          <target state="translated">Выставляет уровень протоколирования для данного модуля.</target>
        </trans-unit>
        <trans-unit id="48a23971095bfbe373d39b1f1c70ac23fcde2d47" translate="yes" xml:space="preserve">
          <source>Puts the &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">Помещает &lt;code&gt;value&lt;/code&gt; в &lt;code&gt;key&lt;/code&gt; для данного &lt;code&gt;app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97d0f1caf6e213cd26ac881b852140f4d9d23037" translate="yes" xml:space="preserve">
          <source>Puts the calling process into a &quot;hibernation&quot; state.</source>
          <target state="translated">Переводит процесс вызова в состояние &quot;спячки&quot;.</target>
        </trans-unit>
        <trans-unit id="cadfddef2accc558bb07d494514e7ca1c284d964" translate="yes" xml:space="preserve">
          <source>Puts the environment for multiple apps at the same time.</source>
          <target state="translated">Поставляет среду для нескольких приложений одновременно.</target>
        </trans-unit>
        <trans-unit id="b6ea1ba815fc83f69431f0cdd76f4213b86b1a54" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">Помещает заданное &lt;code&gt;value&lt;/code&gt; под &lt;code&gt;key&lt;/code&gt; на &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de7749bbf077f512273bf8036b7cb8fc0deef364" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">Помещает заданное &lt;code&gt;value&lt;/code&gt; под &lt;code&gt;key&lt;/code&gt; если &lt;code&gt;key&lt;/code&gt; входа еще не существует на &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b4d02cfb162ff8a780c85d472f56775f06bd43e" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists.</source>
          <target state="translated">Помещает заданное &lt;code&gt;value&lt;/code&gt; под &lt;code&gt;key&lt;/code&gt; если &lt;code&gt;key&lt;/code&gt; входа еще не существует.</target>
        </trans-unit>
        <trans-unit id="801eb18f7c8ac7d16195e64a31d50b2a30aa8262" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Помещает заданное &lt;code&gt;value&lt;/code&gt; под &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="a87585b69b086c147f372f2e5a1d39fb50ad8a31" translate="yes" xml:space="preserve">
          <source>Qualified calls (remote calls)</source>
          <target state="translated">Квалифицированные вызовы (удаленные вызовы)</target>
        </trans-unit>
        <trans-unit id="665a6bcf289c1518f036a63e86791885bb3d1c3f" translate="yes" xml:space="preserve">
          <source>Qualified calls, such as &lt;code&gt;Math.add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscores. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">Квалифицированные вызовы, такие как &lt;code&gt;Math.add(1, 2)&lt;/code&gt; , должны начинаться с подчеркивания или буквы Юникода, которая не должна быть прописной или заглавной. Вызов может продолжаться с использованием последовательности букв Юникода, цифр и знаков подчеркивания. Звонки могут закончиться &lt;code&gt;?&lt;/code&gt; или &lt;code&gt;!&lt;/code&gt; , См. Формальную спецификацию в &lt;a href=&quot;unicode-syntax&quot;&gt;синтаксисе Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d3830748786cef6d1d371b9b4a4083c2ec61ee9" translate="yes" xml:space="preserve">
          <source>Quarter</source>
          <target state="translated">Quarter</target>
        </trans-unit>
        <trans-unit id="d47a22f953dc2b31cf6bc6440050b0aaf55f9649" translate="yes" xml:space="preserve">
          <source>Quote and macros</source>
          <target state="translated">Цитаты и макросы</target>
        </trans-unit>
        <trans-unit id="398f0ab8b840b28a0fd354d1c0d7a72c7d9d306e" translate="yes" xml:space="preserve">
          <source>Quote and unquote</source>
          <target state="translated">Цитировать и закрывать кавычки</target>
        </trans-unit>
        <trans-unit id="d94e69560e301502d99603fd94eaa70bde805275" translate="yes" xml:space="preserve">
          <source>Quote is about retrieving the inner representation of some particular chunk of code. However, sometimes it may be necessary to inject some other particular chunk of code inside the representation we want to retrieve.</source>
          <target state="translated">Цитата посвящена получению внутреннего представления некоторого конкретного фрагмента кода.Однако иногда может понадобиться вставить какой-нибудь другой конкретный фрагмент кода в то представление,которое мы хотим получить.</target>
        </trans-unit>
        <trans-unit id="dc325775a37291e9e0f216be4d97c9b52b5046b9" translate="yes" xml:space="preserve">
          <source>Quoted and unquoted atoms with the same name are considered equivalent, so &lt;code&gt;:atom&lt;/code&gt;, &lt;code&gt;:&quot;atom&quot;&lt;/code&gt;, and &lt;code&gt;:'atom'&lt;/code&gt; represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted.</source>
          <target state="translated">В кавычках и без атомов с тем же именем , считаются эквивалентными, так &lt;code&gt;:atom&lt;/code&gt; , &lt;code&gt;:&quot;atom&quot;&lt;/code&gt; , и &lt;code&gt;:'atom'&lt;/code&gt; представляют собой один и тот же атом. Единственная загвоздка в том, что компилятор предупредит, когда в атомах используются кавычки, которые не нужно заключать в кавычки.</target>
        </trans-unit>
        <trans-unit id="3a432aa09de3e72168ea6a4c0658a86a59f5a08d" translate="yes" xml:space="preserve">
          <source>Quoted expression</source>
          <target state="translated">Цитируемое выражение</target>
        </trans-unit>
        <trans-unit id="1d3b684c7214d0c281c4454aed5c04034ff88811" translate="yes" xml:space="preserve">
          <source>Quoted identifiers, such as strings (&lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt;) and charlists (&lt;code&gt;'ol&amp;aacute;'&lt;/code&gt;), support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation.</source>
          <target state="translated">&lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt; идентификаторы, такие как строки ( &quot;ol&amp;aacute;&quot; ) и списки символов ( &lt;code&gt;'ol&amp;aacute;'&lt;/code&gt; ), поддерживают Unicode, начиная с Elixir v1.0. Строки кодируются в UTF-8. Charlists - это списки кодовых точек Unicode. В таких случаях содержимое сохраняется в том виде, в каком оно написано разработчиками, без каких-либо преобразований.</target>
        </trans-unit>
        <trans-unit id="60fefb29eda0237f92306cb85899330ca8b230ee" translate="yes" xml:space="preserve">
          <source>Quoting</source>
          <target state="translated">Quoting</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="db712921d6fecc09e09fab853318c381738ce114" translate="yes" xml:space="preserve">
          <source>R1. Default Identifiers</source>
          <target state="translated">R1.Идентификаторы по умолчанию</target>
        </trans-unit>
        <trans-unit id="26b991df92308f2a367c957c4d50b613aa415ed2" translate="yes" xml:space="preserve">
          <source>R3. Pattern_White_Space and Pattern_Syntax Characters</source>
          <target state="translated">R3.Pattern_White_Space и Pattern_Syntax Символы синтаксиса</target>
        </trans-unit>
        <trans-unit id="64f597518b8819e33beed326e0aef13663d12b03" translate="yes" xml:space="preserve">
          <source>R6. Filtered Normalized Identifiers</source>
          <target state="translated">R6.Отфильтрованные нормализованные идентификаторы</target>
        </trans-unit>
        <trans-unit id="6f4503a9f856bd401816cf9c9537b400021fea70" translate="yes" xml:space="preserve">
          <source>Race conditions?</source>
          <target state="translated">Условия гонки?</target>
        </trans-unit>
        <trans-unit id="9dbe56f890ac8f921853592e6d6ef65ae4769f24" translate="yes" xml:space="preserve">
          <source>Raised to signal an assertion error.</source>
          <target state="translated">Поднят,чтобы сигнализировать об ошибке утверждения.</target>
        </trans-unit>
        <trans-unit id="5b1ea728487504127e3f68a3942530c7d9ee6815" translate="yes" xml:space="preserve">
          <source>Raised to signal multiple errors happened in a test case.</source>
          <target state="translated">В тестовом примере было выявлено несколько ошибок.</target>
        </trans-unit>
        <trans-unit id="8fdd3d5744b14fe8df2f78525ff278b3980dcf70" translate="yes" xml:space="preserve">
          <source>Raised when a struct cannot be inspected.</source>
          <target state="translated">Воспитан,когда структура не может быть проверена.</target>
        </trans-unit>
        <trans-unit id="fa9e03b9a6f82b7dabd4d26d477bd23b2afc1a4f" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;padding&lt;/code&gt; contains a non-string element.</source>
          <target state="translated">Вызывает ошибку &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; ,&lt;/a&gt; если данное &lt;code&gt;padding&lt;/code&gt; содержит нестроковый элемент.</target>
        </trans-unit>
        <trans-unit id="af83d7d1086d026fc286f4645bae49fd7306d517" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; contains a non-numeric value.</source>
          <target state="translated">Вызывает &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;enumerable&lt;/code&gt; содержит нечисловое значение.</target>
        </trans-unit>
        <trans-unit id="3d76c0d9f487f5fbe07e874551d88d47fee0d896" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;right&lt;/code&gt; is 0 or 0.0.</source>
          <target state="translated">Вызывает &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;right&lt;/code&gt; равно 0 или 0,0.</target>
        </trans-unit>
        <trans-unit id="3c67dbd468ad8055254ab3928808c3935464e4ce" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;enum.emptyerror&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">Поднимает &lt;a href=&quot;enum.emptyerror&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;enumerable&lt;/code&gt; пуст.</target>
        </trans-unit>
        <trans-unit id="a2c86ffce180eacb8b7b1576ec8952dbfa09213a" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;padding&lt;/code&gt; contains a non-string element.</source>
          <target state="translated">Вызывает ошибку &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; ,&lt;/a&gt; если данное &lt;code&gt;padding&lt;/code&gt; содержит нестроковый элемент.</target>
        </trans-unit>
        <trans-unit id="12e047a30fd33f30a0b414e8517dceb291fc56ab" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; contains a non-numeric value.</source>
          <target state="translated">Вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;enumerable&lt;/code&gt; содержит нечисловое значение.</target>
        </trans-unit>
        <trans-unit id="31a33babd84ffaff3913d153392a8557d0b13380" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;right&lt;/code&gt; is 0 or 0.0.</source>
          <target state="translated">Вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;right&lt;/code&gt; равно 0 или 0,0.</target>
        </trans-unit>
        <trans-unit id="811cd2f761326443b2a5258f1c2a68b97e94a132" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">Поднимает &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;enumerable&lt;/code&gt; пуст.</target>
        </trans-unit>
        <trans-unit id="c2d343a2295f4d5274dcbfd886a84ccb41642f80" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OutOfBoundsError&lt;/code&gt; if the given &lt;code&gt;index&lt;/code&gt; is outside the range of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Поднимает &lt;code&gt;OutOfBoundsError&lt;/code&gt; если данный &lt;code&gt;index&lt;/code&gt; находится вне диапазона &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1069e7348e0650333182303ea7b7927bda6e74" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise.</source>
          <target state="translated">Вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt; исключение , если любой из двух приведенных версий не интерпретируемый. Если дана уже проанализированная версия, эта функция не сработает.</target>
        </trans-unit>
        <trans-unit id="d62f9ebd9e34654105a0b6ae931724ee62a02cc0" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise.</source>
          <target state="translated">Вызывает &lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt; исключение , если любой из двух приведенных версий не интерпретируемый. Если дана уже проанализированная версия, эта функция не сработает.</target>
        </trans-unit>
        <trans-unit id="cab5e5df328b4ddb83cc91a4e5866b2d049b9bdc" translate="yes" xml:space="preserve">
          <source>Raises a Mix error that is nicely formatted.</source>
          <target state="translated">Повышает ошибку Mix,которая хорошо отформатирована.</target>
        </trans-unit>
        <trans-unit id="c1c33aaefd8234c7625624d93eaccbd66022ca1e" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; exception if one of the arguments is not an integer, or when the &lt;code&gt;divisor&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Вызывает исключение &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; ,&lt;/a&gt; если один из аргументов не является целым числом или если &lt;code&gt;divisor&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dae7bfdecf9ccf167222b8627b4247b673a0a98" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; exception if one of the arguments is not an integer, or when the &lt;code&gt;divisor&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Вызывает исключение &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; ,&lt;/a&gt; если один из аргументов не является целым числом или если &lt;code&gt;divisor&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f054f51eef773e350ffd8e720d8ef1c2f7f1d3" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;base&lt;/code&gt; is less than 2 or more than 36.</source>
          <target state="translated">Вызывает ошибку, если &lt;code&gt;base&lt;/code&gt; меньше 2 или больше 36.</target>
        </trans-unit>
        <trans-unit id="81fe4cb7e7c869e7a34bf872a48cb536514bff12" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;supervisor&lt;/code&gt; has reached the maximum number of children.</source>
          <target state="translated">Вызывает ошибку, если &lt;code&gt;supervisor&lt;/code&gt; достиг максимального количества детей.</target>
        </trans-unit>
        <trans-unit id="f213a5266dc7fd081628bda995fed2c1460d6ab8" translate="yes" xml:space="preserve">
          <source>Raises an error if all conditions evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. For this reason, it may be necessary to add a final always-truthy condition (anything non-&lt;code&gt;false&lt;/code&gt; and non-&lt;code&gt;nil&lt;/code&gt;), which will always match.</source>
          <target state="translated">Вызывает ошибку, если все условия оцениваются как &lt;code&gt;nil&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . По этой причине может потребоваться добавить последнее условие &amp;laquo;всегда истинно&amp;raquo; (все, что не является &lt;code&gt;false&lt;/code&gt; и не &lt;code&gt;nil&lt;/code&gt; ), которое всегда будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="6807fc8ee18e17589e66f450694ceab675bbe0db" translate="yes" xml:space="preserve">
          <source>Raises an error if retrieving or changing the current directory fails.</source>
          <target state="translated">Увеличивает ошибку при неудачном извлечении или изменении текущего каталога.</target>
        </trans-unit>
        <trans-unit id="164b30096b2ea6dfc6e8c86db79c4ab887d2f1ec" translate="yes" xml:space="preserve">
          <source>Raises an error if the module was already compiled.</source>
          <target state="translated">Повышает вероятность ошибки,если модуль уже был скомпилирован.</target>
        </trans-unit>
        <trans-unit id="1ba05d6b0411d4457bd3803cd3e4d8649a31a71f" translate="yes" xml:space="preserve">
          <source>Raises an exception preserving a previous stacktrace.</source>
          <target state="translated">Поднимает исключение,сохраняя предыдущую траекторию.</target>
        </trans-unit>
        <trans-unit id="437ea54b50fe87d412f3bb3184bcdd4a6c352ece" translate="yes" xml:space="preserve">
          <source>Raises an exception.</source>
          <target state="translated">Поднимает вопрос об исключении.</target>
        </trans-unit>
        <trans-unit id="a4d46f156dd7b4a5a2ee33034cfcad27d106e75f" translate="yes" xml:space="preserve">
          <source>Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple.</source>
          <target state="translated">Повышается,если дата недействительна.Попытка конвертировать недействительную дату календаря ISO приведет к появлению кортежа ошибки.</target>
        </trans-unit>
        <trans-unit id="71d1ef80cf35651a172132daf389ed313ef6e315" translate="yes" xml:space="preserve">
          <source>Raises if the format is invalid.</source>
          <target state="translated">Поднимается,если формат недействителен.</target>
        </trans-unit>
        <trans-unit id="6519231f297c411772999cd1e8103552ac99be07" translate="yes" xml:space="preserve">
          <source>Raising exceptions</source>
          <target state="translated">Растущие исключения</target>
        </trans-unit>
        <trans-unit id="359e09946a5a3b259a34bf421749cd9902b56698" translate="yes" xml:space="preserve">
          <source>Raising variant of &lt;a href=&quot;#break/4&quot;&gt;&lt;code&gt;break/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Повышающий вариант &lt;a href=&quot;#break/4&quot;&gt; &lt;code&gt;break/4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd2c631ba3a5be13e118569eba6eb843de07c72" translate="yes" xml:space="preserve">
          <source>Raising variant of &lt;a href=&quot;#break/6&quot;&gt;&lt;code&gt;break/6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Повышающий вариант &lt;a href=&quot;#break/6&quot;&gt; &lt;code&gt;break/6&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="7831a9dadc261148b4dba32a72a2bfd0aa16960e" translate="yes" xml:space="preserve">
          <source>Range creation operator. Returns a range with the specified &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; integers.</source>
          <target state="translated">Оператор создания диапазона. Возвращает диапазон с указанными &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;last&lt;/code&gt; целыми числами.</target>
        </trans-unit>
        <trans-unit id="72464e74832155795bb0fc97baa40a95fbc7222b" translate="yes" xml:space="preserve">
          <source>Ranges can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). Ranges are also always inclusive.</source>
          <target state="translated">Диапазоны могут быть увеличивающимися ( &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ) или убывающими ( &lt;code&gt;first &amp;gt; last&lt;/code&gt; ). Диапазоны также всегда инклюзивны.</target>
        </trans-unit>
        <trans-unit id="cbd90679e7f8a9b39ae9a6c5d2cc092800f54ef9" translate="yes" xml:space="preserve">
          <source>Ranges must be created with the &lt;a href=&quot;date#range/2&quot;&gt;&lt;code&gt;Date.range/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Диапазоны необходимо создавать с помощью функции &lt;a href=&quot;date#range/2&quot;&gt; &lt;code&gt;Date.range/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7623f13ae92ca005b307bb293cb91d086ea3ae25" translate="yes" xml:space="preserve">
          <source>Ranges must be created with the &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#range/2&quot;&gt;&lt;code&gt;Date.range/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Диапазоны необходимо создавать с помощью функции &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#range/2&quot;&gt; &lt;code&gt;Date.range/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d488a3099ab1cce2c7739fdbf692916264525f0d" translate="yes" xml:space="preserve">
          <source>Ranges of dates can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). They are also always inclusive.</source>
          <target state="translated">Диапазоны дат могут быть увеличивающимися ( &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ) или убывающими ( &lt;code&gt;first &amp;gt; last&lt;/code&gt; ). Они также всегда инклюзивны.</target>
        </trans-unit>
        <trans-unit id="5ae0f1f0ad1824c4af633686b21c1609c50dc0c2" translate="yes" xml:space="preserve">
          <source>Ranges represent a sequence of one or many, ascending or descending, consecutive integers.</source>
          <target state="translated">Диапазоны представляют собой последовательность одного или многих,восходящих или нисходящих,последовательных целых чисел.</target>
        </trans-unit>
        <trans-unit id="8a225b1af2c34f53e990659786a3df7dde051221" translate="yes" xml:space="preserve">
          <source>Raw files</source>
          <target state="translated">Сырые файлы</target>
        </trans-unit>
        <trans-unit id="43be5d1fec74173cc456fcdb989d79f3a6d61e9b" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module documentation for more information about the general usage of &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#async/3&quot;&gt;&lt;code&gt;async/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Прочтите документацию модуля &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации об общем использовании &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#async/3&quot;&gt; &lt;code&gt;async/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0788c3b600d4f3c0505743b96b49889736ec2d75" translate="yes" xml:space="preserve">
          <source>Read the documentation on the &lt;code&gt;Typespec&lt;/code&gt; page and &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; for more information on typespecs and bitstrings respectively.</source>
          <target state="translated">Прочтите документацию на странице &lt;code&gt;Typespec&lt;/code&gt; и &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о спецификациях типов и битовых строках соответственно.</target>
        </trans-unit>
        <trans-unit id="b03a7abf79ea89d9cecc8c93151a283ebf7f7fbb" translate="yes" xml:space="preserve">
          <source>Read the documentation on the &lt;code&gt;Typespec&lt;/code&gt; page and &lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; for more information on typespecs and bitstrings respectively.</source>
          <target state="translated">Прочтите документацию на странице &lt;code&gt;Typespec&lt;/code&gt; и &lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о спецификациях типов и битовых строках соответственно.</target>
        </trans-unit>
        <trans-unit id="a3889ae6a98ae0e53caf306c3aba6c242dcedd31" translate="yes" xml:space="preserve">
          <source>Reads a line from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">Читает строку с &lt;code&gt;device&lt;/code&gt; ввода-вывода .</target>
        </trans-unit>
        <trans-unit id="ed6358cfae9ed346de26368ca0c1a237b2160331" translate="yes" xml:space="preserve">
          <source>Reads a timer created by &lt;a href=&quot;#send_after/3&quot;&gt;&lt;code&gt;send_after/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Читает таймер, созданный &lt;a href=&quot;#send_after/3&quot;&gt; &lt;code&gt;send_after/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31e0122bb1cd5932aff410ddb26d3668b99408af" translate="yes" xml:space="preserve">
          <source>Reads and writes attributes of the current module.</source>
          <target state="translated">Читает и записывает атрибуты текущего модуля.</target>
        </trans-unit>
        <trans-unit id="e5909314d3283d89421e87193f2a66ac8fa016fa" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">Читает с &lt;code&gt;device&lt;/code&gt; ввода-вывода .</target>
        </trans-unit>
        <trans-unit id="812e657f5b579f0750a1f48f3ac381f21e7e7a7d" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;. The operation is Unicode unsafe.</source>
          <target state="translated">Читает с &lt;code&gt;device&lt;/code&gt; ввода-вывода . Операция небезопасна для Unicode.</target>
        </trans-unit>
        <trans-unit id="a1e72b88bea14f6ca08acd272c7aa85760735eeb" translate="yes" xml:space="preserve">
          <source>Reads registry metadata given on &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Читает метаданные реестра, указанные на &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3a6912210c72237f3cf73a18ef9afb3a5bf363f" translate="yes" xml:space="preserve">
          <source>Reads the application environment at compilation time or raises.</source>
          <target state="translated">Читает среду приложений во время компиляции или повышается.</target>
        </trans-unit>
        <trans-unit id="0b6a82b2378ffd360095c83ed0539589a6586d33" translate="yes" xml:space="preserve">
          <source>Reads the application environment at compilation time.</source>
          <target state="translated">Читает среду приложений во время компиляции.</target>
        </trans-unit>
        <trans-unit id="6e4bfe8b8059fffe67509581ca8fd8bb5863a979" translate="yes" xml:space="preserve">
          <source>Reads the client request and writes a response back</source>
          <target state="translated">Читает запрос клиента и записывает ответ обратно.</target>
        </trans-unit>
        <trans-unit id="d5eb24730d097e029875864fbd190d1f5f20b06f" translate="yes" xml:space="preserve">
          <source>Reads the configuration file.</source>
          <target state="translated">Читает файл конфигурации.</target>
        </trans-unit>
        <trans-unit id="dc12f308ba360c8064a3568dfa28b47e57204e51" translate="yes" xml:space="preserve">
          <source>Reads the current process metadata.</source>
          <target state="translated">Читает текущие метаданные процесса.</target>
        </trans-unit>
        <trans-unit id="c48fac6c8d1d06337a98d9b155bf84f8445d1d91" translate="yes" xml:space="preserve">
          <source>Reads the given configuration file alongside its imports.</source>
          <target state="translated">Читает данный конфигурационный файл вместе с его импортом.</target>
        </trans-unit>
        <trans-unit id="996f074d974ca465971e392485cd9fe090583830" translate="yes" xml:space="preserve">
          <source>Reads the given configuration file and returns the configuration with its imports.</source>
          <target state="translated">Читает заданный конфигурационный файл и возвращает конфигурацию с ее импортом.</target>
        </trans-unit>
        <trans-unit id="6d834acb879e83f8d42700d86e86927b636c6aea" translate="yes" xml:space="preserve">
          <source>Reads the symbolic link at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Читает символьную ссылку по &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c1cdacc82e6db0a4e1b004d6bdbb8cec9ef88a1" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and deletes the first tuple where the element at &lt;code&gt;position&lt;/code&gt; matches the given &lt;code&gt;key&lt;/code&gt;. Returns the new list.</source>
          <target state="translated">Получает &lt;code&gt;list&lt;/code&gt; кортежей и удаляет первый кортеж, в котором элемент в &lt;code&gt;position&lt;/code&gt; соответствует заданному &lt;code&gt;key&lt;/code&gt; . Возвращает новый список.</target>
        </trans-unit>
        <trans-unit id="5c5edba47e63948282ba7aa49263dd69fdc08f5b" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and replaces the element identified by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">Получает &lt;code&gt;list&lt;/code&gt; кортежей и заменяет элемент, идентифицированный &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;position&lt;/code&gt; на &lt;code&gt;new_tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52a2ed027070830b2b704b10a1ab579fee6aa05a" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;, as well as the &lt;code&gt;list&lt;/code&gt; without found tuple.</source>
          <target state="translated">Получает &lt;code&gt;list&lt;/code&gt; кортежей и возвращает первый кортеж, в котором элемент в &lt;code&gt;position&lt;/code&gt; в кортеже соответствует заданному &lt;code&gt;key&lt;/code&gt; , а также &lt;code&gt;list&lt;/code&gt; без найденного кортежа.</target>
        </trans-unit>
        <trans-unit id="53639bc3bc3a88fb72d354e316fd411a08ad54fc" translate="yes" xml:space="preserve">
          <source>Receives a key-value enumerable and converts it to &lt;a href=&quot;#t:argv/0&quot;&gt;&lt;code&gt;argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Получает перечислимый ключ и значение и преобразует его в &lt;a href=&quot;#t:argv/0&quot;&gt; &lt;code&gt;argv/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a8cddc4edd4b8cb647e915685f66b6aa81c4ae" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; (workers or supervisors) to supervise and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">Получает список контролируемых &lt;code&gt;children&lt;/code&gt; (работников или руководителей) и набор &lt;code&gt;options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe2e430f09d68bd297bf576261b80cdda5635920" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; to initialize and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">Получает список инициализируемых &lt;code&gt;children&lt;/code&gt; элементов и набор &lt;code&gt;options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f56a4374996752d9c7b0d8cda70d77fc3e98719" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and if the identified element by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; exists, it is replaced with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">Получает список кортежей, и если идентифицированный элемент по &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;position&lt;/code&gt; существует, он заменяется на &lt;code&gt;new_tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1535576671aa2ff6cdb67db512b203dfc4edba" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns &lt;code&gt;true&lt;/code&gt; if there is a tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Получает список кортежей и возвращает &lt;code&gt;true&lt;/code&gt; если существует кортеж, в котором элемент в &lt;code&gt;position&lt;/code&gt; в кортеже соответствует заданному &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f773b7b4671a15478a78104b05a8ac1289c68e25" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Получает список кортежей и возвращает первый кортеж, в котором элемент в &lt;code&gt;position&lt;/code&gt; в кортеже соответствует заданному &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da55da43556e6c04aee3a123495216a662a853e8" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and sorts the elements at &lt;code&gt;position&lt;/code&gt; of the tuples. The sort is stable.</source>
          <target state="translated">Получает список кортежей и сортирует элементы в &lt;code&gt;position&lt;/code&gt; кортежей. Сорт стабильный.</target>
        </trans-unit>
        <trans-unit id="14e20d5c24dff9fd9fe9735cab3e8e1de2a2fe94" translate="yes" xml:space="preserve">
          <source>Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">Получает модуль,веселье и аристику и форматирует его,как показано в стек-трассах.Массив также может представлять собой список аргументов.</target>
        </trans-unit>
        <trans-unit id="e687df4d6dc594b8acd5822458421f8788bb8599" translate="yes" xml:space="preserve">
          <source>Receives a protocol and a list of implementations and consolidates the given protocol.</source>
          <target state="translated">Получает протокол и список реализаций и консолидирует данный протокол.</target>
        </trans-unit>
        <trans-unit id="22210bb4fc25b4244ff90b5d68a7d14f3ce7571b" translate="yes" xml:space="preserve">
          <source>Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement.</source>
          <target state="translated">Получает регекс,двоичный файл и замену,возвращает новый двоичный файл,где все совпадения заменяются заменой.</target>
        </trans-unit>
        <trans-unit id="b61e49df8ff67a9ca03bd1b42a8bb519e4a1c105" translate="yes" xml:space="preserve">
          <source>Receives a set of &lt;code&gt;options&lt;/code&gt; that initializes a dynamic supervisor.</source>
          <target state="translated">Получает набор &lt;code&gt;options&lt;/code&gt; которые инициализируют динамический супервизор.</target>
        </trans-unit>
        <trans-unit id="d9f6da4d53fe4ab814d14ca17ef2d1aa84915fba" translate="yes" xml:space="preserve">
          <source>Receives a stacktrace entry and formats it into a string.</source>
          <target state="translated">Получает запись стековой дорожки и форматирует ее в строку.</target>
        </trans-unit>
        <trans-unit id="be2efbf787eb31d5be3cc076dff27bc518a35202" translate="yes" xml:space="preserve">
          <source>Receives a task name and retrieves the corresponding task module.</source>
          <target state="translated">Получает имя задания и получает соответствующий модуль задания.</target>
        </trans-unit>
        <trans-unit id="e7746187c8e8540596d6f16990c4f1faef1d5f41" translate="yes" xml:space="preserve">
          <source>Receives a task name and retrieves the task module.</source>
          <target state="translated">Получает имя задачи и извлекает модуль задачи.</target>
        </trans-unit>
        <trans-unit id="9482cbe5474f9102533e9e68071d3fd7743238f4" translate="yes" xml:space="preserve">
          <source>Receives a task name and returns the corresponding task module if one exists.</source>
          <target state="translated">Получает имя задания и возвращает соответствующий модуль задания,если он существует.</target>
        </trans-unit>
        <trans-unit id="b879ac32fa8c2699d4481ef4abf60cb310c50593" translate="yes" xml:space="preserve">
          <source>Receives a task name and returns the task module if found.</source>
          <target state="translated">Получает имя задачи и возвращает модуль задачи,если он найден.</target>
        </trans-unit>
        <trans-unit id="9cac5740e1e65c9728fb7126ef3505b66eac12f3" translate="yes" xml:space="preserve">
          <source>Receives a test and formats its failure.</source>
          <target state="translated">Получает тест и форматирует его сбой.</target>
        </trans-unit>
        <trans-unit id="0976194fd3c75699f15dd6f56c0a05b5f408d271" translate="yes" xml:space="preserve">
          <source>Receives a test module and formats its failure.</source>
          <target state="translated">Получает тестовый модуль и форматирует его отказ.</target>
        </trans-unit>
        <trans-unit id="98d45f98af3936ac871d1b420e669aa3ba75d6f8" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it once.</source>
          <target state="translated">Получает узел AST и расширяет его один раз.</target>
        </trans-unit>
        <trans-unit id="ed69a15b3b64f165dbfcf50544a8d1db805c1151" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it until it can no longer be expanded.</source>
          <target state="translated">Получает узел AST и расширяет его до тех пор,пока не сможет быть расширен.</target>
        </trans-unit>
        <trans-unit id="157d1b07d7f33e05788480f92dab05c717cb2225" translate="yes" xml:space="preserve">
          <source>Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">Получает анонимную функцию и аристику и форматирует ее,как показано в стековых трассах.Также arity может быть списком аргументов.</target>
        </trans-unit>
        <trans-unit id="828e3869ea6e3d553f5eaefa42fd41690b88d620" translate="yes" xml:space="preserve">
          <source>Receives any argument (not just booleans) and returns &lt;code&gt;true&lt;/code&gt; if the argument is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;; returns &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Принимает любой аргумент (а не только логические) и возвращает &lt;code&gt;true&lt;/code&gt; если аргумент равен &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;nil&lt;/code&gt; ; в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c743fb2a47a95b2574687dfecdcb831b67c205c2" translate="yes" xml:space="preserve">
          <source>Receives any value (not just booleans) and returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;; returns &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Получает любое значение (не только логические) и возвращает &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;value&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; или равно &lt;code&gt;nil&lt;/code&gt; ; в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca67f922cda85a2c22c1236201d70d4e42246095" translate="yes" xml:space="preserve">
          <source>Receives command-line arguments and performs compilation. If it produces errors, warnings, or any other diagnostic information, it should return a tuple with the status and a list of diagnostics.</source>
          <target state="translated">Получает аргументы командной строки и выполняет компиляцию.Если она выдает ошибки,предупреждения или любую другую диагностическую информацию,то должна возвращать кортеж со статусом и списком диагностик.</target>
        </trans-unit>
        <trans-unit id="43850c741265049e669da2f26b793fdc8099376d" translate="yes" xml:space="preserve">
          <source>Receives two log levels and compares the &lt;code&gt;left&lt;/code&gt; level against the &lt;code&gt;right&lt;/code&gt; level and returns:</source>
          <target state="translated">Получает два уровня журнала, сравнивает &lt;code&gt;left&lt;/code&gt; уровень с &lt;code&gt;right&lt;/code&gt; и возвращает:</target>
        </trans-unit>
        <trans-unit id="db37e93aec89a6614c4173a17f53a9d6b9aaf43e" translate="yes" xml:space="preserve">
          <source>Receives two options and must return &lt;code&gt;true&lt;/code&gt; if they refer to the same repository. The options are guaranteed to belong to the same SCM.</source>
          <target state="translated">Получает два параметра и должен возвращать &lt;code&gt;true&lt;/code&gt; если они относятся к одному и тому же репозиторию. Параметры гарантированно принадлежат одному и тому же SCM.</target>
        </trans-unit>
        <trans-unit id="95c9f8acfe3b80419501346e27b07cd7c2e9cb26" translate="yes" xml:space="preserve">
          <source>Receiving &quot;regular&quot; messages</source>
          <target state="translated">Получение &quot;регулярных&quot; сообщений</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="874c8febf7705c239b56db21c6da13bb314c78a3" translate="yes" xml:space="preserve">
          <source>Recompiles and reloads the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Перекомпилирует и перезагружает данный &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4fd4d9956d6c550135e0c055d986e451b87cd45" translate="yes" xml:space="preserve">
          <source>Recompiles the current Mix application.</source>
          <target state="translated">Перекомпилирует текущее приложение Mix.</target>
        </trans-unit>
        <trans-unit id="5956d214121812f6fd8d760fc2d0039205cb4995" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression and raises &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.CompileError.html&quot;&gt;&lt;code&gt;Regex.CompileError&lt;/code&gt;&lt;/a&gt; in case of errors.</source>
          <target state="translated">Перекомпилирует существующее регулярное выражение и в случае ошибки вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.CompileError.html&quot;&gt; &lt;code&gt;Regex.CompileError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cbd52477e5a038bbc04e1ed928ac44c43841076" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression and raises &lt;a href=&quot;regex.compileerror&quot;&gt;&lt;code&gt;Regex.CompileError&lt;/code&gt;&lt;/a&gt; in case of errors.</source>
          <target state="translated">Перекомпилирует существующее регулярное выражение и в случае ошибки вызывает &lt;a href=&quot;regex.compileerror&quot;&gt; &lt;code&gt;Regex.CompileError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9512d561ed1cc337da6646bba4a0fe0f82cc1019" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression if necessary.</source>
          <target state="translated">При необходимости перекомпилирует существующее регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="1c54132b8e5a9fa44a9a1a7d30b1be36ab3c4247" translate="yes" xml:space="preserve">
          <source>Record</source>
          <target state="translated">Record</target>
        </trans-unit>
        <trans-unit id="f92fd6b1074e6e79dfba76d8cd7647ef66632e5a" translate="yes" xml:space="preserve">
          <source>Records are simply tuples where the first element is an atom:</source>
          <target state="translated">Записи-это просто кортежи,где первым элементом является атом:</target>
        </trans-unit>
        <trans-unit id="8f1975a7def41720ec9c94792bc4fc65a7c012e4" translate="yes" xml:space="preserve">
          <source>Recursion</source>
          <target state="translated">Recursion</target>
        </trans-unit>
        <trans-unit id="1e9eb42c791ec696e90bc24ffe375c923de0f651" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail call&lt;/a&gt; optimization are an important part of Elixir and are commonly used to create loops. However, when programming in Elixir you will rarely use recursion as above to manipulate lists.</source>
          <target state="translated">Рекурсия и оптимизация &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;хвостовых вызовов&lt;/a&gt; являются важной частью Elixir и обычно используются для создания циклов. Однако при программировании на Эликсире вы редко будете использовать рекурсию, как указано выше, для управления списками.</target>
        </trans-unit>
        <trans-unit id="90e048b53959a81bc3861b57069e375346d404f4" translate="yes" xml:space="preserve">
          <source>Recursively escapes a value so it can be inserted into a syntax tree.</source>
          <target state="translated">Рекурсивно ускользает от значения,чтобы его можно было вставить в синтаксическое дерево.</target>
        </trans-unit>
        <trans-unit id="9aa5f460115ac32f0d34ca300a72820b95cfe5a4" translate="yes" xml:space="preserve">
          <source>Redefining existing operators</source>
          <target state="translated">Переопределение существующих операторов</target>
        </trans-unit>
        <trans-unit id="7be6f3bbac5cc51e4aafe0612e17d33124d8093b" translate="yes" xml:space="preserve">
          <source>Reduce (sometimes called &lt;code&gt;fold&lt;/code&gt;) is a basic building block in functional programming. Almost all of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be implemented on top of reduce. Those functions often rely on other operations, such as &lt;a href=&quot;#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;, which are optimized by the runtime.</source>
          <target state="translated">Сокращение (иногда называемое &lt;code&gt;fold&lt;/code&gt; ) является основным строительным блоком в функциональном программировании. Почти все функции модуля &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; могут быть реализованы поверх reduce. Эти функции часто полагаются на другие операции, такие как &lt;a href=&quot;#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt; , которые оптимизируются средой выполнения.</target>
        </trans-unit>
        <trans-unit id="5ec592dbd43af61e2cbf6d03b3e9ee6ca088c0f2" translate="yes" xml:space="preserve">
          <source>Reduce (sometimes called &lt;code&gt;fold&lt;/code&gt;) is a basic building block in functional programming. Almost all of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be implemented on top of reduce. Those functions often rely on other operations, such as &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;, which are optimized by the runtime.</source>
          <target state="translated">Сокращение (иногда называемое &lt;code&gt;fold&lt;/code&gt; ) является основным строительным блоком в функциональном программировании. Почти все функции модуля &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; могут быть реализованы поверх reduce. Эти функции часто полагаются на другие операции, такие как &lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt; , которые оптимизируются средой выполнения.</target>
        </trans-unit>
        <trans-unit id="95a8f2e0d9b4cee6851a4ae983d29171ececc54e" translate="yes" xml:space="preserve">
          <source>Reduce and map algorithms</source>
          <target state="translated">Уменьшить и отобразить алгоритмы</target>
        </trans-unit>
        <trans-unit id="32ab9de27d58bcc7d4d54b8d17c7484a6d29e607" translate="yes" xml:space="preserve">
          <source>Reduce as a building block</source>
          <target state="translated">Сократить как строительный блок</target>
        </trans-unit>
        <trans-unit id="6b8baf4751a0c397c470aa1b489e04d78981d396" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;enumerable&lt;/code&gt; until &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, term}&lt;/code&gt;.</source>
          <target state="translated">Уменьшает &lt;code&gt;enumerable&lt;/code&gt; до тех пор, пока не вернется &lt;code&gt;fun&lt;/code&gt; &lt;code&gt;{:halt, term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3fe1324757a1c4900c6719d6fc7cfb276e4826c" translate="yes" xml:space="preserve">
          <source>Reduces the &lt;code&gt;enumerable&lt;/code&gt; into an element.</source>
          <target state="translated">Уменьшает &lt;code&gt;enumerable&lt;/code&gt; до элемента.</target>
        </trans-unit>
        <trans-unit id="2dbe68b1eeba6b24ea1fba9cc612db280c6c2f67" translate="yes" xml:space="preserve">
          <source>Reenables a given task so it can be executed again down the stack.</source>
          <target state="translated">Возвращает заданную задачу,чтобы ее можно было снова выполнить в стеке.</target>
        </trans-unit>
        <trans-unit id="3b03cbaefa850378932be35a87004bee63b000cd" translate="yes" xml:space="preserve">
          <source>Reference - a unique value in the runtime system, created with &lt;a href=&quot;#make_ref/0&quot;&gt;&lt;code&gt;make_ref/0&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Ссылка - уникальное значение в системе времени выполнения, созданное с помощью &lt;a href=&quot;#make_ref/0&quot;&gt; &lt;code&gt;make_ref/0&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51ad2be02b9697cd310cca4ee9b8b7aa0b47c088" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@callback&lt;/code&gt; by prepending &lt;code&gt;c:&lt;/code&gt;, as in &lt;code&gt;`c:world/1`&lt;/code&gt;.</source>
          <target state="translated">Ссылка на &lt;code&gt;@callback&lt;/code&gt; , предваряя &lt;code&gt;c:&lt;/code&gt; , как в &lt;code&gt;`c:world/1`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dbfb2cc2895149d87c5f4f6bbe82a4d53911ad9" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@type&lt;/code&gt; by prepending &lt;code&gt;t:&lt;/code&gt;, as in &lt;code&gt;`t:values/0`&lt;/code&gt;.</source>
          <target state="translated">Ссылка на &lt;code&gt;@type&lt;/code&gt; , предваряя &lt;code&gt;t:&lt;/code&gt; , как в &lt;code&gt;`t:values/0`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59cb3fcffb3799341188ccd1da595b261b4be7ab" translate="yes" xml:space="preserve">
          <source>Reference and functions for working with protocols.</source>
          <target state="translated">Ссылка и функции для работы с протоколами.</target>
        </trans-unit>
        <trans-unit id="98efd6e2a6b118bb5b50c8bbc16e0f5cd3315ce0" translate="yes" xml:space="preserve">
          <source>Reference functions by name and arity if they are local, as in &lt;code&gt;`world/1`&lt;/code&gt;, or by module, name and arity if pointing to an external module: &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt;.</source>
          <target state="translated">Ссылки на функции по имени и арности, если они локальные, как в &lt;code&gt;`world/1`&lt;/code&gt; , или по модулю, имени и арности, если они указывают на внешний модуль: &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26fa88e9bd1e552c7f736c12a86e4b0eb3d12567" translate="yes" xml:space="preserve">
          <source>Reference modules by their full name.</source>
          <target state="translated">Справочные модули по их полному наименованию.</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="105376683ec11cee0e5b5973530213234a5fd201" translate="yes" xml:space="preserve">
          <source>Refute received with an explicit timeout:</source>
          <target state="translated">Опровержение получено с явным таймаутом:</target>
        </trans-unit>
        <trans-unit id="8fd8f41db359717b5f94a5befb85555200773286" translate="yes" xml:space="preserve">
          <source>Regardless of whether &lt;code&gt;=&amp;gt;&lt;/code&gt; or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity:</source>
          <target state="translated">Независимо от того, используется ли &lt;code&gt;=&amp;gt;&lt;/code&gt; или синтаксис ключевого слова, пары ключ-значение на картах всегда для простоты внутренне представлены в виде списка двухэлементных кортежей:</target>
        </trans-unit>
        <trans-unit id="6e681935761236016678d2656c1d667f0fe6fdac" translate="yes" xml:space="preserve">
          <source>Regex</source>
          <target state="translated">Regex</target>
        </trans-unit>
        <trans-unit id="ea0563594d23ed77538002a13830e067953e4a2b" translate="yes" xml:space="preserve">
          <source>Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's &lt;code&gt;:re&lt;/code&gt; module. More information can be found in the &lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt;&lt;code&gt;:re&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">Regex основан на PCRE (Perl-совместимые регулярные выражения) и построен на основе модуля Erlang &lt;code&gt;:re&lt;/code&gt; . Дополнительную информацию можно найти в &lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt;документации модуля &lt;/a&gt; &lt;code&gt;:re&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e7ac6184c6bddf346a5bb04f8cb4bb31ff3c577" translate="yes" xml:space="preserve">
          <source>Regex supports several built in named character classes. These are used by enclosing the class name in &lt;code&gt;[: :]&lt;/code&gt; inside a group. For example:</source>
          <target state="translated">Regex поддерживает несколько встроенных именованных классов символов. Они используются путем включения имени класса в &lt;code&gt;[: :]&lt;/code&gt; внутри группы. Например:</target>
        </trans-unit>
        <trans-unit id="8f4773b8001d2a236f1f42a57de7334762ef6a6f" translate="yes" xml:space="preserve">
          <source>Regex.CompileError</source>
          <target state="translated">Regex.CompileError</target>
        </trans-unit>
        <trans-unit id="2b2c167065a8849bc602af6807d29b6301a6af4e" translate="yes" xml:space="preserve">
          <source>Regex.CompileError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Regex.CompileError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="921e80bd802450f0a54f55dc59c8a5c73048f3e4" translate="yes" xml:space="preserve">
          <source>Registering under a unique registry does not allow multiple entries:</source>
          <target state="translated">Регистрация в уникальном реестре не позволяет вносить несколько записей:</target>
        </trans-unit>
        <trans-unit id="8b68501359664aa7e3f357030fc262fc752fa96a" translate="yes" xml:space="preserve">
          <source>Registers a &lt;code&gt;pluralization&lt;/code&gt; for &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">Регистрирует &lt;code&gt;pluralization&lt;/code&gt; для &lt;code&gt;word&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ed12562caa517bd68845482c54c6b549957f99" translate="yes" xml:space="preserve">
          <source>Registers a function that will be invoked at the end of an Elixir script. A script is typically started via the command line via the &lt;code&gt;elixir&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; executables.</source>
          <target state="translated">Регистрирует функцию, которая будет вызываться в конце сценария Эликсира. Сценарий обычно запускается из командной строки через исполняемые файлы &lt;code&gt;elixir&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfbc6d24a7a7f0d56fb406aa6036b3e12ffb8353" translate="yes" xml:space="preserve">
          <source>Registers a function that will be invoked at the end of program execution. Useful for invoking a hook in &quot;script&quot; mode.</source>
          <target state="translated">Регистрирует функцию,которая будет вызвана в конце выполнения программы.Полезен для вызова крюка в режиме &quot;скрипт&quot;.</target>
        </trans-unit>
        <trans-unit id="2177c0410d7f5895415b852d1e80afeff722f655" translate="yes" xml:space="preserve">
          <source>Registers a function to be invoked after the IEx process is spawned.</source>
          <target state="translated">Регистрирует функцию,которая будет вызвана после запуска IEx-процесса.</target>
        </trans-unit>
        <trans-unit id="b7cdc0be7757e71f965b3c7ad3fb440f76e506dd" translate="yes" xml:space="preserve">
          <source>Registers a function to run as part of this case.</source>
          <target state="translated">Регистрирует функцию,которая должна выполняться как часть этого дела.</target>
        </trans-unit>
        <trans-unit id="b973e327e3c021c877cc4d29399fa35fa83e3213" translate="yes" xml:space="preserve">
          <source>Registers a new attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">Регистрирует новый атрибут, который будет использоваться во &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; тестов ExUnit.Case .</target>
        </trans-unit>
        <trans-unit id="583a8d9a759b7139876cb9b18fbc6688dbc5db4b" translate="yes" xml:space="preserve">
          <source>Registers a new describe attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">Регистрирует новый атрибут описания, который будет использоваться во &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; тестов ExUnit.Case .</target>
        </trans-unit>
        <trans-unit id="ab70f6a8bd63201ad0973a2ca0e7972e2ffc3bc3" translate="yes" xml:space="preserve">
          <source>Registers a new module attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">Регистрирует новый атрибут модуля, который будет использоваться во &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; тестов ExUnit.Case .</target>
        </trans-unit>
        <trans-unit id="0e8cf2b4cc8729f25da603ab355783aa05318c46" translate="yes" xml:space="preserve">
          <source>Registers a program exit handler function.</source>
          <target state="translated">Регистрирует функцию обработчика выхода из программы.</target>
        </trans-unit>
        <trans-unit id="86f9550834cf29f2c28787220b59431f4c42e38c" translate="yes" xml:space="preserve">
          <source>Registers an attribute.</source>
          <target state="translated">Регистрирует атрибут.</target>
        </trans-unit>
        <trans-unit id="949e454436ebf7fa4a322e7a723b37231ac63ba1" translate="yes" xml:space="preserve">
          <source>Registers the current process under the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">Регистрирует текущий процесс под заданным &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;registry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5cea0af6cc948234d2b641ef218832cc68cbc8f" translate="yes" xml:space="preserve">
          <source>Registers the default &lt;code&gt;port&lt;/code&gt; for the given &lt;code&gt;scheme&lt;/code&gt;.</source>
          <target state="translated">Регистрирует &lt;code&gt;port&lt;/code&gt; по умолчанию для данной &lt;code&gt;scheme&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f29bbe119d2296da4e21436992a76df3eb6cb3e" translate="yes" xml:space="preserve">
          <source>Registers the given &lt;code&gt;pid_or_port&lt;/code&gt; under the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Регистрирует указанный &lt;code&gt;pid_or_port&lt;/code&gt; под заданным &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dddbe6429e016c47c4e1888ab89c26f58346135b" translate="yes" xml:space="preserve">
          <source>Registrations</source>
          <target state="translated">Registrations</target>
        </trans-unit>
        <trans-unit id="435305e548b36c7d783e828784397c394c2d994b" translate="yes" xml:space="preserve">
          <source>Registries can also be used to implement a local, non-distributed, scalable PubSub by relying on the &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; function, similarly to the previous section: in this case, however, we will send messages to each associated process, instead of invoking a given module-function.</source>
          <target state="translated">Реестры также могут использоваться для реализации локального нераспределенного масштабируемого PubSub, полагаясь на функцию &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; , аналогично предыдущему разделу: однако в этом случае мы будем отправлять сообщения каждому связанному процессу вместо того, чтобы вызывать данный модуль-функция.</target>
        </trans-unit>
        <trans-unit id="1fd6a805dae745c87a8b89f1be1a738e608a1668" translate="yes" xml:space="preserve">
          <source>Registry</source>
          <target state="translated">Registry</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">Регулярные выражения</target>
        </trans-unit>
        <trans-unit id="dbb5498e44eab5d71617ba625dacbfc1473d84fe" translate="yes" xml:space="preserve">
          <source>Regular expressions built with sigil are precompiled and stored in &lt;code&gt;.beam&lt;/code&gt; files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt; or similar) or released on the host (via &lt;code&gt;mix releases&lt;/code&gt; or similar) with a matching OTP, OS and architecture as as the target.</source>
          <target state="translated">Регулярные выражения, построенные с помощью sigil, предварительно компилируются и сохраняются в файлах &lt;code&gt;.beam&lt;/code&gt; . Предварительно скомпилированные регулярные выражения будут проверяться во время выполнения и могут работать медленнее между операционными системами и выпусками OTP. Это редко является проблемой, поскольку большая часть кода Elixir, совместно используемого во время разработки, компилируется на целевом объекте (например, зависимости, архивы и секретные коды), а при запуске в производственной среде код должен быть скомпилирован на целевом объекте (с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; или аналогичного ) или выпущены на хосте (через &lt;code&gt;mix releases&lt;/code&gt; или аналогичные) с соответствующими OTP, ОС и архитектурой в качестве цели.</target>
        </trans-unit>
        <trans-unit id="c18d56d63d8904587c2f989ef872b0c37d5a9db3" translate="yes" xml:space="preserve">
          <source>Regular expressions built with sigil are precompiled and stored in &lt;code&gt;.beam&lt;/code&gt; files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt; or similar) or released on the host (via &lt;code&gt;mix releases&lt;/code&gt; or similar) with a matching OTP, operating system and architecture as the target.</source>
          <target state="translated">Регулярные выражения, построенные с помощью sigil, предварительно компилируются и сохраняются в файлах &lt;code&gt;.beam&lt;/code&gt; . Предварительно скомпилированные регулярные выражения будут проверяться во время выполнения и могут работать медленнее между операционными системами и выпусками OTP. Это редко является проблемой, поскольку большая часть кода Elixir, совместно используемого во время разработки, компилируется на целевом объекте (например, зависимости, архивы и секретные коды), а при запуске в производственной среде код должен быть скомпилирован на целевом объекте (с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; или аналогичного ) или выпущены на хосте (через &lt;code&gt;mix releases&lt;/code&gt; или аналогичные) с соответствующими OTP, операционной системой и архитектурой в качестве цели.</target>
        </trans-unit>
        <trans-unit id="ce246b29555944fc83b19767b567b76c5bfeb132" translate="yes" xml:space="preserve">
          <source>Regular expressions created via sigils are pre-compiled and stored in the &lt;code&gt;.beam&lt;/code&gt; file. Note that this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information.</source>
          <target state="translated">Регулярные выражения, созданные с помощью сигилов, предварительно компилируются и сохраняются в файле &lt;code&gt;.beam&lt;/code&gt; . Обратите внимание, что это может быть проблемой, если вы предварительно компилируете Elixir, см. Раздел &amp;laquo;Предварительная компиляция&amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="75480c7e2a8cd4b557d0d4e69e47d2fba660d6e0" translate="yes" xml:space="preserve">
          <source>Regular expressions created via sigils are pre-compiled and stored in the &lt;code&gt;.beam&lt;/code&gt; file. Notice this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information.</source>
          <target state="translated">Регулярные выражения, созданные с помощью сигилов, предварительно компилируются и сохраняются в файле &lt;code&gt;.beam&lt;/code&gt; . Обратите внимание, что это может быть проблемой, если вы предварительно компилируете Elixir. Дополнительные сведения см. В разделе &amp;laquo;Предварительная компиляция&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7e228ec906344d281422481da789e9a8c7ed3c4b" translate="yes" xml:space="preserve">
          <source>Regular expressions in Elixir can be created using the sigils &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;~R&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_R/2&quot;&gt;&lt;code&gt;Kernel.sigil_R/2&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Регулярные выражения в Elixir могут быть созданы с помощью сигилов &lt;code&gt;~r&lt;/code&gt; (см. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; ) или &lt;code&gt;~R&lt;/code&gt; (см. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_R/2&quot;&gt; &lt;code&gt;Kernel.sigil_R/2&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="662de58b3e1c7961e52834df747a357eb8207007" translate="yes" xml:space="preserve">
          <source>Regular expressions in Elixir can be created using the sigils &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;~R&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_R/2&quot;&gt;&lt;code&gt;Kernel.sigil_R/2&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Регулярные выражения в Elixir могут быть созданы с помощью сигилов &lt;code&gt;~r&lt;/code&gt; (см. &lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; ) или &lt;code&gt;~R&lt;/code&gt; (см. &lt;a href=&quot;kernel#sigil_R/2&quot;&gt; &lt;code&gt;Kernel.sigil_R/2&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="33dc63899c782dfe565d47daa688821ea2c061ac" translate="yes" xml:space="preserve">
          <source>Reigsters a test with the given environment.</source>
          <target state="translated">Рейгстерский тест с заданной средой.</target>
        </trans-unit>
        <trans-unit id="8fa41d59c259d95cfaded10953d5a2f8e0b38bb4" translate="yes" xml:space="preserve">
          <source>Releases</source>
          <target state="translated">Releases</target>
        </trans-unit>
        <trans-unit id="da14bf586c00c0b2d6a162b461c2222bd3a8fda0" translate="yes" xml:space="preserve">
          <source>Releases allow developers to precompile and package all of their code and the runtime into a single unit. The benefits of releases are:</source>
          <target state="translated">Релизы позволяют разработчикам прекомпилировать и упаковать весь свой код и время выполнения в одну единицу.Преимуществами релизов являются:</target>
        </trans-unit>
        <trans-unit id="c6e22d2a45a39c91d823d515c586ebf0bbb7339d" translate="yes" xml:space="preserve">
          <source>Releases also provide built-in hooks for configuring almost every need of the production system:</source>
          <target state="translated">В релизах также имеются встроенные крючки для конфигурирования практически каждой потребности производственной системы:</target>
        </trans-unit>
        <trans-unit id="a98ea8e5fe18fa20e35b285b416e9080c681c806" translate="yes" xml:space="preserve">
          <source>Releases also supports custom mechanisms, called config providers, to load any sort of runtime configuration to the system while it boots. For instance, if you need to access a vault or load configuration from a JSON file, it can be achieved with config providers. The runtime configuration outlined in the previous section, which is handled by the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html&quot;&gt;&lt;code&gt;Config.Reader&lt;/code&gt;&lt;/a&gt; provider. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Provider.html&quot;&gt;&lt;code&gt;Config.Provider&lt;/code&gt;&lt;/a&gt; module for more information and more examples.</source>
          <target state="translated">Релизы также поддерживают настраиваемые механизмы, называемые поставщиками конфигурации, для загрузки любой конфигурации времени выполнения в систему во время ее загрузки. Например, если вам нужно получить доступ к хранилищу или загрузить конфигурацию из файла JSON, это можно сделать с помощью поставщиков конфигурации. Конфигурация среды выполнения, &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html&quot;&gt; &lt;code&gt;Config.Reader&lt;/code&gt; &lt;/a&gt; в предыдущем разделе, которая обрабатывается поставщиком Config.Reader . См. Модуль &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Provider.html&quot;&gt; &lt;code&gt;Config.Provider&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации и дополнительных примеров.</target>
        </trans-unit>
        <trans-unit id="4cae294f1ed142ab204367e07015be3d423fed8f" translate="yes" xml:space="preserve">
          <source>Releases are well integrated with umbrella projects, allowing you to release one or more subsets of your umbrella children. The only difference between performing a release in the umbrella project compared to a regular application is that umbrellas require you to explicitly list your release and the starting point for each release. For example, imagine this umbrella applications:</source>
          <target state="translated">Релизы хорошо интегрированы с зонтиком проектов,что позволяет выпустить один или несколько подмножеств ваших детей зонтик.Единственное различие между выполнением релиза в проекте зонтик по сравнению с обычным приложением является то,что зонтики требуют,чтобы вы явно перечислить ваш выпуск и отправной точкой для каждого релиза.Например,представьте себе этот зонтик приложений:</target>
        </trans-unit>
        <trans-unit id="ac2e1d2cd0964546138b0360f4dc93a204d6dfac" translate="yes" xml:space="preserve">
          <source>Releases provides two mechanisms for configuring OTP applications: build-time and runtime.</source>
          <target state="translated">Релизы предоставляют два механизма настройки OTP-приложений:время сборки и время исполнения.</target>
        </trans-unit>
        <trans-unit id="c9ca4a52a1dd10eb55da61c20c8394066a84c979" translate="yes" xml:space="preserve">
          <source>Relevant Type(s)</source>
          <target state="translated">Соответствующий(ие)Тип(ы)</target>
        </trans-unit>
        <trans-unit id="a5e5c7fbabf94e041bedf3cf78e00e95d579c10d" translate="yes" xml:space="preserve">
          <source>Remember Elixir makes a distinction between anonymous functions and named functions, where the former must be invoked with a dot (&lt;code&gt;.&lt;/code&gt;) between the variable name and parentheses. The capture operator bridges this gap by allowing named functions to be assigned to variables and passed as arguments in the same way we assign, invoke and pass anonymous functions.</source>
          <target state="translated">Помните, что в Elixir проводится различие между анонимными функциями и именованными функциями, где первые должны вызываться точкой ( &lt;code&gt;.&lt;/code&gt; ) Между именем переменной и круглыми скобками. Оператор захвата заполняет этот пробел, позволяя назначать именованные функции переменным и передавать их в качестве аргументов так же, как мы назначаем, вызываем и передаем анонимные функции.</target>
        </trans-unit>
        <trans-unit id="943e7d08a29ef9d83c317d0436320ee8105342c6" translate="yes" xml:space="preserve">
          <source>Remember however that our &lt;code&gt;KV.Registry&lt;/code&gt; is both linking (via &lt;code&gt;start_link&lt;/code&gt;) and monitoring (via &lt;code&gt;monitor&lt;/code&gt;) bucket processes in the &lt;code&gt;handle_cast/2&lt;/code&gt; callback:</source>
          <target state="translated">Однако помните, что наш &lt;code&gt;KV.Registry&lt;/code&gt; связывает (через &lt;code&gt;start_link&lt;/code&gt; ) и отслеживает (через &lt;code&gt;monitor&lt;/code&gt; ) процессы корзины в обратном вызове handle_cast &lt;code&gt;handle_cast/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2339016231a3f611f706a0ff8268e0aeed0a9afe" translate="yes" xml:space="preserve">
          <source>Remember lists are literals, so they are represented as themselves in the AST:</source>
          <target state="translated">Помните,что списки являются буквальными,поэтому они представлены как сами по себе в AST:</target>
        </trans-unit>
        <trans-unit id="a9201bbeed5d03751538444a9bdfa2b7a2f29888" translate="yes" xml:space="preserve">
          <source>Remember that the name of a process can be any atom. So far, we have named processes with the same name as the modules that define their implementation. For example, the process defined by &lt;code&gt;KV.Registry&lt;/code&gt; was given a process name of &lt;code&gt;KV.Registry&lt;/code&gt;. This is simply a convention: If later there is an error in your system that says, &amp;ldquo;process named KV.Registry crashed with reason&amp;rdquo;, we know exactly where to investigate.</source>
          <target state="translated">Помните, что имя процесса может быть любым атомом. До сих пор мы называли процессы теми же именами, что и модули, определяющие их реализацию. Например, процессу, определенному &lt;code&gt;KV.Registry&lt;/code&gt; , было присвоено имя процесса &lt;code&gt;KV.Registry&lt;/code&gt; . Это просто соглашение: если позже в вашей системе появится ошибка, которая гласит: &amp;laquo;Процесс с именем KV.Registry завершился с ошибкой по причине&amp;raquo;, мы точно знаем, где исследовать.</target>
        </trans-unit>
        <trans-unit id="a23460e1d638c5436d4d647608a0c43461b2bb03" translate="yes" xml:space="preserve">
          <source>Remember that, because lists and two-element tuples are quoted literals, by definition keywords are also literals (in fact, the only reason tuples with two elements are quoted literals is to support keywords as literals).</source>
          <target state="translated">Помните,что поскольку списки и кортежи с двумя элементами являются кавычками,по определению ключевые слова также являются литералами (на самом деле,единственная причина,по которой кортежи с двумя элементами являются кавычками,это поддержка ключевых слов в качестве литералов).</target>
        </trans-unit>
        <trans-unit id="23ca97c0da01ca937235d0fce860a266449eb7f4" translate="yes" xml:space="preserve">
          <source>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Помните, что эта функция работает с графемами Unicode и считает, что срезы представляют смещения графем. Если вы хотите разделить на необработанные байты, проверьте вместо этого &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="547521c843600e88d013eb66991d1b7a08d0987f" translate="yes" xml:space="preserve">
          <source>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Помните, что эта функция работает с графемами Unicode и считает, что срезы представляют смещения графемы. Если вы хотите разделить на необработанные байты, проверьте вместо этого &lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5668edb8bbd3eda0d96d572b8d98aa2a38819f28" translate="yes" xml:space="preserve">
          <source>Remember, comparisons in Elixir using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Помните, что сравнения в Elixir с использованием &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; и других являются структурными и основаны на полях структуры DateTime. Для правильного сравнения между датами используйте функцию &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="698cb20e961ee6d1a5f74b94b2a7a5aa2f31ae4b" translate="yes" xml:space="preserve">
          <source>Remember, comparisons in Elixir using &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Помните, что сравнения в Elixir с использованием &lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; и других являются структурными и основаны на полях структуры DateTime. Для правильного сравнения между датами используйте функцию &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3e2da127048c057fb60ede4b80ce4e8696a1366" translate="yes" xml:space="preserve">
          <source>Remember: by default, tasks will only run &lt;em&gt;once&lt;/em&gt;, even when called repeatedly! If you need to run a task multiple times, you need to re-enable it via &lt;a href=&quot;#reenable/1&quot;&gt;&lt;code&gt;reenable/1&lt;/code&gt;&lt;/a&gt; or call it using &lt;a href=&quot;#rerun/2&quot;&gt;&lt;code&gt;rerun/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Помните: по умолчанию задачи запускаются только &lt;em&gt;один раз&lt;/em&gt; , даже при повторном вызове! Если вам нужно запускать задачу несколько раз, вам нужно повторно включить ее с помощью &lt;a href=&quot;#reenable/1&quot;&gt; &lt;code&gt;reenable/1&lt;/code&gt; &lt;/a&gt; или вызвать ее с помощью &lt;a href=&quot;#rerun/2&quot;&gt; &lt;code&gt;rerun/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27bb052d1b6cca59f0d8b8e080407897e513da28" translate="yes" xml:space="preserve">
          <source>Remote shells</source>
          <target state="translated">Выносные корпуса</target>
        </trans-unit>
        <trans-unit id="12e6e0a5538b479310c7704c6dff0686bcae2732" translate="yes" xml:space="preserve">
          <source>Remote types</source>
          <target state="translated">Удаленные типы</target>
        </trans-unit>
        <trans-unit id="ad7183d89f1b9dc5b75d0fb7a74934c2fe82e722" translate="yes" xml:space="preserve">
          <source>Removes a backend.</source>
          <target state="translated">Снимает бэкэнд.</target>
        </trans-unit>
        <trans-unit id="6b3c529ef7158c6c64f36c40c48665d4b841a4dc" translate="yes" xml:space="preserve">
          <source>Removes a translator.</source>
          <target state="translated">Убирает переводчика.</target>
        </trans-unit>
        <trans-unit id="0e523878ea75291793b504604435509973416467" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Удаляет все точки останова и инструментарий из &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f725a049c858ae90de002f7c340c653cf53f9e1" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from all modules.</source>
          <target state="translated">Удаляет все точки останова и приборы из всех модулей.</target>
        </trans-unit>
        <trans-unit id="0c59f67c00483a329a14a7b40d25018f4823a4d1" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints on all modules.</source>
          <target state="translated">Удаляет все точки останова на всех модулях.</target>
        </trans-unit>
        <trans-unit id="5cde5498611d5dd73ab4c8f8109c899ca9bbce1f" translate="yes" xml:space="preserve">
          <source>Removes an element from a tuple.</source>
          <target state="translated">Удаляет элемент из кортежа.</target>
        </trans-unit>
        <trans-unit id="ca2eeb651ddbe44b65f869a519694352fefd12dc" translate="yes" xml:space="preserve">
          <source>Removes breakpoints in the given module.</source>
          <target state="translated">Удаляет точки останова в данном модуле.</target>
        </trans-unit>
        <trans-unit id="fafc63cde6615c4f223d05bb8ce9168548859c5d" translate="yes" xml:space="preserve">
          <source>Removes build artifacts and manifests.</source>
          <target state="translated">Удаляет строительные артефакты и манифесты.</target>
        </trans-unit>
        <trans-unit id="e12499048521db44dd18f757b10e57bb80774e3b" translate="yes" xml:space="preserve">
          <source>Removes files and directories recursively at the given &lt;code&gt;path&lt;/code&gt;. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail).</source>
          <target state="translated">Рекурсивно удаляет файлы и каталоги по заданному &lt;code&gt;path&lt;/code&gt; . Символьные ссылки не отслеживаются, а просто удаляются, несуществующие файлы просто игнорируются (т.е. не приводят к сбою этой функции).</target>
        </trans-unit>
        <trans-unit id="7baee7a478497d4737825218f8e15ac03e8c6030" translate="yes" xml:space="preserve">
          <source>Removes files from the required files list.</source>
          <target state="translated">Удаляет файлы из списка требуемых файлов.</target>
        </trans-unit>
        <trans-unit id="e097ba46638772c9b64fea773b1e61d5573174b4" translate="yes" xml:space="preserve">
          <source>Removes the entry with a given key from a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">Удаляет запись с заданным ключом из контейнера (карта, список ключевых слов или структура, реализующая поведение &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ab0917eb6c0ad48d41081c9212ed112569e33de" translate="yes" xml:space="preserve">
          <source>Removes the first occurrence of an element on the left list for each element on the right.</source>
          <target state="translated">Удаляет первое появление элемента в левом списке для каждого элемента справа.</target>
        </trans-unit>
        <trans-unit id="2610a285dc9b1c68c5713f9aeb89d588d07b8d11" translate="yes" xml:space="preserve">
          <source>Removes the link between the calling process and the given item (process or port).</source>
          <target state="translated">Удаляет связь между вызывающим процессом и данным элементом (процессом или портом).</target>
        </trans-unit>
        <trans-unit id="f877e19fb1fb1b9f68495b6349dc80d7ef2d3e8e" translate="yes" xml:space="preserve">
          <source>Removes the registered &lt;code&gt;name&lt;/code&gt;, associated with a PID or a port identifier.</source>
          <target state="translated">Удаляет зарегистрированное &lt;code&gt;name&lt;/code&gt; , связанное с PID или идентификатором порта.</target>
        </trans-unit>
        <trans-unit id="e0ea432075489bb401a38e905e6c792c65da38b3" translate="yes" xml:space="preserve">
          <source>Removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; and returns the value and the updated map.</source>
          <target state="translated">Удаляет значение, связанное с &lt;code&gt;key&lt;/code&gt; в &lt;code&gt;map&lt;/code&gt; и возвращает значение и обновленную карту.</target>
        </trans-unit>
        <trans-unit id="e182592a215c0c2641cada9adb28ed54322e302f" translate="yes" xml:space="preserve">
          <source>Removes the variable &lt;code&gt;varname&lt;/code&gt; from the environment.</source>
          <target state="translated">Удаляет переменную &lt;code&gt;varname&lt;/code&gt; из среды.</target>
        </trans-unit>
        <trans-unit id="6e1b55c9888c715281f3275cbe5053ffaabe0430" translate="yes" xml:space="preserve">
          <source>Renames the &lt;code&gt;source&lt;/code&gt; file to &lt;code&gt;destination&lt;/code&gt; file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the &lt;code&gt;destination&lt;/code&gt; filename, it is not sufficient to simply specify its directory.</source>
          <target state="translated">Переименовывает &lt;code&gt;source&lt;/code&gt; файл в файл &lt;code&gt;destination&lt;/code&gt; . Его можно использовать для перемещения файлов (и каталогов) между каталогами. При перемещении файла необходимо полностью указать имя файла &lt;code&gt;destination&lt;/code&gt; , недостаточно просто указать его каталог.</target>
        </trans-unit>
        <trans-unit id="a91f5880024e32c1ee837d1bf3b64cc8dc6671b0" translate="yes" xml:space="preserve">
          <source>Replaced by (available since)</source>
          <target state="translated">Заменено на (доступно с тех пор)</target>
        </trans-unit>
        <trans-unit id="3ae5fd3a5401d1295a4c3679a829706f16163c68" translate="yes" xml:space="preserve">
          <source>Replaces all leading occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; of &lt;code&gt;match&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Заменяет все ведущие вхождения &lt;code&gt;match&lt;/code&gt; по &lt;code&gt;replacement&lt;/code&gt; в &lt;code&gt;match&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58f3e85bfde4f7a00e1a21674d997cd1b50094da" translate="yes" xml:space="preserve">
          <source>Replaces all trailing occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Заменяет все завершающие вхождения &lt;code&gt;match&lt;/code&gt; по &lt;code&gt;replacement&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82d8aa6c1dd74b7f190708bea27805665c8cdf0e" translate="yes" xml:space="preserve">
          <source>Replaces prefix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">Заменяет префикс в &lt;code&gt;string&lt;/code&gt; путем &lt;code&gt;replacement&lt;/code&gt; , если он соответствует &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c08818204c69c938d93f26169b6a54dc9d5f052e" translate="yes" xml:space="preserve">
          <source>Replaces suffix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">Заменяет суффикс в &lt;code&gt;string&lt;/code&gt; на &lt;code&gt;replacement&lt;/code&gt; если он соответствует &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61b72516eacbd25292524ef703f00e3b0cd63290" translate="yes" xml:space="preserve">
          <source>Replies to a client.</source>
          <target state="translated">Отвечает клиенту.</target>
        </trans-unit>
        <trans-unit id="fb22e2a0db174fb8119ed900f8cb0958c5ae7ca6" translate="yes" xml:space="preserve">
          <source>Report message (maps or keywords):</source>
          <target state="translated">Сообщение о сообщении (карты или ключевые слова):</target>
        </trans-unit>
        <trans-unit id="167f6ac2dbfd0e8be970571e54087bdd8130f746" translate="yes" xml:space="preserve">
          <source>Represents expressions in the AST</source>
          <target state="translated">Представляет выражения в AST</target>
        </trans-unit>
        <trans-unit id="9c6f57c3a5b6011834691a65157b80974d8047ca" translate="yes" xml:space="preserve">
          <source>Represents literals in the AST</source>
          <target state="translated">Представляет буквально в AST</target>
        </trans-unit>
        <trans-unit id="e9c366b4f3c3a1bf3449c6872aaeae5a0c5ecdf4" translate="yes" xml:space="preserve">
          <source>Requirement</source>
          <target state="translated">Requirement</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="412cfb34df55659000dc3fda9977411aa50f05bf" translate="yes" xml:space="preserve">
          <source>Requirements allow you to specify which versions of a given dependency you are willing to work against. Requirements support the common comparison operators such as &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt; that work as one would expect, and additionally the special operator &lt;code&gt;~&amp;gt;&lt;/code&gt; described in detail further below.</source>
          <target state="translated">Требования позволяют указать, с какими версиями данной зависимости вы хотите работать. Требования поддерживают общие операторы сравнения , такие как &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , Что работа , как и следовало ожидать, и дополнительно специальный оператор &lt;code&gt;~&amp;gt;&lt;/code&gt; подробно описано ниже.</target>
        </trans-unit>
        <trans-unit id="ffbcbcafa9cd3ab8fe7f3e0221d371de707c59bf" translate="yes" xml:space="preserve">
          <source>Requirements also support &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; for complex conditions:</source>
          <target state="translated">Требования также поддерживают &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; для сложных условий:</target>
        </trans-unit>
        <trans-unit id="0a37ffbe744b3419c856886db8581bb258bdd52c" translate="yes" xml:space="preserve">
          <source>Requires a module in order to use its macros.</source>
          <target state="translated">Требуется модуль для использования макросов.</target>
        </trans-unit>
        <trans-unit id="bdc77107aca48a34c1255f765ae312ea22e9d590" translate="yes" xml:space="preserve">
          <source>Requires only the &lt;code&gt;left&lt;/code&gt; operand to be a boolean since it short-circuits. If the &lt;code&gt;left&lt;/code&gt; operand is not a boolean, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Требуется, чтобы только &lt;code&gt;left&lt;/code&gt; операнд был логическим, поскольку он замыкается. Если &lt;code&gt;left&lt;/code&gt; операнд не является логическим, возникает исключение &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3fb12553d92bde63ec6c4c1afb010869938df0d" translate="yes" xml:space="preserve">
          <source>Requires only the &lt;code&gt;left&lt;/code&gt; operand to be a boolean since it short-circuits. If the &lt;code&gt;left&lt;/code&gt; operand is not a boolean, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Требуется, чтобы только &lt;code&gt;left&lt;/code&gt; операнд был логическим, поскольку он замыкается. Если &lt;code&gt;left&lt;/code&gt; операнд не является логическим, возникает исключение &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1457fddb0ccb7c73dde9fb1360f8c49c8b2b74" translate="yes" xml:space="preserve">
          <source>Requires the given &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">Требуется данный &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cda5e602ba0cf728e06b8efb2ddbc8599b5d662" translate="yes" xml:space="preserve">
          <source>Requires the given files in parallel.</source>
          <target state="translated">Требуются параллельно заданные файлы.</target>
        </trans-unit>
        <trans-unit id="652877b192a4527170621aec011fcd58f4d804ea" translate="yes" xml:space="preserve">
          <source>Reruns &lt;code&gt;task&lt;/code&gt; with the given arguments.</source>
          <target state="translated">Повторно запускает &lt;code&gt;task&lt;/code&gt; с заданными аргументами.</target>
        </trans-unit>
        <trans-unit id="3303b4d51ecd1f3dd58871e5e01ec85056396381" translate="yes" xml:space="preserve">
          <source>Reserved module names</source>
          <target state="translated">Зарезервированные имена модулей</target>
        </trans-unit>
        <trans-unit id="98d53aa320bfa9f3ee95a18c9df1aa09adb7fddb" translate="yes" xml:space="preserve">
          <source>Reserved words</source>
          <target state="translated">Зарезервированные слова</target>
        </trans-unit>
        <trans-unit id="97f4d7e17f03d2ddae5b33b0691e0061a8d5b3a6" translate="yes" xml:space="preserve">
          <source>Resets all attributes.</source>
          <target state="translated">Сбрасывает все атрибуты.</target>
        </trans-unit>
        <trans-unit id="0d3ace23ff1b1740ea142fd672118920a1baf0d8" translate="yes" xml:space="preserve">
          <source>Resets the breaks for the given &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt;.</source>
          <target state="translated">Сбрасывает разрывы для данного &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;function&lt;/code&gt; и &lt;code&gt;arity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b232329f032cba2e9b444d62650b47ec21e40ea" translate="yes" xml:space="preserve">
          <source>Resets the breaks on a given breakpoint ID.</source>
          <target state="translated">Сбрасывает перерывы на заданный ID точки останова.</target>
        </trans-unit>
        <trans-unit id="20e3b7449f8050f7eb4cdaf37779f0265636b2bb" translate="yes" xml:space="preserve">
          <source>Resets the current process metadata to the given keyword list.</source>
          <target state="translated">Сбрасывает текущие метаданные процесса в заданный список ключевых слов.</target>
        </trans-unit>
        <trans-unit id="49fdd1a2b23b0085e72c09b062efd4ecb9a18ed2" translate="yes" xml:space="preserve">
          <source>Resolves a &lt;a href=&quot;#t:config_path/0&quot;&gt;&lt;code&gt;config_path/0&lt;/code&gt;&lt;/a&gt; to an actual path.</source>
          <target state="translated">Устранена &lt;a href=&quot;#t:config_path/0&quot;&gt; &lt;code&gt;config_path/0&lt;/code&gt; &lt;/a&gt; до фактического пути.</target>
        </trans-unit>
        <trans-unit id="838ebc4a5cadbe62e4f28a82bbc20144b2308c44" translate="yes" xml:space="preserve">
          <source>Respawns the current shell by starting a new shell process.</source>
          <target state="translated">Возобновление текущей оболочки,запустив новый процесс оболочки.</target>
        </trans-unit>
        <trans-unit id="d924949f461a2178615fa560be4fcb1a11adc482" translate="yes" xml:space="preserve">
          <source>Restart values (:restart)</source>
          <target state="translated">Значения перезапуска (:перезапуск)</target>
        </trans-unit>
        <trans-unit id="6c1b23092774f1732bb40fd9217d2008cf95142c" translate="yes" xml:space="preserve">
          <source>Restarts a child process identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">Перезапускает дочерний процесс, идентифицированный &lt;code&gt;child_id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdda01d4f5a4d17bef26c81b5fb2b202c9529bae" translate="yes" xml:space="preserve">
          <source>Restarts all applications in the Erlang runtime system.</source>
          <target state="translated">Перезапускает все приложения в системе Erlang runtime.</target>
        </trans-unit>
        <trans-unit id="e9ef6fa952a1df9e86072dc44600b6f94a8e9045" translate="yes" xml:space="preserve">
          <source>Retrieves the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; level.</source>
          <target state="translated">Извлекает &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; уровень.</target>
        </trans-unit>
        <trans-unit id="9561c4c2ab77e3b4a8a77091d61310e40fe75523" translate="yes" xml:space="preserve">
          <source>Retrieves the current project if there is one.</source>
          <target state="translated">Возвращает текущий проект,если он есть.</target>
        </trans-unit>
        <trans-unit id="8108bc75c4a7082e6ac6f1000b099b62cbb5c8b6" translate="yes" xml:space="preserve">
          <source>Retrieves the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">Извлекает количество элементов в &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd62dedad93356267e6352b4bd2959e6c3d4a64b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; (v1.6)</source>
          <target state="translated">Вернуть &lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; или &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; warnings } (v1.6)</target>
        </trans-unit>
        <trans-unit id="9d42e2f739c476b4724ed40443cd1bdc8b0b0c31" translate="yes" xml:space="preserve">
          <source>Return values</source>
          <target state="translated">Возвращаемые значения</target>
        </trans-unit>
        <trans-unit id="1b92b78b25ceec1de641e02266e51c2ee955125b" translate="yes" xml:space="preserve">
          <source>Return values are the same as &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возвращаемые значения такие же, как &lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6510848f34f0555d205bfb994f51d205f3d74823" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">Возвращаемые значения в &lt;code&gt;start*&lt;/code&gt; функции</target>
        </trans-unit>
        <trans-unit id="9450659c5d952be2b0fe455eb08ad207bd303023" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_child&lt;/code&gt; functions</source>
          <target state="translated">Возвращаемые значения функций &lt;code&gt;start_child&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e9dd619fd23cd606de770ea4c2cbd74b2aa99e4" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_link&lt;/code&gt; functions</source>
          <target state="translated">Возвращаемые значения функций &lt;code&gt;start_link&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c27118a3f170210d140a1ccdbf570ddfe1f62448" translate="yes" xml:space="preserve">
          <source>Returned value will be the effective value used. If no value was set for given module then it will not be present in the returned list.</source>
          <target state="translated">Возвращаемое значение будет эффективным значением.Если для данного модуля не было установлено ни одного значения,то оно не будет присутствовать в возвращаемом списке.</target>
        </trans-unit>
        <trans-unit id="ffa9d4dbc4959fcd3296aae6ba1fdaf274079262" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">Возврат &lt;code&gt;:ignore&lt;/code&gt; приведет к тому, что &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; вернет &lt;code&gt;:ignore&lt;/code&gt; , и процесс завершится нормально, без входа в цикл или вызова &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; . Если он используется в качестве части дерева супервизора, родительский супервизор не сможет ни запустить, ни сразу же попытаться перезапустить &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . Оставшаяся часть дерева контроля будет запущена, поэтому &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; не будет требоваться для других процессов. Его можно запустить позже с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; ,&lt;/a&gt; поскольку дочерняя спецификация сохраняется в родительском супервизоре. Основные варианты использования для этого:</target>
        </trans-unit>
        <trans-unit id="71ad9db2f452d030849e70969695a7639a712f39" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">Возврат &lt;code&gt;:ignore&lt;/code&gt; приведет к тому, что &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; вернет &lt;code&gt;:ignore&lt;/code&gt; , и процесс завершится нормально, без входа в цикл или вызова &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; . Если он используется в качестве части дерева супервизора, родительский супервизор не сможет ни запустить, ни сразу же попытаться перезапустить &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . Будет запущена оставшаяся часть дерева надзора, поэтому &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; не потребуется другим процессам. Его можно будет запустить позже с помощью &lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; ,&lt;/a&gt; поскольку дочерняя спецификация сохраняется в родительском супервизоре. Основные варианты использования для этого:</target>
        </trans-unit>
        <trans-unit id="eb2f30a4d8bc7038c64e5d45423d1462692bb22a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ok&lt;/code&gt; leaves the context unchanged (in &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks).</source>
          <target state="translated">Возврат &lt;code&gt;:ok&lt;/code&gt; оставляет контекст неизменным (в обратных &lt;code&gt;setup_all&lt;/code&gt; &lt;code&gt;setup&lt;/code&gt; и setup_all ).</target>
        </trans-unit>
        <trans-unit id="d4f04b1fc86d756470bf59ce20599e81fba3d31e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:error, reason}&lt;/code&gt; fails the code change with reason &lt;code&gt;reason&lt;/code&gt; and the state remains as the previous state.</source>
          <target state="translated">При возврате &lt;code&gt;{:error, reason}&lt;/code&gt; код не изменяется с указанием &lt;code&gt;reason&lt;/code&gt; и состояние остается прежним.</target>
        </trans-unit>
        <trans-unit id="0592eb111cc826c0b5dc41fef3d96850ddf2ed2a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except the process is hibernated before continuing the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Возврат &lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; аналогичен &lt;code&gt;{:noreply, new_state}&lt;/code&gt; за исключением того, что процесс переводится в спящий режим перед продолжением цикла. См. &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="545abab29816f45f903fc69a76d6d258e74019ea" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except a timeout, hibernation or continue occurs as with a &lt;code&gt;:reply&lt;/code&gt; tuple.</source>
          <target state="translated">Возвращение &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; похоже на &lt;code&gt;{:noreply, new_state}&lt;/code&gt; за исключением того, что тайм-аут, переход в спящий режим или продолжение происходит как с кортежем &lt;code&gt;:reply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d632613338eb1516d1e171379de56d181565aa7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">Возврат &lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; аналогичен &lt;code&gt;{:noreply, new_state}&lt;/code&gt; за исключением того, что он также устанавливает тайм-аут. См. Раздел &amp;laquo;Таймауты&amp;raquo; в документации модуля для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b0dc3e574638c9f3a3a2cb97268326892e9c0517" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">Возврат &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; аналогичен &lt;code&gt;{:noreply, new_state}&lt;/code&gt; за исключением того , что handle_continue &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; будет вызываться сразу после этого со значением &lt;code&gt;continue&lt;/code&gt; в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="7c2e4427bf9da87b7975511fa77c0aa083a93e56" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">Возвращение &lt;code&gt;{:noreply, new_state}&lt;/code&gt; продолжает цикл с новым состоянием &lt;code&gt;new_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0bcdf8d79ea91a9b75d45685f07008e6bb07b7a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; does not send a response to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;. The response must be sent with &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возврат &lt;code&gt;{:noreply, new_state}&lt;/code&gt; не отправляет ответ вызывающей стороне и продолжает цикл с новым состоянием &lt;code&gt;new_state&lt;/code&gt; . Ответ должен быть отправлен с &lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4de3a02b60233fe036c0a08aa97987f8e91d073a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, contents}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; from &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt;&lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt;&lt;/a&gt;'s callback</source>
          <target state="translated">Возврат &lt;code&gt;{:ok, contents}&lt;/code&gt; или &lt;code&gt;:error&lt;/code&gt; из обратного вызова &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt; &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dc53c38e32cf54749c4b9b8b84a6ffad0f5456c" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, contents}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; from &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt;'s callback</source>
          <target state="translated">Возврат &lt;code&gt;{:ok, contents}&lt;/code&gt; или &lt;code&gt;:error&lt;/code&gt; из обратного вызова &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ce39defe2e667a1d9303cd7807fa9deb1f3dff7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, new_state}&lt;/code&gt; changes the state to &lt;code&gt;new_state&lt;/code&gt; and the code change is successful.</source>
          <target state="translated">Возврат &lt;code&gt;{:ok, new_state}&lt;/code&gt; изменяет состояние на &lt;code&gt;new_state&lt;/code&gt; , и изменение кода выполняется успешно.</target>
        </trans-unit>
        <trans-unit id="dda86c57299291383ba12cacce3b8a61cd3aca15" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except the process is hibernated before entering the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information on hibernation.</source>
          <target state="translated">Возврат &lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; аналогичен &lt;code&gt;{:ok, state}&lt;/code&gt; за исключением того, что процесс переводится в спящий режим перед входом в цикл. См. &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о гибернации.</target>
        </trans-unit>
        <trans-unit id="f4f89c1f4a5e07f563900cfccc5421ff9a8161b2" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt;, except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">Возврат &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; аналогичен &lt;code&gt;{:ok, state}&lt;/code&gt; , за исключением того, что он также устанавливает тайм-аут. См. Раздел &amp;laquo;Таймауты&amp;raquo; в документации модуля для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="367f39392e443be5033fcc0ce46cb9c7191866d5" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except that immediately after entering the loop the &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; callback will be invoked with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">Возвращение &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; аналогично &lt;code&gt;{:ok, state}&lt;/code&gt; за исключением того, что сразу после входа в цикл будет вызван обратный вызов &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;continue&lt;/code&gt; в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="4e7d4ebacb2fe086ff03c74440ab13b1423c917e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:ok, pid}&lt;/code&gt; and the process to enter its loop.</source>
          <target state="translated">Возврат &lt;code&gt;{:ok, state}&lt;/code&gt; заставит &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; вернуть &lt;code&gt;{:ok, pid}&lt;/code&gt; и процесс войдет в свой цикл.</target>
        </trans-unit>
        <trans-unit id="2ac7990d3774239b03711f323b97327318be9091" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except the process is hibernated and will continue the loop once a message is in its message queue. If a message is already in the message queue this will be immediately. Hibernating a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; causes garbage collection and leaves a continuous heap that minimises the memory used by the process.</source>
          <target state="translated">Возвращение &lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; аналогично &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; за исключением того, что процесс находится в спящем режиме и продолжит цикл после того, как сообщение окажется в очереди сообщений. Если сообщение уже находится в очереди сообщений, это будет немедленно выполнено. Гибернация &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; вызывает сборку мусора и оставляет непрерывную кучу, которая минимизирует память, используемую процессом.</target>
        </trans-unit>
        <trans-unit id="3664827e00957d1361f076b6c6180a5288429b1e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">Возврат &lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; аналогичен &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; за исключением того, что он также устанавливает время ожидания. См. Раздел &amp;laquo;Таймауты&amp;raquo; в документации модуля для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6f9c42293c17275b2da3909a5ac827406da8908f" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">Возврат &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; аналогичен &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; за исключением того , что handle_continue &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; будет вызываться сразу после этого со значением &lt;code&gt;continue&lt;/code&gt; в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="5d5e6464f7527865bd6d8be289ffe2a3685bee24" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; sends the response &lt;code&gt;reply&lt;/code&gt; to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">Возвращение &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; отправляет ответный &lt;code&gt;reply&lt;/code&gt; вызывающей стороне и продолжает цикл с новым состоянием &lt;code&gt;new_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="534c77debf0badc9c25487b18a7948694707f4bb" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; is similar to &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; except a reply is not sent.</source>
          <target state="translated">Возврат &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; аналогичен &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; за исключением того, что ответ не отправляется.</target>
        </trans-unit>
        <trans-unit id="25233abf67489667f36f12119719f8bf3ab79f10" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with the reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. The process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">При &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; цикл останавливается, а &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; вызывается с &lt;code&gt;new_state&lt;/code&gt; &lt;code&gt;reason&lt;/code&gt; и состояния new_state . Процесс завершается по разумной &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9446727789d28494af33768c5dd1be490cb2c928" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. Then the &lt;code&gt;reply&lt;/code&gt; is sent as the response to call and the process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">При &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; цикл останавливается, а &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; вызывается с &lt;code&gt;new_state&lt;/code&gt; &lt;code&gt;reason&lt;/code&gt; и состояния new_state . Затем &lt;code&gt;reply&lt;/code&gt; отправляется как ответ на вызов, и процесс завершается с указанием &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45b0ba5a4f231122f32567afd5046aeac5ca341b" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:error, reason}&lt;/code&gt; and the process to exit with reason &lt;code&gt;reason&lt;/code&gt; without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возврат &lt;code&gt;{:stop, reason}&lt;/code&gt; cause } приведет к тому, что &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; вернет &lt;code&gt;{:error, reason}&lt;/code&gt; cause }, и процесс завершится с указанием &lt;code&gt;reason&lt;/code&gt; не входя в цикл или не вызывая &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="201a82018e6ccab06f099ffcf6ad93f0589f0ac6" translate="yes" xml:space="preserve">
          <source>Returning anything else from &lt;code&gt;setup_all&lt;/code&gt; will force all tests to fail, while a bad response from &lt;code&gt;setup&lt;/code&gt; causes the current test to fail.</source>
          <target state="translated">Возврат чего-либо еще из &lt;code&gt;setup_all&lt;/code&gt; приведет к сбою всех тестов, в то время как плохой ответ от &lt;code&gt;setup&lt;/code&gt; приведет к сбою текущего теста.</target>
        </trans-unit>
        <trans-unit id="2ccc041e90cdcfa1031811c96f150b22c6b8ca9e" translate="yes" xml:space="preserve">
          <source>Returning to our &lt;code&gt;handle_cast/2&lt;/code&gt; implementation, you can see the registry is both linking and monitoring the buckets:</source>
          <target state="translated">Возвращаясь к нашей реализации &lt;code&gt;handle_cast/2&lt;/code&gt; , вы можете видеть, что реестр связывает и отслеживает сегменты:</target>
        </trans-unit>
        <trans-unit id="3999b945835bc6b25789a6d8bdd35064f0c4e298" translate="yes" xml:space="preserve">
          <source>Returning values</source>
          <target state="translated">Возвращаемые значения</target>
        </trans-unit>
        <trans-unit id="a86c48f96d918e08b84d079d9945718a4599bc5f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:error&lt;/code&gt; when an invalid call syntax is provided.</source>
          <target state="translated">Возвращает &lt;code&gt;:error&lt;/code&gt; если указан неверный синтаксис вызова.</target>
        </trans-unit>
        <trans-unit id="9ab2b4bc1a0b6cdb37b00adb4f725958544c088b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first date is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two dates are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">Возвращает &lt;code&gt;:gt&lt;/code&gt; , если первая дата позже второй, и &lt;code&gt;:lt&lt;/code&gt; ,если наоборот. Если две даты равны &lt;code&gt;:eq&lt;/code&gt; возвращается eq .</target>
        </trans-unit>
        <trans-unit id="097e4060b0440fe77549d8b66e79f7bb6eb97a62" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two NaiveDateTime are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">Возвращает &lt;code&gt;:gt&lt;/code&gt; , если первое позже, чем второе, и &lt;code&gt;:lt&lt;/code&gt; ,если наоборот. Если два NaiveDateTime равны &lt;code&gt;:eq&lt;/code&gt; возвращается eq .</target>
        </trans-unit>
        <trans-unit id="bd2d674dc710366cef94fba09471c28e71a138f9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first time is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two times are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">Возвращает &lt;code&gt;:gt&lt;/code&gt; , если первый раз позже, чем второй, и &lt;code&gt;:lt&lt;/code&gt; ,если наоборот. Если два раза равны &lt;code&gt;:eq&lt;/code&gt; возвращается eq .</target>
        </trans-unit>
        <trans-unit id="53c408a9bef219a6da93ad2df4fe55724f2cb32d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first datetime is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two datetimes are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">Возвращает &lt;code&gt;:gt&lt;/code&gt; , если первое datetime позже, чем второе, и &lt;code&gt;:lt&lt;/code&gt; наоборот. Если две даты равны &lt;code&gt;:eq&lt;/code&gt; возвращается eq .</target>
        </trans-unit>
        <trans-unit id="e433c31c34feefdf2a0b8160341592f2285d40c9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first version is greater than the second one, and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two versions are equal, &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">Возвращает &lt;code&gt;:gt&lt;/code&gt; , если первая версия старше второй, и &lt;code&gt;:lt&lt;/code&gt; наоборот. Если две версии равны, возвращается &lt;code&gt;:eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49f62de8f752ac017916b11e0d5b0e6dfb4ee428" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if so, otherwise raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; если это так, в противном случае возникает &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="511e783cd04e635de8fd03daca4897ee670c34df" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if so, otherwise raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; если это так, иначе вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c527276d77f46398aba41c7763a178e857f1629" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха, &lt;code&gt;{:error, reason}&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="84d6f7930e56db40dca6afbc716ff10cc17e68c7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support hard links, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха, &lt;code&gt;{:error, reason}&lt;/code&gt; противном случае. Если операционная система не поддерживает жесткие ссылки, возвращает &lt;code&gt;{:error, :enotsup}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a9014518965fa93cf5189e6ffe93f29bdec10a9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support symlinks, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха, &lt;code&gt;{:error, reason}&lt;/code&gt; противном случае. Если операционная система не поддерживает символические ссылки, возвращает &lt;code&gt;{:error, :enotsup}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4bfe0e95851ad3e1857f64f97c1d1fb4f5d47b8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха или &lt;code&gt;{:error, reason}&lt;/code&gt; случае ошибки.</target>
        </trans-unit>
        <trans-unit id="8084f7f8c4483c73958f54a0f48dadd5344d6c20" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs. It returns &lt;code&gt;{:error, :eexist}&lt;/code&gt; if the directory is not empty.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; случае успеха или &lt;code&gt;{:error, reason}&lt;/code&gt; случае ошибки. Он возвращает &lt;code&gt;{:error, :eexist}&lt;/code&gt; если каталог не пуст.</target>
        </trans-unit>
        <trans-unit id="ab0c374d46ad2b15399e120024adf6936c21f68c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if there is such breakpoint ID. &lt;code&gt;:not_found&lt;/code&gt; otherwise.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; если есть такой ID точки останова. &lt;code&gt;:not_found&lt;/code&gt; иначе.</target>
        </trans-unit>
        <trans-unit id="3e6eac431d9ebe34612817b0b267721c1695b386" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; в случае успеха, &lt;code&gt;{:error, reason}&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="fccad904de868f3ee196d9c9da31a4d3a418edcf" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; on success, or &lt;code&gt;{:error, reason}&lt;/code&gt; on failure.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; в случае успеха или &lt;code&gt;{:error, reason}&lt;/code&gt; в случае неудачи.</target>
        </trans-unit>
        <trans-unit id="4edb5e74e876c5531ce730345abbd7fb3d428f67" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; or an &lt;code&gt;{:error, reason}&lt;/code&gt; tuple.</source>
          <target state="translated">Возвращает &lt;code&gt;:ok&lt;/code&gt; или кортеж &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
